
Voltron_0.8_btonly.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000287d4  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00008640  08028974  08028974  00038974  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08030fb4  08030fb4  00050110  2**0
                  CONTENTS
  4 .ARM          00000008  08030fb4  08030fb4  00040fb4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08030fbc  08030fbc  00050110  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08030fbc  08030fbc  00040fbc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08030fc0  08030fc0  00040fc0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000110  20000000  08030fc4  00050000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000a620  20000110  080310d4  00050110  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  2000a730  080310d4  0005a730  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00050110  2**0
                  CONTENTS, READONLY
 12 .debug_info   0006c4ad  00000000  00000000  00050140  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000a501  00000000  00000000  000bc5ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000045b0  00000000  00000000  000c6af0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00004508  00000000  00000000  000cb0a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  0002eb03  00000000  00000000  000cf5a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   0003c6c7  00000000  00000000  000fe0ab  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    000e11e7  00000000  00000000  0013a772  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  0021b959  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00012f58  00000000  00000000  0021b9d4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	20000110 	.word	0x20000110
 80001bc:	00000000 	.word	0x00000000
 80001c0:	0802895c 	.word	0x0802895c

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000114 	.word	0x20000114
 80001dc:	0802895c 	.word	0x0802895c

080001e0 <strlen>:
 80001e0:	4603      	mov	r3, r0
 80001e2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001e6:	2a00      	cmp	r2, #0
 80001e8:	d1fb      	bne.n	80001e2 <strlen+0x2>
 80001ea:	1a18      	subs	r0, r3, r0
 80001ec:	3801      	subs	r0, #1
 80001ee:	4770      	bx	lr

080001f0 <memchr>:
 80001f0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80001f4:	2a10      	cmp	r2, #16
 80001f6:	db2b      	blt.n	8000250 <memchr+0x60>
 80001f8:	f010 0f07 	tst.w	r0, #7
 80001fc:	d008      	beq.n	8000210 <memchr+0x20>
 80001fe:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000202:	3a01      	subs	r2, #1
 8000204:	428b      	cmp	r3, r1
 8000206:	d02d      	beq.n	8000264 <memchr+0x74>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	b342      	cbz	r2, 8000260 <memchr+0x70>
 800020e:	d1f6      	bne.n	80001fe <memchr+0xe>
 8000210:	b4f0      	push	{r4, r5, r6, r7}
 8000212:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000216:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800021a:	f022 0407 	bic.w	r4, r2, #7
 800021e:	f07f 0700 	mvns.w	r7, #0
 8000222:	2300      	movs	r3, #0
 8000224:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000228:	3c08      	subs	r4, #8
 800022a:	ea85 0501 	eor.w	r5, r5, r1
 800022e:	ea86 0601 	eor.w	r6, r6, r1
 8000232:	fa85 f547 	uadd8	r5, r5, r7
 8000236:	faa3 f587 	sel	r5, r3, r7
 800023a:	fa86 f647 	uadd8	r6, r6, r7
 800023e:	faa5 f687 	sel	r6, r5, r7
 8000242:	b98e      	cbnz	r6, 8000268 <memchr+0x78>
 8000244:	d1ee      	bne.n	8000224 <memchr+0x34>
 8000246:	bcf0      	pop	{r4, r5, r6, r7}
 8000248:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800024c:	f002 0207 	and.w	r2, r2, #7
 8000250:	b132      	cbz	r2, 8000260 <memchr+0x70>
 8000252:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000256:	3a01      	subs	r2, #1
 8000258:	ea83 0301 	eor.w	r3, r3, r1
 800025c:	b113      	cbz	r3, 8000264 <memchr+0x74>
 800025e:	d1f8      	bne.n	8000252 <memchr+0x62>
 8000260:	2000      	movs	r0, #0
 8000262:	4770      	bx	lr
 8000264:	3801      	subs	r0, #1
 8000266:	4770      	bx	lr
 8000268:	2d00      	cmp	r5, #0
 800026a:	bf06      	itte	eq
 800026c:	4635      	moveq	r5, r6
 800026e:	3803      	subeq	r0, #3
 8000270:	3807      	subne	r0, #7
 8000272:	f015 0f01 	tst.w	r5, #1
 8000276:	d107      	bne.n	8000288 <memchr+0x98>
 8000278:	3001      	adds	r0, #1
 800027a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800027e:	bf02      	ittt	eq
 8000280:	3001      	addeq	r0, #1
 8000282:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000286:	3001      	addeq	r0, #1
 8000288:	bcf0      	pop	{r4, r5, r6, r7}
 800028a:	3801      	subs	r0, #1
 800028c:	4770      	bx	lr
 800028e:	bf00      	nop

08000290 <__aeabi_uldivmod>:
 8000290:	b953      	cbnz	r3, 80002a8 <__aeabi_uldivmod+0x18>
 8000292:	b94a      	cbnz	r2, 80002a8 <__aeabi_uldivmod+0x18>
 8000294:	2900      	cmp	r1, #0
 8000296:	bf08      	it	eq
 8000298:	2800      	cmpeq	r0, #0
 800029a:	bf1c      	itt	ne
 800029c:	f04f 31ff 	movne.w	r1, #4294967295
 80002a0:	f04f 30ff 	movne.w	r0, #4294967295
 80002a4:	f000 b972 	b.w	800058c <__aeabi_idiv0>
 80002a8:	f1ad 0c08 	sub.w	ip, sp, #8
 80002ac:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002b0:	f000 f806 	bl	80002c0 <__udivmoddi4>
 80002b4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002b8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002bc:	b004      	add	sp, #16
 80002be:	4770      	bx	lr

080002c0 <__udivmoddi4>:
 80002c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002c4:	9e08      	ldr	r6, [sp, #32]
 80002c6:	4604      	mov	r4, r0
 80002c8:	4688      	mov	r8, r1
 80002ca:	2b00      	cmp	r3, #0
 80002cc:	d14b      	bne.n	8000366 <__udivmoddi4+0xa6>
 80002ce:	428a      	cmp	r2, r1
 80002d0:	4615      	mov	r5, r2
 80002d2:	d967      	bls.n	80003a4 <__udivmoddi4+0xe4>
 80002d4:	fab2 f282 	clz	r2, r2
 80002d8:	b14a      	cbz	r2, 80002ee <__udivmoddi4+0x2e>
 80002da:	f1c2 0720 	rsb	r7, r2, #32
 80002de:	fa01 f302 	lsl.w	r3, r1, r2
 80002e2:	fa20 f707 	lsr.w	r7, r0, r7
 80002e6:	4095      	lsls	r5, r2
 80002e8:	ea47 0803 	orr.w	r8, r7, r3
 80002ec:	4094      	lsls	r4, r2
 80002ee:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80002f2:	0c23      	lsrs	r3, r4, #16
 80002f4:	fbb8 f7fe 	udiv	r7, r8, lr
 80002f8:	fa1f fc85 	uxth.w	ip, r5
 80002fc:	fb0e 8817 	mls	r8, lr, r7, r8
 8000300:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000304:	fb07 f10c 	mul.w	r1, r7, ip
 8000308:	4299      	cmp	r1, r3
 800030a:	d909      	bls.n	8000320 <__udivmoddi4+0x60>
 800030c:	18eb      	adds	r3, r5, r3
 800030e:	f107 30ff 	add.w	r0, r7, #4294967295
 8000312:	f080 811b 	bcs.w	800054c <__udivmoddi4+0x28c>
 8000316:	4299      	cmp	r1, r3
 8000318:	f240 8118 	bls.w	800054c <__udivmoddi4+0x28c>
 800031c:	3f02      	subs	r7, #2
 800031e:	442b      	add	r3, r5
 8000320:	1a5b      	subs	r3, r3, r1
 8000322:	b2a4      	uxth	r4, r4
 8000324:	fbb3 f0fe 	udiv	r0, r3, lr
 8000328:	fb0e 3310 	mls	r3, lr, r0, r3
 800032c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000330:	fb00 fc0c 	mul.w	ip, r0, ip
 8000334:	45a4      	cmp	ip, r4
 8000336:	d909      	bls.n	800034c <__udivmoddi4+0x8c>
 8000338:	192c      	adds	r4, r5, r4
 800033a:	f100 33ff 	add.w	r3, r0, #4294967295
 800033e:	f080 8107 	bcs.w	8000550 <__udivmoddi4+0x290>
 8000342:	45a4      	cmp	ip, r4
 8000344:	f240 8104 	bls.w	8000550 <__udivmoddi4+0x290>
 8000348:	3802      	subs	r0, #2
 800034a:	442c      	add	r4, r5
 800034c:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8000350:	eba4 040c 	sub.w	r4, r4, ip
 8000354:	2700      	movs	r7, #0
 8000356:	b11e      	cbz	r6, 8000360 <__udivmoddi4+0xa0>
 8000358:	40d4      	lsrs	r4, r2
 800035a:	2300      	movs	r3, #0
 800035c:	e9c6 4300 	strd	r4, r3, [r6]
 8000360:	4639      	mov	r1, r7
 8000362:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000366:	428b      	cmp	r3, r1
 8000368:	d909      	bls.n	800037e <__udivmoddi4+0xbe>
 800036a:	2e00      	cmp	r6, #0
 800036c:	f000 80eb 	beq.w	8000546 <__udivmoddi4+0x286>
 8000370:	2700      	movs	r7, #0
 8000372:	e9c6 0100 	strd	r0, r1, [r6]
 8000376:	4638      	mov	r0, r7
 8000378:	4639      	mov	r1, r7
 800037a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800037e:	fab3 f783 	clz	r7, r3
 8000382:	2f00      	cmp	r7, #0
 8000384:	d147      	bne.n	8000416 <__udivmoddi4+0x156>
 8000386:	428b      	cmp	r3, r1
 8000388:	d302      	bcc.n	8000390 <__udivmoddi4+0xd0>
 800038a:	4282      	cmp	r2, r0
 800038c:	f200 80fa 	bhi.w	8000584 <__udivmoddi4+0x2c4>
 8000390:	1a84      	subs	r4, r0, r2
 8000392:	eb61 0303 	sbc.w	r3, r1, r3
 8000396:	2001      	movs	r0, #1
 8000398:	4698      	mov	r8, r3
 800039a:	2e00      	cmp	r6, #0
 800039c:	d0e0      	beq.n	8000360 <__udivmoddi4+0xa0>
 800039e:	e9c6 4800 	strd	r4, r8, [r6]
 80003a2:	e7dd      	b.n	8000360 <__udivmoddi4+0xa0>
 80003a4:	b902      	cbnz	r2, 80003a8 <__udivmoddi4+0xe8>
 80003a6:	deff      	udf	#255	; 0xff
 80003a8:	fab2 f282 	clz	r2, r2
 80003ac:	2a00      	cmp	r2, #0
 80003ae:	f040 808f 	bne.w	80004d0 <__udivmoddi4+0x210>
 80003b2:	1b49      	subs	r1, r1, r5
 80003b4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80003b8:	fa1f f885 	uxth.w	r8, r5
 80003bc:	2701      	movs	r7, #1
 80003be:	fbb1 fcfe 	udiv	ip, r1, lr
 80003c2:	0c23      	lsrs	r3, r4, #16
 80003c4:	fb0e 111c 	mls	r1, lr, ip, r1
 80003c8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80003cc:	fb08 f10c 	mul.w	r1, r8, ip
 80003d0:	4299      	cmp	r1, r3
 80003d2:	d907      	bls.n	80003e4 <__udivmoddi4+0x124>
 80003d4:	18eb      	adds	r3, r5, r3
 80003d6:	f10c 30ff 	add.w	r0, ip, #4294967295
 80003da:	d202      	bcs.n	80003e2 <__udivmoddi4+0x122>
 80003dc:	4299      	cmp	r1, r3
 80003de:	f200 80cd 	bhi.w	800057c <__udivmoddi4+0x2bc>
 80003e2:	4684      	mov	ip, r0
 80003e4:	1a59      	subs	r1, r3, r1
 80003e6:	b2a3      	uxth	r3, r4
 80003e8:	fbb1 f0fe 	udiv	r0, r1, lr
 80003ec:	fb0e 1410 	mls	r4, lr, r0, r1
 80003f0:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 80003f4:	fb08 f800 	mul.w	r8, r8, r0
 80003f8:	45a0      	cmp	r8, r4
 80003fa:	d907      	bls.n	800040c <__udivmoddi4+0x14c>
 80003fc:	192c      	adds	r4, r5, r4
 80003fe:	f100 33ff 	add.w	r3, r0, #4294967295
 8000402:	d202      	bcs.n	800040a <__udivmoddi4+0x14a>
 8000404:	45a0      	cmp	r8, r4
 8000406:	f200 80b6 	bhi.w	8000576 <__udivmoddi4+0x2b6>
 800040a:	4618      	mov	r0, r3
 800040c:	eba4 0408 	sub.w	r4, r4, r8
 8000410:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000414:	e79f      	b.n	8000356 <__udivmoddi4+0x96>
 8000416:	f1c7 0c20 	rsb	ip, r7, #32
 800041a:	40bb      	lsls	r3, r7
 800041c:	fa22 fe0c 	lsr.w	lr, r2, ip
 8000420:	ea4e 0e03 	orr.w	lr, lr, r3
 8000424:	fa01 f407 	lsl.w	r4, r1, r7
 8000428:	fa20 f50c 	lsr.w	r5, r0, ip
 800042c:	fa21 f30c 	lsr.w	r3, r1, ip
 8000430:	ea4f 481e 	mov.w	r8, lr, lsr #16
 8000434:	4325      	orrs	r5, r4
 8000436:	fbb3 f9f8 	udiv	r9, r3, r8
 800043a:	0c2c      	lsrs	r4, r5, #16
 800043c:	fb08 3319 	mls	r3, r8, r9, r3
 8000440:	fa1f fa8e 	uxth.w	sl, lr
 8000444:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8000448:	fb09 f40a 	mul.w	r4, r9, sl
 800044c:	429c      	cmp	r4, r3
 800044e:	fa02 f207 	lsl.w	r2, r2, r7
 8000452:	fa00 f107 	lsl.w	r1, r0, r7
 8000456:	d90b      	bls.n	8000470 <__udivmoddi4+0x1b0>
 8000458:	eb1e 0303 	adds.w	r3, lr, r3
 800045c:	f109 30ff 	add.w	r0, r9, #4294967295
 8000460:	f080 8087 	bcs.w	8000572 <__udivmoddi4+0x2b2>
 8000464:	429c      	cmp	r4, r3
 8000466:	f240 8084 	bls.w	8000572 <__udivmoddi4+0x2b2>
 800046a:	f1a9 0902 	sub.w	r9, r9, #2
 800046e:	4473      	add	r3, lr
 8000470:	1b1b      	subs	r3, r3, r4
 8000472:	b2ad      	uxth	r5, r5
 8000474:	fbb3 f0f8 	udiv	r0, r3, r8
 8000478:	fb08 3310 	mls	r3, r8, r0, r3
 800047c:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8000480:	fb00 fa0a 	mul.w	sl, r0, sl
 8000484:	45a2      	cmp	sl, r4
 8000486:	d908      	bls.n	800049a <__udivmoddi4+0x1da>
 8000488:	eb1e 0404 	adds.w	r4, lr, r4
 800048c:	f100 33ff 	add.w	r3, r0, #4294967295
 8000490:	d26b      	bcs.n	800056a <__udivmoddi4+0x2aa>
 8000492:	45a2      	cmp	sl, r4
 8000494:	d969      	bls.n	800056a <__udivmoddi4+0x2aa>
 8000496:	3802      	subs	r0, #2
 8000498:	4474      	add	r4, lr
 800049a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800049e:	fba0 8902 	umull	r8, r9, r0, r2
 80004a2:	eba4 040a 	sub.w	r4, r4, sl
 80004a6:	454c      	cmp	r4, r9
 80004a8:	46c2      	mov	sl, r8
 80004aa:	464b      	mov	r3, r9
 80004ac:	d354      	bcc.n	8000558 <__udivmoddi4+0x298>
 80004ae:	d051      	beq.n	8000554 <__udivmoddi4+0x294>
 80004b0:	2e00      	cmp	r6, #0
 80004b2:	d069      	beq.n	8000588 <__udivmoddi4+0x2c8>
 80004b4:	ebb1 050a 	subs.w	r5, r1, sl
 80004b8:	eb64 0403 	sbc.w	r4, r4, r3
 80004bc:	fa04 fc0c 	lsl.w	ip, r4, ip
 80004c0:	40fd      	lsrs	r5, r7
 80004c2:	40fc      	lsrs	r4, r7
 80004c4:	ea4c 0505 	orr.w	r5, ip, r5
 80004c8:	e9c6 5400 	strd	r5, r4, [r6]
 80004cc:	2700      	movs	r7, #0
 80004ce:	e747      	b.n	8000360 <__udivmoddi4+0xa0>
 80004d0:	f1c2 0320 	rsb	r3, r2, #32
 80004d4:	fa20 f703 	lsr.w	r7, r0, r3
 80004d8:	4095      	lsls	r5, r2
 80004da:	fa01 f002 	lsl.w	r0, r1, r2
 80004de:	fa21 f303 	lsr.w	r3, r1, r3
 80004e2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80004e6:	4338      	orrs	r0, r7
 80004e8:	0c01      	lsrs	r1, r0, #16
 80004ea:	fbb3 f7fe 	udiv	r7, r3, lr
 80004ee:	fa1f f885 	uxth.w	r8, r5
 80004f2:	fb0e 3317 	mls	r3, lr, r7, r3
 80004f6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80004fa:	fb07 f308 	mul.w	r3, r7, r8
 80004fe:	428b      	cmp	r3, r1
 8000500:	fa04 f402 	lsl.w	r4, r4, r2
 8000504:	d907      	bls.n	8000516 <__udivmoddi4+0x256>
 8000506:	1869      	adds	r1, r5, r1
 8000508:	f107 3cff 	add.w	ip, r7, #4294967295
 800050c:	d22f      	bcs.n	800056e <__udivmoddi4+0x2ae>
 800050e:	428b      	cmp	r3, r1
 8000510:	d92d      	bls.n	800056e <__udivmoddi4+0x2ae>
 8000512:	3f02      	subs	r7, #2
 8000514:	4429      	add	r1, r5
 8000516:	1acb      	subs	r3, r1, r3
 8000518:	b281      	uxth	r1, r0
 800051a:	fbb3 f0fe 	udiv	r0, r3, lr
 800051e:	fb0e 3310 	mls	r3, lr, r0, r3
 8000522:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000526:	fb00 f308 	mul.w	r3, r0, r8
 800052a:	428b      	cmp	r3, r1
 800052c:	d907      	bls.n	800053e <__udivmoddi4+0x27e>
 800052e:	1869      	adds	r1, r5, r1
 8000530:	f100 3cff 	add.w	ip, r0, #4294967295
 8000534:	d217      	bcs.n	8000566 <__udivmoddi4+0x2a6>
 8000536:	428b      	cmp	r3, r1
 8000538:	d915      	bls.n	8000566 <__udivmoddi4+0x2a6>
 800053a:	3802      	subs	r0, #2
 800053c:	4429      	add	r1, r5
 800053e:	1ac9      	subs	r1, r1, r3
 8000540:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 8000544:	e73b      	b.n	80003be <__udivmoddi4+0xfe>
 8000546:	4637      	mov	r7, r6
 8000548:	4630      	mov	r0, r6
 800054a:	e709      	b.n	8000360 <__udivmoddi4+0xa0>
 800054c:	4607      	mov	r7, r0
 800054e:	e6e7      	b.n	8000320 <__udivmoddi4+0x60>
 8000550:	4618      	mov	r0, r3
 8000552:	e6fb      	b.n	800034c <__udivmoddi4+0x8c>
 8000554:	4541      	cmp	r1, r8
 8000556:	d2ab      	bcs.n	80004b0 <__udivmoddi4+0x1f0>
 8000558:	ebb8 0a02 	subs.w	sl, r8, r2
 800055c:	eb69 020e 	sbc.w	r2, r9, lr
 8000560:	3801      	subs	r0, #1
 8000562:	4613      	mov	r3, r2
 8000564:	e7a4      	b.n	80004b0 <__udivmoddi4+0x1f0>
 8000566:	4660      	mov	r0, ip
 8000568:	e7e9      	b.n	800053e <__udivmoddi4+0x27e>
 800056a:	4618      	mov	r0, r3
 800056c:	e795      	b.n	800049a <__udivmoddi4+0x1da>
 800056e:	4667      	mov	r7, ip
 8000570:	e7d1      	b.n	8000516 <__udivmoddi4+0x256>
 8000572:	4681      	mov	r9, r0
 8000574:	e77c      	b.n	8000470 <__udivmoddi4+0x1b0>
 8000576:	3802      	subs	r0, #2
 8000578:	442c      	add	r4, r5
 800057a:	e747      	b.n	800040c <__udivmoddi4+0x14c>
 800057c:	f1ac 0c02 	sub.w	ip, ip, #2
 8000580:	442b      	add	r3, r5
 8000582:	e72f      	b.n	80003e4 <__udivmoddi4+0x124>
 8000584:	4638      	mov	r0, r7
 8000586:	e708      	b.n	800039a <__udivmoddi4+0xda>
 8000588:	4637      	mov	r7, r6
 800058a:	e6e9      	b.n	8000360 <__udivmoddi4+0xa0>

0800058c <__aeabi_idiv0>:
 800058c:	4770      	bx	lr
 800058e:	bf00      	nop

08000590 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 8000590:	b580      	push	{r7, lr}
 8000592:	b082      	sub	sp, #8
 8000594:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 8000596:	2300      	movs	r3, #0
 8000598:	607b      	str	r3, [r7, #4]
 800059a:	4b10      	ldr	r3, [pc, #64]	; (80005dc <MX_DMA_Init+0x4c>)
 800059c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800059e:	4a0f      	ldr	r2, [pc, #60]	; (80005dc <MX_DMA_Init+0x4c>)
 80005a0:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80005a4:	6313      	str	r3, [r2, #48]	; 0x30
 80005a6:	4b0d      	ldr	r3, [pc, #52]	; (80005dc <MX_DMA_Init+0x4c>)
 80005a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80005aa:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80005ae:	607b      	str	r3, [r7, #4]
 80005b0:	687b      	ldr	r3, [r7, #4]

  /* DMA interrupt init */
  /* DMA2_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0);
 80005b2:	2200      	movs	r2, #0
 80005b4:	2100      	movs	r1, #0
 80005b6:	203a      	movs	r0, #58	; 0x3a
 80005b8:	f001 fe46 	bl	8002248 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
 80005bc:	203a      	movs	r0, #58	; 0x3a
 80005be:	f001 fe5f 	bl	8002280 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream7_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 0);
 80005c2:	2200      	movs	r2, #0
 80005c4:	2100      	movs	r1, #0
 80005c6:	2046      	movs	r0, #70	; 0x46
 80005c8:	f001 fe3e 	bl	8002248 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);
 80005cc:	2046      	movs	r0, #70	; 0x46
 80005ce:	f001 fe57 	bl	8002280 <HAL_NVIC_EnableIRQ>

}
 80005d2:	bf00      	nop
 80005d4:	3708      	adds	r7, #8
 80005d6:	46bd      	mov	sp, r7
 80005d8:	bd80      	pop	{r7, pc}
 80005da:	bf00      	nop
 80005dc:	40023800 	.word	0x40023800

080005e0 <vApplicationIdleHook>:
void vApplicationIdleHook(void);
void vApplicationStackOverflowHook(xTaskHandle xTask, signed char *pcTaskName);

/* USER CODE BEGIN 2 */
__weak void vApplicationIdleHook( void )
{
 80005e0:	b480      	push	{r7}
 80005e2:	af00      	add	r7, sp, #0
   memory allocated by the kernel to any task that has since been deleted. */




}
 80005e4:	bf00      	nop
 80005e6:	46bd      	mov	sp, r7
 80005e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80005ec:	4770      	bx	lr

080005ee <vApplicationStackOverflowHook>:
/* USER CODE END 2 */

/* USER CODE BEGIN 4 */
__weak void vApplicationStackOverflowHook(xTaskHandle xTask, signed char *pcTaskName)
{
 80005ee:	b480      	push	{r7}
 80005f0:	b083      	sub	sp, #12
 80005f2:	af00      	add	r7, sp, #0
 80005f4:	6078      	str	r0, [r7, #4]
 80005f6:	6039      	str	r1, [r7, #0]
   /* Run time stack overflow checking is performed if
   configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2. This hook function is
   called if a stack overflow is detected. */

	while(1);
 80005f8:	e7fe      	b.n	80005f8 <vApplicationStackOverflowHook+0xa>

080005fa <vPortSuppressTicksAndSleep>:
}
/* USER CODE END 4 */

/* USER CODE BEGIN VPORT_SUPPORT_TICKS_AND_SLEEP */
__weak void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
{
 80005fa:	b480      	push	{r7}
 80005fc:	b083      	sub	sp, #12
 80005fe:	af00      	add	r7, sp, #0
 8000600:	6078      	str	r0, [r7, #4]
  // Generated when configUSE_TICKLESS_IDLE == 2.
  // Function called in tasks.c (in portTASK_FUNCTION).
  // TO BE COMPLETED or TO BE REPLACED by a user one, overriding that weak one.
}
 8000602:	bf00      	nop
 8000604:	370c      	adds	r7, #12
 8000606:	46bd      	mov	sp, r7
 8000608:	f85d 7b04 	ldr.w	r7, [sp], #4
 800060c:	4770      	bx	lr
	...

08000610 <MX_FREERTOS_Init>:
/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
 8000610:	b580      	push	{r7, lr}
 8000612:	af00      	add	r7, sp, #0
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of defaultTask */
  defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
 8000614:	4a0a      	ldr	r2, [pc, #40]	; (8000640 <MX_FREERTOS_Init+0x30>)
 8000616:	2100      	movs	r1, #0
 8000618:	480a      	ldr	r0, [pc, #40]	; (8000644 <MX_FREERTOS_Init+0x34>)
 800061a:	f007 f9e1 	bl	80079e0 <osThreadNew>
 800061e:	4602      	mov	r2, r0
 8000620:	4b09      	ldr	r3, [pc, #36]	; (8000648 <MX_FREERTOS_Init+0x38>)
 8000622:	601a      	str	r2, [r3, #0]

  /* USER CODE BEGIN RTOS_THREADS */
  //Stop default task
  osThreadSuspend(defaultTaskHandle);
 8000624:	4b08      	ldr	r3, [pc, #32]	; (8000648 <MX_FREERTOS_Init+0x38>)
 8000626:	681b      	ldr	r3, [r3, #0]
 8000628:	4618      	mov	r0, r3
 800062a:	f007 fa7f 	bl	8007b2c <osThreadSuspend>
  osThreadTerminate(defaultTaskHandle);
 800062e:	4b06      	ldr	r3, [pc, #24]	; (8000648 <MX_FREERTOS_Init+0x38>)
 8000630:	681b      	ldr	r3, [r3, #0]
 8000632:	4618      	mov	r0, r3
 8000634:	f007 faae 	bl	8007b94 <osThreadTerminate>

  port_main();
 8000638:	f001 fc94 	bl	8001f64 <port_main>
  //Start State Machine
  //rtos_createThread(&main_state.sm_handle, SM_RTOS_PRIORITY, SM_STACKSIZE, &stateMachineTask, "State Machine Task", (void *)&main_state);

  /* USER CODE END RTOS_THREADS */

}
 800063c:	bf00      	nop
 800063e:	bd80      	pop	{r7, pc}
 8000640:	0802e600 	.word	0x0802e600
 8000644:	0800064d 	.word	0x0800064d
 8000648:	2000a394 	.word	0x2000a394

0800064c <StartDefaultTask>:
  * @param  argument: Not used 
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
__weak void StartDefaultTask(void *argument)
{
 800064c:	b580      	push	{r7, lr}
 800064e:	b082      	sub	sp, #8
 8000650:	af00      	add	r7, sp, #0
 8000652:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN StartDefaultTask */

  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
 8000654:	2001      	movs	r0, #1
 8000656:	f007 fadd 	bl	8007c14 <osDelay>
 800065a:	e7fb      	b.n	8000654 <StartDefaultTask+0x8>

0800065c <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 800065c:	b580      	push	{r7, lr}
 800065e:	b08a      	sub	sp, #40	; 0x28
 8000660:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000662:	f107 0314 	add.w	r3, r7, #20
 8000666:	2200      	movs	r2, #0
 8000668:	601a      	str	r2, [r3, #0]
 800066a:	605a      	str	r2, [r3, #4]
 800066c:	609a      	str	r2, [r3, #8]
 800066e:	60da      	str	r2, [r3, #12]
 8000670:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8000672:	2300      	movs	r3, #0
 8000674:	613b      	str	r3, [r7, #16]
 8000676:	4b4b      	ldr	r3, [pc, #300]	; (80007a4 <MX_GPIO_Init+0x148>)
 8000678:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800067a:	4a4a      	ldr	r2, [pc, #296]	; (80007a4 <MX_GPIO_Init+0x148>)
 800067c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000680:	6313      	str	r3, [r2, #48]	; 0x30
 8000682:	4b48      	ldr	r3, [pc, #288]	; (80007a4 <MX_GPIO_Init+0x148>)
 8000684:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000686:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800068a:	613b      	str	r3, [r7, #16]
 800068c:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800068e:	2300      	movs	r3, #0
 8000690:	60fb      	str	r3, [r7, #12]
 8000692:	4b44      	ldr	r3, [pc, #272]	; (80007a4 <MX_GPIO_Init+0x148>)
 8000694:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000696:	4a43      	ldr	r2, [pc, #268]	; (80007a4 <MX_GPIO_Init+0x148>)
 8000698:	f043 0301 	orr.w	r3, r3, #1
 800069c:	6313      	str	r3, [r2, #48]	; 0x30
 800069e:	4b41      	ldr	r3, [pc, #260]	; (80007a4 <MX_GPIO_Init+0x148>)
 80006a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80006a2:	f003 0301 	and.w	r3, r3, #1
 80006a6:	60fb      	str	r3, [r7, #12]
 80006a8:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80006aa:	2300      	movs	r3, #0
 80006ac:	60bb      	str	r3, [r7, #8]
 80006ae:	4b3d      	ldr	r3, [pc, #244]	; (80007a4 <MX_GPIO_Init+0x148>)
 80006b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80006b2:	4a3c      	ldr	r2, [pc, #240]	; (80007a4 <MX_GPIO_Init+0x148>)
 80006b4:	f043 0302 	orr.w	r3, r3, #2
 80006b8:	6313      	str	r3, [r2, #48]	; 0x30
 80006ba:	4b3a      	ldr	r3, [pc, #232]	; (80007a4 <MX_GPIO_Init+0x148>)
 80006bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80006be:	f003 0302 	and.w	r3, r3, #2
 80006c2:	60bb      	str	r3, [r7, #8]
 80006c4:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80006c6:	2300      	movs	r3, #0
 80006c8:	607b      	str	r3, [r7, #4]
 80006ca:	4b36      	ldr	r3, [pc, #216]	; (80007a4 <MX_GPIO_Init+0x148>)
 80006cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80006ce:	4a35      	ldr	r2, [pc, #212]	; (80007a4 <MX_GPIO_Init+0x148>)
 80006d0:	f043 0304 	orr.w	r3, r3, #4
 80006d4:	6313      	str	r3, [r2, #48]	; 0x30
 80006d6:	4b33      	ldr	r3, [pc, #204]	; (80007a4 <MX_GPIO_Init+0x148>)
 80006d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80006da:	f003 0304 	and.w	r3, r3, #4
 80006de:	607b      	str	r3, [r7, #4]
 80006e0:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(MEM_CS1_GPIO_Port, MEM_CS1_Pin, GPIO_PIN_SET);
 80006e2:	2201      	movs	r2, #1
 80006e4:	2110      	movs	r1, #16
 80006e6:	4830      	ldr	r0, [pc, #192]	; (80007a8 <MX_GPIO_Init+0x14c>)
 80006e8:	f002 fdde 	bl	80032a8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LSCNTRL_Pin|LS_EN_Pin|DSP_CS_Pin|C_CD_Pin 
 80006ec:	2200      	movs	r2, #0
 80006ee:	f241 7101 	movw	r1, #5889	; 0x1701
 80006f2:	482e      	ldr	r0, [pc, #184]	; (80007ac <MX_GPIO_Init+0x150>)
 80006f4:	f002 fdd8 	bl	80032a8 <HAL_GPIO_WritePin>
                          |EN_1V2_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(MEM_CS2_GPIO_Port, MEM_CS2_Pin, GPIO_PIN_SET);
 80006f8:	2201      	movs	r2, #1
 80006fa:	2104      	movs	r1, #4
 80006fc:	482b      	ldr	r0, [pc, #172]	; (80007ac <MX_GPIO_Init+0x150>)
 80006fe:	f002 fdd3 	bl	80032a8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(BT_NSHUTDOWN_GPIO_Port, BT_NSHUTDOWN_Pin, GPIO_PIN_RESET);
 8000702:	2200      	movs	r2, #0
 8000704:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000708:	4827      	ldr	r0, [pc, #156]	; (80007a8 <MX_GPIO_Init+0x14c>)
 800070a:	f002 fdcd 	bl	80032a8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = MEM_CS1_Pin;
 800070e:	2310      	movs	r3, #16
 8000710:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000712:	2301      	movs	r3, #1
 8000714:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000716:	2300      	movs	r3, #0
 8000718:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800071a:	2303      	movs	r3, #3
 800071c:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(MEM_CS1_GPIO_Port, &GPIO_InitStruct);
 800071e:	f107 0314 	add.w	r3, r7, #20
 8000722:	4619      	mov	r1, r3
 8000724:	4820      	ldr	r0, [pc, #128]	; (80007a8 <MX_GPIO_Init+0x14c>)
 8000726:	f002 fc3d 	bl	8002fa4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = LSCNTRL_Pin|LS_EN_Pin|C_CD_Pin|EN_1V2_Pin;
 800072a:	f240 7301 	movw	r3, #1793	; 0x701
 800072e:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000730:	2301      	movs	r3, #1
 8000732:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000734:	2300      	movs	r3, #0
 8000736:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000738:	2300      	movs	r3, #0
 800073a:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800073c:	f107 0314 	add.w	r3, r7, #20
 8000740:	4619      	mov	r1, r3
 8000742:	481a      	ldr	r0, [pc, #104]	; (80007ac <MX_GPIO_Init+0x150>)
 8000744:	f002 fc2e 	bl	8002fa4 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = PM_INT_Pin;
 8000748:	2302      	movs	r3, #2
 800074a:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800074c:	2300      	movs	r3, #0
 800074e:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000750:	2301      	movs	r3, #1
 8000752:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(PM_INT_GPIO_Port, &GPIO_InitStruct);
 8000754:	f107 0314 	add.w	r3, r7, #20
 8000758:	4619      	mov	r1, r3
 800075a:	4814      	ldr	r0, [pc, #80]	; (80007ac <MX_GPIO_Init+0x150>)
 800075c:	f002 fc22 	bl	8002fa4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin */
  GPIO_InitStruct.Pin = MEM_CS2_Pin|DSP_CS_Pin;
 8000760:	f241 0304 	movw	r3, #4100	; 0x1004
 8000764:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000766:	2301      	movs	r3, #1
 8000768:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800076a:	2300      	movs	r3, #0
 800076c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800076e:	2303      	movs	r3, #3
 8000770:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000772:	f107 0314 	add.w	r3, r7, #20
 8000776:	4619      	mov	r1, r3
 8000778:	480c      	ldr	r0, [pc, #48]	; (80007ac <MX_GPIO_Init+0x150>)
 800077a:	f002 fc13 	bl	8002fa4 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = BT_NSHUTDOWN_Pin;
 800077e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000782:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000784:	2301      	movs	r3, #1
 8000786:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000788:	2300      	movs	r3, #0
 800078a:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800078c:	2300      	movs	r3, #0
 800078e:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(BT_NSHUTDOWN_GPIO_Port, &GPIO_InitStruct);
 8000790:	f107 0314 	add.w	r3, r7, #20
 8000794:	4619      	mov	r1, r3
 8000796:	4804      	ldr	r0, [pc, #16]	; (80007a8 <MX_GPIO_Init+0x14c>)
 8000798:	f002 fc04 	bl	8002fa4 <HAL_GPIO_Init>

}
 800079c:	bf00      	nop
 800079e:	3728      	adds	r7, #40	; 0x28
 80007a0:	46bd      	mov	sp, r7
 80007a2:	bd80      	pop	{r7, pc}
 80007a4:	40023800 	.word	0x40023800
 80007a8:	40020000 	.word	0x40020000
 80007ac:	40020400 	.word	0x40020400

080007b0 <MX_I2C1_Init>:

I2C_HandleTypeDef hi2c1;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
 80007b0:	b580      	push	{r7, lr}
 80007b2:	af00      	add	r7, sp, #0

  hi2c1.Instance = I2C1;
 80007b4:	4b13      	ldr	r3, [pc, #76]	; (8000804 <MX_I2C1_Init+0x54>)
 80007b6:	4a14      	ldr	r2, [pc, #80]	; (8000808 <MX_I2C1_Init+0x58>)
 80007b8:	601a      	str	r2, [r3, #0]
  hi2c1.Init.ClockSpeed = 50000;
 80007ba:	4b12      	ldr	r3, [pc, #72]	; (8000804 <MX_I2C1_Init+0x54>)
 80007bc:	f24c 3250 	movw	r2, #50000	; 0xc350
 80007c0:	605a      	str	r2, [r3, #4]
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
 80007c2:	4b10      	ldr	r3, [pc, #64]	; (8000804 <MX_I2C1_Init+0x54>)
 80007c4:	2200      	movs	r2, #0
 80007c6:	609a      	str	r2, [r3, #8]
  hi2c1.Init.OwnAddress1 = 0;
 80007c8:	4b0e      	ldr	r3, [pc, #56]	; (8000804 <MX_I2C1_Init+0x54>)
 80007ca:	2200      	movs	r2, #0
 80007cc:	60da      	str	r2, [r3, #12]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80007ce:	4b0d      	ldr	r3, [pc, #52]	; (8000804 <MX_I2C1_Init+0x54>)
 80007d0:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80007d4:	611a      	str	r2, [r3, #16]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 80007d6:	4b0b      	ldr	r3, [pc, #44]	; (8000804 <MX_I2C1_Init+0x54>)
 80007d8:	2200      	movs	r2, #0
 80007da:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2 = 0;
 80007dc:	4b09      	ldr	r3, [pc, #36]	; (8000804 <MX_I2C1_Init+0x54>)
 80007de:	2200      	movs	r2, #0
 80007e0:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80007e2:	4b08      	ldr	r3, [pc, #32]	; (8000804 <MX_I2C1_Init+0x54>)
 80007e4:	2200      	movs	r2, #0
 80007e6:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 80007e8:	4b06      	ldr	r3, [pc, #24]	; (8000804 <MX_I2C1_Init+0x54>)
 80007ea:	2200      	movs	r2, #0
 80007ec:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 80007ee:	4805      	ldr	r0, [pc, #20]	; (8000804 <MX_I2C1_Init+0x54>)
 80007f0:	f002 fd8e 	bl	8003310 <HAL_I2C_Init>
 80007f4:	4603      	mov	r3, r0
 80007f6:	2b00      	cmp	r3, #0
 80007f8:	d001      	beq.n	80007fe <MX_I2C1_Init+0x4e>
  {
    Error_Handler();
 80007fa:	f000 f93d 	bl	8000a78 <Error_Handler>
  }

}
 80007fe:	bf00      	nop
 8000800:	bd80      	pop	{r7, pc}
 8000802:	bf00      	nop
 8000804:	2000a398 	.word	0x2000a398
 8000808:	40005400 	.word	0x40005400

0800080c <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 800080c:	b580      	push	{r7, lr}
 800080e:	b08a      	sub	sp, #40	; 0x28
 8000810:	af00      	add	r7, sp, #0
 8000812:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000814:	f107 0314 	add.w	r3, r7, #20
 8000818:	2200      	movs	r2, #0
 800081a:	601a      	str	r2, [r3, #0]
 800081c:	605a      	str	r2, [r3, #4]
 800081e:	609a      	str	r2, [r3, #8]
 8000820:	60da      	str	r2, [r3, #12]
 8000822:	611a      	str	r2, [r3, #16]
  if(i2cHandle->Instance==I2C1)
 8000824:	687b      	ldr	r3, [r7, #4]
 8000826:	681b      	ldr	r3, [r3, #0]
 8000828:	4a21      	ldr	r2, [pc, #132]	; (80008b0 <HAL_I2C_MspInit+0xa4>)
 800082a:	4293      	cmp	r3, r2
 800082c:	d13b      	bne.n	80008a6 <HAL_I2C_MspInit+0x9a>
  {
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */
  
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800082e:	2300      	movs	r3, #0
 8000830:	613b      	str	r3, [r7, #16]
 8000832:	4b20      	ldr	r3, [pc, #128]	; (80008b4 <HAL_I2C_MspInit+0xa8>)
 8000834:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000836:	4a1f      	ldr	r2, [pc, #124]	; (80008b4 <HAL_I2C_MspInit+0xa8>)
 8000838:	f043 0302 	orr.w	r3, r3, #2
 800083c:	6313      	str	r3, [r2, #48]	; 0x30
 800083e:	4b1d      	ldr	r3, [pc, #116]	; (80008b4 <HAL_I2C_MspInit+0xa8>)
 8000840:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000842:	f003 0302 	and.w	r3, r3, #2
 8000846:	613b      	str	r3, [r7, #16]
 8000848:	693b      	ldr	r3, [r7, #16]
    /**I2C1 GPIO Configuration    
    PB6     ------> I2C1_SCL
    PB7     ------> I2C1_SDA 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 800084a:	23c0      	movs	r3, #192	; 0xc0
 800084c:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800084e:	2312      	movs	r3, #18
 8000850:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000852:	2301      	movs	r3, #1
 8000854:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000856:	2303      	movs	r3, #3
 8000858:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 800085a:	2304      	movs	r3, #4
 800085c:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800085e:	f107 0314 	add.w	r3, r7, #20
 8000862:	4619      	mov	r1, r3
 8000864:	4814      	ldr	r0, [pc, #80]	; (80008b8 <HAL_I2C_MspInit+0xac>)
 8000866:	f002 fb9d 	bl	8002fa4 <HAL_GPIO_Init>

    /* I2C1 clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 800086a:	2300      	movs	r3, #0
 800086c:	60fb      	str	r3, [r7, #12]
 800086e:	4b11      	ldr	r3, [pc, #68]	; (80008b4 <HAL_I2C_MspInit+0xa8>)
 8000870:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000872:	4a10      	ldr	r2, [pc, #64]	; (80008b4 <HAL_I2C_MspInit+0xa8>)
 8000874:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8000878:	6413      	str	r3, [r2, #64]	; 0x40
 800087a:	4b0e      	ldr	r3, [pc, #56]	; (80008b4 <HAL_I2C_MspInit+0xa8>)
 800087c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800087e:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8000882:	60fb      	str	r3, [r7, #12]
 8000884:	68fb      	ldr	r3, [r7, #12]

    /* I2C1 interrupt Init */
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 5, 0);
 8000886:	2200      	movs	r2, #0
 8000888:	2105      	movs	r1, #5
 800088a:	201f      	movs	r0, #31
 800088c:	f001 fcdc 	bl	8002248 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
 8000890:	201f      	movs	r0, #31
 8000892:	f001 fcf5 	bl	8002280 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C1_ER_IRQn, 5, 0);
 8000896:	2200      	movs	r2, #0
 8000898:	2105      	movs	r1, #5
 800089a:	2020      	movs	r0, #32
 800089c:	f001 fcd4 	bl	8002248 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
 80008a0:	2020      	movs	r0, #32
 80008a2:	f001 fced 	bl	8002280 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
}
 80008a6:	bf00      	nop
 80008a8:	3728      	adds	r7, #40	; 0x28
 80008aa:	46bd      	mov	sp, r7
 80008ac:	bd80      	pop	{r7, pc}
 80008ae:	bf00      	nop
 80008b0:	40005400 	.word	0x40005400
 80008b4:	40023800 	.word	0x40023800
 80008b8:	40020400 	.word	0x40020400

080008bc <main>:
//    errno = EIO;
//    return -1;
//}

int main(void)
{
 80008bc:	b580      	push	{r7, lr}
 80008be:	b082      	sub	sp, #8
 80008c0:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80008c2:	f001 fbab 	bl	800201c <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 80008c6:	f000 f82f 	bl	8000928 <SystemClock_Config>

  /* USER CODE BEGIN SysInit */
  XTALClock_Config();		//Redundant in final build, but detaches output of Cube from code
 80008ca:	f000 f8b7 	bl	8000a3c <XTALClock_Config>
  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80008ce:	f7ff fec5 	bl	800065c <MX_GPIO_Init>
  MX_DMA_Init();
 80008d2:	f7ff fe5d 	bl	8000590 <MX_DMA_Init>
  MX_I2C1_Init();
 80008d6:	f7ff ff6b 	bl	80007b0 <MX_I2C1_Init>
  MX_SPI1_Init();
 80008da:	f000 f951 	bl	8000b80 <MX_SPI1_Init>
  MX_SPI2_Init();
 80008de:	f000 f985 	bl	8000bec <MX_SPI2_Init>
  //MX_IWDG_Init();
  MX_RTC_Init();
 80008e2:	f000 f8d1 	bl	8000a88 <MX_RTC_Init>
  MX_USART2_UART_Init();
 80008e6:	f000 fbef 	bl	80010c8 <MX_USART2_UART_Init>
  MX_USART1_UART_Init();
 80008ea:	f000 fc17 	bl	800111c <MX_USART1_UART_Init>
#else
  //HAL_UART_MspDeInit(&huart2);
#endif

  //Stop the default wake up timer
  HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);
 80008ee:	480b      	ldr	r0, [pc, #44]	; (800091c <main+0x60>)
 80008f0:	f005 fb65 	bl	8005fbe <HAL_RTCEx_DeactivateWakeUpTimer>

  	uint8_t *Msg = "Hello-LED";
 80008f4:	4b0a      	ldr	r3, [pc, #40]	; (8000920 <main+0x64>)
 80008f6:	607b      	str	r3, [r7, #4]
  	HAL_UART_Transmit(&huart2, Msg, strlen(Msg), 4000);
 80008f8:	6878      	ldr	r0, [r7, #4]
 80008fa:	f7ff fc71 	bl	80001e0 <strlen>
 80008fe:	4603      	mov	r3, r0
 8000900:	b29a      	uxth	r2, r3
 8000902:	f44f 637a 	mov.w	r3, #4000	; 0xfa0
 8000906:	6879      	ldr	r1, [r7, #4]
 8000908:	4806      	ldr	r0, [pc, #24]	; (8000924 <main+0x68>)
 800090a:	f005 ff94 	bl	8006836 <HAL_UART_Transmit>
  /* USER CODE END 2 */



  /* Init scheduler */
  osKernelInitialize();  /* Call init function for freertos objects (in freertos.c) */
 800090e:	f006 fffd 	bl	800790c <osKernelInitialize>
  MX_FREERTOS_Init();
 8000912:	f7ff fe7d 	bl	8000610 <MX_FREERTOS_Init>
  /* Start scheduler */
  osKernelStart();
 8000916:	f007 f82d 	bl	8007974 <osKernelStart>


  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 800091a:	e7fe      	b.n	800091a <main+0x5e>
 800091c:	2000a580 	.word	0x2000a580
 8000920:	08028980 	.word	0x08028980
 8000924:	2000a4e0 	.word	0x2000a4e0

08000928 <SystemClock_Config>:
//			HAL_Delay(1000);
//
//		}
//}
void SystemClock_Config(void)
{
 8000928:	b580      	push	{r7, lr}
 800092a:	b09a      	sub	sp, #104	; 0x68
 800092c:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800092e:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8000932:	2230      	movs	r2, #48	; 0x30
 8000934:	2100      	movs	r1, #0
 8000936:	4618      	mov	r0, r3
 8000938:	f027 f8c3 	bl	8027ac2 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800093c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000940:	2200      	movs	r2, #0
 8000942:	601a      	str	r2, [r3, #0]
 8000944:	605a      	str	r2, [r3, #4]
 8000946:	609a      	str	r2, [r3, #8]
 8000948:	60da      	str	r2, [r3, #12]
 800094a:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800094c:	f107 030c 	add.w	r3, r7, #12
 8000950:	2200      	movs	r2, #0
 8000952:	601a      	str	r2, [r3, #0]
 8000954:	605a      	str	r2, [r3, #4]
 8000956:	609a      	str	r2, [r3, #8]
 8000958:	60da      	str	r2, [r3, #12]
 800095a:	611a      	str	r2, [r3, #16]
 800095c:	615a      	str	r2, [r3, #20]

  /** Configure the main internal regulator output voltage 
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 800095e:	2300      	movs	r3, #0
 8000960:	60bb      	str	r3, [r7, #8]
 8000962:	4b34      	ldr	r3, [pc, #208]	; (8000a34 <SystemClock_Config+0x10c>)
 8000964:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000966:	4a33      	ldr	r2, [pc, #204]	; (8000a34 <SystemClock_Config+0x10c>)
 8000968:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800096c:	6413      	str	r3, [r2, #64]	; 0x40
 800096e:	4b31      	ldr	r3, [pc, #196]	; (8000a34 <SystemClock_Config+0x10c>)
 8000970:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000972:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000976:	60bb      	str	r3, [r7, #8]
 8000978:	68bb      	ldr	r3, [r7, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800097a:	2300      	movs	r3, #0
 800097c:	607b      	str	r3, [r7, #4]
 800097e:	4b2e      	ldr	r3, [pc, #184]	; (8000a38 <SystemClock_Config+0x110>)
 8000980:	681b      	ldr	r3, [r3, #0]
 8000982:	4a2d      	ldr	r2, [pc, #180]	; (8000a38 <SystemClock_Config+0x110>)
 8000984:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8000988:	6013      	str	r3, [r2, #0]
 800098a:	4b2b      	ldr	r3, [pc, #172]	; (8000a38 <SystemClock_Config+0x110>)
 800098c:	681b      	ldr	r3, [r3, #0]
 800098e:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8000992:	607b      	str	r3, [r7, #4]
 8000994:	687b      	ldr	r3, [r7, #4]
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8000996:	2309      	movs	r3, #9
 8000998:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800099a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800099e:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 80009a0:	2301      	movs	r3, #1
 80009a2:	64fb      	str	r3, [r7, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80009a4:	2302      	movs	r3, #2
 80009a6:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80009a8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80009ac:	657b      	str	r3, [r7, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLM = 8;
 80009ae:	2308      	movs	r3, #8
 80009b0:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLN = 192;
 80009b2:	23c0      	movs	r3, #192	; 0xc0
 80009b4:	65fb      	str	r3, [r7, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80009b6:	2302      	movs	r3, #2
 80009b8:	663b      	str	r3, [r7, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLQ = 4;
 80009ba:	2304      	movs	r3, #4
 80009bc:	667b      	str	r3, [r7, #100]	; 0x64
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80009be:	f107 0338 	add.w	r3, r7, #56	; 0x38
 80009c2:	4618      	mov	r0, r3
 80009c4:	f004 fa7c 	bl	8004ec0 <HAL_RCC_OscConfig>
 80009c8:	4603      	mov	r3, r0
 80009ca:	2b00      	cmp	r3, #0
 80009cc:	d001      	beq.n	80009d2 <SystemClock_Config+0xaa>
  {
    Error_Handler();
 80009ce:	f000 f853 	bl	8000a78 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80009d2:	230f      	movs	r3, #15
 80009d4:	627b      	str	r3, [r7, #36]	; 0x24
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80009d6:	2302      	movs	r3, #2
 80009d8:	62bb      	str	r3, [r7, #40]	; 0x28
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80009da:	2300      	movs	r3, #0
 80009dc:	62fb      	str	r3, [r7, #44]	; 0x2c
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 80009de:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80009e2:	633b      	str	r3, [r7, #48]	; 0x30
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80009e4:	2300      	movs	r3, #0
 80009e6:	637b      	str	r3, [r7, #52]	; 0x34

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 80009e8:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80009ec:	2105      	movs	r1, #5
 80009ee:	4618      	mov	r0, r3
 80009f0:	f004 fcd6 	bl	80053a0 <HAL_RCC_ClockConfig>
 80009f4:	4603      	mov	r3, r0
 80009f6:	2b00      	cmp	r3, #0
 80009f8:	d001      	beq.n	80009fe <SystemClock_Config+0xd6>
  {
    Error_Handler();
 80009fa:	f000 f83d 	bl	8000a78 <Error_Handler>
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2S|RCC_PERIPHCLK_RTC;
 80009fe:	2303      	movs	r3, #3
 8000a00:	60fb      	str	r3, [r7, #12]
  PeriphClkInitStruct.PLLI2S.PLLI2SN = 394;
 8000a02:	f44f 73c5 	mov.w	r3, #394	; 0x18a
 8000a06:	617b      	str	r3, [r7, #20]
  PeriphClkInitStruct.PLLI2S.PLLI2SM = 8;
 8000a08:	2308      	movs	r3, #8
 8000a0a:	613b      	str	r3, [r7, #16]
  PeriphClkInitStruct.PLLI2S.PLLI2SR = 4;
 8000a0c:	2304      	movs	r3, #4
 8000a0e:	61bb      	str	r3, [r7, #24]
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 8000a10:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a14:	61fb      	str	r3, [r7, #28]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8000a16:	f107 030c 	add.w	r3, r7, #12
 8000a1a:	4618      	mov	r0, r3
 8000a1c:	f004 fee4 	bl	80057e8 <HAL_RCCEx_PeriphCLKConfig>
 8000a20:	4603      	mov	r3, r0
 8000a22:	2b00      	cmp	r3, #0
 8000a24:	d001      	beq.n	8000a2a <SystemClock_Config+0x102>
  {
    Error_Handler();
 8000a26:	f000 f827 	bl	8000a78 <Error_Handler>
  }
}
 8000a2a:	bf00      	nop
 8000a2c:	3768      	adds	r7, #104	; 0x68
 8000a2e:	46bd      	mov	sp, r7
 8000a30:	bd80      	pop	{r7, pc}
 8000a32:	bf00      	nop
 8000a34:	40023800 	.word	0x40023800
 8000a38:	40007000 	.word	0x40007000

08000a3c <XTALClock_Config>:
/**
  * @brief Crystal Clock Configuration
  * @retval None
  */
void XTALClock_Config(void)
{
 8000a3c:	b480      	push	{r7}
 8000a3e:	b09b      	sub	sp, #108	; 0x6c
 8000a40:	af00      	add	r7, sp, #0
	PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
	{
	Error_Handler();
	}
}
 8000a42:	376c      	adds	r7, #108	; 0x6c
 8000a44:	46bd      	mov	sp, r7
 8000a46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a4a:	4770      	bx	lr

08000a4c <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8000a4c:	b580      	push	{r7, lr}
 8000a4e:	b082      	sub	sp, #8
 8000a50:	af00      	add	r7, sp, #0
 8000a52:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */
	//Reset IWDG
	HAL_IWDG_Refresh(&hiwdg);
 8000a54:	4806      	ldr	r0, [pc, #24]	; (8000a70 <HAL_TIM_PeriodElapsedCallback+0x24>)
 8000a56:	f004 fa22 	bl	8004e9e <HAL_IWDG_Refresh>


  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 8000a5a:	687b      	ldr	r3, [r7, #4]
 8000a5c:	681b      	ldr	r3, [r3, #0]
 8000a5e:	4a05      	ldr	r2, [pc, #20]	; (8000a74 <HAL_TIM_PeriodElapsedCallback+0x28>)
 8000a60:	4293      	cmp	r3, r2
 8000a62:	d101      	bne.n	8000a68 <HAL_TIM_PeriodElapsedCallback+0x1c>
    HAL_IncTick();
 8000a64:	f001 faf6 	bl	8002054 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 8000a68:	bf00      	nop
 8000a6a:	3708      	adds	r7, #8
 8000a6c:	46bd      	mov	sp, r7
 8000a6e:	bd80      	pop	{r7, pc}
 8000a70:	2000a434 	.word	0x2000a434
 8000a74:	40010000 	.word	0x40010000

08000a78 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8000a78:	b480      	push	{r7}
 8000a7a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 8000a7c:	bf00      	nop
 8000a7e:	46bd      	mov	sp, r7
 8000a80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a84:	4770      	bx	lr
	...

08000a88 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 8000a88:	b580      	push	{r7, lr}
 8000a8a:	b086      	sub	sp, #24
 8000a8c:	af00      	add	r7, sp, #0
  RTC_TimeTypeDef sTime = {0};
 8000a8e:	1d3b      	adds	r3, r7, #4
 8000a90:	2200      	movs	r2, #0
 8000a92:	601a      	str	r2, [r3, #0]
 8000a94:	605a      	str	r2, [r3, #4]
 8000a96:	609a      	str	r2, [r3, #8]
 8000a98:	60da      	str	r2, [r3, #12]
 8000a9a:	611a      	str	r2, [r3, #16]
  RTC_DateTypeDef sDate = {0};
 8000a9c:	2300      	movs	r3, #0
 8000a9e:	603b      	str	r3, [r7, #0]

  /** Initialize RTC Only 
  */
  hrtc.Instance = RTC;
 8000aa0:	4b2a      	ldr	r3, [pc, #168]	; (8000b4c <MX_RTC_Init+0xc4>)
 8000aa2:	4a2b      	ldr	r2, [pc, #172]	; (8000b50 <MX_RTC_Init+0xc8>)
 8000aa4:	601a      	str	r2, [r3, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 8000aa6:	4b29      	ldr	r3, [pc, #164]	; (8000b4c <MX_RTC_Init+0xc4>)
 8000aa8:	2200      	movs	r2, #0
 8000aaa:	605a      	str	r2, [r3, #4]
  hrtc.Init.AsynchPrediv = 31;
 8000aac:	4b27      	ldr	r3, [pc, #156]	; (8000b4c <MX_RTC_Init+0xc4>)
 8000aae:	221f      	movs	r2, #31
 8000ab0:	609a      	str	r2, [r3, #8]
  hrtc.Init.SynchPrediv = 10000;
 8000ab2:	4b26      	ldr	r3, [pc, #152]	; (8000b4c <MX_RTC_Init+0xc4>)
 8000ab4:	f242 7210 	movw	r2, #10000	; 0x2710
 8000ab8:	60da      	str	r2, [r3, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 8000aba:	4b24      	ldr	r3, [pc, #144]	; (8000b4c <MX_RTC_Init+0xc4>)
 8000abc:	2200      	movs	r2, #0
 8000abe:	611a      	str	r2, [r3, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 8000ac0:	4b22      	ldr	r3, [pc, #136]	; (8000b4c <MX_RTC_Init+0xc4>)
 8000ac2:	2200      	movs	r2, #0
 8000ac4:	615a      	str	r2, [r3, #20]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8000ac6:	4b21      	ldr	r3, [pc, #132]	; (8000b4c <MX_RTC_Init+0xc4>)
 8000ac8:	2200      	movs	r2, #0
 8000aca:	619a      	str	r2, [r3, #24]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8000acc:	481f      	ldr	r0, [pc, #124]	; (8000b4c <MX_RTC_Init+0xc4>)
 8000ace:	f004 ff7b 	bl	80059c8 <HAL_RTC_Init>
 8000ad2:	4603      	mov	r3, r0
 8000ad4:	2b00      	cmp	r3, #0
 8000ad6:	d001      	beq.n	8000adc <MX_RTC_Init+0x54>
  {
    Error_Handler();
 8000ad8:	f7ff ffce 	bl	8000a78 <Error_Handler>
    
  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date 
  */
  sTime.Hours = 0;
 8000adc:	2300      	movs	r3, #0
 8000ade:	713b      	strb	r3, [r7, #4]
  sTime.Minutes = 0;
 8000ae0:	2300      	movs	r3, #0
 8000ae2:	717b      	strb	r3, [r7, #5]
  sTime.Seconds = 0;
 8000ae4:	2300      	movs	r3, #0
 8000ae6:	71bb      	strb	r3, [r7, #6]
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 8000ae8:	2300      	movs	r3, #0
 8000aea:	613b      	str	r3, [r7, #16]
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
 8000aec:	2300      	movs	r3, #0
 8000aee:	617b      	str	r3, [r7, #20]
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN) != HAL_OK)
 8000af0:	1d3b      	adds	r3, r7, #4
 8000af2:	2200      	movs	r2, #0
 8000af4:	4619      	mov	r1, r3
 8000af6:	4815      	ldr	r0, [pc, #84]	; (8000b4c <MX_RTC_Init+0xc4>)
 8000af8:	f004 fff7 	bl	8005aea <HAL_RTC_SetTime>
 8000afc:	4603      	mov	r3, r0
 8000afe:	2b00      	cmp	r3, #0
 8000b00:	d001      	beq.n	8000b06 <MX_RTC_Init+0x7e>
  {
    Error_Handler();
 8000b02:	f7ff ffb9 	bl	8000a78 <Error_Handler>
  }
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 8000b06:	2301      	movs	r3, #1
 8000b08:	703b      	strb	r3, [r7, #0]
  sDate.Month = RTC_MONTH_JANUARY;
 8000b0a:	2301      	movs	r3, #1
 8000b0c:	707b      	strb	r3, [r7, #1]
  sDate.Date = 1;
 8000b0e:	2301      	movs	r3, #1
 8000b10:	70bb      	strb	r3, [r7, #2]
  sDate.Year = 0;
 8000b12:	2300      	movs	r3, #0
 8000b14:	70fb      	strb	r3, [r7, #3]

  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN) != HAL_OK)
 8000b16:	463b      	mov	r3, r7
 8000b18:	2200      	movs	r2, #0
 8000b1a:	4619      	mov	r1, r3
 8000b1c:	480b      	ldr	r0, [pc, #44]	; (8000b4c <MX_RTC_Init+0xc4>)
 8000b1e:	f005 f8a1 	bl	8005c64 <HAL_RTC_SetDate>
 8000b22:	4603      	mov	r3, r0
 8000b24:	2b00      	cmp	r3, #0
 8000b26:	d001      	beq.n	8000b2c <MX_RTC_Init+0xa4>
  {
    Error_Handler();
 8000b28:	f7ff ffa6 	bl	8000a78 <Error_Handler>
  }
  /** Enable the WakeUp 
  */
  if (HAL_RTCEx_SetWakeUpTimer(&hrtc, 1000, RTC_WAKEUPCLOCK_RTCCLK_DIV16) != HAL_OK)
 8000b2c:	2200      	movs	r2, #0
 8000b2e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8000b32:	4806      	ldr	r0, [pc, #24]	; (8000b4c <MX_RTC_Init+0xc4>)
 8000b34:	f005 f9af 	bl	8005e96 <HAL_RTCEx_SetWakeUpTimer>
 8000b38:	4603      	mov	r3, r0
 8000b3a:	2b00      	cmp	r3, #0
 8000b3c:	d001      	beq.n	8000b42 <MX_RTC_Init+0xba>
  {
    Error_Handler();
 8000b3e:	f7ff ff9b 	bl	8000a78 <Error_Handler>
  }

}
 8000b42:	bf00      	nop
 8000b44:	3718      	adds	r7, #24
 8000b46:	46bd      	mov	sp, r7
 8000b48:	bd80      	pop	{r7, pc}
 8000b4a:	bf00      	nop
 8000b4c:	2000a580 	.word	0x2000a580
 8000b50:	40002800 	.word	0x40002800

08000b54 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 8000b54:	b480      	push	{r7}
 8000b56:	b083      	sub	sp, #12
 8000b58:	af00      	add	r7, sp, #0
 8000b5a:	6078      	str	r0, [r7, #4]

  if(rtcHandle->Instance==RTC)
 8000b5c:	687b      	ldr	r3, [r7, #4]
 8000b5e:	681b      	ldr	r3, [r3, #0]
 8000b60:	4a05      	ldr	r2, [pc, #20]	; (8000b78 <HAL_RTC_MspInit+0x24>)
 8000b62:	4293      	cmp	r3, r2
 8000b64:	d102      	bne.n	8000b6c <HAL_RTC_MspInit+0x18>
  {
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
    /* RTC clock enable */
    __HAL_RCC_RTC_ENABLE();
 8000b66:	4b05      	ldr	r3, [pc, #20]	; (8000b7c <HAL_RTC_MspInit+0x28>)
 8000b68:	2201      	movs	r2, #1
 8000b6a:	601a      	str	r2, [r3, #0]
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 8000b6c:	bf00      	nop
 8000b6e:	370c      	adds	r7, #12
 8000b70:	46bd      	mov	sp, r7
 8000b72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b76:	4770      	bx	lr
 8000b78:	40002800 	.word	0x40002800
 8000b7c:	42470e3c 	.word	0x42470e3c

08000b80 <MX_SPI1_Init>:
SPI_HandleTypeDef hspi1;
SPI_HandleTypeDef hspi2;

/* SPI1 init function */
void MX_SPI1_Init(void)
{
 8000b80:	b580      	push	{r7, lr}
 8000b82:	af00      	add	r7, sp, #0

  hspi1.Instance = SPI1;
 8000b84:	4b17      	ldr	r3, [pc, #92]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000b86:	4a18      	ldr	r2, [pc, #96]	; (8000be8 <MX_SPI1_Init+0x68>)
 8000b88:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8000b8a:	4b16      	ldr	r3, [pc, #88]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000b8c:	f44f 7282 	mov.w	r2, #260	; 0x104
 8000b90:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8000b92:	4b14      	ldr	r3, [pc, #80]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000b94:	2200      	movs	r2, #0
 8000b96:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8000b98:	4b12      	ldr	r3, [pc, #72]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000b9a:	2200      	movs	r2, #0
 8000b9c:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 8000b9e:	4b11      	ldr	r3, [pc, #68]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000ba0:	2200      	movs	r2, #0
 8000ba2:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000ba4:	4b0f      	ldr	r3, [pc, #60]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000ba6:	2200      	movs	r2, #0
 8000ba8:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8000baa:	4b0e      	ldr	r3, [pc, #56]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000bac:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000bb0:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 8000bb2:	4b0c      	ldr	r3, [pc, #48]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000bb4:	2210      	movs	r2, #16
 8000bb6:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000bb8:	4b0a      	ldr	r3, [pc, #40]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000bba:	2200      	movs	r2, #0
 8000bbc:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8000bbe:	4b09      	ldr	r3, [pc, #36]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000bc0:	2200      	movs	r2, #0
 8000bc2:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000bc4:	4b07      	ldr	r3, [pc, #28]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000bc6:	2200      	movs	r2, #0
 8000bc8:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 10;
 8000bca:	4b06      	ldr	r3, [pc, #24]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000bcc:	220a      	movs	r2, #10
 8000bce:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8000bd0:	4804      	ldr	r0, [pc, #16]	; (8000be4 <MX_SPI1_Init+0x64>)
 8000bd2:	f005 fa4c 	bl	800606e <HAL_SPI_Init>
 8000bd6:	4603      	mov	r3, r0
 8000bd8:	2b00      	cmp	r3, #0
 8000bda:	d001      	beq.n	8000be0 <MX_SPI1_Init+0x60>
  {
    Error_Handler();
 8000bdc:	f7ff ff4c 	bl	8000a78 <Error_Handler>
  }

}
 8000be0:	bf00      	nop
 8000be2:	bd80      	pop	{r7, pc}
 8000be4:	2000a5f8 	.word	0x2000a5f8
 8000be8:	40013000 	.word	0x40013000

08000bec <MX_SPI2_Init>:
/* SPI2 init function */
void MX_SPI2_Init(void)
{
 8000bec:	b580      	push	{r7, lr}
 8000bee:	af00      	add	r7, sp, #0

  hspi2.Instance = SPI2;
 8000bf0:	4b18      	ldr	r3, [pc, #96]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000bf2:	4a19      	ldr	r2, [pc, #100]	; (8000c58 <MX_SPI2_Init+0x6c>)
 8000bf4:	601a      	str	r2, [r3, #0]
  hspi2.Init.Mode = SPI_MODE_MASTER;
 8000bf6:	4b17      	ldr	r3, [pc, #92]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000bf8:	f44f 7282 	mov.w	r2, #260	; 0x104
 8000bfc:	605a      	str	r2, [r3, #4]
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
 8000bfe:	4b15      	ldr	r3, [pc, #84]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000c00:	2200      	movs	r2, #0
 8000c02:	609a      	str	r2, [r3, #8]
  hspi2.Init.DataSize = SPI_DATASIZE_16BIT;
 8000c04:	4b13      	ldr	r3, [pc, #76]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000c06:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8000c0a:	60da      	str	r2, [r3, #12]
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
 8000c0c:	4b11      	ldr	r3, [pc, #68]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000c0e:	2200      	movs	r2, #0
 8000c10:	611a      	str	r2, [r3, #16]
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000c12:	4b10      	ldr	r3, [pc, #64]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000c14:	2200      	movs	r2, #0
 8000c16:	615a      	str	r2, [r3, #20]
  hspi2.Init.NSS = SPI_NSS_SOFT;
 8000c18:	4b0e      	ldr	r3, [pc, #56]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000c1a:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000c1e:	619a      	str	r2, [r3, #24]
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 8000c20:	4b0c      	ldr	r3, [pc, #48]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000c22:	2208      	movs	r2, #8
 8000c24:	61da      	str	r2, [r3, #28]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000c26:	4b0b      	ldr	r3, [pc, #44]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000c28:	2200      	movs	r2, #0
 8000c2a:	621a      	str	r2, [r3, #32]
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
 8000c2c:	4b09      	ldr	r3, [pc, #36]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000c2e:	2200      	movs	r2, #0
 8000c30:	625a      	str	r2, [r3, #36]	; 0x24
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000c32:	4b08      	ldr	r3, [pc, #32]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000c34:	2200      	movs	r2, #0
 8000c36:	629a      	str	r2, [r3, #40]	; 0x28
  hspi2.Init.CRCPolynomial = 10;
 8000c38:	4b06      	ldr	r3, [pc, #24]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000c3a:	220a      	movs	r2, #10
 8000c3c:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 8000c3e:	4805      	ldr	r0, [pc, #20]	; (8000c54 <MX_SPI2_Init+0x68>)
 8000c40:	f005 fa15 	bl	800606e <HAL_SPI_Init>
 8000c44:	4603      	mov	r3, r0
 8000c46:	2b00      	cmp	r3, #0
 8000c48:	d001      	beq.n	8000c4e <MX_SPI2_Init+0x62>
  {
    Error_Handler();
 8000c4a:	f7ff ff15 	bl	8000a78 <Error_Handler>
  }

}
 8000c4e:	bf00      	nop
 8000c50:	bd80      	pop	{r7, pc}
 8000c52:	bf00      	nop
 8000c54:	2000a5a0 	.word	0x2000a5a0
 8000c58:	40003800 	.word	0x40003800

08000c5c <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8000c5c:	b580      	push	{r7, lr}
 8000c5e:	b08c      	sub	sp, #48	; 0x30
 8000c60:	af00      	add	r7, sp, #0
 8000c62:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000c64:	f107 031c 	add.w	r3, r7, #28
 8000c68:	2200      	movs	r2, #0
 8000c6a:	601a      	str	r2, [r3, #0]
 8000c6c:	605a      	str	r2, [r3, #4]
 8000c6e:	609a      	str	r2, [r3, #8]
 8000c70:	60da      	str	r2, [r3, #12]
 8000c72:	611a      	str	r2, [r3, #16]
  if(spiHandle->Instance==SPI1)
 8000c74:	687b      	ldr	r3, [r7, #4]
 8000c76:	681b      	ldr	r3, [r3, #0]
 8000c78:	4a3a      	ldr	r2, [pc, #232]	; (8000d64 <HAL_SPI_MspInit+0x108>)
 8000c7a:	4293      	cmp	r3, r2
 8000c7c:	d134      	bne.n	8000ce8 <HAL_SPI_MspInit+0x8c>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* SPI1 clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8000c7e:	2300      	movs	r3, #0
 8000c80:	61bb      	str	r3, [r7, #24]
 8000c82:	4b39      	ldr	r3, [pc, #228]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000c84:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000c86:	4a38      	ldr	r2, [pc, #224]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000c88:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000c8c:	6453      	str	r3, [r2, #68]	; 0x44
 8000c8e:	4b36      	ldr	r3, [pc, #216]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000c90:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000c92:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000c96:	61bb      	str	r3, [r7, #24]
 8000c98:	69bb      	ldr	r3, [r7, #24]
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000c9a:	2300      	movs	r3, #0
 8000c9c:	617b      	str	r3, [r7, #20]
 8000c9e:	4b32      	ldr	r3, [pc, #200]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000ca0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000ca2:	4a31      	ldr	r2, [pc, #196]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000ca4:	f043 0301 	orr.w	r3, r3, #1
 8000ca8:	6313      	str	r3, [r2, #48]	; 0x30
 8000caa:	4b2f      	ldr	r3, [pc, #188]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000cac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000cae:	f003 0301 	and.w	r3, r3, #1
 8000cb2:	617b      	str	r3, [r7, #20]
 8000cb4:	697b      	ldr	r3, [r7, #20]
    /**SPI1 GPIO Configuration    
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 8000cb6:	23e0      	movs	r3, #224	; 0xe0
 8000cb8:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000cba:	2302      	movs	r3, #2
 8000cbc:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000cbe:	2300      	movs	r3, #0
 8000cc0:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000cc2:	2303      	movs	r3, #3
 8000cc4:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8000cc6:	2305      	movs	r3, #5
 8000cc8:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000cca:	f107 031c 	add.w	r3, r7, #28
 8000cce:	4619      	mov	r1, r3
 8000cd0:	4826      	ldr	r0, [pc, #152]	; (8000d6c <HAL_SPI_MspInit+0x110>)
 8000cd2:	f002 f967 	bl	8002fa4 <HAL_GPIO_Init>

    /* SPI1 interrupt Init */
    HAL_NVIC_SetPriority(SPI1_IRQn, 5, 0);
 8000cd6:	2200      	movs	r2, #0
 8000cd8:	2105      	movs	r1, #5
 8000cda:	2023      	movs	r0, #35	; 0x23
 8000cdc:	f001 fab4 	bl	8002248 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI1_IRQn);
 8000ce0:	2023      	movs	r0, #35	; 0x23
 8000ce2:	f001 facd 	bl	8002280 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }
}
 8000ce6:	e039      	b.n	8000d5c <HAL_SPI_MspInit+0x100>
  else if(spiHandle->Instance==SPI2)
 8000ce8:	687b      	ldr	r3, [r7, #4]
 8000cea:	681b      	ldr	r3, [r3, #0]
 8000cec:	4a20      	ldr	r2, [pc, #128]	; (8000d70 <HAL_SPI_MspInit+0x114>)
 8000cee:	4293      	cmp	r3, r2
 8000cf0:	d134      	bne.n	8000d5c <HAL_SPI_MspInit+0x100>
    __HAL_RCC_SPI2_CLK_ENABLE();
 8000cf2:	2300      	movs	r3, #0
 8000cf4:	613b      	str	r3, [r7, #16]
 8000cf6:	4b1c      	ldr	r3, [pc, #112]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000cf8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000cfa:	4a1b      	ldr	r2, [pc, #108]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000cfc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000d00:	6413      	str	r3, [r2, #64]	; 0x40
 8000d02:	4b19      	ldr	r3, [pc, #100]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000d04:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000d06:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000d0a:	613b      	str	r3, [r7, #16]
 8000d0c:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000d0e:	2300      	movs	r3, #0
 8000d10:	60fb      	str	r3, [r7, #12]
 8000d12:	4b15      	ldr	r3, [pc, #84]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000d14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d16:	4a14      	ldr	r2, [pc, #80]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000d18:	f043 0302 	orr.w	r3, r3, #2
 8000d1c:	6313      	str	r3, [r2, #48]	; 0x30
 8000d1e:	4b12      	ldr	r3, [pc, #72]	; (8000d68 <HAL_SPI_MspInit+0x10c>)
 8000d20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d22:	f003 0302 	and.w	r3, r3, #2
 8000d26:	60fb      	str	r3, [r7, #12]
 8000d28:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
 8000d2a:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8000d2e:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000d30:	2302      	movs	r3, #2
 8000d32:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000d34:	2300      	movs	r3, #0
 8000d36:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000d38:	2303      	movs	r3, #3
 8000d3a:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8000d3c:	2305      	movs	r3, #5
 8000d3e:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000d40:	f107 031c 	add.w	r3, r7, #28
 8000d44:	4619      	mov	r1, r3
 8000d46:	480b      	ldr	r0, [pc, #44]	; (8000d74 <HAL_SPI_MspInit+0x118>)
 8000d48:	f002 f92c 	bl	8002fa4 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(SPI2_IRQn, 5, 0);
 8000d4c:	2200      	movs	r2, #0
 8000d4e:	2105      	movs	r1, #5
 8000d50:	2024      	movs	r0, #36	; 0x24
 8000d52:	f001 fa79 	bl	8002248 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
 8000d56:	2024      	movs	r0, #36	; 0x24
 8000d58:	f001 fa92 	bl	8002280 <HAL_NVIC_EnableIRQ>
}
 8000d5c:	bf00      	nop
 8000d5e:	3730      	adds	r7, #48	; 0x30
 8000d60:	46bd      	mov	sp, r7
 8000d62:	bd80      	pop	{r7, pc}
 8000d64:	40013000 	.word	0x40013000
 8000d68:	40023800 	.word	0x40023800
 8000d6c:	40020000 	.word	0x40020000
 8000d70:	40003800 	.word	0x40003800
 8000d74:	40020400 	.word	0x40020400

08000d78 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000d78:	b580      	push	{r7, lr}
 8000d7a:	b082      	sub	sp, #8
 8000d7c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000d7e:	2300      	movs	r3, #0
 8000d80:	607b      	str	r3, [r7, #4]
 8000d82:	4b12      	ldr	r3, [pc, #72]	; (8000dcc <HAL_MspInit+0x54>)
 8000d84:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000d86:	4a11      	ldr	r2, [pc, #68]	; (8000dcc <HAL_MspInit+0x54>)
 8000d88:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000d8c:	6453      	str	r3, [r2, #68]	; 0x44
 8000d8e:	4b0f      	ldr	r3, [pc, #60]	; (8000dcc <HAL_MspInit+0x54>)
 8000d90:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000d92:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000d96:	607b      	str	r3, [r7, #4]
 8000d98:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 8000d9a:	2300      	movs	r3, #0
 8000d9c:	603b      	str	r3, [r7, #0]
 8000d9e:	4b0b      	ldr	r3, [pc, #44]	; (8000dcc <HAL_MspInit+0x54>)
 8000da0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000da2:	4a0a      	ldr	r2, [pc, #40]	; (8000dcc <HAL_MspInit+0x54>)
 8000da4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000da8:	6413      	str	r3, [r2, #64]	; 0x40
 8000daa:	4b08      	ldr	r3, [pc, #32]	; (8000dcc <HAL_MspInit+0x54>)
 8000dac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000dae:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000db2:	603b      	str	r3, [r7, #0]
 8000db4:	683b      	ldr	r3, [r7, #0]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8000db6:	2200      	movs	r2, #0
 8000db8:	210f      	movs	r1, #15
 8000dba:	f06f 0001 	mvn.w	r0, #1
 8000dbe:	f001 fa43 	bl	8002248 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000dc2:	bf00      	nop
 8000dc4:	3708      	adds	r7, #8
 8000dc6:	46bd      	mov	sp, r7
 8000dc8:	bd80      	pop	{r7, pc}
 8000dca:	bf00      	nop
 8000dcc:	40023800 	.word	0x40023800

08000dd0 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000dd0:	b580      	push	{r7, lr}
 8000dd2:	b08c      	sub	sp, #48	; 0x30
 8000dd4:	af00      	add	r7, sp, #0
 8000dd6:	6078      	str	r0, [r7, #4]
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
 8000dd8:	2300      	movs	r3, #0
 8000dda:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t              uwPrescalerValue = 0;
 8000ddc:	2300      	movs	r3, #0
 8000dde:	62bb      	str	r3, [r7, #40]	; 0x28
  uint32_t              pFLatency;
  
  /*Configure the TIM1 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, TickPriority ,0); 
 8000de0:	2200      	movs	r2, #0
 8000de2:	6879      	ldr	r1, [r7, #4]
 8000de4:	2019      	movs	r0, #25
 8000de6:	f001 fa2f 	bl	8002248 <HAL_NVIC_SetPriority>
  
  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn); 
 8000dea:	2019      	movs	r0, #25
 8000dec:	f001 fa48 	bl	8002280 <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 8000df0:	2300      	movs	r3, #0
 8000df2:	60fb      	str	r3, [r7, #12]
 8000df4:	4b1e      	ldr	r3, [pc, #120]	; (8000e70 <HAL_InitTick+0xa0>)
 8000df6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000df8:	4a1d      	ldr	r2, [pc, #116]	; (8000e70 <HAL_InitTick+0xa0>)
 8000dfa:	f043 0301 	orr.w	r3, r3, #1
 8000dfe:	6453      	str	r3, [r2, #68]	; 0x44
 8000e00:	4b1b      	ldr	r3, [pc, #108]	; (8000e70 <HAL_InitTick+0xa0>)
 8000e02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000e04:	f003 0301 	and.w	r3, r3, #1
 8000e08:	60fb      	str	r3, [r7, #12]
 8000e0a:	68fb      	ldr	r3, [r7, #12]
  
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000e0c:	f107 0210 	add.w	r2, r7, #16
 8000e10:	f107 0314 	add.w	r3, r7, #20
 8000e14:	4611      	mov	r1, r2
 8000e16:	4618      	mov	r0, r3
 8000e18:	f004 fcb4 	bl	8005784 <HAL_RCC_GetClockConfig>
  
  /* Compute TIM1 clock */
  uwTimclock = HAL_RCC_GetPCLK2Freq();
 8000e1c:	f004 fc9e 	bl	800575c <HAL_RCC_GetPCLK2Freq>
 8000e20:	62f8      	str	r0, [r7, #44]	; 0x2c
   
  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 8000e22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000e24:	4a13      	ldr	r2, [pc, #76]	; (8000e74 <HAL_InitTick+0xa4>)
 8000e26:	fba2 2303 	umull	r2, r3, r2, r3
 8000e2a:	0c9b      	lsrs	r3, r3, #18
 8000e2c:	3b01      	subs	r3, #1
 8000e2e:	62bb      	str	r3, [r7, #40]	; 0x28
  
  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 8000e30:	4b11      	ldr	r3, [pc, #68]	; (8000e78 <HAL_InitTick+0xa8>)
 8000e32:	4a12      	ldr	r2, [pc, #72]	; (8000e7c <HAL_InitTick+0xac>)
 8000e34:	601a      	str	r2, [r3, #0]
  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000 / 1000) - 1;
 8000e36:	4b10      	ldr	r3, [pc, #64]	; (8000e78 <HAL_InitTick+0xa8>)
 8000e38:	f240 32e7 	movw	r2, #999	; 0x3e7
 8000e3c:	60da      	str	r2, [r3, #12]
  htim1.Init.Prescaler = uwPrescalerValue;
 8000e3e:	4a0e      	ldr	r2, [pc, #56]	; (8000e78 <HAL_InitTick+0xa8>)
 8000e40:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000e42:	6053      	str	r3, [r2, #4]
  htim1.Init.ClockDivision = 0;
 8000e44:	4b0c      	ldr	r3, [pc, #48]	; (8000e78 <HAL_InitTick+0xa8>)
 8000e46:	2200      	movs	r2, #0
 8000e48:	611a      	str	r2, [r3, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000e4a:	4b0b      	ldr	r3, [pc, #44]	; (8000e78 <HAL_InitTick+0xa8>)
 8000e4c:	2200      	movs	r2, #0
 8000e4e:	609a      	str	r2, [r3, #8]
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 8000e50:	4809      	ldr	r0, [pc, #36]	; (8000e78 <HAL_InitTick+0xa8>)
 8000e52:	f005 fa85 	bl	8006360 <HAL_TIM_Base_Init>
 8000e56:	4603      	mov	r3, r0
 8000e58:	2b00      	cmp	r3, #0
 8000e5a:	d104      	bne.n	8000e66 <HAL_InitTick+0x96>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
 8000e5c:	4806      	ldr	r0, [pc, #24]	; (8000e78 <HAL_InitTick+0xa8>)
 8000e5e:	f005 fab4 	bl	80063ca <HAL_TIM_Base_Start_IT>
 8000e62:	4603      	mov	r3, r0
 8000e64:	e000      	b.n	8000e68 <HAL_InitTick+0x98>
  }
  
  /* Return function status */
  return HAL_ERROR;
 8000e66:	2301      	movs	r3, #1
}
 8000e68:	4618      	mov	r0, r3
 8000e6a:	3730      	adds	r7, #48	; 0x30
 8000e6c:	46bd      	mov	sp, r7
 8000e6e:	bd80      	pop	{r7, pc}
 8000e70:	40023800 	.word	0x40023800
 8000e74:	431bde83 	.word	0x431bde83
 8000e78:	2000a650 	.word	0x2000a650
 8000e7c:	40010000 	.word	0x40010000

08000e80 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8000e80:	b480      	push	{r7}
 8000e82:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8000e84:	bf00      	nop
 8000e86:	46bd      	mov	sp, r7
 8000e88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e8c:	4770      	bx	lr

08000e8e <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8000e8e:	b480      	push	{r7}
 8000e90:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8000e92:	e7fe      	b.n	8000e92 <HardFault_Handler+0x4>

08000e94 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8000e94:	b480      	push	{r7}
 8000e96:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8000e98:	e7fe      	b.n	8000e98 <MemManage_Handler+0x4>

08000e9a <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8000e9a:	b480      	push	{r7}
 8000e9c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8000e9e:	e7fe      	b.n	8000e9e <BusFault_Handler+0x4>

08000ea0 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8000ea0:	b480      	push	{r7}
 8000ea2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000ea4:	e7fe      	b.n	8000ea4 <UsageFault_Handler+0x4>

08000ea6 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8000ea6:	b480      	push	{r7}
 8000ea8:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8000eaa:	bf00      	nop
 8000eac:	46bd      	mov	sp, r7
 8000eae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000eb2:	4770      	bx	lr

08000eb4 <DMA2_Stream7_IRQHandler>:

/**
  * @brief This function handles DMA2 stream7 global interrupt.
  */
void DMA2_Stream7_IRQHandler(void)
{
 8000eb4:	b580      	push	{r7, lr}
 8000eb6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream7_IRQn 0 */

  /* USER CODE END DMA2_Stream7_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_tx);
 8000eb8:	4802      	ldr	r0, [pc, #8]	; (8000ec4 <DMA2_Stream7_IRQHandler+0x10>)
 8000eba:	f001 fb17 	bl	80024ec <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream7_IRQn 1 */
}
 8000ebe:	bf00      	nop
 8000ec0:	bd80      	pop	{r7, pc}
 8000ec2:	bf00      	nop
 8000ec4:	2000a520 	.word	0x2000a520

08000ec8 <TIM1_UP_TIM10_IRQHandler>:

/**
  * @brief This function handles TIM1 update interrupt and TIM10 global interrupt.
  */
void TIM1_UP_TIM10_IRQHandler(void)
{
 8000ec8:	b580      	push	{r7, lr}
 8000eca:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM1_UP_TIM10_IRQn 0 */

  /* USER CODE END TIM1_UP_TIM10_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8000ecc:	4802      	ldr	r0, [pc, #8]	; (8000ed8 <TIM1_UP_TIM10_IRQHandler+0x10>)
 8000ece:	f005 faa0 	bl	8006412 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_UP_TIM10_IRQn 1 */

  /* USER CODE END TIM1_UP_TIM10_IRQn 1 */
}
 8000ed2:	bf00      	nop
 8000ed4:	bd80      	pop	{r7, pc}
 8000ed6:	bf00      	nop
 8000ed8:	2000a650 	.word	0x2000a650

08000edc <I2C1_EV_IRQHandler>:

/**
  * @brief This function handles I2C1 event interrupt.
  */
void I2C1_EV_IRQHandler(void)
{
 8000edc:	b580      	push	{r7, lr}
 8000ede:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_EV_IRQn 0 */

  /* USER CODE END I2C1_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c1);
 8000ee0:	4802      	ldr	r0, [pc, #8]	; (8000eec <I2C1_EV_IRQHandler+0x10>)
 8000ee2:	f002 fb4d 	bl	8003580 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C1_EV_IRQn 1 */

  /* USER CODE END I2C1_EV_IRQn 1 */
}
 8000ee6:	bf00      	nop
 8000ee8:	bd80      	pop	{r7, pc}
 8000eea:	bf00      	nop
 8000eec:	2000a398 	.word	0x2000a398

08000ef0 <I2C1_ER_IRQHandler>:

/**
  * @brief This function handles I2C1 error interrupt.
  */
void I2C1_ER_IRQHandler(void)
{
 8000ef0:	b580      	push	{r7, lr}
 8000ef2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_ER_IRQn 0 */

  /* USER CODE END I2C1_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c1);
 8000ef4:	4802      	ldr	r0, [pc, #8]	; (8000f00 <I2C1_ER_IRQHandler+0x10>)
 8000ef6:	f002 fcb0 	bl	800385a <HAL_I2C_ER_IRQHandler>
  /* USER CODE BEGIN I2C1_ER_IRQn 1 */

  /* USER CODE END I2C1_ER_IRQn 1 */
}
 8000efa:	bf00      	nop
 8000efc:	bd80      	pop	{r7, pc}
 8000efe:	bf00      	nop
 8000f00:	2000a398 	.word	0x2000a398

08000f04 <SPI1_IRQHandler>:

/**
  * @brief This function handles SPI1 global interrupt.
  */
void SPI1_IRQHandler(void)
{
 8000f04:	b580      	push	{r7, lr}
 8000f06:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SPI1_IRQn 0 */

  /* USER CODE END SPI1_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi1);
 8000f08:	4802      	ldr	r0, [pc, #8]	; (8000f14 <SPI1_IRQHandler+0x10>)
 8000f0a:	f005 f915 	bl	8006138 <HAL_SPI_IRQHandler>
  /* USER CODE BEGIN SPI1_IRQn 1 */

  /* USER CODE END SPI1_IRQn 1 */
}
 8000f0e:	bf00      	nop
 8000f10:	bd80      	pop	{r7, pc}
 8000f12:	bf00      	nop
 8000f14:	2000a5f8 	.word	0x2000a5f8

08000f18 <SPI2_IRQHandler>:

/**
  * @brief This function handles SPI2 global interrupt.
  */
void SPI2_IRQHandler(void)
{
 8000f18:	b580      	push	{r7, lr}
 8000f1a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SPI2_IRQn 0 */

  /* USER CODE END SPI2_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi2);
 8000f1c:	4802      	ldr	r0, [pc, #8]	; (8000f28 <SPI2_IRQHandler+0x10>)
 8000f1e:	f005 f90b 	bl	8006138 <HAL_SPI_IRQHandler>
  /* USER CODE BEGIN SPI2_IRQn 1 */

  /* USER CODE END SPI2_IRQn 1 */
}
 8000f22:	bf00      	nop
 8000f24:	bd80      	pop	{r7, pc}
 8000f26:	bf00      	nop
 8000f28:	2000a5a0 	.word	0x2000a5a0

08000f2c <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt.
  */
void USART1_IRQHandler(void)
{
 8000f2c:	b580      	push	{r7, lr}
 8000f2e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 8000f30:	4802      	ldr	r0, [pc, #8]	; (8000f3c <USART1_IRQHandler+0x10>)
 8000f32:	f005 fe05 	bl	8006b40 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 8000f36:	bf00      	nop
 8000f38:	bd80      	pop	{r7, pc}
 8000f3a:	bf00      	nop
 8000f3c:	2000a4a0 	.word	0x2000a4a0

08000f40 <DMA2_Stream2_IRQHandler>:

/**
  * @brief This function handles DMA2 stream2 global interrupt.
  */
void DMA2_Stream2_IRQHandler(void)
{
 8000f40:	b580      	push	{r7, lr}
 8000f42:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream2_IRQn 0 */

  /* USER CODE END DMA2_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_rx);
 8000f44:	4802      	ldr	r0, [pc, #8]	; (8000f50 <DMA2_Stream2_IRQHandler+0x10>)
 8000f46:	f001 fad1 	bl	80024ec <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream2_IRQn 1 */

  /* USER CODE END DMA2_Stream2_IRQn 1 */
}
 8000f4a:	bf00      	nop
 8000f4c:	bd80      	pop	{r7, pc}
 8000f4e:	bf00      	nop
 8000f50:	2000a440 	.word	0x2000a440

08000f54 <SPI3_IRQHandler>:

/**
  * @brief This function handles SPI3 global interrupt.
  */
void SPI3_IRQHandler(void)
{
 8000f54:	b580      	push	{r7, lr}
 8000f56:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SPI3_IRQn 0 */

  /* USER CODE END SPI3_IRQn 0 */
  HAL_I2S_IRQHandler(&hi2s3);
 8000f58:	4802      	ldr	r0, [pc, #8]	; (8000f64 <SPI3_IRQHandler+0x10>)
 8000f5a:	f003 ff94 	bl	8004e86 <HAL_I2S_IRQHandler>
  /* USER CODE BEGIN SPI3_IRQn 1 */

  /* USER CODE END SPI3_IRQn 1 */
}
 8000f5e:	bf00      	nop
 8000f60:	bd80      	pop	{r7, pc}
 8000f62:	bf00      	nop
 8000f64:	2000a3ec 	.word	0x2000a3ec

08000f68 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8000f68:	b580      	push	{r7, lr}
 8000f6a:	b086      	sub	sp, #24
 8000f6c:	af00      	add	r7, sp, #0
 8000f6e:	60f8      	str	r0, [r7, #12]
 8000f70:	60b9      	str	r1, [r7, #8]
 8000f72:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000f74:	2300      	movs	r3, #0
 8000f76:	617b      	str	r3, [r7, #20]
 8000f78:	e00a      	b.n	8000f90 <_read+0x28>
	{
		*ptr++ = __io_getchar();
 8000f7a:	f3af 8000 	nop.w
 8000f7e:	4601      	mov	r1, r0
 8000f80:	68bb      	ldr	r3, [r7, #8]
 8000f82:	1c5a      	adds	r2, r3, #1
 8000f84:	60ba      	str	r2, [r7, #8]
 8000f86:	b2ca      	uxtb	r2, r1
 8000f88:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000f8a:	697b      	ldr	r3, [r7, #20]
 8000f8c:	3301      	adds	r3, #1
 8000f8e:	617b      	str	r3, [r7, #20]
 8000f90:	697a      	ldr	r2, [r7, #20]
 8000f92:	687b      	ldr	r3, [r7, #4]
 8000f94:	429a      	cmp	r2, r3
 8000f96:	dbf0      	blt.n	8000f7a <_read+0x12>
	}

return len;
 8000f98:	687b      	ldr	r3, [r7, #4]
}
 8000f9a:	4618      	mov	r0, r3
 8000f9c:	3718      	adds	r7, #24
 8000f9e:	46bd      	mov	sp, r7
 8000fa0:	bd80      	pop	{r7, pc}

08000fa2 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8000fa2:	b580      	push	{r7, lr}
 8000fa4:	b086      	sub	sp, #24
 8000fa6:	af00      	add	r7, sp, #0
 8000fa8:	60f8      	str	r0, [r7, #12]
 8000faa:	60b9      	str	r1, [r7, #8]
 8000fac:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000fae:	2300      	movs	r3, #0
 8000fb0:	617b      	str	r3, [r7, #20]
 8000fb2:	e009      	b.n	8000fc8 <_write+0x26>
	{
		__io_putchar(*ptr++);
 8000fb4:	68bb      	ldr	r3, [r7, #8]
 8000fb6:	1c5a      	adds	r2, r3, #1
 8000fb8:	60ba      	str	r2, [r7, #8]
 8000fba:	781b      	ldrb	r3, [r3, #0]
 8000fbc:	4618      	mov	r0, r3
 8000fbe:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000fc2:	697b      	ldr	r3, [r7, #20]
 8000fc4:	3301      	adds	r3, #1
 8000fc6:	617b      	str	r3, [r7, #20]
 8000fc8:	697a      	ldr	r2, [r7, #20]
 8000fca:	687b      	ldr	r3, [r7, #4]
 8000fcc:	429a      	cmp	r2, r3
 8000fce:	dbf1      	blt.n	8000fb4 <_write+0x12>
	}
	return len;
 8000fd0:	687b      	ldr	r3, [r7, #4]
}
 8000fd2:	4618      	mov	r0, r3
 8000fd4:	3718      	adds	r7, #24
 8000fd6:	46bd      	mov	sp, r7
 8000fd8:	bd80      	pop	{r7, pc}

08000fda <_close>:

int _close(int file)
{
 8000fda:	b480      	push	{r7}
 8000fdc:	b083      	sub	sp, #12
 8000fde:	af00      	add	r7, sp, #0
 8000fe0:	6078      	str	r0, [r7, #4]
	return -1;
 8000fe2:	f04f 33ff 	mov.w	r3, #4294967295
}
 8000fe6:	4618      	mov	r0, r3
 8000fe8:	370c      	adds	r7, #12
 8000fea:	46bd      	mov	sp, r7
 8000fec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000ff0:	4770      	bx	lr

08000ff2 <_fstat>:


int _fstat(int file, struct stat *st)
{
 8000ff2:	b480      	push	{r7}
 8000ff4:	b083      	sub	sp, #12
 8000ff6:	af00      	add	r7, sp, #0
 8000ff8:	6078      	str	r0, [r7, #4]
 8000ffa:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
 8000ffc:	683b      	ldr	r3, [r7, #0]
 8000ffe:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001002:	605a      	str	r2, [r3, #4]
	return 0;
 8001004:	2300      	movs	r3, #0
}
 8001006:	4618      	mov	r0, r3
 8001008:	370c      	adds	r7, #12
 800100a:	46bd      	mov	sp, r7
 800100c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001010:	4770      	bx	lr

08001012 <_isatty>:

int _isatty(int file)
{
 8001012:	b480      	push	{r7}
 8001014:	b083      	sub	sp, #12
 8001016:	af00      	add	r7, sp, #0
 8001018:	6078      	str	r0, [r7, #4]
	return 1;
 800101a:	2301      	movs	r3, #1
}
 800101c:	4618      	mov	r0, r3
 800101e:	370c      	adds	r7, #12
 8001020:	46bd      	mov	sp, r7
 8001022:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001026:	4770      	bx	lr

08001028 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 8001028:	b480      	push	{r7}
 800102a:	b085      	sub	sp, #20
 800102c:	af00      	add	r7, sp, #0
 800102e:	60f8      	str	r0, [r7, #12]
 8001030:	60b9      	str	r1, [r7, #8]
 8001032:	607a      	str	r2, [r7, #4]
	return 0;
 8001034:	2300      	movs	r3, #0
}
 8001036:	4618      	mov	r0, r3
 8001038:	3714      	adds	r7, #20
 800103a:	46bd      	mov	sp, r7
 800103c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001040:	4770      	bx	lr
	...

08001044 <_sbrk>:
/**
 _sbrk
 Increase program data space. Malloc and related functions depend on this
**/
caddr_t _sbrk(int incr)
{
 8001044:	b580      	push	{r7, lr}
 8001046:	b084      	sub	sp, #16
 8001048:	af00      	add	r7, sp, #0
 800104a:	6078      	str	r0, [r7, #4]
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 800104c:	4b11      	ldr	r3, [pc, #68]	; (8001094 <_sbrk+0x50>)
 800104e:	681b      	ldr	r3, [r3, #0]
 8001050:	2b00      	cmp	r3, #0
 8001052:	d102      	bne.n	800105a <_sbrk+0x16>
		heap_end = &end;
 8001054:	4b0f      	ldr	r3, [pc, #60]	; (8001094 <_sbrk+0x50>)
 8001056:	4a10      	ldr	r2, [pc, #64]	; (8001098 <_sbrk+0x54>)
 8001058:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
 800105a:	4b0e      	ldr	r3, [pc, #56]	; (8001094 <_sbrk+0x50>)
 800105c:	681b      	ldr	r3, [r3, #0]
 800105e:	60fb      	str	r3, [r7, #12]
	if (heap_end + incr > stack_ptr)
 8001060:	4b0c      	ldr	r3, [pc, #48]	; (8001094 <_sbrk+0x50>)
 8001062:	681a      	ldr	r2, [r3, #0]
 8001064:	687b      	ldr	r3, [r7, #4]
 8001066:	4413      	add	r3, r2
 8001068:	466a      	mov	r2, sp
 800106a:	4293      	cmp	r3, r2
 800106c:	d907      	bls.n	800107e <_sbrk+0x3a>
	{
		errno = ENOMEM;
 800106e:	f026 fccb 	bl	8027a08 <__errno>
 8001072:	4602      	mov	r2, r0
 8001074:	230c      	movs	r3, #12
 8001076:	6013      	str	r3, [r2, #0]
		return (caddr_t) -1;
 8001078:	f04f 33ff 	mov.w	r3, #4294967295
 800107c:	e006      	b.n	800108c <_sbrk+0x48>
	}

	heap_end += incr;
 800107e:	4b05      	ldr	r3, [pc, #20]	; (8001094 <_sbrk+0x50>)
 8001080:	681a      	ldr	r2, [r3, #0]
 8001082:	687b      	ldr	r3, [r7, #4]
 8001084:	4413      	add	r3, r2
 8001086:	4a03      	ldr	r2, [pc, #12]	; (8001094 <_sbrk+0x50>)
 8001088:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
 800108a:	68fb      	ldr	r3, [r7, #12]
}
 800108c:	4618      	mov	r0, r3
 800108e:	3710      	adds	r7, #16
 8001090:	46bd      	mov	sp, r7
 8001092:	bd80      	pop	{r7, pc}
 8001094:	2000012c 	.word	0x2000012c
 8001098:	2000a730 	.word	0x2000a730

0800109c <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800109c:	b480      	push	{r7}
 800109e:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80010a0:	4b08      	ldr	r3, [pc, #32]	; (80010c4 <SystemInit+0x28>)
 80010a2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80010a6:	4a07      	ldr	r2, [pc, #28]	; (80010c4 <SystemInit+0x28>)
 80010a8:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80010ac:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80010b0:	4b04      	ldr	r3, [pc, #16]	; (80010c4 <SystemInit+0x28>)
 80010b2:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80010b6:	609a      	str	r2, [r3, #8]
#endif
}
 80010b8:	bf00      	nop
 80010ba:	46bd      	mov	sp, r7
 80010bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80010c0:	4770      	bx	lr
 80010c2:	bf00      	nop
 80010c4:	e000ed00 	.word	0xe000ed00

080010c8 <MX_USART2_UART_Init>:
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
void MX_USART2_UART_Init(void)
{
 80010c8:	b580      	push	{r7, lr}
 80010ca:	af00      	add	r7, sp, #0
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 80010cc:	4b11      	ldr	r3, [pc, #68]	; (8001114 <MX_USART2_UART_Init+0x4c>)
 80010ce:	4a12      	ldr	r2, [pc, #72]	; (8001118 <MX_USART2_UART_Init+0x50>)
 80010d0:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 115200;
 80010d2:	4b10      	ldr	r3, [pc, #64]	; (8001114 <MX_USART2_UART_Init+0x4c>)
 80010d4:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 80010d8:	605a      	str	r2, [r3, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 80010da:	4b0e      	ldr	r3, [pc, #56]	; (8001114 <MX_USART2_UART_Init+0x4c>)
 80010dc:	2200      	movs	r2, #0
 80010de:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 80010e0:	4b0c      	ldr	r3, [pc, #48]	; (8001114 <MX_USART2_UART_Init+0x4c>)
 80010e2:	2200      	movs	r2, #0
 80010e4:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 80010e6:	4b0b      	ldr	r3, [pc, #44]	; (8001114 <MX_USART2_UART_Init+0x4c>)
 80010e8:	2200      	movs	r2, #0
 80010ea:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 80010ec:	4b09      	ldr	r3, [pc, #36]	; (8001114 <MX_USART2_UART_Init+0x4c>)
 80010ee:	220c      	movs	r2, #12
 80010f0:	615a      	str	r2, [r3, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80010f2:	4b08      	ldr	r3, [pc, #32]	; (8001114 <MX_USART2_UART_Init+0x4c>)
 80010f4:	2200      	movs	r2, #0
 80010f6:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 80010f8:	4b06      	ldr	r3, [pc, #24]	; (8001114 <MX_USART2_UART_Init+0x4c>)
 80010fa:	2200      	movs	r2, #0
 80010fc:	61da      	str	r2, [r3, #28]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 80010fe:	4805      	ldr	r0, [pc, #20]	; (8001114 <MX_USART2_UART_Init+0x4c>)
 8001100:	f005 fb4c 	bl	800679c <HAL_UART_Init>
 8001104:	4603      	mov	r3, r0
 8001106:	2b00      	cmp	r3, #0
 8001108:	d001      	beq.n	800110e <MX_USART2_UART_Init+0x46>
  {
    Error_Handler();
 800110a:	f7ff fcb5 	bl	8000a78 <Error_Handler>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 800110e:	bf00      	nop
 8001110:	bd80      	pop	{r7, pc}
 8001112:	bf00      	nop
 8001114:	2000a4e0 	.word	0x2000a4e0
 8001118:	40004400 	.word	0x40004400

0800111c <MX_USART1_UART_Init>:
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
void MX_USART1_UART_Init(void)
{
 800111c:	b580      	push	{r7, lr}
 800111e:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 8001120:	4b11      	ldr	r3, [pc, #68]	; (8001168 <MX_USART1_UART_Init+0x4c>)
 8001122:	4a12      	ldr	r2, [pc, #72]	; (800116c <MX_USART1_UART_Init+0x50>)
 8001124:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 8001126:	4b10      	ldr	r3, [pc, #64]	; (8001168 <MX_USART1_UART_Init+0x4c>)
 8001128:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 800112c:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 800112e:	4b0e      	ldr	r3, [pc, #56]	; (8001168 <MX_USART1_UART_Init+0x4c>)
 8001130:	2200      	movs	r2, #0
 8001132:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8001134:	4b0c      	ldr	r3, [pc, #48]	; (8001168 <MX_USART1_UART_Init+0x4c>)
 8001136:	2200      	movs	r2, #0
 8001138:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 800113a:	4b0b      	ldr	r3, [pc, #44]	; (8001168 <MX_USART1_UART_Init+0x4c>)
 800113c:	2200      	movs	r2, #0
 800113e:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8001140:	4b09      	ldr	r3, [pc, #36]	; (8001168 <MX_USART1_UART_Init+0x4c>)
 8001142:	220c      	movs	r2, #12
 8001144:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
 8001146:	4b08      	ldr	r3, [pc, #32]	; (8001168 <MX_USART1_UART_Init+0x4c>)
 8001148:	f44f 7240 	mov.w	r2, #768	; 0x300
 800114c:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 800114e:	4b06      	ldr	r3, [pc, #24]	; (8001168 <MX_USART1_UART_Init+0x4c>)
 8001150:	2200      	movs	r2, #0
 8001152:	61da      	str	r2, [r3, #28]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8001154:	4804      	ldr	r0, [pc, #16]	; (8001168 <MX_USART1_UART_Init+0x4c>)
 8001156:	f005 fb21 	bl	800679c <HAL_UART_Init>
 800115a:	4603      	mov	r3, r0
 800115c:	2b00      	cmp	r3, #0
 800115e:	d001      	beq.n	8001164 <MX_USART1_UART_Init+0x48>
  {
    Error_Handler();
 8001160:	f7ff fc8a 	bl	8000a78 <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 8001164:	bf00      	nop
 8001166:	bd80      	pop	{r7, pc}
 8001168:	2000a4a0 	.word	0x2000a4a0
 800116c:	40011000 	.word	0x40011000

08001170 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8001170:	b580      	push	{r7, lr}
 8001172:	b08c      	sub	sp, #48	; 0x30
 8001174:	af00      	add	r7, sp, #0
 8001176:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001178:	f107 031c 	add.w	r3, r7, #28
 800117c:	2200      	movs	r2, #0
 800117e:	601a      	str	r2, [r3, #0]
 8001180:	605a      	str	r2, [r3, #4]
 8001182:	609a      	str	r2, [r3, #8]
 8001184:	60da      	str	r2, [r3, #12]
 8001186:	611a      	str	r2, [r3, #16]
  if(huart->Instance==USART1)
 8001188:	687b      	ldr	r3, [r7, #4]
 800118a:	681b      	ldr	r3, [r3, #0]
 800118c:	4a66      	ldr	r2, [pc, #408]	; (8001328 <HAL_UART_MspInit+0x1b8>)
 800118e:	4293      	cmp	r3, r2
 8001190:	f040 8094 	bne.w	80012bc <HAL_UART_MspInit+0x14c>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 8001194:	2300      	movs	r3, #0
 8001196:	61bb      	str	r3, [r7, #24]
 8001198:	4b64      	ldr	r3, [pc, #400]	; (800132c <HAL_UART_MspInit+0x1bc>)
 800119a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800119c:	4a63      	ldr	r2, [pc, #396]	; (800132c <HAL_UART_MspInit+0x1bc>)
 800119e:	f043 0310 	orr.w	r3, r3, #16
 80011a2:	6453      	str	r3, [r2, #68]	; 0x44
 80011a4:	4b61      	ldr	r3, [pc, #388]	; (800132c <HAL_UART_MspInit+0x1bc>)
 80011a6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80011a8:	f003 0310 	and.w	r3, r3, #16
 80011ac:	61bb      	str	r3, [r7, #24]
 80011ae:	69bb      	ldr	r3, [r7, #24]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80011b0:	2300      	movs	r3, #0
 80011b2:	617b      	str	r3, [r7, #20]
 80011b4:	4b5d      	ldr	r3, [pc, #372]	; (800132c <HAL_UART_MspInit+0x1bc>)
 80011b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80011b8:	4a5c      	ldr	r2, [pc, #368]	; (800132c <HAL_UART_MspInit+0x1bc>)
 80011ba:	f043 0301 	orr.w	r3, r3, #1
 80011be:	6313      	str	r3, [r2, #48]	; 0x30
 80011c0:	4b5a      	ldr	r3, [pc, #360]	; (800132c <HAL_UART_MspInit+0x1bc>)
 80011c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80011c4:	f003 0301 	and.w	r3, r3, #1
 80011c8:	617b      	str	r3, [r7, #20]
 80011ca:	697b      	ldr	r3, [r7, #20]
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    PA11     ------> USART1_CTS
    PA12     ------> USART1_RTS
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
 80011cc:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
 80011d0:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80011d2:	2302      	movs	r3, #2
 80011d4:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80011d6:	2300      	movs	r3, #0
 80011d8:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80011da:	2303      	movs	r3, #3
 80011dc:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 80011de:	2307      	movs	r3, #7
 80011e0:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80011e2:	f107 031c 	add.w	r3, r7, #28
 80011e6:	4619      	mov	r1, r3
 80011e8:	4851      	ldr	r0, [pc, #324]	; (8001330 <HAL_UART_MspInit+0x1c0>)
 80011ea:	f001 fedb 	bl	8002fa4 <HAL_GPIO_Init>

    /* USART1 DMA Init */
    /* USART1_RX Init */
    hdma_usart1_rx.Instance = DMA2_Stream2;
 80011ee:	4b51      	ldr	r3, [pc, #324]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 80011f0:	4a51      	ldr	r2, [pc, #324]	; (8001338 <HAL_UART_MspInit+0x1c8>)
 80011f2:	601a      	str	r2, [r3, #0]
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
 80011f4:	4b4f      	ldr	r3, [pc, #316]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 80011f6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80011fa:	605a      	str	r2, [r3, #4]
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 80011fc:	4b4d      	ldr	r3, [pc, #308]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 80011fe:	2200      	movs	r2, #0
 8001200:	609a      	str	r2, [r3, #8]
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001202:	4b4c      	ldr	r3, [pc, #304]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 8001204:	2200      	movs	r2, #0
 8001206:	60da      	str	r2, [r3, #12]
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
 8001208:	4b4a      	ldr	r3, [pc, #296]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 800120a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800120e:	611a      	str	r2, [r3, #16]
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8001210:	4b48      	ldr	r3, [pc, #288]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 8001212:	2200      	movs	r2, #0
 8001214:	615a      	str	r2, [r3, #20]
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8001216:	4b47      	ldr	r3, [pc, #284]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 8001218:	2200      	movs	r2, #0
 800121a:	619a      	str	r2, [r3, #24]
    hdma_usart1_rx.Init.Mode = DMA_NORMAL;
 800121c:	4b45      	ldr	r3, [pc, #276]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 800121e:	2200      	movs	r2, #0
 8001220:	61da      	str	r2, [r3, #28]
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 8001222:	4b44      	ldr	r3, [pc, #272]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 8001224:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8001228:	621a      	str	r2, [r3, #32]
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 800122a:	4b42      	ldr	r3, [pc, #264]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 800122c:	2200      	movs	r2, #0
 800122e:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
 8001230:	4840      	ldr	r0, [pc, #256]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 8001232:	f001 f833 	bl	800229c <HAL_DMA_Init>
 8001236:	4603      	mov	r3, r0
 8001238:	2b00      	cmp	r3, #0
 800123a:	d001      	beq.n	8001240 <HAL_UART_MspInit+0xd0>
    {
      Error_Handler();
 800123c:	f7ff fc1c 	bl	8000a78 <Error_Handler>
    }

    __HAL_LINKDMA(huart,hdmarx,hdma_usart1_rx);
 8001240:	687b      	ldr	r3, [r7, #4]
 8001242:	4a3c      	ldr	r2, [pc, #240]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 8001244:	635a      	str	r2, [r3, #52]	; 0x34
 8001246:	4a3b      	ldr	r2, [pc, #236]	; (8001334 <HAL_UART_MspInit+0x1c4>)
 8001248:	687b      	ldr	r3, [r7, #4]
 800124a:	6393      	str	r3, [r2, #56]	; 0x38

    /* USART1_TX Init */
    hdma_usart1_tx.Instance = DMA2_Stream7;
 800124c:	4b3b      	ldr	r3, [pc, #236]	; (800133c <HAL_UART_MspInit+0x1cc>)
 800124e:	4a3c      	ldr	r2, [pc, #240]	; (8001340 <HAL_UART_MspInit+0x1d0>)
 8001250:	601a      	str	r2, [r3, #0]
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
 8001252:	4b3a      	ldr	r3, [pc, #232]	; (800133c <HAL_UART_MspInit+0x1cc>)
 8001254:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001258:	605a      	str	r2, [r3, #4]
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800125a:	4b38      	ldr	r3, [pc, #224]	; (800133c <HAL_UART_MspInit+0x1cc>)
 800125c:	2240      	movs	r2, #64	; 0x40
 800125e:	609a      	str	r2, [r3, #8]
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001260:	4b36      	ldr	r3, [pc, #216]	; (800133c <HAL_UART_MspInit+0x1cc>)
 8001262:	2200      	movs	r2, #0
 8001264:	60da      	str	r2, [r3, #12]
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8001266:	4b35      	ldr	r3, [pc, #212]	; (800133c <HAL_UART_MspInit+0x1cc>)
 8001268:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800126c:	611a      	str	r2, [r3, #16]
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800126e:	4b33      	ldr	r3, [pc, #204]	; (800133c <HAL_UART_MspInit+0x1cc>)
 8001270:	2200      	movs	r2, #0
 8001272:	615a      	str	r2, [r3, #20]
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8001274:	4b31      	ldr	r3, [pc, #196]	; (800133c <HAL_UART_MspInit+0x1cc>)
 8001276:	2200      	movs	r2, #0
 8001278:	619a      	str	r2, [r3, #24]
    hdma_usart1_tx.Init.Mode = DMA_NORMAL;
 800127a:	4b30      	ldr	r3, [pc, #192]	; (800133c <HAL_UART_MspInit+0x1cc>)
 800127c:	2200      	movs	r2, #0
 800127e:	61da      	str	r2, [r3, #28]
    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 8001280:	4b2e      	ldr	r3, [pc, #184]	; (800133c <HAL_UART_MspInit+0x1cc>)
 8001282:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8001286:	621a      	str	r2, [r3, #32]
    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8001288:	4b2c      	ldr	r3, [pc, #176]	; (800133c <HAL_UART_MspInit+0x1cc>)
 800128a:	2200      	movs	r2, #0
 800128c:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
 800128e:	482b      	ldr	r0, [pc, #172]	; (800133c <HAL_UART_MspInit+0x1cc>)
 8001290:	f001 f804 	bl	800229c <HAL_DMA_Init>
 8001294:	4603      	mov	r3, r0
 8001296:	2b00      	cmp	r3, #0
 8001298:	d001      	beq.n	800129e <HAL_UART_MspInit+0x12e>
    {
      Error_Handler();
 800129a:	f7ff fbed 	bl	8000a78 <Error_Handler>
    }

    __HAL_LINKDMA(huart,hdmatx,hdma_usart1_tx);
 800129e:	687b      	ldr	r3, [r7, #4]
 80012a0:	4a26      	ldr	r2, [pc, #152]	; (800133c <HAL_UART_MspInit+0x1cc>)
 80012a2:	631a      	str	r2, [r3, #48]	; 0x30
 80012a4:	4a25      	ldr	r2, [pc, #148]	; (800133c <HAL_UART_MspInit+0x1cc>)
 80012a6:	687b      	ldr	r3, [r7, #4]
 80012a8:	6393      	str	r3, [r2, #56]	; 0x38

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 80012aa:	2200      	movs	r2, #0
 80012ac:	2100      	movs	r1, #0
 80012ae:	2025      	movs	r0, #37	; 0x25
 80012b0:	f000 ffca 	bl	8002248 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 80012b4:	2025      	movs	r0, #37	; 0x25
 80012b6:	f000 ffe3 	bl	8002280 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }

}
 80012ba:	e030      	b.n	800131e <HAL_UART_MspInit+0x1ae>
  else if(huart->Instance==USART2)
 80012bc:	687b      	ldr	r3, [r7, #4]
 80012be:	681b      	ldr	r3, [r3, #0]
 80012c0:	4a20      	ldr	r2, [pc, #128]	; (8001344 <HAL_UART_MspInit+0x1d4>)
 80012c2:	4293      	cmp	r3, r2
 80012c4:	d12b      	bne.n	800131e <HAL_UART_MspInit+0x1ae>
    __HAL_RCC_USART2_CLK_ENABLE();
 80012c6:	2300      	movs	r3, #0
 80012c8:	613b      	str	r3, [r7, #16]
 80012ca:	4b18      	ldr	r3, [pc, #96]	; (800132c <HAL_UART_MspInit+0x1bc>)
 80012cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80012ce:	4a17      	ldr	r2, [pc, #92]	; (800132c <HAL_UART_MspInit+0x1bc>)
 80012d0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80012d4:	6413      	str	r3, [r2, #64]	; 0x40
 80012d6:	4b15      	ldr	r3, [pc, #84]	; (800132c <HAL_UART_MspInit+0x1bc>)
 80012d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80012da:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80012de:	613b      	str	r3, [r7, #16]
 80012e0:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80012e2:	2300      	movs	r3, #0
 80012e4:	60fb      	str	r3, [r7, #12]
 80012e6:	4b11      	ldr	r3, [pc, #68]	; (800132c <HAL_UART_MspInit+0x1bc>)
 80012e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80012ea:	4a10      	ldr	r2, [pc, #64]	; (800132c <HAL_UART_MspInit+0x1bc>)
 80012ec:	f043 0301 	orr.w	r3, r3, #1
 80012f0:	6313      	str	r3, [r2, #48]	; 0x30
 80012f2:	4b0e      	ldr	r3, [pc, #56]	; (800132c <HAL_UART_MspInit+0x1bc>)
 80012f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80012f6:	f003 0301 	and.w	r3, r3, #1
 80012fa:	60fb      	str	r3, [r7, #12]
 80012fc:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3;
 80012fe:	230f      	movs	r3, #15
 8001300:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001302:	2302      	movs	r3, #2
 8001304:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001306:	2300      	movs	r3, #0
 8001308:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800130a:	2303      	movs	r3, #3
 800130c:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 800130e:	2307      	movs	r3, #7
 8001310:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001312:	f107 031c 	add.w	r3, r7, #28
 8001316:	4619      	mov	r1, r3
 8001318:	4805      	ldr	r0, [pc, #20]	; (8001330 <HAL_UART_MspInit+0x1c0>)
 800131a:	f001 fe43 	bl	8002fa4 <HAL_GPIO_Init>
}
 800131e:	bf00      	nop
 8001320:	3730      	adds	r7, #48	; 0x30
 8001322:	46bd      	mov	sp, r7
 8001324:	bd80      	pop	{r7, pc}
 8001326:	bf00      	nop
 8001328:	40011000 	.word	0x40011000
 800132c:	40023800 	.word	0x40023800
 8001330:	40020000 	.word	0x40020000
 8001334:	2000a440 	.word	0x2000a440
 8001338:	40026440 	.word	0x40026440
 800133c:	2000a520 	.word	0x2000a520
 8001340:	400264b8 	.word	0x400264b8
 8001344:	40004400 	.word	0x40004400

08001348 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 8001348:	f8df d034 	ldr.w	sp, [pc, #52]	; 8001380 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800134c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800134e:	e003      	b.n	8001358 <LoopCopyDataInit>

08001350 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8001350:	4b0c      	ldr	r3, [pc, #48]	; (8001384 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8001352:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8001354:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8001356:	3104      	adds	r1, #4

08001358 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8001358:	480b      	ldr	r0, [pc, #44]	; (8001388 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800135a:	4b0c      	ldr	r3, [pc, #48]	; (800138c <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800135c:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800135e:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8001360:	d3f6      	bcc.n	8001350 <CopyDataInit>
  ldr  r2, =_sbss
 8001362:	4a0b      	ldr	r2, [pc, #44]	; (8001390 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8001364:	e002      	b.n	800136c <LoopFillZerobss>

08001366 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8001366:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8001368:	f842 3b04 	str.w	r3, [r2], #4

0800136c <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800136c:	4b09      	ldr	r3, [pc, #36]	; (8001394 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800136e:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8001370:	d3f9      	bcc.n	8001366 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8001372:	f7ff fe93 	bl	800109c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8001376:	f026 fb4d 	bl	8027a14 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800137a:	f7ff fa9f 	bl	80008bc <main>
  bx  lr    
 800137e:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 8001380:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8001384:	08030fc4 	.word	0x08030fc4
  ldr  r0, =_sdata
 8001388:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800138c:	20000110 	.word	0x20000110
  ldr  r2, =_sbss
 8001390:	20000110 	.word	0x20000110
  ldr  r3, = _ebss
 8001394:	2000a730 	.word	0x2000a730

08001398 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001398:	e7fe      	b.n	8001398 <ADC_IRQHandler>

0800139a <hci_event_packet_get_type>:
/**
 * @brief Get event type
 * @param event
 * @return type of event
 */
static inline uint8_t hci_event_packet_get_type(const uint8_t * event){
 800139a:	b480      	push	{r7}
 800139c:	b083      	sub	sp, #12
 800139e:	af00      	add	r7, sp, #0
 80013a0:	6078      	str	r0, [r7, #4]
    return event[0];
 80013a2:	687b      	ldr	r3, [r7, #4]
 80013a4:	781b      	ldrb	r3, [r3, #0]
}
 80013a6:	4618      	mov	r0, r3
 80013a8:	370c      	adds	r7, #12
 80013aa:	46bd      	mov	sp, r7
 80013ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80013b0:	4770      	bx	lr

080013b2 <hci_event_le_meta_get_subevent_code>:
/***
 * @brief Get subevent code for le event
 * @param event packet
 * @return subevent_code
 */
static inline uint8_t hci_event_le_meta_get_subevent_code(const uint8_t * event){
 80013b2:	b480      	push	{r7}
 80013b4:	b083      	sub	sp, #12
 80013b6:	af00      	add	r7, sp, #0
 80013b8:	6078      	str	r0, [r7, #4]
    return event[2];
 80013ba:	687b      	ldr	r3, [r7, #4]
 80013bc:	3302      	adds	r3, #2
 80013be:	781b      	ldrb	r3, [r3, #0]
}
 80013c0:	4618      	mov	r0, r3
 80013c2:	370c      	adds	r7, #12
 80013c4:	46bd      	mov	sp, r7
 80013c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80013ca:	4770      	bx	lr

080013cc <hci_event_disconnection_complete_get_connection_handle>:
 * @brief Get field connection_handle from event HCI_EVENT_DISCONNECTION_COMPLETE
 * @param event packet
 * @return connection_handle
 * @note: btstack_type 2
 */
static inline uint16_t hci_event_disconnection_complete_get_connection_handle(const uint8_t * event){
 80013cc:	b580      	push	{r7, lr}
 80013ce:	b082      	sub	sp, #8
 80013d0:	af00      	add	r7, sp, #0
 80013d2:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 3);
 80013d4:	2103      	movs	r1, #3
 80013d6:	6878      	ldr	r0, [r7, #4]
 80013d8:	f00d fd05 	bl	800ede6 <little_endian_read_16>
 80013dc:	4603      	mov	r3, r0
}
 80013de:	4618      	mov	r0, r3
 80013e0:	3708      	adds	r7, #8
 80013e2:	46bd      	mov	sp, r7
 80013e4:	bd80      	pop	{r7, pc}

080013e6 <hci_event_disconnection_complete_get_reason>:
 * @brief Get field reason from event HCI_EVENT_DISCONNECTION_COMPLETE
 * @param event packet
 * @return reason
 * @note: btstack_type 1
 */
static inline uint8_t hci_event_disconnection_complete_get_reason(const uint8_t * event){
 80013e6:	b480      	push	{r7}
 80013e8:	b083      	sub	sp, #12
 80013ea:	af00      	add	r7, sp, #0
 80013ec:	6078      	str	r0, [r7, #4]
    return event[5];
 80013ee:	687b      	ldr	r3, [r7, #4]
 80013f0:	3305      	adds	r3, #5
 80013f2:	781b      	ldrb	r3, [r3, #0]
}
 80013f4:	4618      	mov	r0, r3
 80013f6:	370c      	adds	r7, #12
 80013f8:	46bd      	mov	sp, r7
 80013fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80013fe:	4770      	bx	lr

08001400 <btstack_event_state_get_state>:
 * @brief Get field state from event BTSTACK_EVENT_STATE
 * @param event packet
 * @return state
 * @note: btstack_type 1
 */
static inline uint8_t btstack_event_state_get_state(const uint8_t * event){
 8001400:	b480      	push	{r7}
 8001402:	b083      	sub	sp, #12
 8001404:	af00      	add	r7, sp, #0
 8001406:	6078      	str	r0, [r7, #4]
    return event[2];
 8001408:	687b      	ldr	r3, [r7, #4]
 800140a:	3302      	adds	r3, #2
 800140c:	781b      	ldrb	r3, [r3, #0]
}
 800140e:	4618      	mov	r0, r3
 8001410:	370c      	adds	r7, #12
 8001412:	46bd      	mov	sp, r7
 8001414:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001418:	4770      	bx	lr

0800141a <att_event_connected_get_handle>:
 * @brief Get field handle from event ATT_EVENT_CONNECTED
 * @param event packet
 * @return handle
 * @note: btstack_type H
 */
static inline hci_con_handle_t att_event_connected_get_handle(const uint8_t * event){
 800141a:	b580      	push	{r7, lr}
 800141c:	b082      	sub	sp, #8
 800141e:	af00      	add	r7, sp, #0
 8001420:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 9);
 8001422:	2109      	movs	r1, #9
 8001424:	6878      	ldr	r0, [r7, #4]
 8001426:	f00d fcde 	bl	800ede6 <little_endian_read_16>
 800142a:	4603      	mov	r3, r0
}
 800142c:	4618      	mov	r0, r3
 800142e:	3708      	adds	r7, #8
 8001430:	46bd      	mov	sp, r7
 8001432:	bd80      	pop	{r7, pc}

08001434 <att_event_disconnected_get_handle>:
 * @brief Get field handle from event ATT_EVENT_DISCONNECTED
 * @param event packet
 * @return handle
 * @note: btstack_type H
 */
static inline hci_con_handle_t att_event_disconnected_get_handle(const uint8_t * event){
 8001434:	b580      	push	{r7, lr}
 8001436:	b082      	sub	sp, #8
 8001438:	af00      	add	r7, sp, #0
 800143a:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 2);
 800143c:	2102      	movs	r1, #2
 800143e:	6878      	ldr	r0, [r7, #4]
 8001440:	f00d fcd1 	bl	800ede6 <little_endian_read_16>
 8001444:	4603      	mov	r3, r0
}
 8001446:	4618      	mov	r0, r3
 8001448:	3708      	adds	r7, #8
 800144a:	46bd      	mov	sp, r7
 800144c:	bd80      	pop	{r7, pc}

0800144e <att_event_mtu_exchange_complete_get_handle>:
 * @brief Get field handle from event ATT_EVENT_MTU_EXCHANGE_COMPLETE
 * @param event packet
 * @return handle
 * @note: btstack_type H
 */
static inline hci_con_handle_t att_event_mtu_exchange_complete_get_handle(const uint8_t * event){
 800144e:	b580      	push	{r7, lr}
 8001450:	b082      	sub	sp, #8
 8001452:	af00      	add	r7, sp, #0
 8001454:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 2);
 8001456:	2102      	movs	r1, #2
 8001458:	6878      	ldr	r0, [r7, #4]
 800145a:	f00d fcc4 	bl	800ede6 <little_endian_read_16>
 800145e:	4603      	mov	r3, r0
}
 8001460:	4618      	mov	r0, r3
 8001462:	3708      	adds	r7, #8
 8001464:	46bd      	mov	sp, r7
 8001466:	bd80      	pop	{r7, pc}

08001468 <att_event_mtu_exchange_complete_get_MTU>:
 * @brief Get field MTU from event ATT_EVENT_MTU_EXCHANGE_COMPLETE
 * @param event packet
 * @return MTU
 * @note: btstack_type 2
 */
static inline uint16_t att_event_mtu_exchange_complete_get_MTU(const uint8_t * event){
 8001468:	b580      	push	{r7, lr}
 800146a:	b082      	sub	sp, #8
 800146c:	af00      	add	r7, sp, #0
 800146e:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 4);
 8001470:	2104      	movs	r1, #4
 8001472:	6878      	ldr	r0, [r7, #4]
 8001474:	f00d fcb7 	bl	800ede6 <little_endian_read_16>
 8001478:	4603      	mov	r3, r0
}
 800147a:	4618      	mov	r0, r3
 800147c:	3708      	adds	r7, #8
 800147e:	46bd      	mov	sp, r7
 8001480:	bd80      	pop	{r7, pc}

08001482 <hci_subevent_le_connection_complete_get_connection_handle>:
 * @brief Get field connection_handle from event HCI_SUBEVENT_LE_CONNECTION_COMPLETE
 * @param event packet
 * @return connection_handle
 * @note: btstack_type H
 */
static inline hci_con_handle_t hci_subevent_le_connection_complete_get_connection_handle(const uint8_t * event){
 8001482:	b580      	push	{r7, lr}
 8001484:	b082      	sub	sp, #8
 8001486:	af00      	add	r7, sp, #0
 8001488:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 4);
 800148a:	2104      	movs	r1, #4
 800148c:	6878      	ldr	r0, [r7, #4]
 800148e:	f00d fcaa 	bl	800ede6 <little_endian_read_16>
 8001492:	4603      	mov	r3, r0
}
 8001494:	4618      	mov	r0, r3
 8001496:	3708      	adds	r7, #8
 8001498:	46bd      	mov	sp, r7
 800149a:	bd80      	pop	{r7, pc}

0800149c <hci_subevent_le_connection_complete_get_conn_interval>:
 * @brief Get field conn_interval from event HCI_SUBEVENT_LE_CONNECTION_COMPLETE
 * @param event packet
 * @return conn_interval
 * @note: btstack_type 2
 */
static inline uint16_t hci_subevent_le_connection_complete_get_conn_interval(const uint8_t * event){
 800149c:	b580      	push	{r7, lr}
 800149e:	b082      	sub	sp, #8
 80014a0:	af00      	add	r7, sp, #0
 80014a2:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 14);
 80014a4:	210e      	movs	r1, #14
 80014a6:	6878      	ldr	r0, [r7, #4]
 80014a8:	f00d fc9d 	bl	800ede6 <little_endian_read_16>
 80014ac:	4603      	mov	r3, r0
}
 80014ae:	4618      	mov	r0, r3
 80014b0:	3708      	adds	r7, #8
 80014b2:	46bd      	mov	sp, r7
 80014b4:	bd80      	pop	{r7, pc}

080014b6 <hci_subevent_le_connection_complete_get_conn_latency>:
 * @brief Get field conn_latency from event HCI_SUBEVENT_LE_CONNECTION_COMPLETE
 * @param event packet
 * @return conn_latency
 * @note: btstack_type 2
 */
static inline uint16_t hci_subevent_le_connection_complete_get_conn_latency(const uint8_t * event){
 80014b6:	b580      	push	{r7, lr}
 80014b8:	b082      	sub	sp, #8
 80014ba:	af00      	add	r7, sp, #0
 80014bc:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 16);
 80014be:	2110      	movs	r1, #16
 80014c0:	6878      	ldr	r0, [r7, #4]
 80014c2:	f00d fc90 	bl	800ede6 <little_endian_read_16>
 80014c6:	4603      	mov	r3, r0
}
 80014c8:	4618      	mov	r0, r3
 80014ca:	3708      	adds	r7, #8
 80014cc:	46bd      	mov	sp, r7
 80014ce:	bd80      	pop	{r7, pc}

080014d0 <hci_subevent_le_connection_update_complete_get_connection_handle>:
 * @brief Get field connection_handle from event HCI_SUBEVENT_LE_CONNECTION_UPDATE_COMPLETE
 * @param event packet
 * @return connection_handle
 * @note: btstack_type H
 */
static inline hci_con_handle_t hci_subevent_le_connection_update_complete_get_connection_handle(const uint8_t * event){
 80014d0:	b580      	push	{r7, lr}
 80014d2:	b082      	sub	sp, #8
 80014d4:	af00      	add	r7, sp, #0
 80014d6:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 4);
 80014d8:	2104      	movs	r1, #4
 80014da:	6878      	ldr	r0, [r7, #4]
 80014dc:	f00d fc83 	bl	800ede6 <little_endian_read_16>
 80014e0:	4603      	mov	r3, r0
}
 80014e2:	4618      	mov	r0, r3
 80014e4:	3708      	adds	r7, #8
 80014e6:	46bd      	mov	sp, r7
 80014e8:	bd80      	pop	{r7, pc}

080014ea <hci_subevent_le_connection_update_complete_get_conn_interval>:
 * @brief Get field conn_interval from event HCI_SUBEVENT_LE_CONNECTION_UPDATE_COMPLETE
 * @param event packet
 * @return conn_interval
 * @note: btstack_type 2
 */
static inline uint16_t hci_subevent_le_connection_update_complete_get_conn_interval(const uint8_t * event){
 80014ea:	b580      	push	{r7, lr}
 80014ec:	b082      	sub	sp, #8
 80014ee:	af00      	add	r7, sp, #0
 80014f0:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 6);
 80014f2:	2106      	movs	r1, #6
 80014f4:	6878      	ldr	r0, [r7, #4]
 80014f6:	f00d fc76 	bl	800ede6 <little_endian_read_16>
 80014fa:	4603      	mov	r3, r0
}
 80014fc:	4618      	mov	r0, r3
 80014fe:	3708      	adds	r7, #8
 8001500:	46bd      	mov	sp, r7
 8001502:	bd80      	pop	{r7, pc}

08001504 <hci_subevent_le_connection_update_complete_get_conn_latency>:
 * @brief Get field conn_latency from event HCI_SUBEVENT_LE_CONNECTION_UPDATE_COMPLETE
 * @param event packet
 * @return conn_latency
 * @note: btstack_type 2
 */
static inline uint16_t hci_subevent_le_connection_update_complete_get_conn_latency(const uint8_t * event){
 8001504:	b580      	push	{r7, lr}
 8001506:	b082      	sub	sp, #8
 8001508:	af00      	add	r7, sp, #0
 800150a:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 8);
 800150c:	2108      	movs	r1, #8
 800150e:	6878      	ldr	r0, [r7, #4]
 8001510:	f00d fc69 	bl	800ede6 <little_endian_read_16>
 8001514:	4603      	mov	r3, r0
}
 8001516:	4618      	mov	r0, r3
 8001518:	3708      	adds	r7, #8
 800151a:	46bd      	mov	sp, r7
 800151c:	bd80      	pop	{r7, pc}
	...

08001520 <init_connections>:

#ifdef ENABLE_GATT_OVER_CLASSIC
static uint8_t gatt_service_buffer[70];
#endif

static void init_connections(void){
 8001520:	b480      	push	{r7}
 8001522:	b083      	sub	sp, #12
 8001524:	af00      	add	r7, sp, #0
    // track connections
    int i;
    for (i=0;i<MAX_NR_CONNECTIONS;i++){
 8001526:	2300      	movs	r3, #0
 8001528:	607b      	str	r3, [r7, #4]
 800152a:	e018      	b.n	800155e <init_connections+0x3e>
        le_streamer_connections[i].connection_handle = HCI_CON_HANDLE_INVALID;
 800152c:	4a10      	ldr	r2, [pc, #64]	; (8001570 <init_connections+0x50>)
 800152e:	687b      	ldr	r3, [r7, #4]
 8001530:	21e4      	movs	r1, #228	; 0xe4
 8001532:	fb01 f303 	mul.w	r3, r1, r3
 8001536:	4413      	add	r3, r2
 8001538:	330a      	adds	r3, #10
 800153a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800153e:	801a      	strh	r2, [r3, #0]
        le_streamer_connections[i].name = 'A' + i;
 8001540:	687b      	ldr	r3, [r7, #4]
 8001542:	b2db      	uxtb	r3, r3
 8001544:	3341      	adds	r3, #65	; 0x41
 8001546:	b2d8      	uxtb	r0, r3
 8001548:	4a09      	ldr	r2, [pc, #36]	; (8001570 <init_connections+0x50>)
 800154a:	687b      	ldr	r3, [r7, #4]
 800154c:	21e4      	movs	r1, #228	; 0xe4
 800154e:	fb01 f303 	mul.w	r3, r1, r3
 8001552:	4413      	add	r3, r2
 8001554:	4602      	mov	r2, r0
 8001556:	701a      	strb	r2, [r3, #0]
    for (i=0;i<MAX_NR_CONNECTIONS;i++){
 8001558:	687b      	ldr	r3, [r7, #4]
 800155a:	3301      	adds	r3, #1
 800155c:	607b      	str	r3, [r7, #4]
 800155e:	687b      	ldr	r3, [r7, #4]
 8001560:	2b02      	cmp	r3, #2
 8001562:	dde3      	ble.n	800152c <init_connections+0xc>
    }
}
 8001564:	bf00      	nop
 8001566:	370c      	adds	r7, #12
 8001568:	46bd      	mov	sp, r7
 800156a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800156e:	4770      	bx	lr
 8001570:	20000138 	.word	0x20000138

08001574 <connection_for_conn_handle>:

static le_streamer_connection_t * connection_for_conn_handle(hci_con_handle_t conn_handle){
 8001574:	b480      	push	{r7}
 8001576:	b085      	sub	sp, #20
 8001578:	af00      	add	r7, sp, #0
 800157a:	4603      	mov	r3, r0
 800157c:	80fb      	strh	r3, [r7, #6]
    int i;
    for (i=0;i<MAX_NR_CONNECTIONS;i++){
 800157e:	2300      	movs	r3, #0
 8001580:	60fb      	str	r3, [r7, #12]
 8001582:	e014      	b.n	80015ae <connection_for_conn_handle+0x3a>
        if (le_streamer_connections[i].connection_handle == conn_handle) return &le_streamer_connections[i];
 8001584:	4a0f      	ldr	r2, [pc, #60]	; (80015c4 <connection_for_conn_handle+0x50>)
 8001586:	68fb      	ldr	r3, [r7, #12]
 8001588:	21e4      	movs	r1, #228	; 0xe4
 800158a:	fb01 f303 	mul.w	r3, r1, r3
 800158e:	4413      	add	r3, r2
 8001590:	330a      	adds	r3, #10
 8001592:	881b      	ldrh	r3, [r3, #0]
 8001594:	88fa      	ldrh	r2, [r7, #6]
 8001596:	429a      	cmp	r2, r3
 8001598:	d106      	bne.n	80015a8 <connection_for_conn_handle+0x34>
 800159a:	68fb      	ldr	r3, [r7, #12]
 800159c:	22e4      	movs	r2, #228	; 0xe4
 800159e:	fb02 f303 	mul.w	r3, r2, r3
 80015a2:	4a08      	ldr	r2, [pc, #32]	; (80015c4 <connection_for_conn_handle+0x50>)
 80015a4:	4413      	add	r3, r2
 80015a6:	e006      	b.n	80015b6 <connection_for_conn_handle+0x42>
    for (i=0;i<MAX_NR_CONNECTIONS;i++){
 80015a8:	68fb      	ldr	r3, [r7, #12]
 80015aa:	3301      	adds	r3, #1
 80015ac:	60fb      	str	r3, [r7, #12]
 80015ae:	68fb      	ldr	r3, [r7, #12]
 80015b0:	2b02      	cmp	r3, #2
 80015b2:	dde7      	ble.n	8001584 <connection_for_conn_handle+0x10>
    }
    return NULL;
 80015b4:	2300      	movs	r3, #0
}
 80015b6:	4618      	mov	r0, r3
 80015b8:	3714      	adds	r7, #20
 80015ba:	46bd      	mov	sp, r7
 80015bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80015c0:	4770      	bx	lr
 80015c2:	bf00      	nop
 80015c4:	20000138 	.word	0x20000138

080015c8 <next_connection_index>:

static void next_connection_index(void){
 80015c8:	b480      	push	{r7}
 80015ca:	af00      	add	r7, sp, #0
    connection_index++;
 80015cc:	4b08      	ldr	r3, [pc, #32]	; (80015f0 <next_connection_index+0x28>)
 80015ce:	681b      	ldr	r3, [r3, #0]
 80015d0:	3301      	adds	r3, #1
 80015d2:	4a07      	ldr	r2, [pc, #28]	; (80015f0 <next_connection_index+0x28>)
 80015d4:	6013      	str	r3, [r2, #0]
    if (connection_index == MAX_NR_CONNECTIONS){
 80015d6:	4b06      	ldr	r3, [pc, #24]	; (80015f0 <next_connection_index+0x28>)
 80015d8:	681b      	ldr	r3, [r3, #0]
 80015da:	2b03      	cmp	r3, #3
 80015dc:	d102      	bne.n	80015e4 <next_connection_index+0x1c>
        connection_index = 0;
 80015de:	4b04      	ldr	r3, [pc, #16]	; (80015f0 <next_connection_index+0x28>)
 80015e0:	2200      	movs	r2, #0
 80015e2:	601a      	str	r2, [r3, #0]
    }
}
 80015e4:	bf00      	nop
 80015e6:	46bd      	mov	sp, r7
 80015e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80015ec:	4770      	bx	lr
 80015ee:	bf00      	nop
 80015f0:	200003e4 	.word	0x200003e4

080015f4 <le_streamer_setup>:
 * and boots the Bluetooth stack.
 */

/* LISTING_START(MainConfiguration): Init L2CAP, SM, ATT Server, and enable advertisements */

static void le_streamer_setup(void){
 80015f4:	b580      	push	{r7, lr}
 80015f6:	b088      	sub	sp, #32
 80015f8:	af04      	add	r7, sp, #16

    l2cap_init();
 80015fa:	f016 ffdf 	bl	80185bc <l2cap_init>

    // setup le device db
    le_device_db_init();
 80015fe:	f01f fa19 	bl	8020a34 <le_device_db_init>

    // setup SM: Display only
    sm_init();
 8001602:	f025 fd31 	bl	8027068 <sm_init>
    gap_ssp_set_io_capability(SSP_IO_CAPABILITY_DISPLAY_YES_NO);
    gap_discoverable_control(1);
#endif

    // setup ATT server
    att_server_init(profile_data, NULL, att_write_callback);
 8001606:	4a1a      	ldr	r2, [pc, #104]	; (8001670 <le_streamer_setup+0x7c>)
 8001608:	2100      	movs	r1, #0
 800160a:	481a      	ldr	r0, [pc, #104]	; (8001674 <le_streamer_setup+0x80>)
 800160c:	f01f f88c 	bl	8020728 <att_server_init>

    // register for HCI events
    hci_event_callback_registration.callback = &hci_packet_handler;
 8001610:	4b19      	ldr	r3, [pc, #100]	; (8001678 <le_streamer_setup+0x84>)
 8001612:	4a1a      	ldr	r2, [pc, #104]	; (800167c <le_streamer_setup+0x88>)
 8001614:	605a      	str	r2, [r3, #4]
	hci_add_event_handler(&hci_event_callback_registration);
 8001616:	4818      	ldr	r0, [pc, #96]	; (8001678 <le_streamer_setup+0x84>)
 8001618:	f012 fc6c 	bl	8013ef4 <hci_add_event_handler>

    // register for ATT events
    att_server_register_packet_handler(att_packet_handler);
 800161c:	4818      	ldr	r0, [pc, #96]	; (8001680 <le_streamer_setup+0x8c>)
 800161e:	f01f f8bb 	bl	8020798 <att_server_register_packet_handler>

    // setup advertisements
    uint16_t adv_int_min = 0x0030;
 8001622:	2330      	movs	r3, #48	; 0x30
 8001624:	81fb      	strh	r3, [r7, #14]
    uint16_t adv_int_max = 0x0030;
 8001626:	2330      	movs	r3, #48	; 0x30
 8001628:	81bb      	strh	r3, [r7, #12]
    uint8_t adv_type = 0;
 800162a:	2300      	movs	r3, #0
 800162c:	72fb      	strb	r3, [r7, #11]
    bd_addr_t null_addr;
    memset(null_addr, 0, 6);
 800162e:	1d3b      	adds	r3, r7, #4
 8001630:	2206      	movs	r2, #6
 8001632:	2100      	movs	r1, #0
 8001634:	4618      	mov	r0, r3
 8001636:	f026 fa44 	bl	8027ac2 <memset>
    gap_advertisements_set_params(adv_int_min, adv_int_max, adv_type, 0, null_addr, 0x07, 0x00);
 800163a:	7afa      	ldrb	r2, [r7, #11]
 800163c:	89b9      	ldrh	r1, [r7, #12]
 800163e:	89f8      	ldrh	r0, [r7, #14]
 8001640:	2300      	movs	r3, #0
 8001642:	9302      	str	r3, [sp, #8]
 8001644:	2307      	movs	r3, #7
 8001646:	9301      	str	r3, [sp, #4]
 8001648:	1d3b      	adds	r3, r7, #4
 800164a:	9300      	str	r3, [sp, #0]
 800164c:	2300      	movs	r3, #0
 800164e:	f025 fef5 	bl	802743c <gap_advertisements_set_params>
    gap_advertisements_set_data(adv_data_len, (uint8_t*) adv_data);
 8001652:	2314      	movs	r3, #20
 8001654:	490b      	ldr	r1, [pc, #44]	; (8001684 <le_streamer_setup+0x90>)
 8001656:	4618      	mov	r0, r3
 8001658:	f015 f96e 	bl	8016938 <gap_advertisements_set_data>
    gap_advertisements_enable(1);
 800165c:	2001      	movs	r0, #1
 800165e:	f015 f9d9 	bl	8016a14 <gap_advertisements_enable>

    // init client state
    init_connections();
 8001662:	f7ff ff5d 	bl	8001520 <init_connections>
}
 8001666:	bf00      	nop
 8001668:	3710      	adds	r7, #16
 800166a:	46bd      	mov	sp, r7
 800166c:	bd80      	pop	{r7, pc}
 800166e:	bf00      	nop
 8001670:	08001aed 	.word	0x08001aed
 8001674:	080307b0 	.word	0x080307b0
 8001678:	20000130 	.word	0x20000130
 800167c:	08001739 	.word	0x08001739
 8001680:	080018c1 	.word	0x080018c1
 8001684:	08030848 	.word	0x08030848

08001688 <test_track_sent>:
static void test_reset(le_streamer_connection_t * context){
    context->test_data_start = btstack_run_loop_get_time_ms();
    context->test_data_sent = 0;
}

static void test_track_sent(le_streamer_connection_t * context, int bytes_sent){
 8001688:	b5b0      	push	{r4, r5, r7, lr}
 800168a:	b088      	sub	sp, #32
 800168c:	af02      	add	r7, sp, #8
 800168e:	6078      	str	r0, [r7, #4]
 8001690:	6039      	str	r1, [r7, #0]
    context->test_data_sent += bytes_sent;
 8001692:	687b      	ldr	r3, [r7, #4]
 8001694:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 8001698:	683b      	ldr	r3, [r7, #0]
 800169a:	441a      	add	r2, r3
 800169c:	687b      	ldr	r3, [r7, #4]
 800169e:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    // evaluate
    uint32_t now = btstack_run_loop_get_time_ms();
 80016a2:	f00d fb23 	bl	800ecec <btstack_run_loop_get_time_ms>
 80016a6:	6178      	str	r0, [r7, #20]
    uint32_t time_passed = now - context->test_data_start;
 80016a8:	687b      	ldr	r3, [r7, #4]
 80016aa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80016ae:	697a      	ldr	r2, [r7, #20]
 80016b0:	1ad3      	subs	r3, r2, r3
 80016b2:	613b      	str	r3, [r7, #16]
    if (time_passed < REPORT_INTERVAL_MS) return;
 80016b4:	693b      	ldr	r3, [r7, #16]
 80016b6:	f640 32b7 	movw	r2, #2999	; 0xbb7
 80016ba:	4293      	cmp	r3, r2
 80016bc:	d933      	bls.n	8001726 <test_track_sent+0x9e>
    // print speed
    int bytes_per_second = context->test_data_sent * 1000 / time_passed;
 80016be:	687b      	ldr	r3, [r7, #4]
 80016c0:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 80016c4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80016c8:	fb02 f203 	mul.w	r2, r2, r3
 80016cc:	693b      	ldr	r3, [r7, #16]
 80016ce:	fbb2 f3f3 	udiv	r3, r2, r3
 80016d2:	60fb      	str	r3, [r7, #12]
    printf("%c: %"PRIu32" bytes sent-> %u.%03u kB/s\n", context->name, context->test_data_sent, bytes_per_second / 1000, bytes_per_second % 1000);
 80016d4:	687b      	ldr	r3, [r7, #4]
 80016d6:	781b      	ldrb	r3, [r3, #0]
 80016d8:	461d      	mov	r5, r3
 80016da:	687b      	ldr	r3, [r7, #4]
 80016dc:	f8d3 00dc 	ldr.w	r0, [r3, #220]	; 0xdc
 80016e0:	68fb      	ldr	r3, [r7, #12]
 80016e2:	4a13      	ldr	r2, [pc, #76]	; (8001730 <test_track_sent+0xa8>)
 80016e4:	fb82 1203 	smull	r1, r2, r2, r3
 80016e8:	1192      	asrs	r2, r2, #6
 80016ea:	17db      	asrs	r3, r3, #31
 80016ec:	1ad4      	subs	r4, r2, r3
 80016ee:	68fa      	ldr	r2, [r7, #12]
 80016f0:	4b0f      	ldr	r3, [pc, #60]	; (8001730 <test_track_sent+0xa8>)
 80016f2:	fb83 1302 	smull	r1, r3, r3, r2
 80016f6:	1199      	asrs	r1, r3, #6
 80016f8:	17d3      	asrs	r3, r2, #31
 80016fa:	1acb      	subs	r3, r1, r3
 80016fc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8001700:	fb01 f303 	mul.w	r3, r1, r3
 8001704:	1ad3      	subs	r3, r2, r3
 8001706:	9300      	str	r3, [sp, #0]
 8001708:	4623      	mov	r3, r4
 800170a:	4602      	mov	r2, r0
 800170c:	4629      	mov	r1, r5
 800170e:	4809      	ldr	r0, [pc, #36]	; (8001734 <test_track_sent+0xac>)
 8001710:	f026 f9e0 	bl	8027ad4 <iprintf>

    // restart
    context->test_data_start = now;
 8001714:	687b      	ldr	r3, [r7, #4]
 8001716:	697a      	ldr	r2, [r7, #20]
 8001718:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    context->test_data_sent  = 0;
 800171c:	687b      	ldr	r3, [r7, #4]
 800171e:	2200      	movs	r2, #0
 8001720:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
 8001724:	e000      	b.n	8001728 <test_track_sent+0xa0>
    if (time_passed < REPORT_INTERVAL_MS) return;
 8001726:	bf00      	nop
}
 8001728:	3718      	adds	r7, #24
 800172a:	46bd      	mov	sp, r7
 800172c:	bdb0      	pop	{r4, r5, r7, pc}
 800172e:	bf00      	nop
 8001730:	10624dd3 	.word	0x10624dd3
 8001734:	0802898c 	.word	0x0802898c

08001738 <hci_packet_handler>:
 * in the commented code block.
 */

/* LISTING_START(hciPacketHandler): Packet Handler */
static void hci_packet_handler (uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size)
{
 8001738:	b5f0      	push	{r4, r5, r6, r7, lr}
 800173a:	b08b      	sub	sp, #44	; 0x2c
 800173c:	af04      	add	r7, sp, #16
 800173e:	60ba      	str	r2, [r7, #8]
 8001740:	461a      	mov	r2, r3
 8001742:	4603      	mov	r3, r0
 8001744:	73fb      	strb	r3, [r7, #15]
 8001746:	460b      	mov	r3, r1
 8001748:	81bb      	strh	r3, [r7, #12]
 800174a:	4613      	mov	r3, r2
 800174c:	80fb      	strh	r3, [r7, #6]
    UNUSED(channel);
    UNUSED(size);

   
   log_error("Read from 0x%04x\n",att_event_connected_get_handle(packet));
 800174e:	68b8      	ldr	r0, [r7, #8]
 8001750:	f7ff fe63 	bl	800141a <att_event_connected_get_handle>
 8001754:	4603      	mov	r3, r0
 8001756:	9300      	str	r3, [sp, #0]
 8001758:	23f4      	movs	r3, #244	; 0xf4
 800175a:	4a52      	ldr	r2, [pc, #328]	; (80018a4 <hci_packet_handler+0x16c>)
 800175c:	4952      	ldr	r1, [pc, #328]	; (80018a8 <hci_packet_handler+0x170>)
 800175e:	2002      	movs	r0, #2
 8001760:	f015 fe6e 	bl	8017440 <hci_dump_log>
	uint16_t conn_interval;
    hci_con_handle_t con_handle;


   
    if (packet_type != HCI_EVENT_PACKET) return;
 8001764:	7bfb      	ldrb	r3, [r7, #15]
 8001766:	2b04      	cmp	r3, #4
 8001768:	f040 8096 	bne.w	8001898 <hci_packet_handler+0x160>

    switch (hci_event_packet_get_type(packet)) {
 800176c:	68b8      	ldr	r0, [r7, #8]
 800176e:	f7ff fe14 	bl	800139a <hci_event_packet_get_type>
 8001772:	4603      	mov	r3, r0
 8001774:	2b3e      	cmp	r3, #62	; 0x3e
 8001776:	d027      	beq.n	80017c8 <hci_packet_handler+0x90>
 8001778:	2b60      	cmp	r3, #96	; 0x60
 800177a:	d002      	beq.n	8001782 <hci_packet_handler+0x4a>
 800177c:	2b05      	cmp	r3, #5
 800177e:	d00f      	beq.n	80017a0 <hci_packet_handler+0x68>
                    break;
            }
            break;

        default:
            break;
 8001780:	e08d      	b.n	800189e <hci_packet_handler+0x166>
            if (btstack_event_state_get_state(packet) == HCI_STATE_WORKING) {
 8001782:	68b8      	ldr	r0, [r7, #8]
 8001784:	f7ff fe3c 	bl	8001400 <btstack_event_state_get_state>
 8001788:	4603      	mov	r3, r0
 800178a:	2b02      	cmp	r3, #2
 800178c:	f040 8086 	bne.w	800189c <hci_packet_handler+0x164>
            	log_error("To start the streaming, please run the le_streamer_client example on other device, or use some GATT Explorer, e.g. LightBlue, BLExplr.\n");
 8001790:	f44f 7383 	mov.w	r3, #262	; 0x106
 8001794:	4a43      	ldr	r2, [pc, #268]	; (80018a4 <hci_packet_handler+0x16c>)
 8001796:	4945      	ldr	r1, [pc, #276]	; (80018ac <hci_packet_handler+0x174>)
 8001798:	2002      	movs	r0, #2
 800179a:	f015 fe51 	bl	8017440 <hci_dump_log>
            break;
 800179e:	e07d      	b.n	800189c <hci_packet_handler+0x164>
            con_handle = hci_event_disconnection_complete_get_connection_handle(packet);
 80017a0:	68b8      	ldr	r0, [r7, #8]
 80017a2:	f7ff fe13 	bl	80013cc <hci_event_disconnection_complete_get_connection_handle>
 80017a6:	4603      	mov	r3, r0
 80017a8:	82fb      	strh	r3, [r7, #22]
            log_error("- LE Connection %04x: disconnect, reason %02x\n", con_handle, hci_event_disconnection_complete_get_reason(packet));
 80017aa:	8afc      	ldrh	r4, [r7, #22]
 80017ac:	68b8      	ldr	r0, [r7, #8]
 80017ae:	f7ff fe1a 	bl	80013e6 <hci_event_disconnection_complete_get_reason>
 80017b2:	4603      	mov	r3, r0
 80017b4:	9301      	str	r3, [sp, #4]
 80017b6:	9400      	str	r4, [sp, #0]
 80017b8:	f240 130b 	movw	r3, #267	; 0x10b
 80017bc:	4a39      	ldr	r2, [pc, #228]	; (80018a4 <hci_packet_handler+0x16c>)
 80017be:	493c      	ldr	r1, [pc, #240]	; (80018b0 <hci_packet_handler+0x178>)
 80017c0:	2002      	movs	r0, #2
 80017c2:	f015 fe3d 	bl	8017440 <hci_dump_log>
            break;
 80017c6:	e06a      	b.n	800189e <hci_packet_handler+0x166>
            switch (hci_event_le_meta_get_subevent_code(packet)) {
 80017c8:	68b8      	ldr	r0, [r7, #8]
 80017ca:	f7ff fdf2 	bl	80013b2 <hci_event_le_meta_get_subevent_code>
 80017ce:	4603      	mov	r3, r0
 80017d0:	2b01      	cmp	r3, #1
 80017d2:	d002      	beq.n	80017da <hci_packet_handler+0xa2>
 80017d4:	2b03      	cmp	r3, #3
 80017d6:	d02f      	beq.n	8001838 <hci_packet_handler+0x100>
                    break;
 80017d8:	e05d      	b.n	8001896 <hci_packet_handler+0x15e>
                    con_handle    = hci_subevent_le_connection_complete_get_connection_handle(packet);
 80017da:	68b8      	ldr	r0, [r7, #8]
 80017dc:	f7ff fe51 	bl	8001482 <hci_subevent_le_connection_complete_get_connection_handle>
 80017e0:	4603      	mov	r3, r0
 80017e2:	82fb      	strh	r3, [r7, #22]
                    conn_interval = hci_subevent_le_connection_complete_get_conn_interval(packet);
 80017e4:	68b8      	ldr	r0, [r7, #8]
 80017e6:	f7ff fe59 	bl	800149c <hci_subevent_le_connection_complete_get_conn_interval>
 80017ea:	4603      	mov	r3, r0
 80017ec:	82bb      	strh	r3, [r7, #20]
                    log_error("- LE Connection %04x: connected - connection interval %u.%02u ms, latency %u\n", con_handle, conn_interval * 125 / 100,
 80017ee:	8afc      	ldrh	r4, [r7, #22]
 80017f0:	8aba      	ldrh	r2, [r7, #20]
 80017f2:	4613      	mov	r3, r2
 80017f4:	015b      	lsls	r3, r3, #5
 80017f6:	1a9b      	subs	r3, r3, r2
 80017f8:	009b      	lsls	r3, r3, #2
 80017fa:	4413      	add	r3, r2
 80017fc:	4a2d      	ldr	r2, [pc, #180]	; (80018b4 <hci_packet_handler+0x17c>)
 80017fe:	fb82 1203 	smull	r1, r2, r2, r3
 8001802:	1152      	asrs	r2, r2, #5
 8001804:	17db      	asrs	r3, r3, #31
 8001806:	1ad5      	subs	r5, r2, r3
 8001808:	8abb      	ldrh	r3, [r7, #20]
 800180a:	f003 0203 	and.w	r2, r3, #3
 800180e:	4613      	mov	r3, r2
 8001810:	009b      	lsls	r3, r3, #2
 8001812:	4413      	add	r3, r2
 8001814:	009a      	lsls	r2, r3, #2
 8001816:	189e      	adds	r6, r3, r2
 8001818:	68b8      	ldr	r0, [r7, #8]
 800181a:	f7ff fe4c 	bl	80014b6 <hci_subevent_le_connection_complete_get_conn_latency>
 800181e:	4603      	mov	r3, r0
 8001820:	9303      	str	r3, [sp, #12]
 8001822:	9602      	str	r6, [sp, #8]
 8001824:	9501      	str	r5, [sp, #4]
 8001826:	9400      	str	r4, [sp, #0]
 8001828:	f44f 738a 	mov.w	r3, #276	; 0x114
 800182c:	4a1d      	ldr	r2, [pc, #116]	; (80018a4 <hci_packet_handler+0x16c>)
 800182e:	4922      	ldr	r1, [pc, #136]	; (80018b8 <hci_packet_handler+0x180>)
 8001830:	2002      	movs	r0, #2
 8001832:	f015 fe05 	bl	8017440 <hci_dump_log>
                    break;
 8001836:	e02e      	b.n	8001896 <hci_packet_handler+0x15e>
                    con_handle    = hci_subevent_le_connection_update_complete_get_connection_handle(packet);
 8001838:	68b8      	ldr	r0, [r7, #8]
 800183a:	f7ff fe49 	bl	80014d0 <hci_subevent_le_connection_update_complete_get_connection_handle>
 800183e:	4603      	mov	r3, r0
 8001840:	82fb      	strh	r3, [r7, #22]
                    conn_interval = hci_subevent_le_connection_update_complete_get_conn_interval(packet);
 8001842:	68b8      	ldr	r0, [r7, #8]
 8001844:	f7ff fe51 	bl	80014ea <hci_subevent_le_connection_update_complete_get_conn_interval>
 8001848:	4603      	mov	r3, r0
 800184a:	82bb      	strh	r3, [r7, #20]
                    log_error("- LE Connection %04x: connection update - connection interval %u.%02u ms, latency %u\n", con_handle, conn_interval * 125 / 100,
 800184c:	8afc      	ldrh	r4, [r7, #22]
 800184e:	8aba      	ldrh	r2, [r7, #20]
 8001850:	4613      	mov	r3, r2
 8001852:	015b      	lsls	r3, r3, #5
 8001854:	1a9b      	subs	r3, r3, r2
 8001856:	009b      	lsls	r3, r3, #2
 8001858:	4413      	add	r3, r2
 800185a:	4a16      	ldr	r2, [pc, #88]	; (80018b4 <hci_packet_handler+0x17c>)
 800185c:	fb82 1203 	smull	r1, r2, r2, r3
 8001860:	1152      	asrs	r2, r2, #5
 8001862:	17db      	asrs	r3, r3, #31
 8001864:	1ad5      	subs	r5, r2, r3
 8001866:	8abb      	ldrh	r3, [r7, #20]
 8001868:	f003 0203 	and.w	r2, r3, #3
 800186c:	4613      	mov	r3, r2
 800186e:	009b      	lsls	r3, r3, #2
 8001870:	4413      	add	r3, r2
 8001872:	009a      	lsls	r2, r3, #2
 8001874:	189e      	adds	r6, r3, r2
 8001876:	68b8      	ldr	r0, [r7, #8]
 8001878:	f7ff fe44 	bl	8001504 <hci_subevent_le_connection_update_complete_get_conn_latency>
 800187c:	4603      	mov	r3, r0
 800187e:	9303      	str	r3, [sp, #12]
 8001880:	9602      	str	r6, [sp, #8]
 8001882:	9501      	str	r5, [sp, #4]
 8001884:	9400      	str	r4, [sp, #0]
 8001886:	f240 131f 	movw	r3, #287	; 0x11f
 800188a:	4a06      	ldr	r2, [pc, #24]	; (80018a4 <hci_packet_handler+0x16c>)
 800188c:	490b      	ldr	r1, [pc, #44]	; (80018bc <hci_packet_handler+0x184>)
 800188e:	2002      	movs	r0, #2
 8001890:	f015 fdd6 	bl	8017440 <hci_dump_log>
                    break;
 8001894:	bf00      	nop
            break;
 8001896:	e002      	b.n	800189e <hci_packet_handler+0x166>
    if (packet_type != HCI_EVENT_PACKET) return;
 8001898:	bf00      	nop
 800189a:	e000      	b.n	800189e <hci_packet_handler+0x166>
            break;
 800189c:	bf00      	nop
    }
}
 800189e:	371c      	adds	r7, #28
 80018a0:	46bd      	mov	sp, r7
 80018a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80018a4:	080289b4 	.word	0x080289b4
 80018a8:	080289cc 	.word	0x080289cc
 80018ac:	080289e8 	.word	0x080289e8
 80018b0:	08028a78 	.word	0x08028a78
 80018b4:	51eb851f 	.word	0x51eb851f
 80018b8:	08028ab0 	.word	0x08028ab0
 80018bc:	08028b08 	.word	0x08028b08

080018c0 <att_packet_handler>:
 *
 * @text The packet handler is used to track the ATT MTU Exchange and trigger ATT send
 */

/* LISTING_START(attPacketHandler): Packet Handler */
static void att_packet_handler (uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){
 80018c0:	b580      	push	{r7, lr}
 80018c2:	b086      	sub	sp, #24
 80018c4:	af00      	add	r7, sp, #0
 80018c6:	60ba      	str	r2, [r7, #8]
 80018c8:	461a      	mov	r2, r3
 80018ca:	4603      	mov	r3, r0
 80018cc:	73fb      	strb	r3, [r7, #15]
 80018ce:	460b      	mov	r3, r1
 80018d0:	81bb      	strh	r3, [r7, #12]
 80018d2:	4613      	mov	r3, r2
 80018d4:	80fb      	strh	r3, [r7, #6]
    UNUSED(size);


    int mtu;
    le_streamer_connection_t * context;
    switch (packet_type) {
 80018d6:	7bfb      	ldrb	r3, [r7, #15]
 80018d8:	2b04      	cmp	r3, #4
 80018da:	d000      	beq.n	80018de <att_packet_handler+0x1e>
                default:
                    break;
            }
            break;
        default:
            break;
 80018dc:	e091      	b.n	8001a02 <att_packet_handler+0x142>
            switch (hci_event_packet_get_type(packet)) {
 80018de:	68b8      	ldr	r0, [r7, #8]
 80018e0:	f7ff fd5b 	bl	800139a <hci_event_packet_get_type>
 80018e4:	4603      	mov	r3, r0
 80018e6:	3bb3      	subs	r3, #179	; 0xb3
 80018e8:	2b04      	cmp	r3, #4
 80018ea:	f200 8082 	bhi.w	80019f2 <att_packet_handler+0x132>
 80018ee:	a201      	add	r2, pc, #4	; (adr r2, 80018f4 <att_packet_handler+0x34>)
 80018f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80018f4:	08001909 	.word	0x08001909
 80018f8:	080019bb 	.word	0x080019bb
 80018fc:	08001967 	.word	0x08001967
 8001900:	080019f3 	.word	0x080019f3
 8001904:	080019b5 	.word	0x080019b5
                    context = connection_for_conn_handle(HCI_CON_HANDLE_INVALID);
 8001908:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800190c:	f7ff fe32 	bl	8001574 <connection_for_conn_handle>
 8001910:	6138      	str	r0, [r7, #16]
                    if (!context) break;
 8001912:	693b      	ldr	r3, [r7, #16]
 8001914:	2b00      	cmp	r3, #0
 8001916:	d06e      	beq.n	80019f6 <att_packet_handler+0x136>
                    context->counter = 'A';
 8001918:	693b      	ldr	r3, [r7, #16]
 800191a:	2241      	movs	r2, #65	; 0x41
 800191c:	60da      	str	r2, [r3, #12]
                    context->connection_handle = att_event_connected_get_handle(packet);
 800191e:	68b8      	ldr	r0, [r7, #8]
 8001920:	f7ff fd7b 	bl	800141a <att_event_connected_get_handle>
 8001924:	4603      	mov	r3, r0
 8001926:	461a      	mov	r2, r3
 8001928:	693b      	ldr	r3, [r7, #16]
 800192a:	815a      	strh	r2, [r3, #10]
                    context->test_data_len = btstack_min(att_server_get_mtu(context->connection_handle) - 3, sizeof(context->test_data));
 800192c:	693b      	ldr	r3, [r7, #16]
 800192e:	895b      	ldrh	r3, [r3, #10]
 8001930:	4618      	mov	r0, r3
 8001932:	f01e ffc0 	bl	80208b6 <att_server_get_mtu>
 8001936:	4603      	mov	r3, r0
 8001938:	3b03      	subs	r3, #3
 800193a:	21c8      	movs	r1, #200	; 0xc8
 800193c:	4618      	mov	r0, r3
 800193e:	f00d fbe6 	bl	800f10e <btstack_min>
 8001942:	4603      	mov	r3, r0
 8001944:	461a      	mov	r2, r3
 8001946:	693b      	ldr	r3, [r7, #16]
 8001948:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
                    printf("%c: ATT connected, handle %04x, test data len %u\n", context->name, context->connection_handle, context->test_data_len);
 800194c:	693b      	ldr	r3, [r7, #16]
 800194e:	781b      	ldrb	r3, [r3, #0]
 8001950:	4619      	mov	r1, r3
 8001952:	693b      	ldr	r3, [r7, #16]
 8001954:	895b      	ldrh	r3, [r3, #10]
 8001956:	461a      	mov	r2, r3
 8001958:	693b      	ldr	r3, [r7, #16]
 800195a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800195e:	482b      	ldr	r0, [pc, #172]	; (8001a0c <att_packet_handler+0x14c>)
 8001960:	f026 f8b8 	bl	8027ad4 <iprintf>
                    break;
 8001964:	e04c      	b.n	8001a00 <att_packet_handler+0x140>
                    mtu = att_event_mtu_exchange_complete_get_MTU(packet) - 3;
 8001966:	68b8      	ldr	r0, [r7, #8]
 8001968:	f7ff fd7e 	bl	8001468 <att_event_mtu_exchange_complete_get_MTU>
 800196c:	4603      	mov	r3, r0
 800196e:	3b03      	subs	r3, #3
 8001970:	617b      	str	r3, [r7, #20]
                    context = connection_for_conn_handle(att_event_mtu_exchange_complete_get_handle(packet));
 8001972:	68b8      	ldr	r0, [r7, #8]
 8001974:	f7ff fd6b 	bl	800144e <att_event_mtu_exchange_complete_get_handle>
 8001978:	4603      	mov	r3, r0
 800197a:	4618      	mov	r0, r3
 800197c:	f7ff fdfa 	bl	8001574 <connection_for_conn_handle>
 8001980:	6138      	str	r0, [r7, #16]
                    if (!context) break;
 8001982:	693b      	ldr	r3, [r7, #16]
 8001984:	2b00      	cmp	r3, #0
 8001986:	d038      	beq.n	80019fa <att_packet_handler+0x13a>
                    context->test_data_len = btstack_min(mtu - 3, sizeof(context->test_data));
 8001988:	697b      	ldr	r3, [r7, #20]
 800198a:	3b03      	subs	r3, #3
 800198c:	21c8      	movs	r1, #200	; 0xc8
 800198e:	4618      	mov	r0, r3
 8001990:	f00d fbbd 	bl	800f10e <btstack_min>
 8001994:	4603      	mov	r3, r0
 8001996:	461a      	mov	r2, r3
 8001998:	693b      	ldr	r3, [r7, #16]
 800199a:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
                    printf("%c: ATT MTU = %u => use test data of len %u\n", context->name, mtu, context->test_data_len);
 800199e:	693b      	ldr	r3, [r7, #16]
 80019a0:	781b      	ldrb	r3, [r3, #0]
 80019a2:	4619      	mov	r1, r3
 80019a4:	693b      	ldr	r3, [r7, #16]
 80019a6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 80019aa:	697a      	ldr	r2, [r7, #20]
 80019ac:	4818      	ldr	r0, [pc, #96]	; (8001a10 <att_packet_handler+0x150>)
 80019ae:	f026 f891 	bl	8027ad4 <iprintf>
                    break;
 80019b2:	e025      	b.n	8001a00 <att_packet_handler+0x140>
                    streamer();
 80019b4:	f000 f830 	bl	8001a18 <streamer>
                    break;
 80019b8:	e022      	b.n	8001a00 <att_packet_handler+0x140>
                    context = connection_for_conn_handle(att_event_disconnected_get_handle(packet));
 80019ba:	68b8      	ldr	r0, [r7, #8]
 80019bc:	f7ff fd3a 	bl	8001434 <att_event_disconnected_get_handle>
 80019c0:	4603      	mov	r3, r0
 80019c2:	4618      	mov	r0, r3
 80019c4:	f7ff fdd6 	bl	8001574 <connection_for_conn_handle>
 80019c8:	6138      	str	r0, [r7, #16]
                    if (!context) break;
 80019ca:	693b      	ldr	r3, [r7, #16]
 80019cc:	2b00      	cmp	r3, #0
 80019ce:	d016      	beq.n	80019fe <att_packet_handler+0x13e>
                    printf("%c: ATT disconnected, handle %04x\n", context->name, context->connection_handle);
 80019d0:	693b      	ldr	r3, [r7, #16]
 80019d2:	781b      	ldrb	r3, [r3, #0]
 80019d4:	4619      	mov	r1, r3
 80019d6:	693b      	ldr	r3, [r7, #16]
 80019d8:	895b      	ldrh	r3, [r3, #10]
 80019da:	461a      	mov	r2, r3
 80019dc:	480d      	ldr	r0, [pc, #52]	; (8001a14 <att_packet_handler+0x154>)
 80019de:	f026 f879 	bl	8027ad4 <iprintf>
                    context->le_notification_enabled = 0;
 80019e2:	693b      	ldr	r3, [r7, #16]
 80019e4:	2200      	movs	r2, #0
 80019e6:	605a      	str	r2, [r3, #4]
                    context->connection_handle = HCI_CON_HANDLE_INVALID;
 80019e8:	693b      	ldr	r3, [r7, #16]
 80019ea:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80019ee:	815a      	strh	r2, [r3, #10]
                    break;
 80019f0:	e006      	b.n	8001a00 <att_packet_handler+0x140>
                    break;
 80019f2:	bf00      	nop
 80019f4:	e004      	b.n	8001a00 <att_packet_handler+0x140>
                    if (!context) break;
 80019f6:	bf00      	nop
 80019f8:	e002      	b.n	8001a00 <att_packet_handler+0x140>
                    if (!context) break;
 80019fa:	bf00      	nop
 80019fc:	e000      	b.n	8001a00 <att_packet_handler+0x140>
                    if (!context) break;
 80019fe:	bf00      	nop
            break;
 8001a00:	bf00      	nop
    }
}
 8001a02:	bf00      	nop
 8001a04:	3718      	adds	r7, #24
 8001a06:	46bd      	mov	sp, r7
 8001a08:	bd80      	pop	{r7, pc}
 8001a0a:	bf00      	nop
 8001a0c:	08028b68 	.word	0x08028b68
 8001a10:	08028b9c 	.word	0x08028b9c
 8001a14:	08028bcc 	.word	0x08028bcc

08001a18 <streamer>:
 * @text The streamer function checks if notifications are enabled and if a notification can be sent now.
 * It creates some test data - a single letter that gets increased every time - and tracks the data sent.
 */

 /* LISTING_START(streamer): Streaming code */
static void streamer(void){
 8001a18:	b580      	push	{r7, lr}
 8001a1a:	b082      	sub	sp, #8
 8001a1c:	af00      	add	r7, sp, #0


    // find next active streaming connection
    int old_connection_index = connection_index;
 8001a1e:	4b31      	ldr	r3, [pc, #196]	; (8001ae4 <streamer+0xcc>)
 8001a20:	681b      	ldr	r3, [r3, #0]
 8001a22:	607b      	str	r3, [r7, #4]
    while (1){
        // active found?
        if ((le_streamer_connections[connection_index].connection_handle != HCI_CON_HANDLE_INVALID) &&
 8001a24:	4b2f      	ldr	r3, [pc, #188]	; (8001ae4 <streamer+0xcc>)
 8001a26:	681b      	ldr	r3, [r3, #0]
 8001a28:	4a2f      	ldr	r2, [pc, #188]	; (8001ae8 <streamer+0xd0>)
 8001a2a:	21e4      	movs	r1, #228	; 0xe4
 8001a2c:	fb01 f303 	mul.w	r3, r1, r3
 8001a30:	4413      	add	r3, r2
 8001a32:	330a      	adds	r3, #10
 8001a34:	881b      	ldrh	r3, [r3, #0]
 8001a36:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001a3a:	4293      	cmp	r3, r2
 8001a3c:	d00a      	beq.n	8001a54 <streamer+0x3c>
            (le_streamer_connections[connection_index].le_notification_enabled)) break;
 8001a3e:	4b29      	ldr	r3, [pc, #164]	; (8001ae4 <streamer+0xcc>)
 8001a40:	681b      	ldr	r3, [r3, #0]
 8001a42:	4a29      	ldr	r2, [pc, #164]	; (8001ae8 <streamer+0xd0>)
 8001a44:	21e4      	movs	r1, #228	; 0xe4
 8001a46:	fb01 f303 	mul.w	r3, r1, r3
 8001a4a:	4413      	add	r3, r2
 8001a4c:	3304      	adds	r3, #4
 8001a4e:	681b      	ldr	r3, [r3, #0]
        if ((le_streamer_connections[connection_index].connection_handle != HCI_CON_HANDLE_INVALID) &&
 8001a50:	2b00      	cmp	r3, #0
 8001a52:	d107      	bne.n	8001a64 <streamer+0x4c>

        // check next
        next_connection_index();
 8001a54:	f7ff fdb8 	bl	80015c8 <next_connection_index>

        // none found
        if (connection_index == old_connection_index) return;
 8001a58:	4b22      	ldr	r3, [pc, #136]	; (8001ae4 <streamer+0xcc>)
 8001a5a:	681b      	ldr	r3, [r3, #0]
 8001a5c:	687a      	ldr	r2, [r7, #4]
 8001a5e:	429a      	cmp	r2, r3
 8001a60:	d03c      	beq.n	8001adc <streamer+0xc4>
        if ((le_streamer_connections[connection_index].connection_handle != HCI_CON_HANDLE_INVALID) &&
 8001a62:	e7df      	b.n	8001a24 <streamer+0xc>
            (le_streamer_connections[connection_index].le_notification_enabled)) break;
 8001a64:	bf00      	nop
    }

    le_streamer_connection_t * context = &le_streamer_connections[connection_index];
 8001a66:	4b1f      	ldr	r3, [pc, #124]	; (8001ae4 <streamer+0xcc>)
 8001a68:	681b      	ldr	r3, [r3, #0]
 8001a6a:	22e4      	movs	r2, #228	; 0xe4
 8001a6c:	fb02 f303 	mul.w	r3, r2, r3
 8001a70:	4a1d      	ldr	r2, [pc, #116]	; (8001ae8 <streamer+0xd0>)
 8001a72:	4413      	add	r3, r2
 8001a74:	603b      	str	r3, [r7, #0]

    // create test data
    context->counter++;
 8001a76:	683b      	ldr	r3, [r7, #0]
 8001a78:	68db      	ldr	r3, [r3, #12]
 8001a7a:	1c5a      	adds	r2, r3, #1
 8001a7c:	683b      	ldr	r3, [r7, #0]
 8001a7e:	60da      	str	r2, [r3, #12]
    if (context->counter > 'Z') context->counter = 'A';
 8001a80:	683b      	ldr	r3, [r7, #0]
 8001a82:	68db      	ldr	r3, [r3, #12]
 8001a84:	2b5a      	cmp	r3, #90	; 0x5a
 8001a86:	dd02      	ble.n	8001a8e <streamer+0x76>
 8001a88:	683b      	ldr	r3, [r7, #0]
 8001a8a:	2241      	movs	r2, #65	; 0x41
 8001a8c:	60da      	str	r2, [r3, #12]
    memset(context->test_data, context->counter, context->test_data_len);
 8001a8e:	683b      	ldr	r3, [r7, #0]
 8001a90:	f103 0010 	add.w	r0, r3, #16
 8001a94:	683b      	ldr	r3, [r7, #0]
 8001a96:	68d9      	ldr	r1, [r3, #12]
 8001a98:	683b      	ldr	r3, [r7, #0]
 8001a9a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8001a9e:	461a      	mov	r2, r3
 8001aa0:	f026 f80f 	bl	8027ac2 <memset>

    // send
    att_server_notify(context->connection_handle, context->value_handle, (uint8_t*) context->test_data, context->test_data_len);
 8001aa4:	683b      	ldr	r3, [r7, #0]
 8001aa6:	8958      	ldrh	r0, [r3, #10]
 8001aa8:	683b      	ldr	r3, [r7, #0]
 8001aaa:	8919      	ldrh	r1, [r3, #8]
 8001aac:	683b      	ldr	r3, [r7, #0]
 8001aae:	f103 0210 	add.w	r2, r3, #16
 8001ab2:	683b      	ldr	r3, [r7, #0]
 8001ab4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8001ab8:	b29b      	uxth	r3, r3
 8001aba:	f01e febc 	bl	8020836 <att_server_notify>

    // track
    test_track_sent(context, context->test_data_len);
 8001abe:	683b      	ldr	r3, [r7, #0]
 8001ac0:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8001ac4:	4619      	mov	r1, r3
 8001ac6:	6838      	ldr	r0, [r7, #0]
 8001ac8:	f7ff fdde 	bl	8001688 <test_track_sent>

    // request next send event
    att_server_request_can_send_now_event(context->connection_handle);
 8001acc:	683b      	ldr	r3, [r7, #0]
 8001ace:	895b      	ldrh	r3, [r3, #10]
 8001ad0:	4618      	mov	r0, r3
 8001ad2:	f01e fe71 	bl	80207b8 <att_server_request_can_send_now_event>

    // check next
    next_connection_index();
 8001ad6:	f7ff fd77 	bl	80015c8 <next_connection_index>
 8001ada:	e000      	b.n	8001ade <streamer+0xc6>
        if (connection_index == old_connection_index) return;
 8001adc:	bf00      	nop
}
 8001ade:	3708      	adds	r7, #8
 8001ae0:	46bd      	mov	sp, r7
 8001ae2:	bd80      	pop	{r7, pc}
 8001ae4:	200003e4 	.word	0x200003e4
 8001ae8:	20000138 	.word	0x20000138

08001aec <att_write_callback>:
 * and indication. If the ATT handle matches the client configuration handle, the new configuration value is stored.
 * If notifications get enabled, an ATT_EVENT_CAN_SEND_NOW is requested. See Listing attWrite.
 */

/* LISTING_START(attWrite): ATT Write */
static int att_write_callback(hci_con_handle_t con_handle, uint16_t att_handle, uint16_t transaction_mode, uint16_t offset, uint8_t *buffer, uint16_t buffer_size){
 8001aec:	b590      	push	{r4, r7, lr}
 8001aee:	b087      	sub	sp, #28
 8001af0:	af02      	add	r7, sp, #8
 8001af2:	4604      	mov	r4, r0
 8001af4:	4608      	mov	r0, r1
 8001af6:	4611      	mov	r1, r2
 8001af8:	461a      	mov	r2, r3
 8001afa:	4623      	mov	r3, r4
 8001afc:	80fb      	strh	r3, [r7, #6]
 8001afe:	4603      	mov	r3, r0
 8001b00:	80bb      	strh	r3, [r7, #4]
 8001b02:	460b      	mov	r3, r1
 8001b04:	807b      	strh	r3, [r7, #2]
 8001b06:	4613      	mov	r3, r2
 8001b08:	803b      	strh	r3, [r7, #0]

   
    //log_error("Write to 0x%04x, value 0x%04u\n", att_handle, hci_event_packet_get_type(buffer));
  

    if (transaction_mode != ATT_TRANSACTION_MODE_NONE) return 0;
 8001b0a:	887b      	ldrh	r3, [r7, #2]
 8001b0c:	2b00      	cmp	r3, #0
 8001b0e:	d001      	beq.n	8001b14 <att_write_callback+0x28>
 8001b10:	2300      	movs	r3, #0
 8001b12:	e02d      	b.n	8001b70 <att_write_callback+0x84>
    le_streamer_connection_t * context = connection_for_conn_handle(con_handle);
 8001b14:	88fb      	ldrh	r3, [r7, #6]
 8001b16:	4618      	mov	r0, r3
 8001b18:	f7ff fd2c 	bl	8001574 <connection_for_conn_handle>
 8001b1c:	60f8      	str	r0, [r7, #12]


    switch(att_handle){
 8001b1e:	88bb      	ldrh	r3, [r7, #4]
 8001b20:	2b09      	cmp	r3, #9
 8001b22:	d002      	beq.n	8001b2a <att_write_callback+0x3e>
 8001b24:	2b0f      	cmp	r3, #15
 8001b26:	d011      	beq.n	8001b4c <att_write_callback+0x60>
        	log_error("Write to 0x%04x, value 0x%04u\n", att_handle, hci_event_packet_get_type(buffer));
        	led_blink();
        	break;

        default:
        	break;
 8001b28:	e021      	b.n	8001b6e <att_write_callback+0x82>
        	log_error("Write to 0x%04x, value 0x%04u\n", att_handle, hci_event_packet_get_type(buffer));
 8001b2a:	88bc      	ldrh	r4, [r7, #4]
 8001b2c:	6a38      	ldr	r0, [r7, #32]
 8001b2e:	f7ff fc34 	bl	800139a <hci_event_packet_get_type>
 8001b32:	4603      	mov	r3, r0
 8001b34:	9301      	str	r3, [sp, #4]
 8001b36:	9400      	str	r4, [sp, #0]
 8001b38:	f44f 73d4 	mov.w	r3, #424	; 0x1a8
 8001b3c:	4a0e      	ldr	r2, [pc, #56]	; (8001b78 <att_write_callback+0x8c>)
 8001b3e:	490f      	ldr	r1, [pc, #60]	; (8001b7c <att_write_callback+0x90>)
 8001b40:	2002      	movs	r0, #2
 8001b42:	f015 fc7d 	bl	8017440 <hci_dump_log>
        	led_blink();
 8001b46:	f000 f81b 	bl	8001b80 <led_blink>
        	break;
 8001b4a:	e010      	b.n	8001b6e <att_write_callback+0x82>
        	log_error("Write to 0x%04x, value 0x%04u\n", att_handle, hci_event_packet_get_type(buffer));
 8001b4c:	88bc      	ldrh	r4, [r7, #4]
 8001b4e:	6a38      	ldr	r0, [r7, #32]
 8001b50:	f7ff fc23 	bl	800139a <hci_event_packet_get_type>
 8001b54:	4603      	mov	r3, r0
 8001b56:	9301      	str	r3, [sp, #4]
 8001b58:	9400      	str	r4, [sp, #0]
 8001b5a:	f240 13ad 	movw	r3, #429	; 0x1ad
 8001b5e:	4a06      	ldr	r2, [pc, #24]	; (8001b78 <att_write_callback+0x8c>)
 8001b60:	4906      	ldr	r1, [pc, #24]	; (8001b7c <att_write_callback+0x90>)
 8001b62:	2002      	movs	r0, #2
 8001b64:	f015 fc6c 	bl	8017440 <hci_dump_log>
        	led_blink();
 8001b68:	f000 f80a 	bl	8001b80 <led_blink>
        	break;
 8001b6c:	bf00      	nop
    }
    return 0;
 8001b6e:	2300      	movs	r3, #0
}
 8001b70:	4618      	mov	r0, r3
 8001b72:	3714      	adds	r7, #20
 8001b74:	46bd      	mov	sp, r7
 8001b76:	bd90      	pop	{r4, r7, pc}
 8001b78:	080289b4 	.word	0x080289b4
 8001b7c:	08028bf0 	.word	0x08028bf0

08001b80 <led_blink>:
/* LISTING_END */
void led_blink()
{
 8001b80:	b590      	push	{r4, r7, lr}
 8001b82:	b089      	sub	sp, #36	; 0x24
 8001b84:	af00      	add	r7, sp, #0
	// LED-1 PA_5 D-13



	__HAL_RCC_GPIOA_CLK_ENABLE();
 8001b86:	2300      	movs	r3, #0
 8001b88:	603b      	str	r3, [r7, #0]
 8001b8a:	4b1b      	ldr	r3, [pc, #108]	; (8001bf8 <led_blink+0x78>)
 8001b8c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001b8e:	4a1a      	ldr	r2, [pc, #104]	; (8001bf8 <led_blink+0x78>)
 8001b90:	f043 0301 	orr.w	r3, r3, #1
 8001b94:	6313      	str	r3, [r2, #48]	; 0x30
 8001b96:	4b18      	ldr	r3, [pc, #96]	; (8001bf8 <led_blink+0x78>)
 8001b98:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001b9a:	f003 0301 	and.w	r3, r3, #1
 8001b9e:	603b      	str	r3, [r7, #0]
 8001ba0:	683b      	ldr	r3, [r7, #0]
		GPIO_InitTypeDef BoardLEDs;
		BoardLEDs.Mode = GPIO_MODE_OUTPUT_PP;
 8001ba2:	2301      	movs	r3, #1
 8001ba4:	60bb      	str	r3, [r7, #8]
		BoardLEDs.Pin = GPIO_PIN_5;
 8001ba6:	2320      	movs	r3, #32
 8001ba8:	607b      	str	r3, [r7, #4]
		BoardLEDs.Pull = GPIO_NOPULL;
 8001baa:	2300      	movs	r3, #0
 8001bac:	60fb      	str	r3, [r7, #12]
		HAL_GPIO_Init(GPIOA, &BoardLEDs);
 8001bae:	1d3b      	adds	r3, r7, #4
 8001bb0:	4619      	mov	r1, r3
 8001bb2:	4812      	ldr	r0, [pc, #72]	; (8001bfc <led_blink+0x7c>)
 8001bb4:	f001 f9f6 	bl	8002fa4 <HAL_GPIO_Init>
		uint64_t i=0;
 8001bb8:	f04f 0300 	mov.w	r3, #0
 8001bbc:	f04f 0400 	mov.w	r4, #0
 8001bc0:	e9c7 3406 	strd	r3, r4, [r7, #24]
		while(i<2)
 8001bc4:	e00e      	b.n	8001be4 <led_blink+0x64>
		{
			HAL_GPIO_TogglePin (GPIOA, GPIO_PIN_5);
 8001bc6:	2120      	movs	r1, #32
 8001bc8:	480c      	ldr	r0, [pc, #48]	; (8001bfc <led_blink+0x7c>)
 8001bca:	f001 fb86 	bl	80032da <HAL_GPIO_TogglePin>
			//HAL_GPIO_WritePin(GPIOA,, GPIO_PIN_SET);
			HAL_Delay(500);
 8001bce:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8001bd2:	f000 fa5f 	bl	8002094 <HAL_Delay>
			i++;
 8001bd6:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 8001bda:	1c59      	adds	r1, r3, #1
 8001bdc:	f144 0200 	adc.w	r2, r4, #0
 8001be0:	e9c7 1206 	strd	r1, r2, [r7, #24]
		while(i<2)
 8001be4:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 8001be8:	2c00      	cmp	r4, #0
 8001bea:	bf08      	it	eq
 8001bec:	2b02      	cmpeq	r3, #2
 8001bee:	d3ea      	bcc.n	8001bc6 <led_blink+0x46>

		}
}
 8001bf0:	bf00      	nop
 8001bf2:	3724      	adds	r7, #36	; 0x24
 8001bf4:	46bd      	mov	sp, r7
 8001bf6:	bd90      	pop	{r4, r7, pc}
 8001bf8:	40023800 	.word	0x40023800
 8001bfc:	40020000 	.word	0x40020000

08001c00 <btstack_main>:
int btstack_main(void);
int btstack_main(void)
{
 8001c00:	b580      	push	{r7, lr}
 8001c02:	af00      	add	r7, sp, #0
    le_streamer_setup();
 8001c04:	f7ff fcf6 	bl	80015f4 <le_streamer_setup>

    // turn on!
	hci_power_control(HCI_POWER_ON);
 8001c08:	2001      	movs	r0, #1
 8001c0a:	f012 fcff 	bl	801460c <hci_power_control>


    return 0;
 8001c0e:	2300      	movs	r3, #0
}
 8001c10:	4618      	mov	r0, r3
 8001c12:	bd80      	pop	{r7, pc}

08001c14 <hal_cpu_disable_irqs>:
// hal_cpu.h implementation
#include "hal_cpu.h"
#include "cmsis_gcc.h"
void hal_cpu_disable_irqs(void){
 8001c14:	b480      	push	{r7}
 8001c16:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c18:	b672      	cpsid	i
    __disable_irq();
}
 8001c1a:	bf00      	nop
 8001c1c:	46bd      	mov	sp, r7
 8001c1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c22:	4770      	bx	lr

08001c24 <hal_cpu_enable_irqs>:

void hal_cpu_enable_irqs(void){
 8001c24:	b480      	push	{r7}
 8001c26:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsie i" : : : "memory");
 8001c28:	b662      	cpsie	i
    __enable_irq();
}
 8001c2a:	bf00      	nop
 8001c2c:	46bd      	mov	sp, r7
 8001c2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c32:	4770      	bx	lr

08001c34 <hal_cpu_enable_irqs_and_sleep>:

void hal_cpu_enable_irqs_and_sleep(void){
 8001c34:	b480      	push	{r7}
 8001c36:	af00      	add	r7, sp, #0
 8001c38:	b662      	cpsie	i
    __enable_irq();
    __asm__("wfe"); // go to sleep if event flag isn't set. if set, just clear it. IRQs set event flag
 8001c3a:	bf20      	wfe
}
 8001c3c:	bf00      	nop
 8001c3e:	46bd      	mov	sp, r7
 8001c40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c44:	4770      	bx	lr

08001c46 <hal_flash_bank_stm32_get_size>:
#include <string.h> // memcpy

#include "hal_flash_bank_stm32.h"
#include "stm32f4xx_hal.h"

static uint32_t hal_flash_bank_stm32_get_size(void * context){
 8001c46:	b480      	push	{r7}
 8001c48:	b085      	sub	sp, #20
 8001c4a:	af00      	add	r7, sp, #0
 8001c4c:	6078      	str	r0, [r7, #4]
	hal_flash_bank_stm32_t * self = (hal_flash_bank_stm32_t *) context;
 8001c4e:	687b      	ldr	r3, [r7, #4]
 8001c50:	60fb      	str	r3, [r7, #12]
	return self->sector_size;
 8001c52:	68fb      	ldr	r3, [r7, #12]
 8001c54:	681b      	ldr	r3, [r3, #0]
}
 8001c56:	4618      	mov	r0, r3
 8001c58:	3714      	adds	r7, #20
 8001c5a:	46bd      	mov	sp, r7
 8001c5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c60:	4770      	bx	lr

08001c62 <hal_flash_bank_memory_get_alignment>:

static uint32_t hal_flash_bank_memory_get_alignment(void * context){
 8001c62:	b480      	push	{r7}
 8001c64:	b083      	sub	sp, #12
 8001c66:	af00      	add	r7, sp, #0
 8001c68:	6078      	str	r0, [r7, #4]
    UNUSED(context);
    return 1;
 8001c6a:	2301      	movs	r3, #1
}
 8001c6c:	4618      	mov	r0, r3
 8001c6e:	370c      	adds	r7, #12
 8001c70:	46bd      	mov	sp, r7
 8001c72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c76:	4770      	bx	lr

08001c78 <hal_flash_bank_stm32_erase>:

static void hal_flash_bank_stm32_erase(void * context, int bank){
 8001c78:	b580      	push	{r7, lr}
 8001c7a:	b08a      	sub	sp, #40	; 0x28
 8001c7c:	af00      	add	r7, sp, #0
 8001c7e:	6078      	str	r0, [r7, #4]
 8001c80:	6039      	str	r1, [r7, #0]
	hal_flash_bank_stm32_t * self = (hal_flash_bank_stm32_t *) context;
 8001c82:	687b      	ldr	r3, [r7, #4]
 8001c84:	627b      	str	r3, [r7, #36]	; 0x24
	if (bank > 1) return;
 8001c86:	683b      	ldr	r3, [r7, #0]
 8001c88:	2b01      	cmp	r3, #1
 8001c8a:	dc18      	bgt.n	8001cbe <hal_flash_bank_stm32_erase+0x46>
	FLASH_EraseInitTypeDef eraseInit;
	eraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
 8001c8c:	2300      	movs	r3, #0
 8001c8e:	613b      	str	r3, [r7, #16]
	eraseInit.Sector = self->sectors[bank];
 8001c90:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001c92:	683b      	ldr	r3, [r7, #0]
 8001c94:	009b      	lsls	r3, r3, #2
 8001c96:	4413      	add	r3, r2
 8001c98:	685b      	ldr	r3, [r3, #4]
 8001c9a:	61bb      	str	r3, [r7, #24]
	eraseInit.NbSectors = 1;
 8001c9c:	2301      	movs	r3, #1
 8001c9e:	61fb      	str	r3, [r7, #28]
	eraseInit.VoltageRange = FLASH_VOLTAGE_RANGE_1;	// safe value
 8001ca0:	2300      	movs	r3, #0
 8001ca2:	623b      	str	r3, [r7, #32]
	uint32_t sectorError;
	HAL_FLASH_Unlock();
 8001ca4:	f000 feec 	bl	8002a80 <HAL_FLASH_Unlock>
	HAL_FLASHEx_Erase(&eraseInit, &sectorError);
 8001ca8:	f107 020c 	add.w	r2, r7, #12
 8001cac:	f107 0310 	add.w	r3, r7, #16
 8001cb0:	4611      	mov	r1, r2
 8001cb2:	4618      	mov	r0, r3
 8001cb4:	f001 f854 	bl	8002d60 <HAL_FLASHEx_Erase>
	HAL_FLASH_Lock();
 8001cb8:	f000 ff04 	bl	8002ac4 <HAL_FLASH_Lock>
 8001cbc:	e000      	b.n	8001cc0 <hal_flash_bank_stm32_erase+0x48>
	if (bank > 1) return;
 8001cbe:	bf00      	nop
}
 8001cc0:	3728      	adds	r7, #40	; 0x28
 8001cc2:	46bd      	mov	sp, r7
 8001cc4:	bd80      	pop	{r7, pc}

08001cc6 <hal_flash_bank_stm32_read>:

static void hal_flash_bank_stm32_read(void * context, int bank, uint32_t offset, uint8_t * buffer, uint32_t size){
 8001cc6:	b580      	push	{r7, lr}
 8001cc8:	b086      	sub	sp, #24
 8001cca:	af00      	add	r7, sp, #0
 8001ccc:	60f8      	str	r0, [r7, #12]
 8001cce:	60b9      	str	r1, [r7, #8]
 8001cd0:	607a      	str	r2, [r7, #4]
 8001cd2:	603b      	str	r3, [r7, #0]
	hal_flash_bank_stm32_t * self = (hal_flash_bank_stm32_t *) context;
 8001cd4:	68fb      	ldr	r3, [r7, #12]
 8001cd6:	617b      	str	r3, [r7, #20]

	if (bank > 1) return;
 8001cd8:	68bb      	ldr	r3, [r7, #8]
 8001cda:	2b01      	cmp	r3, #1
 8001cdc:	dc19      	bgt.n	8001d12 <hal_flash_bank_stm32_read+0x4c>
	if (offset > self->sector_size) return;
 8001cde:	697b      	ldr	r3, [r7, #20]
 8001ce0:	681b      	ldr	r3, [r3, #0]
 8001ce2:	687a      	ldr	r2, [r7, #4]
 8001ce4:	429a      	cmp	r2, r3
 8001ce6:	d816      	bhi.n	8001d16 <hal_flash_bank_stm32_read+0x50>
	if ((offset + size) > self->sector_size) return;
 8001ce8:	687a      	ldr	r2, [r7, #4]
 8001cea:	6a3b      	ldr	r3, [r7, #32]
 8001cec:	441a      	add	r2, r3
 8001cee:	697b      	ldr	r3, [r7, #20]
 8001cf0:	681b      	ldr	r3, [r3, #0]
 8001cf2:	429a      	cmp	r2, r3
 8001cf4:	d811      	bhi.n	8001d1a <hal_flash_bank_stm32_read+0x54>

	memcpy(buffer, ((uint8_t *) self->banks[bank]) + offset, size);
 8001cf6:	697a      	ldr	r2, [r7, #20]
 8001cf8:	68bb      	ldr	r3, [r7, #8]
 8001cfa:	3302      	adds	r3, #2
 8001cfc:	009b      	lsls	r3, r3, #2
 8001cfe:	4413      	add	r3, r2
 8001d00:	685a      	ldr	r2, [r3, #4]
 8001d02:	687b      	ldr	r3, [r7, #4]
 8001d04:	4413      	add	r3, r2
 8001d06:	6a3a      	ldr	r2, [r7, #32]
 8001d08:	4619      	mov	r1, r3
 8001d0a:	6838      	ldr	r0, [r7, #0]
 8001d0c:	f025 feb5 	bl	8027a7a <memcpy>
 8001d10:	e004      	b.n	8001d1c <hal_flash_bank_stm32_read+0x56>
	if (bank > 1) return;
 8001d12:	bf00      	nop
 8001d14:	e002      	b.n	8001d1c <hal_flash_bank_stm32_read+0x56>
	if (offset > self->sector_size) return;
 8001d16:	bf00      	nop
 8001d18:	e000      	b.n	8001d1c <hal_flash_bank_stm32_read+0x56>
	if ((offset + size) > self->sector_size) return;
 8001d1a:	bf00      	nop
}
 8001d1c:	3718      	adds	r7, #24
 8001d1e:	46bd      	mov	sp, r7
 8001d20:	bd80      	pop	{r7, pc}

08001d22 <hal_flash_bank_stm32_write>:

static void hal_flash_bank_stm32_write(void * context, int bank, uint32_t offset, const uint8_t * data, uint32_t size){
 8001d22:	b590      	push	{r4, r7, lr}
 8001d24:	b087      	sub	sp, #28
 8001d26:	af00      	add	r7, sp, #0
 8001d28:	60f8      	str	r0, [r7, #12]
 8001d2a:	60b9      	str	r1, [r7, #8]
 8001d2c:	607a      	str	r2, [r7, #4]
 8001d2e:	603b      	str	r3, [r7, #0]
	hal_flash_bank_stm32_t * self = (hal_flash_bank_stm32_t *) context;
 8001d30:	68fb      	ldr	r3, [r7, #12]
 8001d32:	613b      	str	r3, [r7, #16]

	if (bank > 1) return;
 8001d34:	68bb      	ldr	r3, [r7, #8]
 8001d36:	2b01      	cmp	r3, #1
 8001d38:	dc30      	bgt.n	8001d9c <hal_flash_bank_stm32_write+0x7a>
	if (offset > self->sector_size) return;
 8001d3a:	693b      	ldr	r3, [r7, #16]
 8001d3c:	681b      	ldr	r3, [r3, #0]
 8001d3e:	687a      	ldr	r2, [r7, #4]
 8001d40:	429a      	cmp	r2, r3
 8001d42:	d82d      	bhi.n	8001da0 <hal_flash_bank_stm32_write+0x7e>
	if ((offset + size) > self->sector_size) return;
 8001d44:	687a      	ldr	r2, [r7, #4]
 8001d46:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001d48:	441a      	add	r2, r3
 8001d4a:	693b      	ldr	r3, [r7, #16]
 8001d4c:	681b      	ldr	r3, [r3, #0]
 8001d4e:	429a      	cmp	r2, r3
 8001d50:	d828      	bhi.n	8001da4 <hal_flash_bank_stm32_write+0x82>

	unsigned int i;
	HAL_FLASH_Unlock();
 8001d52:	f000 fe95 	bl	8002a80 <HAL_FLASH_Unlock>
	for (i=0;i<size;i++){
 8001d56:	2300      	movs	r3, #0
 8001d58:	617b      	str	r3, [r7, #20]
 8001d5a:	e018      	b.n	8001d8e <hal_flash_bank_stm32_write+0x6c>
		HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, self->banks[bank] + offset +i, data[i]);
 8001d5c:	693a      	ldr	r2, [r7, #16]
 8001d5e:	68bb      	ldr	r3, [r7, #8]
 8001d60:	3302      	adds	r3, #2
 8001d62:	009b      	lsls	r3, r3, #2
 8001d64:	4413      	add	r3, r2
 8001d66:	685a      	ldr	r2, [r3, #4]
 8001d68:	687b      	ldr	r3, [r7, #4]
 8001d6a:	441a      	add	r2, r3
 8001d6c:	697b      	ldr	r3, [r7, #20]
 8001d6e:	18d1      	adds	r1, r2, r3
 8001d70:	683a      	ldr	r2, [r7, #0]
 8001d72:	697b      	ldr	r3, [r7, #20]
 8001d74:	4413      	add	r3, r2
 8001d76:	781b      	ldrb	r3, [r3, #0]
 8001d78:	b2db      	uxtb	r3, r3
 8001d7a:	f04f 0400 	mov.w	r4, #0
 8001d7e:	461a      	mov	r2, r3
 8001d80:	4623      	mov	r3, r4
 8001d82:	2000      	movs	r0, #0
 8001d84:	f000 fe28 	bl	80029d8 <HAL_FLASH_Program>
	for (i=0;i<size;i++){
 8001d88:	697b      	ldr	r3, [r7, #20]
 8001d8a:	3301      	adds	r3, #1
 8001d8c:	617b      	str	r3, [r7, #20]
 8001d8e:	697a      	ldr	r2, [r7, #20]
 8001d90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001d92:	429a      	cmp	r2, r3
 8001d94:	d3e2      	bcc.n	8001d5c <hal_flash_bank_stm32_write+0x3a>
	}
	HAL_FLASH_Lock();
 8001d96:	f000 fe95 	bl	8002ac4 <HAL_FLASH_Lock>
 8001d9a:	e004      	b.n	8001da6 <hal_flash_bank_stm32_write+0x84>
	if (bank > 1) return;
 8001d9c:	bf00      	nop
 8001d9e:	e002      	b.n	8001da6 <hal_flash_bank_stm32_write+0x84>
	if (offset > self->sector_size) return;
 8001da0:	bf00      	nop
 8001da2:	e000      	b.n	8001da6 <hal_flash_bank_stm32_write+0x84>
	if ((offset + size) > self->sector_size) return;
 8001da4:	bf00      	nop
}
 8001da6:	371c      	adds	r7, #28
 8001da8:	46bd      	mov	sp, r7
 8001daa:	bd90      	pop	{r4, r7, pc}

08001dac <hal_flash_bank_stm32_init_instance>:
	/* void (*read)(..);              */ &hal_flash_bank_stm32_read,
	/* void (*write)(..);             */ &hal_flash_bank_stm32_write,
};

const hal_flash_bank_t * hal_flash_bank_stm32_init_instance(hal_flash_bank_stm32_t * context, uint32_t sector_size,
		uint32_t bank_0_sector, uint32_t bank_1_sector, uintptr_t bank_0_addr, uintptr_t bank_1_addr){
 8001dac:	b480      	push	{r7}
 8001dae:	b085      	sub	sp, #20
 8001db0:	af00      	add	r7, sp, #0
 8001db2:	60f8      	str	r0, [r7, #12]
 8001db4:	60b9      	str	r1, [r7, #8]
 8001db6:	607a      	str	r2, [r7, #4]
 8001db8:	603b      	str	r3, [r7, #0]
	context->sector_size = sector_size;
 8001dba:	68fb      	ldr	r3, [r7, #12]
 8001dbc:	68ba      	ldr	r2, [r7, #8]
 8001dbe:	601a      	str	r2, [r3, #0]
	context->sectors[0] = bank_0_sector;
 8001dc0:	68fb      	ldr	r3, [r7, #12]
 8001dc2:	687a      	ldr	r2, [r7, #4]
 8001dc4:	605a      	str	r2, [r3, #4]
	context->sectors[1] = bank_1_sector;
 8001dc6:	68fb      	ldr	r3, [r7, #12]
 8001dc8:	683a      	ldr	r2, [r7, #0]
 8001dca:	609a      	str	r2, [r3, #8]
	context->banks[0]   = bank_0_addr;
 8001dcc:	68fb      	ldr	r3, [r7, #12]
 8001dce:	69ba      	ldr	r2, [r7, #24]
 8001dd0:	60da      	str	r2, [r3, #12]
	context->banks[1]   = bank_1_addr;
 8001dd2:	68fb      	ldr	r3, [r7, #12]
 8001dd4:	69fa      	ldr	r2, [r7, #28]
 8001dd6:	611a      	str	r2, [r3, #16]
	return &hal_flash_bank_stm32_impl;
 8001dd8:	4b03      	ldr	r3, [pc, #12]	; (8001de8 <hal_flash_bank_stm32_init_instance+0x3c>)
}
 8001dda:	4618      	mov	r0, r3
 8001ddc:	3714      	adds	r7, #20
 8001dde:	46bd      	mov	sp, r7
 8001de0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001de4:	4770      	bx	lr
 8001de6:	bf00      	nop
 8001de8:	0803085c 	.word	0x0803085c

08001dec <hal_time_ms>:
#include "hal_time_ms.h"
uint32_t hal_time_ms(void){
 8001dec:	b580      	push	{r7, lr}
 8001dee:	af00      	add	r7, sp, #0
    return HAL_GetTick();
 8001df0:	f000 f944 	bl	800207c <HAL_GetTick>
 8001df4:	4603      	mov	r3, r0
}
 8001df6:	4618      	mov	r0, r3
 8001df8:	bd80      	pop	{r7, pc}

08001dfa <dummy_handler>:

// handlers
static void (*rx_done_handler)(void) = &dummy_handler;
static void (*tx_done_handler)(void) = &dummy_handler;

static void dummy_handler(void){};
 8001dfa:	b480      	push	{r7}
 8001dfc:	af00      	add	r7, sp, #0
 8001dfe:	bf00      	nop
 8001e00:	46bd      	mov	sp, r7
 8001e02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e06:	4770      	bx	lr

08001e08 <hal_uart_dma_set_sleep>:

void hal_uart_dma_set_sleep(uint8_t sleep){
 8001e08:	b480      	push	{r7}
 8001e0a:	b083      	sub	sp, #12
 8001e0c:	af00      	add	r7, sp, #0
 8001e0e:	4603      	mov	r3, r0
 8001e10:	71fb      	strb	r3, [r7, #7]
    // later..
}
 8001e12:	bf00      	nop
 8001e14:	370c      	adds	r7, #12
 8001e16:	46bd      	mov	sp, r7
 8001e18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e1c:	4770      	bx	lr
	...

08001e20 <bluetooth_power_cycle>:

// reset Bluetooth using nShutdown
static void bluetooth_power_cycle(void){
 8001e20:	b580      	push	{r7, lr}
 8001e22:	af00      	add	r7, sp, #0
    HAL_GPIO_WritePin( GPIOA, GPIO_PIN_8, GPIO_PIN_RESET );
 8001e24:	2200      	movs	r2, #0
 8001e26:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001e2a:	4809      	ldr	r0, [pc, #36]	; (8001e50 <bluetooth_power_cycle+0x30>)
 8001e2c:	f001 fa3c 	bl	80032a8 <HAL_GPIO_WritePin>
    HAL_Delay( 250 );
 8001e30:	20fa      	movs	r0, #250	; 0xfa
 8001e32:	f000 f92f 	bl	8002094 <HAL_Delay>
    HAL_GPIO_WritePin( GPIOA, GPIO_PIN_8, GPIO_PIN_SET );
 8001e36:	2201      	movs	r2, #1
 8001e38:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001e3c:	4804      	ldr	r0, [pc, #16]	; (8001e50 <bluetooth_power_cycle+0x30>)
 8001e3e:	f001 fa33 	bl	80032a8 <HAL_GPIO_WritePin>
    HAL_Delay( 500 );
 8001e42:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8001e46:	f000 f925 	bl	8002094 <HAL_Delay>
}
 8001e4a:	bf00      	nop
 8001e4c:	bd80      	pop	{r7, pc}
 8001e4e:	bf00      	nop
 8001e50:	40020000 	.word	0x40020000

08001e54 <HAL_UART_TxCpltCallback>:

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart){
 8001e54:	b580      	push	{r7, lr}
 8001e56:	b082      	sub	sp, #8
 8001e58:	af00      	add	r7, sp, #0
 8001e5a:	6078      	str	r0, [r7, #4]
    if (huart == &huart1){
 8001e5c:	687b      	ldr	r3, [r7, #4]
 8001e5e:	4a05      	ldr	r2, [pc, #20]	; (8001e74 <HAL_UART_TxCpltCallback+0x20>)
 8001e60:	4293      	cmp	r3, r2
 8001e62:	d102      	bne.n	8001e6a <HAL_UART_TxCpltCallback+0x16>
        (*tx_done_handler)();
 8001e64:	4b04      	ldr	r3, [pc, #16]	; (8001e78 <HAL_UART_TxCpltCallback+0x24>)
 8001e66:	681b      	ldr	r3, [r3, #0]
 8001e68:	4798      	blx	r3
    }
}
 8001e6a:	bf00      	nop
 8001e6c:	3708      	adds	r7, #8
 8001e6e:	46bd      	mov	sp, r7
 8001e70:	bd80      	pop	{r7, pc}
 8001e72:	bf00      	nop
 8001e74:	2000a4a0 	.word	0x2000a4a0
 8001e78:	20000008 	.word	0x20000008

08001e7c <HAL_UART_RxCpltCallback>:

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
 8001e7c:	b580      	push	{r7, lr}
 8001e7e:	b082      	sub	sp, #8
 8001e80:	af00      	add	r7, sp, #0
 8001e82:	6078      	str	r0, [r7, #4]
    if (huart == &huart1){
 8001e84:	687b      	ldr	r3, [r7, #4]
 8001e86:	4a05      	ldr	r2, [pc, #20]	; (8001e9c <HAL_UART_RxCpltCallback+0x20>)
 8001e88:	4293      	cmp	r3, r2
 8001e8a:	d102      	bne.n	8001e92 <HAL_UART_RxCpltCallback+0x16>
        (*rx_done_handler)();
 8001e8c:	4b04      	ldr	r3, [pc, #16]	; (8001ea0 <HAL_UART_RxCpltCallback+0x24>)
 8001e8e:	681b      	ldr	r3, [r3, #0]
 8001e90:	4798      	blx	r3
    }
}
 8001e92:	bf00      	nop
 8001e94:	3708      	adds	r7, #8
 8001e96:	46bd      	mov	sp, r7
 8001e98:	bd80      	pop	{r7, pc}
 8001e9a:	bf00      	nop
 8001e9c:	2000a4a0 	.word	0x2000a4a0
 8001ea0:	20000004 	.word	0x20000004

08001ea4 <hal_uart_dma_init>:

void hal_uart_dma_init(void){
 8001ea4:	b580      	push	{r7, lr}
 8001ea6:	af00      	add	r7, sp, #0
    bluetooth_power_cycle();
 8001ea8:	f7ff ffba 	bl	8001e20 <bluetooth_power_cycle>
}
 8001eac:	bf00      	nop
 8001eae:	bd80      	pop	{r7, pc}

08001eb0 <hal_uart_dma_set_block_received>:
void hal_uart_dma_set_block_received( void (*the_block_handler)(void)){
 8001eb0:	b480      	push	{r7}
 8001eb2:	b083      	sub	sp, #12
 8001eb4:	af00      	add	r7, sp, #0
 8001eb6:	6078      	str	r0, [r7, #4]
    rx_done_handler = the_block_handler;
 8001eb8:	4a04      	ldr	r2, [pc, #16]	; (8001ecc <hal_uart_dma_set_block_received+0x1c>)
 8001eba:	687b      	ldr	r3, [r7, #4]
 8001ebc:	6013      	str	r3, [r2, #0]
}
 8001ebe:	bf00      	nop
 8001ec0:	370c      	adds	r7, #12
 8001ec2:	46bd      	mov	sp, r7
 8001ec4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ec8:	4770      	bx	lr
 8001eca:	bf00      	nop
 8001ecc:	20000004 	.word	0x20000004

08001ed0 <hal_uart_dma_set_block_sent>:

void hal_uart_dma_set_block_sent( void (*the_block_handler)(void)){
 8001ed0:	b480      	push	{r7}
 8001ed2:	b083      	sub	sp, #12
 8001ed4:	af00      	add	r7, sp, #0
 8001ed6:	6078      	str	r0, [r7, #4]
    tx_done_handler = the_block_handler;
 8001ed8:	4a04      	ldr	r2, [pc, #16]	; (8001eec <hal_uart_dma_set_block_sent+0x1c>)
 8001eda:	687b      	ldr	r3, [r7, #4]
 8001edc:	6013      	str	r3, [r2, #0]
}
 8001ede:	bf00      	nop
 8001ee0:	370c      	adds	r7, #12
 8001ee2:	46bd      	mov	sp, r7
 8001ee4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ee8:	4770      	bx	lr
 8001eea:	bf00      	nop
 8001eec:	20000008 	.word	0x20000008

08001ef0 <hal_uart_dma_set_csr_irq_handler>:

void hal_uart_dma_set_csr_irq_handler( void (*the_irq_handler)(void)){
 8001ef0:	b480      	push	{r7}
 8001ef2:	b083      	sub	sp, #12
 8001ef4:	af00      	add	r7, sp, #0
 8001ef6:	6078      	str	r0, [r7, #4]
    // .. later
}
 8001ef8:	bf00      	nop
 8001efa:	370c      	adds	r7, #12
 8001efc:	46bd      	mov	sp, r7
 8001efe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f02:	4770      	bx	lr

08001f04 <hal_uart_dma_set_baud>:

int  hal_uart_dma_set_baud(uint32_t baud){
 8001f04:	b480      	push	{r7}
 8001f06:	b083      	sub	sp, #12
 8001f08:	af00      	add	r7, sp, #0
 8001f0a:	6078      	str	r0, [r7, #4]
    // .. later
    return 0;
 8001f0c:	2300      	movs	r3, #0
}
 8001f0e:	4618      	mov	r0, r3
 8001f10:	370c      	adds	r7, #12
 8001f12:	46bd      	mov	sp, r7
 8001f14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f18:	4770      	bx	lr
	...

08001f1c <hal_uart_dma_send_block>:

void hal_uart_dma_send_block(const uint8_t *data, uint16_t size){
 8001f1c:	b580      	push	{r7, lr}
 8001f1e:	b082      	sub	sp, #8
 8001f20:	af00      	add	r7, sp, #0
 8001f22:	6078      	str	r0, [r7, #4]
 8001f24:	460b      	mov	r3, r1
 8001f26:	807b      	strh	r3, [r7, #2]
    HAL_UART_Transmit_DMA( &huart1, (uint8_t *) data, size);
 8001f28:	887b      	ldrh	r3, [r7, #2]
 8001f2a:	461a      	mov	r2, r3
 8001f2c:	6879      	ldr	r1, [r7, #4]
 8001f2e:	4803      	ldr	r0, [pc, #12]	; (8001f3c <hal_uart_dma_send_block+0x20>)
 8001f30:	f004 fd1a 	bl	8006968 <HAL_UART_Transmit_DMA>
}
 8001f34:	bf00      	nop
 8001f36:	3708      	adds	r7, #8
 8001f38:	46bd      	mov	sp, r7
 8001f3a:	bd80      	pop	{r7, pc}
 8001f3c:	2000a4a0 	.word	0x2000a4a0

08001f40 <hal_uart_dma_receive_block>:

void hal_uart_dma_receive_block(uint8_t *data, uint16_t size){
 8001f40:	b580      	push	{r7, lr}
 8001f42:	b082      	sub	sp, #8
 8001f44:	af00      	add	r7, sp, #0
 8001f46:	6078      	str	r0, [r7, #4]
 8001f48:	460b      	mov	r3, r1
 8001f4a:	807b      	strh	r3, [r7, #2]
    HAL_UART_Receive_DMA( &huart1, data, size );
 8001f4c:	887b      	ldrh	r3, [r7, #2]
 8001f4e:	461a      	mov	r2, r3
 8001f50:	6879      	ldr	r1, [r7, #4]
 8001f52:	4803      	ldr	r0, [pc, #12]	; (8001f60 <hal_uart_dma_receive_block+0x20>)
 8001f54:	f004 fd74 	bl	8006a40 <HAL_UART_Receive_DMA>
}
 8001f58:	bf00      	nop
 8001f5a:	3708      	adds	r7, #8
 8001f5c:	46bd      	mov	sp, r7
 8001f5e:	bd80      	pop	{r7, pc}
 8001f60:	2000a4a0 	.word	0x2000a4a0

08001f64 <port_main>:



int btstack_main(int argc, const char ** argv);

void port_main(void){
 8001f64:	b580      	push	{r7, lr}
 8001f66:	b086      	sub	sp, #24
 8001f68:	af02      	add	r7, sp, #8

	 btstack_memory_init();
 8001f6a:	f00c fcdb 	bl	800e924 <btstack_memory_init>
	    btstack_run_loop_init(btstack_run_loop_embedded_get_instance());
 8001f6e:	f00a fa91 	bl	800c494 <btstack_run_loop_embedded_get_instance>
 8001f72:	4603      	mov	r3, r0
 8001f74:	4618      	mov	r0, r3
 8001f76:	f00c fecf 	bl	800ed18 <btstack_run_loop_init>

	    hci_dump_open( NULL, HCI_DUMP_STDOUT );
 8001f7a:	2102      	movs	r1, #2
 8001f7c:	2000      	movs	r0, #0
 8001f7e:	f015 f887 	bl	8017090 <hci_dump_open>

		// init HCI
	    hci_init(hci_transport_h4_instance(btstack_uart_block_embedded_instance()), (void*) &config);
 8001f82:	f00b f8e7 	bl	800d154 <btstack_uart_block_embedded_instance>
 8001f86:	4603      	mov	r3, r0
 8001f88:	4618      	mov	r0, r3
 8001f8a:	f015 fd0f 	bl	80179ac <hci_transport_h4_instance>
 8001f8e:	4603      	mov	r3, r0
 8001f90:	491d      	ldr	r1, [pc, #116]	; (8002008 <port_main+0xa4>)
 8001f92:	4618      	mov	r0, r3
 8001f94:	f012 f828 	bl	8013fe8 <hci_init>
	    hci_set_chipset(btstack_chipset_cc256x_instance());
 8001f98:	f00a f92c 	bl	800c1f4 <btstack_chipset_cc256x_instance>
 8001f9c:	4603      	mov	r3, r0
 8001f9e:	4618      	mov	r0, r3
 8001fa0:	f012 f8fe 	bl	80141a0 <hci_set_chipset>

	   // MAX_NR_HCI_CONNECTIONS(0);
	    // setup TLV Flash Sector implementation
	    const hal_flash_bank_t * hal_flash_bank_impl = hal_flash_bank_stm32_init_instance(
 8001fa4:	4b19      	ldr	r3, [pc, #100]	; (800200c <port_main+0xa8>)
 8001fa6:	9301      	str	r3, [sp, #4]
 8001fa8:	4b19      	ldr	r3, [pc, #100]	; (8002010 <port_main+0xac>)
 8001faa:	9300      	str	r3, [sp, #0]
 8001fac:	2307      	movs	r3, #7
 8001fae:	2206      	movs	r2, #6
 8001fb0:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8001fb4:	4817      	ldr	r0, [pc, #92]	; (8002014 <port_main+0xb0>)
 8001fb6:	f7ff fef9 	bl	8001dac <hal_flash_bank_stm32_init_instance>
 8001fba:	60f8      	str	r0, [r7, #12]
	    		HAL_FLASH_BANK_SIZE,
				HAL_FLASH_BANK_0_SECTOR,
				HAL_FLASH_BANK_1_SECTOR,
				HAL_FLASH_BANK_0_ADDR,
				HAL_FLASH_BANK_1_ADDR);
	    const btstack_tlv_t * btstack_tlv_impl = btstack_tlv_flash_bank_init_instance(
 8001fbc:	4a15      	ldr	r2, [pc, #84]	; (8002014 <port_main+0xb0>)
 8001fbe:	68f9      	ldr	r1, [r7, #12]
 8001fc0:	4815      	ldr	r0, [pc, #84]	; (8002018 <port_main+0xb4>)
 8001fc2:	f00a fed7 	bl	800cd74 <btstack_tlv_flash_bank_init_instance>
 8001fc6:	60b8      	str	r0, [r7, #8]
	    		&btstack_tlv_flash_bank_context,
				hal_flash_bank_impl,
				&hal_flash_bank_context);
//
//	    // setup global tlv
	    btstack_tlv_set_instance(btstack_tlv_impl, &btstack_tlv_flash_bank_context);
 8001fc8:	4913      	ldr	r1, [pc, #76]	; (8002018 <port_main+0xb4>)
 8001fca:	68b8      	ldr	r0, [r7, #8]
 8001fcc:	f00c feb6 	bl	800ed3c <btstack_tlv_set_instance>

	    // setup Link Key DB using TLV
	    const btstack_link_key_db_t * btstack_link_key_db = btstack_link_key_db_tlv_get_instance(btstack_tlv_impl, &btstack_tlv_flash_bank_context);
 8001fd0:	4911      	ldr	r1, [pc, #68]	; (8002018 <port_main+0xb4>)
 8001fd2:	68b8      	ldr	r0, [r7, #8]
 8001fd4:	f025 fc7c 	bl	80278d0 <btstack_link_key_db_tlv_get_instance>
 8001fd8:	6078      	str	r0, [r7, #4]
	    hci_set_link_key_db(btstack_link_key_db);
 8001fda:	6878      	ldr	r0, [r7, #4]
 8001fdc:	f011 ffec 	bl	8013fb8 <hci_set_link_key_db>

	    // setup LE Device DB using TLV
	    le_device_db_tlv_configure(btstack_tlv_impl, &btstack_tlv_flash_bank_context);
 8001fe0:	490d      	ldr	r1, [pc, #52]	; (8002018 <port_main+0xb4>)
 8001fe2:	68b8      	ldr	r0, [r7, #8]
 8001fe4:	f01e ff7a 	bl	8020edc <le_device_db_tlv_configure>
    // setup audio
   	btstack_audio_sink_set_instance(btstack_audio_embedded_sink_get_instance());
    btstack_audio_source_set_instance(btstack_audio_embedded_source_get_instance());
#endif

    hci_set_chipset(btstack_chipset_cc256x_instance());
 8001fe8:	f00a f904 	bl	800c1f4 <btstack_chipset_cc256x_instance>
 8001fec:	4603      	mov	r3, r0
 8001fee:	4618      	mov	r0, r3
 8001ff0:	f012 f8d6 	bl	80141a0 <hci_set_chipset>
		// hand over to btstack embedded code
	    btstack_main(0, NULL);
 8001ff4:	2100      	movs	r1, #0
 8001ff6:	2000      	movs	r0, #0
 8001ff8:	f7ff fe02 	bl	8001c00 <btstack_main>

	    // go
	    btstack_run_loop_execute();
 8001ffc:	f00c fe82 	bl	800ed04 <btstack_run_loop_execute>
	    //hci_dump_open( NULL, HCI_DUMP_STDOUT );

}
 8002000:	bf00      	nop
 8002002:	3710      	adds	r7, #16
 8002004:	46bd      	mov	sp, r7
 8002006:	bd80      	pop	{r7, pc}
 8002008:	08030870 	.word	0x08030870
 800200c:	08060000 	.word	0x08060000
 8002010:	08040000 	.word	0x08040000
 8002014:	200003fc 	.word	0x200003fc
 8002018:	200003e8 	.word	0x200003e8

0800201c <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800201c:	b580      	push	{r7, lr}
 800201e:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8002020:	4b0b      	ldr	r3, [pc, #44]	; (8002050 <HAL_Init+0x34>)
 8002022:	681b      	ldr	r3, [r3, #0]
 8002024:	4a0a      	ldr	r2, [pc, #40]	; (8002050 <HAL_Init+0x34>)
 8002026:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800202a:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 800202c:	4b08      	ldr	r3, [pc, #32]	; (8002050 <HAL_Init+0x34>)
 800202e:	681b      	ldr	r3, [r3, #0]
 8002030:	4a07      	ldr	r2, [pc, #28]	; (8002050 <HAL_Init+0x34>)
 8002032:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8002036:	6013      	str	r3, [r2, #0]
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8002038:	2003      	movs	r0, #3
 800203a:	f000 f8fa 	bl	8002232 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800203e:	2000      	movs	r0, #0
 8002040:	f7fe fec6 	bl	8000dd0 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8002044:	f7fe fe98 	bl	8000d78 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8002048:	2300      	movs	r3, #0
}
 800204a:	4618      	mov	r0, r3
 800204c:	bd80      	pop	{r7, pc}
 800204e:	bf00      	nop
 8002050:	40023c00 	.word	0x40023c00

08002054 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8002054:	b480      	push	{r7}
 8002056:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8002058:	4b06      	ldr	r3, [pc, #24]	; (8002074 <HAL_IncTick+0x20>)
 800205a:	781b      	ldrb	r3, [r3, #0]
 800205c:	461a      	mov	r2, r3
 800205e:	4b06      	ldr	r3, [pc, #24]	; (8002078 <HAL_IncTick+0x24>)
 8002060:	681b      	ldr	r3, [r3, #0]
 8002062:	4413      	add	r3, r2
 8002064:	4a04      	ldr	r2, [pc, #16]	; (8002078 <HAL_IncTick+0x24>)
 8002066:	6013      	str	r3, [r2, #0]
}
 8002068:	bf00      	nop
 800206a:	46bd      	mov	sp, r7
 800206c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002070:	4770      	bx	lr
 8002072:	bf00      	nop
 8002074:	20000010 	.word	0x20000010
 8002078:	2000a690 	.word	0x2000a690

0800207c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800207c:	b480      	push	{r7}
 800207e:	af00      	add	r7, sp, #0
  return uwTick;
 8002080:	4b03      	ldr	r3, [pc, #12]	; (8002090 <HAL_GetTick+0x14>)
 8002082:	681b      	ldr	r3, [r3, #0]
}
 8002084:	4618      	mov	r0, r3
 8002086:	46bd      	mov	sp, r7
 8002088:	f85d 7b04 	ldr.w	r7, [sp], #4
 800208c:	4770      	bx	lr
 800208e:	bf00      	nop
 8002090:	2000a690 	.word	0x2000a690

08002094 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8002094:	b580      	push	{r7, lr}
 8002096:	b084      	sub	sp, #16
 8002098:	af00      	add	r7, sp, #0
 800209a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 800209c:	f7ff ffee 	bl	800207c <HAL_GetTick>
 80020a0:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 80020a2:	687b      	ldr	r3, [r7, #4]
 80020a4:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80020a6:	68fb      	ldr	r3, [r7, #12]
 80020a8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80020ac:	d005      	beq.n	80020ba <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 80020ae:	4b09      	ldr	r3, [pc, #36]	; (80020d4 <HAL_Delay+0x40>)
 80020b0:	781b      	ldrb	r3, [r3, #0]
 80020b2:	461a      	mov	r2, r3
 80020b4:	68fb      	ldr	r3, [r7, #12]
 80020b6:	4413      	add	r3, r2
 80020b8:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 80020ba:	bf00      	nop
 80020bc:	f7ff ffde 	bl	800207c <HAL_GetTick>
 80020c0:	4602      	mov	r2, r0
 80020c2:	68bb      	ldr	r3, [r7, #8]
 80020c4:	1ad3      	subs	r3, r2, r3
 80020c6:	68fa      	ldr	r2, [r7, #12]
 80020c8:	429a      	cmp	r2, r3
 80020ca:	d8f7      	bhi.n	80020bc <HAL_Delay+0x28>
  {
  }
}
 80020cc:	bf00      	nop
 80020ce:	3710      	adds	r7, #16
 80020d0:	46bd      	mov	sp, r7
 80020d2:	bd80      	pop	{r7, pc}
 80020d4:	20000010 	.word	0x20000010

080020d8 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80020d8:	b480      	push	{r7}
 80020da:	b085      	sub	sp, #20
 80020dc:	af00      	add	r7, sp, #0
 80020de:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80020e0:	687b      	ldr	r3, [r7, #4]
 80020e2:	f003 0307 	and.w	r3, r3, #7
 80020e6:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80020e8:	4b0c      	ldr	r3, [pc, #48]	; (800211c <__NVIC_SetPriorityGrouping+0x44>)
 80020ea:	68db      	ldr	r3, [r3, #12]
 80020ec:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80020ee:	68ba      	ldr	r2, [r7, #8]
 80020f0:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80020f4:	4013      	ands	r3, r2
 80020f6:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80020f8:	68fb      	ldr	r3, [r7, #12]
 80020fa:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80020fc:	68bb      	ldr	r3, [r7, #8]
 80020fe:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8002100:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8002104:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002108:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800210a:	4a04      	ldr	r2, [pc, #16]	; (800211c <__NVIC_SetPriorityGrouping+0x44>)
 800210c:	68bb      	ldr	r3, [r7, #8]
 800210e:	60d3      	str	r3, [r2, #12]
}
 8002110:	bf00      	nop
 8002112:	3714      	adds	r7, #20
 8002114:	46bd      	mov	sp, r7
 8002116:	f85d 7b04 	ldr.w	r7, [sp], #4
 800211a:	4770      	bx	lr
 800211c:	e000ed00 	.word	0xe000ed00

08002120 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8002120:	b480      	push	{r7}
 8002122:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8002124:	4b04      	ldr	r3, [pc, #16]	; (8002138 <__NVIC_GetPriorityGrouping+0x18>)
 8002126:	68db      	ldr	r3, [r3, #12]
 8002128:	0a1b      	lsrs	r3, r3, #8
 800212a:	f003 0307 	and.w	r3, r3, #7
}
 800212e:	4618      	mov	r0, r3
 8002130:	46bd      	mov	sp, r7
 8002132:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002136:	4770      	bx	lr
 8002138:	e000ed00 	.word	0xe000ed00

0800213c <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800213c:	b480      	push	{r7}
 800213e:	b083      	sub	sp, #12
 8002140:	af00      	add	r7, sp, #0
 8002142:	4603      	mov	r3, r0
 8002144:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8002146:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800214a:	2b00      	cmp	r3, #0
 800214c:	db0b      	blt.n	8002166 <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800214e:	79fb      	ldrb	r3, [r7, #7]
 8002150:	f003 021f 	and.w	r2, r3, #31
 8002154:	4907      	ldr	r1, [pc, #28]	; (8002174 <__NVIC_EnableIRQ+0x38>)
 8002156:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800215a:	095b      	lsrs	r3, r3, #5
 800215c:	2001      	movs	r0, #1
 800215e:	fa00 f202 	lsl.w	r2, r0, r2
 8002162:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 8002166:	bf00      	nop
 8002168:	370c      	adds	r7, #12
 800216a:	46bd      	mov	sp, r7
 800216c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002170:	4770      	bx	lr
 8002172:	bf00      	nop
 8002174:	e000e100 	.word	0xe000e100

08002178 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8002178:	b480      	push	{r7}
 800217a:	b083      	sub	sp, #12
 800217c:	af00      	add	r7, sp, #0
 800217e:	4603      	mov	r3, r0
 8002180:	6039      	str	r1, [r7, #0]
 8002182:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8002184:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002188:	2b00      	cmp	r3, #0
 800218a:	db0a      	blt.n	80021a2 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800218c:	683b      	ldr	r3, [r7, #0]
 800218e:	b2da      	uxtb	r2, r3
 8002190:	490c      	ldr	r1, [pc, #48]	; (80021c4 <__NVIC_SetPriority+0x4c>)
 8002192:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002196:	0112      	lsls	r2, r2, #4
 8002198:	b2d2      	uxtb	r2, r2
 800219a:	440b      	add	r3, r1
 800219c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80021a0:	e00a      	b.n	80021b8 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80021a2:	683b      	ldr	r3, [r7, #0]
 80021a4:	b2da      	uxtb	r2, r3
 80021a6:	4908      	ldr	r1, [pc, #32]	; (80021c8 <__NVIC_SetPriority+0x50>)
 80021a8:	79fb      	ldrb	r3, [r7, #7]
 80021aa:	f003 030f 	and.w	r3, r3, #15
 80021ae:	3b04      	subs	r3, #4
 80021b0:	0112      	lsls	r2, r2, #4
 80021b2:	b2d2      	uxtb	r2, r2
 80021b4:	440b      	add	r3, r1
 80021b6:	761a      	strb	r2, [r3, #24]
}
 80021b8:	bf00      	nop
 80021ba:	370c      	adds	r7, #12
 80021bc:	46bd      	mov	sp, r7
 80021be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80021c2:	4770      	bx	lr
 80021c4:	e000e100 	.word	0xe000e100
 80021c8:	e000ed00 	.word	0xe000ed00

080021cc <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80021cc:	b480      	push	{r7}
 80021ce:	b089      	sub	sp, #36	; 0x24
 80021d0:	af00      	add	r7, sp, #0
 80021d2:	60f8      	str	r0, [r7, #12]
 80021d4:	60b9      	str	r1, [r7, #8]
 80021d6:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80021d8:	68fb      	ldr	r3, [r7, #12]
 80021da:	f003 0307 	and.w	r3, r3, #7
 80021de:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80021e0:	69fb      	ldr	r3, [r7, #28]
 80021e2:	f1c3 0307 	rsb	r3, r3, #7
 80021e6:	2b04      	cmp	r3, #4
 80021e8:	bf28      	it	cs
 80021ea:	2304      	movcs	r3, #4
 80021ec:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80021ee:	69fb      	ldr	r3, [r7, #28]
 80021f0:	3304      	adds	r3, #4
 80021f2:	2b06      	cmp	r3, #6
 80021f4:	d902      	bls.n	80021fc <NVIC_EncodePriority+0x30>
 80021f6:	69fb      	ldr	r3, [r7, #28]
 80021f8:	3b03      	subs	r3, #3
 80021fa:	e000      	b.n	80021fe <NVIC_EncodePriority+0x32>
 80021fc:	2300      	movs	r3, #0
 80021fe:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002200:	f04f 32ff 	mov.w	r2, #4294967295
 8002204:	69bb      	ldr	r3, [r7, #24]
 8002206:	fa02 f303 	lsl.w	r3, r2, r3
 800220a:	43da      	mvns	r2, r3
 800220c:	68bb      	ldr	r3, [r7, #8]
 800220e:	401a      	ands	r2, r3
 8002210:	697b      	ldr	r3, [r7, #20]
 8002212:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8002214:	f04f 31ff 	mov.w	r1, #4294967295
 8002218:	697b      	ldr	r3, [r7, #20]
 800221a:	fa01 f303 	lsl.w	r3, r1, r3
 800221e:	43d9      	mvns	r1, r3
 8002220:	687b      	ldr	r3, [r7, #4]
 8002222:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002224:	4313      	orrs	r3, r2
         );
}
 8002226:	4618      	mov	r0, r3
 8002228:	3724      	adds	r7, #36	; 0x24
 800222a:	46bd      	mov	sp, r7
 800222c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002230:	4770      	bx	lr

08002232 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8002232:	b580      	push	{r7, lr}
 8002234:	b082      	sub	sp, #8
 8002236:	af00      	add	r7, sp, #0
 8002238:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800223a:	6878      	ldr	r0, [r7, #4]
 800223c:	f7ff ff4c 	bl	80020d8 <__NVIC_SetPriorityGrouping>
}
 8002240:	bf00      	nop
 8002242:	3708      	adds	r7, #8
 8002244:	46bd      	mov	sp, r7
 8002246:	bd80      	pop	{r7, pc}

08002248 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8002248:	b580      	push	{r7, lr}
 800224a:	b086      	sub	sp, #24
 800224c:	af00      	add	r7, sp, #0
 800224e:	4603      	mov	r3, r0
 8002250:	60b9      	str	r1, [r7, #8]
 8002252:	607a      	str	r2, [r7, #4]
 8002254:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8002256:	2300      	movs	r3, #0
 8002258:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 800225a:	f7ff ff61 	bl	8002120 <__NVIC_GetPriorityGrouping>
 800225e:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8002260:	687a      	ldr	r2, [r7, #4]
 8002262:	68b9      	ldr	r1, [r7, #8]
 8002264:	6978      	ldr	r0, [r7, #20]
 8002266:	f7ff ffb1 	bl	80021cc <NVIC_EncodePriority>
 800226a:	4602      	mov	r2, r0
 800226c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8002270:	4611      	mov	r1, r2
 8002272:	4618      	mov	r0, r3
 8002274:	f7ff ff80 	bl	8002178 <__NVIC_SetPriority>
}
 8002278:	bf00      	nop
 800227a:	3718      	adds	r7, #24
 800227c:	46bd      	mov	sp, r7
 800227e:	bd80      	pop	{r7, pc}

08002280 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8002280:	b580      	push	{r7, lr}
 8002282:	b082      	sub	sp, #8
 8002284:	af00      	add	r7, sp, #0
 8002286:	4603      	mov	r3, r0
 8002288:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800228a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800228e:	4618      	mov	r0, r3
 8002290:	f7ff ff54 	bl	800213c <__NVIC_EnableIRQ>
}
 8002294:	bf00      	nop
 8002296:	3708      	adds	r7, #8
 8002298:	46bd      	mov	sp, r7
 800229a:	bd80      	pop	{r7, pc}

0800229c <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 800229c:	b580      	push	{r7, lr}
 800229e:	b086      	sub	sp, #24
 80022a0:	af00      	add	r7, sp, #0
 80022a2:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
 80022a4:	2300      	movs	r3, #0
 80022a6:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
 80022a8:	f7ff fee8 	bl	800207c <HAL_GetTick>
 80022ac:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 80022ae:	687b      	ldr	r3, [r7, #4]
 80022b0:	2b00      	cmp	r3, #0
 80022b2:	d101      	bne.n	80022b8 <HAL_DMA_Init+0x1c>
  {
    return HAL_ERROR;
 80022b4:	2301      	movs	r3, #1
 80022b6:	e099      	b.n	80023ec <HAL_DMA_Init+0x150>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 80022b8:	687b      	ldr	r3, [r7, #4]
 80022ba:	2200      	movs	r2, #0
 80022bc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80022c0:	687b      	ldr	r3, [r7, #4]
 80022c2:	2202      	movs	r2, #2
 80022c4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 80022c8:	687b      	ldr	r3, [r7, #4]
 80022ca:	681b      	ldr	r3, [r3, #0]
 80022cc:	681a      	ldr	r2, [r3, #0]
 80022ce:	687b      	ldr	r3, [r7, #4]
 80022d0:	681b      	ldr	r3, [r3, #0]
 80022d2:	f022 0201 	bic.w	r2, r2, #1
 80022d6:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80022d8:	e00f      	b.n	80022fa <HAL_DMA_Init+0x5e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 80022da:	f7ff fecf 	bl	800207c <HAL_GetTick>
 80022de:	4602      	mov	r2, r0
 80022e0:	693b      	ldr	r3, [r7, #16]
 80022e2:	1ad3      	subs	r3, r2, r3
 80022e4:	2b05      	cmp	r3, #5
 80022e6:	d908      	bls.n	80022fa <HAL_DMA_Init+0x5e>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80022e8:	687b      	ldr	r3, [r7, #4]
 80022ea:	2220      	movs	r2, #32
 80022ec:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80022ee:	687b      	ldr	r3, [r7, #4]
 80022f0:	2203      	movs	r2, #3
 80022f2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      
      return HAL_TIMEOUT;
 80022f6:	2303      	movs	r3, #3
 80022f8:	e078      	b.n	80023ec <HAL_DMA_Init+0x150>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80022fa:	687b      	ldr	r3, [r7, #4]
 80022fc:	681b      	ldr	r3, [r3, #0]
 80022fe:	681b      	ldr	r3, [r3, #0]
 8002300:	f003 0301 	and.w	r3, r3, #1
 8002304:	2b00      	cmp	r3, #0
 8002306:	d1e8      	bne.n	80022da <HAL_DMA_Init+0x3e>
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 8002308:	687b      	ldr	r3, [r7, #4]
 800230a:	681b      	ldr	r3, [r3, #0]
 800230c:	681b      	ldr	r3, [r3, #0]
 800230e:	617b      	str	r3, [r7, #20]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8002310:	697a      	ldr	r2, [r7, #20]
 8002312:	4b38      	ldr	r3, [pc, #224]	; (80023f4 <HAL_DMA_Init+0x158>)
 8002314:	4013      	ands	r3, r2
 8002316:	617b      	str	r3, [r7, #20]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002318:	687b      	ldr	r3, [r7, #4]
 800231a:	685a      	ldr	r2, [r3, #4]
 800231c:	687b      	ldr	r3, [r7, #4]
 800231e:	689b      	ldr	r3, [r3, #8]
 8002320:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002322:	687b      	ldr	r3, [r7, #4]
 8002324:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002326:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002328:	687b      	ldr	r3, [r7, #4]
 800232a:	691b      	ldr	r3, [r3, #16]
 800232c:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800232e:	687b      	ldr	r3, [r7, #4]
 8002330:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002332:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002334:	687b      	ldr	r3, [r7, #4]
 8002336:	699b      	ldr	r3, [r3, #24]
 8002338:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 800233a:	687b      	ldr	r3, [r7, #4]
 800233c:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800233e:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8002340:	687b      	ldr	r3, [r7, #4]
 8002342:	6a1b      	ldr	r3, [r3, #32]
 8002344:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002346:	697a      	ldr	r2, [r7, #20]
 8002348:	4313      	orrs	r3, r2
 800234a:	617b      	str	r3, [r7, #20]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800234c:	687b      	ldr	r3, [r7, #4]
 800234e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002350:	2b04      	cmp	r3, #4
 8002352:	d107      	bne.n	8002364 <HAL_DMA_Init+0xc8>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8002354:	687b      	ldr	r3, [r7, #4]
 8002356:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002358:	687b      	ldr	r3, [r7, #4]
 800235a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800235c:	4313      	orrs	r3, r2
 800235e:	697a      	ldr	r2, [r7, #20]
 8002360:	4313      	orrs	r3, r2
 8002362:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 8002364:	687b      	ldr	r3, [r7, #4]
 8002366:	681b      	ldr	r3, [r3, #0]
 8002368:	697a      	ldr	r2, [r7, #20]
 800236a:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 800236c:	687b      	ldr	r3, [r7, #4]
 800236e:	681b      	ldr	r3, [r3, #0]
 8002370:	695b      	ldr	r3, [r3, #20]
 8002372:	617b      	str	r3, [r7, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8002374:	697b      	ldr	r3, [r7, #20]
 8002376:	f023 0307 	bic.w	r3, r3, #7
 800237a:	617b      	str	r3, [r7, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 800237c:	687b      	ldr	r3, [r7, #4]
 800237e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002380:	697a      	ldr	r2, [r7, #20]
 8002382:	4313      	orrs	r3, r2
 8002384:	617b      	str	r3, [r7, #20]

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002386:	687b      	ldr	r3, [r7, #4]
 8002388:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800238a:	2b04      	cmp	r3, #4
 800238c:	d117      	bne.n	80023be <HAL_DMA_Init+0x122>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 800238e:	687b      	ldr	r3, [r7, #4]
 8002390:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002392:	697a      	ldr	r2, [r7, #20]
 8002394:	4313      	orrs	r3, r2
 8002396:	617b      	str	r3, [r7, #20]
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8002398:	687b      	ldr	r3, [r7, #4]
 800239a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800239c:	2b00      	cmp	r3, #0
 800239e:	d00e      	beq.n	80023be <HAL_DMA_Init+0x122>
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
 80023a0:	6878      	ldr	r0, [r7, #4]
 80023a2:	f000 fa9f 	bl	80028e4 <DMA_CheckFifoParam>
 80023a6:	4603      	mov	r3, r0
 80023a8:	2b00      	cmp	r3, #0
 80023aa:	d008      	beq.n	80023be <HAL_DMA_Init+0x122>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80023ac:	687b      	ldr	r3, [r7, #4]
 80023ae:	2240      	movs	r2, #64	; 0x40
 80023b0:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 80023b2:	687b      	ldr	r3, [r7, #4]
 80023b4:	2201      	movs	r2, #1
 80023b6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        
        return HAL_ERROR; 
 80023ba:	2301      	movs	r3, #1
 80023bc:	e016      	b.n	80023ec <HAL_DMA_Init+0x150>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 80023be:	687b      	ldr	r3, [r7, #4]
 80023c0:	681b      	ldr	r3, [r3, #0]
 80023c2:	697a      	ldr	r2, [r7, #20]
 80023c4:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 80023c6:	6878      	ldr	r0, [r7, #4]
 80023c8:	f000 fa56 	bl	8002878 <DMA_CalcBaseAndBitshift>
 80023cc:	4603      	mov	r3, r0
 80023ce:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80023d0:	687b      	ldr	r3, [r7, #4]
 80023d2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80023d4:	223f      	movs	r2, #63	; 0x3f
 80023d6:	409a      	lsls	r2, r3
 80023d8:	68fb      	ldr	r3, [r7, #12]
 80023da:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80023dc:	687b      	ldr	r3, [r7, #4]
 80023de:	2200      	movs	r2, #0
 80023e0:	655a      	str	r2, [r3, #84]	; 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 80023e2:	687b      	ldr	r3, [r7, #4]
 80023e4:	2201      	movs	r2, #1
 80023e6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 80023ea:	2300      	movs	r3, #0
}
 80023ec:	4618      	mov	r0, r3
 80023ee:	3718      	adds	r7, #24
 80023f0:	46bd      	mov	sp, r7
 80023f2:	bd80      	pop	{r7, pc}
 80023f4:	f010803f 	.word	0xf010803f

080023f8 <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80023f8:	b580      	push	{r7, lr}
 80023fa:	b086      	sub	sp, #24
 80023fc:	af00      	add	r7, sp, #0
 80023fe:	60f8      	str	r0, [r7, #12]
 8002400:	60b9      	str	r1, [r7, #8]
 8002402:	607a      	str	r2, [r7, #4]
 8002404:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8002406:	2300      	movs	r3, #0
 8002408:	75fb      	strb	r3, [r7, #23]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800240a:	68fb      	ldr	r3, [r7, #12]
 800240c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800240e:	613b      	str	r3, [r7, #16]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
 8002410:	68fb      	ldr	r3, [r7, #12]
 8002412:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8002416:	2b01      	cmp	r3, #1
 8002418:	d101      	bne.n	800241e <HAL_DMA_Start_IT+0x26>
 800241a:	2302      	movs	r3, #2
 800241c:	e040      	b.n	80024a0 <HAL_DMA_Start_IT+0xa8>
 800241e:	68fb      	ldr	r3, [r7, #12]
 8002420:	2201      	movs	r2, #1
 8002422:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 8002426:	68fb      	ldr	r3, [r7, #12]
 8002428:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 800242c:	b2db      	uxtb	r3, r3
 800242e:	2b01      	cmp	r3, #1
 8002430:	d12f      	bne.n	8002492 <HAL_DMA_Start_IT+0x9a>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 8002432:	68fb      	ldr	r3, [r7, #12]
 8002434:	2202      	movs	r2, #2
 8002436:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800243a:	68fb      	ldr	r3, [r7, #12]
 800243c:	2200      	movs	r2, #0
 800243e:	655a      	str	r2, [r3, #84]	; 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8002440:	683b      	ldr	r3, [r7, #0]
 8002442:	687a      	ldr	r2, [r7, #4]
 8002444:	68b9      	ldr	r1, [r7, #8]
 8002446:	68f8      	ldr	r0, [r7, #12]
 8002448:	f000 f9e8 	bl	800281c <DMA_SetConfig>
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 800244c:	68fb      	ldr	r3, [r7, #12]
 800244e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002450:	223f      	movs	r2, #63	; 0x3f
 8002452:	409a      	lsls	r2, r3
 8002454:	693b      	ldr	r3, [r7, #16]
 8002456:	609a      	str	r2, [r3, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8002458:	68fb      	ldr	r3, [r7, #12]
 800245a:	681b      	ldr	r3, [r3, #0]
 800245c:	681a      	ldr	r2, [r3, #0]
 800245e:	68fb      	ldr	r3, [r7, #12]
 8002460:	681b      	ldr	r3, [r3, #0]
 8002462:	f042 0216 	orr.w	r2, r2, #22
 8002466:	601a      	str	r2, [r3, #0]
    
    if(hdma->XferHalfCpltCallback != NULL)
 8002468:	68fb      	ldr	r3, [r7, #12]
 800246a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800246c:	2b00      	cmp	r3, #0
 800246e:	d007      	beq.n	8002480 <HAL_DMA_Start_IT+0x88>
    {
      hdma->Instance->CR  |= DMA_IT_HT;
 8002470:	68fb      	ldr	r3, [r7, #12]
 8002472:	681b      	ldr	r3, [r3, #0]
 8002474:	681a      	ldr	r2, [r3, #0]
 8002476:	68fb      	ldr	r3, [r7, #12]
 8002478:	681b      	ldr	r3, [r3, #0]
 800247a:	f042 0208 	orr.w	r2, r2, #8
 800247e:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 8002480:	68fb      	ldr	r3, [r7, #12]
 8002482:	681b      	ldr	r3, [r3, #0]
 8002484:	681a      	ldr	r2, [r3, #0]
 8002486:	68fb      	ldr	r3, [r7, #12]
 8002488:	681b      	ldr	r3, [r3, #0]
 800248a:	f042 0201 	orr.w	r2, r2, #1
 800248e:	601a      	str	r2, [r3, #0]
 8002490:	e005      	b.n	800249e <HAL_DMA_Start_IT+0xa6>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 8002492:	68fb      	ldr	r3, [r7, #12]
 8002494:	2200      	movs	r2, #0
 8002496:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    /* Return error status */
    status = HAL_BUSY;
 800249a:	2302      	movs	r3, #2
 800249c:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
 800249e:	7dfb      	ldrb	r3, [r7, #23]
}
 80024a0:	4618      	mov	r0, r3
 80024a2:	3718      	adds	r7, #24
 80024a4:	46bd      	mov	sp, r7
 80024a6:	bd80      	pop	{r7, pc}

080024a8 <HAL_DMA_Abort_IT>:
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 80024a8:	b480      	push	{r7}
 80024aa:	b083      	sub	sp, #12
 80024ac:	af00      	add	r7, sp, #0
 80024ae:	6078      	str	r0, [r7, #4]
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80024b0:	687b      	ldr	r3, [r7, #4]
 80024b2:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 80024b6:	b2db      	uxtb	r3, r3
 80024b8:	2b02      	cmp	r3, #2
 80024ba:	d004      	beq.n	80024c6 <HAL_DMA_Abort_IT+0x1e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80024bc:	687b      	ldr	r3, [r7, #4]
 80024be:	2280      	movs	r2, #128	; 0x80
 80024c0:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
 80024c2:	2301      	movs	r3, #1
 80024c4:	e00c      	b.n	80024e0 <HAL_DMA_Abort_IT+0x38>
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 80024c6:	687b      	ldr	r3, [r7, #4]
 80024c8:	2205      	movs	r2, #5
 80024ca:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 80024ce:	687b      	ldr	r3, [r7, #4]
 80024d0:	681b      	ldr	r3, [r3, #0]
 80024d2:	681a      	ldr	r2, [r3, #0]
 80024d4:	687b      	ldr	r3, [r7, #4]
 80024d6:	681b      	ldr	r3, [r3, #0]
 80024d8:	f022 0201 	bic.w	r2, r2, #1
 80024dc:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
 80024de:	2300      	movs	r3, #0
}
 80024e0:	4618      	mov	r0, r3
 80024e2:	370c      	adds	r7, #12
 80024e4:	46bd      	mov	sp, r7
 80024e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80024ea:	4770      	bx	lr

080024ec <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 80024ec:	b580      	push	{r7, lr}
 80024ee:	b086      	sub	sp, #24
 80024f0:	af00      	add	r7, sp, #0
 80024f2:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr;
  __IO uint32_t count = 0U;
 80024f4:	2300      	movs	r3, #0
 80024f6:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
 80024f8:	4b92      	ldr	r3, [pc, #584]	; (8002744 <HAL_DMA_IRQHandler+0x258>)
 80024fa:	681b      	ldr	r3, [r3, #0]
 80024fc:	4a92      	ldr	r2, [pc, #584]	; (8002748 <HAL_DMA_IRQHandler+0x25c>)
 80024fe:	fba2 2303 	umull	r2, r3, r2, r3
 8002502:	0a9b      	lsrs	r3, r3, #10
 8002504:	617b      	str	r3, [r7, #20]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8002506:	687b      	ldr	r3, [r7, #4]
 8002508:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800250a:	613b      	str	r3, [r7, #16]

  tmpisr = regs->ISR;
 800250c:	693b      	ldr	r3, [r7, #16]
 800250e:	681b      	ldr	r3, [r3, #0]
 8002510:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8002512:	687b      	ldr	r3, [r7, #4]
 8002514:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002516:	2208      	movs	r2, #8
 8002518:	409a      	lsls	r2, r3
 800251a:	68fb      	ldr	r3, [r7, #12]
 800251c:	4013      	ands	r3, r2
 800251e:	2b00      	cmp	r3, #0
 8002520:	d01a      	beq.n	8002558 <HAL_DMA_IRQHandler+0x6c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8002522:	687b      	ldr	r3, [r7, #4]
 8002524:	681b      	ldr	r3, [r3, #0]
 8002526:	681b      	ldr	r3, [r3, #0]
 8002528:	f003 0304 	and.w	r3, r3, #4
 800252c:	2b00      	cmp	r3, #0
 800252e:	d013      	beq.n	8002558 <HAL_DMA_IRQHandler+0x6c>
    {
      /* Disable the transfer error interrupt */
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8002530:	687b      	ldr	r3, [r7, #4]
 8002532:	681b      	ldr	r3, [r3, #0]
 8002534:	681a      	ldr	r2, [r3, #0]
 8002536:	687b      	ldr	r3, [r7, #4]
 8002538:	681b      	ldr	r3, [r3, #0]
 800253a:	f022 0204 	bic.w	r2, r2, #4
 800253e:	601a      	str	r2, [r3, #0]
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8002540:	687b      	ldr	r3, [r7, #4]
 8002542:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002544:	2208      	movs	r2, #8
 8002546:	409a      	lsls	r2, r3
 8002548:	693b      	ldr	r3, [r7, #16]
 800254a:	609a      	str	r2, [r3, #8]
      
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800254c:	687b      	ldr	r3, [r7, #4]
 800254e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002550:	f043 0201 	orr.w	r2, r3, #1
 8002554:	687b      	ldr	r3, [r7, #4]
 8002556:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8002558:	687b      	ldr	r3, [r7, #4]
 800255a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800255c:	2201      	movs	r2, #1
 800255e:	409a      	lsls	r2, r3
 8002560:	68fb      	ldr	r3, [r7, #12]
 8002562:	4013      	ands	r3, r2
 8002564:	2b00      	cmp	r3, #0
 8002566:	d012      	beq.n	800258e <HAL_DMA_IRQHandler+0xa2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8002568:	687b      	ldr	r3, [r7, #4]
 800256a:	681b      	ldr	r3, [r3, #0]
 800256c:	695b      	ldr	r3, [r3, #20]
 800256e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002572:	2b00      	cmp	r3, #0
 8002574:	d00b      	beq.n	800258e <HAL_DMA_IRQHandler+0xa2>
    {
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8002576:	687b      	ldr	r3, [r7, #4]
 8002578:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800257a:	2201      	movs	r2, #1
 800257c:	409a      	lsls	r2, r3
 800257e:	693b      	ldr	r3, [r7, #16]
 8002580:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8002582:	687b      	ldr	r3, [r7, #4]
 8002584:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002586:	f043 0202 	orr.w	r2, r3, #2
 800258a:	687b      	ldr	r3, [r7, #4]
 800258c:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 800258e:	687b      	ldr	r3, [r7, #4]
 8002590:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002592:	2204      	movs	r2, #4
 8002594:	409a      	lsls	r2, r3
 8002596:	68fb      	ldr	r3, [r7, #12]
 8002598:	4013      	ands	r3, r2
 800259a:	2b00      	cmp	r3, #0
 800259c:	d012      	beq.n	80025c4 <HAL_DMA_IRQHandler+0xd8>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 800259e:	687b      	ldr	r3, [r7, #4]
 80025a0:	681b      	ldr	r3, [r3, #0]
 80025a2:	681b      	ldr	r3, [r3, #0]
 80025a4:	f003 0302 	and.w	r3, r3, #2
 80025a8:	2b00      	cmp	r3, #0
 80025aa:	d00b      	beq.n	80025c4 <HAL_DMA_IRQHandler+0xd8>
    {
      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 80025ac:	687b      	ldr	r3, [r7, #4]
 80025ae:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80025b0:	2204      	movs	r2, #4
 80025b2:	409a      	lsls	r2, r3
 80025b4:	693b      	ldr	r3, [r7, #16]
 80025b6:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 80025b8:	687b      	ldr	r3, [r7, #4]
 80025ba:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80025bc:	f043 0204 	orr.w	r2, r3, #4
 80025c0:	687b      	ldr	r3, [r7, #4]
 80025c2:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 80025c4:	687b      	ldr	r3, [r7, #4]
 80025c6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80025c8:	2210      	movs	r2, #16
 80025ca:	409a      	lsls	r2, r3
 80025cc:	68fb      	ldr	r3, [r7, #12]
 80025ce:	4013      	ands	r3, r2
 80025d0:	2b00      	cmp	r3, #0
 80025d2:	d043      	beq.n	800265c <HAL_DMA_IRQHandler+0x170>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 80025d4:	687b      	ldr	r3, [r7, #4]
 80025d6:	681b      	ldr	r3, [r3, #0]
 80025d8:	681b      	ldr	r3, [r3, #0]
 80025da:	f003 0308 	and.w	r3, r3, #8
 80025de:	2b00      	cmp	r3, #0
 80025e0:	d03c      	beq.n	800265c <HAL_DMA_IRQHandler+0x170>
    {
      /* Clear the half transfer complete flag */
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 80025e2:	687b      	ldr	r3, [r7, #4]
 80025e4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80025e6:	2210      	movs	r2, #16
 80025e8:	409a      	lsls	r2, r3
 80025ea:	693b      	ldr	r3, [r7, #16]
 80025ec:	609a      	str	r2, [r3, #8]
      
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80025ee:	687b      	ldr	r3, [r7, #4]
 80025f0:	681b      	ldr	r3, [r3, #0]
 80025f2:	681b      	ldr	r3, [r3, #0]
 80025f4:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80025f8:	2b00      	cmp	r3, #0
 80025fa:	d018      	beq.n	800262e <HAL_DMA_IRQHandler+0x142>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80025fc:	687b      	ldr	r3, [r7, #4]
 80025fe:	681b      	ldr	r3, [r3, #0]
 8002600:	681b      	ldr	r3, [r3, #0]
 8002602:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8002606:	2b00      	cmp	r3, #0
 8002608:	d108      	bne.n	800261c <HAL_DMA_IRQHandler+0x130>
        {
          if(hdma->XferHalfCpltCallback != NULL)
 800260a:	687b      	ldr	r3, [r7, #4]
 800260c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800260e:	2b00      	cmp	r3, #0
 8002610:	d024      	beq.n	800265c <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
 8002612:	687b      	ldr	r3, [r7, #4]
 8002614:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002616:	6878      	ldr	r0, [r7, #4]
 8002618:	4798      	blx	r3
 800261a:	e01f      	b.n	800265c <HAL_DMA_IRQHandler+0x170>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 800261c:	687b      	ldr	r3, [r7, #4]
 800261e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002620:	2b00      	cmp	r3, #0
 8002622:	d01b      	beq.n	800265c <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferM1HalfCpltCallback(hdma);
 8002624:	687b      	ldr	r3, [r7, #4]
 8002626:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002628:	6878      	ldr	r0, [r7, #4]
 800262a:	4798      	blx	r3
 800262c:	e016      	b.n	800265c <HAL_DMA_IRQHandler+0x170>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 800262e:	687b      	ldr	r3, [r7, #4]
 8002630:	681b      	ldr	r3, [r3, #0]
 8002632:	681b      	ldr	r3, [r3, #0]
 8002634:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002638:	2b00      	cmp	r3, #0
 800263a:	d107      	bne.n	800264c <HAL_DMA_IRQHandler+0x160>
        {
          /* Disable the half transfer interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 800263c:	687b      	ldr	r3, [r7, #4]
 800263e:	681b      	ldr	r3, [r3, #0]
 8002640:	681a      	ldr	r2, [r3, #0]
 8002642:	687b      	ldr	r3, [r7, #4]
 8002644:	681b      	ldr	r3, [r3, #0]
 8002646:	f022 0208 	bic.w	r2, r2, #8
 800264a:	601a      	str	r2, [r3, #0]
        }
        
        if(hdma->XferHalfCpltCallback != NULL)
 800264c:	687b      	ldr	r3, [r7, #4]
 800264e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002650:	2b00      	cmp	r3, #0
 8002652:	d003      	beq.n	800265c <HAL_DMA_IRQHandler+0x170>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 8002654:	687b      	ldr	r3, [r7, #4]
 8002656:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002658:	6878      	ldr	r0, [r7, #4]
 800265a:	4798      	blx	r3
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 800265c:	687b      	ldr	r3, [r7, #4]
 800265e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002660:	2220      	movs	r2, #32
 8002662:	409a      	lsls	r2, r3
 8002664:	68fb      	ldr	r3, [r7, #12]
 8002666:	4013      	ands	r3, r2
 8002668:	2b00      	cmp	r3, #0
 800266a:	f000 808e 	beq.w	800278a <HAL_DMA_IRQHandler+0x29e>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 800266e:	687b      	ldr	r3, [r7, #4]
 8002670:	681b      	ldr	r3, [r3, #0]
 8002672:	681b      	ldr	r3, [r3, #0]
 8002674:	f003 0310 	and.w	r3, r3, #16
 8002678:	2b00      	cmp	r3, #0
 800267a:	f000 8086 	beq.w	800278a <HAL_DMA_IRQHandler+0x29e>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 800267e:	687b      	ldr	r3, [r7, #4]
 8002680:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002682:	2220      	movs	r2, #32
 8002684:	409a      	lsls	r2, r3
 8002686:	693b      	ldr	r3, [r7, #16]
 8002688:	609a      	str	r2, [r3, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
 800268a:	687b      	ldr	r3, [r7, #4]
 800268c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8002690:	b2db      	uxtb	r3, r3
 8002692:	2b05      	cmp	r3, #5
 8002694:	d136      	bne.n	8002704 <HAL_DMA_IRQHandler+0x218>
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8002696:	687b      	ldr	r3, [r7, #4]
 8002698:	681b      	ldr	r3, [r3, #0]
 800269a:	681a      	ldr	r2, [r3, #0]
 800269c:	687b      	ldr	r3, [r7, #4]
 800269e:	681b      	ldr	r3, [r3, #0]
 80026a0:	f022 0216 	bic.w	r2, r2, #22
 80026a4:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 80026a6:	687b      	ldr	r3, [r7, #4]
 80026a8:	681b      	ldr	r3, [r3, #0]
 80026aa:	695a      	ldr	r2, [r3, #20]
 80026ac:	687b      	ldr	r3, [r7, #4]
 80026ae:	681b      	ldr	r3, [r3, #0]
 80026b0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80026b4:	615a      	str	r2, [r3, #20]
        
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 80026b6:	687b      	ldr	r3, [r7, #4]
 80026b8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80026ba:	2b00      	cmp	r3, #0
 80026bc:	d103      	bne.n	80026c6 <HAL_DMA_IRQHandler+0x1da>
 80026be:	687b      	ldr	r3, [r7, #4]
 80026c0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80026c2:	2b00      	cmp	r3, #0
 80026c4:	d007      	beq.n	80026d6 <HAL_DMA_IRQHandler+0x1ea>
        {
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 80026c6:	687b      	ldr	r3, [r7, #4]
 80026c8:	681b      	ldr	r3, [r3, #0]
 80026ca:	681a      	ldr	r2, [r3, #0]
 80026cc:	687b      	ldr	r3, [r7, #4]
 80026ce:	681b      	ldr	r3, [r3, #0]
 80026d0:	f022 0208 	bic.w	r2, r2, #8
 80026d4:	601a      	str	r2, [r3, #0]
        }

        /* Clear all interrupt flags at correct offset within the register */
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 80026d6:	687b      	ldr	r3, [r7, #4]
 80026d8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80026da:	223f      	movs	r2, #63	; 0x3f
 80026dc:	409a      	lsls	r2, r3
 80026de:	693b      	ldr	r3, [r7, #16]
 80026e0:	609a      	str	r2, [r3, #8]

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 80026e2:	687b      	ldr	r3, [r7, #4]
 80026e4:	2200      	movs	r2, #0
 80026e6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 80026ea:	687b      	ldr	r3, [r7, #4]
 80026ec:	2201      	movs	r2, #1
 80026ee:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        if(hdma->XferAbortCallback != NULL)
 80026f2:	687b      	ldr	r3, [r7, #4]
 80026f4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80026f6:	2b00      	cmp	r3, #0
 80026f8:	d07d      	beq.n	80027f6 <HAL_DMA_IRQHandler+0x30a>
        {
          hdma->XferAbortCallback(hdma);
 80026fa:	687b      	ldr	r3, [r7, #4]
 80026fc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80026fe:	6878      	ldr	r0, [r7, #4]
 8002700:	4798      	blx	r3
        }
        return;
 8002702:	e078      	b.n	80027f6 <HAL_DMA_IRQHandler+0x30a>
      }

      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8002704:	687b      	ldr	r3, [r7, #4]
 8002706:	681b      	ldr	r3, [r3, #0]
 8002708:	681b      	ldr	r3, [r3, #0]
 800270a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800270e:	2b00      	cmp	r3, #0
 8002710:	d01c      	beq.n	800274c <HAL_DMA_IRQHandler+0x260>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8002712:	687b      	ldr	r3, [r7, #4]
 8002714:	681b      	ldr	r3, [r3, #0]
 8002716:	681b      	ldr	r3, [r3, #0]
 8002718:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800271c:	2b00      	cmp	r3, #0
 800271e:	d108      	bne.n	8002732 <HAL_DMA_IRQHandler+0x246>
        {
          if(hdma->XferM1CpltCallback != NULL)
 8002720:	687b      	ldr	r3, [r7, #4]
 8002722:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002724:	2b00      	cmp	r3, #0
 8002726:	d030      	beq.n	800278a <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 8002728:	687b      	ldr	r3, [r7, #4]
 800272a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800272c:	6878      	ldr	r0, [r7, #4]
 800272e:	4798      	blx	r3
 8002730:	e02b      	b.n	800278a <HAL_DMA_IRQHandler+0x29e>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
 8002732:	687b      	ldr	r3, [r7, #4]
 8002734:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002736:	2b00      	cmp	r3, #0
 8002738:	d027      	beq.n	800278a <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 800273a:	687b      	ldr	r3, [r7, #4]
 800273c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800273e:	6878      	ldr	r0, [r7, #4]
 8002740:	4798      	blx	r3
 8002742:	e022      	b.n	800278a <HAL_DMA_IRQHandler+0x29e>
 8002744:	20000000 	.word	0x20000000
 8002748:	1b4e81b5 	.word	0x1b4e81b5
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 800274c:	687b      	ldr	r3, [r7, #4]
 800274e:	681b      	ldr	r3, [r3, #0]
 8002750:	681b      	ldr	r3, [r3, #0]
 8002752:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002756:	2b00      	cmp	r3, #0
 8002758:	d10f      	bne.n	800277a <HAL_DMA_IRQHandler+0x28e>
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 800275a:	687b      	ldr	r3, [r7, #4]
 800275c:	681b      	ldr	r3, [r3, #0]
 800275e:	681a      	ldr	r2, [r3, #0]
 8002760:	687b      	ldr	r3, [r7, #4]
 8002762:	681b      	ldr	r3, [r3, #0]
 8002764:	f022 0210 	bic.w	r2, r2, #16
 8002768:	601a      	str	r2, [r3, #0]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 800276a:	687b      	ldr	r3, [r7, #4]
 800276c:	2200      	movs	r2, #0
 800276e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 8002772:	687b      	ldr	r3, [r7, #4]
 8002774:	2201      	movs	r2, #1
 8002776:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        if(hdma->XferCpltCallback != NULL)
 800277a:	687b      	ldr	r3, [r7, #4]
 800277c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800277e:	2b00      	cmp	r3, #0
 8002780:	d003      	beq.n	800278a <HAL_DMA_IRQHandler+0x29e>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 8002782:	687b      	ldr	r3, [r7, #4]
 8002784:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002786:	6878      	ldr	r0, [r7, #4]
 8002788:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 800278a:	687b      	ldr	r3, [r7, #4]
 800278c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800278e:	2b00      	cmp	r3, #0
 8002790:	d032      	beq.n	80027f8 <HAL_DMA_IRQHandler+0x30c>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8002792:	687b      	ldr	r3, [r7, #4]
 8002794:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002796:	f003 0301 	and.w	r3, r3, #1
 800279a:	2b00      	cmp	r3, #0
 800279c:	d022      	beq.n	80027e4 <HAL_DMA_IRQHandler+0x2f8>
    {
      hdma->State = HAL_DMA_STATE_ABORT;
 800279e:	687b      	ldr	r3, [r7, #4]
 80027a0:	2205      	movs	r2, #5
 80027a2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 80027a6:	687b      	ldr	r3, [r7, #4]
 80027a8:	681b      	ldr	r3, [r3, #0]
 80027aa:	681a      	ldr	r2, [r3, #0]
 80027ac:	687b      	ldr	r3, [r7, #4]
 80027ae:	681b      	ldr	r3, [r3, #0]
 80027b0:	f022 0201 	bic.w	r2, r2, #1
 80027b4:	601a      	str	r2, [r3, #0]

      do
      {
        if (++count > timeout)
 80027b6:	68bb      	ldr	r3, [r7, #8]
 80027b8:	3301      	adds	r3, #1
 80027ba:	60bb      	str	r3, [r7, #8]
 80027bc:	697a      	ldr	r2, [r7, #20]
 80027be:	429a      	cmp	r2, r3
 80027c0:	d307      	bcc.n	80027d2 <HAL_DMA_IRQHandler+0x2e6>
        {
          break;
        }
      }
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 80027c2:	687b      	ldr	r3, [r7, #4]
 80027c4:	681b      	ldr	r3, [r3, #0]
 80027c6:	681b      	ldr	r3, [r3, #0]
 80027c8:	f003 0301 	and.w	r3, r3, #1
 80027cc:	2b00      	cmp	r3, #0
 80027ce:	d1f2      	bne.n	80027b6 <HAL_DMA_IRQHandler+0x2ca>
 80027d0:	e000      	b.n	80027d4 <HAL_DMA_IRQHandler+0x2e8>
          break;
 80027d2:	bf00      	nop

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 80027d4:	687b      	ldr	r3, [r7, #4]
 80027d6:	2200      	movs	r2, #0
 80027d8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 80027dc:	687b      	ldr	r3, [r7, #4]
 80027de:	2201      	movs	r2, #1
 80027e0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    }

    if(hdma->XferErrorCallback != NULL)
 80027e4:	687b      	ldr	r3, [r7, #4]
 80027e6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80027e8:	2b00      	cmp	r3, #0
 80027ea:	d005      	beq.n	80027f8 <HAL_DMA_IRQHandler+0x30c>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 80027ec:	687b      	ldr	r3, [r7, #4]
 80027ee:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80027f0:	6878      	ldr	r0, [r7, #4]
 80027f2:	4798      	blx	r3
 80027f4:	e000      	b.n	80027f8 <HAL_DMA_IRQHandler+0x30c>
        return;
 80027f6:	bf00      	nop
    }
  }
}
 80027f8:	3718      	adds	r7, #24
 80027fa:	46bd      	mov	sp, r7
 80027fc:	bd80      	pop	{r7, pc}
 80027fe:	bf00      	nop

08002800 <HAL_DMA_GetState>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
 8002800:	b480      	push	{r7}
 8002802:	b083      	sub	sp, #12
 8002804:	af00      	add	r7, sp, #0
 8002806:	6078      	str	r0, [r7, #4]
  return hdma->State;
 8002808:	687b      	ldr	r3, [r7, #4]
 800280a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 800280e:	b2db      	uxtb	r3, r3
}
 8002810:	4618      	mov	r0, r3
 8002812:	370c      	adds	r7, #12
 8002814:	46bd      	mov	sp, r7
 8002816:	f85d 7b04 	ldr.w	r7, [sp], #4
 800281a:	4770      	bx	lr

0800281c <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 800281c:	b480      	push	{r7}
 800281e:	b085      	sub	sp, #20
 8002820:	af00      	add	r7, sp, #0
 8002822:	60f8      	str	r0, [r7, #12]
 8002824:	60b9      	str	r1, [r7, #8]
 8002826:	607a      	str	r2, [r7, #4]
 8002828:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 800282a:	68fb      	ldr	r3, [r7, #12]
 800282c:	681b      	ldr	r3, [r3, #0]
 800282e:	681a      	ldr	r2, [r3, #0]
 8002830:	68fb      	ldr	r3, [r7, #12]
 8002832:	681b      	ldr	r3, [r3, #0]
 8002834:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002838:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 800283a:	68fb      	ldr	r3, [r7, #12]
 800283c:	681b      	ldr	r3, [r3, #0]
 800283e:	683a      	ldr	r2, [r7, #0]
 8002840:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8002842:	68fb      	ldr	r3, [r7, #12]
 8002844:	689b      	ldr	r3, [r3, #8]
 8002846:	2b40      	cmp	r3, #64	; 0x40
 8002848:	d108      	bne.n	800285c <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 800284a:	68fb      	ldr	r3, [r7, #12]
 800284c:	681b      	ldr	r3, [r3, #0]
 800284e:	687a      	ldr	r2, [r7, #4]
 8002850:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 8002852:	68fb      	ldr	r3, [r7, #12]
 8002854:	681b      	ldr	r3, [r3, #0]
 8002856:	68ba      	ldr	r2, [r7, #8]
 8002858:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
 800285a:	e007      	b.n	800286c <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
 800285c:	68fb      	ldr	r3, [r7, #12]
 800285e:	681b      	ldr	r3, [r3, #0]
 8002860:	68ba      	ldr	r2, [r7, #8]
 8002862:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
 8002864:	68fb      	ldr	r3, [r7, #12]
 8002866:	681b      	ldr	r3, [r3, #0]
 8002868:	687a      	ldr	r2, [r7, #4]
 800286a:	60da      	str	r2, [r3, #12]
}
 800286c:	bf00      	nop
 800286e:	3714      	adds	r7, #20
 8002870:	46bd      	mov	sp, r7
 8002872:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002876:	4770      	bx	lr

08002878 <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 8002878:	b480      	push	{r7}
 800287a:	b085      	sub	sp, #20
 800287c:	af00      	add	r7, sp, #0
 800287e:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8002880:	687b      	ldr	r3, [r7, #4]
 8002882:	681b      	ldr	r3, [r3, #0]
 8002884:	b2db      	uxtb	r3, r3
 8002886:	3b10      	subs	r3, #16
 8002888:	4a14      	ldr	r2, [pc, #80]	; (80028dc <DMA_CalcBaseAndBitshift+0x64>)
 800288a:	fba2 2303 	umull	r2, r3, r2, r3
 800288e:	091b      	lsrs	r3, r3, #4
 8002890:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8002892:	4a13      	ldr	r2, [pc, #76]	; (80028e0 <DMA_CalcBaseAndBitshift+0x68>)
 8002894:	68fb      	ldr	r3, [r7, #12]
 8002896:	4413      	add	r3, r2
 8002898:	781b      	ldrb	r3, [r3, #0]
 800289a:	461a      	mov	r2, r3
 800289c:	687b      	ldr	r3, [r7, #4]
 800289e:	65da      	str	r2, [r3, #92]	; 0x5c
  
  if (stream_number > 3U)
 80028a0:	68fb      	ldr	r3, [r7, #12]
 80028a2:	2b03      	cmp	r3, #3
 80028a4:	d909      	bls.n	80028ba <DMA_CalcBaseAndBitshift+0x42>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80028a6:	687b      	ldr	r3, [r7, #4]
 80028a8:	681b      	ldr	r3, [r3, #0]
 80028aa:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 80028ae:	f023 0303 	bic.w	r3, r3, #3
 80028b2:	1d1a      	adds	r2, r3, #4
 80028b4:	687b      	ldr	r3, [r7, #4]
 80028b6:	659a      	str	r2, [r3, #88]	; 0x58
 80028b8:	e007      	b.n	80028ca <DMA_CalcBaseAndBitshift+0x52>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 80028ba:	687b      	ldr	r3, [r7, #4]
 80028bc:	681b      	ldr	r3, [r3, #0]
 80028be:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 80028c2:	f023 0303 	bic.w	r3, r3, #3
 80028c6:	687a      	ldr	r2, [r7, #4]
 80028c8:	6593      	str	r3, [r2, #88]	; 0x58
  }
  
  return hdma->StreamBaseAddress;
 80028ca:	687b      	ldr	r3, [r7, #4]
 80028cc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
 80028ce:	4618      	mov	r0, r3
 80028d0:	3714      	adds	r7, #20
 80028d2:	46bd      	mov	sp, r7
 80028d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028d8:	4770      	bx	lr
 80028da:	bf00      	nop
 80028dc:	aaaaaaab 	.word	0xaaaaaaab
 80028e0:	08030884 	.word	0x08030884

080028e4 <DMA_CheckFifoParam>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
 80028e4:	b480      	push	{r7}
 80028e6:	b085      	sub	sp, #20
 80028e8:	af00      	add	r7, sp, #0
 80028ea:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80028ec:	2300      	movs	r3, #0
 80028ee:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = hdma->Init.FIFOThreshold;
 80028f0:	687b      	ldr	r3, [r7, #4]
 80028f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80028f4:	60bb      	str	r3, [r7, #8]
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 80028f6:	687b      	ldr	r3, [r7, #4]
 80028f8:	699b      	ldr	r3, [r3, #24]
 80028fa:	2b00      	cmp	r3, #0
 80028fc:	d11f      	bne.n	800293e <DMA_CheckFifoParam+0x5a>
  {
    switch (tmp)
 80028fe:	68bb      	ldr	r3, [r7, #8]
 8002900:	2b03      	cmp	r3, #3
 8002902:	d855      	bhi.n	80029b0 <DMA_CheckFifoParam+0xcc>
 8002904:	a201      	add	r2, pc, #4	; (adr r2, 800290c <DMA_CheckFifoParam+0x28>)
 8002906:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800290a:	bf00      	nop
 800290c:	0800291d 	.word	0x0800291d
 8002910:	0800292f 	.word	0x0800292f
 8002914:	0800291d 	.word	0x0800291d
 8002918:	080029b1 	.word	0x080029b1
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800291c:	687b      	ldr	r3, [r7, #4]
 800291e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002920:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8002924:	2b00      	cmp	r3, #0
 8002926:	d045      	beq.n	80029b4 <DMA_CheckFifoParam+0xd0>
      {
        status = HAL_ERROR;
 8002928:	2301      	movs	r3, #1
 800292a:	73fb      	strb	r3, [r7, #15]
      }
      break;
 800292c:	e042      	b.n	80029b4 <DMA_CheckFifoParam+0xd0>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 800292e:	687b      	ldr	r3, [r7, #4]
 8002930:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002932:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 8002936:	d13f      	bne.n	80029b8 <DMA_CheckFifoParam+0xd4>
      {
        status = HAL_ERROR;
 8002938:	2301      	movs	r3, #1
 800293a:	73fb      	strb	r3, [r7, #15]
      }
      break;
 800293c:	e03c      	b.n	80029b8 <DMA_CheckFifoParam+0xd4>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 800293e:	687b      	ldr	r3, [r7, #4]
 8002940:	699b      	ldr	r3, [r3, #24]
 8002942:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8002946:	d121      	bne.n	800298c <DMA_CheckFifoParam+0xa8>
  {
    switch (tmp)
 8002948:	68bb      	ldr	r3, [r7, #8]
 800294a:	2b03      	cmp	r3, #3
 800294c:	d836      	bhi.n	80029bc <DMA_CheckFifoParam+0xd8>
 800294e:	a201      	add	r2, pc, #4	; (adr r2, 8002954 <DMA_CheckFifoParam+0x70>)
 8002950:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002954:	08002965 	.word	0x08002965
 8002958:	0800296b 	.word	0x0800296b
 800295c:	08002965 	.word	0x08002965
 8002960:	0800297d 	.word	0x0800297d
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
 8002964:	2301      	movs	r3, #1
 8002966:	73fb      	strb	r3, [r7, #15]
      break;
 8002968:	e02f      	b.n	80029ca <DMA_CheckFifoParam+0xe6>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800296a:	687b      	ldr	r3, [r7, #4]
 800296c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800296e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8002972:	2b00      	cmp	r3, #0
 8002974:	d024      	beq.n	80029c0 <DMA_CheckFifoParam+0xdc>
      {
        status = HAL_ERROR;
 8002976:	2301      	movs	r3, #1
 8002978:	73fb      	strb	r3, [r7, #15]
      }
      break;
 800297a:	e021      	b.n	80029c0 <DMA_CheckFifoParam+0xdc>
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 800297c:	687b      	ldr	r3, [r7, #4]
 800297e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002980:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 8002984:	d11e      	bne.n	80029c4 <DMA_CheckFifoParam+0xe0>
      {
        status = HAL_ERROR;
 8002986:	2301      	movs	r3, #1
 8002988:	73fb      	strb	r3, [r7, #15]
      }
      break;   
 800298a:	e01b      	b.n	80029c4 <DMA_CheckFifoParam+0xe0>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 800298c:	68bb      	ldr	r3, [r7, #8]
 800298e:	2b02      	cmp	r3, #2
 8002990:	d902      	bls.n	8002998 <DMA_CheckFifoParam+0xb4>
 8002992:	2b03      	cmp	r3, #3
 8002994:	d003      	beq.n	800299e <DMA_CheckFifoParam+0xba>
      {
        status = HAL_ERROR;
      }
      break;
    default:
      break;
 8002996:	e018      	b.n	80029ca <DMA_CheckFifoParam+0xe6>
      status = HAL_ERROR;
 8002998:	2301      	movs	r3, #1
 800299a:	73fb      	strb	r3, [r7, #15]
      break;
 800299c:	e015      	b.n	80029ca <DMA_CheckFifoParam+0xe6>
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800299e:	687b      	ldr	r3, [r7, #4]
 80029a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80029a2:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80029a6:	2b00      	cmp	r3, #0
 80029a8:	d00e      	beq.n	80029c8 <DMA_CheckFifoParam+0xe4>
        status = HAL_ERROR;
 80029aa:	2301      	movs	r3, #1
 80029ac:	73fb      	strb	r3, [r7, #15]
      break;
 80029ae:	e00b      	b.n	80029c8 <DMA_CheckFifoParam+0xe4>
      break;
 80029b0:	bf00      	nop
 80029b2:	e00a      	b.n	80029ca <DMA_CheckFifoParam+0xe6>
      break;
 80029b4:	bf00      	nop
 80029b6:	e008      	b.n	80029ca <DMA_CheckFifoParam+0xe6>
      break;
 80029b8:	bf00      	nop
 80029ba:	e006      	b.n	80029ca <DMA_CheckFifoParam+0xe6>
      break;
 80029bc:	bf00      	nop
 80029be:	e004      	b.n	80029ca <DMA_CheckFifoParam+0xe6>
      break;
 80029c0:	bf00      	nop
 80029c2:	e002      	b.n	80029ca <DMA_CheckFifoParam+0xe6>
      break;   
 80029c4:	bf00      	nop
 80029c6:	e000      	b.n	80029ca <DMA_CheckFifoParam+0xe6>
      break;
 80029c8:	bf00      	nop
    }
  } 
  
  return status; 
 80029ca:	7bfb      	ldrb	r3, [r7, #15]
}
 80029cc:	4618      	mov	r0, r3
 80029ce:	3714      	adds	r7, #20
 80029d0:	46bd      	mov	sp, r7
 80029d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80029d6:	4770      	bx	lr

080029d8 <HAL_FLASH_Program>:
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 80029d8:	b580      	push	{r7, lr}
 80029da:	b086      	sub	sp, #24
 80029dc:	af00      	add	r7, sp, #0
 80029de:	60f8      	str	r0, [r7, #12]
 80029e0:	60b9      	str	r1, [r7, #8]
 80029e2:	e9c7 2300 	strd	r2, r3, [r7]
  HAL_StatusTypeDef status = HAL_ERROR;
 80029e6:	2301      	movs	r3, #1
 80029e8:	75fb      	strb	r3, [r7, #23]
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 80029ea:	4b23      	ldr	r3, [pc, #140]	; (8002a78 <HAL_FLASH_Program+0xa0>)
 80029ec:	7e1b      	ldrb	r3, [r3, #24]
 80029ee:	2b01      	cmp	r3, #1
 80029f0:	d101      	bne.n	80029f6 <HAL_FLASH_Program+0x1e>
 80029f2:	2302      	movs	r3, #2
 80029f4:	e03b      	b.n	8002a6e <HAL_FLASH_Program+0x96>
 80029f6:	4b20      	ldr	r3, [pc, #128]	; (8002a78 <HAL_FLASH_Program+0xa0>)
 80029f8:	2201      	movs	r2, #1
 80029fa:	761a      	strb	r2, [r3, #24]
  
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80029fc:	f24c 3050 	movw	r0, #50000	; 0xc350
 8002a00:	f000 f870 	bl	8002ae4 <FLASH_WaitForLastOperation>
 8002a04:	4603      	mov	r3, r0
 8002a06:	75fb      	strb	r3, [r7, #23]
  
  if(status == HAL_OK)
 8002a08:	7dfb      	ldrb	r3, [r7, #23]
 8002a0a:	2b00      	cmp	r3, #0
 8002a0c:	d12b      	bne.n	8002a66 <HAL_FLASH_Program+0x8e>
  {
    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
 8002a0e:	68fb      	ldr	r3, [r7, #12]
 8002a10:	2b00      	cmp	r3, #0
 8002a12:	d105      	bne.n	8002a20 <HAL_FLASH_Program+0x48>
    {
      /*Program byte (8-bit) at a specified address.*/
      FLASH_Program_Byte(Address, (uint8_t) Data);
 8002a14:	783b      	ldrb	r3, [r7, #0]
 8002a16:	4619      	mov	r1, r3
 8002a18:	68b8      	ldr	r0, [r7, #8]
 8002a1a:	f000 f919 	bl	8002c50 <FLASH_Program_Byte>
 8002a1e:	e016      	b.n	8002a4e <HAL_FLASH_Program+0x76>
    }
    else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 8002a20:	68fb      	ldr	r3, [r7, #12]
 8002a22:	2b01      	cmp	r3, #1
 8002a24:	d105      	bne.n	8002a32 <HAL_FLASH_Program+0x5a>
    {
      /*Program halfword (16-bit) at a specified address.*/
      FLASH_Program_HalfWord(Address, (uint16_t) Data);
 8002a26:	883b      	ldrh	r3, [r7, #0]
 8002a28:	4619      	mov	r1, r3
 8002a2a:	68b8      	ldr	r0, [r7, #8]
 8002a2c:	f000 f8ec 	bl	8002c08 <FLASH_Program_HalfWord>
 8002a30:	e00d      	b.n	8002a4e <HAL_FLASH_Program+0x76>
    }
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 8002a32:	68fb      	ldr	r3, [r7, #12]
 8002a34:	2b02      	cmp	r3, #2
 8002a36:	d105      	bne.n	8002a44 <HAL_FLASH_Program+0x6c>
    {
      /*Program word (32-bit) at a specified address.*/
      FLASH_Program_Word(Address, (uint32_t) Data);
 8002a38:	683b      	ldr	r3, [r7, #0]
 8002a3a:	4619      	mov	r1, r3
 8002a3c:	68b8      	ldr	r0, [r7, #8]
 8002a3e:	f000 f8c1 	bl	8002bc4 <FLASH_Program_Word>
 8002a42:	e004      	b.n	8002a4e <HAL_FLASH_Program+0x76>
    }
    else
    {
      /*Program double word (64-bit) at a specified address.*/
      FLASH_Program_DoubleWord(Address, Data);
 8002a44:	e9d7 2300 	ldrd	r2, r3, [r7]
 8002a48:	68b8      	ldr	r0, [r7, #8]
 8002a4a:	f000 f88b 	bl	8002b64 <FLASH_Program_DoubleWord>
    }
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8002a4e:	f24c 3050 	movw	r0, #50000	; 0xc350
 8002a52:	f000 f847 	bl	8002ae4 <FLASH_WaitForLastOperation>
 8002a56:	4603      	mov	r3, r0
 8002a58:	75fb      	strb	r3, [r7, #23]
    
    /* If the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);  
 8002a5a:	4b08      	ldr	r3, [pc, #32]	; (8002a7c <HAL_FLASH_Program+0xa4>)
 8002a5c:	691b      	ldr	r3, [r3, #16]
 8002a5e:	4a07      	ldr	r2, [pc, #28]	; (8002a7c <HAL_FLASH_Program+0xa4>)
 8002a60:	f023 0301 	bic.w	r3, r3, #1
 8002a64:	6113      	str	r3, [r2, #16]
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 8002a66:	4b04      	ldr	r3, [pc, #16]	; (8002a78 <HAL_FLASH_Program+0xa0>)
 8002a68:	2200      	movs	r2, #0
 8002a6a:	761a      	strb	r2, [r3, #24]
  
  return status;
 8002a6c:	7dfb      	ldrb	r3, [r7, #23]
}
 8002a6e:	4618      	mov	r0, r3
 8002a70:	3718      	adds	r7, #24
 8002a72:	46bd      	mov	sp, r7
 8002a74:	bd80      	pop	{r7, pc}
 8002a76:	bf00      	nop
 8002a78:	2000a694 	.word	0x2000a694
 8002a7c:	40023c00 	.word	0x40023c00

08002a80 <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
 8002a80:	b480      	push	{r7}
 8002a82:	b083      	sub	sp, #12
 8002a84:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 8002a86:	2300      	movs	r3, #0
 8002a88:	71fb      	strb	r3, [r7, #7]

  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8002a8a:	4b0b      	ldr	r3, [pc, #44]	; (8002ab8 <HAL_FLASH_Unlock+0x38>)
 8002a8c:	691b      	ldr	r3, [r3, #16]
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	da0b      	bge.n	8002aaa <HAL_FLASH_Unlock+0x2a>
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8002a92:	4b09      	ldr	r3, [pc, #36]	; (8002ab8 <HAL_FLASH_Unlock+0x38>)
 8002a94:	4a09      	ldr	r2, [pc, #36]	; (8002abc <HAL_FLASH_Unlock+0x3c>)
 8002a96:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8002a98:	4b07      	ldr	r3, [pc, #28]	; (8002ab8 <HAL_FLASH_Unlock+0x38>)
 8002a9a:	4a09      	ldr	r2, [pc, #36]	; (8002ac0 <HAL_FLASH_Unlock+0x40>)
 8002a9c:	605a      	str	r2, [r3, #4]

    /* Verify Flash is unlocked */
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8002a9e:	4b06      	ldr	r3, [pc, #24]	; (8002ab8 <HAL_FLASH_Unlock+0x38>)
 8002aa0:	691b      	ldr	r3, [r3, #16]
 8002aa2:	2b00      	cmp	r3, #0
 8002aa4:	da01      	bge.n	8002aaa <HAL_FLASH_Unlock+0x2a>
    {
      status = HAL_ERROR;
 8002aa6:	2301      	movs	r3, #1
 8002aa8:	71fb      	strb	r3, [r7, #7]
    }
  }

  return status;
 8002aaa:	79fb      	ldrb	r3, [r7, #7]
}
 8002aac:	4618      	mov	r0, r3
 8002aae:	370c      	adds	r7, #12
 8002ab0:	46bd      	mov	sp, r7
 8002ab2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ab6:	4770      	bx	lr
 8002ab8:	40023c00 	.word	0x40023c00
 8002abc:	45670123 	.word	0x45670123
 8002ac0:	cdef89ab 	.word	0xcdef89ab

08002ac4 <HAL_FLASH_Lock>:
/**
  * @brief  Locks the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
 8002ac4:	b480      	push	{r7}
 8002ac6:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 8002ac8:	4b05      	ldr	r3, [pc, #20]	; (8002ae0 <HAL_FLASH_Lock+0x1c>)
 8002aca:	691b      	ldr	r3, [r3, #16]
 8002acc:	4a04      	ldr	r2, [pc, #16]	; (8002ae0 <HAL_FLASH_Lock+0x1c>)
 8002ace:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002ad2:	6113      	str	r3, [r2, #16]
  
  return HAL_OK;  
 8002ad4:	2300      	movs	r3, #0
}
 8002ad6:	4618      	mov	r0, r3
 8002ad8:	46bd      	mov	sp, r7
 8002ada:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ade:	4770      	bx	lr
 8002ae0:	40023c00 	.word	0x40023c00

08002ae4 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operationtimeout
  * @retval HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
 8002ae4:	b580      	push	{r7, lr}
 8002ae6:	b084      	sub	sp, #16
 8002ae8:	af00      	add	r7, sp, #0
 8002aea:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8002aec:	2300      	movs	r3, #0
 8002aee:	60fb      	str	r3, [r7, #12]
  
  /* Clear Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8002af0:	4b1a      	ldr	r3, [pc, #104]	; (8002b5c <FLASH_WaitForLastOperation+0x78>)
 8002af2:	2200      	movs	r2, #0
 8002af4:	61da      	str	r2, [r3, #28]
  
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  /* Get tick */
  tickstart = HAL_GetTick();
 8002af6:	f7ff fac1 	bl	800207c <HAL_GetTick>
 8002afa:	60f8      	str	r0, [r7, #12]

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8002afc:	e010      	b.n	8002b20 <FLASH_WaitForLastOperation+0x3c>
  { 
    if(Timeout != HAL_MAX_DELAY)
 8002afe:	687b      	ldr	r3, [r7, #4]
 8002b00:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002b04:	d00c      	beq.n	8002b20 <FLASH_WaitForLastOperation+0x3c>
    {
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 8002b06:	687b      	ldr	r3, [r7, #4]
 8002b08:	2b00      	cmp	r3, #0
 8002b0a:	d007      	beq.n	8002b1c <FLASH_WaitForLastOperation+0x38>
 8002b0c:	f7ff fab6 	bl	800207c <HAL_GetTick>
 8002b10:	4602      	mov	r2, r0
 8002b12:	68fb      	ldr	r3, [r7, #12]
 8002b14:	1ad3      	subs	r3, r2, r3
 8002b16:	687a      	ldr	r2, [r7, #4]
 8002b18:	429a      	cmp	r2, r3
 8002b1a:	d201      	bcs.n	8002b20 <FLASH_WaitForLastOperation+0x3c>
      {
        return HAL_TIMEOUT;
 8002b1c:	2303      	movs	r3, #3
 8002b1e:	e019      	b.n	8002b54 <FLASH_WaitForLastOperation+0x70>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8002b20:	4b0f      	ldr	r3, [pc, #60]	; (8002b60 <FLASH_WaitForLastOperation+0x7c>)
 8002b22:	68db      	ldr	r3, [r3, #12]
 8002b24:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002b28:	2b00      	cmp	r3, #0
 8002b2a:	d1e8      	bne.n	8002afe <FLASH_WaitForLastOperation+0x1a>
      }
    } 
  }

  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 8002b2c:	4b0c      	ldr	r3, [pc, #48]	; (8002b60 <FLASH_WaitForLastOperation+0x7c>)
 8002b2e:	68db      	ldr	r3, [r3, #12]
 8002b30:	f003 0301 	and.w	r3, r3, #1
 8002b34:	2b00      	cmp	r3, #0
 8002b36:	d002      	beq.n	8002b3e <FLASH_WaitForLastOperation+0x5a>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8002b38:	4b09      	ldr	r3, [pc, #36]	; (8002b60 <FLASH_WaitForLastOperation+0x7c>)
 8002b3a:	2201      	movs	r2, #1
 8002b3c:	60da      	str	r2, [r3, #12]
  }
#if defined(FLASH_SR_RDERR)  
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 8002b3e:	4b08      	ldr	r3, [pc, #32]	; (8002b60 <FLASH_WaitForLastOperation+0x7c>)
 8002b40:	68db      	ldr	r3, [r3, #12]
 8002b42:	f403 73f9 	and.w	r3, r3, #498	; 0x1f2
 8002b46:	2b00      	cmp	r3, #0
 8002b48:	d003      	beq.n	8002b52 <FLASH_WaitForLastOperation+0x6e>
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
                           FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR)) != RESET)
#endif /* FLASH_SR_RDERR */
  {
    /*Save the error code*/
    FLASH_SetErrorCode();
 8002b4a:	f000 f8a3 	bl	8002c94 <FLASH_SetErrorCode>
    return HAL_ERROR;
 8002b4e:	2301      	movs	r3, #1
 8002b50:	e000      	b.n	8002b54 <FLASH_WaitForLastOperation+0x70>
  }

  /* If there is no error flag set */
  return HAL_OK;
 8002b52:	2300      	movs	r3, #0
  
}  
 8002b54:	4618      	mov	r0, r3
 8002b56:	3710      	adds	r7, #16
 8002b58:	46bd      	mov	sp, r7
 8002b5a:	bd80      	pop	{r7, pc}
 8002b5c:	2000a694 	.word	0x2000a694
 8002b60:	40023c00 	.word	0x40023c00

08002b64 <FLASH_Program_DoubleWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 8002b64:	b490      	push	{r4, r7}
 8002b66:	b084      	sub	sp, #16
 8002b68:	af00      	add	r7, sp, #0
 8002b6a:	60f8      	str	r0, [r7, #12]
 8002b6c:	e9c7 2300 	strd	r2, r3, [r7]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8002b70:	4b13      	ldr	r3, [pc, #76]	; (8002bc0 <FLASH_Program_DoubleWord+0x5c>)
 8002b72:	691b      	ldr	r3, [r3, #16]
 8002b74:	4a12      	ldr	r2, [pc, #72]	; (8002bc0 <FLASH_Program_DoubleWord+0x5c>)
 8002b76:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002b7a:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8002b7c:	4b10      	ldr	r3, [pc, #64]	; (8002bc0 <FLASH_Program_DoubleWord+0x5c>)
 8002b7e:	691b      	ldr	r3, [r3, #16]
 8002b80:	4a0f      	ldr	r2, [pc, #60]	; (8002bc0 <FLASH_Program_DoubleWord+0x5c>)
 8002b82:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 8002b86:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8002b88:	4b0d      	ldr	r3, [pc, #52]	; (8002bc0 <FLASH_Program_DoubleWord+0x5c>)
 8002b8a:	691b      	ldr	r3, [r3, #16]
 8002b8c:	4a0c      	ldr	r2, [pc, #48]	; (8002bc0 <FLASH_Program_DoubleWord+0x5c>)
 8002b8e:	f043 0301 	orr.w	r3, r3, #1
 8002b92:	6113      	str	r3, [r2, #16]

  /* Program first word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
 8002b94:	68fb      	ldr	r3, [r7, #12]
 8002b96:	683a      	ldr	r2, [r7, #0]
 8002b98:	601a      	str	r2, [r3, #0]
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8002b9a:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
 8002b9e:	e9d7 1200 	ldrd	r1, r2, [r7]
 8002ba2:	f04f 0300 	mov.w	r3, #0
 8002ba6:	f04f 0400 	mov.w	r4, #0
 8002baa:	0013      	movs	r3, r2
 8002bac:	2400      	movs	r4, #0
 8002bae:	68fa      	ldr	r2, [r7, #12]
 8002bb0:	3204      	adds	r2, #4
 8002bb2:	6013      	str	r3, [r2, #0]
}
 8002bb4:	bf00      	nop
 8002bb6:	3710      	adds	r7, #16
 8002bb8:	46bd      	mov	sp, r7
 8002bba:	bc90      	pop	{r4, r7}
 8002bbc:	4770      	bx	lr
 8002bbe:	bf00      	nop
 8002bc0:	40023c00 	.word	0x40023c00

08002bc4 <FLASH_Program_Word>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_Word(uint32_t Address, uint32_t Data)
{
 8002bc4:	b480      	push	{r7}
 8002bc6:	b083      	sub	sp, #12
 8002bc8:	af00      	add	r7, sp, #0
 8002bca:	6078      	str	r0, [r7, #4]
 8002bcc:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8002bce:	4b0d      	ldr	r3, [pc, #52]	; (8002c04 <FLASH_Program_Word+0x40>)
 8002bd0:	691b      	ldr	r3, [r3, #16]
 8002bd2:	4a0c      	ldr	r2, [pc, #48]	; (8002c04 <FLASH_Program_Word+0x40>)
 8002bd4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002bd8:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_WORD;
 8002bda:	4b0a      	ldr	r3, [pc, #40]	; (8002c04 <FLASH_Program_Word+0x40>)
 8002bdc:	691b      	ldr	r3, [r3, #16]
 8002bde:	4a09      	ldr	r2, [pc, #36]	; (8002c04 <FLASH_Program_Word+0x40>)
 8002be0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002be4:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8002be6:	4b07      	ldr	r3, [pc, #28]	; (8002c04 <FLASH_Program_Word+0x40>)
 8002be8:	691b      	ldr	r3, [r3, #16]
 8002bea:	4a06      	ldr	r2, [pc, #24]	; (8002c04 <FLASH_Program_Word+0x40>)
 8002bec:	f043 0301 	orr.w	r3, r3, #1
 8002bf0:	6113      	str	r3, [r2, #16]

  *(__IO uint32_t*)Address = Data;
 8002bf2:	687b      	ldr	r3, [r7, #4]
 8002bf4:	683a      	ldr	r2, [r7, #0]
 8002bf6:	601a      	str	r2, [r3, #0]
}
 8002bf8:	bf00      	nop
 8002bfa:	370c      	adds	r7, #12
 8002bfc:	46bd      	mov	sp, r7
 8002bfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c02:	4770      	bx	lr
 8002c04:	40023c00 	.word	0x40023c00

08002c08 <FLASH_Program_HalfWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
{
 8002c08:	b480      	push	{r7}
 8002c0a:	b083      	sub	sp, #12
 8002c0c:	af00      	add	r7, sp, #0
 8002c0e:	6078      	str	r0, [r7, #4]
 8002c10:	460b      	mov	r3, r1
 8002c12:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8002c14:	4b0d      	ldr	r3, [pc, #52]	; (8002c4c <FLASH_Program_HalfWord+0x44>)
 8002c16:	691b      	ldr	r3, [r3, #16]
 8002c18:	4a0c      	ldr	r2, [pc, #48]	; (8002c4c <FLASH_Program_HalfWord+0x44>)
 8002c1a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002c1e:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 8002c20:	4b0a      	ldr	r3, [pc, #40]	; (8002c4c <FLASH_Program_HalfWord+0x44>)
 8002c22:	691b      	ldr	r3, [r3, #16]
 8002c24:	4a09      	ldr	r2, [pc, #36]	; (8002c4c <FLASH_Program_HalfWord+0x44>)
 8002c26:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002c2a:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8002c2c:	4b07      	ldr	r3, [pc, #28]	; (8002c4c <FLASH_Program_HalfWord+0x44>)
 8002c2e:	691b      	ldr	r3, [r3, #16]
 8002c30:	4a06      	ldr	r2, [pc, #24]	; (8002c4c <FLASH_Program_HalfWord+0x44>)
 8002c32:	f043 0301 	orr.w	r3, r3, #1
 8002c36:	6113      	str	r3, [r2, #16]

  *(__IO uint16_t*)Address = Data;
 8002c38:	687b      	ldr	r3, [r7, #4]
 8002c3a:	887a      	ldrh	r2, [r7, #2]
 8002c3c:	801a      	strh	r2, [r3, #0]
}
 8002c3e:	bf00      	nop
 8002c40:	370c      	adds	r7, #12
 8002c42:	46bd      	mov	sp, r7
 8002c44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c48:	4770      	bx	lr
 8002c4a:	bf00      	nop
 8002c4c:	40023c00 	.word	0x40023c00

08002c50 <FLASH_Program_Byte>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)
{
 8002c50:	b480      	push	{r7}
 8002c52:	b083      	sub	sp, #12
 8002c54:	af00      	add	r7, sp, #0
 8002c56:	6078      	str	r0, [r7, #4]
 8002c58:	460b      	mov	r3, r1
 8002c5a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8002c5c:	4b0c      	ldr	r3, [pc, #48]	; (8002c90 <FLASH_Program_Byte+0x40>)
 8002c5e:	691b      	ldr	r3, [r3, #16]
 8002c60:	4a0b      	ldr	r2, [pc, #44]	; (8002c90 <FLASH_Program_Byte+0x40>)
 8002c62:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002c66:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
 8002c68:	4b09      	ldr	r3, [pc, #36]	; (8002c90 <FLASH_Program_Byte+0x40>)
 8002c6a:	4a09      	ldr	r2, [pc, #36]	; (8002c90 <FLASH_Program_Byte+0x40>)
 8002c6c:	691b      	ldr	r3, [r3, #16]
 8002c6e:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8002c70:	4b07      	ldr	r3, [pc, #28]	; (8002c90 <FLASH_Program_Byte+0x40>)
 8002c72:	691b      	ldr	r3, [r3, #16]
 8002c74:	4a06      	ldr	r2, [pc, #24]	; (8002c90 <FLASH_Program_Byte+0x40>)
 8002c76:	f043 0301 	orr.w	r3, r3, #1
 8002c7a:	6113      	str	r3, [r2, #16]

  *(__IO uint8_t*)Address = Data;
 8002c7c:	687b      	ldr	r3, [r7, #4]
 8002c7e:	78fa      	ldrb	r2, [r7, #3]
 8002c80:	701a      	strb	r2, [r3, #0]
}
 8002c82:	bf00      	nop
 8002c84:	370c      	adds	r7, #12
 8002c86:	46bd      	mov	sp, r7
 8002c88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c8c:	4770      	bx	lr
 8002c8e:	bf00      	nop
 8002c90:	40023c00 	.word	0x40023c00

08002c94 <FLASH_SetErrorCode>:
/**
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{ 
 8002c94:	b480      	push	{r7}
 8002c96:	af00      	add	r7, sp, #0
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 8002c98:	4b2f      	ldr	r3, [pc, #188]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002c9a:	68db      	ldr	r3, [r3, #12]
 8002c9c:	f003 0310 	and.w	r3, r3, #16
 8002ca0:	2b00      	cmp	r3, #0
 8002ca2:	d008      	beq.n	8002cb6 <FLASH_SetErrorCode+0x22>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8002ca4:	4b2d      	ldr	r3, [pc, #180]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002ca6:	69db      	ldr	r3, [r3, #28]
 8002ca8:	f043 0310 	orr.w	r3, r3, #16
 8002cac:	4a2b      	ldr	r2, [pc, #172]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002cae:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH write protection error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
 8002cb0:	4b29      	ldr	r3, [pc, #164]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002cb2:	2210      	movs	r2, #16
 8002cb4:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 8002cb6:	4b28      	ldr	r3, [pc, #160]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002cb8:	68db      	ldr	r3, [r3, #12]
 8002cba:	f003 0320 	and.w	r3, r3, #32
 8002cbe:	2b00      	cmp	r3, #0
 8002cc0:	d008      	beq.n	8002cd4 <FLASH_SetErrorCode+0x40>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 8002cc2:	4b26      	ldr	r3, [pc, #152]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002cc4:	69db      	ldr	r3, [r3, #28]
 8002cc6:	f043 0308 	orr.w	r3, r3, #8
 8002cca:	4a24      	ldr	r2, [pc, #144]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002ccc:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH Programming alignment error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
 8002cce:	4b22      	ldr	r3, [pc, #136]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002cd0:	2220      	movs	r2, #32
 8002cd2:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 8002cd4:	4b20      	ldr	r3, [pc, #128]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002cd6:	68db      	ldr	r3, [r3, #12]
 8002cd8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002cdc:	2b00      	cmp	r3, #0
 8002cde:	d008      	beq.n	8002cf2 <FLASH_SetErrorCode+0x5e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 8002ce0:	4b1e      	ldr	r3, [pc, #120]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002ce2:	69db      	ldr	r3, [r3, #28]
 8002ce4:	f043 0304 	orr.w	r3, r3, #4
 8002ce8:	4a1c      	ldr	r2, [pc, #112]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002cea:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming parallelism error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
 8002cec:	4b1a      	ldr	r3, [pc, #104]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002cee:	2240      	movs	r2, #64	; 0x40
 8002cf0:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)
 8002cf2:	4b19      	ldr	r3, [pc, #100]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002cf4:	68db      	ldr	r3, [r3, #12]
 8002cf6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002cfa:	2b00      	cmp	r3, #0
 8002cfc:	d008      	beq.n	8002d10 <FLASH_SetErrorCode+0x7c>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
 8002cfe:	4b17      	ldr	r3, [pc, #92]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002d00:	69db      	ldr	r3, [r3, #28]
 8002d02:	f043 0302 	orr.w	r3, r3, #2
 8002d06:	4a15      	ldr	r2, [pc, #84]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002d08:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming sequence error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
 8002d0a:	4b13      	ldr	r3, [pc, #76]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002d0c:	2280      	movs	r2, #128	; 0x80
 8002d0e:	60da      	str	r2, [r3, #12]
  }
#if defined(FLASH_SR_RDERR) 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
 8002d10:	4b11      	ldr	r3, [pc, #68]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002d12:	68db      	ldr	r3, [r3, #12]
 8002d14:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002d18:	2b00      	cmp	r3, #0
 8002d1a:	d009      	beq.n	8002d30 <FLASH_SetErrorCode+0x9c>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
 8002d1c:	4b0f      	ldr	r3, [pc, #60]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002d1e:	69db      	ldr	r3, [r3, #28]
 8002d20:	f043 0301 	orr.w	r3, r3, #1
 8002d24:	4a0d      	ldr	r2, [pc, #52]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002d26:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Proprietary readout protection error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
 8002d28:	4b0b      	ldr	r3, [pc, #44]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002d2a:	f44f 7280 	mov.w	r2, #256	; 0x100
 8002d2e:	60da      	str	r2, [r3, #12]
  }
#endif /* FLASH_SR_RDERR */  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8002d30:	4b09      	ldr	r3, [pc, #36]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002d32:	68db      	ldr	r3, [r3, #12]
 8002d34:	f003 0302 	and.w	r3, r3, #2
 8002d38:	2b00      	cmp	r3, #0
 8002d3a:	d008      	beq.n	8002d4e <FLASH_SetErrorCode+0xba>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 8002d3c:	4b07      	ldr	r3, [pc, #28]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002d3e:	69db      	ldr	r3, [r3, #28]
 8002d40:	f043 0320 	orr.w	r3, r3, #32
 8002d44:	4a05      	ldr	r2, [pc, #20]	; (8002d5c <FLASH_SetErrorCode+0xc8>)
 8002d46:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Operation error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
 8002d48:	4b03      	ldr	r3, [pc, #12]	; (8002d58 <FLASH_SetErrorCode+0xc4>)
 8002d4a:	2202      	movs	r2, #2
 8002d4c:	60da      	str	r2, [r3, #12]
  }
}
 8002d4e:	bf00      	nop
 8002d50:	46bd      	mov	sp, r7
 8002d52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d56:	4770      	bx	lr
 8002d58:	40023c00 	.word	0x40023c00
 8002d5c:	2000a694 	.word	0x2000a694

08002d60 <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFFU means that all the sectors have been correctly erased)
  * 
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
 8002d60:	b580      	push	{r7, lr}
 8002d62:	b084      	sub	sp, #16
 8002d64:	af00      	add	r7, sp, #0
 8002d66:	6078      	str	r0, [r7, #4]
 8002d68:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_ERROR;
 8002d6a:	2301      	movs	r3, #1
 8002d6c:	73fb      	strb	r3, [r7, #15]
  uint32_t index = 0U;
 8002d6e:	2300      	movs	r3, #0
 8002d70:	60bb      	str	r3, [r7, #8]
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8002d72:	4b31      	ldr	r3, [pc, #196]	; (8002e38 <HAL_FLASHEx_Erase+0xd8>)
 8002d74:	7e1b      	ldrb	r3, [r3, #24]
 8002d76:	2b01      	cmp	r3, #1
 8002d78:	d101      	bne.n	8002d7e <HAL_FLASHEx_Erase+0x1e>
 8002d7a:	2302      	movs	r3, #2
 8002d7c:	e058      	b.n	8002e30 <HAL_FLASHEx_Erase+0xd0>
 8002d7e:	4b2e      	ldr	r3, [pc, #184]	; (8002e38 <HAL_FLASHEx_Erase+0xd8>)
 8002d80:	2201      	movs	r2, #1
 8002d82:	761a      	strb	r2, [r3, #24]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8002d84:	f24c 3050 	movw	r0, #50000	; 0xc350
 8002d88:	f7ff feac 	bl	8002ae4 <FLASH_WaitForLastOperation>
 8002d8c:	4603      	mov	r3, r0
 8002d8e:	73fb      	strb	r3, [r7, #15]

  if(status == HAL_OK)
 8002d90:	7bfb      	ldrb	r3, [r7, #15]
 8002d92:	2b00      	cmp	r3, #0
 8002d94:	d148      	bne.n	8002e28 <HAL_FLASHEx_Erase+0xc8>
  {
    /*Initialization of SectorError variable*/
    *SectorError = 0xFFFFFFFFU;
 8002d96:	683b      	ldr	r3, [r7, #0]
 8002d98:	f04f 32ff 	mov.w	r2, #4294967295
 8002d9c:	601a      	str	r2, [r3, #0]
    
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8002d9e:	687b      	ldr	r3, [r7, #4]
 8002da0:	681b      	ldr	r3, [r3, #0]
 8002da2:	2b01      	cmp	r3, #1
 8002da4:	d115      	bne.n	8002dd2 <HAL_FLASHEx_Erase+0x72>
    {
      /*Mass erase to be done*/
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
 8002da6:	687b      	ldr	r3, [r7, #4]
 8002da8:	691b      	ldr	r3, [r3, #16]
 8002daa:	b2da      	uxtb	r2, r3
 8002dac:	687b      	ldr	r3, [r7, #4]
 8002dae:	685b      	ldr	r3, [r3, #4]
 8002db0:	4619      	mov	r1, r3
 8002db2:	4610      	mov	r0, r2
 8002db4:	f000 f844 	bl	8002e40 <FLASH_MassErase>

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8002db8:	f24c 3050 	movw	r0, #50000	; 0xc350
 8002dbc:	f7ff fe92 	bl	8002ae4 <FLASH_WaitForLastOperation>
 8002dc0:	4603      	mov	r3, r0
 8002dc2:	73fb      	strb	r3, [r7, #15]
      
      /* if the erase operation is completed, disable the MER Bit */
      FLASH->CR &= (~FLASH_MER_BIT);
 8002dc4:	4b1d      	ldr	r3, [pc, #116]	; (8002e3c <HAL_FLASHEx_Erase+0xdc>)
 8002dc6:	691b      	ldr	r3, [r3, #16]
 8002dc8:	4a1c      	ldr	r2, [pc, #112]	; (8002e3c <HAL_FLASHEx_Erase+0xdc>)
 8002dca:	f023 0304 	bic.w	r3, r3, #4
 8002dce:	6113      	str	r3, [r2, #16]
 8002dd0:	e028      	b.n	8002e24 <HAL_FLASHEx_Erase+0xc4>
    {
      /* Check the parameters */
      assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));

      /* Erase by sector by sector to be done*/
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8002dd2:	687b      	ldr	r3, [r7, #4]
 8002dd4:	689b      	ldr	r3, [r3, #8]
 8002dd6:	60bb      	str	r3, [r7, #8]
 8002dd8:	e01c      	b.n	8002e14 <HAL_FLASHEx_Erase+0xb4>
      {
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
 8002dda:	687b      	ldr	r3, [r7, #4]
 8002ddc:	691b      	ldr	r3, [r3, #16]
 8002dde:	b2db      	uxtb	r3, r3
 8002de0:	4619      	mov	r1, r3
 8002de2:	68b8      	ldr	r0, [r7, #8]
 8002de4:	f000 f850 	bl	8002e88 <FLASH_Erase_Sector>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8002de8:	f24c 3050 	movw	r0, #50000	; 0xc350
 8002dec:	f7ff fe7a 	bl	8002ae4 <FLASH_WaitForLastOperation>
 8002df0:	4603      	mov	r3, r0
 8002df2:	73fb      	strb	r3, [r7, #15]
        
        /* If the erase operation is completed, disable the SER and SNB Bits */
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
 8002df4:	4b11      	ldr	r3, [pc, #68]	; (8002e3c <HAL_FLASHEx_Erase+0xdc>)
 8002df6:	691b      	ldr	r3, [r3, #16]
 8002df8:	4a10      	ldr	r2, [pc, #64]	; (8002e3c <HAL_FLASHEx_Erase+0xdc>)
 8002dfa:	f023 03fa 	bic.w	r3, r3, #250	; 0xfa
 8002dfe:	6113      	str	r3, [r2, #16]

        if(status != HAL_OK) 
 8002e00:	7bfb      	ldrb	r3, [r7, #15]
 8002e02:	2b00      	cmp	r3, #0
 8002e04:	d003      	beq.n	8002e0e <HAL_FLASHEx_Erase+0xae>
        {
          /* In case of error, stop erase procedure and return the faulty sector*/
          *SectorError = index;
 8002e06:	683b      	ldr	r3, [r7, #0]
 8002e08:	68ba      	ldr	r2, [r7, #8]
 8002e0a:	601a      	str	r2, [r3, #0]
          break;
 8002e0c:	e00a      	b.n	8002e24 <HAL_FLASHEx_Erase+0xc4>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8002e0e:	68bb      	ldr	r3, [r7, #8]
 8002e10:	3301      	adds	r3, #1
 8002e12:	60bb      	str	r3, [r7, #8]
 8002e14:	687b      	ldr	r3, [r7, #4]
 8002e16:	68da      	ldr	r2, [r3, #12]
 8002e18:	687b      	ldr	r3, [r7, #4]
 8002e1a:	689b      	ldr	r3, [r3, #8]
 8002e1c:	4413      	add	r3, r2
 8002e1e:	68ba      	ldr	r2, [r7, #8]
 8002e20:	429a      	cmp	r2, r3
 8002e22:	d3da      	bcc.n	8002dda <HAL_FLASHEx_Erase+0x7a>
        }
      }
    }
    /* Flush the caches to be sure of the data consistency */
    FLASH_FlushCaches();    
 8002e24:	f000 f878 	bl	8002f18 <FLASH_FlushCaches>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 8002e28:	4b03      	ldr	r3, [pc, #12]	; (8002e38 <HAL_FLASHEx_Erase+0xd8>)
 8002e2a:	2200      	movs	r2, #0
 8002e2c:	761a      	strb	r2, [r3, #24]

  return status;
 8002e2e:	7bfb      	ldrb	r3, [r7, #15]
}
 8002e30:	4618      	mov	r0, r3
 8002e32:	3710      	adds	r7, #16
 8002e34:	46bd      	mov	sp, r7
 8002e36:	bd80      	pop	{r7, pc}
 8002e38:	2000a694 	.word	0x2000a694
 8002e3c:	40023c00 	.word	0x40023c00

08002e40 <FLASH_MassErase>:
  *            @arg FLASH_BANK_1: Bank1 to be erased
  *
  * @retval None
  */
static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)
{
 8002e40:	b480      	push	{r7}
 8002e42:	b083      	sub	sp, #12
 8002e44:	af00      	add	r7, sp, #0
 8002e46:	4603      	mov	r3, r0
 8002e48:	6039      	str	r1, [r7, #0]
 8002e4a:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  assert_param(IS_FLASH_BANK(Banks));
  
  /* If the previous operation is completed, proceed to erase all sectors */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8002e4c:	4b0d      	ldr	r3, [pc, #52]	; (8002e84 <FLASH_MassErase+0x44>)
 8002e4e:	691b      	ldr	r3, [r3, #16]
 8002e50:	4a0c      	ldr	r2, [pc, #48]	; (8002e84 <FLASH_MassErase+0x44>)
 8002e52:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002e56:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_MER;
 8002e58:	4b0a      	ldr	r3, [pc, #40]	; (8002e84 <FLASH_MassErase+0x44>)
 8002e5a:	691b      	ldr	r3, [r3, #16]
 8002e5c:	4a09      	ldr	r2, [pc, #36]	; (8002e84 <FLASH_MassErase+0x44>)
 8002e5e:	f043 0304 	orr.w	r3, r3, #4
 8002e62:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8U);
 8002e64:	4b07      	ldr	r3, [pc, #28]	; (8002e84 <FLASH_MassErase+0x44>)
 8002e66:	691a      	ldr	r2, [r3, #16]
 8002e68:	79fb      	ldrb	r3, [r7, #7]
 8002e6a:	021b      	lsls	r3, r3, #8
 8002e6c:	4313      	orrs	r3, r2
 8002e6e:	4a05      	ldr	r2, [pc, #20]	; (8002e84 <FLASH_MassErase+0x44>)
 8002e70:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002e74:	6113      	str	r3, [r2, #16]
}
 8002e76:	bf00      	nop
 8002e78:	370c      	adds	r7, #12
 8002e7a:	46bd      	mov	sp, r7
 8002e7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002e80:	4770      	bx	lr
 8002e82:	bf00      	nop
 8002e84:	40023c00 	.word	0x40023c00

08002e88 <FLASH_Erase_Sector>:
  *                                  the operation will be done by double word (64-bit)
  * 
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
{
 8002e88:	b480      	push	{r7}
 8002e8a:	b085      	sub	sp, #20
 8002e8c:	af00      	add	r7, sp, #0
 8002e8e:	6078      	str	r0, [r7, #4]
 8002e90:	460b      	mov	r3, r1
 8002e92:	70fb      	strb	r3, [r7, #3]
  uint32_t tmp_psize = 0U;
 8002e94:	2300      	movs	r3, #0
 8002e96:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
 8002e98:	78fb      	ldrb	r3, [r7, #3]
 8002e9a:	2b00      	cmp	r3, #0
 8002e9c:	d102      	bne.n	8002ea4 <FLASH_Erase_Sector+0x1c>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 8002e9e:	2300      	movs	r3, #0
 8002ea0:	60fb      	str	r3, [r7, #12]
 8002ea2:	e010      	b.n	8002ec6 <FLASH_Erase_Sector+0x3e>
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
 8002ea4:	78fb      	ldrb	r3, [r7, #3]
 8002ea6:	2b01      	cmp	r3, #1
 8002ea8:	d103      	bne.n	8002eb2 <FLASH_Erase_Sector+0x2a>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8002eaa:	f44f 7380 	mov.w	r3, #256	; 0x100
 8002eae:	60fb      	str	r3, [r7, #12]
 8002eb0:	e009      	b.n	8002ec6 <FLASH_Erase_Sector+0x3e>
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
 8002eb2:	78fb      	ldrb	r3, [r7, #3]
 8002eb4:	2b02      	cmp	r3, #2
 8002eb6:	d103      	bne.n	8002ec0 <FLASH_Erase_Sector+0x38>
  {
    tmp_psize = FLASH_PSIZE_WORD;
 8002eb8:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002ebc:	60fb      	str	r3, [r7, #12]
 8002ebe:	e002      	b.n	8002ec6 <FLASH_Erase_Sector+0x3e>
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 8002ec0:	f44f 7340 	mov.w	r3, #768	; 0x300
 8002ec4:	60fb      	str	r3, [r7, #12]
  }

  /* If the previous operation is completed, proceed to erase the sector */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8002ec6:	4b13      	ldr	r3, [pc, #76]	; (8002f14 <FLASH_Erase_Sector+0x8c>)
 8002ec8:	691b      	ldr	r3, [r3, #16]
 8002eca:	4a12      	ldr	r2, [pc, #72]	; (8002f14 <FLASH_Erase_Sector+0x8c>)
 8002ecc:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002ed0:	6113      	str	r3, [r2, #16]
  FLASH->CR |= tmp_psize;
 8002ed2:	4b10      	ldr	r3, [pc, #64]	; (8002f14 <FLASH_Erase_Sector+0x8c>)
 8002ed4:	691a      	ldr	r2, [r3, #16]
 8002ed6:	490f      	ldr	r1, [pc, #60]	; (8002f14 <FLASH_Erase_Sector+0x8c>)
 8002ed8:	68fb      	ldr	r3, [r7, #12]
 8002eda:	4313      	orrs	r3, r2
 8002edc:	610b      	str	r3, [r1, #16]
  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
 8002ede:	4b0d      	ldr	r3, [pc, #52]	; (8002f14 <FLASH_Erase_Sector+0x8c>)
 8002ee0:	691b      	ldr	r3, [r3, #16]
 8002ee2:	4a0c      	ldr	r2, [pc, #48]	; (8002f14 <FLASH_Erase_Sector+0x8c>)
 8002ee4:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8002ee8:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
 8002eea:	4b0a      	ldr	r3, [pc, #40]	; (8002f14 <FLASH_Erase_Sector+0x8c>)
 8002eec:	691a      	ldr	r2, [r3, #16]
 8002eee:	687b      	ldr	r3, [r7, #4]
 8002ef0:	00db      	lsls	r3, r3, #3
 8002ef2:	4313      	orrs	r3, r2
 8002ef4:	4a07      	ldr	r2, [pc, #28]	; (8002f14 <FLASH_Erase_Sector+0x8c>)
 8002ef6:	f043 0302 	orr.w	r3, r3, #2
 8002efa:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_STRT;
 8002efc:	4b05      	ldr	r3, [pc, #20]	; (8002f14 <FLASH_Erase_Sector+0x8c>)
 8002efe:	691b      	ldr	r3, [r3, #16]
 8002f00:	4a04      	ldr	r2, [pc, #16]	; (8002f14 <FLASH_Erase_Sector+0x8c>)
 8002f02:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002f06:	6113      	str	r3, [r2, #16]
}
 8002f08:	bf00      	nop
 8002f0a:	3714      	adds	r7, #20
 8002f0c:	46bd      	mov	sp, r7
 8002f0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f12:	4770      	bx	lr
 8002f14:	40023c00 	.word	0x40023c00

08002f18 <FLASH_FlushCaches>:
/**
  * @brief  Flush the instruction and data caches
  * @retval None
  */
void FLASH_FlushCaches(void)
{
 8002f18:	b480      	push	{r7}
 8002f1a:	af00      	add	r7, sp, #0
  /* Flush instruction cache  */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN)!= RESET)
 8002f1c:	4b20      	ldr	r3, [pc, #128]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f1e:	681b      	ldr	r3, [r3, #0]
 8002f20:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8002f24:	2b00      	cmp	r3, #0
 8002f26:	d017      	beq.n	8002f58 <FLASH_FlushCaches+0x40>
  {
    /* Disable instruction cache  */
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8002f28:	4b1d      	ldr	r3, [pc, #116]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f2a:	681b      	ldr	r3, [r3, #0]
 8002f2c:	4a1c      	ldr	r2, [pc, #112]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f2e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8002f32:	6013      	str	r3, [r2, #0]
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 8002f34:	4b1a      	ldr	r3, [pc, #104]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f36:	681b      	ldr	r3, [r3, #0]
 8002f38:	4a19      	ldr	r2, [pc, #100]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f3a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8002f3e:	6013      	str	r3, [r2, #0]
 8002f40:	4b17      	ldr	r3, [pc, #92]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f42:	681b      	ldr	r3, [r3, #0]
 8002f44:	4a16      	ldr	r2, [pc, #88]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f46:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8002f4a:	6013      	str	r3, [r2, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8002f4c:	4b14      	ldr	r3, [pc, #80]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f4e:	681b      	ldr	r3, [r3, #0]
 8002f50:	4a13      	ldr	r2, [pc, #76]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f52:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002f56:	6013      	str	r3, [r2, #0]
  }
  
  /* Flush data cache */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 8002f58:	4b11      	ldr	r3, [pc, #68]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f5a:	681b      	ldr	r3, [r3, #0]
 8002f5c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002f60:	2b00      	cmp	r3, #0
 8002f62:	d017      	beq.n	8002f94 <FLASH_FlushCaches+0x7c>
  {
    /* Disable data cache  */
    __HAL_FLASH_DATA_CACHE_DISABLE();
 8002f64:	4b0e      	ldr	r3, [pc, #56]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f66:	681b      	ldr	r3, [r3, #0]
 8002f68:	4a0d      	ldr	r2, [pc, #52]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f6a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8002f6e:	6013      	str	r3, [r2, #0]
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
 8002f70:	4b0b      	ldr	r3, [pc, #44]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f72:	681b      	ldr	r3, [r3, #0]
 8002f74:	4a0a      	ldr	r2, [pc, #40]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f76:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8002f7a:	6013      	str	r3, [r2, #0]
 8002f7c:	4b08      	ldr	r3, [pc, #32]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f7e:	681b      	ldr	r3, [r3, #0]
 8002f80:	4a07      	ldr	r2, [pc, #28]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f82:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8002f86:	6013      	str	r3, [r2, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
 8002f88:	4b05      	ldr	r3, [pc, #20]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f8a:	681b      	ldr	r3, [r3, #0]
 8002f8c:	4a04      	ldr	r2, [pc, #16]	; (8002fa0 <FLASH_FlushCaches+0x88>)
 8002f8e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8002f92:	6013      	str	r3, [r2, #0]
  }
}
 8002f94:	bf00      	nop
 8002f96:	46bd      	mov	sp, r7
 8002f98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f9c:	4770      	bx	lr
 8002f9e:	bf00      	nop
 8002fa0:	40023c00 	.word	0x40023c00

08002fa4 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8002fa4:	b480      	push	{r7}
 8002fa6:	b089      	sub	sp, #36	; 0x24
 8002fa8:	af00      	add	r7, sp, #0
 8002faa:	6078      	str	r0, [r7, #4]
 8002fac:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 8002fae:	2300      	movs	r3, #0
 8002fb0:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 8002fb2:	2300      	movs	r3, #0
 8002fb4:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 8002fb6:	2300      	movs	r3, #0
 8002fb8:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002fba:	2300      	movs	r3, #0
 8002fbc:	61fb      	str	r3, [r7, #28]
 8002fbe:	e159      	b.n	8003274 <HAL_GPIO_Init+0x2d0>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 8002fc0:	2201      	movs	r2, #1
 8002fc2:	69fb      	ldr	r3, [r7, #28]
 8002fc4:	fa02 f303 	lsl.w	r3, r2, r3
 8002fc8:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8002fca:	683b      	ldr	r3, [r7, #0]
 8002fcc:	681b      	ldr	r3, [r3, #0]
 8002fce:	697a      	ldr	r2, [r7, #20]
 8002fd0:	4013      	ands	r3, r2
 8002fd2:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8002fd4:	693a      	ldr	r2, [r7, #16]
 8002fd6:	697b      	ldr	r3, [r7, #20]
 8002fd8:	429a      	cmp	r2, r3
 8002fda:	f040 8148 	bne.w	800326e <HAL_GPIO_Init+0x2ca>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8002fde:	683b      	ldr	r3, [r7, #0]
 8002fe0:	685b      	ldr	r3, [r3, #4]
 8002fe2:	2b01      	cmp	r3, #1
 8002fe4:	d00b      	beq.n	8002ffe <HAL_GPIO_Init+0x5a>
 8002fe6:	683b      	ldr	r3, [r7, #0]
 8002fe8:	685b      	ldr	r3, [r3, #4]
 8002fea:	2b02      	cmp	r3, #2
 8002fec:	d007      	beq.n	8002ffe <HAL_GPIO_Init+0x5a>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8002fee:	683b      	ldr	r3, [r7, #0]
 8002ff0:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8002ff2:	2b11      	cmp	r3, #17
 8002ff4:	d003      	beq.n	8002ffe <HAL_GPIO_Init+0x5a>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8002ff6:	683b      	ldr	r3, [r7, #0]
 8002ff8:	685b      	ldr	r3, [r3, #4]
 8002ffa:	2b12      	cmp	r3, #18
 8002ffc:	d130      	bne.n	8003060 <HAL_GPIO_Init+0xbc>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8002ffe:	687b      	ldr	r3, [r7, #4]
 8003000:	689b      	ldr	r3, [r3, #8]
 8003002:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8003004:	69fb      	ldr	r3, [r7, #28]
 8003006:	005b      	lsls	r3, r3, #1
 8003008:	2203      	movs	r2, #3
 800300a:	fa02 f303 	lsl.w	r3, r2, r3
 800300e:	43db      	mvns	r3, r3
 8003010:	69ba      	ldr	r2, [r7, #24]
 8003012:	4013      	ands	r3, r2
 8003014:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8003016:	683b      	ldr	r3, [r7, #0]
 8003018:	68da      	ldr	r2, [r3, #12]
 800301a:	69fb      	ldr	r3, [r7, #28]
 800301c:	005b      	lsls	r3, r3, #1
 800301e:	fa02 f303 	lsl.w	r3, r2, r3
 8003022:	69ba      	ldr	r2, [r7, #24]
 8003024:	4313      	orrs	r3, r2
 8003026:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8003028:	687b      	ldr	r3, [r7, #4]
 800302a:	69ba      	ldr	r2, [r7, #24]
 800302c:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800302e:	687b      	ldr	r3, [r7, #4]
 8003030:	685b      	ldr	r3, [r3, #4]
 8003032:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8003034:	2201      	movs	r2, #1
 8003036:	69fb      	ldr	r3, [r7, #28]
 8003038:	fa02 f303 	lsl.w	r3, r2, r3
 800303c:	43db      	mvns	r3, r3
 800303e:	69ba      	ldr	r2, [r7, #24]
 8003040:	4013      	ands	r3, r2
 8003042:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8003044:	683b      	ldr	r3, [r7, #0]
 8003046:	685b      	ldr	r3, [r3, #4]
 8003048:	091b      	lsrs	r3, r3, #4
 800304a:	f003 0201 	and.w	r2, r3, #1
 800304e:	69fb      	ldr	r3, [r7, #28]
 8003050:	fa02 f303 	lsl.w	r3, r2, r3
 8003054:	69ba      	ldr	r2, [r7, #24]
 8003056:	4313      	orrs	r3, r2
 8003058:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 800305a:	687b      	ldr	r3, [r7, #4]
 800305c:	69ba      	ldr	r2, [r7, #24]
 800305e:	605a      	str	r2, [r3, #4]
       }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8003060:	687b      	ldr	r3, [r7, #4]
 8003062:	68db      	ldr	r3, [r3, #12]
 8003064:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8003066:	69fb      	ldr	r3, [r7, #28]
 8003068:	005b      	lsls	r3, r3, #1
 800306a:	2203      	movs	r2, #3
 800306c:	fa02 f303 	lsl.w	r3, r2, r3
 8003070:	43db      	mvns	r3, r3
 8003072:	69ba      	ldr	r2, [r7, #24]
 8003074:	4013      	ands	r3, r2
 8003076:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8003078:	683b      	ldr	r3, [r7, #0]
 800307a:	689a      	ldr	r2, [r3, #8]
 800307c:	69fb      	ldr	r3, [r7, #28]
 800307e:	005b      	lsls	r3, r3, #1
 8003080:	fa02 f303 	lsl.w	r3, r2, r3
 8003084:	69ba      	ldr	r2, [r7, #24]
 8003086:	4313      	orrs	r3, r2
 8003088:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 800308a:	687b      	ldr	r3, [r7, #4]
 800308c:	69ba      	ldr	r2, [r7, #24]
 800308e:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8003090:	683b      	ldr	r3, [r7, #0]
 8003092:	685b      	ldr	r3, [r3, #4]
 8003094:	2b02      	cmp	r3, #2
 8003096:	d003      	beq.n	80030a0 <HAL_GPIO_Init+0xfc>
 8003098:	683b      	ldr	r3, [r7, #0]
 800309a:	685b      	ldr	r3, [r3, #4]
 800309c:	2b12      	cmp	r3, #18
 800309e:	d123      	bne.n	80030e8 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 80030a0:	69fb      	ldr	r3, [r7, #28]
 80030a2:	08da      	lsrs	r2, r3, #3
 80030a4:	687b      	ldr	r3, [r7, #4]
 80030a6:	3208      	adds	r2, #8
 80030a8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80030ac:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 80030ae:	69fb      	ldr	r3, [r7, #28]
 80030b0:	f003 0307 	and.w	r3, r3, #7
 80030b4:	009b      	lsls	r3, r3, #2
 80030b6:	220f      	movs	r2, #15
 80030b8:	fa02 f303 	lsl.w	r3, r2, r3
 80030bc:	43db      	mvns	r3, r3
 80030be:	69ba      	ldr	r2, [r7, #24]
 80030c0:	4013      	ands	r3, r2
 80030c2:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 80030c4:	683b      	ldr	r3, [r7, #0]
 80030c6:	691a      	ldr	r2, [r3, #16]
 80030c8:	69fb      	ldr	r3, [r7, #28]
 80030ca:	f003 0307 	and.w	r3, r3, #7
 80030ce:	009b      	lsls	r3, r3, #2
 80030d0:	fa02 f303 	lsl.w	r3, r2, r3
 80030d4:	69ba      	ldr	r2, [r7, #24]
 80030d6:	4313      	orrs	r3, r2
 80030d8:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 80030da:	69fb      	ldr	r3, [r7, #28]
 80030dc:	08da      	lsrs	r2, r3, #3
 80030de:	687b      	ldr	r3, [r7, #4]
 80030e0:	3208      	adds	r2, #8
 80030e2:	69b9      	ldr	r1, [r7, #24]
 80030e4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80030e8:	687b      	ldr	r3, [r7, #4]
 80030ea:	681b      	ldr	r3, [r3, #0]
 80030ec:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80030ee:	69fb      	ldr	r3, [r7, #28]
 80030f0:	005b      	lsls	r3, r3, #1
 80030f2:	2203      	movs	r2, #3
 80030f4:	fa02 f303 	lsl.w	r3, r2, r3
 80030f8:	43db      	mvns	r3, r3
 80030fa:	69ba      	ldr	r2, [r7, #24]
 80030fc:	4013      	ands	r3, r2
 80030fe:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8003100:	683b      	ldr	r3, [r7, #0]
 8003102:	685b      	ldr	r3, [r3, #4]
 8003104:	f003 0203 	and.w	r2, r3, #3
 8003108:	69fb      	ldr	r3, [r7, #28]
 800310a:	005b      	lsls	r3, r3, #1
 800310c:	fa02 f303 	lsl.w	r3, r2, r3
 8003110:	69ba      	ldr	r2, [r7, #24]
 8003112:	4313      	orrs	r3, r2
 8003114:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8003116:	687b      	ldr	r3, [r7, #4]
 8003118:	69ba      	ldr	r2, [r7, #24]
 800311a:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800311c:	683b      	ldr	r3, [r7, #0]
 800311e:	685b      	ldr	r3, [r3, #4]
 8003120:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003124:	2b00      	cmp	r3, #0
 8003126:	f000 80a2 	beq.w	800326e <HAL_GPIO_Init+0x2ca>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800312a:	2300      	movs	r3, #0
 800312c:	60fb      	str	r3, [r7, #12]
 800312e:	4b56      	ldr	r3, [pc, #344]	; (8003288 <HAL_GPIO_Init+0x2e4>)
 8003130:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003132:	4a55      	ldr	r2, [pc, #340]	; (8003288 <HAL_GPIO_Init+0x2e4>)
 8003134:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003138:	6453      	str	r3, [r2, #68]	; 0x44
 800313a:	4b53      	ldr	r3, [pc, #332]	; (8003288 <HAL_GPIO_Init+0x2e4>)
 800313c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800313e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8003142:	60fb      	str	r3, [r7, #12]
 8003144:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8003146:	4a51      	ldr	r2, [pc, #324]	; (800328c <HAL_GPIO_Init+0x2e8>)
 8003148:	69fb      	ldr	r3, [r7, #28]
 800314a:	089b      	lsrs	r3, r3, #2
 800314c:	3302      	adds	r3, #2
 800314e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003152:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8003154:	69fb      	ldr	r3, [r7, #28]
 8003156:	f003 0303 	and.w	r3, r3, #3
 800315a:	009b      	lsls	r3, r3, #2
 800315c:	220f      	movs	r2, #15
 800315e:	fa02 f303 	lsl.w	r3, r2, r3
 8003162:	43db      	mvns	r3, r3
 8003164:	69ba      	ldr	r2, [r7, #24]
 8003166:	4013      	ands	r3, r2
 8003168:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800316a:	687b      	ldr	r3, [r7, #4]
 800316c:	4a48      	ldr	r2, [pc, #288]	; (8003290 <HAL_GPIO_Init+0x2ec>)
 800316e:	4293      	cmp	r3, r2
 8003170:	d019      	beq.n	80031a6 <HAL_GPIO_Init+0x202>
 8003172:	687b      	ldr	r3, [r7, #4]
 8003174:	4a47      	ldr	r2, [pc, #284]	; (8003294 <HAL_GPIO_Init+0x2f0>)
 8003176:	4293      	cmp	r3, r2
 8003178:	d013      	beq.n	80031a2 <HAL_GPIO_Init+0x1fe>
 800317a:	687b      	ldr	r3, [r7, #4]
 800317c:	4a46      	ldr	r2, [pc, #280]	; (8003298 <HAL_GPIO_Init+0x2f4>)
 800317e:	4293      	cmp	r3, r2
 8003180:	d00d      	beq.n	800319e <HAL_GPIO_Init+0x1fa>
 8003182:	687b      	ldr	r3, [r7, #4]
 8003184:	4a45      	ldr	r2, [pc, #276]	; (800329c <HAL_GPIO_Init+0x2f8>)
 8003186:	4293      	cmp	r3, r2
 8003188:	d007      	beq.n	800319a <HAL_GPIO_Init+0x1f6>
 800318a:	687b      	ldr	r3, [r7, #4]
 800318c:	4a44      	ldr	r2, [pc, #272]	; (80032a0 <HAL_GPIO_Init+0x2fc>)
 800318e:	4293      	cmp	r3, r2
 8003190:	d101      	bne.n	8003196 <HAL_GPIO_Init+0x1f2>
 8003192:	2304      	movs	r3, #4
 8003194:	e008      	b.n	80031a8 <HAL_GPIO_Init+0x204>
 8003196:	2307      	movs	r3, #7
 8003198:	e006      	b.n	80031a8 <HAL_GPIO_Init+0x204>
 800319a:	2303      	movs	r3, #3
 800319c:	e004      	b.n	80031a8 <HAL_GPIO_Init+0x204>
 800319e:	2302      	movs	r3, #2
 80031a0:	e002      	b.n	80031a8 <HAL_GPIO_Init+0x204>
 80031a2:	2301      	movs	r3, #1
 80031a4:	e000      	b.n	80031a8 <HAL_GPIO_Init+0x204>
 80031a6:	2300      	movs	r3, #0
 80031a8:	69fa      	ldr	r2, [r7, #28]
 80031aa:	f002 0203 	and.w	r2, r2, #3
 80031ae:	0092      	lsls	r2, r2, #2
 80031b0:	4093      	lsls	r3, r2
 80031b2:	69ba      	ldr	r2, [r7, #24]
 80031b4:	4313      	orrs	r3, r2
 80031b6:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 80031b8:	4934      	ldr	r1, [pc, #208]	; (800328c <HAL_GPIO_Init+0x2e8>)
 80031ba:	69fb      	ldr	r3, [r7, #28]
 80031bc:	089b      	lsrs	r3, r3, #2
 80031be:	3302      	adds	r3, #2
 80031c0:	69ba      	ldr	r2, [r7, #24]
 80031c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80031c6:	4b37      	ldr	r3, [pc, #220]	; (80032a4 <HAL_GPIO_Init+0x300>)
 80031c8:	681b      	ldr	r3, [r3, #0]
 80031ca:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 80031cc:	693b      	ldr	r3, [r7, #16]
 80031ce:	43db      	mvns	r3, r3
 80031d0:	69ba      	ldr	r2, [r7, #24]
 80031d2:	4013      	ands	r3, r2
 80031d4:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80031d6:	683b      	ldr	r3, [r7, #0]
 80031d8:	685b      	ldr	r3, [r3, #4]
 80031da:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80031de:	2b00      	cmp	r3, #0
 80031e0:	d003      	beq.n	80031ea <HAL_GPIO_Init+0x246>
        {
          temp |= iocurrent;
 80031e2:	69ba      	ldr	r2, [r7, #24]
 80031e4:	693b      	ldr	r3, [r7, #16]
 80031e6:	4313      	orrs	r3, r2
 80031e8:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 80031ea:	4a2e      	ldr	r2, [pc, #184]	; (80032a4 <HAL_GPIO_Init+0x300>)
 80031ec:	69bb      	ldr	r3, [r7, #24]
 80031ee:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
 80031f0:	4b2c      	ldr	r3, [pc, #176]	; (80032a4 <HAL_GPIO_Init+0x300>)
 80031f2:	685b      	ldr	r3, [r3, #4]
 80031f4:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 80031f6:	693b      	ldr	r3, [r7, #16]
 80031f8:	43db      	mvns	r3, r3
 80031fa:	69ba      	ldr	r2, [r7, #24]
 80031fc:	4013      	ands	r3, r2
 80031fe:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8003200:	683b      	ldr	r3, [r7, #0]
 8003202:	685b      	ldr	r3, [r3, #4]
 8003204:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003208:	2b00      	cmp	r3, #0
 800320a:	d003      	beq.n	8003214 <HAL_GPIO_Init+0x270>
        {
          temp |= iocurrent;
 800320c:	69ba      	ldr	r2, [r7, #24]
 800320e:	693b      	ldr	r3, [r7, #16]
 8003210:	4313      	orrs	r3, r2
 8003212:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 8003214:	4a23      	ldr	r2, [pc, #140]	; (80032a4 <HAL_GPIO_Init+0x300>)
 8003216:	69bb      	ldr	r3, [r7, #24]
 8003218:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800321a:	4b22      	ldr	r3, [pc, #136]	; (80032a4 <HAL_GPIO_Init+0x300>)
 800321c:	689b      	ldr	r3, [r3, #8]
 800321e:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8003220:	693b      	ldr	r3, [r7, #16]
 8003222:	43db      	mvns	r3, r3
 8003224:	69ba      	ldr	r2, [r7, #24]
 8003226:	4013      	ands	r3, r2
 8003228:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800322a:	683b      	ldr	r3, [r7, #0]
 800322c:	685b      	ldr	r3, [r3, #4]
 800322e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8003232:	2b00      	cmp	r3, #0
 8003234:	d003      	beq.n	800323e <HAL_GPIO_Init+0x29a>
        {
          temp |= iocurrent;
 8003236:	69ba      	ldr	r2, [r7, #24]
 8003238:	693b      	ldr	r3, [r7, #16]
 800323a:	4313      	orrs	r3, r2
 800323c:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 800323e:	4a19      	ldr	r2, [pc, #100]	; (80032a4 <HAL_GPIO_Init+0x300>)
 8003240:	69bb      	ldr	r3, [r7, #24]
 8003242:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 8003244:	4b17      	ldr	r3, [pc, #92]	; (80032a4 <HAL_GPIO_Init+0x300>)
 8003246:	68db      	ldr	r3, [r3, #12]
 8003248:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800324a:	693b      	ldr	r3, [r7, #16]
 800324c:	43db      	mvns	r3, r3
 800324e:	69ba      	ldr	r2, [r7, #24]
 8003250:	4013      	ands	r3, r2
 8003252:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8003254:	683b      	ldr	r3, [r7, #0]
 8003256:	685b      	ldr	r3, [r3, #4]
 8003258:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800325c:	2b00      	cmp	r3, #0
 800325e:	d003      	beq.n	8003268 <HAL_GPIO_Init+0x2c4>
        {
          temp |= iocurrent;
 8003260:	69ba      	ldr	r2, [r7, #24]
 8003262:	693b      	ldr	r3, [r7, #16]
 8003264:	4313      	orrs	r3, r2
 8003266:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 8003268:	4a0e      	ldr	r2, [pc, #56]	; (80032a4 <HAL_GPIO_Init+0x300>)
 800326a:	69bb      	ldr	r3, [r7, #24]
 800326c:	60d3      	str	r3, [r2, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800326e:	69fb      	ldr	r3, [r7, #28]
 8003270:	3301      	adds	r3, #1
 8003272:	61fb      	str	r3, [r7, #28]
 8003274:	69fb      	ldr	r3, [r7, #28]
 8003276:	2b0f      	cmp	r3, #15
 8003278:	f67f aea2 	bls.w	8002fc0 <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 800327c:	bf00      	nop
 800327e:	3724      	adds	r7, #36	; 0x24
 8003280:	46bd      	mov	sp, r7
 8003282:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003286:	4770      	bx	lr
 8003288:	40023800 	.word	0x40023800
 800328c:	40013800 	.word	0x40013800
 8003290:	40020000 	.word	0x40020000
 8003294:	40020400 	.word	0x40020400
 8003298:	40020800 	.word	0x40020800
 800329c:	40020c00 	.word	0x40020c00
 80032a0:	40021000 	.word	0x40021000
 80032a4:	40013c00 	.word	0x40013c00

080032a8 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 80032a8:	b480      	push	{r7}
 80032aa:	b083      	sub	sp, #12
 80032ac:	af00      	add	r7, sp, #0
 80032ae:	6078      	str	r0, [r7, #4]
 80032b0:	460b      	mov	r3, r1
 80032b2:	807b      	strh	r3, [r7, #2]
 80032b4:	4613      	mov	r3, r2
 80032b6:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80032b8:	787b      	ldrb	r3, [r7, #1]
 80032ba:	2b00      	cmp	r3, #0
 80032bc:	d003      	beq.n	80032c6 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 80032be:	887a      	ldrh	r2, [r7, #2]
 80032c0:	687b      	ldr	r3, [r7, #4]
 80032c2:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 80032c4:	e003      	b.n	80032ce <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 80032c6:	887b      	ldrh	r3, [r7, #2]
 80032c8:	041a      	lsls	r2, r3, #16
 80032ca:	687b      	ldr	r3, [r7, #4]
 80032cc:	619a      	str	r2, [r3, #24]
}
 80032ce:	bf00      	nop
 80032d0:	370c      	adds	r7, #12
 80032d2:	46bd      	mov	sp, r7
 80032d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80032d8:	4770      	bx	lr

080032da <HAL_GPIO_TogglePin>:
  *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
  * @param  GPIO_Pin Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80032da:	b480      	push	{r7}
 80032dc:	b083      	sub	sp, #12
 80032de:	af00      	add	r7, sp, #0
 80032e0:	6078      	str	r0, [r7, #4]
 80032e2:	460b      	mov	r3, r1
 80032e4:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
 80032e6:	687b      	ldr	r3, [r7, #4]
 80032e8:	695a      	ldr	r2, [r3, #20]
 80032ea:	887b      	ldrh	r3, [r7, #2]
 80032ec:	401a      	ands	r2, r3
 80032ee:	887b      	ldrh	r3, [r7, #2]
 80032f0:	429a      	cmp	r2, r3
 80032f2:	d104      	bne.n	80032fe <HAL_GPIO_TogglePin+0x24>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 80032f4:	887b      	ldrh	r3, [r7, #2]
 80032f6:	041a      	lsls	r2, r3, #16
 80032f8:	687b      	ldr	r3, [r7, #4]
 80032fa:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
  }
}
 80032fc:	e002      	b.n	8003304 <HAL_GPIO_TogglePin+0x2a>
    GPIOx->BSRR = GPIO_Pin;
 80032fe:	887a      	ldrh	r2, [r7, #2]
 8003300:	687b      	ldr	r3, [r7, #4]
 8003302:	619a      	str	r2, [r3, #24]
}
 8003304:	bf00      	nop
 8003306:	370c      	adds	r7, #12
 8003308:	46bd      	mov	sp, r7
 800330a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800330e:	4770      	bx	lr

08003310 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 8003310:	b580      	push	{r7, lr}
 8003312:	b084      	sub	sp, #16
 8003314:	af00      	add	r7, sp, #0
 8003316:	6078      	str	r0, [r7, #4]
  uint32_t freqrange;
  uint32_t pclk1;

  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8003318:	687b      	ldr	r3, [r7, #4]
 800331a:	2b00      	cmp	r3, #0
 800331c:	d101      	bne.n	8003322 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 800331e:	2301      	movs	r3, #1
 8003320:	e11f      	b.n	8003562 <HAL_I2C_Init+0x252>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 8003322:	687b      	ldr	r3, [r7, #4]
 8003324:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8003328:	b2db      	uxtb	r3, r3
 800332a:	2b00      	cmp	r3, #0
 800332c:	d106      	bne.n	800333c <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800332e:	687b      	ldr	r3, [r7, #4]
 8003330:	2200      	movs	r2, #0
 8003332:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
 8003336:	6878      	ldr	r0, [r7, #4]
 8003338:	f7fd fa68 	bl	800080c <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800333c:	687b      	ldr	r3, [r7, #4]
 800333e:	2224      	movs	r2, #36	; 0x24
 8003340:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 8003344:	687b      	ldr	r3, [r7, #4]
 8003346:	681b      	ldr	r3, [r3, #0]
 8003348:	681a      	ldr	r2, [r3, #0]
 800334a:	687b      	ldr	r3, [r7, #4]
 800334c:	681b      	ldr	r3, [r3, #0]
 800334e:	f022 0201 	bic.w	r2, r2, #1
 8003352:	601a      	str	r2, [r3, #0]

  /*Reset I2C*/
  hi2c->Instance->CR1 |= I2C_CR1_SWRST;
 8003354:	687b      	ldr	r3, [r7, #4]
 8003356:	681b      	ldr	r3, [r3, #0]
 8003358:	681a      	ldr	r2, [r3, #0]
 800335a:	687b      	ldr	r3, [r7, #4]
 800335c:	681b      	ldr	r3, [r3, #0]
 800335e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003362:	601a      	str	r2, [r3, #0]
  hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
 8003364:	687b      	ldr	r3, [r7, #4]
 8003366:	681b      	ldr	r3, [r3, #0]
 8003368:	681a      	ldr	r2, [r3, #0]
 800336a:	687b      	ldr	r3, [r7, #4]
 800336c:	681b      	ldr	r3, [r3, #0]
 800336e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8003372:	601a      	str	r2, [r3, #0]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();
 8003374:	f002 f9de 	bl	8005734 <HAL_RCC_GetPCLK1Freq>
 8003378:	60f8      	str	r0, [r7, #12]

  /* Check the minimum allowed PCLK1 frequency */
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 800337a:	687b      	ldr	r3, [r7, #4]
 800337c:	685b      	ldr	r3, [r3, #4]
 800337e:	4a7b      	ldr	r2, [pc, #492]	; (800356c <HAL_I2C_Init+0x25c>)
 8003380:	4293      	cmp	r3, r2
 8003382:	d807      	bhi.n	8003394 <HAL_I2C_Init+0x84>
 8003384:	68fb      	ldr	r3, [r7, #12]
 8003386:	4a7a      	ldr	r2, [pc, #488]	; (8003570 <HAL_I2C_Init+0x260>)
 8003388:	4293      	cmp	r3, r2
 800338a:	bf94      	ite	ls
 800338c:	2301      	movls	r3, #1
 800338e:	2300      	movhi	r3, #0
 8003390:	b2db      	uxtb	r3, r3
 8003392:	e006      	b.n	80033a2 <HAL_I2C_Init+0x92>
 8003394:	68fb      	ldr	r3, [r7, #12]
 8003396:	4a77      	ldr	r2, [pc, #476]	; (8003574 <HAL_I2C_Init+0x264>)
 8003398:	4293      	cmp	r3, r2
 800339a:	bf94      	ite	ls
 800339c:	2301      	movls	r3, #1
 800339e:	2300      	movhi	r3, #0
 80033a0:	b2db      	uxtb	r3, r3
 80033a2:	2b00      	cmp	r3, #0
 80033a4:	d001      	beq.n	80033aa <HAL_I2C_Init+0x9a>
  {
    return HAL_ERROR;
 80033a6:	2301      	movs	r3, #1
 80033a8:	e0db      	b.n	8003562 <HAL_I2C_Init+0x252>
  }

  /* Calculate frequency range */
  freqrange = I2C_FREQRANGE(pclk1);
 80033aa:	68fb      	ldr	r3, [r7, #12]
 80033ac:	4a72      	ldr	r2, [pc, #456]	; (8003578 <HAL_I2C_Init+0x268>)
 80033ae:	fba2 2303 	umull	r2, r3, r2, r3
 80033b2:	0c9b      	lsrs	r3, r3, #18
 80033b4:	60bb      	str	r3, [r7, #8]

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Frequency range */
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 80033b6:	687b      	ldr	r3, [r7, #4]
 80033b8:	681b      	ldr	r3, [r3, #0]
 80033ba:	685b      	ldr	r3, [r3, #4]
 80033bc:	f023 013f 	bic.w	r1, r3, #63	; 0x3f
 80033c0:	687b      	ldr	r3, [r7, #4]
 80033c2:	681b      	ldr	r3, [r3, #0]
 80033c4:	68ba      	ldr	r2, [r7, #8]
 80033c6:	430a      	orrs	r2, r1
 80033c8:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 80033ca:	687b      	ldr	r3, [r7, #4]
 80033cc:	681b      	ldr	r3, [r3, #0]
 80033ce:	6a1b      	ldr	r3, [r3, #32]
 80033d0:	f023 013f 	bic.w	r1, r3, #63	; 0x3f
 80033d4:	687b      	ldr	r3, [r7, #4]
 80033d6:	685b      	ldr	r3, [r3, #4]
 80033d8:	4a64      	ldr	r2, [pc, #400]	; (800356c <HAL_I2C_Init+0x25c>)
 80033da:	4293      	cmp	r3, r2
 80033dc:	d802      	bhi.n	80033e4 <HAL_I2C_Init+0xd4>
 80033de:	68bb      	ldr	r3, [r7, #8]
 80033e0:	3301      	adds	r3, #1
 80033e2:	e009      	b.n	80033f8 <HAL_I2C_Init+0xe8>
 80033e4:	68bb      	ldr	r3, [r7, #8]
 80033e6:	f44f 7296 	mov.w	r2, #300	; 0x12c
 80033ea:	fb02 f303 	mul.w	r3, r2, r3
 80033ee:	4a63      	ldr	r2, [pc, #396]	; (800357c <HAL_I2C_Init+0x26c>)
 80033f0:	fba2 2303 	umull	r2, r3, r2, r3
 80033f4:	099b      	lsrs	r3, r3, #6
 80033f6:	3301      	adds	r3, #1
 80033f8:	687a      	ldr	r2, [r7, #4]
 80033fa:	6812      	ldr	r2, [r2, #0]
 80033fc:	430b      	orrs	r3, r1
 80033fe:	6213      	str	r3, [r2, #32]

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 8003400:	687b      	ldr	r3, [r7, #4]
 8003402:	681b      	ldr	r3, [r3, #0]
 8003404:	69db      	ldr	r3, [r3, #28]
 8003406:	f423 424f 	bic.w	r2, r3, #52992	; 0xcf00
 800340a:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 800340e:	687b      	ldr	r3, [r7, #4]
 8003410:	685b      	ldr	r3, [r3, #4]
 8003412:	4956      	ldr	r1, [pc, #344]	; (800356c <HAL_I2C_Init+0x25c>)
 8003414:	428b      	cmp	r3, r1
 8003416:	d80d      	bhi.n	8003434 <HAL_I2C_Init+0x124>
 8003418:	68fb      	ldr	r3, [r7, #12]
 800341a:	1e59      	subs	r1, r3, #1
 800341c:	687b      	ldr	r3, [r7, #4]
 800341e:	685b      	ldr	r3, [r3, #4]
 8003420:	005b      	lsls	r3, r3, #1
 8003422:	fbb1 f3f3 	udiv	r3, r1, r3
 8003426:	3301      	adds	r3, #1
 8003428:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800342c:	2b04      	cmp	r3, #4
 800342e:	bf38      	it	cc
 8003430:	2304      	movcc	r3, #4
 8003432:	e04f      	b.n	80034d4 <HAL_I2C_Init+0x1c4>
 8003434:	687b      	ldr	r3, [r7, #4]
 8003436:	689b      	ldr	r3, [r3, #8]
 8003438:	2b00      	cmp	r3, #0
 800343a:	d111      	bne.n	8003460 <HAL_I2C_Init+0x150>
 800343c:	68fb      	ldr	r3, [r7, #12]
 800343e:	1e58      	subs	r0, r3, #1
 8003440:	687b      	ldr	r3, [r7, #4]
 8003442:	6859      	ldr	r1, [r3, #4]
 8003444:	460b      	mov	r3, r1
 8003446:	005b      	lsls	r3, r3, #1
 8003448:	440b      	add	r3, r1
 800344a:	fbb0 f3f3 	udiv	r3, r0, r3
 800344e:	3301      	adds	r3, #1
 8003450:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8003454:	2b00      	cmp	r3, #0
 8003456:	bf0c      	ite	eq
 8003458:	2301      	moveq	r3, #1
 800345a:	2300      	movne	r3, #0
 800345c:	b2db      	uxtb	r3, r3
 800345e:	e012      	b.n	8003486 <HAL_I2C_Init+0x176>
 8003460:	68fb      	ldr	r3, [r7, #12]
 8003462:	1e58      	subs	r0, r3, #1
 8003464:	687b      	ldr	r3, [r7, #4]
 8003466:	6859      	ldr	r1, [r3, #4]
 8003468:	460b      	mov	r3, r1
 800346a:	009b      	lsls	r3, r3, #2
 800346c:	440b      	add	r3, r1
 800346e:	0099      	lsls	r1, r3, #2
 8003470:	440b      	add	r3, r1
 8003472:	fbb0 f3f3 	udiv	r3, r0, r3
 8003476:	3301      	adds	r3, #1
 8003478:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800347c:	2b00      	cmp	r3, #0
 800347e:	bf0c      	ite	eq
 8003480:	2301      	moveq	r3, #1
 8003482:	2300      	movne	r3, #0
 8003484:	b2db      	uxtb	r3, r3
 8003486:	2b00      	cmp	r3, #0
 8003488:	d001      	beq.n	800348e <HAL_I2C_Init+0x17e>
 800348a:	2301      	movs	r3, #1
 800348c:	e022      	b.n	80034d4 <HAL_I2C_Init+0x1c4>
 800348e:	687b      	ldr	r3, [r7, #4]
 8003490:	689b      	ldr	r3, [r3, #8]
 8003492:	2b00      	cmp	r3, #0
 8003494:	d10e      	bne.n	80034b4 <HAL_I2C_Init+0x1a4>
 8003496:	68fb      	ldr	r3, [r7, #12]
 8003498:	1e58      	subs	r0, r3, #1
 800349a:	687b      	ldr	r3, [r7, #4]
 800349c:	6859      	ldr	r1, [r3, #4]
 800349e:	460b      	mov	r3, r1
 80034a0:	005b      	lsls	r3, r3, #1
 80034a2:	440b      	add	r3, r1
 80034a4:	fbb0 f3f3 	udiv	r3, r0, r3
 80034a8:	3301      	adds	r3, #1
 80034aa:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80034ae:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80034b2:	e00f      	b.n	80034d4 <HAL_I2C_Init+0x1c4>
 80034b4:	68fb      	ldr	r3, [r7, #12]
 80034b6:	1e58      	subs	r0, r3, #1
 80034b8:	687b      	ldr	r3, [r7, #4]
 80034ba:	6859      	ldr	r1, [r3, #4]
 80034bc:	460b      	mov	r3, r1
 80034be:	009b      	lsls	r3, r3, #2
 80034c0:	440b      	add	r3, r1
 80034c2:	0099      	lsls	r1, r3, #2
 80034c4:	440b      	add	r3, r1
 80034c6:	fbb0 f3f3 	udiv	r3, r0, r3
 80034ca:	3301      	adds	r3, #1
 80034cc:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80034d0:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80034d4:	6879      	ldr	r1, [r7, #4]
 80034d6:	6809      	ldr	r1, [r1, #0]
 80034d8:	4313      	orrs	r3, r2
 80034da:	61cb      	str	r3, [r1, #28]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
 80034dc:	687b      	ldr	r3, [r7, #4]
 80034de:	681b      	ldr	r3, [r3, #0]
 80034e0:	681b      	ldr	r3, [r3, #0]
 80034e2:	f023 01c0 	bic.w	r1, r3, #192	; 0xc0
 80034e6:	687b      	ldr	r3, [r7, #4]
 80034e8:	69da      	ldr	r2, [r3, #28]
 80034ea:	687b      	ldr	r3, [r7, #4]
 80034ec:	6a1b      	ldr	r3, [r3, #32]
 80034ee:	431a      	orrs	r2, r3
 80034f0:	687b      	ldr	r3, [r7, #4]
 80034f2:	681b      	ldr	r3, [r3, #0]
 80034f4:	430a      	orrs	r2, r1
 80034f6:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
 80034f8:	687b      	ldr	r3, [r7, #4]
 80034fa:	681b      	ldr	r3, [r3, #0]
 80034fc:	689b      	ldr	r3, [r3, #8]
 80034fe:	f423 4303 	bic.w	r3, r3, #33536	; 0x8300
 8003502:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8003506:	687a      	ldr	r2, [r7, #4]
 8003508:	6911      	ldr	r1, [r2, #16]
 800350a:	687a      	ldr	r2, [r7, #4]
 800350c:	68d2      	ldr	r2, [r2, #12]
 800350e:	4311      	orrs	r1, r2
 8003510:	687a      	ldr	r2, [r7, #4]
 8003512:	6812      	ldr	r2, [r2, #0]
 8003514:	430b      	orrs	r3, r1
 8003516:	6093      	str	r3, [r2, #8]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
 8003518:	687b      	ldr	r3, [r7, #4]
 800351a:	681b      	ldr	r3, [r3, #0]
 800351c:	68db      	ldr	r3, [r3, #12]
 800351e:	f023 01ff 	bic.w	r1, r3, #255	; 0xff
 8003522:	687b      	ldr	r3, [r7, #4]
 8003524:	695a      	ldr	r2, [r3, #20]
 8003526:	687b      	ldr	r3, [r7, #4]
 8003528:	699b      	ldr	r3, [r3, #24]
 800352a:	431a      	orrs	r2, r3
 800352c:	687b      	ldr	r3, [r7, #4]
 800352e:	681b      	ldr	r3, [r3, #0]
 8003530:	430a      	orrs	r2, r1
 8003532:	60da      	str	r2, [r3, #12]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8003534:	687b      	ldr	r3, [r7, #4]
 8003536:	681b      	ldr	r3, [r3, #0]
 8003538:	681a      	ldr	r2, [r3, #0]
 800353a:	687b      	ldr	r3, [r7, #4]
 800353c:	681b      	ldr	r3, [r3, #0]
 800353e:	f042 0201 	orr.w	r2, r2, #1
 8003542:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003544:	687b      	ldr	r3, [r7, #4]
 8003546:	2200      	movs	r2, #0
 8003548:	641a      	str	r2, [r3, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 800354a:	687b      	ldr	r3, [r7, #4]
 800354c:	2220      	movs	r2, #32
 800354e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 8003552:	687b      	ldr	r3, [r7, #4]
 8003554:	2200      	movs	r2, #0
 8003556:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8003558:	687b      	ldr	r3, [r7, #4]
 800355a:	2200      	movs	r2, #0
 800355c:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e

  return HAL_OK;
 8003560:	2300      	movs	r3, #0
}
 8003562:	4618      	mov	r0, r3
 8003564:	3710      	adds	r7, #16
 8003566:	46bd      	mov	sp, r7
 8003568:	bd80      	pop	{r7, pc}
 800356a:	bf00      	nop
 800356c:	000186a0 	.word	0x000186a0
 8003570:	001e847f 	.word	0x001e847f
 8003574:	003d08ff 	.word	0x003d08ff
 8003578:	431bde83 	.word	0x431bde83
 800357c:	10624dd3 	.word	0x10624dd3

08003580 <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 8003580:	b580      	push	{r7, lr}
 8003582:	b088      	sub	sp, #32
 8003584:	af00      	add	r7, sp, #0
 8003586:	6078      	str	r0, [r7, #4]
  uint32_t sr1itflags;
  uint32_t sr2itflags               = 0U;
 8003588:	2300      	movs	r3, #0
 800358a:	61bb      	str	r3, [r7, #24]
  uint32_t itsources                = READ_REG(hi2c->Instance->CR2);
 800358c:	687b      	ldr	r3, [r7, #4]
 800358e:	681b      	ldr	r3, [r3, #0]
 8003590:	685b      	ldr	r3, [r3, #4]
 8003592:	617b      	str	r3, [r7, #20]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8003594:	687b      	ldr	r3, [r7, #4]
 8003596:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003598:	613b      	str	r3, [r7, #16]
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 800359a:	687b      	ldr	r3, [r7, #4]
 800359c:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 80035a0:	73fb      	strb	r3, [r7, #15]
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 80035a2:	687b      	ldr	r3, [r7, #4]
 80035a4:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80035a8:	73bb      	strb	r3, [r7, #14]

  /* Master or Memory mode selected */
  if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 80035aa:	7bfb      	ldrb	r3, [r7, #15]
 80035ac:	2b10      	cmp	r3, #16
 80035ae:	d003      	beq.n	80035b8 <HAL_I2C_EV_IRQHandler+0x38>
 80035b0:	7bfb      	ldrb	r3, [r7, #15]
 80035b2:	2b40      	cmp	r3, #64	; 0x40
 80035b4:	f040 80bd 	bne.w	8003732 <HAL_I2C_EV_IRQHandler+0x1b2>
  {
    sr2itflags   = READ_REG(hi2c->Instance->SR2);
 80035b8:	687b      	ldr	r3, [r7, #4]
 80035ba:	681b      	ldr	r3, [r3, #0]
 80035bc:	699b      	ldr	r3, [r3, #24]
 80035be:	61bb      	str	r3, [r7, #24]
    sr1itflags   = READ_REG(hi2c->Instance->SR1);
 80035c0:	687b      	ldr	r3, [r7, #4]
 80035c2:	681b      	ldr	r3, [r3, #0]
 80035c4:	695b      	ldr	r3, [r3, #20]
 80035c6:	61fb      	str	r3, [r7, #28]

    /* Exit IRQ event until Start Bit detected in case of Other frame requested */
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) == RESET) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(CurrentXferOptions) == 1U))
 80035c8:	69fb      	ldr	r3, [r7, #28]
 80035ca:	f003 0301 	and.w	r3, r3, #1
 80035ce:	2b00      	cmp	r3, #0
 80035d0:	d10d      	bne.n	80035ee <HAL_I2C_EV_IRQHandler+0x6e>
 80035d2:	693b      	ldr	r3, [r7, #16]
 80035d4:	f5b3 0f2a 	cmp.w	r3, #11141120	; 0xaa0000
 80035d8:	d003      	beq.n	80035e2 <HAL_I2C_EV_IRQHandler+0x62>
 80035da:	693b      	ldr	r3, [r7, #16]
 80035dc:	f1b3 4f2a 	cmp.w	r3, #2852126720	; 0xaa000000
 80035e0:	d101      	bne.n	80035e6 <HAL_I2C_EV_IRQHandler+0x66>
 80035e2:	2301      	movs	r3, #1
 80035e4:	e000      	b.n	80035e8 <HAL_I2C_EV_IRQHandler+0x68>
 80035e6:	2300      	movs	r3, #0
 80035e8:	2b01      	cmp	r3, #1
 80035ea:	f000 812e 	beq.w	800384a <HAL_I2C_EV_IRQHandler+0x2ca>
    {
      return;
    }

    /* SB Set ----------------------------------------------------------------*/
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 80035ee:	69fb      	ldr	r3, [r7, #28]
 80035f0:	f003 0301 	and.w	r3, r3, #1
 80035f4:	2b00      	cmp	r3, #0
 80035f6:	d00c      	beq.n	8003612 <HAL_I2C_EV_IRQHandler+0x92>
 80035f8:	697b      	ldr	r3, [r7, #20]
 80035fa:	0a5b      	lsrs	r3, r3, #9
 80035fc:	f003 0301 	and.w	r3, r3, #1
 8003600:	2b00      	cmp	r3, #0
 8003602:	d006      	beq.n	8003612 <HAL_I2C_EV_IRQHandler+0x92>
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
 8003604:	6878      	ldr	r0, [r7, #4]
 8003606:	f001 fc23 	bl	8004e50 <I2C_ConvertOtherXferOptions>

      I2C_Master_SB(hi2c);
 800360a:	6878      	ldr	r0, [r7, #4]
 800360c:	f000 fd30 	bl	8004070 <I2C_Master_SB>
 8003610:	e08e      	b.n	8003730 <HAL_I2C_EV_IRQHandler+0x1b0>
    }
    /* ADD10 Set -------------------------------------------------------------*/
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADD10) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8003612:	69fb      	ldr	r3, [r7, #28]
 8003614:	08db      	lsrs	r3, r3, #3
 8003616:	f003 0301 	and.w	r3, r3, #1
 800361a:	2b00      	cmp	r3, #0
 800361c:	d009      	beq.n	8003632 <HAL_I2C_EV_IRQHandler+0xb2>
 800361e:	697b      	ldr	r3, [r7, #20]
 8003620:	0a5b      	lsrs	r3, r3, #9
 8003622:	f003 0301 	and.w	r3, r3, #1
 8003626:	2b00      	cmp	r3, #0
 8003628:	d003      	beq.n	8003632 <HAL_I2C_EV_IRQHandler+0xb2>
    {
      I2C_Master_ADD10(hi2c);
 800362a:	6878      	ldr	r0, [r7, #4]
 800362c:	f000 fda6 	bl	800417c <I2C_Master_ADD10>
 8003630:	e07e      	b.n	8003730 <HAL_I2C_EV_IRQHandler+0x1b0>
    }
    /* ADDR Set --------------------------------------------------------------*/
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8003632:	69fb      	ldr	r3, [r7, #28]
 8003634:	085b      	lsrs	r3, r3, #1
 8003636:	f003 0301 	and.w	r3, r3, #1
 800363a:	2b00      	cmp	r3, #0
 800363c:	d009      	beq.n	8003652 <HAL_I2C_EV_IRQHandler+0xd2>
 800363e:	697b      	ldr	r3, [r7, #20]
 8003640:	0a5b      	lsrs	r3, r3, #9
 8003642:	f003 0301 	and.w	r3, r3, #1
 8003646:	2b00      	cmp	r3, #0
 8003648:	d003      	beq.n	8003652 <HAL_I2C_EV_IRQHandler+0xd2>
    {
      I2C_Master_ADDR(hi2c);
 800364a:	6878      	ldr	r0, [r7, #4]
 800364c:	f000 fdc0 	bl	80041d0 <I2C_Master_ADDR>
 8003650:	e06e      	b.n	8003730 <HAL_I2C_EV_IRQHandler+0x1b0>
    }
    /* I2C in mode Transmitter -----------------------------------------------*/
    else if (I2C_CHECK_FLAG(sr2itflags, I2C_FLAG_TRA) != RESET)
 8003652:	69bb      	ldr	r3, [r7, #24]
 8003654:	089b      	lsrs	r3, r3, #2
 8003656:	f003 0301 	and.w	r3, r3, #1
 800365a:	2b00      	cmp	r3, #0
 800365c:	d037      	beq.n	80036ce <HAL_I2C_EV_IRQHandler+0x14e>
    {
      /* Do not check buffer and BTF flag if a Xfer DMA is on going */
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 800365e:	687b      	ldr	r3, [r7, #4]
 8003660:	681b      	ldr	r3, [r3, #0]
 8003662:	685b      	ldr	r3, [r3, #4]
 8003664:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003668:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800366c:	f000 80ef 	beq.w	800384e <HAL_I2C_EV_IRQHandler+0x2ce>
      {
        /* TXE set and BTF reset -----------------------------------------------*/
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8003670:	69fb      	ldr	r3, [r7, #28]
 8003672:	09db      	lsrs	r3, r3, #7
 8003674:	f003 0301 	and.w	r3, r3, #1
 8003678:	2b00      	cmp	r3, #0
 800367a:	d00f      	beq.n	800369c <HAL_I2C_EV_IRQHandler+0x11c>
 800367c:	697b      	ldr	r3, [r7, #20]
 800367e:	0a9b      	lsrs	r3, r3, #10
 8003680:	f003 0301 	and.w	r3, r3, #1
 8003684:	2b00      	cmp	r3, #0
 8003686:	d009      	beq.n	800369c <HAL_I2C_EV_IRQHandler+0x11c>
 8003688:	69fb      	ldr	r3, [r7, #28]
 800368a:	089b      	lsrs	r3, r3, #2
 800368c:	f003 0301 	and.w	r3, r3, #1
 8003690:	2b00      	cmp	r3, #0
 8003692:	d103      	bne.n	800369c <HAL_I2C_EV_IRQHandler+0x11c>
        {
          I2C_MasterTransmit_TXE(hi2c);
 8003694:	6878      	ldr	r0, [r7, #4]
 8003696:	f000 f9bd 	bl	8003a14 <I2C_MasterTransmit_TXE>
 800369a:	e049      	b.n	8003730 <HAL_I2C_EV_IRQHandler+0x1b0>
        }
        /* BTF set -------------------------------------------------------------*/
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800369c:	69fb      	ldr	r3, [r7, #28]
 800369e:	089b      	lsrs	r3, r3, #2
 80036a0:	f003 0301 	and.w	r3, r3, #1
 80036a4:	2b00      	cmp	r3, #0
 80036a6:	f000 80d2 	beq.w	800384e <HAL_I2C_EV_IRQHandler+0x2ce>
 80036aa:	697b      	ldr	r3, [r7, #20]
 80036ac:	0a5b      	lsrs	r3, r3, #9
 80036ae:	f003 0301 	and.w	r3, r3, #1
 80036b2:	2b00      	cmp	r3, #0
 80036b4:	f000 80cb 	beq.w	800384e <HAL_I2C_EV_IRQHandler+0x2ce>
        {
          if (CurrentMode == HAL_I2C_MODE_MASTER)
 80036b8:	7bfb      	ldrb	r3, [r7, #15]
 80036ba:	2b10      	cmp	r3, #16
 80036bc:	d103      	bne.n	80036c6 <HAL_I2C_EV_IRQHandler+0x146>
          {
            I2C_MasterTransmit_BTF(hi2c);
 80036be:	6878      	ldr	r0, [r7, #4]
 80036c0:	f000 fa44 	bl	8003b4c <I2C_MasterTransmit_BTF>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 80036c4:	e0c3      	b.n	800384e <HAL_I2C_EV_IRQHandler+0x2ce>
          }
          else /* HAL_I2C_MODE_MEM */
          {
            I2C_MemoryTransmit_TXE_BTF(hi2c);
 80036c6:	6878      	ldr	r0, [r7, #4]
 80036c8:	f000 faa8 	bl	8003c1c <I2C_MemoryTransmit_TXE_BTF>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 80036cc:	e0bf      	b.n	800384e <HAL_I2C_EV_IRQHandler+0x2ce>
    }
    /* I2C in mode Receiver --------------------------------------------------*/
    else
    {
      /* Do not check buffer and BTF flag if a Xfer DMA is on going */
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 80036ce:	687b      	ldr	r3, [r7, #4]
 80036d0:	681b      	ldr	r3, [r3, #0]
 80036d2:	685b      	ldr	r3, [r3, #4]
 80036d4:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80036d8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80036dc:	f000 80b7 	beq.w	800384e <HAL_I2C_EV_IRQHandler+0x2ce>
      {
        /* RXNE set and BTF reset -----------------------------------------------*/
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 80036e0:	69fb      	ldr	r3, [r7, #28]
 80036e2:	099b      	lsrs	r3, r3, #6
 80036e4:	f003 0301 	and.w	r3, r3, #1
 80036e8:	2b00      	cmp	r3, #0
 80036ea:	d00f      	beq.n	800370c <HAL_I2C_EV_IRQHandler+0x18c>
 80036ec:	697b      	ldr	r3, [r7, #20]
 80036ee:	0a9b      	lsrs	r3, r3, #10
 80036f0:	f003 0301 	and.w	r3, r3, #1
 80036f4:	2b00      	cmp	r3, #0
 80036f6:	d009      	beq.n	800370c <HAL_I2C_EV_IRQHandler+0x18c>
 80036f8:	69fb      	ldr	r3, [r7, #28]
 80036fa:	089b      	lsrs	r3, r3, #2
 80036fc:	f003 0301 	and.w	r3, r3, #1
 8003700:	2b00      	cmp	r3, #0
 8003702:	d103      	bne.n	800370c <HAL_I2C_EV_IRQHandler+0x18c>
        {
          I2C_MasterReceive_RXNE(hi2c);
 8003704:	6878      	ldr	r0, [r7, #4]
 8003706:	f000 fb18 	bl	8003d3a <I2C_MasterReceive_RXNE>
 800370a:	e011      	b.n	8003730 <HAL_I2C_EV_IRQHandler+0x1b0>
        }
        /* BTF set -------------------------------------------------------------*/
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800370c:	69fb      	ldr	r3, [r7, #28]
 800370e:	089b      	lsrs	r3, r3, #2
 8003710:	f003 0301 	and.w	r3, r3, #1
 8003714:	2b00      	cmp	r3, #0
 8003716:	f000 809a 	beq.w	800384e <HAL_I2C_EV_IRQHandler+0x2ce>
 800371a:	697b      	ldr	r3, [r7, #20]
 800371c:	0a5b      	lsrs	r3, r3, #9
 800371e:	f003 0301 	and.w	r3, r3, #1
 8003722:	2b00      	cmp	r3, #0
 8003724:	f000 8093 	beq.w	800384e <HAL_I2C_EV_IRQHandler+0x2ce>
        {
          I2C_MasterReceive_BTF(hi2c);
 8003728:	6878      	ldr	r0, [r7, #4]
 800372a:	f000 fbb7 	bl	8003e9c <I2C_MasterReceive_BTF>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800372e:	e08e      	b.n	800384e <HAL_I2C_EV_IRQHandler+0x2ce>
 8003730:	e08d      	b.n	800384e <HAL_I2C_EV_IRQHandler+0x2ce>
  /* Slave mode selected */
  else
  {
    /* If an error is detected, read only SR1 register to prevent */
    /* a clear of ADDR flags by reading SR2 after reading SR1 in Error treatment */
    if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003732:	687b      	ldr	r3, [r7, #4]
 8003734:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003736:	2b00      	cmp	r3, #0
 8003738:	d004      	beq.n	8003744 <HAL_I2C_EV_IRQHandler+0x1c4>
    {
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 800373a:	687b      	ldr	r3, [r7, #4]
 800373c:	681b      	ldr	r3, [r3, #0]
 800373e:	695b      	ldr	r3, [r3, #20]
 8003740:	61fb      	str	r3, [r7, #28]
 8003742:	e007      	b.n	8003754 <HAL_I2C_EV_IRQHandler+0x1d4>
    }
    else
    {
      sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8003744:	687b      	ldr	r3, [r7, #4]
 8003746:	681b      	ldr	r3, [r3, #0]
 8003748:	699b      	ldr	r3, [r3, #24]
 800374a:	61bb      	str	r3, [r7, #24]
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 800374c:	687b      	ldr	r3, [r7, #4]
 800374e:	681b      	ldr	r3, [r3, #0]
 8003750:	695b      	ldr	r3, [r3, #20]
 8003752:	61fb      	str	r3, [r7, #28]
    }

    /* ADDR set --------------------------------------------------------------*/
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8003754:	69fb      	ldr	r3, [r7, #28]
 8003756:	085b      	lsrs	r3, r3, #1
 8003758:	f003 0301 	and.w	r3, r3, #1
 800375c:	2b00      	cmp	r3, #0
 800375e:	d012      	beq.n	8003786 <HAL_I2C_EV_IRQHandler+0x206>
 8003760:	697b      	ldr	r3, [r7, #20]
 8003762:	0a5b      	lsrs	r3, r3, #9
 8003764:	f003 0301 	and.w	r3, r3, #1
 8003768:	2b00      	cmp	r3, #0
 800376a:	d00c      	beq.n	8003786 <HAL_I2C_EV_IRQHandler+0x206>
    {
      /* Now time to read SR2, this will clear ADDR flag automatically */
      if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 800376c:	687b      	ldr	r3, [r7, #4]
 800376e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003770:	2b00      	cmp	r3, #0
 8003772:	d003      	beq.n	800377c <HAL_I2C_EV_IRQHandler+0x1fc>
      {
        sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8003774:	687b      	ldr	r3, [r7, #4]
 8003776:	681b      	ldr	r3, [r3, #0]
 8003778:	699b      	ldr	r3, [r3, #24]
 800377a:	61bb      	str	r3, [r7, #24]
      }
      I2C_Slave_ADDR(hi2c, sr2itflags);
 800377c:	69b9      	ldr	r1, [r7, #24]
 800377e:	6878      	ldr	r0, [r7, #4]
 8003780:	f000 ff75 	bl	800466e <I2C_Slave_ADDR>
 8003784:	e066      	b.n	8003854 <HAL_I2C_EV_IRQHandler+0x2d4>
    }
    /* STOPF set --------------------------------------------------------------*/
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8003786:	69fb      	ldr	r3, [r7, #28]
 8003788:	091b      	lsrs	r3, r3, #4
 800378a:	f003 0301 	and.w	r3, r3, #1
 800378e:	2b00      	cmp	r3, #0
 8003790:	d009      	beq.n	80037a6 <HAL_I2C_EV_IRQHandler+0x226>
 8003792:	697b      	ldr	r3, [r7, #20]
 8003794:	0a5b      	lsrs	r3, r3, #9
 8003796:	f003 0301 	and.w	r3, r3, #1
 800379a:	2b00      	cmp	r3, #0
 800379c:	d003      	beq.n	80037a6 <HAL_I2C_EV_IRQHandler+0x226>
    {
      I2C_Slave_STOPF(hi2c);
 800379e:	6878      	ldr	r0, [r7, #4]
 80037a0:	f000 ffaa 	bl	80046f8 <I2C_Slave_STOPF>
 80037a4:	e056      	b.n	8003854 <HAL_I2C_EV_IRQHandler+0x2d4>
    }
    /* I2C in mode Transmitter -----------------------------------------------*/
    else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 80037a6:	7bbb      	ldrb	r3, [r7, #14]
 80037a8:	2b21      	cmp	r3, #33	; 0x21
 80037aa:	d002      	beq.n	80037b2 <HAL_I2C_EV_IRQHandler+0x232>
 80037ac:	7bbb      	ldrb	r3, [r7, #14]
 80037ae:	2b29      	cmp	r3, #41	; 0x29
 80037b0:	d125      	bne.n	80037fe <HAL_I2C_EV_IRQHandler+0x27e>
    {
      /* TXE set and BTF reset -----------------------------------------------*/
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 80037b2:	69fb      	ldr	r3, [r7, #28]
 80037b4:	09db      	lsrs	r3, r3, #7
 80037b6:	f003 0301 	and.w	r3, r3, #1
 80037ba:	2b00      	cmp	r3, #0
 80037bc:	d00f      	beq.n	80037de <HAL_I2C_EV_IRQHandler+0x25e>
 80037be:	697b      	ldr	r3, [r7, #20]
 80037c0:	0a9b      	lsrs	r3, r3, #10
 80037c2:	f003 0301 	and.w	r3, r3, #1
 80037c6:	2b00      	cmp	r3, #0
 80037c8:	d009      	beq.n	80037de <HAL_I2C_EV_IRQHandler+0x25e>
 80037ca:	69fb      	ldr	r3, [r7, #28]
 80037cc:	089b      	lsrs	r3, r3, #2
 80037ce:	f003 0301 	and.w	r3, r3, #1
 80037d2:	2b00      	cmp	r3, #0
 80037d4:	d103      	bne.n	80037de <HAL_I2C_EV_IRQHandler+0x25e>
      {
        I2C_SlaveTransmit_TXE(hi2c);
 80037d6:	6878      	ldr	r0, [r7, #4]
 80037d8:	f000 fe8b 	bl	80044f2 <I2C_SlaveTransmit_TXE>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 80037dc:	e039      	b.n	8003852 <HAL_I2C_EV_IRQHandler+0x2d2>
      }
      /* BTF set -------------------------------------------------------------*/
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 80037de:	69fb      	ldr	r3, [r7, #28]
 80037e0:	089b      	lsrs	r3, r3, #2
 80037e2:	f003 0301 	and.w	r3, r3, #1
 80037e6:	2b00      	cmp	r3, #0
 80037e8:	d033      	beq.n	8003852 <HAL_I2C_EV_IRQHandler+0x2d2>
 80037ea:	697b      	ldr	r3, [r7, #20]
 80037ec:	0a5b      	lsrs	r3, r3, #9
 80037ee:	f003 0301 	and.w	r3, r3, #1
 80037f2:	2b00      	cmp	r3, #0
 80037f4:	d02d      	beq.n	8003852 <HAL_I2C_EV_IRQHandler+0x2d2>
      {
        I2C_SlaveTransmit_BTF(hi2c);
 80037f6:	6878      	ldr	r0, [r7, #4]
 80037f8:	f000 feb8 	bl	800456c <I2C_SlaveTransmit_BTF>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 80037fc:	e029      	b.n	8003852 <HAL_I2C_EV_IRQHandler+0x2d2>
    }
    /* I2C in mode Receiver --------------------------------------------------*/
    else
    {
      /* RXNE set and BTF reset ----------------------------------------------*/
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 80037fe:	69fb      	ldr	r3, [r7, #28]
 8003800:	099b      	lsrs	r3, r3, #6
 8003802:	f003 0301 	and.w	r3, r3, #1
 8003806:	2b00      	cmp	r3, #0
 8003808:	d00f      	beq.n	800382a <HAL_I2C_EV_IRQHandler+0x2aa>
 800380a:	697b      	ldr	r3, [r7, #20]
 800380c:	0a9b      	lsrs	r3, r3, #10
 800380e:	f003 0301 	and.w	r3, r3, #1
 8003812:	2b00      	cmp	r3, #0
 8003814:	d009      	beq.n	800382a <HAL_I2C_EV_IRQHandler+0x2aa>
 8003816:	69fb      	ldr	r3, [r7, #28]
 8003818:	089b      	lsrs	r3, r3, #2
 800381a:	f003 0301 	and.w	r3, r3, #1
 800381e:	2b00      	cmp	r3, #0
 8003820:	d103      	bne.n	800382a <HAL_I2C_EV_IRQHandler+0x2aa>
      {
        I2C_SlaveReceive_RXNE(hi2c);
 8003822:	6878      	ldr	r0, [r7, #4]
 8003824:	f000 fec3 	bl	80045ae <I2C_SlaveReceive_RXNE>
 8003828:	e014      	b.n	8003854 <HAL_I2C_EV_IRQHandler+0x2d4>
      }
      /* BTF set -------------------------------------------------------------*/
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800382a:	69fb      	ldr	r3, [r7, #28]
 800382c:	089b      	lsrs	r3, r3, #2
 800382e:	f003 0301 	and.w	r3, r3, #1
 8003832:	2b00      	cmp	r3, #0
 8003834:	d00e      	beq.n	8003854 <HAL_I2C_EV_IRQHandler+0x2d4>
 8003836:	697b      	ldr	r3, [r7, #20]
 8003838:	0a5b      	lsrs	r3, r3, #9
 800383a:	f003 0301 	and.w	r3, r3, #1
 800383e:	2b00      	cmp	r3, #0
 8003840:	d008      	beq.n	8003854 <HAL_I2C_EV_IRQHandler+0x2d4>
      {
        I2C_SlaveReceive_BTF(hi2c);
 8003842:	6878      	ldr	r0, [r7, #4]
 8003844:	f000 fef1 	bl	800462a <I2C_SlaveReceive_BTF>
 8003848:	e004      	b.n	8003854 <HAL_I2C_EV_IRQHandler+0x2d4>
      return;
 800384a:	bf00      	nop
 800384c:	e002      	b.n	8003854 <HAL_I2C_EV_IRQHandler+0x2d4>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800384e:	bf00      	nop
 8003850:	e000      	b.n	8003854 <HAL_I2C_EV_IRQHandler+0x2d4>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8003852:	bf00      	nop
      {
        /* Do nothing */
      }
    }
  }
}
 8003854:	3720      	adds	r7, #32
 8003856:	46bd      	mov	sp, r7
 8003858:	bd80      	pop	{r7, pc}

0800385a <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 800385a:	b580      	push	{r7, lr}
 800385c:	b08a      	sub	sp, #40	; 0x28
 800385e:	af00      	add	r7, sp, #0
 8003860:	6078      	str	r0, [r7, #4]
  HAL_I2C_ModeTypeDef tmp1;
  uint32_t tmp2;
  HAL_I2C_StateTypeDef tmp3;
  uint32_t tmp4;
  uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
 8003862:	687b      	ldr	r3, [r7, #4]
 8003864:	681b      	ldr	r3, [r3, #0]
 8003866:	695b      	ldr	r3, [r3, #20]
 8003868:	623b      	str	r3, [r7, #32]
  uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
 800386a:	687b      	ldr	r3, [r7, #4]
 800386c:	681b      	ldr	r3, [r3, #0]
 800386e:	685b      	ldr	r3, [r3, #4]
 8003870:	61fb      	str	r3, [r7, #28]
  uint32_t error      = HAL_I2C_ERROR_NONE;
 8003872:	2300      	movs	r3, #0
 8003874:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 8003876:	687b      	ldr	r3, [r7, #4]
 8003878:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 800387c:	76fb      	strb	r3, [r7, #27]

  /* I2C Bus error interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 800387e:	6a3b      	ldr	r3, [r7, #32]
 8003880:	0a1b      	lsrs	r3, r3, #8
 8003882:	f003 0301 	and.w	r3, r3, #1
 8003886:	2b00      	cmp	r3, #0
 8003888:	d00e      	beq.n	80038a8 <HAL_I2C_ER_IRQHandler+0x4e>
 800388a:	69fb      	ldr	r3, [r7, #28]
 800388c:	0a1b      	lsrs	r3, r3, #8
 800388e:	f003 0301 	and.w	r3, r3, #1
 8003892:	2b00      	cmp	r3, #0
 8003894:	d008      	beq.n	80038a8 <HAL_I2C_ER_IRQHandler+0x4e>
  {
    error |= HAL_I2C_ERROR_BERR;
 8003896:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003898:	f043 0301 	orr.w	r3, r3, #1
 800389c:	627b      	str	r3, [r7, #36]	; 0x24

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 800389e:	687b      	ldr	r3, [r7, #4]
 80038a0:	681b      	ldr	r3, [r3, #0]
 80038a2:	f46f 7280 	mvn.w	r2, #256	; 0x100
 80038a6:	615a      	str	r2, [r3, #20]
  }

  /* I2C Arbitration Lost error interrupt occurred ---------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 80038a8:	6a3b      	ldr	r3, [r7, #32]
 80038aa:	0a5b      	lsrs	r3, r3, #9
 80038ac:	f003 0301 	and.w	r3, r3, #1
 80038b0:	2b00      	cmp	r3, #0
 80038b2:	d00e      	beq.n	80038d2 <HAL_I2C_ER_IRQHandler+0x78>
 80038b4:	69fb      	ldr	r3, [r7, #28]
 80038b6:	0a1b      	lsrs	r3, r3, #8
 80038b8:	f003 0301 	and.w	r3, r3, #1
 80038bc:	2b00      	cmp	r3, #0
 80038be:	d008      	beq.n	80038d2 <HAL_I2C_ER_IRQHandler+0x78>
  {
    error |= HAL_I2C_ERROR_ARLO;
 80038c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80038c2:	f043 0302 	orr.w	r3, r3, #2
 80038c6:	627b      	str	r3, [r7, #36]	; 0x24

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 80038c8:	687b      	ldr	r3, [r7, #4]
 80038ca:	681b      	ldr	r3, [r3, #0]
 80038cc:	f46f 7200 	mvn.w	r2, #512	; 0x200
 80038d0:	615a      	str	r2, [r3, #20]
  }

  /* I2C Acknowledge failure error interrupt occurred ------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 80038d2:	6a3b      	ldr	r3, [r7, #32]
 80038d4:	0a9b      	lsrs	r3, r3, #10
 80038d6:	f003 0301 	and.w	r3, r3, #1
 80038da:	2b00      	cmp	r3, #0
 80038dc:	d03f      	beq.n	800395e <HAL_I2C_ER_IRQHandler+0x104>
 80038de:	69fb      	ldr	r3, [r7, #28]
 80038e0:	0a1b      	lsrs	r3, r3, #8
 80038e2:	f003 0301 	and.w	r3, r3, #1
 80038e6:	2b00      	cmp	r3, #0
 80038e8:	d039      	beq.n	800395e <HAL_I2C_ER_IRQHandler+0x104>
  {
    tmp1 = CurrentMode;
 80038ea:	7efb      	ldrb	r3, [r7, #27]
 80038ec:	76bb      	strb	r3, [r7, #26]
    tmp2 = hi2c->XferCount;
 80038ee:	687b      	ldr	r3, [r7, #4]
 80038f0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80038f2:	b29b      	uxth	r3, r3
 80038f4:	617b      	str	r3, [r7, #20]
    tmp3 = hi2c->State;
 80038f6:	687b      	ldr	r3, [r7, #4]
 80038f8:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80038fc:	74fb      	strb	r3, [r7, #19]
    tmp4 = hi2c->PreviousState;
 80038fe:	687b      	ldr	r3, [r7, #4]
 8003900:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003902:	60fb      	str	r3, [r7, #12]
    if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8003904:	7ebb      	ldrb	r3, [r7, #26]
 8003906:	2b20      	cmp	r3, #32
 8003908:	d112      	bne.n	8003930 <HAL_I2C_ER_IRQHandler+0xd6>
 800390a:	697b      	ldr	r3, [r7, #20]
 800390c:	2b00      	cmp	r3, #0
 800390e:	d10f      	bne.n	8003930 <HAL_I2C_ER_IRQHandler+0xd6>
 8003910:	7cfb      	ldrb	r3, [r7, #19]
 8003912:	2b21      	cmp	r3, #33	; 0x21
 8003914:	d008      	beq.n	8003928 <HAL_I2C_ER_IRQHandler+0xce>
        ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
 8003916:	7cfb      	ldrb	r3, [r7, #19]
 8003918:	2b29      	cmp	r3, #41	; 0x29
 800391a:	d005      	beq.n	8003928 <HAL_I2C_ER_IRQHandler+0xce>
 800391c:	7cfb      	ldrb	r3, [r7, #19]
 800391e:	2b28      	cmp	r3, #40	; 0x28
 8003920:	d106      	bne.n	8003930 <HAL_I2C_ER_IRQHandler+0xd6>
         ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
 8003922:	68fb      	ldr	r3, [r7, #12]
 8003924:	2b21      	cmp	r3, #33	; 0x21
 8003926:	d103      	bne.n	8003930 <HAL_I2C_ER_IRQHandler+0xd6>
    {
      I2C_Slave_AF(hi2c);
 8003928:	6878      	ldr	r0, [r7, #4]
 800392a:	f001 f815 	bl	8004958 <I2C_Slave_AF>
 800392e:	e016      	b.n	800395e <HAL_I2C_ER_IRQHandler+0x104>
    }
    else
    {
      /* Clear AF flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8003930:	687b      	ldr	r3, [r7, #4]
 8003932:	681b      	ldr	r3, [r3, #0]
 8003934:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8003938:	615a      	str	r2, [r3, #20]

      error |= HAL_I2C_ERROR_AF;
 800393a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800393c:	f043 0304 	orr.w	r3, r3, #4
 8003940:	627b      	str	r3, [r7, #36]	; 0x24

      /* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */
      if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 8003942:	7efb      	ldrb	r3, [r7, #27]
 8003944:	2b10      	cmp	r3, #16
 8003946:	d002      	beq.n	800394e <HAL_I2C_ER_IRQHandler+0xf4>
 8003948:	7efb      	ldrb	r3, [r7, #27]
 800394a:	2b40      	cmp	r3, #64	; 0x40
 800394c:	d107      	bne.n	800395e <HAL_I2C_ER_IRQHandler+0x104>
      {
        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800394e:	687b      	ldr	r3, [r7, #4]
 8003950:	681b      	ldr	r3, [r3, #0]
 8003952:	681a      	ldr	r2, [r3, #0]
 8003954:	687b      	ldr	r3, [r7, #4]
 8003956:	681b      	ldr	r3, [r3, #0]
 8003958:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800395c:	601a      	str	r2, [r3, #0]
      }
    }
  }

  /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 800395e:	6a3b      	ldr	r3, [r7, #32]
 8003960:	0adb      	lsrs	r3, r3, #11
 8003962:	f003 0301 	and.w	r3, r3, #1
 8003966:	2b00      	cmp	r3, #0
 8003968:	d00e      	beq.n	8003988 <HAL_I2C_ER_IRQHandler+0x12e>
 800396a:	69fb      	ldr	r3, [r7, #28]
 800396c:	0a1b      	lsrs	r3, r3, #8
 800396e:	f003 0301 	and.w	r3, r3, #1
 8003972:	2b00      	cmp	r3, #0
 8003974:	d008      	beq.n	8003988 <HAL_I2C_ER_IRQHandler+0x12e>
  {
    error |= HAL_I2C_ERROR_OVR;
 8003976:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003978:	f043 0308 	orr.w	r3, r3, #8
 800397c:	627b      	str	r3, [r7, #36]	; 0x24
    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 800397e:	687b      	ldr	r3, [r7, #4]
 8003980:	681b      	ldr	r3, [r3, #0]
 8003982:	f46f 6200 	mvn.w	r2, #2048	; 0x800
 8003986:	615a      	str	r2, [r3, #20]
  }

  /* Call the Error Callback in case of Error detected -----------------------*/
  if (error != HAL_I2C_ERROR_NONE)
 8003988:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800398a:	2b00      	cmp	r3, #0
 800398c:	d008      	beq.n	80039a0 <HAL_I2C_ER_IRQHandler+0x146>
  {
    hi2c->ErrorCode |= error;
 800398e:	687b      	ldr	r3, [r7, #4]
 8003990:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8003992:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003994:	431a      	orrs	r2, r3
 8003996:	687b      	ldr	r3, [r7, #4]
 8003998:	641a      	str	r2, [r3, #64]	; 0x40
    I2C_ITError(hi2c);
 800399a:	6878      	ldr	r0, [r7, #4]
 800399c:	f001 f84c 	bl	8004a38 <I2C_ITError>
  }
}
 80039a0:	bf00      	nop
 80039a2:	3728      	adds	r7, #40	; 0x28
 80039a4:	46bd      	mov	sp, r7
 80039a6:	bd80      	pop	{r7, pc}

080039a8 <HAL_I2C_SlaveTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 80039a8:	b480      	push	{r7}
 80039aa:	b083      	sub	sp, #12
 80039ac:	af00      	add	r7, sp, #0
 80039ae:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   */
}
 80039b0:	bf00      	nop
 80039b2:	370c      	adds	r7, #12
 80039b4:	46bd      	mov	sp, r7
 80039b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039ba:	4770      	bx	lr

080039bc <HAL_I2C_SlaveRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 80039bc:	b480      	push	{r7}
 80039be:	b083      	sub	sp, #12
 80039c0:	af00      	add	r7, sp, #0
 80039c2:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   */
}
 80039c4:	bf00      	nop
 80039c6:	370c      	adds	r7, #12
 80039c8:	46bd      	mov	sp, r7
 80039ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039ce:	4770      	bx	lr

080039d0 <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XferDirection_definition
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
 80039d0:	b480      	push	{r7}
 80039d2:	b083      	sub	sp, #12
 80039d4:	af00      	add	r7, sp, #0
 80039d6:	6078      	str	r0, [r7, #4]
 80039d8:	460b      	mov	r3, r1
 80039da:	70fb      	strb	r3, [r7, #3]
 80039dc:	4613      	mov	r3, r2
 80039de:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
 80039e0:	bf00      	nop
 80039e2:	370c      	adds	r7, #12
 80039e4:	46bd      	mov	sp, r7
 80039e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039ea:	4770      	bx	lr

080039ec <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
 80039ec:	b480      	push	{r7}
 80039ee:	b083      	sub	sp, #12
 80039f0:	af00      	add	r7, sp, #0
 80039f2:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
  */
}
 80039f4:	bf00      	nop
 80039f6:	370c      	adds	r7, #12
 80039f8:	46bd      	mov	sp, r7
 80039fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039fe:	4770      	bx	lr

08003a00 <HAL_I2C_AbortCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8003a00:	b480      	push	{r7}
 8003a02:	b083      	sub	sp, #12
 8003a04:	af00      	add	r7, sp, #0
 8003a06:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   */
}
 8003a08:	bf00      	nop
 8003a0a:	370c      	adds	r7, #12
 8003a0c:	46bd      	mov	sp, r7
 8003a0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a12:	4770      	bx	lr

08003a14 <I2C_MasterTransmit_TXE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
{
 8003a14:	b580      	push	{r7, lr}
 8003a16:	b084      	sub	sp, #16
 8003a18:	af00      	add	r7, sp, #0
 8003a1a:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8003a1c:	687b      	ldr	r3, [r7, #4]
 8003a1e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8003a22:	73fb      	strb	r3, [r7, #15]
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 8003a24:	687b      	ldr	r3, [r7, #4]
 8003a26:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8003a2a:	73bb      	strb	r3, [r7, #14]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8003a2c:	687b      	ldr	r3, [r7, #4]
 8003a2e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003a30:	60bb      	str	r3, [r7, #8]

  if ((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 8003a32:	687b      	ldr	r3, [r7, #4]
 8003a34:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8003a36:	2b00      	cmp	r3, #0
 8003a38:	d150      	bne.n	8003adc <I2C_MasterTransmit_TXE+0xc8>
 8003a3a:	7bfb      	ldrb	r3, [r7, #15]
 8003a3c:	2b21      	cmp	r3, #33	; 0x21
 8003a3e:	d14d      	bne.n	8003adc <I2C_MasterTransmit_TXE+0xc8>
  {
    /* Call TxCpltCallback() directly if no stop mode is set */
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 8003a40:	68bb      	ldr	r3, [r7, #8]
 8003a42:	2b08      	cmp	r3, #8
 8003a44:	d01d      	beq.n	8003a82 <I2C_MasterTransmit_TXE+0x6e>
 8003a46:	68bb      	ldr	r3, [r7, #8]
 8003a48:	2b20      	cmp	r3, #32
 8003a4a:	d01a      	beq.n	8003a82 <I2C_MasterTransmit_TXE+0x6e>
 8003a4c:	68bb      	ldr	r3, [r7, #8]
 8003a4e:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 8003a52:	d016      	beq.n	8003a82 <I2C_MasterTransmit_TXE+0x6e>
    {
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8003a54:	687b      	ldr	r3, [r7, #4]
 8003a56:	681b      	ldr	r3, [r3, #0]
 8003a58:	685a      	ldr	r2, [r3, #4]
 8003a5a:	687b      	ldr	r3, [r7, #4]
 8003a5c:	681b      	ldr	r3, [r3, #0]
 8003a5e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8003a62:	605a      	str	r2, [r3, #4]

      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8003a64:	687b      	ldr	r3, [r7, #4]
 8003a66:	2211      	movs	r2, #17
 8003a68:	631a      	str	r2, [r3, #48]	; 0x30
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8003a6a:	687b      	ldr	r3, [r7, #4]
 8003a6c:	2200      	movs	r2, #0
 8003a6e:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      hi2c->State = HAL_I2C_STATE_READY;
 8003a72:	687b      	ldr	r3, [r7, #4]
 8003a74:	2220      	movs	r2, #32
 8003a76:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
      hi2c->MasterTxCpltCallback(hi2c);
#else
      HAL_I2C_MasterTxCpltCallback(hi2c);
 8003a7a:	6878      	ldr	r0, [r7, #4]
 8003a7c:	f023 ff56 	bl	802792c <HAL_I2C_MasterTxCpltCallback>
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 8003a80:	e060      	b.n	8003b44 <I2C_MasterTransmit_TXE+0x130>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    }
    else /* Generate Stop condition then Call TxCpltCallback() */
    {
      /* Disable EVT, BUF and ERR interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8003a82:	687b      	ldr	r3, [r7, #4]
 8003a84:	681b      	ldr	r3, [r3, #0]
 8003a86:	685a      	ldr	r2, [r3, #4]
 8003a88:	687b      	ldr	r3, [r7, #4]
 8003a8a:	681b      	ldr	r3, [r3, #0]
 8003a8c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8003a90:	605a      	str	r2, [r3, #4]

      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8003a92:	687b      	ldr	r3, [r7, #4]
 8003a94:	681b      	ldr	r3, [r3, #0]
 8003a96:	681a      	ldr	r2, [r3, #0]
 8003a98:	687b      	ldr	r3, [r7, #4]
 8003a9a:	681b      	ldr	r3, [r3, #0]
 8003a9c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8003aa0:	601a      	str	r2, [r3, #0]

      hi2c->PreviousState = I2C_STATE_NONE;
 8003aa2:	687b      	ldr	r3, [r7, #4]
 8003aa4:	2200      	movs	r2, #0
 8003aa6:	631a      	str	r2, [r3, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 8003aa8:	687b      	ldr	r3, [r7, #4]
 8003aaa:	2220      	movs	r2, #32
 8003aac:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8003ab0:	687b      	ldr	r3, [r7, #4]
 8003ab2:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8003ab6:	b2db      	uxtb	r3, r3
 8003ab8:	2b40      	cmp	r3, #64	; 0x40
 8003aba:	d107      	bne.n	8003acc <I2C_MasterTransmit_TXE+0xb8>
      {
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003abc:	687b      	ldr	r3, [r7, #4]
 8003abe:	2200      	movs	r2, #0
 8003ac0:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
        hi2c->MemTxCpltCallback(hi2c);
#else
        HAL_I2C_MemTxCpltCallback(hi2c);
 8003ac4:	6878      	ldr	r0, [r7, #4]
 8003ac6:	f023 ff45 	bl	8027954 <HAL_I2C_MemTxCpltCallback>
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 8003aca:	e03b      	b.n	8003b44 <I2C_MasterTransmit_TXE+0x130>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
      }
      else
      {
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003acc:	687b      	ldr	r3, [r7, #4]
 8003ace:	2200      	movs	r2, #0
 8003ad0:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
        hi2c->MasterTxCpltCallback(hi2c);
#else
        HAL_I2C_MasterTxCpltCallback(hi2c);
 8003ad4:	6878      	ldr	r0, [r7, #4]
 8003ad6:	f023 ff29 	bl	802792c <HAL_I2C_MasterTxCpltCallback>
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 8003ada:	e033      	b.n	8003b44 <I2C_MasterTransmit_TXE+0x130>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
      }
    }
  }
  else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
 8003adc:	7bfb      	ldrb	r3, [r7, #15]
 8003ade:	2b21      	cmp	r3, #33	; 0x21
 8003ae0:	d005      	beq.n	8003aee <I2C_MasterTransmit_TXE+0xda>
 8003ae2:	7bbb      	ldrb	r3, [r7, #14]
 8003ae4:	2b40      	cmp	r3, #64	; 0x40
 8003ae6:	d12d      	bne.n	8003b44 <I2C_MasterTransmit_TXE+0x130>
           ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
 8003ae8:	7bfb      	ldrb	r3, [r7, #15]
 8003aea:	2b22      	cmp	r3, #34	; 0x22
 8003aec:	d12a      	bne.n	8003b44 <I2C_MasterTransmit_TXE+0x130>
  {
    if (hi2c->XferCount == 0U)
 8003aee:	687b      	ldr	r3, [r7, #4]
 8003af0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003af2:	b29b      	uxth	r3, r3
 8003af4:	2b00      	cmp	r3, #0
 8003af6:	d108      	bne.n	8003b0a <I2C_MasterTransmit_TXE+0xf6>
    {
      /* Disable BUF interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8003af8:	687b      	ldr	r3, [r7, #4]
 8003afa:	681b      	ldr	r3, [r3, #0]
 8003afc:	685a      	ldr	r2, [r3, #4]
 8003afe:	687b      	ldr	r3, [r7, #4]
 8003b00:	681b      	ldr	r3, [r3, #0]
 8003b02:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003b06:	605a      	str	r2, [r3, #4]
  }
  else
  {
    /* Do nothing */
  }
}
 8003b08:	e01c      	b.n	8003b44 <I2C_MasterTransmit_TXE+0x130>
      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8003b0a:	687b      	ldr	r3, [r7, #4]
 8003b0c:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8003b10:	b2db      	uxtb	r3, r3
 8003b12:	2b40      	cmp	r3, #64	; 0x40
 8003b14:	d103      	bne.n	8003b1e <I2C_MasterTransmit_TXE+0x10a>
        I2C_MemoryTransmit_TXE_BTF(hi2c);
 8003b16:	6878      	ldr	r0, [r7, #4]
 8003b18:	f000 f880 	bl	8003c1c <I2C_MemoryTransmit_TXE_BTF>
}
 8003b1c:	e012      	b.n	8003b44 <I2C_MasterTransmit_TXE+0x130>
        hi2c->Instance->DR = *hi2c->pBuffPtr;
 8003b1e:	687b      	ldr	r3, [r7, #4]
 8003b20:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003b22:	781a      	ldrb	r2, [r3, #0]
 8003b24:	687b      	ldr	r3, [r7, #4]
 8003b26:	681b      	ldr	r3, [r3, #0]
 8003b28:	611a      	str	r2, [r3, #16]
        hi2c->pBuffPtr++;
 8003b2a:	687b      	ldr	r3, [r7, #4]
 8003b2c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003b2e:	1c5a      	adds	r2, r3, #1
 8003b30:	687b      	ldr	r3, [r7, #4]
 8003b32:	625a      	str	r2, [r3, #36]	; 0x24
        hi2c->XferCount--;
 8003b34:	687b      	ldr	r3, [r7, #4]
 8003b36:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003b38:	b29b      	uxth	r3, r3
 8003b3a:	3b01      	subs	r3, #1
 8003b3c:	b29a      	uxth	r2, r3
 8003b3e:	687b      	ldr	r3, [r7, #4]
 8003b40:	855a      	strh	r2, [r3, #42]	; 0x2a
}
 8003b42:	e7ff      	b.n	8003b44 <I2C_MasterTransmit_TXE+0x130>
 8003b44:	bf00      	nop
 8003b46:	3710      	adds	r7, #16
 8003b48:	46bd      	mov	sp, r7
 8003b4a:	bd80      	pop	{r7, pc}

08003b4c <I2C_MasterTransmit_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
{
 8003b4c:	b580      	push	{r7, lr}
 8003b4e:	b084      	sub	sp, #16
 8003b50:	af00      	add	r7, sp, #0
 8003b52:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8003b54:	687b      	ldr	r3, [r7, #4]
 8003b56:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003b58:	60fb      	str	r3, [r7, #12]

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8003b5a:	687b      	ldr	r3, [r7, #4]
 8003b5c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8003b60:	b2db      	uxtb	r3, r3
 8003b62:	2b21      	cmp	r3, #33	; 0x21
 8003b64:	d156      	bne.n	8003c14 <I2C_MasterTransmit_BTF+0xc8>
  {
    if (hi2c->XferCount != 0U)
 8003b66:	687b      	ldr	r3, [r7, #4]
 8003b68:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003b6a:	b29b      	uxth	r3, r3
 8003b6c:	2b00      	cmp	r3, #0
 8003b6e:	d012      	beq.n	8003b96 <I2C_MasterTransmit_BTF+0x4a>
    {
      /* Write data to DR */
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 8003b70:	687b      	ldr	r3, [r7, #4]
 8003b72:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003b74:	781a      	ldrb	r2, [r3, #0]
 8003b76:	687b      	ldr	r3, [r7, #4]
 8003b78:	681b      	ldr	r3, [r3, #0]
 8003b7a:	611a      	str	r2, [r3, #16]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8003b7c:	687b      	ldr	r3, [r7, #4]
 8003b7e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003b80:	1c5a      	adds	r2, r3, #1
 8003b82:	687b      	ldr	r3, [r7, #4]
 8003b84:	625a      	str	r2, [r3, #36]	; 0x24

      /* Update counter */
      hi2c->XferCount--;
 8003b86:	687b      	ldr	r3, [r7, #4]
 8003b88:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003b8a:	b29b      	uxth	r3, r3
 8003b8c:	3b01      	subs	r3, #1
 8003b8e:	b29a      	uxth	r2, r3
 8003b90:	687b      	ldr	r3, [r7, #4]
 8003b92:	855a      	strh	r2, [r3, #42]	; 0x2a
  }
  else
  {
    /* Do nothing */
  }
}
 8003b94:	e03e      	b.n	8003c14 <I2C_MasterTransmit_BTF+0xc8>
      if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 8003b96:	68fb      	ldr	r3, [r7, #12]
 8003b98:	2b08      	cmp	r3, #8
 8003b9a:	d01d      	beq.n	8003bd8 <I2C_MasterTransmit_BTF+0x8c>
 8003b9c:	68fb      	ldr	r3, [r7, #12]
 8003b9e:	2b20      	cmp	r3, #32
 8003ba0:	d01a      	beq.n	8003bd8 <I2C_MasterTransmit_BTF+0x8c>
 8003ba2:	68fb      	ldr	r3, [r7, #12]
 8003ba4:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 8003ba8:	d016      	beq.n	8003bd8 <I2C_MasterTransmit_BTF+0x8c>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8003baa:	687b      	ldr	r3, [r7, #4]
 8003bac:	681b      	ldr	r3, [r3, #0]
 8003bae:	685a      	ldr	r2, [r3, #4]
 8003bb0:	687b      	ldr	r3, [r7, #4]
 8003bb2:	681b      	ldr	r3, [r3, #0]
 8003bb4:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8003bb8:	605a      	str	r2, [r3, #4]
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8003bba:	687b      	ldr	r3, [r7, #4]
 8003bbc:	2211      	movs	r2, #17
 8003bbe:	631a      	str	r2, [r3, #48]	; 0x30
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003bc0:	687b      	ldr	r3, [r7, #4]
 8003bc2:	2200      	movs	r2, #0
 8003bc4:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
        hi2c->State = HAL_I2C_STATE_READY;
 8003bc8:	687b      	ldr	r3, [r7, #4]
 8003bca:	2220      	movs	r2, #32
 8003bcc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        HAL_I2C_MasterTxCpltCallback(hi2c);
 8003bd0:	6878      	ldr	r0, [r7, #4]
 8003bd2:	f023 feab 	bl	802792c <HAL_I2C_MasterTxCpltCallback>
}
 8003bd6:	e01d      	b.n	8003c14 <I2C_MasterTransmit_BTF+0xc8>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8003bd8:	687b      	ldr	r3, [r7, #4]
 8003bda:	681b      	ldr	r3, [r3, #0]
 8003bdc:	685a      	ldr	r2, [r3, #4]
 8003bde:	687b      	ldr	r3, [r7, #4]
 8003be0:	681b      	ldr	r3, [r3, #0]
 8003be2:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8003be6:	605a      	str	r2, [r3, #4]
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8003be8:	687b      	ldr	r3, [r7, #4]
 8003bea:	681b      	ldr	r3, [r3, #0]
 8003bec:	681a      	ldr	r2, [r3, #0]
 8003bee:	687b      	ldr	r3, [r7, #4]
 8003bf0:	681b      	ldr	r3, [r3, #0]
 8003bf2:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8003bf6:	601a      	str	r2, [r3, #0]
        hi2c->PreviousState = I2C_STATE_NONE;
 8003bf8:	687b      	ldr	r3, [r7, #4]
 8003bfa:	2200      	movs	r2, #0
 8003bfc:	631a      	str	r2, [r3, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 8003bfe:	687b      	ldr	r3, [r7, #4]
 8003c00:	2220      	movs	r2, #32
 8003c02:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003c06:	687b      	ldr	r3, [r7, #4]
 8003c08:	2200      	movs	r2, #0
 8003c0a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
        HAL_I2C_MasterTxCpltCallback(hi2c);
 8003c0e:	6878      	ldr	r0, [r7, #4]
 8003c10:	f023 fe8c 	bl	802792c <HAL_I2C_MasterTxCpltCallback>
}
 8003c14:	bf00      	nop
 8003c16:	3710      	adds	r7, #16
 8003c18:	46bd      	mov	sp, r7
 8003c1a:	bd80      	pop	{r7, pc}

08003c1c <I2C_MemoryTransmit_TXE_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MemoryTransmit_TXE_BTF(I2C_HandleTypeDef *hi2c)
{
 8003c1c:	b580      	push	{r7, lr}
 8003c1e:	b084      	sub	sp, #16
 8003c20:	af00      	add	r7, sp, #0
 8003c22:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8003c24:	687b      	ldr	r3, [r7, #4]
 8003c26:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8003c2a:	73fb      	strb	r3, [r7, #15]

  if (hi2c->EventCount == 0U)
 8003c2c:	687b      	ldr	r3, [r7, #4]
 8003c2e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003c30:	2b00      	cmp	r3, #0
 8003c32:	d11d      	bne.n	8003c70 <I2C_MemoryTransmit_TXE_BTF+0x54>
  {
    /* If Memory address size is 8Bit */
    if (hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
 8003c34:	687b      	ldr	r3, [r7, #4]
 8003c36:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003c38:	2b01      	cmp	r3, #1
 8003c3a:	d10b      	bne.n	8003c54 <I2C_MemoryTransmit_TXE_BTF+0x38>
    {
      /* Send Memory Address */
      hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8003c3c:	687b      	ldr	r3, [r7, #4]
 8003c3e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8003c40:	b2da      	uxtb	r2, r3
 8003c42:	687b      	ldr	r3, [r7, #4]
 8003c44:	681b      	ldr	r3, [r3, #0]
 8003c46:	611a      	str	r2, [r3, #16]

      hi2c->EventCount += 2U;
 8003c48:	687b      	ldr	r3, [r7, #4]
 8003c4a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003c4c:	1c9a      	adds	r2, r3, #2
 8003c4e:	687b      	ldr	r3, [r7, #4]
 8003c50:	651a      	str	r2, [r3, #80]	; 0x50
  }
  else
  {
    /* Do nothing */
  }
}
 8003c52:	e06e      	b.n	8003d32 <I2C_MemoryTransmit_TXE_BTF+0x116>
      hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
 8003c54:	687b      	ldr	r3, [r7, #4]
 8003c56:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8003c58:	b29b      	uxth	r3, r3
 8003c5a:	121b      	asrs	r3, r3, #8
 8003c5c:	b2da      	uxtb	r2, r3
 8003c5e:	687b      	ldr	r3, [r7, #4]
 8003c60:	681b      	ldr	r3, [r3, #0]
 8003c62:	611a      	str	r2, [r3, #16]
      hi2c->EventCount++;
 8003c64:	687b      	ldr	r3, [r7, #4]
 8003c66:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003c68:	1c5a      	adds	r2, r3, #1
 8003c6a:	687b      	ldr	r3, [r7, #4]
 8003c6c:	651a      	str	r2, [r3, #80]	; 0x50
}
 8003c6e:	e060      	b.n	8003d32 <I2C_MemoryTransmit_TXE_BTF+0x116>
  else if (hi2c->EventCount == 1U)
 8003c70:	687b      	ldr	r3, [r7, #4]
 8003c72:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003c74:	2b01      	cmp	r3, #1
 8003c76:	d10b      	bne.n	8003c90 <I2C_MemoryTransmit_TXE_BTF+0x74>
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8003c78:	687b      	ldr	r3, [r7, #4]
 8003c7a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8003c7c:	b2da      	uxtb	r2, r3
 8003c7e:	687b      	ldr	r3, [r7, #4]
 8003c80:	681b      	ldr	r3, [r3, #0]
 8003c82:	611a      	str	r2, [r3, #16]
    hi2c->EventCount++;
 8003c84:	687b      	ldr	r3, [r7, #4]
 8003c86:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003c88:	1c5a      	adds	r2, r3, #1
 8003c8a:	687b      	ldr	r3, [r7, #4]
 8003c8c:	651a      	str	r2, [r3, #80]	; 0x50
}
 8003c8e:	e050      	b.n	8003d32 <I2C_MemoryTransmit_TXE_BTF+0x116>
  else if (hi2c->EventCount == 2U)
 8003c90:	687b      	ldr	r3, [r7, #4]
 8003c92:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003c94:	2b02      	cmp	r3, #2
 8003c96:	d14c      	bne.n	8003d32 <I2C_MemoryTransmit_TXE_BTF+0x116>
    if (CurrentState == HAL_I2C_STATE_BUSY_RX)
 8003c98:	7bfb      	ldrb	r3, [r7, #15]
 8003c9a:	2b22      	cmp	r3, #34	; 0x22
 8003c9c:	d108      	bne.n	8003cb0 <I2C_MemoryTransmit_TXE_BTF+0x94>
      hi2c->Instance->CR1 |= I2C_CR1_START;
 8003c9e:	687b      	ldr	r3, [r7, #4]
 8003ca0:	681b      	ldr	r3, [r3, #0]
 8003ca2:	681a      	ldr	r2, [r3, #0]
 8003ca4:	687b      	ldr	r3, [r7, #4]
 8003ca6:	681b      	ldr	r3, [r3, #0]
 8003ca8:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8003cac:	601a      	str	r2, [r3, #0]
}
 8003cae:	e040      	b.n	8003d32 <I2C_MemoryTransmit_TXE_BTF+0x116>
    else if ((hi2c->XferCount > 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 8003cb0:	687b      	ldr	r3, [r7, #4]
 8003cb2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003cb4:	b29b      	uxth	r3, r3
 8003cb6:	2b00      	cmp	r3, #0
 8003cb8:	d015      	beq.n	8003ce6 <I2C_MemoryTransmit_TXE_BTF+0xca>
 8003cba:	7bfb      	ldrb	r3, [r7, #15]
 8003cbc:	2b21      	cmp	r3, #33	; 0x21
 8003cbe:	d112      	bne.n	8003ce6 <I2C_MemoryTransmit_TXE_BTF+0xca>
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 8003cc0:	687b      	ldr	r3, [r7, #4]
 8003cc2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003cc4:	781a      	ldrb	r2, [r3, #0]
 8003cc6:	687b      	ldr	r3, [r7, #4]
 8003cc8:	681b      	ldr	r3, [r3, #0]
 8003cca:	611a      	str	r2, [r3, #16]
      hi2c->pBuffPtr++;
 8003ccc:	687b      	ldr	r3, [r7, #4]
 8003cce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003cd0:	1c5a      	adds	r2, r3, #1
 8003cd2:	687b      	ldr	r3, [r7, #4]
 8003cd4:	625a      	str	r2, [r3, #36]	; 0x24
      hi2c->XferCount--;
 8003cd6:	687b      	ldr	r3, [r7, #4]
 8003cd8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003cda:	b29b      	uxth	r3, r3
 8003cdc:	3b01      	subs	r3, #1
 8003cde:	b29a      	uxth	r2, r3
 8003ce0:	687b      	ldr	r3, [r7, #4]
 8003ce2:	855a      	strh	r2, [r3, #42]	; 0x2a
}
 8003ce4:	e025      	b.n	8003d32 <I2C_MemoryTransmit_TXE_BTF+0x116>
    else if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 8003ce6:	687b      	ldr	r3, [r7, #4]
 8003ce8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003cea:	b29b      	uxth	r3, r3
 8003cec:	2b00      	cmp	r3, #0
 8003cee:	d120      	bne.n	8003d32 <I2C_MemoryTransmit_TXE_BTF+0x116>
 8003cf0:	7bfb      	ldrb	r3, [r7, #15]
 8003cf2:	2b21      	cmp	r3, #33	; 0x21
 8003cf4:	d11d      	bne.n	8003d32 <I2C_MemoryTransmit_TXE_BTF+0x116>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8003cf6:	687b      	ldr	r3, [r7, #4]
 8003cf8:	681b      	ldr	r3, [r3, #0]
 8003cfa:	685a      	ldr	r2, [r3, #4]
 8003cfc:	687b      	ldr	r3, [r7, #4]
 8003cfe:	681b      	ldr	r3, [r3, #0]
 8003d00:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8003d04:	605a      	str	r2, [r3, #4]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8003d06:	687b      	ldr	r3, [r7, #4]
 8003d08:	681b      	ldr	r3, [r3, #0]
 8003d0a:	681a      	ldr	r2, [r3, #0]
 8003d0c:	687b      	ldr	r3, [r7, #4]
 8003d0e:	681b      	ldr	r3, [r3, #0]
 8003d10:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8003d14:	601a      	str	r2, [r3, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 8003d16:	687b      	ldr	r3, [r7, #4]
 8003d18:	2200      	movs	r2, #0
 8003d1a:	631a      	str	r2, [r3, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 8003d1c:	687b      	ldr	r3, [r7, #4]
 8003d1e:	2220      	movs	r2, #32
 8003d20:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8003d24:	687b      	ldr	r3, [r7, #4]
 8003d26:	2200      	movs	r2, #0
 8003d28:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      HAL_I2C_MemTxCpltCallback(hi2c);
 8003d2c:	6878      	ldr	r0, [r7, #4]
 8003d2e:	f023 fe11 	bl	8027954 <HAL_I2C_MemTxCpltCallback>
}
 8003d32:	bf00      	nop
 8003d34:	3710      	adds	r7, #16
 8003d36:	46bd      	mov	sp, r7
 8003d38:	bd80      	pop	{r7, pc}

08003d3a <I2C_MasterReceive_RXNE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
{
 8003d3a:	b580      	push	{r7, lr}
 8003d3c:	b084      	sub	sp, #16
 8003d3e:	af00      	add	r7, sp, #0
 8003d40:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8003d42:	687b      	ldr	r3, [r7, #4]
 8003d44:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8003d48:	b2db      	uxtb	r3, r3
 8003d4a:	2b22      	cmp	r3, #34	; 0x22
 8003d4c:	f040 80a2 	bne.w	8003e94 <I2C_MasterReceive_RXNE+0x15a>
  {
    uint32_t tmp;

    tmp = hi2c->XferCount;
 8003d50:	687b      	ldr	r3, [r7, #4]
 8003d52:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003d54:	b29b      	uxth	r3, r3
 8003d56:	60fb      	str	r3, [r7, #12]
    if (tmp > 3U)
 8003d58:	68fb      	ldr	r3, [r7, #12]
 8003d5a:	2b03      	cmp	r3, #3
 8003d5c:	d921      	bls.n	8003da2 <I2C_MasterReceive_RXNE+0x68>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8003d5e:	687b      	ldr	r3, [r7, #4]
 8003d60:	681b      	ldr	r3, [r3, #0]
 8003d62:	691a      	ldr	r2, [r3, #16]
 8003d64:	687b      	ldr	r3, [r7, #4]
 8003d66:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003d68:	b2d2      	uxtb	r2, r2
 8003d6a:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8003d6c:	687b      	ldr	r3, [r7, #4]
 8003d6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003d70:	1c5a      	adds	r2, r3, #1
 8003d72:	687b      	ldr	r3, [r7, #4]
 8003d74:	625a      	str	r2, [r3, #36]	; 0x24

      /* Update counter */
      hi2c->XferCount--;
 8003d76:	687b      	ldr	r3, [r7, #4]
 8003d78:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003d7a:	b29b      	uxth	r3, r3
 8003d7c:	3b01      	subs	r3, #1
 8003d7e:	b29a      	uxth	r2, r3
 8003d80:	687b      	ldr	r3, [r7, #4]
 8003d82:	855a      	strh	r2, [r3, #42]	; 0x2a

      if (hi2c->XferCount == (uint16_t)3)
 8003d84:	687b      	ldr	r3, [r7, #4]
 8003d86:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003d88:	b29b      	uxth	r3, r3
 8003d8a:	2b03      	cmp	r3, #3
 8003d8c:	f040 8082 	bne.w	8003e94 <I2C_MasterReceive_RXNE+0x15a>
      {
        /* Disable BUF interrupt, this help to treat correctly the last 4 bytes
        on BTF subroutine */
        /* Disable BUF interrupt */
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8003d90:	687b      	ldr	r3, [r7, #4]
 8003d92:	681b      	ldr	r3, [r3, #0]
 8003d94:	685a      	ldr	r2, [r3, #4]
 8003d96:	687b      	ldr	r3, [r7, #4]
 8003d98:	681b      	ldr	r3, [r3, #0]
 8003d9a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003d9e:	605a      	str	r2, [r3, #4]
    else
    {
      /* Do nothing */
    }
  }
}
 8003da0:	e078      	b.n	8003e94 <I2C_MasterReceive_RXNE+0x15a>
    else if ((hi2c->XferOptions != I2C_FIRST_AND_NEXT_FRAME) && ((tmp == 1U) || (tmp == 0U)))
 8003da2:	687b      	ldr	r3, [r7, #4]
 8003da4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003da6:	2b02      	cmp	r3, #2
 8003da8:	d074      	beq.n	8003e94 <I2C_MasterReceive_RXNE+0x15a>
 8003daa:	68fb      	ldr	r3, [r7, #12]
 8003dac:	2b01      	cmp	r3, #1
 8003dae:	d002      	beq.n	8003db6 <I2C_MasterReceive_RXNE+0x7c>
 8003db0:	68fb      	ldr	r3, [r7, #12]
 8003db2:	2b00      	cmp	r3, #0
 8003db4:	d16e      	bne.n	8003e94 <I2C_MasterReceive_RXNE+0x15a>
      if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
 8003db6:	6878      	ldr	r0, [r7, #4]
 8003db8:	f001 f818 	bl	8004dec <I2C_WaitOnSTOPRequestThroughIT>
 8003dbc:	4603      	mov	r3, r0
 8003dbe:	2b00      	cmp	r3, #0
 8003dc0:	d142      	bne.n	8003e48 <I2C_MasterReceive_RXNE+0x10e>
        CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8003dc2:	687b      	ldr	r3, [r7, #4]
 8003dc4:	681b      	ldr	r3, [r3, #0]
 8003dc6:	681a      	ldr	r2, [r3, #0]
 8003dc8:	687b      	ldr	r3, [r7, #4]
 8003dca:	681b      	ldr	r3, [r3, #0]
 8003dcc:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003dd0:	601a      	str	r2, [r3, #0]
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8003dd2:	687b      	ldr	r3, [r7, #4]
 8003dd4:	681b      	ldr	r3, [r3, #0]
 8003dd6:	685a      	ldr	r2, [r3, #4]
 8003dd8:	687b      	ldr	r3, [r7, #4]
 8003dda:	681b      	ldr	r3, [r3, #0]
 8003ddc:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8003de0:	605a      	str	r2, [r3, #4]
        *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8003de2:	687b      	ldr	r3, [r7, #4]
 8003de4:	681b      	ldr	r3, [r3, #0]
 8003de6:	691a      	ldr	r2, [r3, #16]
 8003de8:	687b      	ldr	r3, [r7, #4]
 8003dea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003dec:	b2d2      	uxtb	r2, r2
 8003dee:	701a      	strb	r2, [r3, #0]
        hi2c->pBuffPtr++;
 8003df0:	687b      	ldr	r3, [r7, #4]
 8003df2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003df4:	1c5a      	adds	r2, r3, #1
 8003df6:	687b      	ldr	r3, [r7, #4]
 8003df8:	625a      	str	r2, [r3, #36]	; 0x24
        hi2c->XferCount--;
 8003dfa:	687b      	ldr	r3, [r7, #4]
 8003dfc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003dfe:	b29b      	uxth	r3, r3
 8003e00:	3b01      	subs	r3, #1
 8003e02:	b29a      	uxth	r2, r3
 8003e04:	687b      	ldr	r3, [r7, #4]
 8003e06:	855a      	strh	r2, [r3, #42]	; 0x2a
        hi2c->State = HAL_I2C_STATE_READY;
 8003e08:	687b      	ldr	r3, [r7, #4]
 8003e0a:	2220      	movs	r2, #32
 8003e0c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8003e10:	687b      	ldr	r3, [r7, #4]
 8003e12:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8003e16:	b2db      	uxtb	r3, r3
 8003e18:	2b40      	cmp	r3, #64	; 0x40
 8003e1a:	d10a      	bne.n	8003e32 <I2C_MasterReceive_RXNE+0xf8>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8003e1c:	687b      	ldr	r3, [r7, #4]
 8003e1e:	2200      	movs	r2, #0
 8003e20:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
          hi2c->PreviousState = I2C_STATE_NONE;
 8003e24:	687b      	ldr	r3, [r7, #4]
 8003e26:	2200      	movs	r2, #0
 8003e28:	631a      	str	r2, [r3, #48]	; 0x30
          HAL_I2C_MemRxCpltCallback(hi2c);
 8003e2a:	6878      	ldr	r0, [r7, #4]
 8003e2c:	f023 fd9c 	bl	8027968 <HAL_I2C_MemRxCpltCallback>
}
 8003e30:	e030      	b.n	8003e94 <I2C_MasterReceive_RXNE+0x15a>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8003e32:	687b      	ldr	r3, [r7, #4]
 8003e34:	2200      	movs	r2, #0
 8003e36:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
          hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8003e3a:	687b      	ldr	r3, [r7, #4]
 8003e3c:	2212      	movs	r2, #18
 8003e3e:	631a      	str	r2, [r3, #48]	; 0x30
          HAL_I2C_MasterRxCpltCallback(hi2c);
 8003e40:	6878      	ldr	r0, [r7, #4]
 8003e42:	f023 fd7d 	bl	8027940 <HAL_I2C_MasterRxCpltCallback>
}
 8003e46:	e025      	b.n	8003e94 <I2C_MasterReceive_RXNE+0x15a>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8003e48:	687b      	ldr	r3, [r7, #4]
 8003e4a:	681b      	ldr	r3, [r3, #0]
 8003e4c:	685a      	ldr	r2, [r3, #4]
 8003e4e:	687b      	ldr	r3, [r7, #4]
 8003e50:	681b      	ldr	r3, [r3, #0]
 8003e52:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8003e56:	605a      	str	r2, [r3, #4]
        *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8003e58:	687b      	ldr	r3, [r7, #4]
 8003e5a:	681b      	ldr	r3, [r3, #0]
 8003e5c:	691a      	ldr	r2, [r3, #16]
 8003e5e:	687b      	ldr	r3, [r7, #4]
 8003e60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003e62:	b2d2      	uxtb	r2, r2
 8003e64:	701a      	strb	r2, [r3, #0]
        hi2c->pBuffPtr++;
 8003e66:	687b      	ldr	r3, [r7, #4]
 8003e68:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003e6a:	1c5a      	adds	r2, r3, #1
 8003e6c:	687b      	ldr	r3, [r7, #4]
 8003e6e:	625a      	str	r2, [r3, #36]	; 0x24
        hi2c->XferCount--;
 8003e70:	687b      	ldr	r3, [r7, #4]
 8003e72:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003e74:	b29b      	uxth	r3, r3
 8003e76:	3b01      	subs	r3, #1
 8003e78:	b29a      	uxth	r2, r3
 8003e7a:	687b      	ldr	r3, [r7, #4]
 8003e7c:	855a      	strh	r2, [r3, #42]	; 0x2a
        hi2c->State = HAL_I2C_STATE_READY;
 8003e7e:	687b      	ldr	r3, [r7, #4]
 8003e80:	2220      	movs	r2, #32
 8003e82:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003e86:	687b      	ldr	r3, [r7, #4]
 8003e88:	2200      	movs	r2, #0
 8003e8a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
        HAL_I2C_ErrorCallback(hi2c);
 8003e8e:	6878      	ldr	r0, [r7, #4]
 8003e90:	f023 fd74 	bl	802797c <HAL_I2C_ErrorCallback>
}
 8003e94:	bf00      	nop
 8003e96:	3710      	adds	r7, #16
 8003e98:	46bd      	mov	sp, r7
 8003e9a:	bd80      	pop	{r7, pc}

08003e9c <I2C_MasterReceive_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
{
 8003e9c:	b580      	push	{r7, lr}
 8003e9e:	b084      	sub	sp, #16
 8003ea0:	af00      	add	r7, sp, #0
 8003ea2:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8003ea4:	687b      	ldr	r3, [r7, #4]
 8003ea6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003ea8:	60fb      	str	r3, [r7, #12]

  if (hi2c->XferCount == 4U)
 8003eaa:	687b      	ldr	r3, [r7, #4]
 8003eac:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003eae:	b29b      	uxth	r3, r3
 8003eb0:	2b04      	cmp	r3, #4
 8003eb2:	d11b      	bne.n	8003eec <I2C_MasterReceive_BTF+0x50>
  {
    /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
       on BTF subroutine if there is a reception delay between N-1 and N byte */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8003eb4:	687b      	ldr	r3, [r7, #4]
 8003eb6:	681b      	ldr	r3, [r3, #0]
 8003eb8:	685a      	ldr	r2, [r3, #4]
 8003eba:	687b      	ldr	r3, [r7, #4]
 8003ebc:	681b      	ldr	r3, [r3, #0]
 8003ebe:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003ec2:	605a      	str	r2, [r3, #4]

    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8003ec4:	687b      	ldr	r3, [r7, #4]
 8003ec6:	681b      	ldr	r3, [r3, #0]
 8003ec8:	691a      	ldr	r2, [r3, #16]
 8003eca:	687b      	ldr	r3, [r7, #4]
 8003ecc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003ece:	b2d2      	uxtb	r2, r2
 8003ed0:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8003ed2:	687b      	ldr	r3, [r7, #4]
 8003ed4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003ed6:	1c5a      	adds	r2, r3, #1
 8003ed8:	687b      	ldr	r3, [r7, #4]
 8003eda:	625a      	str	r2, [r3, #36]	; 0x24

    /* Update counter */
    hi2c->XferCount--;
 8003edc:	687b      	ldr	r3, [r7, #4]
 8003ede:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003ee0:	b29b      	uxth	r3, r3
 8003ee2:	3b01      	subs	r3, #1
 8003ee4:	b29a      	uxth	r2, r3
 8003ee6:	687b      	ldr	r3, [r7, #4]
 8003ee8:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->pBuffPtr++;

    /* Update counter */
    hi2c->XferCount--;
  }
}
 8003eea:	e0bd      	b.n	8004068 <I2C_MasterReceive_BTF+0x1cc>
  else if (hi2c->XferCount == 3U)
 8003eec:	687b      	ldr	r3, [r7, #4]
 8003eee:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003ef0:	b29b      	uxth	r3, r3
 8003ef2:	2b03      	cmp	r3, #3
 8003ef4:	d129      	bne.n	8003f4a <I2C_MasterReceive_BTF+0xae>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8003ef6:	687b      	ldr	r3, [r7, #4]
 8003ef8:	681b      	ldr	r3, [r3, #0]
 8003efa:	685a      	ldr	r2, [r3, #4]
 8003efc:	687b      	ldr	r3, [r7, #4]
 8003efe:	681b      	ldr	r3, [r3, #0]
 8003f00:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003f04:	605a      	str	r2, [r3, #4]
    if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME))
 8003f06:	68fb      	ldr	r3, [r7, #12]
 8003f08:	2b04      	cmp	r3, #4
 8003f0a:	d00a      	beq.n	8003f22 <I2C_MasterReceive_BTF+0x86>
 8003f0c:	68fb      	ldr	r3, [r7, #12]
 8003f0e:	2b02      	cmp	r3, #2
 8003f10:	d007      	beq.n	8003f22 <I2C_MasterReceive_BTF+0x86>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8003f12:	687b      	ldr	r3, [r7, #4]
 8003f14:	681b      	ldr	r3, [r3, #0]
 8003f16:	681a      	ldr	r2, [r3, #0]
 8003f18:	687b      	ldr	r3, [r7, #4]
 8003f1a:	681b      	ldr	r3, [r3, #0]
 8003f1c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003f20:	601a      	str	r2, [r3, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8003f22:	687b      	ldr	r3, [r7, #4]
 8003f24:	681b      	ldr	r3, [r3, #0]
 8003f26:	691a      	ldr	r2, [r3, #16]
 8003f28:	687b      	ldr	r3, [r7, #4]
 8003f2a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003f2c:	b2d2      	uxtb	r2, r2
 8003f2e:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8003f30:	687b      	ldr	r3, [r7, #4]
 8003f32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003f34:	1c5a      	adds	r2, r3, #1
 8003f36:	687b      	ldr	r3, [r7, #4]
 8003f38:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount--;
 8003f3a:	687b      	ldr	r3, [r7, #4]
 8003f3c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003f3e:	b29b      	uxth	r3, r3
 8003f40:	3b01      	subs	r3, #1
 8003f42:	b29a      	uxth	r2, r3
 8003f44:	687b      	ldr	r3, [r7, #4]
 8003f46:	855a      	strh	r2, [r3, #42]	; 0x2a
}
 8003f48:	e08e      	b.n	8004068 <I2C_MasterReceive_BTF+0x1cc>
  else if (hi2c->XferCount == 2U)
 8003f4a:	687b      	ldr	r3, [r7, #4]
 8003f4c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003f4e:	b29b      	uxth	r3, r3
 8003f50:	2b02      	cmp	r3, #2
 8003f52:	d176      	bne.n	8004042 <I2C_MasterReceive_BTF+0x1a6>
    if ((CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP))
 8003f54:	68fb      	ldr	r3, [r7, #12]
 8003f56:	2b01      	cmp	r3, #1
 8003f58:	d002      	beq.n	8003f60 <I2C_MasterReceive_BTF+0xc4>
 8003f5a:	68fb      	ldr	r3, [r7, #12]
 8003f5c:	2b10      	cmp	r3, #16
 8003f5e:	d108      	bne.n	8003f72 <I2C_MasterReceive_BTF+0xd6>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8003f60:	687b      	ldr	r3, [r7, #4]
 8003f62:	681b      	ldr	r3, [r3, #0]
 8003f64:	681a      	ldr	r2, [r3, #0]
 8003f66:	687b      	ldr	r3, [r7, #4]
 8003f68:	681b      	ldr	r3, [r3, #0]
 8003f6a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003f6e:	601a      	str	r2, [r3, #0]
 8003f70:	e019      	b.n	8003fa6 <I2C_MasterReceive_BTF+0x10a>
    else if ((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_NEXT_FRAME))
 8003f72:	68fb      	ldr	r3, [r7, #12]
 8003f74:	2b04      	cmp	r3, #4
 8003f76:	d002      	beq.n	8003f7e <I2C_MasterReceive_BTF+0xe2>
 8003f78:	68fb      	ldr	r3, [r7, #12]
 8003f7a:	2b02      	cmp	r3, #2
 8003f7c:	d108      	bne.n	8003f90 <I2C_MasterReceive_BTF+0xf4>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8003f7e:	687b      	ldr	r3, [r7, #4]
 8003f80:	681b      	ldr	r3, [r3, #0]
 8003f82:	681a      	ldr	r2, [r3, #0]
 8003f84:	687b      	ldr	r3, [r7, #4]
 8003f86:	681b      	ldr	r3, [r3, #0]
 8003f88:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8003f8c:	601a      	str	r2, [r3, #0]
 8003f8e:	e00a      	b.n	8003fa6 <I2C_MasterReceive_BTF+0x10a>
    else if (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP)
 8003f90:	68fb      	ldr	r3, [r7, #12]
 8003f92:	2b10      	cmp	r3, #16
 8003f94:	d007      	beq.n	8003fa6 <I2C_MasterReceive_BTF+0x10a>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8003f96:	687b      	ldr	r3, [r7, #4]
 8003f98:	681b      	ldr	r3, [r3, #0]
 8003f9a:	681a      	ldr	r2, [r3, #0]
 8003f9c:	687b      	ldr	r3, [r7, #4]
 8003f9e:	681b      	ldr	r3, [r3, #0]
 8003fa0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8003fa4:	601a      	str	r2, [r3, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8003fa6:	687b      	ldr	r3, [r7, #4]
 8003fa8:	681b      	ldr	r3, [r3, #0]
 8003faa:	691a      	ldr	r2, [r3, #16]
 8003fac:	687b      	ldr	r3, [r7, #4]
 8003fae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003fb0:	b2d2      	uxtb	r2, r2
 8003fb2:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8003fb4:	687b      	ldr	r3, [r7, #4]
 8003fb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003fb8:	1c5a      	adds	r2, r3, #1
 8003fba:	687b      	ldr	r3, [r7, #4]
 8003fbc:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount--;
 8003fbe:	687b      	ldr	r3, [r7, #4]
 8003fc0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003fc2:	b29b      	uxth	r3, r3
 8003fc4:	3b01      	subs	r3, #1
 8003fc6:	b29a      	uxth	r2, r3
 8003fc8:	687b      	ldr	r3, [r7, #4]
 8003fca:	855a      	strh	r2, [r3, #42]	; 0x2a
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8003fcc:	687b      	ldr	r3, [r7, #4]
 8003fce:	681b      	ldr	r3, [r3, #0]
 8003fd0:	691a      	ldr	r2, [r3, #16]
 8003fd2:	687b      	ldr	r3, [r7, #4]
 8003fd4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003fd6:	b2d2      	uxtb	r2, r2
 8003fd8:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8003fda:	687b      	ldr	r3, [r7, #4]
 8003fdc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003fde:	1c5a      	adds	r2, r3, #1
 8003fe0:	687b      	ldr	r3, [r7, #4]
 8003fe2:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount--;
 8003fe4:	687b      	ldr	r3, [r7, #4]
 8003fe6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003fe8:	b29b      	uxth	r3, r3
 8003fea:	3b01      	subs	r3, #1
 8003fec:	b29a      	uxth	r2, r3
 8003fee:	687b      	ldr	r3, [r7, #4]
 8003ff0:	855a      	strh	r2, [r3, #42]	; 0x2a
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
 8003ff2:	687b      	ldr	r3, [r7, #4]
 8003ff4:	681b      	ldr	r3, [r3, #0]
 8003ff6:	685a      	ldr	r2, [r3, #4]
 8003ff8:	687b      	ldr	r3, [r7, #4]
 8003ffa:	681b      	ldr	r3, [r3, #0]
 8003ffc:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8004000:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8004002:	687b      	ldr	r3, [r7, #4]
 8004004:	2220      	movs	r2, #32
 8004006:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 800400a:	687b      	ldr	r3, [r7, #4]
 800400c:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8004010:	b2db      	uxtb	r3, r3
 8004012:	2b40      	cmp	r3, #64	; 0x40
 8004014:	d10a      	bne.n	800402c <I2C_MasterReceive_BTF+0x190>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8004016:	687b      	ldr	r3, [r7, #4]
 8004018:	2200      	movs	r2, #0
 800401a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      hi2c->PreviousState = I2C_STATE_NONE;
 800401e:	687b      	ldr	r3, [r7, #4]
 8004020:	2200      	movs	r2, #0
 8004022:	631a      	str	r2, [r3, #48]	; 0x30
      HAL_I2C_MemRxCpltCallback(hi2c);
 8004024:	6878      	ldr	r0, [r7, #4]
 8004026:	f023 fc9f 	bl	8027968 <HAL_I2C_MemRxCpltCallback>
}
 800402a:	e01d      	b.n	8004068 <I2C_MasterReceive_BTF+0x1cc>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800402c:	687b      	ldr	r3, [r7, #4]
 800402e:	2200      	movs	r2, #0
 8004030:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8004034:	687b      	ldr	r3, [r7, #4]
 8004036:	2212      	movs	r2, #18
 8004038:	631a      	str	r2, [r3, #48]	; 0x30
      HAL_I2C_MasterRxCpltCallback(hi2c);
 800403a:	6878      	ldr	r0, [r7, #4]
 800403c:	f023 fc80 	bl	8027940 <HAL_I2C_MasterRxCpltCallback>
}
 8004040:	e012      	b.n	8004068 <I2C_MasterReceive_BTF+0x1cc>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8004042:	687b      	ldr	r3, [r7, #4]
 8004044:	681b      	ldr	r3, [r3, #0]
 8004046:	691a      	ldr	r2, [r3, #16]
 8004048:	687b      	ldr	r3, [r7, #4]
 800404a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800404c:	b2d2      	uxtb	r2, r2
 800404e:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8004050:	687b      	ldr	r3, [r7, #4]
 8004052:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004054:	1c5a      	adds	r2, r3, #1
 8004056:	687b      	ldr	r3, [r7, #4]
 8004058:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount--;
 800405a:	687b      	ldr	r3, [r7, #4]
 800405c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800405e:	b29b      	uxth	r3, r3
 8004060:	3b01      	subs	r3, #1
 8004062:	b29a      	uxth	r2, r3
 8004064:	687b      	ldr	r3, [r7, #4]
 8004066:	855a      	strh	r2, [r3, #42]	; 0x2a
}
 8004068:	bf00      	nop
 800406a:	3710      	adds	r7, #16
 800406c:	46bd      	mov	sp, r7
 800406e:	bd80      	pop	{r7, pc}

08004070 <I2C_Master_SB>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_SB(I2C_HandleTypeDef *hi2c)
{
 8004070:	b480      	push	{r7}
 8004072:	b083      	sub	sp, #12
 8004074:	af00      	add	r7, sp, #0
 8004076:	6078      	str	r0, [r7, #4]
  if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8004078:	687b      	ldr	r3, [r7, #4]
 800407a:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 800407e:	b2db      	uxtb	r3, r3
 8004080:	2b40      	cmp	r3, #64	; 0x40
 8004082:	d117      	bne.n	80040b4 <I2C_Master_SB+0x44>
  {
    if (hi2c->EventCount == 0U)
 8004084:	687b      	ldr	r3, [r7, #4]
 8004086:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004088:	2b00      	cmp	r3, #0
 800408a:	d109      	bne.n	80040a0 <I2C_Master_SB+0x30>
    {
      /* Send slave address */
      hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 800408c:	687b      	ldr	r3, [r7, #4]
 800408e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004090:	b2db      	uxtb	r3, r3
 8004092:	461a      	mov	r2, r3
 8004094:	687b      	ldr	r3, [r7, #4]
 8004096:	681b      	ldr	r3, [r3, #0]
 8004098:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 800409c:	611a      	str	r2, [r3, #16]
      {
        /* Do nothing */
      }
    }
  }
}
 800409e:	e067      	b.n	8004170 <I2C_Master_SB+0x100>
      hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 80040a0:	687b      	ldr	r3, [r7, #4]
 80040a2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80040a4:	b2db      	uxtb	r3, r3
 80040a6:	f043 0301 	orr.w	r3, r3, #1
 80040aa:	b2da      	uxtb	r2, r3
 80040ac:	687b      	ldr	r3, [r7, #4]
 80040ae:	681b      	ldr	r3, [r3, #0]
 80040b0:	611a      	str	r2, [r3, #16]
}
 80040b2:	e05d      	b.n	8004170 <I2C_Master_SB+0x100>
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80040b4:	687b      	ldr	r3, [r7, #4]
 80040b6:	691b      	ldr	r3, [r3, #16]
 80040b8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80040bc:	d133      	bne.n	8004126 <I2C_Master_SB+0xb6>
      if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 80040be:	687b      	ldr	r3, [r7, #4]
 80040c0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80040c4:	b2db      	uxtb	r3, r3
 80040c6:	2b21      	cmp	r3, #33	; 0x21
 80040c8:	d109      	bne.n	80040de <I2C_Master_SB+0x6e>
        hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 80040ca:	687b      	ldr	r3, [r7, #4]
 80040cc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80040ce:	b2db      	uxtb	r3, r3
 80040d0:	461a      	mov	r2, r3
 80040d2:	687b      	ldr	r3, [r7, #4]
 80040d4:	681b      	ldr	r3, [r3, #0]
 80040d6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 80040da:	611a      	str	r2, [r3, #16]
 80040dc:	e008      	b.n	80040f0 <I2C_Master_SB+0x80>
        hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 80040de:	687b      	ldr	r3, [r7, #4]
 80040e0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80040e2:	b2db      	uxtb	r3, r3
 80040e4:	f043 0301 	orr.w	r3, r3, #1
 80040e8:	b2da      	uxtb	r2, r3
 80040ea:	687b      	ldr	r3, [r7, #4]
 80040ec:	681b      	ldr	r3, [r3, #0]
 80040ee:	611a      	str	r2, [r3, #16]
      if (((hi2c->hdmatx != NULL) && (hi2c->hdmatx->XferCpltCallback != NULL))
 80040f0:	687b      	ldr	r3, [r7, #4]
 80040f2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80040f4:	2b00      	cmp	r3, #0
 80040f6:	d004      	beq.n	8004102 <I2C_Master_SB+0x92>
 80040f8:	687b      	ldr	r3, [r7, #4]
 80040fa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80040fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80040fe:	2b00      	cmp	r3, #0
 8004100:	d108      	bne.n	8004114 <I2C_Master_SB+0xa4>
          || ((hi2c->hdmarx != NULL) && (hi2c->hdmarx->XferCpltCallback != NULL)))
 8004102:	687b      	ldr	r3, [r7, #4]
 8004104:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004106:	2b00      	cmp	r3, #0
 8004108:	d032      	beq.n	8004170 <I2C_Master_SB+0x100>
 800410a:	687b      	ldr	r3, [r7, #4]
 800410c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800410e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004110:	2b00      	cmp	r3, #0
 8004112:	d02d      	beq.n	8004170 <I2C_Master_SB+0x100>
        SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 8004114:	687b      	ldr	r3, [r7, #4]
 8004116:	681b      	ldr	r3, [r3, #0]
 8004118:	685a      	ldr	r2, [r3, #4]
 800411a:	687b      	ldr	r3, [r7, #4]
 800411c:	681b      	ldr	r3, [r3, #0]
 800411e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8004122:	605a      	str	r2, [r3, #4]
}
 8004124:	e024      	b.n	8004170 <I2C_Master_SB+0x100>
      if (hi2c->EventCount == 0U)
 8004126:	687b      	ldr	r3, [r7, #4]
 8004128:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800412a:	2b00      	cmp	r3, #0
 800412c:	d10e      	bne.n	800414c <I2C_Master_SB+0xdc>
        hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
 800412e:	687b      	ldr	r3, [r7, #4]
 8004130:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004132:	b29b      	uxth	r3, r3
 8004134:	11db      	asrs	r3, r3, #7
 8004136:	b2db      	uxtb	r3, r3
 8004138:	f003 0306 	and.w	r3, r3, #6
 800413c:	b2db      	uxtb	r3, r3
 800413e:	f063 030f 	orn	r3, r3, #15
 8004142:	b2da      	uxtb	r2, r3
 8004144:	687b      	ldr	r3, [r7, #4]
 8004146:	681b      	ldr	r3, [r3, #0]
 8004148:	611a      	str	r2, [r3, #16]
}
 800414a:	e011      	b.n	8004170 <I2C_Master_SB+0x100>
      else if (hi2c->EventCount == 1U)
 800414c:	687b      	ldr	r3, [r7, #4]
 800414e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004150:	2b01      	cmp	r3, #1
 8004152:	d10d      	bne.n	8004170 <I2C_Master_SB+0x100>
        hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
 8004154:	687b      	ldr	r3, [r7, #4]
 8004156:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004158:	b29b      	uxth	r3, r3
 800415a:	11db      	asrs	r3, r3, #7
 800415c:	b2db      	uxtb	r3, r3
 800415e:	f003 0306 	and.w	r3, r3, #6
 8004162:	b2db      	uxtb	r3, r3
 8004164:	f063 030e 	orn	r3, r3, #14
 8004168:	b2da      	uxtb	r2, r3
 800416a:	687b      	ldr	r3, [r7, #4]
 800416c:	681b      	ldr	r3, [r3, #0]
 800416e:	611a      	str	r2, [r3, #16]
}
 8004170:	bf00      	nop
 8004172:	370c      	adds	r7, #12
 8004174:	46bd      	mov	sp, r7
 8004176:	f85d 7b04 	ldr.w	r7, [sp], #4
 800417a:	4770      	bx	lr

0800417c <I2C_Master_ADD10>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
{
 800417c:	b480      	push	{r7}
 800417e:	b083      	sub	sp, #12
 8004180:	af00      	add	r7, sp, #0
 8004182:	6078      	str	r0, [r7, #4]
  /* Send slave address */
  hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
 8004184:	687b      	ldr	r3, [r7, #4]
 8004186:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004188:	b2da      	uxtb	r2, r3
 800418a:	687b      	ldr	r3, [r7, #4]
 800418c:	681b      	ldr	r3, [r3, #0]
 800418e:	611a      	str	r2, [r3, #16]

  if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
 8004190:	687b      	ldr	r3, [r7, #4]
 8004192:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004194:	2b00      	cmp	r3, #0
 8004196:	d103      	bne.n	80041a0 <I2C_Master_ADD10+0x24>
 8004198:	687b      	ldr	r3, [r7, #4]
 800419a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800419c:	2b00      	cmp	r3, #0
 800419e:	d011      	beq.n	80041c4 <I2C_Master_ADD10+0x48>
  {
    if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
 80041a0:	687b      	ldr	r3, [r7, #4]
 80041a2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80041a4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80041a6:	2b00      	cmp	r3, #0
 80041a8:	d104      	bne.n	80041b4 <I2C_Master_ADD10+0x38>
 80041aa:	687b      	ldr	r3, [r7, #4]
 80041ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80041ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80041b0:	2b00      	cmp	r3, #0
 80041b2:	d007      	beq.n	80041c4 <I2C_Master_ADD10+0x48>
    {
      /* Enable DMA Request */
      SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 80041b4:	687b      	ldr	r3, [r7, #4]
 80041b6:	681b      	ldr	r3, [r3, #0]
 80041b8:	685a      	ldr	r2, [r3, #4]
 80041ba:	687b      	ldr	r3, [r7, #4]
 80041bc:	681b      	ldr	r3, [r3, #0]
 80041be:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80041c2:	605a      	str	r2, [r3, #4]
    }
  }
}
 80041c4:	bf00      	nop
 80041c6:	370c      	adds	r7, #12
 80041c8:	46bd      	mov	sp, r7
 80041ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80041ce:	4770      	bx	lr

080041d0 <I2C_Master_ADDR>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
{
 80041d0:	b480      	push	{r7}
 80041d2:	b091      	sub	sp, #68	; 0x44
 80041d4:	af00      	add	r7, sp, #0
 80041d6:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_ModeTypeDef CurrentMode       = hi2c->Mode;
 80041d8:	687b      	ldr	r3, [r7, #4]
 80041da:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 80041de:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  uint32_t CurrentXferOptions           = hi2c->XferOptions;
 80041e2:	687b      	ldr	r3, [r7, #4]
 80041e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80041e6:	63bb      	str	r3, [r7, #56]	; 0x38
  uint32_t Prev_State                   = hi2c->PreviousState;
 80041e8:	687b      	ldr	r3, [r7, #4]
 80041ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80041ec:	637b      	str	r3, [r7, #52]	; 0x34

  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 80041ee:	687b      	ldr	r3, [r7, #4]
 80041f0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80041f4:	b2db      	uxtb	r3, r3
 80041f6:	2b22      	cmp	r3, #34	; 0x22
 80041f8:	f040 8169 	bne.w	80044ce <I2C_Master_ADDR+0x2fe>
  {
    if ((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
 80041fc:	687b      	ldr	r3, [r7, #4]
 80041fe:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004200:	2b00      	cmp	r3, #0
 8004202:	d10f      	bne.n	8004224 <I2C_Master_ADDR+0x54>
 8004204:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8004208:	2b40      	cmp	r3, #64	; 0x40
 800420a:	d10b      	bne.n	8004224 <I2C_Master_ADDR+0x54>
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800420c:	2300      	movs	r3, #0
 800420e:	633b      	str	r3, [r7, #48]	; 0x30
 8004210:	687b      	ldr	r3, [r7, #4]
 8004212:	681b      	ldr	r3, [r3, #0]
 8004214:	695b      	ldr	r3, [r3, #20]
 8004216:	633b      	str	r3, [r7, #48]	; 0x30
 8004218:	687b      	ldr	r3, [r7, #4]
 800421a:	681b      	ldr	r3, [r3, #0]
 800421c:	699b      	ldr	r3, [r3, #24]
 800421e:	633b      	str	r3, [r7, #48]	; 0x30
 8004220:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004222:	e160      	b.n	80044e6 <I2C_Master_ADDR+0x316>
    }
    else if ((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
 8004224:	687b      	ldr	r3, [r7, #4]
 8004226:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004228:	2b00      	cmp	r3, #0
 800422a:	d11d      	bne.n	8004268 <I2C_Master_ADDR+0x98>
 800422c:	687b      	ldr	r3, [r7, #4]
 800422e:	691b      	ldr	r3, [r3, #16]
 8004230:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 8004234:	d118      	bne.n	8004268 <I2C_Master_ADDR+0x98>
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8004236:	2300      	movs	r3, #0
 8004238:	62fb      	str	r3, [r7, #44]	; 0x2c
 800423a:	687b      	ldr	r3, [r7, #4]
 800423c:	681b      	ldr	r3, [r3, #0]
 800423e:	695b      	ldr	r3, [r3, #20]
 8004240:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004242:	687b      	ldr	r3, [r7, #4]
 8004244:	681b      	ldr	r3, [r3, #0]
 8004246:	699b      	ldr	r3, [r3, #24]
 8004248:	62fb      	str	r3, [r7, #44]	; 0x2c
 800424a:	6afb      	ldr	r3, [r7, #44]	; 0x2c

      /* Generate Restart */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 800424c:	687b      	ldr	r3, [r7, #4]
 800424e:	681b      	ldr	r3, [r3, #0]
 8004250:	681a      	ldr	r2, [r3, #0]
 8004252:	687b      	ldr	r3, [r7, #4]
 8004254:	681b      	ldr	r3, [r3, #0]
 8004256:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800425a:	601a      	str	r2, [r3, #0]

      hi2c->EventCount++;
 800425c:	687b      	ldr	r3, [r7, #4]
 800425e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004260:	1c5a      	adds	r2, r3, #1
 8004262:	687b      	ldr	r3, [r7, #4]
 8004264:	651a      	str	r2, [r3, #80]	; 0x50
 8004266:	e13e      	b.n	80044e6 <I2C_Master_ADDR+0x316>
    }
    else
    {
      if (hi2c->XferCount == 0U)
 8004268:	687b      	ldr	r3, [r7, #4]
 800426a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800426c:	b29b      	uxth	r3, r3
 800426e:	2b00      	cmp	r3, #0
 8004270:	d113      	bne.n	800429a <I2C_Master_ADDR+0xca>
      {
        /* Clear ADDR flag */
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8004272:	2300      	movs	r3, #0
 8004274:	62bb      	str	r3, [r7, #40]	; 0x28
 8004276:	687b      	ldr	r3, [r7, #4]
 8004278:	681b      	ldr	r3, [r3, #0]
 800427a:	695b      	ldr	r3, [r3, #20]
 800427c:	62bb      	str	r3, [r7, #40]	; 0x28
 800427e:	687b      	ldr	r3, [r7, #4]
 8004280:	681b      	ldr	r3, [r3, #0]
 8004282:	699b      	ldr	r3, [r3, #24]
 8004284:	62bb      	str	r3, [r7, #40]	; 0x28
 8004286:	6abb      	ldr	r3, [r7, #40]	; 0x28

        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8004288:	687b      	ldr	r3, [r7, #4]
 800428a:	681b      	ldr	r3, [r3, #0]
 800428c:	681a      	ldr	r2, [r3, #0]
 800428e:	687b      	ldr	r3, [r7, #4]
 8004290:	681b      	ldr	r3, [r3, #0]
 8004292:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8004296:	601a      	str	r2, [r3, #0]
 8004298:	e115      	b.n	80044c6 <I2C_Master_ADDR+0x2f6>
      }
      else if (hi2c->XferCount == 1U)
 800429a:	687b      	ldr	r3, [r7, #4]
 800429c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800429e:	b29b      	uxth	r3, r3
 80042a0:	2b01      	cmp	r3, #1
 80042a2:	f040 808a 	bne.w	80043ba <I2C_Master_ADDR+0x1ea>
      {
        if (CurrentXferOptions == I2C_NO_OPTION_FRAME)
 80042a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80042a8:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 80042ac:	d137      	bne.n	800431e <I2C_Master_ADDR+0x14e>
        {
          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80042ae:	687b      	ldr	r3, [r7, #4]
 80042b0:	681b      	ldr	r3, [r3, #0]
 80042b2:	681a      	ldr	r2, [r3, #0]
 80042b4:	687b      	ldr	r3, [r7, #4]
 80042b6:	681b      	ldr	r3, [r3, #0]
 80042b8:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80042bc:	601a      	str	r2, [r3, #0]

          if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 80042be:	687b      	ldr	r3, [r7, #4]
 80042c0:	681b      	ldr	r3, [r3, #0]
 80042c2:	685b      	ldr	r3, [r3, #4]
 80042c4:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80042c8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80042cc:	d113      	bne.n	80042f6 <I2C_Master_ADDR+0x126>
          {
            /* Disable Acknowledge */
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80042ce:	687b      	ldr	r3, [r7, #4]
 80042d0:	681b      	ldr	r3, [r3, #0]
 80042d2:	681a      	ldr	r2, [r3, #0]
 80042d4:	687b      	ldr	r3, [r7, #4]
 80042d6:	681b      	ldr	r3, [r3, #0]
 80042d8:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80042dc:	601a      	str	r2, [r3, #0]

            /* Clear ADDR flag */
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80042de:	2300      	movs	r3, #0
 80042e0:	627b      	str	r3, [r7, #36]	; 0x24
 80042e2:	687b      	ldr	r3, [r7, #4]
 80042e4:	681b      	ldr	r3, [r3, #0]
 80042e6:	695b      	ldr	r3, [r3, #20]
 80042e8:	627b      	str	r3, [r7, #36]	; 0x24
 80042ea:	687b      	ldr	r3, [r7, #4]
 80042ec:	681b      	ldr	r3, [r3, #0]
 80042ee:	699b      	ldr	r3, [r3, #24]
 80042f0:	627b      	str	r3, [r7, #36]	; 0x24
 80042f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80042f4:	e0e7      	b.n	80044c6 <I2C_Master_ADDR+0x2f6>
          }
          else
          {
            /* Clear ADDR flag */
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80042f6:	2300      	movs	r3, #0
 80042f8:	623b      	str	r3, [r7, #32]
 80042fa:	687b      	ldr	r3, [r7, #4]
 80042fc:	681b      	ldr	r3, [r3, #0]
 80042fe:	695b      	ldr	r3, [r3, #20]
 8004300:	623b      	str	r3, [r7, #32]
 8004302:	687b      	ldr	r3, [r7, #4]
 8004304:	681b      	ldr	r3, [r3, #0]
 8004306:	699b      	ldr	r3, [r3, #24]
 8004308:	623b      	str	r3, [r7, #32]
 800430a:	6a3b      	ldr	r3, [r7, #32]

            /* Generate Stop */
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800430c:	687b      	ldr	r3, [r7, #4]
 800430e:	681b      	ldr	r3, [r3, #0]
 8004310:	681a      	ldr	r2, [r3, #0]
 8004312:	687b      	ldr	r3, [r7, #4]
 8004314:	681b      	ldr	r3, [r3, #0]
 8004316:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800431a:	601a      	str	r2, [r3, #0]
 800431c:	e0d3      	b.n	80044c6 <I2C_Master_ADDR+0x2f6>
          }
        }
        /* Prepare next transfer or stop current transfer */
        else if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
 800431e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004320:	2b08      	cmp	r3, #8
 8004322:	d02e      	beq.n	8004382 <I2C_Master_ADDR+0x1b2>
 8004324:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004326:	2b20      	cmp	r3, #32
 8004328:	d02b      	beq.n	8004382 <I2C_Master_ADDR+0x1b2>
                 && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
 800432a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800432c:	2b12      	cmp	r3, #18
 800432e:	d102      	bne.n	8004336 <I2C_Master_ADDR+0x166>
 8004330:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004332:	2b01      	cmp	r3, #1
 8004334:	d125      	bne.n	8004382 <I2C_Master_ADDR+0x1b2>
        {
          if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 8004336:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004338:	2b04      	cmp	r3, #4
 800433a:	d00e      	beq.n	800435a <I2C_Master_ADDR+0x18a>
 800433c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800433e:	2b02      	cmp	r3, #2
 8004340:	d00b      	beq.n	800435a <I2C_Master_ADDR+0x18a>
 8004342:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004344:	2b10      	cmp	r3, #16
 8004346:	d008      	beq.n	800435a <I2C_Master_ADDR+0x18a>
          {
            /* Disable Acknowledge */
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8004348:	687b      	ldr	r3, [r7, #4]
 800434a:	681b      	ldr	r3, [r3, #0]
 800434c:	681a      	ldr	r2, [r3, #0]
 800434e:	687b      	ldr	r3, [r7, #4]
 8004350:	681b      	ldr	r3, [r3, #0]
 8004352:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8004356:	601a      	str	r2, [r3, #0]
 8004358:	e007      	b.n	800436a <I2C_Master_ADDR+0x19a>
          }
          else
          {
            /* Enable Acknowledge */
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800435a:	687b      	ldr	r3, [r7, #4]
 800435c:	681b      	ldr	r3, [r3, #0]
 800435e:	681a      	ldr	r2, [r3, #0]
 8004360:	687b      	ldr	r3, [r7, #4]
 8004362:	681b      	ldr	r3, [r3, #0]
 8004364:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8004368:	601a      	str	r2, [r3, #0]
          }

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800436a:	2300      	movs	r3, #0
 800436c:	61fb      	str	r3, [r7, #28]
 800436e:	687b      	ldr	r3, [r7, #4]
 8004370:	681b      	ldr	r3, [r3, #0]
 8004372:	695b      	ldr	r3, [r3, #20]
 8004374:	61fb      	str	r3, [r7, #28]
 8004376:	687b      	ldr	r3, [r7, #4]
 8004378:	681b      	ldr	r3, [r3, #0]
 800437a:	699b      	ldr	r3, [r3, #24]
 800437c:	61fb      	str	r3, [r7, #28]
 800437e:	69fb      	ldr	r3, [r7, #28]
 8004380:	e0a1      	b.n	80044c6 <I2C_Master_ADDR+0x2f6>
        }
        else
        {
          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8004382:	687b      	ldr	r3, [r7, #4]
 8004384:	681b      	ldr	r3, [r3, #0]
 8004386:	681a      	ldr	r2, [r3, #0]
 8004388:	687b      	ldr	r3, [r7, #4]
 800438a:	681b      	ldr	r3, [r3, #0]
 800438c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8004390:	601a      	str	r2, [r3, #0]

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8004392:	2300      	movs	r3, #0
 8004394:	61bb      	str	r3, [r7, #24]
 8004396:	687b      	ldr	r3, [r7, #4]
 8004398:	681b      	ldr	r3, [r3, #0]
 800439a:	695b      	ldr	r3, [r3, #20]
 800439c:	61bb      	str	r3, [r7, #24]
 800439e:	687b      	ldr	r3, [r7, #4]
 80043a0:	681b      	ldr	r3, [r3, #0]
 80043a2:	699b      	ldr	r3, [r3, #24]
 80043a4:	61bb      	str	r3, [r7, #24]
 80043a6:	69bb      	ldr	r3, [r7, #24]

          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80043a8:	687b      	ldr	r3, [r7, #4]
 80043aa:	681b      	ldr	r3, [r3, #0]
 80043ac:	681a      	ldr	r2, [r3, #0]
 80043ae:	687b      	ldr	r3, [r7, #4]
 80043b0:	681b      	ldr	r3, [r3, #0]
 80043b2:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80043b6:	601a      	str	r2, [r3, #0]
 80043b8:	e085      	b.n	80044c6 <I2C_Master_ADDR+0x2f6>
        }
      }
      else if (hi2c->XferCount == 2U)
 80043ba:	687b      	ldr	r3, [r7, #4]
 80043bc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80043be:	b29b      	uxth	r3, r3
 80043c0:	2b02      	cmp	r3, #2
 80043c2:	d14d      	bne.n	8004460 <I2C_Master_ADDR+0x290>
      {
        if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 80043c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80043c6:	2b04      	cmp	r3, #4
 80043c8:	d016      	beq.n	80043f8 <I2C_Master_ADDR+0x228>
 80043ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80043cc:	2b02      	cmp	r3, #2
 80043ce:	d013      	beq.n	80043f8 <I2C_Master_ADDR+0x228>
 80043d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80043d2:	2b10      	cmp	r3, #16
 80043d4:	d010      	beq.n	80043f8 <I2C_Master_ADDR+0x228>
        {
          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80043d6:	687b      	ldr	r3, [r7, #4]
 80043d8:	681b      	ldr	r3, [r3, #0]
 80043da:	681a      	ldr	r2, [r3, #0]
 80043dc:	687b      	ldr	r3, [r7, #4]
 80043de:	681b      	ldr	r3, [r3, #0]
 80043e0:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80043e4:	601a      	str	r2, [r3, #0]

          /* Enable Pos */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 80043e6:	687b      	ldr	r3, [r7, #4]
 80043e8:	681b      	ldr	r3, [r3, #0]
 80043ea:	681a      	ldr	r2, [r3, #0]
 80043ec:	687b      	ldr	r3, [r7, #4]
 80043ee:	681b      	ldr	r3, [r3, #0]
 80043f0:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80043f4:	601a      	str	r2, [r3, #0]
 80043f6:	e007      	b.n	8004408 <I2C_Master_ADDR+0x238>
        }
        else
        {
          /* Enable Acknowledge */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80043f8:	687b      	ldr	r3, [r7, #4]
 80043fa:	681b      	ldr	r3, [r3, #0]
 80043fc:	681a      	ldr	r2, [r3, #0]
 80043fe:	687b      	ldr	r3, [r7, #4]
 8004400:	681b      	ldr	r3, [r3, #0]
 8004402:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8004406:	601a      	str	r2, [r3, #0]
        }

        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 8004408:	687b      	ldr	r3, [r7, #4]
 800440a:	681b      	ldr	r3, [r3, #0]
 800440c:	685b      	ldr	r3, [r3, #4]
 800440e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004412:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8004416:	d117      	bne.n	8004448 <I2C_Master_ADDR+0x278>
 8004418:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800441a:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 800441e:	d00b      	beq.n	8004438 <I2C_Master_ADDR+0x268>
 8004420:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004422:	2b01      	cmp	r3, #1
 8004424:	d008      	beq.n	8004438 <I2C_Master_ADDR+0x268>
 8004426:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004428:	2b08      	cmp	r3, #8
 800442a:	d005      	beq.n	8004438 <I2C_Master_ADDR+0x268>
 800442c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800442e:	2b10      	cmp	r3, #16
 8004430:	d002      	beq.n	8004438 <I2C_Master_ADDR+0x268>
 8004432:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004434:	2b20      	cmp	r3, #32
 8004436:	d107      	bne.n	8004448 <I2C_Master_ADDR+0x278>
        {
          /* Enable Last DMA bit */
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 8004438:	687b      	ldr	r3, [r7, #4]
 800443a:	681b      	ldr	r3, [r3, #0]
 800443c:	685a      	ldr	r2, [r3, #4]
 800443e:	687b      	ldr	r3, [r7, #4]
 8004440:	681b      	ldr	r3, [r3, #0]
 8004442:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8004446:	605a      	str	r2, [r3, #4]
        }

        /* Clear ADDR flag */
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8004448:	2300      	movs	r3, #0
 800444a:	617b      	str	r3, [r7, #20]
 800444c:	687b      	ldr	r3, [r7, #4]
 800444e:	681b      	ldr	r3, [r3, #0]
 8004450:	695b      	ldr	r3, [r3, #20]
 8004452:	617b      	str	r3, [r7, #20]
 8004454:	687b      	ldr	r3, [r7, #4]
 8004456:	681b      	ldr	r3, [r3, #0]
 8004458:	699b      	ldr	r3, [r3, #24]
 800445a:	617b      	str	r3, [r7, #20]
 800445c:	697b      	ldr	r3, [r7, #20]
 800445e:	e032      	b.n	80044c6 <I2C_Master_ADDR+0x2f6>
      }
      else
      {
        /* Enable Acknowledge */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8004460:	687b      	ldr	r3, [r7, #4]
 8004462:	681b      	ldr	r3, [r3, #0]
 8004464:	681a      	ldr	r2, [r3, #0]
 8004466:	687b      	ldr	r3, [r7, #4]
 8004468:	681b      	ldr	r3, [r3, #0]
 800446a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800446e:	601a      	str	r2, [r3, #0]

        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 8004470:	687b      	ldr	r3, [r7, #4]
 8004472:	681b      	ldr	r3, [r3, #0]
 8004474:	685b      	ldr	r3, [r3, #4]
 8004476:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800447a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800447e:	d117      	bne.n	80044b0 <I2C_Master_ADDR+0x2e0>
 8004480:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004482:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 8004486:	d00b      	beq.n	80044a0 <I2C_Master_ADDR+0x2d0>
 8004488:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800448a:	2b01      	cmp	r3, #1
 800448c:	d008      	beq.n	80044a0 <I2C_Master_ADDR+0x2d0>
 800448e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004490:	2b08      	cmp	r3, #8
 8004492:	d005      	beq.n	80044a0 <I2C_Master_ADDR+0x2d0>
 8004494:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004496:	2b10      	cmp	r3, #16
 8004498:	d002      	beq.n	80044a0 <I2C_Master_ADDR+0x2d0>
 800449a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800449c:	2b20      	cmp	r3, #32
 800449e:	d107      	bne.n	80044b0 <I2C_Master_ADDR+0x2e0>
        {
          /* Enable Last DMA bit */
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 80044a0:	687b      	ldr	r3, [r7, #4]
 80044a2:	681b      	ldr	r3, [r3, #0]
 80044a4:	685a      	ldr	r2, [r3, #4]
 80044a6:	687b      	ldr	r3, [r7, #4]
 80044a8:	681b      	ldr	r3, [r3, #0]
 80044aa:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80044ae:	605a      	str	r2, [r3, #4]
        }

        /* Clear ADDR flag */
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80044b0:	2300      	movs	r3, #0
 80044b2:	613b      	str	r3, [r7, #16]
 80044b4:	687b      	ldr	r3, [r7, #4]
 80044b6:	681b      	ldr	r3, [r3, #0]
 80044b8:	695b      	ldr	r3, [r3, #20]
 80044ba:	613b      	str	r3, [r7, #16]
 80044bc:	687b      	ldr	r3, [r7, #4]
 80044be:	681b      	ldr	r3, [r3, #0]
 80044c0:	699b      	ldr	r3, [r3, #24]
 80044c2:	613b      	str	r3, [r7, #16]
 80044c4:	693b      	ldr	r3, [r7, #16]
      }

      /* Reset Event counter  */
      hi2c->EventCount = 0U;
 80044c6:	687b      	ldr	r3, [r7, #4]
 80044c8:	2200      	movs	r2, #0
 80044ca:	651a      	str	r2, [r3, #80]	; 0x50
  else
  {
    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
  }
}
 80044cc:	e00b      	b.n	80044e6 <I2C_Master_ADDR+0x316>
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80044ce:	2300      	movs	r3, #0
 80044d0:	60fb      	str	r3, [r7, #12]
 80044d2:	687b      	ldr	r3, [r7, #4]
 80044d4:	681b      	ldr	r3, [r3, #0]
 80044d6:	695b      	ldr	r3, [r3, #20]
 80044d8:	60fb      	str	r3, [r7, #12]
 80044da:	687b      	ldr	r3, [r7, #4]
 80044dc:	681b      	ldr	r3, [r3, #0]
 80044de:	699b      	ldr	r3, [r3, #24]
 80044e0:	60fb      	str	r3, [r7, #12]
 80044e2:	68fb      	ldr	r3, [r7, #12]
}
 80044e4:	e7ff      	b.n	80044e6 <I2C_Master_ADDR+0x316>
 80044e6:	bf00      	nop
 80044e8:	3744      	adds	r7, #68	; 0x44
 80044ea:	46bd      	mov	sp, r7
 80044ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80044f0:	4770      	bx	lr

080044f2 <I2C_SlaveTransmit_TXE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
{
 80044f2:	b580      	push	{r7, lr}
 80044f4:	b084      	sub	sp, #16
 80044f6:	af00      	add	r7, sp, #0
 80044f8:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 80044fa:	687b      	ldr	r3, [r7, #4]
 80044fc:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8004500:	73fb      	strb	r3, [r7, #15]

  if (hi2c->XferCount != 0U)
 8004502:	687b      	ldr	r3, [r7, #4]
 8004504:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8004506:	b29b      	uxth	r3, r3
 8004508:	2b00      	cmp	r3, #0
 800450a:	d02b      	beq.n	8004564 <I2C_SlaveTransmit_TXE+0x72>
  {
    /* Write data to DR */
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 800450c:	687b      	ldr	r3, [r7, #4]
 800450e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004510:	781a      	ldrb	r2, [r3, #0]
 8004512:	687b      	ldr	r3, [r7, #4]
 8004514:	681b      	ldr	r3, [r3, #0]
 8004516:	611a      	str	r2, [r3, #16]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8004518:	687b      	ldr	r3, [r7, #4]
 800451a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800451c:	1c5a      	adds	r2, r3, #1
 800451e:	687b      	ldr	r3, [r7, #4]
 8004520:	625a      	str	r2, [r3, #36]	; 0x24

    /* Update counter */
    hi2c->XferCount--;
 8004522:	687b      	ldr	r3, [r7, #4]
 8004524:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8004526:	b29b      	uxth	r3, r3
 8004528:	3b01      	subs	r3, #1
 800452a:	b29a      	uxth	r2, r3
 800452c:	687b      	ldr	r3, [r7, #4]
 800452e:	855a      	strh	r2, [r3, #42]	; 0x2a

    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8004530:	687b      	ldr	r3, [r7, #4]
 8004532:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8004534:	b29b      	uxth	r3, r3
 8004536:	2b00      	cmp	r3, #0
 8004538:	d114      	bne.n	8004564 <I2C_SlaveTransmit_TXE+0x72>
 800453a:	7bfb      	ldrb	r3, [r7, #15]
 800453c:	2b29      	cmp	r3, #41	; 0x29
 800453e:	d111      	bne.n	8004564 <I2C_SlaveTransmit_TXE+0x72>
    {
      /* Last Byte is received, disable Interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8004540:	687b      	ldr	r3, [r7, #4]
 8004542:	681b      	ldr	r3, [r3, #0]
 8004544:	685a      	ldr	r2, [r3, #4]
 8004546:	687b      	ldr	r3, [r7, #4]
 8004548:	681b      	ldr	r3, [r3, #0]
 800454a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800454e:	605a      	str	r2, [r3, #4]

      /* Set state at HAL_I2C_STATE_LISTEN */
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8004550:	687b      	ldr	r3, [r7, #4]
 8004552:	2221      	movs	r2, #33	; 0x21
 8004554:	631a      	str	r2, [r3, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8004556:	687b      	ldr	r3, [r7, #4]
 8004558:	2228      	movs	r2, #40	; 0x28
 800455a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
      hi2c->SlaveTxCpltCallback(hi2c);
#else
      HAL_I2C_SlaveTxCpltCallback(hi2c);
 800455e:	6878      	ldr	r0, [r7, #4]
 8004560:	f7ff fa22 	bl	80039a8 <HAL_I2C_SlaveTxCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    }
  }
}
 8004564:	bf00      	nop
 8004566:	3710      	adds	r7, #16
 8004568:	46bd      	mov	sp, r7
 800456a:	bd80      	pop	{r7, pc}

0800456c <I2C_SlaveTransmit_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
{
 800456c:	b480      	push	{r7}
 800456e:	b083      	sub	sp, #12
 8004570:	af00      	add	r7, sp, #0
 8004572:	6078      	str	r0, [r7, #4]
  if (hi2c->XferCount != 0U)
 8004574:	687b      	ldr	r3, [r7, #4]
 8004576:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8004578:	b29b      	uxth	r3, r3
 800457a:	2b00      	cmp	r3, #0
 800457c:	d011      	beq.n	80045a2 <I2C_SlaveTransmit_BTF+0x36>
  {
    /* Write data to DR */
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 800457e:	687b      	ldr	r3, [r7, #4]
 8004580:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004582:	781a      	ldrb	r2, [r3, #0]
 8004584:	687b      	ldr	r3, [r7, #4]
 8004586:	681b      	ldr	r3, [r3, #0]
 8004588:	611a      	str	r2, [r3, #16]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 800458a:	687b      	ldr	r3, [r7, #4]
 800458c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800458e:	1c5a      	adds	r2, r3, #1
 8004590:	687b      	ldr	r3, [r7, #4]
 8004592:	625a      	str	r2, [r3, #36]	; 0x24

    /* Update counter */
    hi2c->XferCount--;
 8004594:	687b      	ldr	r3, [r7, #4]
 8004596:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8004598:	b29b      	uxth	r3, r3
 800459a:	3b01      	subs	r3, #1
 800459c:	b29a      	uxth	r2, r3
 800459e:	687b      	ldr	r3, [r7, #4]
 80045a0:	855a      	strh	r2, [r3, #42]	; 0x2a
  }
}
 80045a2:	bf00      	nop
 80045a4:	370c      	adds	r7, #12
 80045a6:	46bd      	mov	sp, r7
 80045a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80045ac:	4770      	bx	lr

080045ae <I2C_SlaveReceive_RXNE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
{
 80045ae:	b580      	push	{r7, lr}
 80045b0:	b084      	sub	sp, #16
 80045b2:	af00      	add	r7, sp, #0
 80045b4:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 80045b6:	687b      	ldr	r3, [r7, #4]
 80045b8:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80045bc:	73fb      	strb	r3, [r7, #15]

  if (hi2c->XferCount != 0U)
 80045be:	687b      	ldr	r3, [r7, #4]
 80045c0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80045c2:	b29b      	uxth	r3, r3
 80045c4:	2b00      	cmp	r3, #0
 80045c6:	d02c      	beq.n	8004622 <I2C_SlaveReceive_RXNE+0x74>
  {
    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80045c8:	687b      	ldr	r3, [r7, #4]
 80045ca:	681b      	ldr	r3, [r3, #0]
 80045cc:	691a      	ldr	r2, [r3, #16]
 80045ce:	687b      	ldr	r3, [r7, #4]
 80045d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045d2:	b2d2      	uxtb	r2, r2
 80045d4:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 80045d6:	687b      	ldr	r3, [r7, #4]
 80045d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045da:	1c5a      	adds	r2, r3, #1
 80045dc:	687b      	ldr	r3, [r7, #4]
 80045de:	625a      	str	r2, [r3, #36]	; 0x24

    /* Update counter */
    hi2c->XferCount--;
 80045e0:	687b      	ldr	r3, [r7, #4]
 80045e2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80045e4:	b29b      	uxth	r3, r3
 80045e6:	3b01      	subs	r3, #1
 80045e8:	b29a      	uxth	r2, r3
 80045ea:	687b      	ldr	r3, [r7, #4]
 80045ec:	855a      	strh	r2, [r3, #42]	; 0x2a

    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 80045ee:	687b      	ldr	r3, [r7, #4]
 80045f0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80045f2:	b29b      	uxth	r3, r3
 80045f4:	2b00      	cmp	r3, #0
 80045f6:	d114      	bne.n	8004622 <I2C_SlaveReceive_RXNE+0x74>
 80045f8:	7bfb      	ldrb	r3, [r7, #15]
 80045fa:	2b2a      	cmp	r3, #42	; 0x2a
 80045fc:	d111      	bne.n	8004622 <I2C_SlaveReceive_RXNE+0x74>
    {
      /* Last Byte is received, disable Interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 80045fe:	687b      	ldr	r3, [r7, #4]
 8004600:	681b      	ldr	r3, [r3, #0]
 8004602:	685a      	ldr	r2, [r3, #4]
 8004604:	687b      	ldr	r3, [r7, #4]
 8004606:	681b      	ldr	r3, [r3, #0]
 8004608:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800460c:	605a      	str	r2, [r3, #4]

      /* Set state at HAL_I2C_STATE_LISTEN */
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 800460e:	687b      	ldr	r3, [r7, #4]
 8004610:	2222      	movs	r2, #34	; 0x22
 8004612:	631a      	str	r2, [r3, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8004614:	687b      	ldr	r3, [r7, #4]
 8004616:	2228      	movs	r2, #40	; 0x28
 8004618:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
      hi2c->SlaveRxCpltCallback(hi2c);
#else
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 800461c:	6878      	ldr	r0, [r7, #4]
 800461e:	f7ff f9cd 	bl	80039bc <HAL_I2C_SlaveRxCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    }
  }
}
 8004622:	bf00      	nop
 8004624:	3710      	adds	r7, #16
 8004626:	46bd      	mov	sp, r7
 8004628:	bd80      	pop	{r7, pc}

0800462a <I2C_SlaveReceive_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
{
 800462a:	b480      	push	{r7}
 800462c:	b083      	sub	sp, #12
 800462e:	af00      	add	r7, sp, #0
 8004630:	6078      	str	r0, [r7, #4]
  if (hi2c->XferCount != 0U)
 8004632:	687b      	ldr	r3, [r7, #4]
 8004634:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8004636:	b29b      	uxth	r3, r3
 8004638:	2b00      	cmp	r3, #0
 800463a:	d012      	beq.n	8004662 <I2C_SlaveReceive_BTF+0x38>
  {
    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800463c:	687b      	ldr	r3, [r7, #4]
 800463e:	681b      	ldr	r3, [r3, #0]
 8004640:	691a      	ldr	r2, [r3, #16]
 8004642:	687b      	ldr	r3, [r7, #4]
 8004644:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004646:	b2d2      	uxtb	r2, r2
 8004648:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 800464a:	687b      	ldr	r3, [r7, #4]
 800464c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800464e:	1c5a      	adds	r2, r3, #1
 8004650:	687b      	ldr	r3, [r7, #4]
 8004652:	625a      	str	r2, [r3, #36]	; 0x24

    /* Update counter */
    hi2c->XferCount--;
 8004654:	687b      	ldr	r3, [r7, #4]
 8004656:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8004658:	b29b      	uxth	r3, r3
 800465a:	3b01      	subs	r3, #1
 800465c:	b29a      	uxth	r2, r3
 800465e:	687b      	ldr	r3, [r7, #4]
 8004660:	855a      	strh	r2, [r3, #42]	; 0x2a
  }
}
 8004662:	bf00      	nop
 8004664:	370c      	adds	r7, #12
 8004666:	46bd      	mov	sp, r7
 8004668:	f85d 7b04 	ldr.w	r7, [sp], #4
 800466c:	4770      	bx	lr

0800466e <I2C_Slave_ADDR>:
  *         the configuration information for I2C module
  * @param  IT2Flags Interrupt2 flags to handle.
  * @retval None
  */
static void I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c, uint32_t IT2Flags)
{
 800466e:	b580      	push	{r7, lr}
 8004670:	b084      	sub	sp, #16
 8004672:	af00      	add	r7, sp, #0
 8004674:	6078      	str	r0, [r7, #4]
 8004676:	6039      	str	r1, [r7, #0]
  uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
 8004678:	2300      	movs	r3, #0
 800467a:	73fb      	strb	r3, [r7, #15]
  uint16_t SlaveAddrCode;

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 800467c:	687b      	ldr	r3, [r7, #4]
 800467e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8004682:	b2db      	uxtb	r3, r3
 8004684:	f003 0328 	and.w	r3, r3, #40	; 0x28
 8004688:	2b28      	cmp	r3, #40	; 0x28
 800468a:	d127      	bne.n	80046dc <I2C_Slave_ADDR+0x6e>
  {
    /* Disable BUF interrupt, BUF enabling is manage through slave specific interface */
    __HAL_I2C_DISABLE_IT(hi2c, (I2C_IT_BUF));
 800468c:	687b      	ldr	r3, [r7, #4]
 800468e:	681b      	ldr	r3, [r3, #0]
 8004690:	685a      	ldr	r2, [r3, #4]
 8004692:	687b      	ldr	r3, [r7, #4]
 8004694:	681b      	ldr	r3, [r3, #0]
 8004696:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800469a:	605a      	str	r2, [r3, #4]

    /* Transfer Direction requested by Master */
    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_TRA) == RESET)
 800469c:	683b      	ldr	r3, [r7, #0]
 800469e:	089b      	lsrs	r3, r3, #2
 80046a0:	f003 0301 	and.w	r3, r3, #1
 80046a4:	2b00      	cmp	r3, #0
 80046a6:	d101      	bne.n	80046ac <I2C_Slave_ADDR+0x3e>
    {
      TransferDirection = I2C_DIRECTION_TRANSMIT;
 80046a8:	2301      	movs	r3, #1
 80046aa:	73fb      	strb	r3, [r7, #15]
    }

    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_DUALF) == RESET)
 80046ac:	683b      	ldr	r3, [r7, #0]
 80046ae:	09db      	lsrs	r3, r3, #7
 80046b0:	f003 0301 	and.w	r3, r3, #1
 80046b4:	2b00      	cmp	r3, #0
 80046b6:	d103      	bne.n	80046c0 <I2C_Slave_ADDR+0x52>
    {
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress1;
 80046b8:	687b      	ldr	r3, [r7, #4]
 80046ba:	68db      	ldr	r3, [r3, #12]
 80046bc:	81bb      	strh	r3, [r7, #12]
 80046be:	e002      	b.n	80046c6 <I2C_Slave_ADDR+0x58>
    }
    else
    {
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress2;
 80046c0:	687b      	ldr	r3, [r7, #4]
 80046c2:	699b      	ldr	r3, [r3, #24]
 80046c4:	81bb      	strh	r3, [r7, #12]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80046c6:	687b      	ldr	r3, [r7, #4]
 80046c8:	2200      	movs	r2, #0
 80046ca:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
#else
    HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
 80046ce:	89ba      	ldrh	r2, [r7, #12]
 80046d0:	7bfb      	ldrb	r3, [r7, #15]
 80046d2:	4619      	mov	r1, r3
 80046d4:	6878      	ldr	r0, [r7, #4]
 80046d6:	f7ff f97b 	bl	80039d0 <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
 80046da:	e008      	b.n	80046ee <I2C_Slave_ADDR+0x80>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 80046dc:	687b      	ldr	r3, [r7, #4]
 80046de:	681b      	ldr	r3, [r3, #0]
 80046e0:	f06f 0202 	mvn.w	r2, #2
 80046e4:	615a      	str	r2, [r3, #20]
    __HAL_UNLOCK(hi2c);
 80046e6:	687b      	ldr	r3, [r7, #4]
 80046e8:	2200      	movs	r2, #0
 80046ea:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 80046ee:	bf00      	nop
 80046f0:	3710      	adds	r7, #16
 80046f2:	46bd      	mov	sp, r7
 80046f4:	bd80      	pop	{r7, pc}
	...

080046f8 <I2C_Slave_STOPF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
{
 80046f8:	b580      	push	{r7, lr}
 80046fa:	b084      	sub	sp, #16
 80046fc:	af00      	add	r7, sp, #0
 80046fe:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8004700:	687b      	ldr	r3, [r7, #4]
 8004702:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8004706:	73fb      	strb	r3, [r7, #15]

  /* Disable EVT, BUF and ERR interrupt */
  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8004708:	687b      	ldr	r3, [r7, #4]
 800470a:	681b      	ldr	r3, [r3, #0]
 800470c:	685a      	ldr	r2, [r3, #4]
 800470e:	687b      	ldr	r3, [r7, #4]
 8004710:	681b      	ldr	r3, [r3, #0]
 8004712:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8004716:	605a      	str	r2, [r3, #4]

  /* Clear STOPF flag */
  __HAL_I2C_CLEAR_STOPFLAG(hi2c);
 8004718:	2300      	movs	r3, #0
 800471a:	60bb      	str	r3, [r7, #8]
 800471c:	687b      	ldr	r3, [r7, #4]
 800471e:	681b      	ldr	r3, [r3, #0]
 8004720:	695b      	ldr	r3, [r3, #20]
 8004722:	60bb      	str	r3, [r7, #8]
 8004724:	687b      	ldr	r3, [r7, #4]
 8004726:	681b      	ldr	r3, [r3, #0]
 8004728:	681a      	ldr	r2, [r3, #0]
 800472a:	687b      	ldr	r3, [r7, #4]
 800472c:	681b      	ldr	r3, [r3, #0]
 800472e:	f042 0201 	orr.w	r2, r2, #1
 8004732:	601a      	str	r2, [r3, #0]
 8004734:	68bb      	ldr	r3, [r7, #8]

  /* Disable Acknowledge */
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8004736:	687b      	ldr	r3, [r7, #4]
 8004738:	681b      	ldr	r3, [r3, #0]
 800473a:	681a      	ldr	r2, [r3, #0]
 800473c:	687b      	ldr	r3, [r7, #4]
 800473e:	681b      	ldr	r3, [r3, #0]
 8004740:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8004744:	601a      	str	r2, [r3, #0]

  /* If a DMA is ongoing, Update handle size context */
  if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8004746:	687b      	ldr	r3, [r7, #4]
 8004748:	681b      	ldr	r3, [r3, #0]
 800474a:	685b      	ldr	r3, [r3, #4]
 800474c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004750:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8004754:	d172      	bne.n	800483c <I2C_Slave_STOPF+0x144>
  {
    if ((CurrentState == HAL_I2C_STATE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8004756:	7bfb      	ldrb	r3, [r7, #15]
 8004758:	2b22      	cmp	r3, #34	; 0x22
 800475a:	d002      	beq.n	8004762 <I2C_Slave_STOPF+0x6a>
 800475c:	7bfb      	ldrb	r3, [r7, #15]
 800475e:	2b2a      	cmp	r3, #42	; 0x2a
 8004760:	d135      	bne.n	80047ce <I2C_Slave_STOPF+0xd6>
    {
      hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmarx));
 8004762:	687b      	ldr	r3, [r7, #4]
 8004764:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004766:	681b      	ldr	r3, [r3, #0]
 8004768:	685b      	ldr	r3, [r3, #4]
 800476a:	b29a      	uxth	r2, r3
 800476c:	687b      	ldr	r3, [r7, #4]
 800476e:	855a      	strh	r2, [r3, #42]	; 0x2a

      if (hi2c->XferCount != 0U)
 8004770:	687b      	ldr	r3, [r7, #4]
 8004772:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8004774:	b29b      	uxth	r3, r3
 8004776:	2b00      	cmp	r3, #0
 8004778:	d005      	beq.n	8004786 <I2C_Slave_STOPF+0x8e>
      {
        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800477a:	687b      	ldr	r3, [r7, #4]
 800477c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800477e:	f043 0204 	orr.w	r2, r3, #4
 8004782:	687b      	ldr	r3, [r7, #4]
 8004784:	641a      	str	r2, [r3, #64]	; 0x40
      }

      /* Disable, stop the current DMA */
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 8004786:	687b      	ldr	r3, [r7, #4]
 8004788:	681b      	ldr	r3, [r3, #0]
 800478a:	685a      	ldr	r2, [r3, #4]
 800478c:	687b      	ldr	r3, [r7, #4]
 800478e:	681b      	ldr	r3, [r3, #0]
 8004790:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8004794:	605a      	str	r2, [r3, #4]

      /* Abort DMA Xfer if any */
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8004796:	687b      	ldr	r3, [r7, #4]
 8004798:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800479a:	4618      	mov	r0, r3
 800479c:	f7fe f830 	bl	8002800 <HAL_DMA_GetState>
 80047a0:	4603      	mov	r3, r0
 80047a2:	2b01      	cmp	r3, #1
 80047a4:	d049      	beq.n	800483a <I2C_Slave_STOPF+0x142>
      {
        /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
        hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 80047a6:	687b      	ldr	r3, [r7, #4]
 80047a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80047aa:	4a69      	ldr	r2, [pc, #420]	; (8004950 <I2C_Slave_STOPF+0x258>)
 80047ac:	651a      	str	r2, [r3, #80]	; 0x50

        /* Abort DMA RX */
        if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 80047ae:	687b      	ldr	r3, [r7, #4]
 80047b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80047b2:	4618      	mov	r0, r3
 80047b4:	f7fd fe78 	bl	80024a8 <HAL_DMA_Abort_IT>
 80047b8:	4603      	mov	r3, r0
 80047ba:	2b00      	cmp	r3, #0
 80047bc:	d03d      	beq.n	800483a <I2C_Slave_STOPF+0x142>
        {
          /* Call Directly XferAbortCallback function in case of error */
          hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 80047be:	687b      	ldr	r3, [r7, #4]
 80047c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80047c2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80047c4:	687a      	ldr	r2, [r7, #4]
 80047c6:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80047c8:	4610      	mov	r0, r2
 80047ca:	4798      	blx	r3
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 80047cc:	e035      	b.n	800483a <I2C_Slave_STOPF+0x142>
        }
      }
    }
    else
    {
      hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmatx));
 80047ce:	687b      	ldr	r3, [r7, #4]
 80047d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80047d2:	681b      	ldr	r3, [r3, #0]
 80047d4:	685b      	ldr	r3, [r3, #4]
 80047d6:	b29a      	uxth	r2, r3
 80047d8:	687b      	ldr	r3, [r7, #4]
 80047da:	855a      	strh	r2, [r3, #42]	; 0x2a

      if (hi2c->XferCount != 0U)
 80047dc:	687b      	ldr	r3, [r7, #4]
 80047de:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80047e0:	b29b      	uxth	r3, r3
 80047e2:	2b00      	cmp	r3, #0
 80047e4:	d005      	beq.n	80047f2 <I2C_Slave_STOPF+0xfa>
      {
        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80047e6:	687b      	ldr	r3, [r7, #4]
 80047e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80047ea:	f043 0204 	orr.w	r2, r3, #4
 80047ee:	687b      	ldr	r3, [r7, #4]
 80047f0:	641a      	str	r2, [r3, #64]	; 0x40
      }

      /* Disable, stop the current DMA */
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 80047f2:	687b      	ldr	r3, [r7, #4]
 80047f4:	681b      	ldr	r3, [r3, #0]
 80047f6:	685a      	ldr	r2, [r3, #4]
 80047f8:	687b      	ldr	r3, [r7, #4]
 80047fa:	681b      	ldr	r3, [r3, #0]
 80047fc:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8004800:	605a      	str	r2, [r3, #4]

      /* Abort DMA Xfer if any */
      if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8004802:	687b      	ldr	r3, [r7, #4]
 8004804:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004806:	4618      	mov	r0, r3
 8004808:	f7fd fffa 	bl	8002800 <HAL_DMA_GetState>
 800480c:	4603      	mov	r3, r0
 800480e:	2b01      	cmp	r3, #1
 8004810:	d014      	beq.n	800483c <I2C_Slave_STOPF+0x144>
      {
        /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
        hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8004812:	687b      	ldr	r3, [r7, #4]
 8004814:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004816:	4a4e      	ldr	r2, [pc, #312]	; (8004950 <I2C_Slave_STOPF+0x258>)
 8004818:	651a      	str	r2, [r3, #80]	; 0x50

        /* Abort DMA TX */
        if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 800481a:	687b      	ldr	r3, [r7, #4]
 800481c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800481e:	4618      	mov	r0, r3
 8004820:	f7fd fe42 	bl	80024a8 <HAL_DMA_Abort_IT>
 8004824:	4603      	mov	r3, r0
 8004826:	2b00      	cmp	r3, #0
 8004828:	d008      	beq.n	800483c <I2C_Slave_STOPF+0x144>
        {
          /* Call Directly XferAbortCallback function in case of error */
          hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 800482a:	687b      	ldr	r3, [r7, #4]
 800482c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800482e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004830:	687a      	ldr	r2, [r7, #4]
 8004832:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8004834:	4610      	mov	r0, r2
 8004836:	4798      	blx	r3
 8004838:	e000      	b.n	800483c <I2C_Slave_STOPF+0x144>
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 800483a:	bf00      	nop
      }
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
 800483c:	687b      	ldr	r3, [r7, #4]
 800483e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8004840:	b29b      	uxth	r3, r3
 8004842:	2b00      	cmp	r3, #0
 8004844:	d03e      	beq.n	80048c4 <I2C_Slave_STOPF+0x1cc>
  {
    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 8004846:	687b      	ldr	r3, [r7, #4]
 8004848:	681b      	ldr	r3, [r3, #0]
 800484a:	695b      	ldr	r3, [r3, #20]
 800484c:	f003 0304 	and.w	r3, r3, #4
 8004850:	2b04      	cmp	r3, #4
 8004852:	d112      	bne.n	800487a <I2C_Slave_STOPF+0x182>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8004854:	687b      	ldr	r3, [r7, #4]
 8004856:	681b      	ldr	r3, [r3, #0]
 8004858:	691a      	ldr	r2, [r3, #16]
 800485a:	687b      	ldr	r3, [r7, #4]
 800485c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800485e:	b2d2      	uxtb	r2, r2
 8004860:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8004862:	687b      	ldr	r3, [r7, #4]
 8004864:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004866:	1c5a      	adds	r2, r3, #1
 8004868:	687b      	ldr	r3, [r7, #4]
 800486a:	625a      	str	r2, [r3, #36]	; 0x24

      /* Update counter */
      hi2c->XferCount--;
 800486c:	687b      	ldr	r3, [r7, #4]
 800486e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8004870:	b29b      	uxth	r3, r3
 8004872:	3b01      	subs	r3, #1
 8004874:	b29a      	uxth	r2, r3
 8004876:	687b      	ldr	r3, [r7, #4]
 8004878:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 800487a:	687b      	ldr	r3, [r7, #4]
 800487c:	681b      	ldr	r3, [r3, #0]
 800487e:	695b      	ldr	r3, [r3, #20]
 8004880:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8004884:	2b40      	cmp	r3, #64	; 0x40
 8004886:	d112      	bne.n	80048ae <I2C_Slave_STOPF+0x1b6>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8004888:	687b      	ldr	r3, [r7, #4]
 800488a:	681b      	ldr	r3, [r3, #0]
 800488c:	691a      	ldr	r2, [r3, #16]
 800488e:	687b      	ldr	r3, [r7, #4]
 8004890:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004892:	b2d2      	uxtb	r2, r2
 8004894:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8004896:	687b      	ldr	r3, [r7, #4]
 8004898:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800489a:	1c5a      	adds	r2, r3, #1
 800489c:	687b      	ldr	r3, [r7, #4]
 800489e:	625a      	str	r2, [r3, #36]	; 0x24

      /* Update counter */
      hi2c->XferCount--;
 80048a0:	687b      	ldr	r3, [r7, #4]
 80048a2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80048a4:	b29b      	uxth	r3, r3
 80048a6:	3b01      	subs	r3, #1
 80048a8:	b29a      	uxth	r2, r3
 80048aa:	687b      	ldr	r3, [r7, #4]
 80048ac:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    if (hi2c->XferCount != 0U)
 80048ae:	687b      	ldr	r3, [r7, #4]
 80048b0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80048b2:	b29b      	uxth	r3, r3
 80048b4:	2b00      	cmp	r3, #0
 80048b6:	d005      	beq.n	80048c4 <I2C_Slave_STOPF+0x1cc>
    {
      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80048b8:	687b      	ldr	r3, [r7, #4]
 80048ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80048bc:	f043 0204 	orr.w	r2, r3, #4
 80048c0:	687b      	ldr	r3, [r7, #4]
 80048c2:	641a      	str	r2, [r3, #64]	; 0x40
    }
  }

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 80048c4:	687b      	ldr	r3, [r7, #4]
 80048c6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80048c8:	2b00      	cmp	r3, #0
 80048ca:	d003      	beq.n	80048d4 <I2C_Slave_STOPF+0x1dc>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c);
 80048cc:	6878      	ldr	r0, [r7, #4]
 80048ce:	f000 f8b3 	bl	8004a38 <I2C_ITError>
        HAL_I2C_SlaveRxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
      }
    }
  }
}
 80048d2:	e039      	b.n	8004948 <I2C_Slave_STOPF+0x250>
    if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
 80048d4:	7bfb      	ldrb	r3, [r7, #15]
 80048d6:	2b2a      	cmp	r3, #42	; 0x2a
 80048d8:	d109      	bne.n	80048ee <I2C_Slave_STOPF+0x1f6>
      hi2c->PreviousState = I2C_STATE_NONE;
 80048da:	687b      	ldr	r3, [r7, #4]
 80048dc:	2200      	movs	r2, #0
 80048de:	631a      	str	r2, [r3, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 80048e0:	687b      	ldr	r3, [r7, #4]
 80048e2:	2228      	movs	r2, #40	; 0x28
 80048e4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 80048e8:	6878      	ldr	r0, [r7, #4]
 80048ea:	f7ff f867 	bl	80039bc <HAL_I2C_SlaveRxCpltCallback>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 80048ee:	687b      	ldr	r3, [r7, #4]
 80048f0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80048f4:	b2db      	uxtb	r3, r3
 80048f6:	2b28      	cmp	r3, #40	; 0x28
 80048f8:	d111      	bne.n	800491e <I2C_Slave_STOPF+0x226>
      hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80048fa:	687b      	ldr	r3, [r7, #4]
 80048fc:	4a15      	ldr	r2, [pc, #84]	; (8004954 <I2C_Slave_STOPF+0x25c>)
 80048fe:	62da      	str	r2, [r3, #44]	; 0x2c
      hi2c->PreviousState = I2C_STATE_NONE;
 8004900:	687b      	ldr	r3, [r7, #4]
 8004902:	2200      	movs	r2, #0
 8004904:	631a      	str	r2, [r3, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 8004906:	687b      	ldr	r3, [r7, #4]
 8004908:	2220      	movs	r2, #32
 800490a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800490e:	687b      	ldr	r3, [r7, #4]
 8004910:	2200      	movs	r2, #0
 8004912:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      HAL_I2C_ListenCpltCallback(hi2c);
 8004916:	6878      	ldr	r0, [r7, #4]
 8004918:	f7ff f868 	bl	80039ec <HAL_I2C_ListenCpltCallback>
}
 800491c:	e014      	b.n	8004948 <I2C_Slave_STOPF+0x250>
      if ((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
 800491e:	687b      	ldr	r3, [r7, #4]
 8004920:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004922:	2b22      	cmp	r3, #34	; 0x22
 8004924:	d002      	beq.n	800492c <I2C_Slave_STOPF+0x234>
 8004926:	7bfb      	ldrb	r3, [r7, #15]
 8004928:	2b22      	cmp	r3, #34	; 0x22
 800492a:	d10d      	bne.n	8004948 <I2C_Slave_STOPF+0x250>
        hi2c->PreviousState = I2C_STATE_NONE;
 800492c:	687b      	ldr	r3, [r7, #4]
 800492e:	2200      	movs	r2, #0
 8004930:	631a      	str	r2, [r3, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 8004932:	687b      	ldr	r3, [r7, #4]
 8004934:	2220      	movs	r2, #32
 8004936:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800493a:	687b      	ldr	r3, [r7, #4]
 800493c:	2200      	movs	r2, #0
 800493e:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
        HAL_I2C_SlaveRxCpltCallback(hi2c);
 8004942:	6878      	ldr	r0, [r7, #4]
 8004944:	f7ff f83a 	bl	80039bc <HAL_I2C_SlaveRxCpltCallback>
}
 8004948:	bf00      	nop
 800494a:	3710      	adds	r7, #16
 800494c:	46bd      	mov	sp, r7
 800494e:	bd80      	pop	{r7, pc}
 8004950:	08004c9d 	.word	0x08004c9d
 8004954:	ffff0000 	.word	0xffff0000

08004958 <I2C_Slave_AF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
{
 8004958:	b580      	push	{r7, lr}
 800495a:	b084      	sub	sp, #16
 800495c:	af00      	add	r7, sp, #0
 800495e:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8004960:	687b      	ldr	r3, [r7, #4]
 8004962:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8004966:	73fb      	strb	r3, [r7, #15]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8004968:	687b      	ldr	r3, [r7, #4]
 800496a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800496c:	60bb      	str	r3, [r7, #8]

  if (((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
 800496e:	68bb      	ldr	r3, [r7, #8]
 8004970:	2b08      	cmp	r3, #8
 8004972:	d002      	beq.n	800497a <I2C_Slave_AF+0x22>
 8004974:	68bb      	ldr	r3, [r7, #8]
 8004976:	2b20      	cmp	r3, #32
 8004978:	d129      	bne.n	80049ce <I2C_Slave_AF+0x76>
 800497a:	7bfb      	ldrb	r3, [r7, #15]
 800497c:	2b28      	cmp	r3, #40	; 0x28
 800497e:	d126      	bne.n	80049ce <I2C_Slave_AF+0x76>
      (CurrentState == HAL_I2C_STATE_LISTEN))
  {
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8004980:	687b      	ldr	r3, [r7, #4]
 8004982:	4a2c      	ldr	r2, [pc, #176]	; (8004a34 <I2C_Slave_AF+0xdc>)
 8004984:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Disable EVT, BUF and ERR interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8004986:	687b      	ldr	r3, [r7, #4]
 8004988:	681b      	ldr	r3, [r3, #0]
 800498a:	685a      	ldr	r2, [r3, #4]
 800498c:	687b      	ldr	r3, [r7, #4]
 800498e:	681b      	ldr	r3, [r3, #0]
 8004990:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8004994:	605a      	str	r2, [r3, #4]

    /* Clear AF flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8004996:	687b      	ldr	r3, [r7, #4]
 8004998:	681b      	ldr	r3, [r3, #0]
 800499a:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 800499e:	615a      	str	r2, [r3, #20]

    /* Disable Acknowledge */
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80049a0:	687b      	ldr	r3, [r7, #4]
 80049a2:	681b      	ldr	r3, [r3, #0]
 80049a4:	681a      	ldr	r2, [r3, #0]
 80049a6:	687b      	ldr	r3, [r7, #4]
 80049a8:	681b      	ldr	r3, [r3, #0]
 80049aa:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80049ae:	601a      	str	r2, [r3, #0]

    hi2c->PreviousState = I2C_STATE_NONE;
 80049b0:	687b      	ldr	r3, [r7, #4]
 80049b2:	2200      	movs	r2, #0
 80049b4:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 80049b6:	687b      	ldr	r3, [r7, #4]
 80049b8:	2220      	movs	r2, #32
 80049ba:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 80049be:	687b      	ldr	r3, [r7, #4]
 80049c0:	2200      	movs	r2, #0
 80049c2:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->ListenCpltCallback(hi2c);
#else
    HAL_I2C_ListenCpltCallback(hi2c);
 80049c6:	6878      	ldr	r0, [r7, #4]
 80049c8:	f7ff f810 	bl	80039ec <HAL_I2C_ListenCpltCallback>
  {
    /* Clear AF flag only */
    /* State Listen, but XferOptions == FIRST or NEXT */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
  }
}
 80049cc:	e02e      	b.n	8004a2c <I2C_Slave_AF+0xd4>
  else if (CurrentState == HAL_I2C_STATE_BUSY_TX)
 80049ce:	7bfb      	ldrb	r3, [r7, #15]
 80049d0:	2b21      	cmp	r3, #33	; 0x21
 80049d2:	d126      	bne.n	8004a22 <I2C_Slave_AF+0xca>
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 80049d4:	687b      	ldr	r3, [r7, #4]
 80049d6:	4a17      	ldr	r2, [pc, #92]	; (8004a34 <I2C_Slave_AF+0xdc>)
 80049d8:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 80049da:	687b      	ldr	r3, [r7, #4]
 80049dc:	2221      	movs	r2, #33	; 0x21
 80049de:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 80049e0:	687b      	ldr	r3, [r7, #4]
 80049e2:	2220      	movs	r2, #32
 80049e4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 80049e8:	687b      	ldr	r3, [r7, #4]
 80049ea:	2200      	movs	r2, #0
 80049ec:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80049f0:	687b      	ldr	r3, [r7, #4]
 80049f2:	681b      	ldr	r3, [r3, #0]
 80049f4:	685a      	ldr	r2, [r3, #4]
 80049f6:	687b      	ldr	r3, [r7, #4]
 80049f8:	681b      	ldr	r3, [r3, #0]
 80049fa:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 80049fe:	605a      	str	r2, [r3, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8004a00:	687b      	ldr	r3, [r7, #4]
 8004a02:	681b      	ldr	r3, [r3, #0]
 8004a04:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8004a08:	615a      	str	r2, [r3, #20]
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8004a0a:	687b      	ldr	r3, [r7, #4]
 8004a0c:	681b      	ldr	r3, [r3, #0]
 8004a0e:	681a      	ldr	r2, [r3, #0]
 8004a10:	687b      	ldr	r3, [r7, #4]
 8004a12:	681b      	ldr	r3, [r3, #0]
 8004a14:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8004a18:	601a      	str	r2, [r3, #0]
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8004a1a:	6878      	ldr	r0, [r7, #4]
 8004a1c:	f7fe ffc4 	bl	80039a8 <HAL_I2C_SlaveTxCpltCallback>
}
 8004a20:	e004      	b.n	8004a2c <I2C_Slave_AF+0xd4>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8004a22:	687b      	ldr	r3, [r7, #4]
 8004a24:	681b      	ldr	r3, [r3, #0]
 8004a26:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8004a2a:	615a      	str	r2, [r3, #20]
}
 8004a2c:	bf00      	nop
 8004a2e:	3710      	adds	r7, #16
 8004a30:	46bd      	mov	sp, r7
 8004a32:	bd80      	pop	{r7, pc}
 8004a34:	ffff0000 	.word	0xffff0000

08004a38 <I2C_ITError>:
  * @brief  I2C interrupts error process
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c)
{
 8004a38:	b580      	push	{r7, lr}
 8004a3a:	b084      	sub	sp, #16
 8004a3c:	af00      	add	r7, sp, #0
 8004a3e:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8004a40:	687b      	ldr	r3, [r7, #4]
 8004a42:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8004a46:	73fb      	strb	r3, [r7, #15]
  HAL_I2C_ModeTypeDef CurrentMode = hi2c->Mode;
 8004a48:	687b      	ldr	r3, [r7, #4]
 8004a4a:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8004a4e:	73bb      	strb	r3, [r7, #14]
  uint32_t CurrentError;

  if (((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM)) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
 8004a50:	7bbb      	ldrb	r3, [r7, #14]
 8004a52:	2b10      	cmp	r3, #16
 8004a54:	d002      	beq.n	8004a5c <I2C_ITError+0x24>
 8004a56:	7bbb      	ldrb	r3, [r7, #14]
 8004a58:	2b40      	cmp	r3, #64	; 0x40
 8004a5a:	d10a      	bne.n	8004a72 <I2C_ITError+0x3a>
 8004a5c:	7bfb      	ldrb	r3, [r7, #15]
 8004a5e:	2b22      	cmp	r3, #34	; 0x22
 8004a60:	d107      	bne.n	8004a72 <I2C_ITError+0x3a>
  {
    /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 8004a62:	687b      	ldr	r3, [r7, #4]
 8004a64:	681b      	ldr	r3, [r3, #0]
 8004a66:	681a      	ldr	r2, [r3, #0]
 8004a68:	687b      	ldr	r3, [r7, #4]
 8004a6a:	681b      	ldr	r3, [r3, #0]
 8004a6c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8004a70:	601a      	str	r2, [r3, #0]
  }

  if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8004a72:	7bfb      	ldrb	r3, [r7, #15]
 8004a74:	f003 0328 	and.w	r3, r3, #40	; 0x28
 8004a78:	2b28      	cmp	r3, #40	; 0x28
 8004a7a:	d107      	bne.n	8004a8c <I2C_ITError+0x54>
  {
    /* keep HAL_I2C_STATE_LISTEN */
    hi2c->PreviousState = I2C_STATE_NONE;
 8004a7c:	687b      	ldr	r3, [r7, #4]
 8004a7e:	2200      	movs	r2, #0
 8004a80:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_LISTEN;
 8004a82:	687b      	ldr	r3, [r7, #4]
 8004a84:	2228      	movs	r2, #40	; 0x28
 8004a86:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8004a8a:	e015      	b.n	8004ab8 <I2C_ITError+0x80>
  }
  else
  {
    /* If state is an abort treatment on going, don't change state */
    /* This change will be do later */
    if ((READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN) && (CurrentState != HAL_I2C_STATE_ABORT))
 8004a8c:	687b      	ldr	r3, [r7, #4]
 8004a8e:	681b      	ldr	r3, [r3, #0]
 8004a90:	685b      	ldr	r3, [r3, #4]
 8004a92:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004a96:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8004a9a:	d00a      	beq.n	8004ab2 <I2C_ITError+0x7a>
 8004a9c:	7bfb      	ldrb	r3, [r7, #15]
 8004a9e:	2b60      	cmp	r3, #96	; 0x60
 8004aa0:	d007      	beq.n	8004ab2 <I2C_ITError+0x7a>
    {
      hi2c->State = HAL_I2C_STATE_READY;
 8004aa2:	687b      	ldr	r3, [r7, #4]
 8004aa4:	2220      	movs	r2, #32
 8004aa6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8004aaa:	687b      	ldr	r3, [r7, #4]
 8004aac:	2200      	movs	r2, #0
 8004aae:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
    }
    hi2c->PreviousState = I2C_STATE_NONE;
 8004ab2:	687b      	ldr	r3, [r7, #4]
 8004ab4:	2200      	movs	r2, #0
 8004ab6:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Abort DMA transfer */
  if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8004ab8:	687b      	ldr	r3, [r7, #4]
 8004aba:	681b      	ldr	r3, [r3, #0]
 8004abc:	685b      	ldr	r3, [r3, #4]
 8004abe:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004ac2:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8004ac6:	d162      	bne.n	8004b8e <I2C_ITError+0x156>
  {
    hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
 8004ac8:	687b      	ldr	r3, [r7, #4]
 8004aca:	681b      	ldr	r3, [r3, #0]
 8004acc:	685a      	ldr	r2, [r3, #4]
 8004ace:	687b      	ldr	r3, [r7, #4]
 8004ad0:	681b      	ldr	r3, [r3, #0]
 8004ad2:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8004ad6:	605a      	str	r2, [r3, #4]

    if (hi2c->hdmatx->State != HAL_DMA_STATE_READY)
 8004ad8:	687b      	ldr	r3, [r7, #4]
 8004ada:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004adc:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8004ae0:	b2db      	uxtb	r3, r3
 8004ae2:	2b01      	cmp	r3, #1
 8004ae4:	d020      	beq.n	8004b28 <I2C_ITError+0xf0>
    {
      /* Set the DMA Abort callback :
      will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8004ae6:	687b      	ldr	r3, [r7, #4]
 8004ae8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004aea:	4a6a      	ldr	r2, [pc, #424]	; (8004c94 <I2C_ITError+0x25c>)
 8004aec:	651a      	str	r2, [r3, #80]	; 0x50

      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8004aee:	687b      	ldr	r3, [r7, #4]
 8004af0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004af2:	4618      	mov	r0, r3
 8004af4:	f7fd fcd8 	bl	80024a8 <HAL_DMA_Abort_IT>
 8004af8:	4603      	mov	r3, r0
 8004afa:	2b00      	cmp	r3, #0
 8004afc:	f000 8089 	beq.w	8004c12 <I2C_ITError+0x1da>
      {
        /* Disable I2C peripheral to prevent dummy data in buffer */
        __HAL_I2C_DISABLE(hi2c);
 8004b00:	687b      	ldr	r3, [r7, #4]
 8004b02:	681b      	ldr	r3, [r3, #0]
 8004b04:	681a      	ldr	r2, [r3, #0]
 8004b06:	687b      	ldr	r3, [r7, #4]
 8004b08:	681b      	ldr	r3, [r3, #0]
 8004b0a:	f022 0201 	bic.w	r2, r2, #1
 8004b0e:	601a      	str	r2, [r3, #0]

        hi2c->State = HAL_I2C_STATE_READY;
 8004b10:	687b      	ldr	r3, [r7, #4]
 8004b12:	2220      	movs	r2, #32
 8004b14:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8004b18:	687b      	ldr	r3, [r7, #4]
 8004b1a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004b1c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004b1e:	687a      	ldr	r2, [r7, #4]
 8004b20:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8004b22:	4610      	mov	r0, r2
 8004b24:	4798      	blx	r3
 8004b26:	e074      	b.n	8004c12 <I2C_ITError+0x1da>
    }
    else
    {
      /* Set the DMA Abort callback :
      will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8004b28:	687b      	ldr	r3, [r7, #4]
 8004b2a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004b2c:	4a59      	ldr	r2, [pc, #356]	; (8004c94 <I2C_ITError+0x25c>)
 8004b2e:	651a      	str	r2, [r3, #80]	; 0x50

      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8004b30:	687b      	ldr	r3, [r7, #4]
 8004b32:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004b34:	4618      	mov	r0, r3
 8004b36:	f7fd fcb7 	bl	80024a8 <HAL_DMA_Abort_IT>
 8004b3a:	4603      	mov	r3, r0
 8004b3c:	2b00      	cmp	r3, #0
 8004b3e:	d068      	beq.n	8004c12 <I2C_ITError+0x1da>
      {
        /* Store Last receive data if any */
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 8004b40:	687b      	ldr	r3, [r7, #4]
 8004b42:	681b      	ldr	r3, [r3, #0]
 8004b44:	695b      	ldr	r3, [r3, #20]
 8004b46:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8004b4a:	2b40      	cmp	r3, #64	; 0x40
 8004b4c:	d10b      	bne.n	8004b66 <I2C_ITError+0x12e>
        {
          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8004b4e:	687b      	ldr	r3, [r7, #4]
 8004b50:	681b      	ldr	r3, [r3, #0]
 8004b52:	691a      	ldr	r2, [r3, #16]
 8004b54:	687b      	ldr	r3, [r7, #4]
 8004b56:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004b58:	b2d2      	uxtb	r2, r2
 8004b5a:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8004b5c:	687b      	ldr	r3, [r7, #4]
 8004b5e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004b60:	1c5a      	adds	r2, r3, #1
 8004b62:	687b      	ldr	r3, [r7, #4]
 8004b64:	625a      	str	r2, [r3, #36]	; 0x24
        }

        /* Disable I2C peripheral to prevent dummy data in buffer */
        __HAL_I2C_DISABLE(hi2c);
 8004b66:	687b      	ldr	r3, [r7, #4]
 8004b68:	681b      	ldr	r3, [r3, #0]
 8004b6a:	681a      	ldr	r2, [r3, #0]
 8004b6c:	687b      	ldr	r3, [r7, #4]
 8004b6e:	681b      	ldr	r3, [r3, #0]
 8004b70:	f022 0201 	bic.w	r2, r2, #1
 8004b74:	601a      	str	r2, [r3, #0]

        hi2c->State = HAL_I2C_STATE_READY;
 8004b76:	687b      	ldr	r3, [r7, #4]
 8004b78:	2220      	movs	r2, #32
 8004b7a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8004b7e:	687b      	ldr	r3, [r7, #4]
 8004b80:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004b82:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004b84:	687a      	ldr	r2, [r7, #4]
 8004b86:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8004b88:	4610      	mov	r0, r2
 8004b8a:	4798      	blx	r3
 8004b8c:	e041      	b.n	8004c12 <I2C_ITError+0x1da>
      }
    }
  }
  else if (hi2c->State == HAL_I2C_STATE_ABORT)
 8004b8e:	687b      	ldr	r3, [r7, #4]
 8004b90:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8004b94:	b2db      	uxtb	r3, r3
 8004b96:	2b60      	cmp	r3, #96	; 0x60
 8004b98:	d125      	bne.n	8004be6 <I2C_ITError+0x1ae>
  {
    hi2c->State = HAL_I2C_STATE_READY;
 8004b9a:	687b      	ldr	r3, [r7, #4]
 8004b9c:	2220      	movs	r2, #32
 8004b9e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8004ba2:	687b      	ldr	r3, [r7, #4]
 8004ba4:	2200      	movs	r2, #0
 8004ba6:	641a      	str	r2, [r3, #64]	; 0x40

    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 8004ba8:	687b      	ldr	r3, [r7, #4]
 8004baa:	681b      	ldr	r3, [r3, #0]
 8004bac:	695b      	ldr	r3, [r3, #20]
 8004bae:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8004bb2:	2b40      	cmp	r3, #64	; 0x40
 8004bb4:	d10b      	bne.n	8004bce <I2C_ITError+0x196>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8004bb6:	687b      	ldr	r3, [r7, #4]
 8004bb8:	681b      	ldr	r3, [r3, #0]
 8004bba:	691a      	ldr	r2, [r3, #16]
 8004bbc:	687b      	ldr	r3, [r7, #4]
 8004bbe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004bc0:	b2d2      	uxtb	r2, r2
 8004bc2:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8004bc4:	687b      	ldr	r3, [r7, #4]
 8004bc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004bc8:	1c5a      	adds	r2, r3, #1
 8004bca:	687b      	ldr	r3, [r7, #4]
 8004bcc:	625a      	str	r2, [r3, #36]	; 0x24
    }

    /* Disable I2C peripheral to prevent dummy data in buffer */
    __HAL_I2C_DISABLE(hi2c);
 8004bce:	687b      	ldr	r3, [r7, #4]
 8004bd0:	681b      	ldr	r3, [r3, #0]
 8004bd2:	681a      	ldr	r2, [r3, #0]
 8004bd4:	687b      	ldr	r3, [r7, #4]
 8004bd6:	681b      	ldr	r3, [r3, #0]
 8004bd8:	f022 0201 	bic.w	r2, r2, #1
 8004bdc:	601a      	str	r2, [r3, #0]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
 8004bde:	6878      	ldr	r0, [r7, #4]
 8004be0:	f7fe ff0e 	bl	8003a00 <HAL_I2C_AbortCpltCallback>
 8004be4:	e015      	b.n	8004c12 <I2C_ITError+0x1da>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
  else
  {
    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 8004be6:	687b      	ldr	r3, [r7, #4]
 8004be8:	681b      	ldr	r3, [r3, #0]
 8004bea:	695b      	ldr	r3, [r3, #20]
 8004bec:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8004bf0:	2b40      	cmp	r3, #64	; 0x40
 8004bf2:	d10b      	bne.n	8004c0c <I2C_ITError+0x1d4>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8004bf4:	687b      	ldr	r3, [r7, #4]
 8004bf6:	681b      	ldr	r3, [r3, #0]
 8004bf8:	691a      	ldr	r2, [r3, #16]
 8004bfa:	687b      	ldr	r3, [r7, #4]
 8004bfc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004bfe:	b2d2      	uxtb	r2, r2
 8004c00:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8004c02:	687b      	ldr	r3, [r7, #4]
 8004c04:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004c06:	1c5a      	adds	r2, r3, #1
 8004c08:	687b      	ldr	r3, [r7, #4]
 8004c0a:	625a      	str	r2, [r3, #36]	; 0x24

    /* Call user error callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
 8004c0c:	6878      	ldr	r0, [r7, #4]
 8004c0e:	f022 feb5 	bl	802797c <HAL_I2C_ErrorCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  /* STOP Flag is not set after a NACK reception, BusError, ArbitrationLost, OverRun */
  CurrentError = hi2c->ErrorCode;
 8004c12:	687b      	ldr	r3, [r7, #4]
 8004c14:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004c16:	60bb      	str	r3, [r7, #8]

  if (((CurrentError & HAL_I2C_ERROR_BERR) == HAL_I2C_ERROR_BERR) || \
 8004c18:	68bb      	ldr	r3, [r7, #8]
 8004c1a:	f003 0301 	and.w	r3, r3, #1
 8004c1e:	2b00      	cmp	r3, #0
 8004c20:	d10e      	bne.n	8004c40 <I2C_ITError+0x208>
      ((CurrentError & HAL_I2C_ERROR_ARLO) == HAL_I2C_ERROR_ARLO) || \
 8004c22:	68bb      	ldr	r3, [r7, #8]
 8004c24:	f003 0302 	and.w	r3, r3, #2
  if (((CurrentError & HAL_I2C_ERROR_BERR) == HAL_I2C_ERROR_BERR) || \
 8004c28:	2b00      	cmp	r3, #0
 8004c2a:	d109      	bne.n	8004c40 <I2C_ITError+0x208>
      ((CurrentError & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF)     || \
 8004c2c:	68bb      	ldr	r3, [r7, #8]
 8004c2e:	f003 0304 	and.w	r3, r3, #4
      ((CurrentError & HAL_I2C_ERROR_ARLO) == HAL_I2C_ERROR_ARLO) || \
 8004c32:	2b00      	cmp	r3, #0
 8004c34:	d104      	bne.n	8004c40 <I2C_ITError+0x208>
      ((CurrentError & HAL_I2C_ERROR_OVR) == HAL_I2C_ERROR_OVR))
 8004c36:	68bb      	ldr	r3, [r7, #8]
 8004c38:	f003 0308 	and.w	r3, r3, #8
      ((CurrentError & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF)     || \
 8004c3c:	2b00      	cmp	r3, #0
 8004c3e:	d007      	beq.n	8004c50 <I2C_ITError+0x218>
  {
    /* Disable EVT, BUF and ERR interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8004c40:	687b      	ldr	r3, [r7, #4]
 8004c42:	681b      	ldr	r3, [r3, #0]
 8004c44:	685a      	ldr	r2, [r3, #4]
 8004c46:	687b      	ldr	r3, [r7, #4]
 8004c48:	681b      	ldr	r3, [r3, #0]
 8004c4a:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8004c4e:	605a      	str	r2, [r3, #4]
  }

  /* So may inform upper layer that listen phase is stopped */
  /* during NACK error treatment */
  CurrentState = hi2c->State;
 8004c50:	687b      	ldr	r3, [r7, #4]
 8004c52:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8004c56:	73fb      	strb	r3, [r7, #15]
  if (((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF) && (CurrentState == HAL_I2C_STATE_LISTEN))
 8004c58:	687b      	ldr	r3, [r7, #4]
 8004c5a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004c5c:	f003 0304 	and.w	r3, r3, #4
 8004c60:	2b04      	cmp	r3, #4
 8004c62:	d113      	bne.n	8004c8c <I2C_ITError+0x254>
 8004c64:	7bfb      	ldrb	r3, [r7, #15]
 8004c66:	2b28      	cmp	r3, #40	; 0x28
 8004c68:	d110      	bne.n	8004c8c <I2C_ITError+0x254>
  {
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8004c6a:	687b      	ldr	r3, [r7, #4]
 8004c6c:	4a0a      	ldr	r2, [pc, #40]	; (8004c98 <I2C_ITError+0x260>)
 8004c6e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_NONE;
 8004c70:	687b      	ldr	r3, [r7, #4]
 8004c72:	2200      	movs	r2, #0
 8004c74:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 8004c76:	687b      	ldr	r3, [r7, #4]
 8004c78:	2220      	movs	r2, #32
 8004c7a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8004c7e:	687b      	ldr	r3, [r7, #4]
 8004c80:	2200      	movs	r2, #0
 8004c82:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->ListenCpltCallback(hi2c);
#else
    HAL_I2C_ListenCpltCallback(hi2c);
 8004c86:	6878      	ldr	r0, [r7, #4]
 8004c88:	f7fe feb0 	bl	80039ec <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
 8004c8c:	bf00      	nop
 8004c8e:	3710      	adds	r7, #16
 8004c90:	46bd      	mov	sp, r7
 8004c92:	bd80      	pop	{r7, pc}
 8004c94:	08004c9d 	.word	0x08004c9d
 8004c98:	ffff0000 	.word	0xffff0000

08004c9c <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
 8004c9c:	b580      	push	{r7, lr}
 8004c9e:	b086      	sub	sp, #24
 8004ca0:	af00      	add	r7, sp, #0
 8004ca2:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8004ca4:	2300      	movs	r3, #0
 8004ca6:	60fb      	str	r3, [r7, #12]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
 8004ca8:	687b      	ldr	r3, [r7, #4]
 8004caa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004cac:	617b      	str	r3, [r7, #20]

  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8004cae:	697b      	ldr	r3, [r7, #20]
 8004cb0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8004cb4:	74fb      	strb	r3, [r7, #19]

  /* During abort treatment, check that there is no pending STOP request */
  /* Wait until STOP flag is reset */
  count = I2C_TIMEOUT_FLAG * (SystemCoreClock / 25U / 1000U);
 8004cb6:	4b4b      	ldr	r3, [pc, #300]	; (8004de4 <I2C_DMAAbort+0x148>)
 8004cb8:	681b      	ldr	r3, [r3, #0]
 8004cba:	08db      	lsrs	r3, r3, #3
 8004cbc:	4a4a      	ldr	r2, [pc, #296]	; (8004de8 <I2C_DMAAbort+0x14c>)
 8004cbe:	fba2 2303 	umull	r2, r3, r2, r3
 8004cc2:	0a1a      	lsrs	r2, r3, #8
 8004cc4:	4613      	mov	r3, r2
 8004cc6:	009b      	lsls	r3, r3, #2
 8004cc8:	4413      	add	r3, r2
 8004cca:	00da      	lsls	r2, r3, #3
 8004ccc:	1ad3      	subs	r3, r2, r3
 8004cce:	60fb      	str	r3, [r7, #12]
  do
  {
    if (count == 0U)
 8004cd0:	68fb      	ldr	r3, [r7, #12]
 8004cd2:	2b00      	cmp	r3, #0
 8004cd4:	d106      	bne.n	8004ce4 <I2C_DMAAbort+0x48>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8004cd6:	697b      	ldr	r3, [r7, #20]
 8004cd8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004cda:	f043 0220 	orr.w	r2, r3, #32
 8004cde:	697b      	ldr	r3, [r7, #20]
 8004ce0:	641a      	str	r2, [r3, #64]	; 0x40
      break;
 8004ce2:	e00a      	b.n	8004cfa <I2C_DMAAbort+0x5e>
    }
    count--;
 8004ce4:	68fb      	ldr	r3, [r7, #12]
 8004ce6:	3b01      	subs	r3, #1
 8004ce8:	60fb      	str	r3, [r7, #12]
  }
  while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
 8004cea:	697b      	ldr	r3, [r7, #20]
 8004cec:	681b      	ldr	r3, [r3, #0]
 8004cee:	681b      	ldr	r3, [r3, #0]
 8004cf0:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8004cf4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004cf8:	d0ea      	beq.n	8004cd0 <I2C_DMAAbort+0x34>

  /* Clear Complete callback */
  if (hi2c->hdmatx != NULL)
 8004cfa:	697b      	ldr	r3, [r7, #20]
 8004cfc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004cfe:	2b00      	cmp	r3, #0
 8004d00:	d003      	beq.n	8004d0a <I2C_DMAAbort+0x6e>
  {
    hi2c->hdmatx->XferCpltCallback = NULL;
 8004d02:	697b      	ldr	r3, [r7, #20]
 8004d04:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004d06:	2200      	movs	r2, #0
 8004d08:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  if (hi2c->hdmarx != NULL)
 8004d0a:	697b      	ldr	r3, [r7, #20]
 8004d0c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004d0e:	2b00      	cmp	r3, #0
 8004d10:	d003      	beq.n	8004d1a <I2C_DMAAbort+0x7e>
  {
    hi2c->hdmarx->XferCpltCallback = NULL;
 8004d12:	697b      	ldr	r3, [r7, #20]
 8004d14:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004d16:	2200      	movs	r2, #0
 8004d18:	63da      	str	r2, [r3, #60]	; 0x3c
  }

  /* Disable Acknowledge */
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8004d1a:	697b      	ldr	r3, [r7, #20]
 8004d1c:	681b      	ldr	r3, [r3, #0]
 8004d1e:	681a      	ldr	r2, [r3, #0]
 8004d20:	697b      	ldr	r3, [r7, #20]
 8004d22:	681b      	ldr	r3, [r3, #0]
 8004d24:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8004d28:	601a      	str	r2, [r3, #0]

  hi2c->XferCount = 0U;
 8004d2a:	697b      	ldr	r3, [r7, #20]
 8004d2c:	2200      	movs	r2, #0
 8004d2e:	855a      	strh	r2, [r3, #42]	; 0x2a

  /* Reset XferAbortCallback */
  if (hi2c->hdmatx != NULL)
 8004d30:	697b      	ldr	r3, [r7, #20]
 8004d32:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004d34:	2b00      	cmp	r3, #0
 8004d36:	d003      	beq.n	8004d40 <I2C_DMAAbort+0xa4>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
 8004d38:	697b      	ldr	r3, [r7, #20]
 8004d3a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004d3c:	2200      	movs	r2, #0
 8004d3e:	651a      	str	r2, [r3, #80]	; 0x50
  }
  if (hi2c->hdmarx != NULL)
 8004d40:	697b      	ldr	r3, [r7, #20]
 8004d42:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004d44:	2b00      	cmp	r3, #0
 8004d46:	d003      	beq.n	8004d50 <I2C_DMAAbort+0xb4>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
 8004d48:	697b      	ldr	r3, [r7, #20]
 8004d4a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004d4c:	2200      	movs	r2, #0
 8004d4e:	651a      	str	r2, [r3, #80]	; 0x50
  }

  /* Disable I2C peripheral to prevent dummy data in buffer */
  __HAL_I2C_DISABLE(hi2c);
 8004d50:	697b      	ldr	r3, [r7, #20]
 8004d52:	681b      	ldr	r3, [r3, #0]
 8004d54:	681a      	ldr	r2, [r3, #0]
 8004d56:	697b      	ldr	r3, [r7, #20]
 8004d58:	681b      	ldr	r3, [r3, #0]
 8004d5a:	f022 0201 	bic.w	r2, r2, #1
 8004d5e:	601a      	str	r2, [r3, #0]

  /* Check if come from abort from user */
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8004d60:	697b      	ldr	r3, [r7, #20]
 8004d62:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8004d66:	b2db      	uxtb	r3, r3
 8004d68:	2b60      	cmp	r3, #96	; 0x60
 8004d6a:	d10e      	bne.n	8004d8a <I2C_DMAAbort+0xee>
  {
    hi2c->State         = HAL_I2C_STATE_READY;
 8004d6c:	697b      	ldr	r3, [r7, #20]
 8004d6e:	2220      	movs	r2, #32
 8004d70:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8004d74:	697b      	ldr	r3, [r7, #20]
 8004d76:	2200      	movs	r2, #0
 8004d78:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
    hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
 8004d7c:	697b      	ldr	r3, [r7, #20]
 8004d7e:	2200      	movs	r2, #0
 8004d80:	641a      	str	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
 8004d82:	6978      	ldr	r0, [r7, #20]
 8004d84:	f7fe fe3c 	bl	8003a00 <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
 8004d88:	e027      	b.n	8004dda <I2C_DMAAbort+0x13e>
    if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8004d8a:	7cfb      	ldrb	r3, [r7, #19]
 8004d8c:	f003 0328 	and.w	r3, r3, #40	; 0x28
 8004d90:	2b28      	cmp	r3, #40	; 0x28
 8004d92:	d117      	bne.n	8004dc4 <I2C_DMAAbort+0x128>
      __HAL_I2C_ENABLE(hi2c);
 8004d94:	697b      	ldr	r3, [r7, #20]
 8004d96:	681b      	ldr	r3, [r3, #0]
 8004d98:	681a      	ldr	r2, [r3, #0]
 8004d9a:	697b      	ldr	r3, [r7, #20]
 8004d9c:	681b      	ldr	r3, [r3, #0]
 8004d9e:	f042 0201 	orr.w	r2, r2, #1
 8004da2:	601a      	str	r2, [r3, #0]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8004da4:	697b      	ldr	r3, [r7, #20]
 8004da6:	681b      	ldr	r3, [r3, #0]
 8004da8:	681a      	ldr	r2, [r3, #0]
 8004daa:	697b      	ldr	r3, [r7, #20]
 8004dac:	681b      	ldr	r3, [r3, #0]
 8004dae:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8004db2:	601a      	str	r2, [r3, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 8004db4:	697b      	ldr	r3, [r7, #20]
 8004db6:	2200      	movs	r2, #0
 8004db8:	631a      	str	r2, [r3, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8004dba:	697b      	ldr	r3, [r7, #20]
 8004dbc:	2228      	movs	r2, #40	; 0x28
 8004dbe:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8004dc2:	e007      	b.n	8004dd4 <I2C_DMAAbort+0x138>
      hi2c->State = HAL_I2C_STATE_READY;
 8004dc4:	697b      	ldr	r3, [r7, #20]
 8004dc6:	2220      	movs	r2, #32
 8004dc8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8004dcc:	697b      	ldr	r3, [r7, #20]
 8004dce:	2200      	movs	r2, #0
 8004dd0:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
    HAL_I2C_ErrorCallback(hi2c);
 8004dd4:	6978      	ldr	r0, [r7, #20]
 8004dd6:	f022 fdd1 	bl	802797c <HAL_I2C_ErrorCallback>
}
 8004dda:	bf00      	nop
 8004ddc:	3718      	adds	r7, #24
 8004dde:	46bd      	mov	sp, r7
 8004de0:	bd80      	pop	{r7, pc}
 8004de2:	bf00      	nop
 8004de4:	20000000 	.word	0x20000000
 8004de8:	14f8b589 	.word	0x14f8b589

08004dec <I2C_WaitOnSTOPRequestThroughIT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPRequestThroughIT(I2C_HandleTypeDef *hi2c)
{
 8004dec:	b480      	push	{r7}
 8004dee:	b085      	sub	sp, #20
 8004df0:	af00      	add	r7, sp, #0
 8004df2:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8004df4:	2300      	movs	r3, #0
 8004df6:	60fb      	str	r3, [r7, #12]

  /* Wait until STOP flag is reset */
  count = I2C_TIMEOUT_STOP_FLAG * (SystemCoreClock / 25U / 1000U);
 8004df8:	4b13      	ldr	r3, [pc, #76]	; (8004e48 <I2C_WaitOnSTOPRequestThroughIT+0x5c>)
 8004dfa:	681b      	ldr	r3, [r3, #0]
 8004dfc:	08db      	lsrs	r3, r3, #3
 8004dfe:	4a13      	ldr	r2, [pc, #76]	; (8004e4c <I2C_WaitOnSTOPRequestThroughIT+0x60>)
 8004e00:	fba2 2303 	umull	r2, r3, r2, r3
 8004e04:	0a1a      	lsrs	r2, r3, #8
 8004e06:	4613      	mov	r3, r2
 8004e08:	009b      	lsls	r3, r3, #2
 8004e0a:	4413      	add	r3, r2
 8004e0c:	60fb      	str	r3, [r7, #12]
  do
  {
    count--;
 8004e0e:	68fb      	ldr	r3, [r7, #12]
 8004e10:	3b01      	subs	r3, #1
 8004e12:	60fb      	str	r3, [r7, #12]
    if (count == 0U)
 8004e14:	68fb      	ldr	r3, [r7, #12]
 8004e16:	2b00      	cmp	r3, #0
 8004e18:	d107      	bne.n	8004e2a <I2C_WaitOnSTOPRequestThroughIT+0x3e>
    {
      hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 8004e1a:	687b      	ldr	r3, [r7, #4]
 8004e1c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004e1e:	f043 0220 	orr.w	r2, r3, #32
 8004e22:	687b      	ldr	r3, [r7, #4]
 8004e24:	641a      	str	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
 8004e26:	2301      	movs	r3, #1
 8004e28:	e008      	b.n	8004e3c <I2C_WaitOnSTOPRequestThroughIT+0x50>
    }
  }
  while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
 8004e2a:	687b      	ldr	r3, [r7, #4]
 8004e2c:	681b      	ldr	r3, [r3, #0]
 8004e2e:	681b      	ldr	r3, [r3, #0]
 8004e30:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8004e34:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004e38:	d0e9      	beq.n	8004e0e <I2C_WaitOnSTOPRequestThroughIT+0x22>

  return HAL_OK;
 8004e3a:	2300      	movs	r3, #0
}
 8004e3c:	4618      	mov	r0, r3
 8004e3e:	3714      	adds	r7, #20
 8004e40:	46bd      	mov	sp, r7
 8004e42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004e46:	4770      	bx	lr
 8004e48:	20000000 	.word	0x20000000
 8004e4c:	14f8b589 	.word	0x14f8b589

08004e50 <I2C_ConvertOtherXferOptions>:
  * @brief  Convert I2Cx OTHER_xxx XferOptions to functionnal XferOptions.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
 8004e50:	b480      	push	{r7}
 8004e52:	b083      	sub	sp, #12
 8004e54:	af00      	add	r7, sp, #0
 8004e56:	6078      	str	r0, [r7, #4]
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
 8004e58:	687b      	ldr	r3, [r7, #4]
 8004e5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004e5c:	f5b3 0f2a 	cmp.w	r3, #11141120	; 0xaa0000
 8004e60:	d103      	bne.n	8004e6a <I2C_ConvertOtherXferOptions+0x1a>
  {
    hi2c->XferOptions = I2C_FIRST_FRAME;
 8004e62:	687b      	ldr	r3, [r7, #4]
 8004e64:	2201      	movs	r2, #1
 8004e66:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  else
  {
    /* Nothing to do */
  }
}
 8004e68:	e007      	b.n	8004e7a <I2C_ConvertOtherXferOptions+0x2a>
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
 8004e6a:	687b      	ldr	r3, [r7, #4]
 8004e6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004e6e:	f1b3 4f2a 	cmp.w	r3, #2852126720	; 0xaa000000
 8004e72:	d102      	bne.n	8004e7a <I2C_ConvertOtherXferOptions+0x2a>
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
 8004e74:	687b      	ldr	r3, [r7, #4]
 8004e76:	2208      	movs	r2, #8
 8004e78:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8004e7a:	bf00      	nop
 8004e7c:	370c      	adds	r7, #12
 8004e7e:	46bd      	mov	sp, r7
 8004e80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004e84:	4770      	bx	lr

08004e86 <HAL_I2S_IRQHandler>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
void HAL_I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 8004e86:	b580      	push	{r7, lr}
 8004e88:	b082      	sub	sp, #8
 8004e8a:	af00      	add	r7, sp, #0
 8004e8c:	6078      	str	r0, [r7, #4]
  /* Call the IrqHandler ISR set during HAL_I2S_INIT */
  hi2s->IrqHandlerISR(hi2s);
 8004e8e:	687b      	ldr	r3, [r7, #4]
 8004e90:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004e92:	6878      	ldr	r0, [r7, #4]
 8004e94:	4798      	blx	r3
}
 8004e96:	bf00      	nop
 8004e98:	3708      	adds	r7, #8
 8004e9a:	46bd      	mov	sp, r7
 8004e9c:	bd80      	pop	{r7, pc}

08004e9e <HAL_IWDG_Refresh>:
  * @param  hiwdg  pointer to a IWDG_HandleTypeDef structure that contains
  *                the configuration information for the specified IWDG module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)
{
 8004e9e:	b480      	push	{r7}
 8004ea0:	b083      	sub	sp, #12
 8004ea2:	af00      	add	r7, sp, #0
 8004ea4:	6078      	str	r0, [r7, #4]
  /* Reload IWDG counter with value defined in the reload register */
  __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 8004ea6:	687b      	ldr	r3, [r7, #4]
 8004ea8:	681b      	ldr	r3, [r3, #0]
 8004eaa:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8004eae:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
 8004eb0:	2300      	movs	r3, #0
}
 8004eb2:	4618      	mov	r0, r3
 8004eb4:	370c      	adds	r7, #12
 8004eb6:	46bd      	mov	sp, r7
 8004eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004ebc:	4770      	bx	lr
	...

08004ec0 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8004ec0:	b580      	push	{r7, lr}
 8004ec2:	b086      	sub	sp, #24
 8004ec4:	af00      	add	r7, sp, #0
 8004ec6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8004ec8:	687b      	ldr	r3, [r7, #4]
 8004eca:	2b00      	cmp	r3, #0
 8004ecc:	d101      	bne.n	8004ed2 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 8004ece:	2301      	movs	r3, #1
 8004ed0:	e25b      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8004ed2:	687b      	ldr	r3, [r7, #4]
 8004ed4:	681b      	ldr	r3, [r3, #0]
 8004ed6:	f003 0301 	and.w	r3, r3, #1
 8004eda:	2b00      	cmp	r3, #0
 8004edc:	d075      	beq.n	8004fca <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8004ede:	4ba3      	ldr	r3, [pc, #652]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004ee0:	689b      	ldr	r3, [r3, #8]
 8004ee2:	f003 030c 	and.w	r3, r3, #12
 8004ee6:	2b04      	cmp	r3, #4
 8004ee8:	d00c      	beq.n	8004f04 <HAL_RCC_OscConfig+0x44>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8004eea:	4ba0      	ldr	r3, [pc, #640]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004eec:	689b      	ldr	r3, [r3, #8]
 8004eee:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8004ef2:	2b08      	cmp	r3, #8
 8004ef4:	d112      	bne.n	8004f1c <HAL_RCC_OscConfig+0x5c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8004ef6:	4b9d      	ldr	r3, [pc, #628]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004ef8:	685b      	ldr	r3, [r3, #4]
 8004efa:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8004efe:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8004f02:	d10b      	bne.n	8004f1c <HAL_RCC_OscConfig+0x5c>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8004f04:	4b99      	ldr	r3, [pc, #612]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f06:	681b      	ldr	r3, [r3, #0]
 8004f08:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004f0c:	2b00      	cmp	r3, #0
 8004f0e:	d05b      	beq.n	8004fc8 <HAL_RCC_OscConfig+0x108>
 8004f10:	687b      	ldr	r3, [r7, #4]
 8004f12:	685b      	ldr	r3, [r3, #4]
 8004f14:	2b00      	cmp	r3, #0
 8004f16:	d157      	bne.n	8004fc8 <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 8004f18:	2301      	movs	r3, #1
 8004f1a:	e236      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004f1c:	687b      	ldr	r3, [r7, #4]
 8004f1e:	685b      	ldr	r3, [r3, #4]
 8004f20:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8004f24:	d106      	bne.n	8004f34 <HAL_RCC_OscConfig+0x74>
 8004f26:	4b91      	ldr	r3, [pc, #580]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f28:	681b      	ldr	r3, [r3, #0]
 8004f2a:	4a90      	ldr	r2, [pc, #576]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f2c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004f30:	6013      	str	r3, [r2, #0]
 8004f32:	e01d      	b.n	8004f70 <HAL_RCC_OscConfig+0xb0>
 8004f34:	687b      	ldr	r3, [r7, #4]
 8004f36:	685b      	ldr	r3, [r3, #4]
 8004f38:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8004f3c:	d10c      	bne.n	8004f58 <HAL_RCC_OscConfig+0x98>
 8004f3e:	4b8b      	ldr	r3, [pc, #556]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f40:	681b      	ldr	r3, [r3, #0]
 8004f42:	4a8a      	ldr	r2, [pc, #552]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f44:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8004f48:	6013      	str	r3, [r2, #0]
 8004f4a:	4b88      	ldr	r3, [pc, #544]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f4c:	681b      	ldr	r3, [r3, #0]
 8004f4e:	4a87      	ldr	r2, [pc, #540]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f50:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004f54:	6013      	str	r3, [r2, #0]
 8004f56:	e00b      	b.n	8004f70 <HAL_RCC_OscConfig+0xb0>
 8004f58:	4b84      	ldr	r3, [pc, #528]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f5a:	681b      	ldr	r3, [r3, #0]
 8004f5c:	4a83      	ldr	r2, [pc, #524]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f5e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004f62:	6013      	str	r3, [r2, #0]
 8004f64:	4b81      	ldr	r3, [pc, #516]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f66:	681b      	ldr	r3, [r3, #0]
 8004f68:	4a80      	ldr	r2, [pc, #512]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f6a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8004f6e:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8004f70:	687b      	ldr	r3, [r7, #4]
 8004f72:	685b      	ldr	r3, [r3, #4]
 8004f74:	2b00      	cmp	r3, #0
 8004f76:	d013      	beq.n	8004fa0 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004f78:	f7fd f880 	bl	800207c <HAL_GetTick>
 8004f7c:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004f7e:	e008      	b.n	8004f92 <HAL_RCC_OscConfig+0xd2>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8004f80:	f7fd f87c 	bl	800207c <HAL_GetTick>
 8004f84:	4602      	mov	r2, r0
 8004f86:	693b      	ldr	r3, [r7, #16]
 8004f88:	1ad3      	subs	r3, r2, r3
 8004f8a:	2b64      	cmp	r3, #100	; 0x64
 8004f8c:	d901      	bls.n	8004f92 <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 8004f8e:	2303      	movs	r3, #3
 8004f90:	e1fb      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004f92:	4b76      	ldr	r3, [pc, #472]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004f94:	681b      	ldr	r3, [r3, #0]
 8004f96:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004f9a:	2b00      	cmp	r3, #0
 8004f9c:	d0f0      	beq.n	8004f80 <HAL_RCC_OscConfig+0xc0>
 8004f9e:	e014      	b.n	8004fca <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004fa0:	f7fd f86c 	bl	800207c <HAL_GetTick>
 8004fa4:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8004fa6:	e008      	b.n	8004fba <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8004fa8:	f7fd f868 	bl	800207c <HAL_GetTick>
 8004fac:	4602      	mov	r2, r0
 8004fae:	693b      	ldr	r3, [r7, #16]
 8004fb0:	1ad3      	subs	r3, r2, r3
 8004fb2:	2b64      	cmp	r3, #100	; 0x64
 8004fb4:	d901      	bls.n	8004fba <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 8004fb6:	2303      	movs	r3, #3
 8004fb8:	e1e7      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8004fba:	4b6c      	ldr	r3, [pc, #432]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004fbc:	681b      	ldr	r3, [r3, #0]
 8004fbe:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004fc2:	2b00      	cmp	r3, #0
 8004fc4:	d1f0      	bne.n	8004fa8 <HAL_RCC_OscConfig+0xe8>
 8004fc6:	e000      	b.n	8004fca <HAL_RCC_OscConfig+0x10a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8004fc8:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8004fca:	687b      	ldr	r3, [r7, #4]
 8004fcc:	681b      	ldr	r3, [r3, #0]
 8004fce:	f003 0302 	and.w	r3, r3, #2
 8004fd2:	2b00      	cmp	r3, #0
 8004fd4:	d063      	beq.n	800509e <HAL_RCC_OscConfig+0x1de>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8004fd6:	4b65      	ldr	r3, [pc, #404]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004fd8:	689b      	ldr	r3, [r3, #8]
 8004fda:	f003 030c 	and.w	r3, r3, #12
 8004fde:	2b00      	cmp	r3, #0
 8004fe0:	d00b      	beq.n	8004ffa <HAL_RCC_OscConfig+0x13a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8004fe2:	4b62      	ldr	r3, [pc, #392]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004fe4:	689b      	ldr	r3, [r3, #8]
 8004fe6:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8004fea:	2b08      	cmp	r3, #8
 8004fec:	d11c      	bne.n	8005028 <HAL_RCC_OscConfig+0x168>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8004fee:	4b5f      	ldr	r3, [pc, #380]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004ff0:	685b      	ldr	r3, [r3, #4]
 8004ff2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8004ff6:	2b00      	cmp	r3, #0
 8004ff8:	d116      	bne.n	8005028 <HAL_RCC_OscConfig+0x168>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8004ffa:	4b5c      	ldr	r3, [pc, #368]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8004ffc:	681b      	ldr	r3, [r3, #0]
 8004ffe:	f003 0302 	and.w	r3, r3, #2
 8005002:	2b00      	cmp	r3, #0
 8005004:	d005      	beq.n	8005012 <HAL_RCC_OscConfig+0x152>
 8005006:	687b      	ldr	r3, [r7, #4]
 8005008:	68db      	ldr	r3, [r3, #12]
 800500a:	2b01      	cmp	r3, #1
 800500c:	d001      	beq.n	8005012 <HAL_RCC_OscConfig+0x152>
      {
        return HAL_ERROR;
 800500e:	2301      	movs	r3, #1
 8005010:	e1bb      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8005012:	4b56      	ldr	r3, [pc, #344]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8005014:	681b      	ldr	r3, [r3, #0]
 8005016:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800501a:	687b      	ldr	r3, [r7, #4]
 800501c:	691b      	ldr	r3, [r3, #16]
 800501e:	00db      	lsls	r3, r3, #3
 8005020:	4952      	ldr	r1, [pc, #328]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8005022:	4313      	orrs	r3, r2
 8005024:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8005026:	e03a      	b.n	800509e <HAL_RCC_OscConfig+0x1de>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8005028:	687b      	ldr	r3, [r7, #4]
 800502a:	68db      	ldr	r3, [r3, #12]
 800502c:	2b00      	cmp	r3, #0
 800502e:	d020      	beq.n	8005072 <HAL_RCC_OscConfig+0x1b2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8005030:	4b4f      	ldr	r3, [pc, #316]	; (8005170 <HAL_RCC_OscConfig+0x2b0>)
 8005032:	2201      	movs	r2, #1
 8005034:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005036:	f7fd f821 	bl	800207c <HAL_GetTick>
 800503a:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800503c:	e008      	b.n	8005050 <HAL_RCC_OscConfig+0x190>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800503e:	f7fd f81d 	bl	800207c <HAL_GetTick>
 8005042:	4602      	mov	r2, r0
 8005044:	693b      	ldr	r3, [r7, #16]
 8005046:	1ad3      	subs	r3, r2, r3
 8005048:	2b02      	cmp	r3, #2
 800504a:	d901      	bls.n	8005050 <HAL_RCC_OscConfig+0x190>
          {
            return HAL_TIMEOUT;
 800504c:	2303      	movs	r3, #3
 800504e:	e19c      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8005050:	4b46      	ldr	r3, [pc, #280]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8005052:	681b      	ldr	r3, [r3, #0]
 8005054:	f003 0302 	and.w	r3, r3, #2
 8005058:	2b00      	cmp	r3, #0
 800505a:	d0f0      	beq.n	800503e <HAL_RCC_OscConfig+0x17e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800505c:	4b43      	ldr	r3, [pc, #268]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 800505e:	681b      	ldr	r3, [r3, #0]
 8005060:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8005064:	687b      	ldr	r3, [r7, #4]
 8005066:	691b      	ldr	r3, [r3, #16]
 8005068:	00db      	lsls	r3, r3, #3
 800506a:	4940      	ldr	r1, [pc, #256]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 800506c:	4313      	orrs	r3, r2
 800506e:	600b      	str	r3, [r1, #0]
 8005070:	e015      	b.n	800509e <HAL_RCC_OscConfig+0x1de>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8005072:	4b3f      	ldr	r3, [pc, #252]	; (8005170 <HAL_RCC_OscConfig+0x2b0>)
 8005074:	2200      	movs	r2, #0
 8005076:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005078:	f7fd f800 	bl	800207c <HAL_GetTick>
 800507c:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800507e:	e008      	b.n	8005092 <HAL_RCC_OscConfig+0x1d2>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8005080:	f7fc fffc 	bl	800207c <HAL_GetTick>
 8005084:	4602      	mov	r2, r0
 8005086:	693b      	ldr	r3, [r7, #16]
 8005088:	1ad3      	subs	r3, r2, r3
 800508a:	2b02      	cmp	r3, #2
 800508c:	d901      	bls.n	8005092 <HAL_RCC_OscConfig+0x1d2>
          {
            return HAL_TIMEOUT;
 800508e:	2303      	movs	r3, #3
 8005090:	e17b      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8005092:	4b36      	ldr	r3, [pc, #216]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8005094:	681b      	ldr	r3, [r3, #0]
 8005096:	f003 0302 	and.w	r3, r3, #2
 800509a:	2b00      	cmp	r3, #0
 800509c:	d1f0      	bne.n	8005080 <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800509e:	687b      	ldr	r3, [r7, #4]
 80050a0:	681b      	ldr	r3, [r3, #0]
 80050a2:	f003 0308 	and.w	r3, r3, #8
 80050a6:	2b00      	cmp	r3, #0
 80050a8:	d030      	beq.n	800510c <HAL_RCC_OscConfig+0x24c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80050aa:	687b      	ldr	r3, [r7, #4]
 80050ac:	695b      	ldr	r3, [r3, #20]
 80050ae:	2b00      	cmp	r3, #0
 80050b0:	d016      	beq.n	80050e0 <HAL_RCC_OscConfig+0x220>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80050b2:	4b30      	ldr	r3, [pc, #192]	; (8005174 <HAL_RCC_OscConfig+0x2b4>)
 80050b4:	2201      	movs	r2, #1
 80050b6:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80050b8:	f7fc ffe0 	bl	800207c <HAL_GetTick>
 80050bc:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80050be:	e008      	b.n	80050d2 <HAL_RCC_OscConfig+0x212>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80050c0:	f7fc ffdc 	bl	800207c <HAL_GetTick>
 80050c4:	4602      	mov	r2, r0
 80050c6:	693b      	ldr	r3, [r7, #16]
 80050c8:	1ad3      	subs	r3, r2, r3
 80050ca:	2b02      	cmp	r3, #2
 80050cc:	d901      	bls.n	80050d2 <HAL_RCC_OscConfig+0x212>
        {
          return HAL_TIMEOUT;
 80050ce:	2303      	movs	r3, #3
 80050d0:	e15b      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80050d2:	4b26      	ldr	r3, [pc, #152]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 80050d4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80050d6:	f003 0302 	and.w	r3, r3, #2
 80050da:	2b00      	cmp	r3, #0
 80050dc:	d0f0      	beq.n	80050c0 <HAL_RCC_OscConfig+0x200>
 80050de:	e015      	b.n	800510c <HAL_RCC_OscConfig+0x24c>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80050e0:	4b24      	ldr	r3, [pc, #144]	; (8005174 <HAL_RCC_OscConfig+0x2b4>)
 80050e2:	2200      	movs	r2, #0
 80050e4:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 80050e6:	f7fc ffc9 	bl	800207c <HAL_GetTick>
 80050ea:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80050ec:	e008      	b.n	8005100 <HAL_RCC_OscConfig+0x240>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80050ee:	f7fc ffc5 	bl	800207c <HAL_GetTick>
 80050f2:	4602      	mov	r2, r0
 80050f4:	693b      	ldr	r3, [r7, #16]
 80050f6:	1ad3      	subs	r3, r2, r3
 80050f8:	2b02      	cmp	r3, #2
 80050fa:	d901      	bls.n	8005100 <HAL_RCC_OscConfig+0x240>
        {
          return HAL_TIMEOUT;
 80050fc:	2303      	movs	r3, #3
 80050fe:	e144      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8005100:	4b1a      	ldr	r3, [pc, #104]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8005102:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8005104:	f003 0302 	and.w	r3, r3, #2
 8005108:	2b00      	cmp	r3, #0
 800510a:	d1f0      	bne.n	80050ee <HAL_RCC_OscConfig+0x22e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800510c:	687b      	ldr	r3, [r7, #4]
 800510e:	681b      	ldr	r3, [r3, #0]
 8005110:	f003 0304 	and.w	r3, r3, #4
 8005114:	2b00      	cmp	r3, #0
 8005116:	f000 80a0 	beq.w	800525a <HAL_RCC_OscConfig+0x39a>
  {
    FlagStatus       pwrclkchanged = RESET;
 800511a:	2300      	movs	r3, #0
 800511c:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800511e:	4b13      	ldr	r3, [pc, #76]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8005120:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005122:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8005126:	2b00      	cmp	r3, #0
 8005128:	d10f      	bne.n	800514a <HAL_RCC_OscConfig+0x28a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800512a:	2300      	movs	r3, #0
 800512c:	60bb      	str	r3, [r7, #8]
 800512e:	4b0f      	ldr	r3, [pc, #60]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8005130:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005132:	4a0e      	ldr	r2, [pc, #56]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 8005134:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005138:	6413      	str	r3, [r2, #64]	; 0x40
 800513a:	4b0c      	ldr	r3, [pc, #48]	; (800516c <HAL_RCC_OscConfig+0x2ac>)
 800513c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800513e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8005142:	60bb      	str	r3, [r7, #8]
 8005144:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 8005146:	2301      	movs	r3, #1
 8005148:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800514a:	4b0b      	ldr	r3, [pc, #44]	; (8005178 <HAL_RCC_OscConfig+0x2b8>)
 800514c:	681b      	ldr	r3, [r3, #0]
 800514e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8005152:	2b00      	cmp	r3, #0
 8005154:	d121      	bne.n	800519a <HAL_RCC_OscConfig+0x2da>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8005156:	4b08      	ldr	r3, [pc, #32]	; (8005178 <HAL_RCC_OscConfig+0x2b8>)
 8005158:	681b      	ldr	r3, [r3, #0]
 800515a:	4a07      	ldr	r2, [pc, #28]	; (8005178 <HAL_RCC_OscConfig+0x2b8>)
 800515c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005160:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8005162:	f7fc ff8b 	bl	800207c <HAL_GetTick>
 8005166:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8005168:	e011      	b.n	800518e <HAL_RCC_OscConfig+0x2ce>
 800516a:	bf00      	nop
 800516c:	40023800 	.word	0x40023800
 8005170:	42470000 	.word	0x42470000
 8005174:	42470e80 	.word	0x42470e80
 8005178:	40007000 	.word	0x40007000
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800517c:	f7fc ff7e 	bl	800207c <HAL_GetTick>
 8005180:	4602      	mov	r2, r0
 8005182:	693b      	ldr	r3, [r7, #16]
 8005184:	1ad3      	subs	r3, r2, r3
 8005186:	2b02      	cmp	r3, #2
 8005188:	d901      	bls.n	800518e <HAL_RCC_OscConfig+0x2ce>
        {
          return HAL_TIMEOUT;
 800518a:	2303      	movs	r3, #3
 800518c:	e0fd      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800518e:	4b81      	ldr	r3, [pc, #516]	; (8005394 <HAL_RCC_OscConfig+0x4d4>)
 8005190:	681b      	ldr	r3, [r3, #0]
 8005192:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8005196:	2b00      	cmp	r3, #0
 8005198:	d0f0      	beq.n	800517c <HAL_RCC_OscConfig+0x2bc>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800519a:	687b      	ldr	r3, [r7, #4]
 800519c:	689b      	ldr	r3, [r3, #8]
 800519e:	2b01      	cmp	r3, #1
 80051a0:	d106      	bne.n	80051b0 <HAL_RCC_OscConfig+0x2f0>
 80051a2:	4b7d      	ldr	r3, [pc, #500]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80051a4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80051a6:	4a7c      	ldr	r2, [pc, #496]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80051a8:	f043 0301 	orr.w	r3, r3, #1
 80051ac:	6713      	str	r3, [r2, #112]	; 0x70
 80051ae:	e01c      	b.n	80051ea <HAL_RCC_OscConfig+0x32a>
 80051b0:	687b      	ldr	r3, [r7, #4]
 80051b2:	689b      	ldr	r3, [r3, #8]
 80051b4:	2b05      	cmp	r3, #5
 80051b6:	d10c      	bne.n	80051d2 <HAL_RCC_OscConfig+0x312>
 80051b8:	4b77      	ldr	r3, [pc, #476]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80051ba:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80051bc:	4a76      	ldr	r2, [pc, #472]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80051be:	f043 0304 	orr.w	r3, r3, #4
 80051c2:	6713      	str	r3, [r2, #112]	; 0x70
 80051c4:	4b74      	ldr	r3, [pc, #464]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80051c6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80051c8:	4a73      	ldr	r2, [pc, #460]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80051ca:	f043 0301 	orr.w	r3, r3, #1
 80051ce:	6713      	str	r3, [r2, #112]	; 0x70
 80051d0:	e00b      	b.n	80051ea <HAL_RCC_OscConfig+0x32a>
 80051d2:	4b71      	ldr	r3, [pc, #452]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80051d4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80051d6:	4a70      	ldr	r2, [pc, #448]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80051d8:	f023 0301 	bic.w	r3, r3, #1
 80051dc:	6713      	str	r3, [r2, #112]	; 0x70
 80051de:	4b6e      	ldr	r3, [pc, #440]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80051e0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80051e2:	4a6d      	ldr	r2, [pc, #436]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80051e4:	f023 0304 	bic.w	r3, r3, #4
 80051e8:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80051ea:	687b      	ldr	r3, [r7, #4]
 80051ec:	689b      	ldr	r3, [r3, #8]
 80051ee:	2b00      	cmp	r3, #0
 80051f0:	d015      	beq.n	800521e <HAL_RCC_OscConfig+0x35e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80051f2:	f7fc ff43 	bl	800207c <HAL_GetTick>
 80051f6:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80051f8:	e00a      	b.n	8005210 <HAL_RCC_OscConfig+0x350>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80051fa:	f7fc ff3f 	bl	800207c <HAL_GetTick>
 80051fe:	4602      	mov	r2, r0
 8005200:	693b      	ldr	r3, [r7, #16]
 8005202:	1ad3      	subs	r3, r2, r3
 8005204:	f241 3288 	movw	r2, #5000	; 0x1388
 8005208:	4293      	cmp	r3, r2
 800520a:	d901      	bls.n	8005210 <HAL_RCC_OscConfig+0x350>
        {
          return HAL_TIMEOUT;
 800520c:	2303      	movs	r3, #3
 800520e:	e0bc      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8005210:	4b61      	ldr	r3, [pc, #388]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 8005212:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005214:	f003 0302 	and.w	r3, r3, #2
 8005218:	2b00      	cmp	r3, #0
 800521a:	d0ee      	beq.n	80051fa <HAL_RCC_OscConfig+0x33a>
 800521c:	e014      	b.n	8005248 <HAL_RCC_OscConfig+0x388>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800521e:	f7fc ff2d 	bl	800207c <HAL_GetTick>
 8005222:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8005224:	e00a      	b.n	800523c <HAL_RCC_OscConfig+0x37c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8005226:	f7fc ff29 	bl	800207c <HAL_GetTick>
 800522a:	4602      	mov	r2, r0
 800522c:	693b      	ldr	r3, [r7, #16]
 800522e:	1ad3      	subs	r3, r2, r3
 8005230:	f241 3288 	movw	r2, #5000	; 0x1388
 8005234:	4293      	cmp	r3, r2
 8005236:	d901      	bls.n	800523c <HAL_RCC_OscConfig+0x37c>
        {
          return HAL_TIMEOUT;
 8005238:	2303      	movs	r3, #3
 800523a:	e0a6      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800523c:	4b56      	ldr	r3, [pc, #344]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 800523e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005240:	f003 0302 	and.w	r3, r3, #2
 8005244:	2b00      	cmp	r3, #0
 8005246:	d1ee      	bne.n	8005226 <HAL_RCC_OscConfig+0x366>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8005248:	7dfb      	ldrb	r3, [r7, #23]
 800524a:	2b01      	cmp	r3, #1
 800524c:	d105      	bne.n	800525a <HAL_RCC_OscConfig+0x39a>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800524e:	4b52      	ldr	r3, [pc, #328]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 8005250:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005252:	4a51      	ldr	r2, [pc, #324]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 8005254:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8005258:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800525a:	687b      	ldr	r3, [r7, #4]
 800525c:	699b      	ldr	r3, [r3, #24]
 800525e:	2b00      	cmp	r3, #0
 8005260:	f000 8092 	beq.w	8005388 <HAL_RCC_OscConfig+0x4c8>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8005264:	4b4c      	ldr	r3, [pc, #304]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 8005266:	689b      	ldr	r3, [r3, #8]
 8005268:	f003 030c 	and.w	r3, r3, #12
 800526c:	2b08      	cmp	r3, #8
 800526e:	d05c      	beq.n	800532a <HAL_RCC_OscConfig+0x46a>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8005270:	687b      	ldr	r3, [r7, #4]
 8005272:	699b      	ldr	r3, [r3, #24]
 8005274:	2b02      	cmp	r3, #2
 8005276:	d141      	bne.n	80052fc <HAL_RCC_OscConfig+0x43c>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8005278:	4b48      	ldr	r3, [pc, #288]	; (800539c <HAL_RCC_OscConfig+0x4dc>)
 800527a:	2200      	movs	r2, #0
 800527c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800527e:	f7fc fefd 	bl	800207c <HAL_GetTick>
 8005282:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8005284:	e008      	b.n	8005298 <HAL_RCC_OscConfig+0x3d8>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8005286:	f7fc fef9 	bl	800207c <HAL_GetTick>
 800528a:	4602      	mov	r2, r0
 800528c:	693b      	ldr	r3, [r7, #16]
 800528e:	1ad3      	subs	r3, r2, r3
 8005290:	2b02      	cmp	r3, #2
 8005292:	d901      	bls.n	8005298 <HAL_RCC_OscConfig+0x3d8>
          {
            return HAL_TIMEOUT;
 8005294:	2303      	movs	r3, #3
 8005296:	e078      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8005298:	4b3f      	ldr	r3, [pc, #252]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 800529a:	681b      	ldr	r3, [r3, #0]
 800529c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80052a0:	2b00      	cmp	r3, #0
 80052a2:	d1f0      	bne.n	8005286 <HAL_RCC_OscConfig+0x3c6>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80052a4:	687b      	ldr	r3, [r7, #4]
 80052a6:	69da      	ldr	r2, [r3, #28]
 80052a8:	687b      	ldr	r3, [r7, #4]
 80052aa:	6a1b      	ldr	r3, [r3, #32]
 80052ac:	431a      	orrs	r2, r3
 80052ae:	687b      	ldr	r3, [r7, #4]
 80052b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80052b2:	019b      	lsls	r3, r3, #6
 80052b4:	431a      	orrs	r2, r3
 80052b6:	687b      	ldr	r3, [r7, #4]
 80052b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80052ba:	085b      	lsrs	r3, r3, #1
 80052bc:	3b01      	subs	r3, #1
 80052be:	041b      	lsls	r3, r3, #16
 80052c0:	431a      	orrs	r2, r3
 80052c2:	687b      	ldr	r3, [r7, #4]
 80052c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80052c6:	061b      	lsls	r3, r3, #24
 80052c8:	4933      	ldr	r1, [pc, #204]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80052ca:	4313      	orrs	r3, r2
 80052cc:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 80052ce:	4b33      	ldr	r3, [pc, #204]	; (800539c <HAL_RCC_OscConfig+0x4dc>)
 80052d0:	2201      	movs	r2, #1
 80052d2:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80052d4:	f7fc fed2 	bl	800207c <HAL_GetTick>
 80052d8:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80052da:	e008      	b.n	80052ee <HAL_RCC_OscConfig+0x42e>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80052dc:	f7fc fece 	bl	800207c <HAL_GetTick>
 80052e0:	4602      	mov	r2, r0
 80052e2:	693b      	ldr	r3, [r7, #16]
 80052e4:	1ad3      	subs	r3, r2, r3
 80052e6:	2b02      	cmp	r3, #2
 80052e8:	d901      	bls.n	80052ee <HAL_RCC_OscConfig+0x42e>
          {
            return HAL_TIMEOUT;
 80052ea:	2303      	movs	r3, #3
 80052ec:	e04d      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80052ee:	4b2a      	ldr	r3, [pc, #168]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 80052f0:	681b      	ldr	r3, [r3, #0]
 80052f2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80052f6:	2b00      	cmp	r3, #0
 80052f8:	d0f0      	beq.n	80052dc <HAL_RCC_OscConfig+0x41c>
 80052fa:	e045      	b.n	8005388 <HAL_RCC_OscConfig+0x4c8>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80052fc:	4b27      	ldr	r3, [pc, #156]	; (800539c <HAL_RCC_OscConfig+0x4dc>)
 80052fe:	2200      	movs	r2, #0
 8005300:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8005302:	f7fc febb 	bl	800207c <HAL_GetTick>
 8005306:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8005308:	e008      	b.n	800531c <HAL_RCC_OscConfig+0x45c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800530a:	f7fc feb7 	bl	800207c <HAL_GetTick>
 800530e:	4602      	mov	r2, r0
 8005310:	693b      	ldr	r3, [r7, #16]
 8005312:	1ad3      	subs	r3, r2, r3
 8005314:	2b02      	cmp	r3, #2
 8005316:	d901      	bls.n	800531c <HAL_RCC_OscConfig+0x45c>
          {
            return HAL_TIMEOUT;
 8005318:	2303      	movs	r3, #3
 800531a:	e036      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800531c:	4b1e      	ldr	r3, [pc, #120]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 800531e:	681b      	ldr	r3, [r3, #0]
 8005320:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8005324:	2b00      	cmp	r3, #0
 8005326:	d1f0      	bne.n	800530a <HAL_RCC_OscConfig+0x44a>
 8005328:	e02e      	b.n	8005388 <HAL_RCC_OscConfig+0x4c8>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800532a:	687b      	ldr	r3, [r7, #4]
 800532c:	699b      	ldr	r3, [r3, #24]
 800532e:	2b01      	cmp	r3, #1
 8005330:	d101      	bne.n	8005336 <HAL_RCC_OscConfig+0x476>
      {
        return HAL_ERROR;
 8005332:	2301      	movs	r3, #1
 8005334:	e029      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR;
 8005336:	4b18      	ldr	r3, [pc, #96]	; (8005398 <HAL_RCC_OscConfig+0x4d8>)
 8005338:	685b      	ldr	r3, [r3, #4]
 800533a:	60fb      	str	r3, [r7, #12]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800533c:	68fb      	ldr	r3, [r7, #12]
 800533e:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
 8005342:	687b      	ldr	r3, [r7, #4]
 8005344:	69db      	ldr	r3, [r3, #28]
 8005346:	429a      	cmp	r2, r3
 8005348:	d11c      	bne.n	8005384 <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 800534a:	68fb      	ldr	r3, [r7, #12]
 800534c:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8005350:	687b      	ldr	r3, [r7, #4]
 8005352:	6a1b      	ldr	r3, [r3, #32]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8005354:	429a      	cmp	r2, r3
 8005356:	d115      	bne.n	8005384 <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 8005358:	68fa      	ldr	r2, [r7, #12]
 800535a:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800535e:	4013      	ands	r3, r2
 8005360:	687a      	ldr	r2, [r7, #4]
 8005362:	6a52      	ldr	r2, [r2, #36]	; 0x24
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8005364:	4293      	cmp	r3, r2
 8005366:	d10d      	bne.n	8005384 <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8005368:	68fb      	ldr	r3, [r7, #12]
 800536a:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 800536e:	687b      	ldr	r3, [r7, #4]
 8005370:	6a9b      	ldr	r3, [r3, #40]	; 0x28
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 8005372:	429a      	cmp	r2, r3
 8005374:	d106      	bne.n	8005384 <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ))
 8005376:	68fb      	ldr	r3, [r7, #12]
 8005378:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 800537c:	687b      	ldr	r3, [r7, #4]
 800537e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8005380:	429a      	cmp	r2, r3
 8005382:	d001      	beq.n	8005388 <HAL_RCC_OscConfig+0x4c8>
        {
          return HAL_ERROR;
 8005384:	2301      	movs	r3, #1
 8005386:	e000      	b.n	800538a <HAL_RCC_OscConfig+0x4ca>
        }
      }
    }
  }
  return HAL_OK;
 8005388:	2300      	movs	r3, #0
}
 800538a:	4618      	mov	r0, r3
 800538c:	3718      	adds	r7, #24
 800538e:	46bd      	mov	sp, r7
 8005390:	bd80      	pop	{r7, pc}
 8005392:	bf00      	nop
 8005394:	40007000 	.word	0x40007000
 8005398:	40023800 	.word	0x40023800
 800539c:	42470060 	.word	0x42470060

080053a0 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80053a0:	b580      	push	{r7, lr}
 80053a2:	b084      	sub	sp, #16
 80053a4:	af00      	add	r7, sp, #0
 80053a6:	6078      	str	r0, [r7, #4]
 80053a8:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 80053aa:	687b      	ldr	r3, [r7, #4]
 80053ac:	2b00      	cmp	r3, #0
 80053ae:	d101      	bne.n	80053b4 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 80053b0:	2301      	movs	r3, #1
 80053b2:	e0cc      	b.n	800554e <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80053b4:	4b68      	ldr	r3, [pc, #416]	; (8005558 <HAL_RCC_ClockConfig+0x1b8>)
 80053b6:	681b      	ldr	r3, [r3, #0]
 80053b8:	f003 030f 	and.w	r3, r3, #15
 80053bc:	683a      	ldr	r2, [r7, #0]
 80053be:	429a      	cmp	r2, r3
 80053c0:	d90c      	bls.n	80053dc <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80053c2:	4b65      	ldr	r3, [pc, #404]	; (8005558 <HAL_RCC_ClockConfig+0x1b8>)
 80053c4:	683a      	ldr	r2, [r7, #0]
 80053c6:	b2d2      	uxtb	r2, r2
 80053c8:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80053ca:	4b63      	ldr	r3, [pc, #396]	; (8005558 <HAL_RCC_ClockConfig+0x1b8>)
 80053cc:	681b      	ldr	r3, [r3, #0]
 80053ce:	f003 030f 	and.w	r3, r3, #15
 80053d2:	683a      	ldr	r2, [r7, #0]
 80053d4:	429a      	cmp	r2, r3
 80053d6:	d001      	beq.n	80053dc <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 80053d8:	2301      	movs	r3, #1
 80053da:	e0b8      	b.n	800554e <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80053dc:	687b      	ldr	r3, [r7, #4]
 80053de:	681b      	ldr	r3, [r3, #0]
 80053e0:	f003 0302 	and.w	r3, r3, #2
 80053e4:	2b00      	cmp	r3, #0
 80053e6:	d020      	beq.n	800542a <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80053e8:	687b      	ldr	r3, [r7, #4]
 80053ea:	681b      	ldr	r3, [r3, #0]
 80053ec:	f003 0304 	and.w	r3, r3, #4
 80053f0:	2b00      	cmp	r3, #0
 80053f2:	d005      	beq.n	8005400 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80053f4:	4b59      	ldr	r3, [pc, #356]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 80053f6:	689b      	ldr	r3, [r3, #8]
 80053f8:	4a58      	ldr	r2, [pc, #352]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 80053fa:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 80053fe:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8005400:	687b      	ldr	r3, [r7, #4]
 8005402:	681b      	ldr	r3, [r3, #0]
 8005404:	f003 0308 	and.w	r3, r3, #8
 8005408:	2b00      	cmp	r3, #0
 800540a:	d005      	beq.n	8005418 <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800540c:	4b53      	ldr	r3, [pc, #332]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 800540e:	689b      	ldr	r3, [r3, #8]
 8005410:	4a52      	ldr	r2, [pc, #328]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 8005412:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 8005416:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8005418:	4b50      	ldr	r3, [pc, #320]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 800541a:	689b      	ldr	r3, [r3, #8]
 800541c:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8005420:	687b      	ldr	r3, [r7, #4]
 8005422:	689b      	ldr	r3, [r3, #8]
 8005424:	494d      	ldr	r1, [pc, #308]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 8005426:	4313      	orrs	r3, r2
 8005428:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800542a:	687b      	ldr	r3, [r7, #4]
 800542c:	681b      	ldr	r3, [r3, #0]
 800542e:	f003 0301 	and.w	r3, r3, #1
 8005432:	2b00      	cmp	r3, #0
 8005434:	d044      	beq.n	80054c0 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8005436:	687b      	ldr	r3, [r7, #4]
 8005438:	685b      	ldr	r3, [r3, #4]
 800543a:	2b01      	cmp	r3, #1
 800543c:	d107      	bne.n	800544e <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800543e:	4b47      	ldr	r3, [pc, #284]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 8005440:	681b      	ldr	r3, [r3, #0]
 8005442:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8005446:	2b00      	cmp	r3, #0
 8005448:	d119      	bne.n	800547e <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800544a:	2301      	movs	r3, #1
 800544c:	e07f      	b.n	800554e <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800544e:	687b      	ldr	r3, [r7, #4]
 8005450:	685b      	ldr	r3, [r3, #4]
 8005452:	2b02      	cmp	r3, #2
 8005454:	d003      	beq.n	800545e <HAL_RCC_ClockConfig+0xbe>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 8005456:	687b      	ldr	r3, [r7, #4]
 8005458:	685b      	ldr	r3, [r3, #4]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800545a:	2b03      	cmp	r3, #3
 800545c:	d107      	bne.n	800546e <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800545e:	4b3f      	ldr	r3, [pc, #252]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 8005460:	681b      	ldr	r3, [r3, #0]
 8005462:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8005466:	2b00      	cmp	r3, #0
 8005468:	d109      	bne.n	800547e <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800546a:	2301      	movs	r3, #1
 800546c:	e06f      	b.n	800554e <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800546e:	4b3b      	ldr	r3, [pc, #236]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 8005470:	681b      	ldr	r3, [r3, #0]
 8005472:	f003 0302 	and.w	r3, r3, #2
 8005476:	2b00      	cmp	r3, #0
 8005478:	d101      	bne.n	800547e <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800547a:	2301      	movs	r3, #1
 800547c:	e067      	b.n	800554e <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800547e:	4b37      	ldr	r3, [pc, #220]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 8005480:	689b      	ldr	r3, [r3, #8]
 8005482:	f023 0203 	bic.w	r2, r3, #3
 8005486:	687b      	ldr	r3, [r7, #4]
 8005488:	685b      	ldr	r3, [r3, #4]
 800548a:	4934      	ldr	r1, [pc, #208]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 800548c:	4313      	orrs	r3, r2
 800548e:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8005490:	f7fc fdf4 	bl	800207c <HAL_GetTick>
 8005494:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8005496:	e00a      	b.n	80054ae <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8005498:	f7fc fdf0 	bl	800207c <HAL_GetTick>
 800549c:	4602      	mov	r2, r0
 800549e:	68fb      	ldr	r3, [r7, #12]
 80054a0:	1ad3      	subs	r3, r2, r3
 80054a2:	f241 3288 	movw	r2, #5000	; 0x1388
 80054a6:	4293      	cmp	r3, r2
 80054a8:	d901      	bls.n	80054ae <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 80054aa:	2303      	movs	r3, #3
 80054ac:	e04f      	b.n	800554e <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80054ae:	4b2b      	ldr	r3, [pc, #172]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 80054b0:	689b      	ldr	r3, [r3, #8]
 80054b2:	f003 020c 	and.w	r2, r3, #12
 80054b6:	687b      	ldr	r3, [r7, #4]
 80054b8:	685b      	ldr	r3, [r3, #4]
 80054ba:	009b      	lsls	r3, r3, #2
 80054bc:	429a      	cmp	r2, r3
 80054be:	d1eb      	bne.n	8005498 <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 80054c0:	4b25      	ldr	r3, [pc, #148]	; (8005558 <HAL_RCC_ClockConfig+0x1b8>)
 80054c2:	681b      	ldr	r3, [r3, #0]
 80054c4:	f003 030f 	and.w	r3, r3, #15
 80054c8:	683a      	ldr	r2, [r7, #0]
 80054ca:	429a      	cmp	r2, r3
 80054cc:	d20c      	bcs.n	80054e8 <HAL_RCC_ClockConfig+0x148>
  {
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80054ce:	4b22      	ldr	r3, [pc, #136]	; (8005558 <HAL_RCC_ClockConfig+0x1b8>)
 80054d0:	683a      	ldr	r2, [r7, #0]
 80054d2:	b2d2      	uxtb	r2, r2
 80054d4:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80054d6:	4b20      	ldr	r3, [pc, #128]	; (8005558 <HAL_RCC_ClockConfig+0x1b8>)
 80054d8:	681b      	ldr	r3, [r3, #0]
 80054da:	f003 030f 	and.w	r3, r3, #15
 80054de:	683a      	ldr	r2, [r7, #0]
 80054e0:	429a      	cmp	r2, r3
 80054e2:	d001      	beq.n	80054e8 <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 80054e4:	2301      	movs	r3, #1
 80054e6:	e032      	b.n	800554e <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80054e8:	687b      	ldr	r3, [r7, #4]
 80054ea:	681b      	ldr	r3, [r3, #0]
 80054ec:	f003 0304 	and.w	r3, r3, #4
 80054f0:	2b00      	cmp	r3, #0
 80054f2:	d008      	beq.n	8005506 <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80054f4:	4b19      	ldr	r3, [pc, #100]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 80054f6:	689b      	ldr	r3, [r3, #8]
 80054f8:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 80054fc:	687b      	ldr	r3, [r7, #4]
 80054fe:	68db      	ldr	r3, [r3, #12]
 8005500:	4916      	ldr	r1, [pc, #88]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 8005502:	4313      	orrs	r3, r2
 8005504:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8005506:	687b      	ldr	r3, [r7, #4]
 8005508:	681b      	ldr	r3, [r3, #0]
 800550a:	f003 0308 	and.w	r3, r3, #8
 800550e:	2b00      	cmp	r3, #0
 8005510:	d009      	beq.n	8005526 <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8005512:	4b12      	ldr	r3, [pc, #72]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 8005514:	689b      	ldr	r3, [r3, #8]
 8005516:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 800551a:	687b      	ldr	r3, [r7, #4]
 800551c:	691b      	ldr	r3, [r3, #16]
 800551e:	00db      	lsls	r3, r3, #3
 8005520:	490e      	ldr	r1, [pc, #56]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 8005522:	4313      	orrs	r3, r2
 8005524:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8005526:	f000 f821 	bl	800556c <HAL_RCC_GetSysClockFreq>
 800552a:	4601      	mov	r1, r0
 800552c:	4b0b      	ldr	r3, [pc, #44]	; (800555c <HAL_RCC_ClockConfig+0x1bc>)
 800552e:	689b      	ldr	r3, [r3, #8]
 8005530:	091b      	lsrs	r3, r3, #4
 8005532:	f003 030f 	and.w	r3, r3, #15
 8005536:	4a0a      	ldr	r2, [pc, #40]	; (8005560 <HAL_RCC_ClockConfig+0x1c0>)
 8005538:	5cd3      	ldrb	r3, [r2, r3]
 800553a:	fa21 f303 	lsr.w	r3, r1, r3
 800553e:	4a09      	ldr	r2, [pc, #36]	; (8005564 <HAL_RCC_ClockConfig+0x1c4>)
 8005540:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (uwTickPrio);
 8005542:	4b09      	ldr	r3, [pc, #36]	; (8005568 <HAL_RCC_ClockConfig+0x1c8>)
 8005544:	681b      	ldr	r3, [r3, #0]
 8005546:	4618      	mov	r0, r3
 8005548:	f7fb fc42 	bl	8000dd0 <HAL_InitTick>

  return HAL_OK;
 800554c:	2300      	movs	r3, #0
}
 800554e:	4618      	mov	r0, r3
 8005550:	3710      	adds	r7, #16
 8005552:	46bd      	mov	sp, r7
 8005554:	bd80      	pop	{r7, pc}
 8005556:	bf00      	nop
 8005558:	40023c00 	.word	0x40023c00
 800555c:	40023800 	.word	0x40023800
 8005560:	0802e624 	.word	0x0802e624
 8005564:	20000000 	.word	0x20000000
 8005568:	2000000c 	.word	0x2000000c

0800556c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800556c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800556e:	b085      	sub	sp, #20
 8005570:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
 8005572:	2300      	movs	r3, #0
 8005574:	607b      	str	r3, [r7, #4]
 8005576:	2300      	movs	r3, #0
 8005578:	60fb      	str	r3, [r7, #12]
 800557a:	2300      	movs	r3, #0
 800557c:	603b      	str	r3, [r7, #0]
  uint32_t sysclockfreq = 0U;
 800557e:	2300      	movs	r3, #0
 8005580:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8005582:	4b63      	ldr	r3, [pc, #396]	; (8005710 <HAL_RCC_GetSysClockFreq+0x1a4>)
 8005584:	689b      	ldr	r3, [r3, #8]
 8005586:	f003 030c 	and.w	r3, r3, #12
 800558a:	2b04      	cmp	r3, #4
 800558c:	d007      	beq.n	800559e <HAL_RCC_GetSysClockFreq+0x32>
 800558e:	2b08      	cmp	r3, #8
 8005590:	d008      	beq.n	80055a4 <HAL_RCC_GetSysClockFreq+0x38>
 8005592:	2b00      	cmp	r3, #0
 8005594:	f040 80b4 	bne.w	8005700 <HAL_RCC_GetSysClockFreq+0x194>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8005598:	4b5e      	ldr	r3, [pc, #376]	; (8005714 <HAL_RCC_GetSysClockFreq+0x1a8>)
 800559a:	60bb      	str	r3, [r7, #8]
       break;
 800559c:	e0b3      	b.n	8005706 <HAL_RCC_GetSysClockFreq+0x19a>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 800559e:	4b5e      	ldr	r3, [pc, #376]	; (8005718 <HAL_RCC_GetSysClockFreq+0x1ac>)
 80055a0:	60bb      	str	r3, [r7, #8]
      break;
 80055a2:	e0b0      	b.n	8005706 <HAL_RCC_GetSysClockFreq+0x19a>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80055a4:	4b5a      	ldr	r3, [pc, #360]	; (8005710 <HAL_RCC_GetSysClockFreq+0x1a4>)
 80055a6:	685b      	ldr	r3, [r3, #4]
 80055a8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80055ac:	607b      	str	r3, [r7, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80055ae:	4b58      	ldr	r3, [pc, #352]	; (8005710 <HAL_RCC_GetSysClockFreq+0x1a4>)
 80055b0:	685b      	ldr	r3, [r3, #4]
 80055b2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80055b6:	2b00      	cmp	r3, #0
 80055b8:	d04a      	beq.n	8005650 <HAL_RCC_GetSysClockFreq+0xe4>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80055ba:	4b55      	ldr	r3, [pc, #340]	; (8005710 <HAL_RCC_GetSysClockFreq+0x1a4>)
 80055bc:	685b      	ldr	r3, [r3, #4]
 80055be:	099b      	lsrs	r3, r3, #6
 80055c0:	f04f 0400 	mov.w	r4, #0
 80055c4:	f240 11ff 	movw	r1, #511	; 0x1ff
 80055c8:	f04f 0200 	mov.w	r2, #0
 80055cc:	ea03 0501 	and.w	r5, r3, r1
 80055d0:	ea04 0602 	and.w	r6, r4, r2
 80055d4:	4629      	mov	r1, r5
 80055d6:	4632      	mov	r2, r6
 80055d8:	f04f 0300 	mov.w	r3, #0
 80055dc:	f04f 0400 	mov.w	r4, #0
 80055e0:	0154      	lsls	r4, r2, #5
 80055e2:	ea44 64d1 	orr.w	r4, r4, r1, lsr #27
 80055e6:	014b      	lsls	r3, r1, #5
 80055e8:	4619      	mov	r1, r3
 80055ea:	4622      	mov	r2, r4
 80055ec:	1b49      	subs	r1, r1, r5
 80055ee:	eb62 0206 	sbc.w	r2, r2, r6
 80055f2:	f04f 0300 	mov.w	r3, #0
 80055f6:	f04f 0400 	mov.w	r4, #0
 80055fa:	0194      	lsls	r4, r2, #6
 80055fc:	ea44 6491 	orr.w	r4, r4, r1, lsr #26
 8005600:	018b      	lsls	r3, r1, #6
 8005602:	1a5b      	subs	r3, r3, r1
 8005604:	eb64 0402 	sbc.w	r4, r4, r2
 8005608:	f04f 0100 	mov.w	r1, #0
 800560c:	f04f 0200 	mov.w	r2, #0
 8005610:	00e2      	lsls	r2, r4, #3
 8005612:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
 8005616:	00d9      	lsls	r1, r3, #3
 8005618:	460b      	mov	r3, r1
 800561a:	4614      	mov	r4, r2
 800561c:	195b      	adds	r3, r3, r5
 800561e:	eb44 0406 	adc.w	r4, r4, r6
 8005622:	f04f 0100 	mov.w	r1, #0
 8005626:	f04f 0200 	mov.w	r2, #0
 800562a:	0262      	lsls	r2, r4, #9
 800562c:	ea42 52d3 	orr.w	r2, r2, r3, lsr #23
 8005630:	0259      	lsls	r1, r3, #9
 8005632:	460b      	mov	r3, r1
 8005634:	4614      	mov	r4, r2
 8005636:	4618      	mov	r0, r3
 8005638:	4621      	mov	r1, r4
 800563a:	687b      	ldr	r3, [r7, #4]
 800563c:	f04f 0400 	mov.w	r4, #0
 8005640:	461a      	mov	r2, r3
 8005642:	4623      	mov	r3, r4
 8005644:	f7fa fe24 	bl	8000290 <__aeabi_uldivmod>
 8005648:	4603      	mov	r3, r0
 800564a:	460c      	mov	r4, r1
 800564c:	60fb      	str	r3, [r7, #12]
 800564e:	e049      	b.n	80056e4 <HAL_RCC_GetSysClockFreq+0x178>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8005650:	4b2f      	ldr	r3, [pc, #188]	; (8005710 <HAL_RCC_GetSysClockFreq+0x1a4>)
 8005652:	685b      	ldr	r3, [r3, #4]
 8005654:	099b      	lsrs	r3, r3, #6
 8005656:	f04f 0400 	mov.w	r4, #0
 800565a:	f240 11ff 	movw	r1, #511	; 0x1ff
 800565e:	f04f 0200 	mov.w	r2, #0
 8005662:	ea03 0501 	and.w	r5, r3, r1
 8005666:	ea04 0602 	and.w	r6, r4, r2
 800566a:	4629      	mov	r1, r5
 800566c:	4632      	mov	r2, r6
 800566e:	f04f 0300 	mov.w	r3, #0
 8005672:	f04f 0400 	mov.w	r4, #0
 8005676:	0154      	lsls	r4, r2, #5
 8005678:	ea44 64d1 	orr.w	r4, r4, r1, lsr #27
 800567c:	014b      	lsls	r3, r1, #5
 800567e:	4619      	mov	r1, r3
 8005680:	4622      	mov	r2, r4
 8005682:	1b49      	subs	r1, r1, r5
 8005684:	eb62 0206 	sbc.w	r2, r2, r6
 8005688:	f04f 0300 	mov.w	r3, #0
 800568c:	f04f 0400 	mov.w	r4, #0
 8005690:	0194      	lsls	r4, r2, #6
 8005692:	ea44 6491 	orr.w	r4, r4, r1, lsr #26
 8005696:	018b      	lsls	r3, r1, #6
 8005698:	1a5b      	subs	r3, r3, r1
 800569a:	eb64 0402 	sbc.w	r4, r4, r2
 800569e:	f04f 0100 	mov.w	r1, #0
 80056a2:	f04f 0200 	mov.w	r2, #0
 80056a6:	00e2      	lsls	r2, r4, #3
 80056a8:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
 80056ac:	00d9      	lsls	r1, r3, #3
 80056ae:	460b      	mov	r3, r1
 80056b0:	4614      	mov	r4, r2
 80056b2:	195b      	adds	r3, r3, r5
 80056b4:	eb44 0406 	adc.w	r4, r4, r6
 80056b8:	f04f 0100 	mov.w	r1, #0
 80056bc:	f04f 0200 	mov.w	r2, #0
 80056c0:	02a2      	lsls	r2, r4, #10
 80056c2:	ea42 5293 	orr.w	r2, r2, r3, lsr #22
 80056c6:	0299      	lsls	r1, r3, #10
 80056c8:	460b      	mov	r3, r1
 80056ca:	4614      	mov	r4, r2
 80056cc:	4618      	mov	r0, r3
 80056ce:	4621      	mov	r1, r4
 80056d0:	687b      	ldr	r3, [r7, #4]
 80056d2:	f04f 0400 	mov.w	r4, #0
 80056d6:	461a      	mov	r2, r3
 80056d8:	4623      	mov	r3, r4
 80056da:	f7fa fdd9 	bl	8000290 <__aeabi_uldivmod>
 80056de:	4603      	mov	r3, r0
 80056e0:	460c      	mov	r4, r1
 80056e2:	60fb      	str	r3, [r7, #12]
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 80056e4:	4b0a      	ldr	r3, [pc, #40]	; (8005710 <HAL_RCC_GetSysClockFreq+0x1a4>)
 80056e6:	685b      	ldr	r3, [r3, #4]
 80056e8:	0c1b      	lsrs	r3, r3, #16
 80056ea:	f003 0303 	and.w	r3, r3, #3
 80056ee:	3301      	adds	r3, #1
 80056f0:	005b      	lsls	r3, r3, #1
 80056f2:	603b      	str	r3, [r7, #0]

      sysclockfreq = pllvco/pllp;
 80056f4:	68fa      	ldr	r2, [r7, #12]
 80056f6:	683b      	ldr	r3, [r7, #0]
 80056f8:	fbb2 f3f3 	udiv	r3, r2, r3
 80056fc:	60bb      	str	r3, [r7, #8]
      break;
 80056fe:	e002      	b.n	8005706 <HAL_RCC_GetSysClockFreq+0x19a>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 8005700:	4b04      	ldr	r3, [pc, #16]	; (8005714 <HAL_RCC_GetSysClockFreq+0x1a8>)
 8005702:	60bb      	str	r3, [r7, #8]
      break;
 8005704:	bf00      	nop
    }
  }
  return sysclockfreq;
 8005706:	68bb      	ldr	r3, [r7, #8]
}
 8005708:	4618      	mov	r0, r3
 800570a:	3714      	adds	r7, #20
 800570c:	46bd      	mov	sp, r7
 800570e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005710:	40023800 	.word	0x40023800
 8005714:	00f42400 	.word	0x00f42400
 8005718:	007a1200 	.word	0x007a1200

0800571c <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800571c:	b480      	push	{r7}
 800571e:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8005720:	4b03      	ldr	r3, [pc, #12]	; (8005730 <HAL_RCC_GetHCLKFreq+0x14>)
 8005722:	681b      	ldr	r3, [r3, #0]
}
 8005724:	4618      	mov	r0, r3
 8005726:	46bd      	mov	sp, r7
 8005728:	f85d 7b04 	ldr.w	r7, [sp], #4
 800572c:	4770      	bx	lr
 800572e:	bf00      	nop
 8005730:	20000000 	.word	0x20000000

08005734 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8005734:	b580      	push	{r7, lr}
 8005736:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8005738:	f7ff fff0 	bl	800571c <HAL_RCC_GetHCLKFreq>
 800573c:	4601      	mov	r1, r0
 800573e:	4b05      	ldr	r3, [pc, #20]	; (8005754 <HAL_RCC_GetPCLK1Freq+0x20>)
 8005740:	689b      	ldr	r3, [r3, #8]
 8005742:	0a9b      	lsrs	r3, r3, #10
 8005744:	f003 0307 	and.w	r3, r3, #7
 8005748:	4a03      	ldr	r2, [pc, #12]	; (8005758 <HAL_RCC_GetPCLK1Freq+0x24>)
 800574a:	5cd3      	ldrb	r3, [r2, r3]
 800574c:	fa21 f303 	lsr.w	r3, r1, r3
}
 8005750:	4618      	mov	r0, r3
 8005752:	bd80      	pop	{r7, pc}
 8005754:	40023800 	.word	0x40023800
 8005758:	0802e634 	.word	0x0802e634

0800575c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800575c:	b580      	push	{r7, lr}
 800575e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8005760:	f7ff ffdc 	bl	800571c <HAL_RCC_GetHCLKFreq>
 8005764:	4601      	mov	r1, r0
 8005766:	4b05      	ldr	r3, [pc, #20]	; (800577c <HAL_RCC_GetPCLK2Freq+0x20>)
 8005768:	689b      	ldr	r3, [r3, #8]
 800576a:	0b5b      	lsrs	r3, r3, #13
 800576c:	f003 0307 	and.w	r3, r3, #7
 8005770:	4a03      	ldr	r2, [pc, #12]	; (8005780 <HAL_RCC_GetPCLK2Freq+0x24>)
 8005772:	5cd3      	ldrb	r3, [r2, r3]
 8005774:	fa21 f303 	lsr.w	r3, r1, r3
}
 8005778:	4618      	mov	r0, r3
 800577a:	bd80      	pop	{r7, pc}
 800577c:	40023800 	.word	0x40023800
 8005780:	0802e634 	.word	0x0802e634

08005784 <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 8005784:	b480      	push	{r7}
 8005786:	b083      	sub	sp, #12
 8005788:	af00      	add	r7, sp, #0
 800578a:	6078      	str	r0, [r7, #4]
 800578c:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 800578e:	687b      	ldr	r3, [r7, #4]
 8005790:	220f      	movs	r2, #15
 8005792:	601a      	str	r2, [r3, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8005794:	4b12      	ldr	r3, [pc, #72]	; (80057e0 <HAL_RCC_GetClockConfig+0x5c>)
 8005796:	689b      	ldr	r3, [r3, #8]
 8005798:	f003 0203 	and.w	r2, r3, #3
 800579c:	687b      	ldr	r3, [r7, #4]
 800579e:	605a      	str	r2, [r3, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 80057a0:	4b0f      	ldr	r3, [pc, #60]	; (80057e0 <HAL_RCC_GetClockConfig+0x5c>)
 80057a2:	689b      	ldr	r3, [r3, #8]
 80057a4:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 80057a8:	687b      	ldr	r3, [r7, #4]
 80057aa:	609a      	str	r2, [r3, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 80057ac:	4b0c      	ldr	r3, [pc, #48]	; (80057e0 <HAL_RCC_GetClockConfig+0x5c>)
 80057ae:	689b      	ldr	r3, [r3, #8]
 80057b0:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
 80057b4:	687b      	ldr	r3, [r7, #4]
 80057b6:	60da      	str	r2, [r3, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
 80057b8:	4b09      	ldr	r3, [pc, #36]	; (80057e0 <HAL_RCC_GetClockConfig+0x5c>)
 80057ba:	689b      	ldr	r3, [r3, #8]
 80057bc:	08db      	lsrs	r3, r3, #3
 80057be:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
 80057c2:	687b      	ldr	r3, [r7, #4]
 80057c4:	611a      	str	r2, [r3, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 80057c6:	4b07      	ldr	r3, [pc, #28]	; (80057e4 <HAL_RCC_GetClockConfig+0x60>)
 80057c8:	681b      	ldr	r3, [r3, #0]
 80057ca:	f003 020f 	and.w	r2, r3, #15
 80057ce:	683b      	ldr	r3, [r7, #0]
 80057d0:	601a      	str	r2, [r3, #0]
}
 80057d2:	bf00      	nop
 80057d4:	370c      	adds	r7, #12
 80057d6:	46bd      	mov	sp, r7
 80057d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80057dc:	4770      	bx	lr
 80057de:	bf00      	nop
 80057e0:	40023800 	.word	0x40023800
 80057e4:	40023c00 	.word	0x40023c00

080057e8 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80057e8:	b580      	push	{r7, lr}
 80057ea:	b086      	sub	sp, #24
 80057ec:	af00      	add	r7, sp, #0
 80057ee:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 80057f0:	2300      	movs	r3, #0
 80057f2:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg1 = 0U;
 80057f4:	2300      	movs	r3, #0
 80057f6:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 80057f8:	687b      	ldr	r3, [r7, #4]
 80057fa:	681b      	ldr	r3, [r3, #0]
 80057fc:	f003 0301 	and.w	r3, r3, #1
 8005800:	2b00      	cmp	r3, #0
 8005802:	d105      	bne.n	8005810 <HAL_RCCEx_PeriphCLKConfig+0x28>
     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 8005804:	687b      	ldr	r3, [r7, #4]
 8005806:	681b      	ldr	r3, [r3, #0]
 8005808:	f003 0304 	and.w	r3, r3, #4
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 800580c:	2b00      	cmp	r3, #0
 800580e:	d038      	beq.n	8005882 <HAL_RCCEx_PeriphCLKConfig+0x9a>
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
#if defined(STM32F411xE)
    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));
#endif /* STM32F411xE */
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8005810:	4b68      	ldr	r3, [pc, #416]	; (80059b4 <HAL_RCCEx_PeriphCLKConfig+0x1cc>)
 8005812:	2200      	movs	r2, #0
 8005814:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8005816:	f7fc fc31 	bl	800207c <HAL_GetTick>
 800581a:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800581c:	e008      	b.n	8005830 <HAL_RCCEx_PeriphCLKConfig+0x48>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 800581e:	f7fc fc2d 	bl	800207c <HAL_GetTick>
 8005822:	4602      	mov	r2, r0
 8005824:	697b      	ldr	r3, [r7, #20]
 8005826:	1ad3      	subs	r3, r2, r3
 8005828:	2b02      	cmp	r3, #2
 800582a:	d901      	bls.n	8005830 <HAL_RCCEx_PeriphCLKConfig+0x48>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800582c:	2303      	movs	r3, #3
 800582e:	e0bd      	b.n	80059ac <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8005830:	4b61      	ldr	r3, [pc, #388]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8005832:	681b      	ldr	r3, [r3, #0]
 8005834:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8005838:	2b00      	cmp	r3, #0
 800583a:	d1f0      	bne.n	800581e <HAL_RCCEx_PeriphCLKConfig+0x36>

#if defined(STM32F411xE)
    /* Configure the PLLI2S division factors */
    /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
 800583c:	687b      	ldr	r3, [r7, #4]
 800583e:	685a      	ldr	r2, [r3, #4]
 8005840:	687b      	ldr	r3, [r7, #4]
 8005842:	689b      	ldr	r3, [r3, #8]
 8005844:	019b      	lsls	r3, r3, #6
 8005846:	431a      	orrs	r2, r3
 8005848:	687b      	ldr	r3, [r7, #4]
 800584a:	68db      	ldr	r3, [r3, #12]
 800584c:	071b      	lsls	r3, r3, #28
 800584e:	495a      	ldr	r1, [pc, #360]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8005850:	4313      	orrs	r3, r2
 8005852:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
#endif /* STM32F411xE */

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 8005856:	4b57      	ldr	r3, [pc, #348]	; (80059b4 <HAL_RCCEx_PeriphCLKConfig+0x1cc>)
 8005858:	2201      	movs	r2, #1
 800585a:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 800585c:	f7fc fc0e 	bl	800207c <HAL_GetTick>
 8005860:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8005862:	e008      	b.n	8005876 <HAL_RCCEx_PeriphCLKConfig+0x8e>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8005864:	f7fc fc0a 	bl	800207c <HAL_GetTick>
 8005868:	4602      	mov	r2, r0
 800586a:	697b      	ldr	r3, [r7, #20]
 800586c:	1ad3      	subs	r3, r2, r3
 800586e:	2b02      	cmp	r3, #2
 8005870:	d901      	bls.n	8005876 <HAL_RCCEx_PeriphCLKConfig+0x8e>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8005872:	2303      	movs	r3, #3
 8005874:	e09a      	b.n	80059ac <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8005876:	4b50      	ldr	r3, [pc, #320]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8005878:	681b      	ldr	r3, [r3, #0]
 800587a:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800587e:	2b00      	cmp	r3, #0
 8005880:	d0f0      	beq.n	8005864 <HAL_RCCEx_PeriphCLKConfig+0x7c>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8005882:	687b      	ldr	r3, [r7, #4]
 8005884:	681b      	ldr	r3, [r3, #0]
 8005886:	f003 0302 	and.w	r3, r3, #2
 800588a:	2b00      	cmp	r3, #0
 800588c:	f000 8083 	beq.w	8005996 <HAL_RCCEx_PeriphCLKConfig+0x1ae>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8005890:	2300      	movs	r3, #0
 8005892:	60fb      	str	r3, [r7, #12]
 8005894:	4b48      	ldr	r3, [pc, #288]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8005896:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005898:	4a47      	ldr	r2, [pc, #284]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800589a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800589e:	6413      	str	r3, [r2, #64]	; 0x40
 80058a0:	4b45      	ldr	r3, [pc, #276]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 80058a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80058a4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80058a8:	60fb      	str	r3, [r7, #12]
 80058aa:	68fb      	ldr	r3, [r7, #12]

    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 80058ac:	4b43      	ldr	r3, [pc, #268]	; (80059bc <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 80058ae:	681b      	ldr	r3, [r3, #0]
 80058b0:	4a42      	ldr	r2, [pc, #264]	; (80059bc <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 80058b2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80058b6:	6013      	str	r3, [r2, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 80058b8:	f7fc fbe0 	bl	800207c <HAL_GetTick>
 80058bc:	6178      	str	r0, [r7, #20]

    while((PWR->CR & PWR_CR_DBP) == RESET)
 80058be:	e008      	b.n	80058d2 <HAL_RCCEx_PeriphCLKConfig+0xea>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 80058c0:	f7fc fbdc 	bl	800207c <HAL_GetTick>
 80058c4:	4602      	mov	r2, r0
 80058c6:	697b      	ldr	r3, [r7, #20]
 80058c8:	1ad3      	subs	r3, r2, r3
 80058ca:	2b02      	cmp	r3, #2
 80058cc:	d901      	bls.n	80058d2 <HAL_RCCEx_PeriphCLKConfig+0xea>
      {
        return HAL_TIMEOUT;
 80058ce:	2303      	movs	r3, #3
 80058d0:	e06c      	b.n	80059ac <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    while((PWR->CR & PWR_CR_DBP) == RESET)
 80058d2:	4b3a      	ldr	r3, [pc, #232]	; (80059bc <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 80058d4:	681b      	ldr	r3, [r3, #0]
 80058d6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80058da:	2b00      	cmp	r3, #0
 80058dc:	d0f0      	beq.n	80058c0 <HAL_RCCEx_PeriphCLKConfig+0xd8>
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 80058de:	4b36      	ldr	r3, [pc, #216]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 80058e0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80058e2:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80058e6:	613b      	str	r3, [r7, #16]
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 80058e8:	693b      	ldr	r3, [r7, #16]
 80058ea:	2b00      	cmp	r3, #0
 80058ec:	d02f      	beq.n	800594e <HAL_RCCEx_PeriphCLKConfig+0x166>
 80058ee:	687b      	ldr	r3, [r7, #4]
 80058f0:	691b      	ldr	r3, [r3, #16]
 80058f2:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80058f6:	693a      	ldr	r2, [r7, #16]
 80058f8:	429a      	cmp	r2, r3
 80058fa:	d028      	beq.n	800594e <HAL_RCCEx_PeriphCLKConfig+0x166>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80058fc:	4b2e      	ldr	r3, [pc, #184]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 80058fe:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005900:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8005904:	613b      	str	r3, [r7, #16]
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8005906:	4b2e      	ldr	r3, [pc, #184]	; (80059c0 <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
 8005908:	2201      	movs	r2, #1
 800590a:	601a      	str	r2, [r3, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 800590c:	4b2c      	ldr	r3, [pc, #176]	; (80059c0 <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
 800590e:	2200      	movs	r2, #0
 8005910:	601a      	str	r2, [r3, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg1;
 8005912:	4a29      	ldr	r2, [pc, #164]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8005914:	693b      	ldr	r3, [r7, #16]
 8005916:	6713      	str	r3, [r2, #112]	; 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8005918:	4b27      	ldr	r3, [pc, #156]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800591a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800591c:	f003 0301 	and.w	r3, r3, #1
 8005920:	2b01      	cmp	r3, #1
 8005922:	d114      	bne.n	800594e <HAL_RCCEx_PeriphCLKConfig+0x166>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 8005924:	f7fc fbaa 	bl	800207c <HAL_GetTick>
 8005928:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800592a:	e00a      	b.n	8005942 <HAL_RCCEx_PeriphCLKConfig+0x15a>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800592c:	f7fc fba6 	bl	800207c <HAL_GetTick>
 8005930:	4602      	mov	r2, r0
 8005932:	697b      	ldr	r3, [r7, #20]
 8005934:	1ad3      	subs	r3, r2, r3
 8005936:	f241 3288 	movw	r2, #5000	; 0x1388
 800593a:	4293      	cmp	r3, r2
 800593c:	d901      	bls.n	8005942 <HAL_RCCEx_PeriphCLKConfig+0x15a>
          {
            return HAL_TIMEOUT;
 800593e:	2303      	movs	r3, #3
 8005940:	e034      	b.n	80059ac <HAL_RCCEx_PeriphCLKConfig+0x1c4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8005942:	4b1d      	ldr	r3, [pc, #116]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8005944:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005946:	f003 0302 	and.w	r3, r3, #2
 800594a:	2b00      	cmp	r3, #0
 800594c:	d0ee      	beq.n	800592c <HAL_RCCEx_PeriphCLKConfig+0x144>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800594e:	687b      	ldr	r3, [r7, #4]
 8005950:	691b      	ldr	r3, [r3, #16]
 8005952:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005956:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800595a:	d10d      	bne.n	8005978 <HAL_RCCEx_PeriphCLKConfig+0x190>
 800595c:	4b16      	ldr	r3, [pc, #88]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800595e:	689b      	ldr	r3, [r3, #8]
 8005960:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 8005964:	687b      	ldr	r3, [r7, #4]
 8005966:	691b      	ldr	r3, [r3, #16]
 8005968:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 800596c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8005970:	4911      	ldr	r1, [pc, #68]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8005972:	4313      	orrs	r3, r2
 8005974:	608b      	str	r3, [r1, #8]
 8005976:	e005      	b.n	8005984 <HAL_RCCEx_PeriphCLKConfig+0x19c>
 8005978:	4b0f      	ldr	r3, [pc, #60]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800597a:	689b      	ldr	r3, [r3, #8]
 800597c:	4a0e      	ldr	r2, [pc, #56]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800597e:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 8005982:	6093      	str	r3, [r2, #8]
 8005984:	4b0c      	ldr	r3, [pc, #48]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8005986:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8005988:	687b      	ldr	r3, [r7, #4]
 800598a:	691b      	ldr	r3, [r3, #16]
 800598c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8005990:	4909      	ldr	r1, [pc, #36]	; (80059b8 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8005992:	4313      	orrs	r3, r2
 8005994:	670b      	str	r3, [r1, #112]	; 0x70
  }
#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8005996:	687b      	ldr	r3, [r7, #4]
 8005998:	681b      	ldr	r3, [r3, #0]
 800599a:	f003 0308 	and.w	r3, r3, #8
 800599e:	2b00      	cmp	r3, #0
 80059a0:	d003      	beq.n	80059aa <HAL_RCCEx_PeriphCLKConfig+0x1c2>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 80059a2:	687b      	ldr	r3, [r7, #4]
 80059a4:	7d1a      	ldrb	r2, [r3, #20]
 80059a6:	4b07      	ldr	r3, [pc, #28]	; (80059c4 <HAL_RCCEx_PeriphCLKConfig+0x1dc>)
 80059a8:	601a      	str	r2, [r3, #0]
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 80059aa:	2300      	movs	r3, #0
}
 80059ac:	4618      	mov	r0, r3
 80059ae:	3718      	adds	r7, #24
 80059b0:	46bd      	mov	sp, r7
 80059b2:	bd80      	pop	{r7, pc}
 80059b4:	42470068 	.word	0x42470068
 80059b8:	40023800 	.word	0x40023800
 80059bc:	40007000 	.word	0x40007000
 80059c0:	42470e40 	.word	0x42470e40
 80059c4:	424711e0 	.word	0x424711e0

080059c8 <HAL_RTC_Init>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 80059c8:	b580      	push	{r7, lr}
 80059ca:	b082      	sub	sp, #8
 80059cc:	af00      	add	r7, sp, #0
 80059ce:	6078      	str	r0, [r7, #4]
  /* Check the RTC peripheral state */
  if(hrtc == NULL)
 80059d0:	687b      	ldr	r3, [r7, #4]
 80059d2:	2b00      	cmp	r3, #0
 80059d4:	d101      	bne.n	80059da <HAL_RTC_Init+0x12>
  {
     return HAL_ERROR;
 80059d6:	2301      	movs	r3, #1
 80059d8:	e083      	b.n	8005ae2 <HAL_RTC_Init+0x11a>
    {
      hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    }
  }
#else
  if(hrtc->State == HAL_RTC_STATE_RESET)
 80059da:	687b      	ldr	r3, [r7, #4]
 80059dc:	7f5b      	ldrb	r3, [r3, #29]
 80059de:	b2db      	uxtb	r3, r3
 80059e0:	2b00      	cmp	r3, #0
 80059e2:	d105      	bne.n	80059f0 <HAL_RTC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hrtc->Lock = HAL_UNLOCKED;
 80059e4:	687b      	ldr	r3, [r7, #4]
 80059e6:	2200      	movs	r2, #0
 80059e8:	771a      	strb	r2, [r3, #28]

    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
 80059ea:	6878      	ldr	r0, [r7, #4]
 80059ec:	f7fb f8b2 	bl	8000b54 <HAL_RTC_MspInit>
  }
#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 80059f0:	687b      	ldr	r3, [r7, #4]
 80059f2:	2202      	movs	r2, #2
 80059f4:	775a      	strb	r2, [r3, #29]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80059f6:	687b      	ldr	r3, [r7, #4]
 80059f8:	681b      	ldr	r3, [r3, #0]
 80059fa:	22ca      	movs	r2, #202	; 0xca
 80059fc:	625a      	str	r2, [r3, #36]	; 0x24
 80059fe:	687b      	ldr	r3, [r7, #4]
 8005a00:	681b      	ldr	r3, [r3, #0]
 8005a02:	2253      	movs	r2, #83	; 0x53
 8005a04:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8005a06:	6878      	ldr	r0, [r7, #4]
 8005a08:	f000 f9fb 	bl	8005e02 <RTC_EnterInitMode>
 8005a0c:	4603      	mov	r3, r0
 8005a0e:	2b00      	cmp	r3, #0
 8005a10:	d008      	beq.n	8005a24 <HAL_RTC_Init+0x5c>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005a12:	687b      	ldr	r3, [r7, #4]
 8005a14:	681b      	ldr	r3, [r3, #0]
 8005a16:	22ff      	movs	r2, #255	; 0xff
 8005a18:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 8005a1a:	687b      	ldr	r3, [r7, #4]
 8005a1c:	2204      	movs	r2, #4
 8005a1e:	775a      	strb	r2, [r3, #29]

    return HAL_ERROR;
 8005a20:	2301      	movs	r3, #1
 8005a22:	e05e      	b.n	8005ae2 <HAL_RTC_Init+0x11a>
  }
  else
  {
    /* Clear RTC_CR FMT, OSEL and POL Bits */
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8005a24:	687b      	ldr	r3, [r7, #4]
 8005a26:	681b      	ldr	r3, [r3, #0]
 8005a28:	689b      	ldr	r3, [r3, #8]
 8005a2a:	687a      	ldr	r2, [r7, #4]
 8005a2c:	6812      	ldr	r2, [r2, #0]
 8005a2e:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8005a32:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005a36:	6093      	str	r3, [r2, #8]
    /* Set RTC_CR register */
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8005a38:	687b      	ldr	r3, [r7, #4]
 8005a3a:	681b      	ldr	r3, [r3, #0]
 8005a3c:	6899      	ldr	r1, [r3, #8]
 8005a3e:	687b      	ldr	r3, [r7, #4]
 8005a40:	685a      	ldr	r2, [r3, #4]
 8005a42:	687b      	ldr	r3, [r7, #4]
 8005a44:	691b      	ldr	r3, [r3, #16]
 8005a46:	431a      	orrs	r2, r3
 8005a48:	687b      	ldr	r3, [r7, #4]
 8005a4a:	695b      	ldr	r3, [r3, #20]
 8005a4c:	431a      	orrs	r2, r3
 8005a4e:	687b      	ldr	r3, [r7, #4]
 8005a50:	681b      	ldr	r3, [r3, #0]
 8005a52:	430a      	orrs	r2, r1
 8005a54:	609a      	str	r2, [r3, #8]

    /* Configure the RTC PRER */
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8005a56:	687b      	ldr	r3, [r7, #4]
 8005a58:	681b      	ldr	r3, [r3, #0]
 8005a5a:	687a      	ldr	r2, [r7, #4]
 8005a5c:	68d2      	ldr	r2, [r2, #12]
 8005a5e:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 8005a60:	687b      	ldr	r3, [r7, #4]
 8005a62:	681b      	ldr	r3, [r3, #0]
 8005a64:	6919      	ldr	r1, [r3, #16]
 8005a66:	687b      	ldr	r3, [r7, #4]
 8005a68:	689b      	ldr	r3, [r3, #8]
 8005a6a:	041a      	lsls	r2, r3, #16
 8005a6c:	687b      	ldr	r3, [r7, #4]
 8005a6e:	681b      	ldr	r3, [r3, #0]
 8005a70:	430a      	orrs	r2, r1
 8005a72:	611a      	str	r2, [r3, #16]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 8005a74:	687b      	ldr	r3, [r7, #4]
 8005a76:	681b      	ldr	r3, [r3, #0]
 8005a78:	68da      	ldr	r2, [r3, #12]
 8005a7a:	687b      	ldr	r3, [r7, #4]
 8005a7c:	681b      	ldr	r3, [r3, #0]
 8005a7e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8005a82:	60da      	str	r2, [r3, #12]

    /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8005a84:	687b      	ldr	r3, [r7, #4]
 8005a86:	681b      	ldr	r3, [r3, #0]
 8005a88:	689b      	ldr	r3, [r3, #8]
 8005a8a:	f003 0320 	and.w	r3, r3, #32
 8005a8e:	2b00      	cmp	r3, #0
 8005a90:	d10e      	bne.n	8005ab0 <HAL_RTC_Init+0xe8>
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8005a92:	6878      	ldr	r0, [r7, #4]
 8005a94:	f000 f98d 	bl	8005db2 <HAL_RTC_WaitForSynchro>
 8005a98:	4603      	mov	r3, r0
 8005a9a:	2b00      	cmp	r3, #0
 8005a9c:	d008      	beq.n	8005ab0 <HAL_RTC_Init+0xe8>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005a9e:	687b      	ldr	r3, [r7, #4]
 8005aa0:	681b      	ldr	r3, [r3, #0]
 8005aa2:	22ff      	movs	r2, #255	; 0xff
 8005aa4:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;
 8005aa6:	687b      	ldr	r3, [r7, #4]
 8005aa8:	2204      	movs	r2, #4
 8005aaa:	775a      	strb	r2, [r3, #29]

        return HAL_ERROR;
 8005aac:	2301      	movs	r3, #1
 8005aae:	e018      	b.n	8005ae2 <HAL_RTC_Init+0x11a>
      }
    }

    hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
 8005ab0:	687b      	ldr	r3, [r7, #4]
 8005ab2:	681b      	ldr	r3, [r3, #0]
 8005ab4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005ab6:	687b      	ldr	r3, [r7, #4]
 8005ab8:	681b      	ldr	r3, [r3, #0]
 8005aba:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8005abe:	641a      	str	r2, [r3, #64]	; 0x40
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType);
 8005ac0:	687b      	ldr	r3, [r7, #4]
 8005ac2:	681b      	ldr	r3, [r3, #0]
 8005ac4:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8005ac6:	687b      	ldr	r3, [r7, #4]
 8005ac8:	699a      	ldr	r2, [r3, #24]
 8005aca:	687b      	ldr	r3, [r7, #4]
 8005acc:	681b      	ldr	r3, [r3, #0]
 8005ace:	430a      	orrs	r2, r1
 8005ad0:	641a      	str	r2, [r3, #64]	; 0x40

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005ad2:	687b      	ldr	r3, [r7, #4]
 8005ad4:	681b      	ldr	r3, [r3, #0]
 8005ad6:	22ff      	movs	r2, #255	; 0xff
 8005ad8:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
 8005ada:	687b      	ldr	r3, [r7, #4]
 8005adc:	2201      	movs	r2, #1
 8005ade:	775a      	strb	r2, [r3, #29]

    return HAL_OK;
 8005ae0:	2300      	movs	r3, #0
  }
}
 8005ae2:	4618      	mov	r0, r3
 8005ae4:	3708      	adds	r7, #8
 8005ae6:	46bd      	mov	sp, r7
 8005ae8:	bd80      	pop	{r7, pc}

08005aea <HAL_RTC_SetTime>:
  *            @arg RTC_FORMAT_BIN: Binary data format
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
 8005aea:	b590      	push	{r4, r7, lr}
 8005aec:	b087      	sub	sp, #28
 8005aee:	af00      	add	r7, sp, #0
 8005af0:	60f8      	str	r0, [r7, #12]
 8005af2:	60b9      	str	r1, [r7, #8]
 8005af4:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0U;
 8005af6:	2300      	movs	r3, #0
 8005af8:	617b      	str	r3, [r7, #20]
  assert_param(IS_RTC_FORMAT(Format));
  assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8005afa:	68fb      	ldr	r3, [r7, #12]
 8005afc:	7f1b      	ldrb	r3, [r3, #28]
 8005afe:	2b01      	cmp	r3, #1
 8005b00:	d101      	bne.n	8005b06 <HAL_RTC_SetTime+0x1c>
 8005b02:	2302      	movs	r3, #2
 8005b04:	e0aa      	b.n	8005c5c <HAL_RTC_SetTime+0x172>
 8005b06:	68fb      	ldr	r3, [r7, #12]
 8005b08:	2201      	movs	r2, #1
 8005b0a:	771a      	strb	r2, [r3, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8005b0c:	68fb      	ldr	r3, [r7, #12]
 8005b0e:	2202      	movs	r2, #2
 8005b10:	775a      	strb	r2, [r3, #29]

  if(Format == RTC_FORMAT_BIN)
 8005b12:	687b      	ldr	r3, [r7, #4]
 8005b14:	2b00      	cmp	r3, #0
 8005b16:	d126      	bne.n	8005b66 <HAL_RTC_SetTime+0x7c>
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8005b18:	68fb      	ldr	r3, [r7, #12]
 8005b1a:	681b      	ldr	r3, [r3, #0]
 8005b1c:	689b      	ldr	r3, [r3, #8]
 8005b1e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005b22:	2b00      	cmp	r3, #0
 8005b24:	d102      	bne.n	8005b2c <HAL_RTC_SetTime+0x42>
      assert_param(IS_RTC_HOUR12(sTime->Hours));
      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    }
    else
    {
      sTime->TimeFormat = 0x00U;
 8005b26:	68bb      	ldr	r3, [r7, #8]
 8005b28:	2200      	movs	r2, #0
 8005b2a:	70da      	strb	r2, [r3, #3]
      assert_param(IS_RTC_HOUR24(sTime->Hours));
    }
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8005b2c:	68bb      	ldr	r3, [r7, #8]
 8005b2e:	781b      	ldrb	r3, [r3, #0]
 8005b30:	4618      	mov	r0, r3
 8005b32:	f000 f992 	bl	8005e5a <RTC_ByteToBcd2>
 8005b36:	4603      	mov	r3, r0
 8005b38:	041c      	lsls	r4, r3, #16
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 8005b3a:	68bb      	ldr	r3, [r7, #8]
 8005b3c:	785b      	ldrb	r3, [r3, #1]
 8005b3e:	4618      	mov	r0, r3
 8005b40:	f000 f98b 	bl	8005e5a <RTC_ByteToBcd2>
 8005b44:	4603      	mov	r3, r0
 8005b46:	021b      	lsls	r3, r3, #8
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8005b48:	431c      	orrs	r4, r3
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 8005b4a:	68bb      	ldr	r3, [r7, #8]
 8005b4c:	789b      	ldrb	r3, [r3, #2]
 8005b4e:	4618      	mov	r0, r3
 8005b50:	f000 f983 	bl	8005e5a <RTC_ByteToBcd2>
 8005b54:	4603      	mov	r3, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 8005b56:	ea44 0203 	orr.w	r2, r4, r3
                        (((uint32_t)sTime->TimeFormat) << 16U));
 8005b5a:	68bb      	ldr	r3, [r7, #8]
 8005b5c:	78db      	ldrb	r3, [r3, #3]
 8005b5e:	041b      	lsls	r3, r3, #16
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8005b60:	4313      	orrs	r3, r2
 8005b62:	617b      	str	r3, [r7, #20]
 8005b64:	e018      	b.n	8005b98 <HAL_RTC_SetTime+0xae>
  }
  else
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8005b66:	68fb      	ldr	r3, [r7, #12]
 8005b68:	681b      	ldr	r3, [r3, #0]
 8005b6a:	689b      	ldr	r3, [r3, #8]
 8005b6c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005b70:	2b00      	cmp	r3, #0
 8005b72:	d102      	bne.n	8005b7a <HAL_RTC_SetTime+0x90>
      assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sTime->Hours)));
      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    }
    else
    {
      sTime->TimeFormat = 0x00U;
 8005b74:	68bb      	ldr	r3, [r7, #8]
 8005b76:	2200      	movs	r2, #0
 8005b78:	70da      	strb	r2, [r3, #3]
      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    }
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8005b7a:	68bb      	ldr	r3, [r7, #8]
 8005b7c:	781b      	ldrb	r3, [r3, #0]
 8005b7e:	041a      	lsls	r2, r3, #16
              ((uint32_t)(sTime->Minutes) << 8U) | \
 8005b80:	68bb      	ldr	r3, [r7, #8]
 8005b82:	785b      	ldrb	r3, [r3, #1]
 8005b84:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8005b86:	4313      	orrs	r3, r2
              ((uint32_t)sTime->Seconds) | \
 8005b88:	68ba      	ldr	r2, [r7, #8]
 8005b8a:	7892      	ldrb	r2, [r2, #2]
              ((uint32_t)(sTime->Minutes) << 8U) | \
 8005b8c:	431a      	orrs	r2, r3
              ((uint32_t)(sTime->TimeFormat) << 16U));
 8005b8e:	68bb      	ldr	r3, [r7, #8]
 8005b90:	78db      	ldrb	r3, [r3, #3]
 8005b92:	041b      	lsls	r3, r3, #16
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8005b94:	4313      	orrs	r3, r2
 8005b96:	617b      	str	r3, [r7, #20]
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8005b98:	68fb      	ldr	r3, [r7, #12]
 8005b9a:	681b      	ldr	r3, [r3, #0]
 8005b9c:	22ca      	movs	r2, #202	; 0xca
 8005b9e:	625a      	str	r2, [r3, #36]	; 0x24
 8005ba0:	68fb      	ldr	r3, [r7, #12]
 8005ba2:	681b      	ldr	r3, [r3, #0]
 8005ba4:	2253      	movs	r2, #83	; 0x53
 8005ba6:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8005ba8:	68f8      	ldr	r0, [r7, #12]
 8005baa:	f000 f92a 	bl	8005e02 <RTC_EnterInitMode>
 8005bae:	4603      	mov	r3, r0
 8005bb0:	2b00      	cmp	r3, #0
 8005bb2:	d00b      	beq.n	8005bcc <HAL_RTC_SetTime+0xe2>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005bb4:	68fb      	ldr	r3, [r7, #12]
 8005bb6:	681b      	ldr	r3, [r3, #0]
 8005bb8:	22ff      	movs	r2, #255	; 0xff
 8005bba:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 8005bbc:	68fb      	ldr	r3, [r7, #12]
 8005bbe:	2204      	movs	r2, #4
 8005bc0:	775a      	strb	r2, [r3, #29]

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 8005bc2:	68fb      	ldr	r3, [r7, #12]
 8005bc4:	2200      	movs	r2, #0
 8005bc6:	771a      	strb	r2, [r3, #28]

    return HAL_ERROR;
 8005bc8:	2301      	movs	r3, #1
 8005bca:	e047      	b.n	8005c5c <HAL_RTC_SetTime+0x172>
  }
  else
  {
    /* Set the RTC_TR register */
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8005bcc:	68fb      	ldr	r3, [r7, #12]
 8005bce:	681a      	ldr	r2, [r3, #0]
 8005bd0:	697b      	ldr	r3, [r7, #20]
 8005bd2:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 8005bd6:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8005bda:	6013      	str	r3, [r2, #0]

    /* Clear the bits to be configured */
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BCK;
 8005bdc:	68fb      	ldr	r3, [r7, #12]
 8005bde:	681b      	ldr	r3, [r3, #0]
 8005be0:	689a      	ldr	r2, [r3, #8]
 8005be2:	68fb      	ldr	r3, [r7, #12]
 8005be4:	681b      	ldr	r3, [r3, #0]
 8005be6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8005bea:	609a      	str	r2, [r3, #8]

    /* Configure the RTC_CR register */
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8005bec:	68fb      	ldr	r3, [r7, #12]
 8005bee:	681b      	ldr	r3, [r3, #0]
 8005bf0:	6899      	ldr	r1, [r3, #8]
 8005bf2:	68bb      	ldr	r3, [r7, #8]
 8005bf4:	68da      	ldr	r2, [r3, #12]
 8005bf6:	68bb      	ldr	r3, [r7, #8]
 8005bf8:	691b      	ldr	r3, [r3, #16]
 8005bfa:	431a      	orrs	r2, r3
 8005bfc:	68fb      	ldr	r3, [r7, #12]
 8005bfe:	681b      	ldr	r3, [r3, #0]
 8005c00:	430a      	orrs	r2, r1
 8005c02:	609a      	str	r2, [r3, #8]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 8005c04:	68fb      	ldr	r3, [r7, #12]
 8005c06:	681b      	ldr	r3, [r3, #0]
 8005c08:	68da      	ldr	r2, [r3, #12]
 8005c0a:	68fb      	ldr	r3, [r7, #12]
 8005c0c:	681b      	ldr	r3, [r3, #0]
 8005c0e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8005c12:	60da      	str	r2, [r3, #12]

    /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8005c14:	68fb      	ldr	r3, [r7, #12]
 8005c16:	681b      	ldr	r3, [r3, #0]
 8005c18:	689b      	ldr	r3, [r3, #8]
 8005c1a:	f003 0320 	and.w	r3, r3, #32
 8005c1e:	2b00      	cmp	r3, #0
 8005c20:	d111      	bne.n	8005c46 <HAL_RTC_SetTime+0x15c>
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8005c22:	68f8      	ldr	r0, [r7, #12]
 8005c24:	f000 f8c5 	bl	8005db2 <HAL_RTC_WaitForSynchro>
 8005c28:	4603      	mov	r3, r0
 8005c2a:	2b00      	cmp	r3, #0
 8005c2c:	d00b      	beq.n	8005c46 <HAL_RTC_SetTime+0x15c>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005c2e:	68fb      	ldr	r3, [r7, #12]
 8005c30:	681b      	ldr	r3, [r3, #0]
 8005c32:	22ff      	movs	r2, #255	; 0xff
 8005c34:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;
 8005c36:	68fb      	ldr	r3, [r7, #12]
 8005c38:	2204      	movs	r2, #4
 8005c3a:	775a      	strb	r2, [r3, #29]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 8005c3c:	68fb      	ldr	r3, [r7, #12]
 8005c3e:	2200      	movs	r2, #0
 8005c40:	771a      	strb	r2, [r3, #28]

        return HAL_ERROR;
 8005c42:	2301      	movs	r3, #1
 8005c44:	e00a      	b.n	8005c5c <HAL_RTC_SetTime+0x172>
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005c46:	68fb      	ldr	r3, [r7, #12]
 8005c48:	681b      	ldr	r3, [r3, #0]
 8005c4a:	22ff      	movs	r2, #255	; 0xff
 8005c4c:	625a      	str	r2, [r3, #36]	; 0x24

   hrtc->State = HAL_RTC_STATE_READY;
 8005c4e:	68fb      	ldr	r3, [r7, #12]
 8005c50:	2201      	movs	r2, #1
 8005c52:	775a      	strb	r2, [r3, #29]

   __HAL_UNLOCK(hrtc);
 8005c54:	68fb      	ldr	r3, [r7, #12]
 8005c56:	2200      	movs	r2, #0
 8005c58:	771a      	strb	r2, [r3, #28]

   return HAL_OK;
 8005c5a:	2300      	movs	r3, #0
  }
}
 8005c5c:	4618      	mov	r0, r3
 8005c5e:	371c      	adds	r7, #28
 8005c60:	46bd      	mov	sp, r7
 8005c62:	bd90      	pop	{r4, r7, pc}

08005c64 <HAL_RTC_SetDate>:
  *            @arg RTC_FORMAT_BIN: Binary data format
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
 8005c64:	b590      	push	{r4, r7, lr}
 8005c66:	b087      	sub	sp, #28
 8005c68:	af00      	add	r7, sp, #0
 8005c6a:	60f8      	str	r0, [r7, #12]
 8005c6c:	60b9      	str	r1, [r7, #8]
 8005c6e:	607a      	str	r2, [r7, #4]
  uint32_t datetmpreg = 0U;
 8005c70:	2300      	movs	r3, #0
 8005c72:	617b      	str	r3, [r7, #20]

 /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

 /* Process Locked */
 __HAL_LOCK(hrtc);
 8005c74:	68fb      	ldr	r3, [r7, #12]
 8005c76:	7f1b      	ldrb	r3, [r3, #28]
 8005c78:	2b01      	cmp	r3, #1
 8005c7a:	d101      	bne.n	8005c80 <HAL_RTC_SetDate+0x1c>
 8005c7c:	2302      	movs	r3, #2
 8005c7e:	e094      	b.n	8005daa <HAL_RTC_SetDate+0x146>
 8005c80:	68fb      	ldr	r3, [r7, #12]
 8005c82:	2201      	movs	r2, #1
 8005c84:	771a      	strb	r2, [r3, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8005c86:	68fb      	ldr	r3, [r7, #12]
 8005c88:	2202      	movs	r2, #2
 8005c8a:	775a      	strb	r2, [r3, #29]

  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8005c8c:	687b      	ldr	r3, [r7, #4]
 8005c8e:	2b00      	cmp	r3, #0
 8005c90:	d10e      	bne.n	8005cb0 <HAL_RTC_SetDate+0x4c>
 8005c92:	68bb      	ldr	r3, [r7, #8]
 8005c94:	785b      	ldrb	r3, [r3, #1]
 8005c96:	f003 0310 	and.w	r3, r3, #16
 8005c9a:	2b00      	cmp	r3, #0
 8005c9c:	d008      	beq.n	8005cb0 <HAL_RTC_SetDate+0x4c>
  {
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8005c9e:	68bb      	ldr	r3, [r7, #8]
 8005ca0:	785b      	ldrb	r3, [r3, #1]
 8005ca2:	f023 0310 	bic.w	r3, r3, #16
 8005ca6:	b2db      	uxtb	r3, r3
 8005ca8:	330a      	adds	r3, #10
 8005caa:	b2da      	uxtb	r2, r3
 8005cac:	68bb      	ldr	r3, [r7, #8]
 8005cae:	705a      	strb	r2, [r3, #1]
  }

  assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));

  if(Format == RTC_FORMAT_BIN)
 8005cb0:	687b      	ldr	r3, [r7, #4]
 8005cb2:	2b00      	cmp	r3, #0
 8005cb4:	d11c      	bne.n	8005cf0 <HAL_RTC_SetDate+0x8c>
  {
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8005cb6:	68bb      	ldr	r3, [r7, #8]
 8005cb8:	78db      	ldrb	r3, [r3, #3]
 8005cba:	4618      	mov	r0, r3
 8005cbc:	f000 f8cd 	bl	8005e5a <RTC_ByteToBcd2>
 8005cc0:	4603      	mov	r3, r0
 8005cc2:	041c      	lsls	r4, r3, #16
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 8005cc4:	68bb      	ldr	r3, [r7, #8]
 8005cc6:	785b      	ldrb	r3, [r3, #1]
 8005cc8:	4618      	mov	r0, r3
 8005cca:	f000 f8c6 	bl	8005e5a <RTC_ByteToBcd2>
 8005cce:	4603      	mov	r3, r0
 8005cd0:	021b      	lsls	r3, r3, #8
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8005cd2:	431c      	orrs	r4, r3
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 8005cd4:	68bb      	ldr	r3, [r7, #8]
 8005cd6:	789b      	ldrb	r3, [r3, #2]
 8005cd8:	4618      	mov	r0, r3
 8005cda:	f000 f8be 	bl	8005e5a <RTC_ByteToBcd2>
 8005cde:	4603      	mov	r3, r0
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 8005ce0:	ea44 0203 	orr.w	r2, r4, r3
                 ((uint32_t)sDate->WeekDay << 13U));
 8005ce4:	68bb      	ldr	r3, [r7, #8]
 8005ce6:	781b      	ldrb	r3, [r3, #0]
 8005ce8:	035b      	lsls	r3, r3, #13
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8005cea:	4313      	orrs	r3, r2
 8005cec:	617b      	str	r3, [r7, #20]
 8005cee:	e00e      	b.n	8005d0e <HAL_RTC_SetDate+0xaa>
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
    assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));

    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8005cf0:	68bb      	ldr	r3, [r7, #8]
 8005cf2:	78db      	ldrb	r3, [r3, #3]
 8005cf4:	041a      	lsls	r2, r3, #16
                  (((uint32_t)sDate->Month) << 8U) | \
 8005cf6:	68bb      	ldr	r3, [r7, #8]
 8005cf8:	785b      	ldrb	r3, [r3, #1]
 8005cfa:	021b      	lsls	r3, r3, #8
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8005cfc:	4313      	orrs	r3, r2
                  ((uint32_t)sDate->Date) | \
 8005cfe:	68ba      	ldr	r2, [r7, #8]
 8005d00:	7892      	ldrb	r2, [r2, #2]
                  (((uint32_t)sDate->Month) << 8U) | \
 8005d02:	431a      	orrs	r2, r3
                  (((uint32_t)sDate->WeekDay) << 13U));
 8005d04:	68bb      	ldr	r3, [r7, #8]
 8005d06:	781b      	ldrb	r3, [r3, #0]
 8005d08:	035b      	lsls	r3, r3, #13
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8005d0a:	4313      	orrs	r3, r2
 8005d0c:	617b      	str	r3, [r7, #20]
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8005d0e:	68fb      	ldr	r3, [r7, #12]
 8005d10:	681b      	ldr	r3, [r3, #0]
 8005d12:	22ca      	movs	r2, #202	; 0xca
 8005d14:	625a      	str	r2, [r3, #36]	; 0x24
 8005d16:	68fb      	ldr	r3, [r7, #12]
 8005d18:	681b      	ldr	r3, [r3, #0]
 8005d1a:	2253      	movs	r2, #83	; 0x53
 8005d1c:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8005d1e:	68f8      	ldr	r0, [r7, #12]
 8005d20:	f000 f86f 	bl	8005e02 <RTC_EnterInitMode>
 8005d24:	4603      	mov	r3, r0
 8005d26:	2b00      	cmp	r3, #0
 8005d28:	d00b      	beq.n	8005d42 <HAL_RTC_SetDate+0xde>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005d2a:	68fb      	ldr	r3, [r7, #12]
 8005d2c:	681b      	ldr	r3, [r3, #0]
 8005d2e:	22ff      	movs	r2, #255	; 0xff
 8005d30:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state*/
    hrtc->State = HAL_RTC_STATE_ERROR;
 8005d32:	68fb      	ldr	r3, [r7, #12]
 8005d34:	2204      	movs	r2, #4
 8005d36:	775a      	strb	r2, [r3, #29]

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 8005d38:	68fb      	ldr	r3, [r7, #12]
 8005d3a:	2200      	movs	r2, #0
 8005d3c:	771a      	strb	r2, [r3, #28]

    return HAL_ERROR;
 8005d3e:	2301      	movs	r3, #1
 8005d40:	e033      	b.n	8005daa <HAL_RTC_SetDate+0x146>
  }
  else
  {
    /* Set the RTC_DR register */
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 8005d42:	68fb      	ldr	r3, [r7, #12]
 8005d44:	681a      	ldr	r2, [r3, #0]
 8005d46:	697b      	ldr	r3, [r7, #20]
 8005d48:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8005d4c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8005d50:	6053      	str	r3, [r2, #4]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 8005d52:	68fb      	ldr	r3, [r7, #12]
 8005d54:	681b      	ldr	r3, [r3, #0]
 8005d56:	68da      	ldr	r2, [r3, #12]
 8005d58:	68fb      	ldr	r3, [r7, #12]
 8005d5a:	681b      	ldr	r3, [r3, #0]
 8005d5c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8005d60:	60da      	str	r2, [r3, #12]

    /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8005d62:	68fb      	ldr	r3, [r7, #12]
 8005d64:	681b      	ldr	r3, [r3, #0]
 8005d66:	689b      	ldr	r3, [r3, #8]
 8005d68:	f003 0320 	and.w	r3, r3, #32
 8005d6c:	2b00      	cmp	r3, #0
 8005d6e:	d111      	bne.n	8005d94 <HAL_RTC_SetDate+0x130>
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8005d70:	68f8      	ldr	r0, [r7, #12]
 8005d72:	f000 f81e 	bl	8005db2 <HAL_RTC_WaitForSynchro>
 8005d76:	4603      	mov	r3, r0
 8005d78:	2b00      	cmp	r3, #0
 8005d7a:	d00b      	beq.n	8005d94 <HAL_RTC_SetDate+0x130>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005d7c:	68fb      	ldr	r3, [r7, #12]
 8005d7e:	681b      	ldr	r3, [r3, #0]
 8005d80:	22ff      	movs	r2, #255	; 0xff
 8005d82:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;
 8005d84:	68fb      	ldr	r3, [r7, #12]
 8005d86:	2204      	movs	r2, #4
 8005d88:	775a      	strb	r2, [r3, #29]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 8005d8a:	68fb      	ldr	r3, [r7, #12]
 8005d8c:	2200      	movs	r2, #0
 8005d8e:	771a      	strb	r2, [r3, #28]

        return HAL_ERROR;
 8005d90:	2301      	movs	r3, #1
 8005d92:	e00a      	b.n	8005daa <HAL_RTC_SetDate+0x146>
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005d94:	68fb      	ldr	r3, [r7, #12]
 8005d96:	681b      	ldr	r3, [r3, #0]
 8005d98:	22ff      	movs	r2, #255	; 0xff
 8005d9a:	625a      	str	r2, [r3, #36]	; 0x24

    hrtc->State = HAL_RTC_STATE_READY ;
 8005d9c:	68fb      	ldr	r3, [r7, #12]
 8005d9e:	2201      	movs	r2, #1
 8005da0:	775a      	strb	r2, [r3, #29]

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 8005da2:	68fb      	ldr	r3, [r7, #12]
 8005da4:	2200      	movs	r2, #0
 8005da6:	771a      	strb	r2, [r3, #28]

    return HAL_OK;
 8005da8:	2300      	movs	r3, #0
  }
}
 8005daa:	4618      	mov	r0, r3
 8005dac:	371c      	adds	r7, #28
 8005dae:	46bd      	mov	sp, r7
 8005db0:	bd90      	pop	{r4, r7, pc}

08005db2 <HAL_RTC_WaitForSynchro>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
 8005db2:	b580      	push	{r7, lr}
 8005db4:	b084      	sub	sp, #16
 8005db6:	af00      	add	r7, sp, #0
 8005db8:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8005dba:	2300      	movs	r3, #0
 8005dbc:	60fb      	str	r3, [r7, #12]

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8005dbe:	687b      	ldr	r3, [r7, #4]
 8005dc0:	681b      	ldr	r3, [r3, #0]
 8005dc2:	68da      	ldr	r2, [r3, #12]
 8005dc4:	687b      	ldr	r3, [r7, #4]
 8005dc6:	681b      	ldr	r3, [r3, #0]
 8005dc8:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 8005dcc:	60da      	str	r2, [r3, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 8005dce:	f7fc f955 	bl	800207c <HAL_GetTick>
 8005dd2:	60f8      	str	r0, [r7, #12]

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8005dd4:	e009      	b.n	8005dea <HAL_RTC_WaitForSynchro+0x38>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8005dd6:	f7fc f951 	bl	800207c <HAL_GetTick>
 8005dda:	4602      	mov	r2, r0
 8005ddc:	68fb      	ldr	r3, [r7, #12]
 8005dde:	1ad3      	subs	r3, r2, r3
 8005de0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005de4:	d901      	bls.n	8005dea <HAL_RTC_WaitForSynchro+0x38>
    {
      return HAL_TIMEOUT;
 8005de6:	2303      	movs	r3, #3
 8005de8:	e007      	b.n	8005dfa <HAL_RTC_WaitForSynchro+0x48>
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8005dea:	687b      	ldr	r3, [r7, #4]
 8005dec:	681b      	ldr	r3, [r3, #0]
 8005dee:	68db      	ldr	r3, [r3, #12]
 8005df0:	f003 0320 	and.w	r3, r3, #32
 8005df4:	2b00      	cmp	r3, #0
 8005df6:	d0ee      	beq.n	8005dd6 <HAL_RTC_WaitForSynchro+0x24>
    }
  }

  return HAL_OK;
 8005df8:	2300      	movs	r3, #0
}
 8005dfa:	4618      	mov	r0, r3
 8005dfc:	3710      	adds	r7, #16
 8005dfe:	46bd      	mov	sp, r7
 8005e00:	bd80      	pop	{r7, pc}

08005e02 <RTC_EnterInitMode>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 8005e02:	b580      	push	{r7, lr}
 8005e04:	b084      	sub	sp, #16
 8005e06:	af00      	add	r7, sp, #0
 8005e08:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8005e0a:	2300      	movs	r3, #0
 8005e0c:	60fb      	str	r3, [r7, #12]

  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8005e0e:	687b      	ldr	r3, [r7, #4]
 8005e10:	681b      	ldr	r3, [r3, #0]
 8005e12:	68db      	ldr	r3, [r3, #12]
 8005e14:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005e18:	2b00      	cmp	r3, #0
 8005e1a:	d119      	bne.n	8005e50 <RTC_EnterInitMode+0x4e>
  {
    /* Set the Initialization mode */
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8005e1c:	687b      	ldr	r3, [r7, #4]
 8005e1e:	681b      	ldr	r3, [r3, #0]
 8005e20:	f04f 32ff 	mov.w	r2, #4294967295
 8005e24:	60da      	str	r2, [r3, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 8005e26:	f7fc f929 	bl	800207c <HAL_GetTick>
 8005e2a:	60f8      	str	r0, [r7, #12]

    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8005e2c:	e009      	b.n	8005e42 <RTC_EnterInitMode+0x40>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8005e2e:	f7fc f925 	bl	800207c <HAL_GetTick>
 8005e32:	4602      	mov	r2, r0
 8005e34:	68fb      	ldr	r3, [r7, #12]
 8005e36:	1ad3      	subs	r3, r2, r3
 8005e38:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005e3c:	d901      	bls.n	8005e42 <RTC_EnterInitMode+0x40>
      {
        return HAL_TIMEOUT;
 8005e3e:	2303      	movs	r3, #3
 8005e40:	e007      	b.n	8005e52 <RTC_EnterInitMode+0x50>
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8005e42:	687b      	ldr	r3, [r7, #4]
 8005e44:	681b      	ldr	r3, [r3, #0]
 8005e46:	68db      	ldr	r3, [r3, #12]
 8005e48:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005e4c:	2b00      	cmp	r3, #0
 8005e4e:	d0ee      	beq.n	8005e2e <RTC_EnterInitMode+0x2c>
      }
    }
  }

  return HAL_OK;
 8005e50:	2300      	movs	r3, #0
}
 8005e52:	4618      	mov	r0, r3
 8005e54:	3710      	adds	r7, #16
 8005e56:	46bd      	mov	sp, r7
 8005e58:	bd80      	pop	{r7, pc}

08005e5a <RTC_ByteToBcd2>:
  * @brief  Converts a 2 digit decimal to BCD format.
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
 8005e5a:	b480      	push	{r7}
 8005e5c:	b085      	sub	sp, #20
 8005e5e:	af00      	add	r7, sp, #0
 8005e60:	4603      	mov	r3, r0
 8005e62:	71fb      	strb	r3, [r7, #7]
  uint32_t bcdhigh = 0U;
 8005e64:	2300      	movs	r3, #0
 8005e66:	60fb      	str	r3, [r7, #12]

  while(Value >= 10U)
 8005e68:	e005      	b.n	8005e76 <RTC_ByteToBcd2+0x1c>
  {
    bcdhigh++;
 8005e6a:	68fb      	ldr	r3, [r7, #12]
 8005e6c:	3301      	adds	r3, #1
 8005e6e:	60fb      	str	r3, [r7, #12]
    Value -= 10U;
 8005e70:	79fb      	ldrb	r3, [r7, #7]
 8005e72:	3b0a      	subs	r3, #10
 8005e74:	71fb      	strb	r3, [r7, #7]
  while(Value >= 10U)
 8005e76:	79fb      	ldrb	r3, [r7, #7]
 8005e78:	2b09      	cmp	r3, #9
 8005e7a:	d8f6      	bhi.n	8005e6a <RTC_ByteToBcd2+0x10>
  }

  return  ((uint8_t)(bcdhigh << 4U) | Value);
 8005e7c:	68fb      	ldr	r3, [r7, #12]
 8005e7e:	b2db      	uxtb	r3, r3
 8005e80:	011b      	lsls	r3, r3, #4
 8005e82:	b2da      	uxtb	r2, r3
 8005e84:	79fb      	ldrb	r3, [r7, #7]
 8005e86:	4313      	orrs	r3, r2
 8005e88:	b2db      	uxtb	r3, r3
}
 8005e8a:	4618      	mov	r0, r3
 8005e8c:	3714      	adds	r7, #20
 8005e8e:	46bd      	mov	sp, r7
 8005e90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e94:	4770      	bx	lr

08005e96 <HAL_RTCEx_SetWakeUpTimer>:
  * @param  WakeUpCounter Wake up counter
  * @param  WakeUpClock Wake up clock
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
{
 8005e96:	b580      	push	{r7, lr}
 8005e98:	b086      	sub	sp, #24
 8005e9a:	af00      	add	r7, sp, #0
 8005e9c:	60f8      	str	r0, [r7, #12]
 8005e9e:	60b9      	str	r1, [r7, #8]
 8005ea0:	607a      	str	r2, [r7, #4]
  uint32_t tickstart = 0U;
 8005ea2:	2300      	movs	r3, #0
 8005ea4:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8005ea6:	68fb      	ldr	r3, [r7, #12]
 8005ea8:	7f1b      	ldrb	r3, [r3, #28]
 8005eaa:	2b01      	cmp	r3, #1
 8005eac:	d101      	bne.n	8005eb2 <HAL_RTCEx_SetWakeUpTimer+0x1c>
 8005eae:	2302      	movs	r3, #2
 8005eb0:	e081      	b.n	8005fb6 <HAL_RTCEx_SetWakeUpTimer+0x120>
 8005eb2:	68fb      	ldr	r3, [r7, #12]
 8005eb4:	2201      	movs	r2, #1
 8005eb6:	771a      	strb	r2, [r3, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8005eb8:	68fb      	ldr	r3, [r7, #12]
 8005eba:	2202      	movs	r2, #2
 8005ebc:	775a      	strb	r2, [r3, #29]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8005ebe:	68fb      	ldr	r3, [r7, #12]
 8005ec0:	681b      	ldr	r3, [r3, #0]
 8005ec2:	22ca      	movs	r2, #202	; 0xca
 8005ec4:	625a      	str	r2, [r3, #36]	; 0x24
 8005ec6:	68fb      	ldr	r3, [r7, #12]
 8005ec8:	681b      	ldr	r3, [r3, #0]
 8005eca:	2253      	movs	r2, #83	; 0x53
 8005ecc:	625a      	str	r2, [r3, #36]	; 0x24

  /*Check RTC WUTWF flag is reset only when wake up timer enabled*/
  if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
 8005ece:	68fb      	ldr	r3, [r7, #12]
 8005ed0:	681b      	ldr	r3, [r3, #0]
 8005ed2:	689b      	ldr	r3, [r3, #8]
 8005ed4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8005ed8:	2b00      	cmp	r3, #0
 8005eda:	d01e      	beq.n	8005f1a <HAL_RTCEx_SetWakeUpTimer+0x84>
  {
    tickstart = HAL_GetTick();
 8005edc:	f7fc f8ce 	bl	800207c <HAL_GetTick>
 8005ee0:	6178      	str	r0, [r7, #20]

    /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
 8005ee2:	e013      	b.n	8005f0c <HAL_RTCEx_SetWakeUpTimer+0x76>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8005ee4:	f7fc f8ca 	bl	800207c <HAL_GetTick>
 8005ee8:	4602      	mov	r2, r0
 8005eea:	697b      	ldr	r3, [r7, #20]
 8005eec:	1ad3      	subs	r3, r2, r3
 8005eee:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005ef2:	d90b      	bls.n	8005f0c <HAL_RTCEx_SetWakeUpTimer+0x76>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005ef4:	68fb      	ldr	r3, [r7, #12]
 8005ef6:	681b      	ldr	r3, [r3, #0]
 8005ef8:	22ff      	movs	r2, #255	; 0xff
 8005efa:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8005efc:	68fb      	ldr	r3, [r7, #12]
 8005efe:	2203      	movs	r2, #3
 8005f00:	775a      	strb	r2, [r3, #29]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 8005f02:	68fb      	ldr	r3, [r7, #12]
 8005f04:	2200      	movs	r2, #0
 8005f06:	771a      	strb	r2, [r3, #28]

        return HAL_TIMEOUT;
 8005f08:	2303      	movs	r3, #3
 8005f0a:	e054      	b.n	8005fb6 <HAL_RTCEx_SetWakeUpTimer+0x120>
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
 8005f0c:	68fb      	ldr	r3, [r7, #12]
 8005f0e:	681b      	ldr	r3, [r3, #0]
 8005f10:	68db      	ldr	r3, [r3, #12]
 8005f12:	f003 0304 	and.w	r3, r3, #4
 8005f16:	2b00      	cmp	r3, #0
 8005f18:	d1e4      	bne.n	8005ee4 <HAL_RTCEx_SetWakeUpTimer+0x4e>
      }
    }
  }

  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
 8005f1a:	68fb      	ldr	r3, [r7, #12]
 8005f1c:	681b      	ldr	r3, [r3, #0]
 8005f1e:	689a      	ldr	r2, [r3, #8]
 8005f20:	68fb      	ldr	r3, [r7, #12]
 8005f22:	681b      	ldr	r3, [r3, #0]
 8005f24:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8005f28:	609a      	str	r2, [r3, #8]

  tickstart = HAL_GetTick();
 8005f2a:	f7fc f8a7 	bl	800207c <HAL_GetTick>
 8005f2e:	6178      	str	r0, [r7, #20]

  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8005f30:	e013      	b.n	8005f5a <HAL_RTCEx_SetWakeUpTimer+0xc4>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8005f32:	f7fc f8a3 	bl	800207c <HAL_GetTick>
 8005f36:	4602      	mov	r2, r0
 8005f38:	697b      	ldr	r3, [r7, #20]
 8005f3a:	1ad3      	subs	r3, r2, r3
 8005f3c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005f40:	d90b      	bls.n	8005f5a <HAL_RTCEx_SetWakeUpTimer+0xc4>
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005f42:	68fb      	ldr	r3, [r7, #12]
 8005f44:	681b      	ldr	r3, [r3, #0]
 8005f46:	22ff      	movs	r2, #255	; 0xff
 8005f48:	625a      	str	r2, [r3, #36]	; 0x24

      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8005f4a:	68fb      	ldr	r3, [r7, #12]
 8005f4c:	2203      	movs	r2, #3
 8005f4e:	775a      	strb	r2, [r3, #29]

      /* Process Unlocked */
      __HAL_UNLOCK(hrtc);
 8005f50:	68fb      	ldr	r3, [r7, #12]
 8005f52:	2200      	movs	r2, #0
 8005f54:	771a      	strb	r2, [r3, #28]

      return HAL_TIMEOUT;
 8005f56:	2303      	movs	r3, #3
 8005f58:	e02d      	b.n	8005fb6 <HAL_RTCEx_SetWakeUpTimer+0x120>
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8005f5a:	68fb      	ldr	r3, [r7, #12]
 8005f5c:	681b      	ldr	r3, [r3, #0]
 8005f5e:	68db      	ldr	r3, [r3, #12]
 8005f60:	f003 0304 	and.w	r3, r3, #4
 8005f64:	2b00      	cmp	r3, #0
 8005f66:	d0e4      	beq.n	8005f32 <HAL_RTCEx_SetWakeUpTimer+0x9c>
    }
  }

  /* Clear the Wake-up Timer clock source bits in CR register */
  hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 8005f68:	68fb      	ldr	r3, [r7, #12]
 8005f6a:	681b      	ldr	r3, [r3, #0]
 8005f6c:	689a      	ldr	r2, [r3, #8]
 8005f6e:	68fb      	ldr	r3, [r7, #12]
 8005f70:	681b      	ldr	r3, [r3, #0]
 8005f72:	f022 0207 	bic.w	r2, r2, #7
 8005f76:	609a      	str	r2, [r3, #8]

  /* Configure the clock source */
  hrtc->Instance->CR |= (uint32_t)WakeUpClock;
 8005f78:	68fb      	ldr	r3, [r7, #12]
 8005f7a:	681b      	ldr	r3, [r3, #0]
 8005f7c:	6899      	ldr	r1, [r3, #8]
 8005f7e:	68fb      	ldr	r3, [r7, #12]
 8005f80:	681b      	ldr	r3, [r3, #0]
 8005f82:	687a      	ldr	r2, [r7, #4]
 8005f84:	430a      	orrs	r2, r1
 8005f86:	609a      	str	r2, [r3, #8]

  /* Configure the Wake-up Timer counter */
  hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
 8005f88:	68fb      	ldr	r3, [r7, #12]
 8005f8a:	681b      	ldr	r3, [r3, #0]
 8005f8c:	68ba      	ldr	r2, [r7, #8]
 8005f8e:	615a      	str	r2, [r3, #20]

   /* Enable the Wake-up Timer */
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
 8005f90:	68fb      	ldr	r3, [r7, #12]
 8005f92:	681b      	ldr	r3, [r3, #0]
 8005f94:	689a      	ldr	r2, [r3, #8]
 8005f96:	68fb      	ldr	r3, [r7, #12]
 8005f98:	681b      	ldr	r3, [r3, #0]
 8005f9a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8005f9e:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005fa0:	68fb      	ldr	r3, [r7, #12]
 8005fa2:	681b      	ldr	r3, [r3, #0]
 8005fa4:	22ff      	movs	r2, #255	; 0xff
 8005fa6:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8005fa8:	68fb      	ldr	r3, [r7, #12]
 8005faa:	2201      	movs	r2, #1
 8005fac:	775a      	strb	r2, [r3, #29]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8005fae:	68fb      	ldr	r3, [r7, #12]
 8005fb0:	2200      	movs	r2, #0
 8005fb2:	771a      	strb	r2, [r3, #28]

  return HAL_OK;
 8005fb4:	2300      	movs	r3, #0
}
 8005fb6:	4618      	mov	r0, r3
 8005fb8:	3718      	adds	r7, #24
 8005fba:	46bd      	mov	sp, r7
 8005fbc:	bd80      	pop	{r7, pc}

08005fbe <HAL_RTCEx_DeactivateWakeUpTimer>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
uint32_t HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
{
 8005fbe:	b580      	push	{r7, lr}
 8005fc0:	b084      	sub	sp, #16
 8005fc2:	af00      	add	r7, sp, #0
 8005fc4:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8005fc6:	2300      	movs	r3, #0
 8005fc8:	60fb      	str	r3, [r7, #12]

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8005fca:	687b      	ldr	r3, [r7, #4]
 8005fcc:	7f1b      	ldrb	r3, [r3, #28]
 8005fce:	2b01      	cmp	r3, #1
 8005fd0:	d101      	bne.n	8005fd6 <HAL_RTCEx_DeactivateWakeUpTimer+0x18>
 8005fd2:	2302      	movs	r3, #2
 8005fd4:	e047      	b.n	8006066 <HAL_RTCEx_DeactivateWakeUpTimer+0xa8>
 8005fd6:	687b      	ldr	r3, [r7, #4]
 8005fd8:	2201      	movs	r2, #1
 8005fda:	771a      	strb	r2, [r3, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8005fdc:	687b      	ldr	r3, [r7, #4]
 8005fde:	2202      	movs	r2, #2
 8005fe0:	775a      	strb	r2, [r3, #29]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8005fe2:	687b      	ldr	r3, [r7, #4]
 8005fe4:	681b      	ldr	r3, [r3, #0]
 8005fe6:	22ca      	movs	r2, #202	; 0xca
 8005fe8:	625a      	str	r2, [r3, #36]	; 0x24
 8005fea:	687b      	ldr	r3, [r7, #4]
 8005fec:	681b      	ldr	r3, [r3, #0]
 8005fee:	2253      	movs	r2, #83	; 0x53
 8005ff0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable the Wake-up Timer */
  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
 8005ff2:	687b      	ldr	r3, [r7, #4]
 8005ff4:	681b      	ldr	r3, [r3, #0]
 8005ff6:	689a      	ldr	r2, [r3, #8]
 8005ff8:	687b      	ldr	r3, [r7, #4]
 8005ffa:	681b      	ldr	r3, [r3, #0]
 8005ffc:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8006000:	609a      	str	r2, [r3, #8]

  /* In case of interrupt mode is used, the interrupt source must disabled */
  __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc,RTC_IT_WUT);
 8006002:	687b      	ldr	r3, [r7, #4]
 8006004:	681b      	ldr	r3, [r3, #0]
 8006006:	689a      	ldr	r2, [r3, #8]
 8006008:	687b      	ldr	r3, [r7, #4]
 800600a:	681b      	ldr	r3, [r3, #0]
 800600c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8006010:	609a      	str	r2, [r3, #8]

  /* Get tick */
  tickstart = HAL_GetTick();
 8006012:	f7fc f833 	bl	800207c <HAL_GetTick>
 8006016:	60f8      	str	r0, [r7, #12]

  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8006018:	e013      	b.n	8006042 <HAL_RTCEx_DeactivateWakeUpTimer+0x84>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 800601a:	f7fc f82f 	bl	800207c <HAL_GetTick>
 800601e:	4602      	mov	r2, r0
 8006020:	68fb      	ldr	r3, [r7, #12]
 8006022:	1ad3      	subs	r3, r2, r3
 8006024:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8006028:	d90b      	bls.n	8006042 <HAL_RTCEx_DeactivateWakeUpTimer+0x84>
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800602a:	687b      	ldr	r3, [r7, #4]
 800602c:	681b      	ldr	r3, [r3, #0]
 800602e:	22ff      	movs	r2, #255	; 0xff
 8006030:	625a      	str	r2, [r3, #36]	; 0x24

      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8006032:	687b      	ldr	r3, [r7, #4]
 8006034:	2203      	movs	r2, #3
 8006036:	775a      	strb	r2, [r3, #29]

      /* Process Unlocked */
      __HAL_UNLOCK(hrtc);
 8006038:	687b      	ldr	r3, [r7, #4]
 800603a:	2200      	movs	r2, #0
 800603c:	771a      	strb	r2, [r3, #28]

      return HAL_TIMEOUT;
 800603e:	2303      	movs	r3, #3
 8006040:	e011      	b.n	8006066 <HAL_RTCEx_DeactivateWakeUpTimer+0xa8>
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8006042:	687b      	ldr	r3, [r7, #4]
 8006044:	681b      	ldr	r3, [r3, #0]
 8006046:	68db      	ldr	r3, [r3, #12]
 8006048:	f003 0304 	and.w	r3, r3, #4
 800604c:	2b00      	cmp	r3, #0
 800604e:	d0e4      	beq.n	800601a <HAL_RTCEx_DeactivateWakeUpTimer+0x5c>
    }
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8006050:	687b      	ldr	r3, [r7, #4]
 8006052:	681b      	ldr	r3, [r3, #0]
 8006054:	22ff      	movs	r2, #255	; 0xff
 8006056:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8006058:	687b      	ldr	r3, [r7, #4]
 800605a:	2201      	movs	r2, #1
 800605c:	775a      	strb	r2, [r3, #29]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 800605e:	687b      	ldr	r3, [r7, #4]
 8006060:	2200      	movs	r2, #0
 8006062:	771a      	strb	r2, [r3, #28]

  return HAL_OK;
 8006064:	2300      	movs	r3, #0
}
 8006066:	4618      	mov	r0, r3
 8006068:	3710      	adds	r7, #16
 800606a:	46bd      	mov	sp, r7
 800606c:	bd80      	pop	{r7, pc}

0800606e <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 800606e:	b580      	push	{r7, lr}
 8006070:	b082      	sub	sp, #8
 8006072:	af00      	add	r7, sp, #0
 8006074:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 8006076:	687b      	ldr	r3, [r7, #4]
 8006078:	2b00      	cmp	r3, #0
 800607a:	d101      	bne.n	8006080 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 800607c:	2301      	movs	r3, #1
 800607e:	e056      	b.n	800612e <HAL_SPI_Init+0xc0>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8006080:	687b      	ldr	r3, [r7, #4]
 8006082:	2200      	movs	r2, #0
 8006084:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8006086:	687b      	ldr	r3, [r7, #4]
 8006088:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800608c:	b2db      	uxtb	r3, r3
 800608e:	2b00      	cmp	r3, #0
 8006090:	d106      	bne.n	80060a0 <HAL_SPI_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8006092:	687b      	ldr	r3, [r7, #4]
 8006094:	2200      	movs	r2, #0
 8006096:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800609a:	6878      	ldr	r0, [r7, #4]
 800609c:	f7fa fdde 	bl	8000c5c <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 80060a0:	687b      	ldr	r3, [r7, #4]
 80060a2:	2202      	movs	r2, #2
 80060a4:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80060a8:	687b      	ldr	r3, [r7, #4]
 80060aa:	681b      	ldr	r3, [r3, #0]
 80060ac:	681a      	ldr	r2, [r3, #0]
 80060ae:	687b      	ldr	r3, [r7, #4]
 80060b0:	681b      	ldr	r3, [r3, #0]
 80060b2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80060b6:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80060b8:	687b      	ldr	r3, [r7, #4]
 80060ba:	685a      	ldr	r2, [r3, #4]
 80060bc:	687b      	ldr	r3, [r7, #4]
 80060be:	689b      	ldr	r3, [r3, #8]
 80060c0:	431a      	orrs	r2, r3
 80060c2:	687b      	ldr	r3, [r7, #4]
 80060c4:	68db      	ldr	r3, [r3, #12]
 80060c6:	431a      	orrs	r2, r3
 80060c8:	687b      	ldr	r3, [r7, #4]
 80060ca:	691b      	ldr	r3, [r3, #16]
 80060cc:	431a      	orrs	r2, r3
 80060ce:	687b      	ldr	r3, [r7, #4]
 80060d0:	695b      	ldr	r3, [r3, #20]
 80060d2:	431a      	orrs	r2, r3
 80060d4:	687b      	ldr	r3, [r7, #4]
 80060d6:	699b      	ldr	r3, [r3, #24]
 80060d8:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80060dc:	431a      	orrs	r2, r3
 80060de:	687b      	ldr	r3, [r7, #4]
 80060e0:	69db      	ldr	r3, [r3, #28]
 80060e2:	431a      	orrs	r2, r3
 80060e4:	687b      	ldr	r3, [r7, #4]
 80060e6:	6a1b      	ldr	r3, [r3, #32]
 80060e8:	ea42 0103 	orr.w	r1, r2, r3
 80060ec:	687b      	ldr	r3, [r7, #4]
 80060ee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80060f0:	687b      	ldr	r3, [r7, #4]
 80060f2:	681b      	ldr	r3, [r3, #0]
 80060f4:	430a      	orrs	r2, r1
 80060f6:	601a      	str	r2, [r3, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 80060f8:	687b      	ldr	r3, [r7, #4]
 80060fa:	699b      	ldr	r3, [r3, #24]
 80060fc:	0c1b      	lsrs	r3, r3, #16
 80060fe:	f003 0104 	and.w	r1, r3, #4
 8006102:	687b      	ldr	r3, [r7, #4]
 8006104:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006106:	687b      	ldr	r3, [r7, #4]
 8006108:	681b      	ldr	r3, [r3, #0]
 800610a:	430a      	orrs	r2, r1
 800610c:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800610e:	687b      	ldr	r3, [r7, #4]
 8006110:	681b      	ldr	r3, [r3, #0]
 8006112:	69da      	ldr	r2, [r3, #28]
 8006114:	687b      	ldr	r3, [r7, #4]
 8006116:	681b      	ldr	r3, [r3, #0]
 8006118:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800611c:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800611e:	687b      	ldr	r3, [r7, #4]
 8006120:	2200      	movs	r2, #0
 8006122:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 8006124:	687b      	ldr	r3, [r7, #4]
 8006126:	2201      	movs	r2, #1
 8006128:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  return HAL_OK;
 800612c:	2300      	movs	r3, #0
}
 800612e:	4618      	mov	r0, r3
 8006130:	3708      	adds	r7, #8
 8006132:	46bd      	mov	sp, r7
 8006134:	bd80      	pop	{r7, pc}
	...

08006138 <HAL_SPI_IRQHandler>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
 8006138:	b580      	push	{r7, lr}
 800613a:	b088      	sub	sp, #32
 800613c:	af00      	add	r7, sp, #0
 800613e:	6078      	str	r0, [r7, #4]
  uint32_t itsource = hspi->Instance->CR2;
 8006140:	687b      	ldr	r3, [r7, #4]
 8006142:	681b      	ldr	r3, [r3, #0]
 8006144:	685b      	ldr	r3, [r3, #4]
 8006146:	61fb      	str	r3, [r7, #28]
  uint32_t itflag   = hspi->Instance->SR;
 8006148:	687b      	ldr	r3, [r7, #4]
 800614a:	681b      	ldr	r3, [r3, #0]
 800614c:	689b      	ldr	r3, [r3, #8]
 800614e:	61bb      	str	r3, [r7, #24]

  /* SPI in mode Receiver ----------------------------------------------------*/
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 8006150:	69bb      	ldr	r3, [r7, #24]
 8006152:	099b      	lsrs	r3, r3, #6
 8006154:	f003 0301 	and.w	r3, r3, #1
 8006158:	2b00      	cmp	r3, #0
 800615a:	d10f      	bne.n	800617c <HAL_SPI_IRQHandler+0x44>
      (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
 800615c:	69bb      	ldr	r3, [r7, #24]
 800615e:	f003 0301 	and.w	r3, r3, #1
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 8006162:	2b00      	cmp	r3, #0
 8006164:	d00a      	beq.n	800617c <HAL_SPI_IRQHandler+0x44>
      (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
 8006166:	69fb      	ldr	r3, [r7, #28]
 8006168:	099b      	lsrs	r3, r3, #6
 800616a:	f003 0301 	and.w	r3, r3, #1
 800616e:	2b00      	cmp	r3, #0
 8006170:	d004      	beq.n	800617c <HAL_SPI_IRQHandler+0x44>
  {
    hspi->RxISR(hspi);
 8006172:	687b      	ldr	r3, [r7, #4]
 8006174:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006176:	6878      	ldr	r0, [r7, #4]
 8006178:	4798      	blx	r3
    return;
 800617a:	e0d8      	b.n	800632e <HAL_SPI_IRQHandler+0x1f6>
  }

  /* SPI in mode Transmitter -------------------------------------------------*/
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
 800617c:	69bb      	ldr	r3, [r7, #24]
 800617e:	085b      	lsrs	r3, r3, #1
 8006180:	f003 0301 	and.w	r3, r3, #1
 8006184:	2b00      	cmp	r3, #0
 8006186:	d00a      	beq.n	800619e <HAL_SPI_IRQHandler+0x66>
 8006188:	69fb      	ldr	r3, [r7, #28]
 800618a:	09db      	lsrs	r3, r3, #7
 800618c:	f003 0301 	and.w	r3, r3, #1
 8006190:	2b00      	cmp	r3, #0
 8006192:	d004      	beq.n	800619e <HAL_SPI_IRQHandler+0x66>
  {
    hspi->TxISR(hspi);
 8006194:	687b      	ldr	r3, [r7, #4]
 8006196:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8006198:	6878      	ldr	r0, [r7, #4]
 800619a:	4798      	blx	r3
    return;
 800619c:	e0c7      	b.n	800632e <HAL_SPI_IRQHandler+0x1f6>
  }

  /* SPI in Error Treatment --------------------------------------------------*/
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 800619e:	69bb      	ldr	r3, [r7, #24]
 80061a0:	095b      	lsrs	r3, r3, #5
 80061a2:	f003 0301 	and.w	r3, r3, #1
 80061a6:	2b00      	cmp	r3, #0
 80061a8:	d10c      	bne.n	80061c4 <HAL_SPI_IRQHandler+0x8c>
 80061aa:	69bb      	ldr	r3, [r7, #24]
 80061ac:	099b      	lsrs	r3, r3, #6
 80061ae:	f003 0301 	and.w	r3, r3, #1
 80061b2:	2b00      	cmp	r3, #0
 80061b4:	d106      	bne.n	80061c4 <HAL_SPI_IRQHandler+0x8c>
       || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 80061b6:	69bb      	ldr	r3, [r7, #24]
 80061b8:	0a1b      	lsrs	r3, r3, #8
 80061ba:	f003 0301 	and.w	r3, r3, #1
 80061be:	2b00      	cmp	r3, #0
 80061c0:	f000 80b5 	beq.w	800632e <HAL_SPI_IRQHandler+0x1f6>
 80061c4:	69fb      	ldr	r3, [r7, #28]
 80061c6:	095b      	lsrs	r3, r3, #5
 80061c8:	f003 0301 	and.w	r3, r3, #1
 80061cc:	2b00      	cmp	r3, #0
 80061ce:	f000 80ae 	beq.w	800632e <HAL_SPI_IRQHandler+0x1f6>
  {
    /* SPI Overrun error interrupt occurred ----------------------------------*/
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 80061d2:	69bb      	ldr	r3, [r7, #24]
 80061d4:	099b      	lsrs	r3, r3, #6
 80061d6:	f003 0301 	and.w	r3, r3, #1
 80061da:	2b00      	cmp	r3, #0
 80061dc:	d023      	beq.n	8006226 <HAL_SPI_IRQHandler+0xee>
    {
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 80061de:	687b      	ldr	r3, [r7, #4]
 80061e0:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 80061e4:	b2db      	uxtb	r3, r3
 80061e6:	2b03      	cmp	r3, #3
 80061e8:	d011      	beq.n	800620e <HAL_SPI_IRQHandler+0xd6>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 80061ea:	687b      	ldr	r3, [r7, #4]
 80061ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80061ee:	f043 0204 	orr.w	r2, r3, #4
 80061f2:	687b      	ldr	r3, [r7, #4]
 80061f4:	655a      	str	r2, [r3, #84]	; 0x54
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80061f6:	2300      	movs	r3, #0
 80061f8:	617b      	str	r3, [r7, #20]
 80061fa:	687b      	ldr	r3, [r7, #4]
 80061fc:	681b      	ldr	r3, [r3, #0]
 80061fe:	68db      	ldr	r3, [r3, #12]
 8006200:	617b      	str	r3, [r7, #20]
 8006202:	687b      	ldr	r3, [r7, #4]
 8006204:	681b      	ldr	r3, [r3, #0]
 8006206:	689b      	ldr	r3, [r3, #8]
 8006208:	617b      	str	r3, [r7, #20]
 800620a:	697b      	ldr	r3, [r7, #20]
 800620c:	e00b      	b.n	8006226 <HAL_SPI_IRQHandler+0xee>
      }
      else
      {
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800620e:	2300      	movs	r3, #0
 8006210:	613b      	str	r3, [r7, #16]
 8006212:	687b      	ldr	r3, [r7, #4]
 8006214:	681b      	ldr	r3, [r3, #0]
 8006216:	68db      	ldr	r3, [r3, #12]
 8006218:	613b      	str	r3, [r7, #16]
 800621a:	687b      	ldr	r3, [r7, #4]
 800621c:	681b      	ldr	r3, [r3, #0]
 800621e:	689b      	ldr	r3, [r3, #8]
 8006220:	613b      	str	r3, [r7, #16]
 8006222:	693b      	ldr	r3, [r7, #16]
        return;
 8006224:	e083      	b.n	800632e <HAL_SPI_IRQHandler+0x1f6>
      }
    }

    /* SPI Mode Fault error interrupt occurred -------------------------------*/
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
 8006226:	69bb      	ldr	r3, [r7, #24]
 8006228:	095b      	lsrs	r3, r3, #5
 800622a:	f003 0301 	and.w	r3, r3, #1
 800622e:	2b00      	cmp	r3, #0
 8006230:	d014      	beq.n	800625c <HAL_SPI_IRQHandler+0x124>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8006232:	687b      	ldr	r3, [r7, #4]
 8006234:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006236:	f043 0201 	orr.w	r2, r3, #1
 800623a:	687b      	ldr	r3, [r7, #4]
 800623c:	655a      	str	r2, [r3, #84]	; 0x54
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 800623e:	2300      	movs	r3, #0
 8006240:	60fb      	str	r3, [r7, #12]
 8006242:	687b      	ldr	r3, [r7, #4]
 8006244:	681b      	ldr	r3, [r3, #0]
 8006246:	689b      	ldr	r3, [r3, #8]
 8006248:	60fb      	str	r3, [r7, #12]
 800624a:	687b      	ldr	r3, [r7, #4]
 800624c:	681b      	ldr	r3, [r3, #0]
 800624e:	681a      	ldr	r2, [r3, #0]
 8006250:	687b      	ldr	r3, [r7, #4]
 8006252:	681b      	ldr	r3, [r3, #0]
 8006254:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8006258:	601a      	str	r2, [r3, #0]
 800625a:	68fb      	ldr	r3, [r7, #12]
    }

    /* SPI Frame error interrupt occurred ------------------------------------*/
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
 800625c:	69bb      	ldr	r3, [r7, #24]
 800625e:	0a1b      	lsrs	r3, r3, #8
 8006260:	f003 0301 	and.w	r3, r3, #1
 8006264:	2b00      	cmp	r3, #0
 8006266:	d00c      	beq.n	8006282 <HAL_SPI_IRQHandler+0x14a>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8006268:	687b      	ldr	r3, [r7, #4]
 800626a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800626c:	f043 0208 	orr.w	r2, r3, #8
 8006270:	687b      	ldr	r3, [r7, #4]
 8006272:	655a      	str	r2, [r3, #84]	; 0x54
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 8006274:	2300      	movs	r3, #0
 8006276:	60bb      	str	r3, [r7, #8]
 8006278:	687b      	ldr	r3, [r7, #4]
 800627a:	681b      	ldr	r3, [r3, #0]
 800627c:	689b      	ldr	r3, [r3, #8]
 800627e:	60bb      	str	r3, [r7, #8]
 8006280:	68bb      	ldr	r3, [r7, #8]
    }

    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8006282:	687b      	ldr	r3, [r7, #4]
 8006284:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006286:	2b00      	cmp	r3, #0
 8006288:	d050      	beq.n	800632c <HAL_SPI_IRQHandler+0x1f4>
    {
      /* Disable all interrupts */
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 800628a:	687b      	ldr	r3, [r7, #4]
 800628c:	681b      	ldr	r3, [r3, #0]
 800628e:	685a      	ldr	r2, [r3, #4]
 8006290:	687b      	ldr	r3, [r7, #4]
 8006292:	681b      	ldr	r3, [r3, #0]
 8006294:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8006298:	605a      	str	r2, [r3, #4]

      hspi->State = HAL_SPI_STATE_READY;
 800629a:	687b      	ldr	r3, [r7, #4]
 800629c:	2201      	movs	r2, #1
 800629e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
      /* Disable the SPI DMA requests if enabled */
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 80062a2:	69fb      	ldr	r3, [r7, #28]
 80062a4:	f003 0302 	and.w	r3, r3, #2
 80062a8:	2b00      	cmp	r3, #0
 80062aa:	d104      	bne.n	80062b6 <HAL_SPI_IRQHandler+0x17e>
 80062ac:	69fb      	ldr	r3, [r7, #28]
 80062ae:	f003 0301 	and.w	r3, r3, #1
 80062b2:	2b00      	cmp	r3, #0
 80062b4:	d034      	beq.n	8006320 <HAL_SPI_IRQHandler+0x1e8>
      {
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 80062b6:	687b      	ldr	r3, [r7, #4]
 80062b8:	681b      	ldr	r3, [r3, #0]
 80062ba:	685a      	ldr	r2, [r3, #4]
 80062bc:	687b      	ldr	r3, [r7, #4]
 80062be:	681b      	ldr	r3, [r3, #0]
 80062c0:	f022 0203 	bic.w	r2, r2, #3
 80062c4:	605a      	str	r2, [r3, #4]

        /* Abort the SPI DMA Rx channel */
        if (hspi->hdmarx != NULL)
 80062c6:	687b      	ldr	r3, [r7, #4]
 80062c8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80062ca:	2b00      	cmp	r3, #0
 80062cc:	d011      	beq.n	80062f2 <HAL_SPI_IRQHandler+0x1ba>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 80062ce:	687b      	ldr	r3, [r7, #4]
 80062d0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80062d2:	4a18      	ldr	r2, [pc, #96]	; (8006334 <HAL_SPI_IRQHandler+0x1fc>)
 80062d4:	651a      	str	r2, [r3, #80]	; 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
 80062d6:	687b      	ldr	r3, [r7, #4]
 80062d8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80062da:	4618      	mov	r0, r3
 80062dc:	f7fc f8e4 	bl	80024a8 <HAL_DMA_Abort_IT>
 80062e0:	4603      	mov	r3, r0
 80062e2:	2b00      	cmp	r3, #0
 80062e4:	d005      	beq.n	80062f2 <HAL_SPI_IRQHandler+0x1ba>
          {
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 80062e6:	687b      	ldr	r3, [r7, #4]
 80062e8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80062ea:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 80062ee:	687b      	ldr	r3, [r7, #4]
 80062f0:	655a      	str	r2, [r3, #84]	; 0x54
          }
        }
        /* Abort the SPI DMA Tx channel */
        if (hspi->hdmatx != NULL)
 80062f2:	687b      	ldr	r3, [r7, #4]
 80062f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80062f6:	2b00      	cmp	r3, #0
 80062f8:	d016      	beq.n	8006328 <HAL_SPI_IRQHandler+0x1f0>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 80062fa:	687b      	ldr	r3, [r7, #4]
 80062fc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80062fe:	4a0d      	ldr	r2, [pc, #52]	; (8006334 <HAL_SPI_IRQHandler+0x1fc>)
 8006300:	651a      	str	r2, [r3, #80]	; 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
 8006302:	687b      	ldr	r3, [r7, #4]
 8006304:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8006306:	4618      	mov	r0, r3
 8006308:	f7fc f8ce 	bl	80024a8 <HAL_DMA_Abort_IT>
 800630c:	4603      	mov	r3, r0
 800630e:	2b00      	cmp	r3, #0
 8006310:	d00a      	beq.n	8006328 <HAL_SPI_IRQHandler+0x1f0>
          {
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 8006312:	687b      	ldr	r3, [r7, #4]
 8006314:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006316:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800631a:	687b      	ldr	r3, [r7, #4]
 800631c:	655a      	str	r2, [r3, #84]	; 0x54
        if (hspi->hdmatx != NULL)
 800631e:	e003      	b.n	8006328 <HAL_SPI_IRQHandler+0x1f0>
      {
        /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
        hspi->ErrorCallback(hspi);
#else
        HAL_SPI_ErrorCallback(hspi);
 8006320:	6878      	ldr	r0, [r7, #4]
 8006322:	f021 fb65 	bl	80279f0 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      }
    }
    return;
 8006326:	e000      	b.n	800632a <HAL_SPI_IRQHandler+0x1f2>
        if (hspi->hdmatx != NULL)
 8006328:	bf00      	nop
    return;
 800632a:	bf00      	nop
 800632c:	bf00      	nop
  }
}
 800632e:	3720      	adds	r7, #32
 8006330:	46bd      	mov	sp, r7
 8006332:	bd80      	pop	{r7, pc}
 8006334:	08006339 	.word	0x08006339

08006338 <SPI_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8006338:	b580      	push	{r7, lr}
 800633a:	b084      	sub	sp, #16
 800633c:	af00      	add	r7, sp, #0
 800633e:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8006340:	687b      	ldr	r3, [r7, #4]
 8006342:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8006344:	60fb      	str	r3, [r7, #12]
  hspi->RxXferCount = 0U;
 8006346:	68fb      	ldr	r3, [r7, #12]
 8006348:	2200      	movs	r2, #0
 800634a:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->TxXferCount = 0U;
 800634c:	68fb      	ldr	r3, [r7, #12]
 800634e:	2200      	movs	r2, #0
 8006350:	86da      	strh	r2, [r3, #54]	; 0x36

  /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->ErrorCallback(hspi);
#else
  HAL_SPI_ErrorCallback(hspi);
 8006352:	68f8      	ldr	r0, [r7, #12]
 8006354:	f021 fb4c 	bl	80279f0 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 8006358:	bf00      	nop
 800635a:	3710      	adds	r7, #16
 800635c:	46bd      	mov	sp, r7
 800635e:	bd80      	pop	{r7, pc}

08006360 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 8006360:	b580      	push	{r7, lr}
 8006362:	b082      	sub	sp, #8
 8006364:	af00      	add	r7, sp, #0
 8006366:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8006368:	687b      	ldr	r3, [r7, #4]
 800636a:	2b00      	cmp	r3, #0
 800636c:	d101      	bne.n	8006372 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 800636e:	2301      	movs	r3, #1
 8006370:	e01d      	b.n	80063ae <HAL_TIM_Base_Init+0x4e>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8006372:	687b      	ldr	r3, [r7, #4]
 8006374:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006378:	b2db      	uxtb	r3, r3
 800637a:	2b00      	cmp	r3, #0
 800637c:	d106      	bne.n	800638c <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800637e:	687b      	ldr	r3, [r7, #4]
 8006380:	2200      	movs	r2, #0
 8006382:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 8006386:	6878      	ldr	r0, [r7, #4]
 8006388:	f000 f815 	bl	80063b6 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800638c:	687b      	ldr	r3, [r7, #4]
 800638e:	2202      	movs	r2, #2
 8006390:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8006394:	687b      	ldr	r3, [r7, #4]
 8006396:	681a      	ldr	r2, [r3, #0]
 8006398:	687b      	ldr	r3, [r7, #4]
 800639a:	3304      	adds	r3, #4
 800639c:	4619      	mov	r1, r3
 800639e:	4610      	mov	r0, r2
 80063a0:	f000 f968 	bl	8006674 <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 80063a4:	687b      	ldr	r3, [r7, #4]
 80063a6:	2201      	movs	r2, #1
 80063a8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 80063ac:	2300      	movs	r3, #0
}
 80063ae:	4618      	mov	r0, r3
 80063b0:	3708      	adds	r7, #8
 80063b2:	46bd      	mov	sp, r7
 80063b4:	bd80      	pop	{r7, pc}

080063b6 <HAL_TIM_Base_MspInit>:
  * @brief  Initializes the TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  */
__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
 80063b6:	b480      	push	{r7}
 80063b8:	b083      	sub	sp, #12
 80063ba:	af00      	add	r7, sp, #0
 80063bc:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 80063be:	bf00      	nop
 80063c0:	370c      	adds	r7, #12
 80063c2:	46bd      	mov	sp, r7
 80063c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80063c8:	4770      	bx	lr

080063ca <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 80063ca:	b480      	push	{r7}
 80063cc:	b085      	sub	sp, #20
 80063ce:	af00      	add	r7, sp, #0
 80063d0:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80063d2:	687b      	ldr	r3, [r7, #4]
 80063d4:	681b      	ldr	r3, [r3, #0]
 80063d6:	68da      	ldr	r2, [r3, #12]
 80063d8:	687b      	ldr	r3, [r7, #4]
 80063da:	681b      	ldr	r3, [r3, #0]
 80063dc:	f042 0201 	orr.w	r2, r2, #1
 80063e0:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80063e2:	687b      	ldr	r3, [r7, #4]
 80063e4:	681b      	ldr	r3, [r3, #0]
 80063e6:	689b      	ldr	r3, [r3, #8]
 80063e8:	f003 0307 	and.w	r3, r3, #7
 80063ec:	60fb      	str	r3, [r7, #12]
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80063ee:	68fb      	ldr	r3, [r7, #12]
 80063f0:	2b06      	cmp	r3, #6
 80063f2:	d007      	beq.n	8006404 <HAL_TIM_Base_Start_IT+0x3a>
  {
    __HAL_TIM_ENABLE(htim);
 80063f4:	687b      	ldr	r3, [r7, #4]
 80063f6:	681b      	ldr	r3, [r3, #0]
 80063f8:	681a      	ldr	r2, [r3, #0]
 80063fa:	687b      	ldr	r3, [r7, #4]
 80063fc:	681b      	ldr	r3, [r3, #0]
 80063fe:	f042 0201 	orr.w	r2, r2, #1
 8006402:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 8006404:	2300      	movs	r3, #0
}
 8006406:	4618      	mov	r0, r3
 8006408:	3714      	adds	r7, #20
 800640a:	46bd      	mov	sp, r7
 800640c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006410:	4770      	bx	lr

08006412 <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 8006412:	b580      	push	{r7, lr}
 8006414:	b082      	sub	sp, #8
 8006416:	af00      	add	r7, sp, #0
 8006418:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800641a:	687b      	ldr	r3, [r7, #4]
 800641c:	681b      	ldr	r3, [r3, #0]
 800641e:	691b      	ldr	r3, [r3, #16]
 8006420:	f003 0302 	and.w	r3, r3, #2
 8006424:	2b02      	cmp	r3, #2
 8006426:	d122      	bne.n	800646e <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8006428:	687b      	ldr	r3, [r7, #4]
 800642a:	681b      	ldr	r3, [r3, #0]
 800642c:	68db      	ldr	r3, [r3, #12]
 800642e:	f003 0302 	and.w	r3, r3, #2
 8006432:	2b02      	cmp	r3, #2
 8006434:	d11b      	bne.n	800646e <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8006436:	687b      	ldr	r3, [r7, #4]
 8006438:	681b      	ldr	r3, [r3, #0]
 800643a:	f06f 0202 	mvn.w	r2, #2
 800643e:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8006440:	687b      	ldr	r3, [r7, #4]
 8006442:	2201      	movs	r2, #1
 8006444:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8006446:	687b      	ldr	r3, [r7, #4]
 8006448:	681b      	ldr	r3, [r3, #0]
 800644a:	699b      	ldr	r3, [r3, #24]
 800644c:	f003 0303 	and.w	r3, r3, #3
 8006450:	2b00      	cmp	r3, #0
 8006452:	d003      	beq.n	800645c <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8006454:	6878      	ldr	r0, [r7, #4]
 8006456:	f000 f8ee 	bl	8006636 <HAL_TIM_IC_CaptureCallback>
 800645a:	e005      	b.n	8006468 <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800645c:	6878      	ldr	r0, [r7, #4]
 800645e:	f000 f8e0 	bl	8006622 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8006462:	6878      	ldr	r0, [r7, #4]
 8006464:	f000 f8f1 	bl	800664a <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006468:	687b      	ldr	r3, [r7, #4]
 800646a:	2200      	movs	r2, #0
 800646c:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800646e:	687b      	ldr	r3, [r7, #4]
 8006470:	681b      	ldr	r3, [r3, #0]
 8006472:	691b      	ldr	r3, [r3, #16]
 8006474:	f003 0304 	and.w	r3, r3, #4
 8006478:	2b04      	cmp	r3, #4
 800647a:	d122      	bne.n	80064c2 <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 800647c:	687b      	ldr	r3, [r7, #4]
 800647e:	681b      	ldr	r3, [r3, #0]
 8006480:	68db      	ldr	r3, [r3, #12]
 8006482:	f003 0304 	and.w	r3, r3, #4
 8006486:	2b04      	cmp	r3, #4
 8006488:	d11b      	bne.n	80064c2 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800648a:	687b      	ldr	r3, [r7, #4]
 800648c:	681b      	ldr	r3, [r3, #0]
 800648e:	f06f 0204 	mvn.w	r2, #4
 8006492:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8006494:	687b      	ldr	r3, [r7, #4]
 8006496:	2202      	movs	r2, #2
 8006498:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800649a:	687b      	ldr	r3, [r7, #4]
 800649c:	681b      	ldr	r3, [r3, #0]
 800649e:	699b      	ldr	r3, [r3, #24]
 80064a0:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80064a4:	2b00      	cmp	r3, #0
 80064a6:	d003      	beq.n	80064b0 <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80064a8:	6878      	ldr	r0, [r7, #4]
 80064aa:	f000 f8c4 	bl	8006636 <HAL_TIM_IC_CaptureCallback>
 80064ae:	e005      	b.n	80064bc <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80064b0:	6878      	ldr	r0, [r7, #4]
 80064b2:	f000 f8b6 	bl	8006622 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80064b6:	6878      	ldr	r0, [r7, #4]
 80064b8:	f000 f8c7 	bl	800664a <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80064bc:	687b      	ldr	r3, [r7, #4]
 80064be:	2200      	movs	r2, #0
 80064c0:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 80064c2:	687b      	ldr	r3, [r7, #4]
 80064c4:	681b      	ldr	r3, [r3, #0]
 80064c6:	691b      	ldr	r3, [r3, #16]
 80064c8:	f003 0308 	and.w	r3, r3, #8
 80064cc:	2b08      	cmp	r3, #8
 80064ce:	d122      	bne.n	8006516 <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 80064d0:	687b      	ldr	r3, [r7, #4]
 80064d2:	681b      	ldr	r3, [r3, #0]
 80064d4:	68db      	ldr	r3, [r3, #12]
 80064d6:	f003 0308 	and.w	r3, r3, #8
 80064da:	2b08      	cmp	r3, #8
 80064dc:	d11b      	bne.n	8006516 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 80064de:	687b      	ldr	r3, [r7, #4]
 80064e0:	681b      	ldr	r3, [r3, #0]
 80064e2:	f06f 0208 	mvn.w	r2, #8
 80064e6:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80064e8:	687b      	ldr	r3, [r7, #4]
 80064ea:	2204      	movs	r2, #4
 80064ec:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80064ee:	687b      	ldr	r3, [r7, #4]
 80064f0:	681b      	ldr	r3, [r3, #0]
 80064f2:	69db      	ldr	r3, [r3, #28]
 80064f4:	f003 0303 	and.w	r3, r3, #3
 80064f8:	2b00      	cmp	r3, #0
 80064fa:	d003      	beq.n	8006504 <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80064fc:	6878      	ldr	r0, [r7, #4]
 80064fe:	f000 f89a 	bl	8006636 <HAL_TIM_IC_CaptureCallback>
 8006502:	e005      	b.n	8006510 <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8006504:	6878      	ldr	r0, [r7, #4]
 8006506:	f000 f88c 	bl	8006622 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800650a:	6878      	ldr	r0, [r7, #4]
 800650c:	f000 f89d 	bl	800664a <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006510:	687b      	ldr	r3, [r7, #4]
 8006512:	2200      	movs	r2, #0
 8006514:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8006516:	687b      	ldr	r3, [r7, #4]
 8006518:	681b      	ldr	r3, [r3, #0]
 800651a:	691b      	ldr	r3, [r3, #16]
 800651c:	f003 0310 	and.w	r3, r3, #16
 8006520:	2b10      	cmp	r3, #16
 8006522:	d122      	bne.n	800656a <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8006524:	687b      	ldr	r3, [r7, #4]
 8006526:	681b      	ldr	r3, [r3, #0]
 8006528:	68db      	ldr	r3, [r3, #12]
 800652a:	f003 0310 	and.w	r3, r3, #16
 800652e:	2b10      	cmp	r3, #16
 8006530:	d11b      	bne.n	800656a <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8006532:	687b      	ldr	r3, [r7, #4]
 8006534:	681b      	ldr	r3, [r3, #0]
 8006536:	f06f 0210 	mvn.w	r2, #16
 800653a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800653c:	687b      	ldr	r3, [r7, #4]
 800653e:	2208      	movs	r2, #8
 8006540:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8006542:	687b      	ldr	r3, [r7, #4]
 8006544:	681b      	ldr	r3, [r3, #0]
 8006546:	69db      	ldr	r3, [r3, #28]
 8006548:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800654c:	2b00      	cmp	r3, #0
 800654e:	d003      	beq.n	8006558 <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8006550:	6878      	ldr	r0, [r7, #4]
 8006552:	f000 f870 	bl	8006636 <HAL_TIM_IC_CaptureCallback>
 8006556:	e005      	b.n	8006564 <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8006558:	6878      	ldr	r0, [r7, #4]
 800655a:	f000 f862 	bl	8006622 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800655e:	6878      	ldr	r0, [r7, #4]
 8006560:	f000 f873 	bl	800664a <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006564:	687b      	ldr	r3, [r7, #4]
 8006566:	2200      	movs	r2, #0
 8006568:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800656a:	687b      	ldr	r3, [r7, #4]
 800656c:	681b      	ldr	r3, [r3, #0]
 800656e:	691b      	ldr	r3, [r3, #16]
 8006570:	f003 0301 	and.w	r3, r3, #1
 8006574:	2b01      	cmp	r3, #1
 8006576:	d10e      	bne.n	8006596 <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8006578:	687b      	ldr	r3, [r7, #4]
 800657a:	681b      	ldr	r3, [r3, #0]
 800657c:	68db      	ldr	r3, [r3, #12]
 800657e:	f003 0301 	and.w	r3, r3, #1
 8006582:	2b01      	cmp	r3, #1
 8006584:	d107      	bne.n	8006596 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8006586:	687b      	ldr	r3, [r7, #4]
 8006588:	681b      	ldr	r3, [r3, #0]
 800658a:	f06f 0201 	mvn.w	r2, #1
 800658e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8006590:	6878      	ldr	r0, [r7, #4]
 8006592:	f7fa fa5b 	bl	8000a4c <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8006596:	687b      	ldr	r3, [r7, #4]
 8006598:	681b      	ldr	r3, [r3, #0]
 800659a:	691b      	ldr	r3, [r3, #16]
 800659c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80065a0:	2b80      	cmp	r3, #128	; 0x80
 80065a2:	d10e      	bne.n	80065c2 <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 80065a4:	687b      	ldr	r3, [r7, #4]
 80065a6:	681b      	ldr	r3, [r3, #0]
 80065a8:	68db      	ldr	r3, [r3, #12]
 80065aa:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80065ae:	2b80      	cmp	r3, #128	; 0x80
 80065b0:	d107      	bne.n	80065c2 <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 80065b2:	687b      	ldr	r3, [r7, #4]
 80065b4:	681b      	ldr	r3, [r3, #0]
 80065b6:	f06f 0280 	mvn.w	r2, #128	; 0x80
 80065ba:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 80065bc:	6878      	ldr	r0, [r7, #4]
 80065be:	f000 f8e3 	bl	8006788 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 80065c2:	687b      	ldr	r3, [r7, #4]
 80065c4:	681b      	ldr	r3, [r3, #0]
 80065c6:	691b      	ldr	r3, [r3, #16]
 80065c8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80065cc:	2b40      	cmp	r3, #64	; 0x40
 80065ce:	d10e      	bne.n	80065ee <HAL_TIM_IRQHandler+0x1dc>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 80065d0:	687b      	ldr	r3, [r7, #4]
 80065d2:	681b      	ldr	r3, [r3, #0]
 80065d4:	68db      	ldr	r3, [r3, #12]
 80065d6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80065da:	2b40      	cmp	r3, #64	; 0x40
 80065dc:	d107      	bne.n	80065ee <HAL_TIM_IRQHandler+0x1dc>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80065de:	687b      	ldr	r3, [r7, #4]
 80065e0:	681b      	ldr	r3, [r3, #0]
 80065e2:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80065e6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 80065e8:	6878      	ldr	r0, [r7, #4]
 80065ea:	f000 f838 	bl	800665e <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80065ee:	687b      	ldr	r3, [r7, #4]
 80065f0:	681b      	ldr	r3, [r3, #0]
 80065f2:	691b      	ldr	r3, [r3, #16]
 80065f4:	f003 0320 	and.w	r3, r3, #32
 80065f8:	2b20      	cmp	r3, #32
 80065fa:	d10e      	bne.n	800661a <HAL_TIM_IRQHandler+0x208>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 80065fc:	687b      	ldr	r3, [r7, #4]
 80065fe:	681b      	ldr	r3, [r3, #0]
 8006600:	68db      	ldr	r3, [r3, #12]
 8006602:	f003 0320 	and.w	r3, r3, #32
 8006606:	2b20      	cmp	r3, #32
 8006608:	d107      	bne.n	800661a <HAL_TIM_IRQHandler+0x208>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800660a:	687b      	ldr	r3, [r7, #4]
 800660c:	681b      	ldr	r3, [r3, #0]
 800660e:	f06f 0220 	mvn.w	r2, #32
 8006612:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 8006614:	6878      	ldr	r0, [r7, #4]
 8006616:	f000 f8ad 	bl	8006774 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 800661a:	bf00      	nop
 800661c:	3708      	adds	r7, #8
 800661e:	46bd      	mov	sp, r7
 8006620:	bd80      	pop	{r7, pc}

08006622 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 8006622:	b480      	push	{r7}
 8006624:	b083      	sub	sp, #12
 8006626:	af00      	add	r7, sp, #0
 8006628:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 800662a:	bf00      	nop
 800662c:	370c      	adds	r7, #12
 800662e:	46bd      	mov	sp, r7
 8006630:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006634:	4770      	bx	lr

08006636 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8006636:	b480      	push	{r7}
 8006638:	b083      	sub	sp, #12
 800663a:	af00      	add	r7, sp, #0
 800663c:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 800663e:	bf00      	nop
 8006640:	370c      	adds	r7, #12
 8006642:	46bd      	mov	sp, r7
 8006644:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006648:	4770      	bx	lr

0800664a <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 800664a:	b480      	push	{r7}
 800664c:	b083      	sub	sp, #12
 800664e:	af00      	add	r7, sp, #0
 8006650:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8006652:	bf00      	nop
 8006654:	370c      	adds	r7, #12
 8006656:	46bd      	mov	sp, r7
 8006658:	f85d 7b04 	ldr.w	r7, [sp], #4
 800665c:	4770      	bx	lr

0800665e <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 800665e:	b480      	push	{r7}
 8006660:	b083      	sub	sp, #12
 8006662:	af00      	add	r7, sp, #0
 8006664:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8006666:	bf00      	nop
 8006668:	370c      	adds	r7, #12
 800666a:	46bd      	mov	sp, r7
 800666c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006670:	4770      	bx	lr
	...

08006674 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 8006674:	b480      	push	{r7}
 8006676:	b085      	sub	sp, #20
 8006678:	af00      	add	r7, sp, #0
 800667a:	6078      	str	r0, [r7, #4]
 800667c:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 800667e:	687b      	ldr	r3, [r7, #4]
 8006680:	681b      	ldr	r3, [r3, #0]
 8006682:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006684:	687b      	ldr	r3, [r7, #4]
 8006686:	4a34      	ldr	r2, [pc, #208]	; (8006758 <TIM_Base_SetConfig+0xe4>)
 8006688:	4293      	cmp	r3, r2
 800668a:	d00f      	beq.n	80066ac <TIM_Base_SetConfig+0x38>
 800668c:	687b      	ldr	r3, [r7, #4]
 800668e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006692:	d00b      	beq.n	80066ac <TIM_Base_SetConfig+0x38>
 8006694:	687b      	ldr	r3, [r7, #4]
 8006696:	4a31      	ldr	r2, [pc, #196]	; (800675c <TIM_Base_SetConfig+0xe8>)
 8006698:	4293      	cmp	r3, r2
 800669a:	d007      	beq.n	80066ac <TIM_Base_SetConfig+0x38>
 800669c:	687b      	ldr	r3, [r7, #4]
 800669e:	4a30      	ldr	r2, [pc, #192]	; (8006760 <TIM_Base_SetConfig+0xec>)
 80066a0:	4293      	cmp	r3, r2
 80066a2:	d003      	beq.n	80066ac <TIM_Base_SetConfig+0x38>
 80066a4:	687b      	ldr	r3, [r7, #4]
 80066a6:	4a2f      	ldr	r2, [pc, #188]	; (8006764 <TIM_Base_SetConfig+0xf0>)
 80066a8:	4293      	cmp	r3, r2
 80066aa:	d108      	bne.n	80066be <TIM_Base_SetConfig+0x4a>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80066ac:	68fb      	ldr	r3, [r7, #12]
 80066ae:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80066b2:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 80066b4:	683b      	ldr	r3, [r7, #0]
 80066b6:	685b      	ldr	r3, [r3, #4]
 80066b8:	68fa      	ldr	r2, [r7, #12]
 80066ba:	4313      	orrs	r3, r2
 80066bc:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80066be:	687b      	ldr	r3, [r7, #4]
 80066c0:	4a25      	ldr	r2, [pc, #148]	; (8006758 <TIM_Base_SetConfig+0xe4>)
 80066c2:	4293      	cmp	r3, r2
 80066c4:	d01b      	beq.n	80066fe <TIM_Base_SetConfig+0x8a>
 80066c6:	687b      	ldr	r3, [r7, #4]
 80066c8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80066cc:	d017      	beq.n	80066fe <TIM_Base_SetConfig+0x8a>
 80066ce:	687b      	ldr	r3, [r7, #4]
 80066d0:	4a22      	ldr	r2, [pc, #136]	; (800675c <TIM_Base_SetConfig+0xe8>)
 80066d2:	4293      	cmp	r3, r2
 80066d4:	d013      	beq.n	80066fe <TIM_Base_SetConfig+0x8a>
 80066d6:	687b      	ldr	r3, [r7, #4]
 80066d8:	4a21      	ldr	r2, [pc, #132]	; (8006760 <TIM_Base_SetConfig+0xec>)
 80066da:	4293      	cmp	r3, r2
 80066dc:	d00f      	beq.n	80066fe <TIM_Base_SetConfig+0x8a>
 80066de:	687b      	ldr	r3, [r7, #4]
 80066e0:	4a20      	ldr	r2, [pc, #128]	; (8006764 <TIM_Base_SetConfig+0xf0>)
 80066e2:	4293      	cmp	r3, r2
 80066e4:	d00b      	beq.n	80066fe <TIM_Base_SetConfig+0x8a>
 80066e6:	687b      	ldr	r3, [r7, #4]
 80066e8:	4a1f      	ldr	r2, [pc, #124]	; (8006768 <TIM_Base_SetConfig+0xf4>)
 80066ea:	4293      	cmp	r3, r2
 80066ec:	d007      	beq.n	80066fe <TIM_Base_SetConfig+0x8a>
 80066ee:	687b      	ldr	r3, [r7, #4]
 80066f0:	4a1e      	ldr	r2, [pc, #120]	; (800676c <TIM_Base_SetConfig+0xf8>)
 80066f2:	4293      	cmp	r3, r2
 80066f4:	d003      	beq.n	80066fe <TIM_Base_SetConfig+0x8a>
 80066f6:	687b      	ldr	r3, [r7, #4]
 80066f8:	4a1d      	ldr	r2, [pc, #116]	; (8006770 <TIM_Base_SetConfig+0xfc>)
 80066fa:	4293      	cmp	r3, r2
 80066fc:	d108      	bne.n	8006710 <TIM_Base_SetConfig+0x9c>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80066fe:	68fb      	ldr	r3, [r7, #12]
 8006700:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8006704:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8006706:	683b      	ldr	r3, [r7, #0]
 8006708:	68db      	ldr	r3, [r3, #12]
 800670a:	68fa      	ldr	r2, [r7, #12]
 800670c:	4313      	orrs	r3, r2
 800670e:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8006710:	68fb      	ldr	r3, [r7, #12]
 8006712:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8006716:	683b      	ldr	r3, [r7, #0]
 8006718:	695b      	ldr	r3, [r3, #20]
 800671a:	4313      	orrs	r3, r2
 800671c:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 800671e:	687b      	ldr	r3, [r7, #4]
 8006720:	68fa      	ldr	r2, [r7, #12]
 8006722:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8006724:	683b      	ldr	r3, [r7, #0]
 8006726:	689a      	ldr	r2, [r3, #8]
 8006728:	687b      	ldr	r3, [r7, #4]
 800672a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800672c:	683b      	ldr	r3, [r7, #0]
 800672e:	681a      	ldr	r2, [r3, #0]
 8006730:	687b      	ldr	r3, [r7, #4]
 8006732:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8006734:	687b      	ldr	r3, [r7, #4]
 8006736:	4a08      	ldr	r2, [pc, #32]	; (8006758 <TIM_Base_SetConfig+0xe4>)
 8006738:	4293      	cmp	r3, r2
 800673a:	d103      	bne.n	8006744 <TIM_Base_SetConfig+0xd0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800673c:	683b      	ldr	r3, [r7, #0]
 800673e:	691a      	ldr	r2, [r3, #16]
 8006740:	687b      	ldr	r3, [r7, #4]
 8006742:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8006744:	687b      	ldr	r3, [r7, #4]
 8006746:	2201      	movs	r2, #1
 8006748:	615a      	str	r2, [r3, #20]
}
 800674a:	bf00      	nop
 800674c:	3714      	adds	r7, #20
 800674e:	46bd      	mov	sp, r7
 8006750:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006754:	4770      	bx	lr
 8006756:	bf00      	nop
 8006758:	40010000 	.word	0x40010000
 800675c:	40000400 	.word	0x40000400
 8006760:	40000800 	.word	0x40000800
 8006764:	40000c00 	.word	0x40000c00
 8006768:	40014000 	.word	0x40014000
 800676c:	40014400 	.word	0x40014400
 8006770:	40014800 	.word	0x40014800

08006774 <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 8006774:	b480      	push	{r7}
 8006776:	b083      	sub	sp, #12
 8006778:	af00      	add	r7, sp, #0
 800677a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 800677c:	bf00      	nop
 800677e:	370c      	adds	r7, #12
 8006780:	46bd      	mov	sp, r7
 8006782:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006786:	4770      	bx	lr

08006788 <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8006788:	b480      	push	{r7}
 800678a:	b083      	sub	sp, #12
 800678c:	af00      	add	r7, sp, #0
 800678e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8006790:	bf00      	nop
 8006792:	370c      	adds	r7, #12
 8006794:	46bd      	mov	sp, r7
 8006796:	f85d 7b04 	ldr.w	r7, [sp], #4
 800679a:	4770      	bx	lr

0800679c <HAL_UART_Init>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800679c:	b580      	push	{r7, lr}
 800679e:	b082      	sub	sp, #8
 80067a0:	af00      	add	r7, sp, #0
 80067a2:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 80067a4:	687b      	ldr	r3, [r7, #4]
 80067a6:	2b00      	cmp	r3, #0
 80067a8:	d101      	bne.n	80067ae <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 80067aa:	2301      	movs	r3, #1
 80067ac:	e03f      	b.n	800682e <HAL_UART_Init+0x92>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));

  if (huart->gState == HAL_UART_STATE_RESET)
 80067ae:	687b      	ldr	r3, [r7, #4]
 80067b0:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 80067b4:	b2db      	uxtb	r3, r3
 80067b6:	2b00      	cmp	r3, #0
 80067b8:	d106      	bne.n	80067c8 <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 80067ba:	687b      	ldr	r3, [r7, #4]
 80067bc:	2200      	movs	r2, #0
 80067be:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 80067c2:	6878      	ldr	r0, [r7, #4]
 80067c4:	f7fa fcd4 	bl	8001170 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 80067c8:	687b      	ldr	r3, [r7, #4]
 80067ca:	2224      	movs	r2, #36	; 0x24
 80067cc:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 80067d0:	687b      	ldr	r3, [r7, #4]
 80067d2:	681b      	ldr	r3, [r3, #0]
 80067d4:	68da      	ldr	r2, [r3, #12]
 80067d6:	687b      	ldr	r3, [r7, #4]
 80067d8:	681b      	ldr	r3, [r3, #0]
 80067da:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80067de:	60da      	str	r2, [r3, #12]

  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 80067e0:	6878      	ldr	r0, [r7, #4]
 80067e2:	f000 fd0f 	bl	8007204 <UART_SetConfig>

  /* In asynchronous mode, the following bits must be kept cleared:
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80067e6:	687b      	ldr	r3, [r7, #4]
 80067e8:	681b      	ldr	r3, [r3, #0]
 80067ea:	691a      	ldr	r2, [r3, #16]
 80067ec:	687b      	ldr	r3, [r7, #4]
 80067ee:	681b      	ldr	r3, [r3, #0]
 80067f0:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 80067f4:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80067f6:	687b      	ldr	r3, [r7, #4]
 80067f8:	681b      	ldr	r3, [r3, #0]
 80067fa:	695a      	ldr	r2, [r3, #20]
 80067fc:	687b      	ldr	r3, [r7, #4]
 80067fe:	681b      	ldr	r3, [r3, #0]
 8006800:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8006804:	615a      	str	r2, [r3, #20]

  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8006806:	687b      	ldr	r3, [r7, #4]
 8006808:	681b      	ldr	r3, [r3, #0]
 800680a:	68da      	ldr	r2, [r3, #12]
 800680c:	687b      	ldr	r3, [r7, #4]
 800680e:	681b      	ldr	r3, [r3, #0]
 8006810:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8006814:	60da      	str	r2, [r3, #12]

  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006816:	687b      	ldr	r3, [r7, #4]
 8006818:	2200      	movs	r2, #0
 800681a:	63da      	str	r2, [r3, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_READY;
 800681c:	687b      	ldr	r3, [r7, #4]
 800681e:	2220      	movs	r2, #32
 8006820:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  huart->RxState = HAL_UART_STATE_READY;
 8006824:	687b      	ldr	r3, [r7, #4]
 8006826:	2220      	movs	r2, #32
 8006828:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a

  return HAL_OK;
 800682c:	2300      	movs	r3, #0
}
 800682e:	4618      	mov	r0, r3
 8006830:	3708      	adds	r7, #8
 8006832:	46bd      	mov	sp, r7
 8006834:	bd80      	pop	{r7, pc}

08006836 <HAL_UART_Transmit>:
  * @param  Size  Amount of data elements (u8 or u16) to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8006836:	b580      	push	{r7, lr}
 8006838:	b088      	sub	sp, #32
 800683a:	af02      	add	r7, sp, #8
 800683c:	60f8      	str	r0, [r7, #12]
 800683e:	60b9      	str	r1, [r7, #8]
 8006840:	603b      	str	r3, [r7, #0]
 8006842:	4613      	mov	r3, r2
 8006844:	80fb      	strh	r3, [r7, #6]
  uint16_t *tmp;
  uint32_t tickstart = 0U;
 8006846:	2300      	movs	r3, #0
 8006848:	617b      	str	r3, [r7, #20]

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800684a:	68fb      	ldr	r3, [r7, #12]
 800684c:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8006850:	b2db      	uxtb	r3, r3
 8006852:	2b20      	cmp	r3, #32
 8006854:	f040 8083 	bne.w	800695e <HAL_UART_Transmit+0x128>
  {
    if ((pData == NULL) || (Size == 0U))
 8006858:	68bb      	ldr	r3, [r7, #8]
 800685a:	2b00      	cmp	r3, #0
 800685c:	d002      	beq.n	8006864 <HAL_UART_Transmit+0x2e>
 800685e:	88fb      	ldrh	r3, [r7, #6]
 8006860:	2b00      	cmp	r3, #0
 8006862:	d101      	bne.n	8006868 <HAL_UART_Transmit+0x32>
    {
      return  HAL_ERROR;
 8006864:	2301      	movs	r3, #1
 8006866:	e07b      	b.n	8006960 <HAL_UART_Transmit+0x12a>
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8006868:	68fb      	ldr	r3, [r7, #12]
 800686a:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800686e:	2b01      	cmp	r3, #1
 8006870:	d101      	bne.n	8006876 <HAL_UART_Transmit+0x40>
 8006872:	2302      	movs	r3, #2
 8006874:	e074      	b.n	8006960 <HAL_UART_Transmit+0x12a>
 8006876:	68fb      	ldr	r3, [r7, #12]
 8006878:	2201      	movs	r2, #1
 800687a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800687e:	68fb      	ldr	r3, [r7, #12]
 8006880:	2200      	movs	r2, #0
 8006882:	63da      	str	r2, [r3, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8006884:	68fb      	ldr	r3, [r7, #12]
 8006886:	2221      	movs	r2, #33	; 0x21
 8006888:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

    /* Init tickstart for timeout managment */
    tickstart = HAL_GetTick();
 800688c:	f7fb fbf6 	bl	800207c <HAL_GetTick>
 8006890:	6178      	str	r0, [r7, #20]

    huart->TxXferSize = Size;
 8006892:	68fb      	ldr	r3, [r7, #12]
 8006894:	88fa      	ldrh	r2, [r7, #6]
 8006896:	849a      	strh	r2, [r3, #36]	; 0x24
    huart->TxXferCount = Size;
 8006898:	68fb      	ldr	r3, [r7, #12]
 800689a:	88fa      	ldrh	r2, [r7, #6]
 800689c:	84da      	strh	r2, [r3, #38]	; 0x26

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 800689e:	68fb      	ldr	r3, [r7, #12]
 80068a0:	2200      	movs	r2, #0
 80068a2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    while (huart->TxXferCount > 0U)
 80068a6:	e042      	b.n	800692e <HAL_UART_Transmit+0xf8>
    {
      huart->TxXferCount--;
 80068a8:	68fb      	ldr	r3, [r7, #12]
 80068aa:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 80068ac:	b29b      	uxth	r3, r3
 80068ae:	3b01      	subs	r3, #1
 80068b0:	b29a      	uxth	r2, r3
 80068b2:	68fb      	ldr	r3, [r7, #12]
 80068b4:	84da      	strh	r2, [r3, #38]	; 0x26
      if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 80068b6:	68fb      	ldr	r3, [r7, #12]
 80068b8:	689b      	ldr	r3, [r3, #8]
 80068ba:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80068be:	d122      	bne.n	8006906 <HAL_UART_Transmit+0xd0>
      {
        if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80068c0:	683b      	ldr	r3, [r7, #0]
 80068c2:	9300      	str	r3, [sp, #0]
 80068c4:	697b      	ldr	r3, [r7, #20]
 80068c6:	2200      	movs	r2, #0
 80068c8:	2180      	movs	r1, #128	; 0x80
 80068ca:	68f8      	ldr	r0, [r7, #12]
 80068cc:	f000 fb19 	bl	8006f02 <UART_WaitOnFlagUntilTimeout>
 80068d0:	4603      	mov	r3, r0
 80068d2:	2b00      	cmp	r3, #0
 80068d4:	d001      	beq.n	80068da <HAL_UART_Transmit+0xa4>
        {
          return HAL_TIMEOUT;
 80068d6:	2303      	movs	r3, #3
 80068d8:	e042      	b.n	8006960 <HAL_UART_Transmit+0x12a>
        }
        tmp = (uint16_t *) pData;
 80068da:	68bb      	ldr	r3, [r7, #8]
 80068dc:	613b      	str	r3, [r7, #16]
        huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
 80068de:	693b      	ldr	r3, [r7, #16]
 80068e0:	881b      	ldrh	r3, [r3, #0]
 80068e2:	461a      	mov	r2, r3
 80068e4:	68fb      	ldr	r3, [r7, #12]
 80068e6:	681b      	ldr	r3, [r3, #0]
 80068e8:	f3c2 0208 	ubfx	r2, r2, #0, #9
 80068ec:	605a      	str	r2, [r3, #4]
        if (huart->Init.Parity == UART_PARITY_NONE)
 80068ee:	68fb      	ldr	r3, [r7, #12]
 80068f0:	691b      	ldr	r3, [r3, #16]
 80068f2:	2b00      	cmp	r3, #0
 80068f4:	d103      	bne.n	80068fe <HAL_UART_Transmit+0xc8>
        {
          pData += 2U;
 80068f6:	68bb      	ldr	r3, [r7, #8]
 80068f8:	3302      	adds	r3, #2
 80068fa:	60bb      	str	r3, [r7, #8]
 80068fc:	e017      	b.n	800692e <HAL_UART_Transmit+0xf8>
        }
        else
        {
          pData += 1U;
 80068fe:	68bb      	ldr	r3, [r7, #8]
 8006900:	3301      	adds	r3, #1
 8006902:	60bb      	str	r3, [r7, #8]
 8006904:	e013      	b.n	800692e <HAL_UART_Transmit+0xf8>
        }
      }
      else
      {
        if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8006906:	683b      	ldr	r3, [r7, #0]
 8006908:	9300      	str	r3, [sp, #0]
 800690a:	697b      	ldr	r3, [r7, #20]
 800690c:	2200      	movs	r2, #0
 800690e:	2180      	movs	r1, #128	; 0x80
 8006910:	68f8      	ldr	r0, [r7, #12]
 8006912:	f000 faf6 	bl	8006f02 <UART_WaitOnFlagUntilTimeout>
 8006916:	4603      	mov	r3, r0
 8006918:	2b00      	cmp	r3, #0
 800691a:	d001      	beq.n	8006920 <HAL_UART_Transmit+0xea>
        {
          return HAL_TIMEOUT;
 800691c:	2303      	movs	r3, #3
 800691e:	e01f      	b.n	8006960 <HAL_UART_Transmit+0x12a>
        }
        huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
 8006920:	68bb      	ldr	r3, [r7, #8]
 8006922:	1c5a      	adds	r2, r3, #1
 8006924:	60ba      	str	r2, [r7, #8]
 8006926:	781a      	ldrb	r2, [r3, #0]
 8006928:	68fb      	ldr	r3, [r7, #12]
 800692a:	681b      	ldr	r3, [r3, #0]
 800692c:	605a      	str	r2, [r3, #4]
    while (huart->TxXferCount > 0U)
 800692e:	68fb      	ldr	r3, [r7, #12]
 8006930:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8006932:	b29b      	uxth	r3, r3
 8006934:	2b00      	cmp	r3, #0
 8006936:	d1b7      	bne.n	80068a8 <HAL_UART_Transmit+0x72>
      }
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8006938:	683b      	ldr	r3, [r7, #0]
 800693a:	9300      	str	r3, [sp, #0]
 800693c:	697b      	ldr	r3, [r7, #20]
 800693e:	2200      	movs	r2, #0
 8006940:	2140      	movs	r1, #64	; 0x40
 8006942:	68f8      	ldr	r0, [r7, #12]
 8006944:	f000 fadd 	bl	8006f02 <UART_WaitOnFlagUntilTimeout>
 8006948:	4603      	mov	r3, r0
 800694a:	2b00      	cmp	r3, #0
 800694c:	d001      	beq.n	8006952 <HAL_UART_Transmit+0x11c>
    {
      return HAL_TIMEOUT;
 800694e:	2303      	movs	r3, #3
 8006950:	e006      	b.n	8006960 <HAL_UART_Transmit+0x12a>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 8006952:	68fb      	ldr	r3, [r7, #12]
 8006954:	2220      	movs	r2, #32
 8006956:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

    return HAL_OK;
 800695a:	2300      	movs	r3, #0
 800695c:	e000      	b.n	8006960 <HAL_UART_Transmit+0x12a>
  }
  else
  {
    return HAL_BUSY;
 800695e:	2302      	movs	r3, #2
  }
}
 8006960:	4618      	mov	r0, r3
 8006962:	3718      	adds	r7, #24
 8006964:	46bd      	mov	sp, r7
 8006966:	bd80      	pop	{r7, pc}

08006968 <HAL_UART_Transmit_DMA>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8006968:	b580      	push	{r7, lr}
 800696a:	b086      	sub	sp, #24
 800696c:	af00      	add	r7, sp, #0
 800696e:	60f8      	str	r0, [r7, #12]
 8006970:	60b9      	str	r1, [r7, #8]
 8006972:	4613      	mov	r3, r2
 8006974:	80fb      	strh	r3, [r7, #6]
  uint32_t *tmp;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8006976:	68fb      	ldr	r3, [r7, #12]
 8006978:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 800697c:	b2db      	uxtb	r3, r3
 800697e:	2b20      	cmp	r3, #32
 8006980:	d153      	bne.n	8006a2a <HAL_UART_Transmit_DMA+0xc2>
  {
    if ((pData == NULL) || (Size == 0U))
 8006982:	68bb      	ldr	r3, [r7, #8]
 8006984:	2b00      	cmp	r3, #0
 8006986:	d002      	beq.n	800698e <HAL_UART_Transmit_DMA+0x26>
 8006988:	88fb      	ldrh	r3, [r7, #6]
 800698a:	2b00      	cmp	r3, #0
 800698c:	d101      	bne.n	8006992 <HAL_UART_Transmit_DMA+0x2a>
    {
      return HAL_ERROR;
 800698e:	2301      	movs	r3, #1
 8006990:	e04c      	b.n	8006a2c <HAL_UART_Transmit_DMA+0xc4>
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8006992:	68fb      	ldr	r3, [r7, #12]
 8006994:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8006998:	2b01      	cmp	r3, #1
 800699a:	d101      	bne.n	80069a0 <HAL_UART_Transmit_DMA+0x38>
 800699c:	2302      	movs	r3, #2
 800699e:	e045      	b.n	8006a2c <HAL_UART_Transmit_DMA+0xc4>
 80069a0:	68fb      	ldr	r3, [r7, #12]
 80069a2:	2201      	movs	r2, #1
 80069a4:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    huart->pTxBuffPtr = pData;
 80069a8:	68ba      	ldr	r2, [r7, #8]
 80069aa:	68fb      	ldr	r3, [r7, #12]
 80069ac:	621a      	str	r2, [r3, #32]
    huart->TxXferSize = Size;
 80069ae:	68fb      	ldr	r3, [r7, #12]
 80069b0:	88fa      	ldrh	r2, [r7, #6]
 80069b2:	849a      	strh	r2, [r3, #36]	; 0x24
    huart->TxXferCount = Size;
 80069b4:	68fb      	ldr	r3, [r7, #12]
 80069b6:	88fa      	ldrh	r2, [r7, #6]
 80069b8:	84da      	strh	r2, [r3, #38]	; 0x26

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80069ba:	68fb      	ldr	r3, [r7, #12]
 80069bc:	2200      	movs	r2, #0
 80069be:	63da      	str	r2, [r3, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80069c0:	68fb      	ldr	r3, [r7, #12]
 80069c2:	2221      	movs	r2, #33	; 0x21
 80069c4:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

    /* Set the UART DMA transfer complete callback */
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 80069c8:	68fb      	ldr	r3, [r7, #12]
 80069ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80069cc:	4a19      	ldr	r2, [pc, #100]	; (8006a34 <HAL_UART_Transmit_DMA+0xcc>)
 80069ce:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the UART DMA Half transfer complete callback */
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 80069d0:	68fb      	ldr	r3, [r7, #12]
 80069d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80069d4:	4a18      	ldr	r2, [pc, #96]	; (8006a38 <HAL_UART_Transmit_DMA+0xd0>)
 80069d6:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the DMA error callback */
    huart->hdmatx->XferErrorCallback = UART_DMAError;
 80069d8:	68fb      	ldr	r3, [r7, #12]
 80069da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80069dc:	4a17      	ldr	r2, [pc, #92]	; (8006a3c <HAL_UART_Transmit_DMA+0xd4>)
 80069de:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA abort callback */
    huart->hdmatx->XferAbortCallback = NULL;
 80069e0:	68fb      	ldr	r3, [r7, #12]
 80069e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80069e4:	2200      	movs	r2, #0
 80069e6:	651a      	str	r2, [r3, #80]	; 0x50

    /* Enable the UART transmit DMA stream */
    tmp = (uint32_t *)&pData;
 80069e8:	f107 0308 	add.w	r3, r7, #8
 80069ec:	617b      	str	r3, [r7, #20]
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
 80069ee:	68fb      	ldr	r3, [r7, #12]
 80069f0:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80069f2:	697b      	ldr	r3, [r7, #20]
 80069f4:	6819      	ldr	r1, [r3, #0]
 80069f6:	68fb      	ldr	r3, [r7, #12]
 80069f8:	681b      	ldr	r3, [r3, #0]
 80069fa:	3304      	adds	r3, #4
 80069fc:	461a      	mov	r2, r3
 80069fe:	88fb      	ldrh	r3, [r7, #6]
 8006a00:	f7fb fcfa 	bl	80023f8 <HAL_DMA_Start_IT>

    /* Clear the TC flag in the SR register by writing 0 to it */
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
 8006a04:	68fb      	ldr	r3, [r7, #12]
 8006a06:	681b      	ldr	r3, [r3, #0]
 8006a08:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8006a0c:	601a      	str	r2, [r3, #0]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8006a0e:	68fb      	ldr	r3, [r7, #12]
 8006a10:	2200      	movs	r2, #0
 8006a12:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    /* Enable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8006a16:	68fb      	ldr	r3, [r7, #12]
 8006a18:	681b      	ldr	r3, [r3, #0]
 8006a1a:	695a      	ldr	r2, [r3, #20]
 8006a1c:	68fb      	ldr	r3, [r7, #12]
 8006a1e:	681b      	ldr	r3, [r3, #0]
 8006a20:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8006a24:	615a      	str	r2, [r3, #20]

    return HAL_OK;
 8006a26:	2300      	movs	r3, #0
 8006a28:	e000      	b.n	8006a2c <HAL_UART_Transmit_DMA+0xc4>
  }
  else
  {
    return HAL_BUSY;
 8006a2a:	2302      	movs	r3, #2
  }
}
 8006a2c:	4618      	mov	r0, r3
 8006a2e:	3718      	adds	r7, #24
 8006a30:	46bd      	mov	sp, r7
 8006a32:	bd80      	pop	{r7, pc}
 8006a34:	08006d7d 	.word	0x08006d7d
 8006a38:	08006dcf 	.word	0x08006dcf
 8006a3c:	08006e6f 	.word	0x08006e6f

08006a40 <HAL_UART_Receive_DMA>:
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @note   When the UART parity is enabled (PCE = 1) the received data contains the parity bit.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8006a40:	b580      	push	{r7, lr}
 8006a42:	b086      	sub	sp, #24
 8006a44:	af00      	add	r7, sp, #0
 8006a46:	60f8      	str	r0, [r7, #12]
 8006a48:	60b9      	str	r1, [r7, #8]
 8006a4a:	4613      	mov	r3, r2
 8006a4c:	80fb      	strh	r3, [r7, #6]
  uint32_t *tmp;

  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 8006a4e:	68fb      	ldr	r3, [r7, #12]
 8006a50:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 8006a54:	b2db      	uxtb	r3, r3
 8006a56:	2b20      	cmp	r3, #32
 8006a58:	d166      	bne.n	8006b28 <HAL_UART_Receive_DMA+0xe8>
  {
    if ((pData == NULL) || (Size == 0U))
 8006a5a:	68bb      	ldr	r3, [r7, #8]
 8006a5c:	2b00      	cmp	r3, #0
 8006a5e:	d002      	beq.n	8006a66 <HAL_UART_Receive_DMA+0x26>
 8006a60:	88fb      	ldrh	r3, [r7, #6]
 8006a62:	2b00      	cmp	r3, #0
 8006a64:	d101      	bne.n	8006a6a <HAL_UART_Receive_DMA+0x2a>
    {
      return HAL_ERROR;
 8006a66:	2301      	movs	r3, #1
 8006a68:	e05f      	b.n	8006b2a <HAL_UART_Receive_DMA+0xea>
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8006a6a:	68fb      	ldr	r3, [r7, #12]
 8006a6c:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8006a70:	2b01      	cmp	r3, #1
 8006a72:	d101      	bne.n	8006a78 <HAL_UART_Receive_DMA+0x38>
 8006a74:	2302      	movs	r3, #2
 8006a76:	e058      	b.n	8006b2a <HAL_UART_Receive_DMA+0xea>
 8006a78:	68fb      	ldr	r3, [r7, #12]
 8006a7a:	2201      	movs	r2, #1
 8006a7c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    huart->pRxBuffPtr = pData;
 8006a80:	68ba      	ldr	r2, [r7, #8]
 8006a82:	68fb      	ldr	r3, [r7, #12]
 8006a84:	629a      	str	r2, [r3, #40]	; 0x28
    huart->RxXferSize = Size;
 8006a86:	68fb      	ldr	r3, [r7, #12]
 8006a88:	88fa      	ldrh	r2, [r7, #6]
 8006a8a:	859a      	strh	r2, [r3, #44]	; 0x2c

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006a8c:	68fb      	ldr	r3, [r7, #12]
 8006a8e:	2200      	movs	r2, #0
 8006a90:	63da      	str	r2, [r3, #60]	; 0x3c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8006a92:	68fb      	ldr	r3, [r7, #12]
 8006a94:	2222      	movs	r2, #34	; 0x22
 8006a96:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a

    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8006a9a:	68fb      	ldr	r3, [r7, #12]
 8006a9c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006a9e:	4a25      	ldr	r2, [pc, #148]	; (8006b34 <HAL_UART_Receive_DMA+0xf4>)
 8006aa0:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the UART DMA Half transfer complete callback */
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8006aa2:	68fb      	ldr	r3, [r7, #12]
 8006aa4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006aa6:	4a24      	ldr	r2, [pc, #144]	; (8006b38 <HAL_UART_Receive_DMA+0xf8>)
 8006aa8:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the DMA error callback */
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 8006aaa:	68fb      	ldr	r3, [r7, #12]
 8006aac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006aae:	4a23      	ldr	r2, [pc, #140]	; (8006b3c <HAL_UART_Receive_DMA+0xfc>)
 8006ab0:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA abort callback */
    huart->hdmarx->XferAbortCallback = NULL;
 8006ab2:	68fb      	ldr	r3, [r7, #12]
 8006ab4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006ab6:	2200      	movs	r2, #0
 8006ab8:	651a      	str	r2, [r3, #80]	; 0x50

    /* Enable the DMA stream */
    tmp = (uint32_t *)&pData;
 8006aba:	f107 0308 	add.w	r3, r7, #8
 8006abe:	617b      	str	r3, [r7, #20]
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
 8006ac0:	68fb      	ldr	r3, [r7, #12]
 8006ac2:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8006ac4:	68fb      	ldr	r3, [r7, #12]
 8006ac6:	681b      	ldr	r3, [r3, #0]
 8006ac8:	3304      	adds	r3, #4
 8006aca:	4619      	mov	r1, r3
 8006acc:	697b      	ldr	r3, [r7, #20]
 8006ace:	681a      	ldr	r2, [r3, #0]
 8006ad0:	88fb      	ldrh	r3, [r7, #6]
 8006ad2:	f7fb fc91 	bl	80023f8 <HAL_DMA_Start_IT>

    /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
    __HAL_UART_CLEAR_OREFLAG(huart);
 8006ad6:	2300      	movs	r3, #0
 8006ad8:	613b      	str	r3, [r7, #16]
 8006ada:	68fb      	ldr	r3, [r7, #12]
 8006adc:	681b      	ldr	r3, [r3, #0]
 8006ade:	681b      	ldr	r3, [r3, #0]
 8006ae0:	613b      	str	r3, [r7, #16]
 8006ae2:	68fb      	ldr	r3, [r7, #12]
 8006ae4:	681b      	ldr	r3, [r3, #0]
 8006ae6:	685b      	ldr	r3, [r3, #4]
 8006ae8:	613b      	str	r3, [r7, #16]
 8006aea:	693b      	ldr	r3, [r7, #16]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8006aec:	68fb      	ldr	r3, [r7, #12]
 8006aee:	2200      	movs	r2, #0
 8006af0:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    /* Enable the UART Parity Error Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8006af4:	68fb      	ldr	r3, [r7, #12]
 8006af6:	681b      	ldr	r3, [r3, #0]
 8006af8:	68da      	ldr	r2, [r3, #12]
 8006afa:	68fb      	ldr	r3, [r7, #12]
 8006afc:	681b      	ldr	r3, [r3, #0]
 8006afe:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8006b02:	60da      	str	r2, [r3, #12]

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006b04:	68fb      	ldr	r3, [r7, #12]
 8006b06:	681b      	ldr	r3, [r3, #0]
 8006b08:	695a      	ldr	r2, [r3, #20]
 8006b0a:	68fb      	ldr	r3, [r7, #12]
 8006b0c:	681b      	ldr	r3, [r3, #0]
 8006b0e:	f042 0201 	orr.w	r2, r2, #1
 8006b12:	615a      	str	r2, [r3, #20]

    /* Enable the DMA transfer for the receiver request by setting the DMAR bit
    in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8006b14:	68fb      	ldr	r3, [r7, #12]
 8006b16:	681b      	ldr	r3, [r3, #0]
 8006b18:	695a      	ldr	r2, [r3, #20]
 8006b1a:	68fb      	ldr	r3, [r7, #12]
 8006b1c:	681b      	ldr	r3, [r3, #0]
 8006b1e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8006b22:	615a      	str	r2, [r3, #20]

    return HAL_OK;
 8006b24:	2300      	movs	r3, #0
 8006b26:	e000      	b.n	8006b2a <HAL_UART_Receive_DMA+0xea>
  }
  else
  {
    return HAL_BUSY;
 8006b28:	2302      	movs	r3, #2
  }
}
 8006b2a:	4618      	mov	r0, r3
 8006b2c:	3718      	adds	r7, #24
 8006b2e:	46bd      	mov	sp, r7
 8006b30:	bd80      	pop	{r7, pc}
 8006b32:	bf00      	nop
 8006b34:	08006deb 	.word	0x08006deb
 8006b38:	08006e53 	.word	0x08006e53
 8006b3c:	08006e6f 	.word	0x08006e6f

08006b40 <HAL_UART_IRQHandler>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8006b40:	b580      	push	{r7, lr}
 8006b42:	b088      	sub	sp, #32
 8006b44:	af00      	add	r7, sp, #0
 8006b46:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8006b48:	687b      	ldr	r3, [r7, #4]
 8006b4a:	681b      	ldr	r3, [r3, #0]
 8006b4c:	681b      	ldr	r3, [r3, #0]
 8006b4e:	61fb      	str	r3, [r7, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8006b50:	687b      	ldr	r3, [r7, #4]
 8006b52:	681b      	ldr	r3, [r3, #0]
 8006b54:	68db      	ldr	r3, [r3, #12]
 8006b56:	61bb      	str	r3, [r7, #24]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8006b58:	687b      	ldr	r3, [r7, #4]
 8006b5a:	681b      	ldr	r3, [r3, #0]
 8006b5c:	695b      	ldr	r3, [r3, #20]
 8006b5e:	617b      	str	r3, [r7, #20]
  uint32_t errorflags = 0x00U;
 8006b60:	2300      	movs	r3, #0
 8006b62:	613b      	str	r3, [r7, #16]
  uint32_t dmarequest = 0x00U;
 8006b64:	2300      	movs	r3, #0
 8006b66:	60fb      	str	r3, [r7, #12]

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
 8006b68:	69fb      	ldr	r3, [r7, #28]
 8006b6a:	f003 030f 	and.w	r3, r3, #15
 8006b6e:	613b      	str	r3, [r7, #16]
  if (errorflags == RESET)
 8006b70:	693b      	ldr	r3, [r7, #16]
 8006b72:	2b00      	cmp	r3, #0
 8006b74:	d10d      	bne.n	8006b92 <HAL_UART_IRQHandler+0x52>
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8006b76:	69fb      	ldr	r3, [r7, #28]
 8006b78:	f003 0320 	and.w	r3, r3, #32
 8006b7c:	2b00      	cmp	r3, #0
 8006b7e:	d008      	beq.n	8006b92 <HAL_UART_IRQHandler+0x52>
 8006b80:	69bb      	ldr	r3, [r7, #24]
 8006b82:	f003 0320 	and.w	r3, r3, #32
 8006b86:	2b00      	cmp	r3, #0
 8006b88:	d003      	beq.n	8006b92 <HAL_UART_IRQHandler+0x52>
    {
      UART_Receive_IT(huart);
 8006b8a:	6878      	ldr	r0, [r7, #4]
 8006b8c:	f000 fab9 	bl	8007102 <UART_Receive_IT>
      return;
 8006b90:	e0d1      	b.n	8006d36 <HAL_UART_IRQHandler+0x1f6>
    }
  }

  /* If some errors occur */
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8006b92:	693b      	ldr	r3, [r7, #16]
 8006b94:	2b00      	cmp	r3, #0
 8006b96:	f000 80b0 	beq.w	8006cfa <HAL_UART_IRQHandler+0x1ba>
 8006b9a:	697b      	ldr	r3, [r7, #20]
 8006b9c:	f003 0301 	and.w	r3, r3, #1
 8006ba0:	2b00      	cmp	r3, #0
 8006ba2:	d105      	bne.n	8006bb0 <HAL_UART_IRQHandler+0x70>
 8006ba4:	69bb      	ldr	r3, [r7, #24]
 8006ba6:	f403 7390 	and.w	r3, r3, #288	; 0x120
 8006baa:	2b00      	cmp	r3, #0
 8006bac:	f000 80a5 	beq.w	8006cfa <HAL_UART_IRQHandler+0x1ba>
  {
    /* UART parity error interrupt occurred ----------------------------------*/
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8006bb0:	69fb      	ldr	r3, [r7, #28]
 8006bb2:	f003 0301 	and.w	r3, r3, #1
 8006bb6:	2b00      	cmp	r3, #0
 8006bb8:	d00a      	beq.n	8006bd0 <HAL_UART_IRQHandler+0x90>
 8006bba:	69bb      	ldr	r3, [r7, #24]
 8006bbc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8006bc0:	2b00      	cmp	r3, #0
 8006bc2:	d005      	beq.n	8006bd0 <HAL_UART_IRQHandler+0x90>
    {
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8006bc4:	687b      	ldr	r3, [r7, #4]
 8006bc6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006bc8:	f043 0201 	orr.w	r2, r3, #1
 8006bcc:	687b      	ldr	r3, [r7, #4]
 8006bce:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* UART noise error interrupt occurred -----------------------------------*/
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8006bd0:	69fb      	ldr	r3, [r7, #28]
 8006bd2:	f003 0304 	and.w	r3, r3, #4
 8006bd6:	2b00      	cmp	r3, #0
 8006bd8:	d00a      	beq.n	8006bf0 <HAL_UART_IRQHandler+0xb0>
 8006bda:	697b      	ldr	r3, [r7, #20]
 8006bdc:	f003 0301 	and.w	r3, r3, #1
 8006be0:	2b00      	cmp	r3, #0
 8006be2:	d005      	beq.n	8006bf0 <HAL_UART_IRQHandler+0xb0>
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8006be4:	687b      	ldr	r3, [r7, #4]
 8006be6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006be8:	f043 0202 	orr.w	r2, r3, #2
 8006bec:	687b      	ldr	r3, [r7, #4]
 8006bee:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* UART frame error interrupt occurred -----------------------------------*/
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8006bf0:	69fb      	ldr	r3, [r7, #28]
 8006bf2:	f003 0302 	and.w	r3, r3, #2
 8006bf6:	2b00      	cmp	r3, #0
 8006bf8:	d00a      	beq.n	8006c10 <HAL_UART_IRQHandler+0xd0>
 8006bfa:	697b      	ldr	r3, [r7, #20]
 8006bfc:	f003 0301 	and.w	r3, r3, #1
 8006c00:	2b00      	cmp	r3, #0
 8006c02:	d005      	beq.n	8006c10 <HAL_UART_IRQHandler+0xd0>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8006c04:	687b      	ldr	r3, [r7, #4]
 8006c06:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006c08:	f043 0204 	orr.w	r2, r3, #4
 8006c0c:	687b      	ldr	r3, [r7, #4]
 8006c0e:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* UART Over-Run interrupt occurred --------------------------------------*/
    if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 8006c10:	69fb      	ldr	r3, [r7, #28]
 8006c12:	f003 0308 	and.w	r3, r3, #8
 8006c16:	2b00      	cmp	r3, #0
 8006c18:	d00f      	beq.n	8006c3a <HAL_UART_IRQHandler+0xfa>
 8006c1a:	69bb      	ldr	r3, [r7, #24]
 8006c1c:	f003 0320 	and.w	r3, r3, #32
 8006c20:	2b00      	cmp	r3, #0
 8006c22:	d104      	bne.n	8006c2e <HAL_UART_IRQHandler+0xee>
 8006c24:	697b      	ldr	r3, [r7, #20]
 8006c26:	f003 0301 	and.w	r3, r3, #1
 8006c2a:	2b00      	cmp	r3, #0
 8006c2c:	d005      	beq.n	8006c3a <HAL_UART_IRQHandler+0xfa>
    {
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8006c2e:	687b      	ldr	r3, [r7, #4]
 8006c30:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006c32:	f043 0208 	orr.w	r2, r3, #8
 8006c36:	687b      	ldr	r3, [r7, #4]
 8006c38:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* Call UART Error Call back function if need be --------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8006c3a:	687b      	ldr	r3, [r7, #4]
 8006c3c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006c3e:	2b00      	cmp	r3, #0
 8006c40:	d078      	beq.n	8006d34 <HAL_UART_IRQHandler+0x1f4>
    {
      /* UART in mode Receiver -----------------------------------------------*/
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8006c42:	69fb      	ldr	r3, [r7, #28]
 8006c44:	f003 0320 	and.w	r3, r3, #32
 8006c48:	2b00      	cmp	r3, #0
 8006c4a:	d007      	beq.n	8006c5c <HAL_UART_IRQHandler+0x11c>
 8006c4c:	69bb      	ldr	r3, [r7, #24]
 8006c4e:	f003 0320 	and.w	r3, r3, #32
 8006c52:	2b00      	cmp	r3, #0
 8006c54:	d002      	beq.n	8006c5c <HAL_UART_IRQHandler+0x11c>
      {
        UART_Receive_IT(huart);
 8006c56:	6878      	ldr	r0, [r7, #4]
 8006c58:	f000 fa53 	bl	8007102 <UART_Receive_IT>
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8006c5c:	687b      	ldr	r3, [r7, #4]
 8006c5e:	681b      	ldr	r3, [r3, #0]
 8006c60:	695b      	ldr	r3, [r3, #20]
 8006c62:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006c66:	2b40      	cmp	r3, #64	; 0x40
 8006c68:	bf0c      	ite	eq
 8006c6a:	2301      	moveq	r3, #1
 8006c6c:	2300      	movne	r3, #0
 8006c6e:	b2db      	uxtb	r3, r3
 8006c70:	60fb      	str	r3, [r7, #12]
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8006c72:	687b      	ldr	r3, [r7, #4]
 8006c74:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006c76:	f003 0308 	and.w	r3, r3, #8
 8006c7a:	2b00      	cmp	r3, #0
 8006c7c:	d102      	bne.n	8006c84 <HAL_UART_IRQHandler+0x144>
 8006c7e:	68fb      	ldr	r3, [r7, #12]
 8006c80:	2b00      	cmp	r3, #0
 8006c82:	d031      	beq.n	8006ce8 <HAL_UART_IRQHandler+0x1a8>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 8006c84:	6878      	ldr	r0, [r7, #4]
 8006c86:	f000 f99c 	bl	8006fc2 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8006c8a:	687b      	ldr	r3, [r7, #4]
 8006c8c:	681b      	ldr	r3, [r3, #0]
 8006c8e:	695b      	ldr	r3, [r3, #20]
 8006c90:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006c94:	2b40      	cmp	r3, #64	; 0x40
 8006c96:	d123      	bne.n	8006ce0 <HAL_UART_IRQHandler+0x1a0>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8006c98:	687b      	ldr	r3, [r7, #4]
 8006c9a:	681b      	ldr	r3, [r3, #0]
 8006c9c:	695a      	ldr	r2, [r3, #20]
 8006c9e:	687b      	ldr	r3, [r7, #4]
 8006ca0:	681b      	ldr	r3, [r3, #0]
 8006ca2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8006ca6:	615a      	str	r2, [r3, #20]

          /* Abort the UART DMA Rx stream */
          if (huart->hdmarx != NULL)
 8006ca8:	687b      	ldr	r3, [r7, #4]
 8006caa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006cac:	2b00      	cmp	r3, #0
 8006cae:	d013      	beq.n	8006cd8 <HAL_UART_IRQHandler+0x198>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8006cb0:	687b      	ldr	r3, [r7, #4]
 8006cb2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006cb4:	4a21      	ldr	r2, [pc, #132]	; (8006d3c <HAL_UART_IRQHandler+0x1fc>)
 8006cb6:	651a      	str	r2, [r3, #80]	; 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8006cb8:	687b      	ldr	r3, [r7, #4]
 8006cba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006cbc:	4618      	mov	r0, r3
 8006cbe:	f7fb fbf3 	bl	80024a8 <HAL_DMA_Abort_IT>
 8006cc2:	4603      	mov	r3, r0
 8006cc4:	2b00      	cmp	r3, #0
 8006cc6:	d016      	beq.n	8006cf6 <HAL_UART_IRQHandler+0x1b6>
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8006cc8:	687b      	ldr	r3, [r7, #4]
 8006cca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006ccc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8006cce:	687a      	ldr	r2, [r7, #4]
 8006cd0:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8006cd2:	4610      	mov	r0, r2
 8006cd4:	4798      	blx	r3
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8006cd6:	e00e      	b.n	8006cf6 <HAL_UART_IRQHandler+0x1b6>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 8006cd8:	6878      	ldr	r0, [r7, #4]
 8006cda:	f000 f845 	bl	8006d68 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8006cde:	e00a      	b.n	8006cf6 <HAL_UART_IRQHandler+0x1b6>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 8006ce0:	6878      	ldr	r0, [r7, #4]
 8006ce2:	f000 f841 	bl	8006d68 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8006ce6:	e006      	b.n	8006cf6 <HAL_UART_IRQHandler+0x1b6>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 8006ce8:	6878      	ldr	r0, [r7, #4]
 8006cea:	f000 f83d 	bl	8006d68 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006cee:	687b      	ldr	r3, [r7, #4]
 8006cf0:	2200      	movs	r2, #0
 8006cf2:	63da      	str	r2, [r3, #60]	; 0x3c
      }
    }
    return;
 8006cf4:	e01e      	b.n	8006d34 <HAL_UART_IRQHandler+0x1f4>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8006cf6:	bf00      	nop
    return;
 8006cf8:	e01c      	b.n	8006d34 <HAL_UART_IRQHandler+0x1f4>
  } /* End if some error occurs */

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8006cfa:	69fb      	ldr	r3, [r7, #28]
 8006cfc:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006d00:	2b00      	cmp	r3, #0
 8006d02:	d008      	beq.n	8006d16 <HAL_UART_IRQHandler+0x1d6>
 8006d04:	69bb      	ldr	r3, [r7, #24]
 8006d06:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006d0a:	2b00      	cmp	r3, #0
 8006d0c:	d003      	beq.n	8006d16 <HAL_UART_IRQHandler+0x1d6>
  {
    UART_Transmit_IT(huart);
 8006d0e:	6878      	ldr	r0, [r7, #4]
 8006d10:	f000 f989 	bl	8007026 <UART_Transmit_IT>
    return;
 8006d14:	e00f      	b.n	8006d36 <HAL_UART_IRQHandler+0x1f6>
  }

  /* UART in mode Transmitter end --------------------------------------------*/
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8006d16:	69fb      	ldr	r3, [r7, #28]
 8006d18:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006d1c:	2b00      	cmp	r3, #0
 8006d1e:	d00a      	beq.n	8006d36 <HAL_UART_IRQHandler+0x1f6>
 8006d20:	69bb      	ldr	r3, [r7, #24]
 8006d22:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006d26:	2b00      	cmp	r3, #0
 8006d28:	d005      	beq.n	8006d36 <HAL_UART_IRQHandler+0x1f6>
  {
    UART_EndTransmit_IT(huart);
 8006d2a:	6878      	ldr	r0, [r7, #4]
 8006d2c:	f000 f9d1 	bl	80070d2 <UART_EndTransmit_IT>
    return;
 8006d30:	bf00      	nop
 8006d32:	e000      	b.n	8006d36 <HAL_UART_IRQHandler+0x1f6>
    return;
 8006d34:	bf00      	nop
  }
}
 8006d36:	3720      	adds	r7, #32
 8006d38:	46bd      	mov	sp, r7
 8006d3a:	bd80      	pop	{r7, pc}
 8006d3c:	08006fff 	.word	0x08006fff

08006d40 <HAL_UART_TxHalfCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 8006d40:	b480      	push	{r7}
 8006d42:	b083      	sub	sp, #12
 8006d44:	af00      	add	r7, sp, #0
 8006d46:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_TxHalfCpltCallback could be implemented in the user file
   */
}
 8006d48:	bf00      	nop
 8006d4a:	370c      	adds	r7, #12
 8006d4c:	46bd      	mov	sp, r7
 8006d4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d52:	4770      	bx	lr

08006d54 <HAL_UART_RxHalfCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 8006d54:	b480      	push	{r7}
 8006d56:	b083      	sub	sp, #12
 8006d58:	af00      	add	r7, sp, #0
 8006d5a:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxHalfCpltCallback could be implemented in the user file
   */
}
 8006d5c:	bf00      	nop
 8006d5e:	370c      	adds	r7, #12
 8006d60:	46bd      	mov	sp, r7
 8006d62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d66:	4770      	bx	lr

08006d68 <HAL_UART_ErrorCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8006d68:	b480      	push	{r7}
 8006d6a:	b083      	sub	sp, #12
 8006d6c:	af00      	add	r7, sp, #0
 8006d6e:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_ErrorCallback could be implemented in the user file
   */
}
 8006d70:	bf00      	nop
 8006d72:	370c      	adds	r7, #12
 8006d74:	46bd      	mov	sp, r7
 8006d76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d7a:	4770      	bx	lr

08006d7c <UART_DMATransmitCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 8006d7c:	b580      	push	{r7, lr}
 8006d7e:	b084      	sub	sp, #16
 8006d80:	af00      	add	r7, sp, #0
 8006d82:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8006d84:	687b      	ldr	r3, [r7, #4]
 8006d86:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8006d88:	60fb      	str	r3, [r7, #12]
  /* DMA Normal mode*/
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8006d8a:	687b      	ldr	r3, [r7, #4]
 8006d8c:	681b      	ldr	r3, [r3, #0]
 8006d8e:	681b      	ldr	r3, [r3, #0]
 8006d90:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8006d94:	2b00      	cmp	r3, #0
 8006d96:	d113      	bne.n	8006dc0 <UART_DMATransmitCplt+0x44>
  {
    huart->TxXferCount = 0x00U;
 8006d98:	68fb      	ldr	r3, [r7, #12]
 8006d9a:	2200      	movs	r2, #0
 8006d9c:	84da      	strh	r2, [r3, #38]	; 0x26

    /* Disable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8006d9e:	68fb      	ldr	r3, [r7, #12]
 8006da0:	681b      	ldr	r3, [r3, #0]
 8006da2:	695a      	ldr	r2, [r3, #20]
 8006da4:	68fb      	ldr	r3, [r7, #12]
 8006da6:	681b      	ldr	r3, [r3, #0]
 8006da8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8006dac:	615a      	str	r2, [r3, #20]

    /* Enable the UART Transmit Complete Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8006dae:	68fb      	ldr	r3, [r7, #12]
 8006db0:	681b      	ldr	r3, [r3, #0]
 8006db2:	68da      	ldr	r2, [r3, #12]
 8006db4:	68fb      	ldr	r3, [r7, #12]
 8006db6:	681b      	ldr	r3, [r3, #0]
 8006db8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8006dbc:	60da      	str	r2, [r3, #12]
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 8006dbe:	e002      	b.n	8006dc6 <UART_DMATransmitCplt+0x4a>
    HAL_UART_TxCpltCallback(huart);
 8006dc0:	68f8      	ldr	r0, [r7, #12]
 8006dc2:	f7fb f847 	bl	8001e54 <HAL_UART_TxCpltCallback>
}
 8006dc6:	bf00      	nop
 8006dc8:	3710      	adds	r7, #16
 8006dca:	46bd      	mov	sp, r7
 8006dcc:	bd80      	pop	{r7, pc}

08006dce <UART_DMATxHalfCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 8006dce:	b580      	push	{r7, lr}
 8006dd0:	b084      	sub	sp, #16
 8006dd2:	af00      	add	r7, sp, #0
 8006dd4:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8006dd6:	687b      	ldr	r3, [r7, #4]
 8006dd8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8006dda:	60fb      	str	r3, [r7, #12]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 8006ddc:	68f8      	ldr	r0, [r7, #12]
 8006dde:	f7ff ffaf 	bl	8006d40 <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8006de2:	bf00      	nop
 8006de4:	3710      	adds	r7, #16
 8006de6:	46bd      	mov	sp, r7
 8006de8:	bd80      	pop	{r7, pc}

08006dea <UART_DMAReceiveCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
 8006dea:	b580      	push	{r7, lr}
 8006dec:	b084      	sub	sp, #16
 8006dee:	af00      	add	r7, sp, #0
 8006df0:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8006df2:	687b      	ldr	r3, [r7, #4]
 8006df4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8006df6:	60fb      	str	r3, [r7, #12]
  /* DMA Normal mode*/
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8006df8:	687b      	ldr	r3, [r7, #4]
 8006dfa:	681b      	ldr	r3, [r3, #0]
 8006dfc:	681b      	ldr	r3, [r3, #0]
 8006dfe:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8006e02:	2b00      	cmp	r3, #0
 8006e04:	d11e      	bne.n	8006e44 <UART_DMAReceiveCplt+0x5a>
  {
    huart->RxXferCount = 0U;
 8006e06:	68fb      	ldr	r3, [r7, #12]
 8006e08:	2200      	movs	r2, #0
 8006e0a:	85da      	strh	r2, [r3, #46]	; 0x2e

    /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8006e0c:	68fb      	ldr	r3, [r7, #12]
 8006e0e:	681b      	ldr	r3, [r3, #0]
 8006e10:	68da      	ldr	r2, [r3, #12]
 8006e12:	68fb      	ldr	r3, [r7, #12]
 8006e14:	681b      	ldr	r3, [r3, #0]
 8006e16:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8006e1a:	60da      	str	r2, [r3, #12]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006e1c:	68fb      	ldr	r3, [r7, #12]
 8006e1e:	681b      	ldr	r3, [r3, #0]
 8006e20:	695a      	ldr	r2, [r3, #20]
 8006e22:	68fb      	ldr	r3, [r7, #12]
 8006e24:	681b      	ldr	r3, [r3, #0]
 8006e26:	f022 0201 	bic.w	r2, r2, #1
 8006e2a:	615a      	str	r2, [r3, #20]

    /* Disable the DMA transfer for the receiver request by setting the DMAR bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8006e2c:	68fb      	ldr	r3, [r7, #12]
 8006e2e:	681b      	ldr	r3, [r3, #0]
 8006e30:	695a      	ldr	r2, [r3, #20]
 8006e32:	68fb      	ldr	r3, [r7, #12]
 8006e34:	681b      	ldr	r3, [r3, #0]
 8006e36:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8006e3a:	615a      	str	r2, [r3, #20]

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
 8006e3c:	68fb      	ldr	r3, [r7, #12]
 8006e3e:	2220      	movs	r2, #32
 8006e40:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Rx complete callback*/
  huart->RxCpltCallback(huart);
#else
  /*Call legacy weak Rx complete callback*/
  HAL_UART_RxCpltCallback(huart);
 8006e44:	68f8      	ldr	r0, [r7, #12]
 8006e46:	f7fb f819 	bl	8001e7c <HAL_UART_RxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8006e4a:	bf00      	nop
 8006e4c:	3710      	adds	r7, #16
 8006e4e:	46bd      	mov	sp, r7
 8006e50:	bd80      	pop	{r7, pc}

08006e52 <UART_DMARxHalfCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 8006e52:	b580      	push	{r7, lr}
 8006e54:	b084      	sub	sp, #16
 8006e56:	af00      	add	r7, sp, #0
 8006e58:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8006e5a:	687b      	ldr	r3, [r7, #4]
 8006e5c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8006e5e:	60fb      	str	r3, [r7, #12]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Rx Half complete callback*/
  huart->RxHalfCpltCallback(huart);
#else
  /*Call legacy weak Rx Half complete callback*/
  HAL_UART_RxHalfCpltCallback(huart);
 8006e60:	68f8      	ldr	r0, [r7, #12]
 8006e62:	f7ff ff77 	bl	8006d54 <HAL_UART_RxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8006e66:	bf00      	nop
 8006e68:	3710      	adds	r7, #16
 8006e6a:	46bd      	mov	sp, r7
 8006e6c:	bd80      	pop	{r7, pc}

08006e6e <UART_DMAError>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
 8006e6e:	b580      	push	{r7, lr}
 8006e70:	b084      	sub	sp, #16
 8006e72:	af00      	add	r7, sp, #0
 8006e74:	6078      	str	r0, [r7, #4]
  uint32_t dmarequest = 0x00U;
 8006e76:	2300      	movs	r3, #0
 8006e78:	60fb      	str	r3, [r7, #12]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8006e7a:	687b      	ldr	r3, [r7, #4]
 8006e7c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8006e7e:	60bb      	str	r3, [r7, #8]

  /* Stop UART DMA Tx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 8006e80:	68bb      	ldr	r3, [r7, #8]
 8006e82:	681b      	ldr	r3, [r3, #0]
 8006e84:	695b      	ldr	r3, [r3, #20]
 8006e86:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006e8a:	2b80      	cmp	r3, #128	; 0x80
 8006e8c:	bf0c      	ite	eq
 8006e8e:	2301      	moveq	r3, #1
 8006e90:	2300      	movne	r3, #0
 8006e92:	b2db      	uxtb	r3, r3
 8006e94:	60fb      	str	r3, [r7, #12]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 8006e96:	68bb      	ldr	r3, [r7, #8]
 8006e98:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8006e9c:	b2db      	uxtb	r3, r3
 8006e9e:	2b21      	cmp	r3, #33	; 0x21
 8006ea0:	d108      	bne.n	8006eb4 <UART_DMAError+0x46>
 8006ea2:	68fb      	ldr	r3, [r7, #12]
 8006ea4:	2b00      	cmp	r3, #0
 8006ea6:	d005      	beq.n	8006eb4 <UART_DMAError+0x46>
  {
    huart->TxXferCount = 0x00U;
 8006ea8:	68bb      	ldr	r3, [r7, #8]
 8006eaa:	2200      	movs	r2, #0
 8006eac:	84da      	strh	r2, [r3, #38]	; 0x26
    UART_EndTxTransfer(huart);
 8006eae:	68b8      	ldr	r0, [r7, #8]
 8006eb0:	f000 f871 	bl	8006f96 <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8006eb4:	68bb      	ldr	r3, [r7, #8]
 8006eb6:	681b      	ldr	r3, [r3, #0]
 8006eb8:	695b      	ldr	r3, [r3, #20]
 8006eba:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006ebe:	2b40      	cmp	r3, #64	; 0x40
 8006ec0:	bf0c      	ite	eq
 8006ec2:	2301      	moveq	r3, #1
 8006ec4:	2300      	movne	r3, #0
 8006ec6:	b2db      	uxtb	r3, r3
 8006ec8:	60fb      	str	r3, [r7, #12]
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8006eca:	68bb      	ldr	r3, [r7, #8]
 8006ecc:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 8006ed0:	b2db      	uxtb	r3, r3
 8006ed2:	2b22      	cmp	r3, #34	; 0x22
 8006ed4:	d108      	bne.n	8006ee8 <UART_DMAError+0x7a>
 8006ed6:	68fb      	ldr	r3, [r7, #12]
 8006ed8:	2b00      	cmp	r3, #0
 8006eda:	d005      	beq.n	8006ee8 <UART_DMAError+0x7a>
  {
    huart->RxXferCount = 0x00U;
 8006edc:	68bb      	ldr	r3, [r7, #8]
 8006ede:	2200      	movs	r2, #0
 8006ee0:	85da      	strh	r2, [r3, #46]	; 0x2e
    UART_EndRxTransfer(huart);
 8006ee2:	68b8      	ldr	r0, [r7, #8]
 8006ee4:	f000 f86d 	bl	8006fc2 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8006ee8:	68bb      	ldr	r3, [r7, #8]
 8006eea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006eec:	f043 0210 	orr.w	r2, r3, #16
 8006ef0:	68bb      	ldr	r3, [r7, #8]
 8006ef2:	63da      	str	r2, [r3, #60]	; 0x3c
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8006ef4:	68b8      	ldr	r0, [r7, #8]
 8006ef6:	f7ff ff37 	bl	8006d68 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8006efa:	bf00      	nop
 8006efc:	3710      	adds	r7, #16
 8006efe:	46bd      	mov	sp, r7
 8006f00:	bd80      	pop	{r7, pc}

08006f02 <UART_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 8006f02:	b580      	push	{r7, lr}
 8006f04:	b084      	sub	sp, #16
 8006f06:	af00      	add	r7, sp, #0
 8006f08:	60f8      	str	r0, [r7, #12]
 8006f0a:	60b9      	str	r1, [r7, #8]
 8006f0c:	603b      	str	r3, [r7, #0]
 8006f0e:	4613      	mov	r3, r2
 8006f10:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006f12:	e02c      	b.n	8006f6e <UART_WaitOnFlagUntilTimeout+0x6c>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8006f14:	69bb      	ldr	r3, [r7, #24]
 8006f16:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006f1a:	d028      	beq.n	8006f6e <UART_WaitOnFlagUntilTimeout+0x6c>
    {
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8006f1c:	69bb      	ldr	r3, [r7, #24]
 8006f1e:	2b00      	cmp	r3, #0
 8006f20:	d007      	beq.n	8006f32 <UART_WaitOnFlagUntilTimeout+0x30>
 8006f22:	f7fb f8ab 	bl	800207c <HAL_GetTick>
 8006f26:	4602      	mov	r2, r0
 8006f28:	683b      	ldr	r3, [r7, #0]
 8006f2a:	1ad3      	subs	r3, r2, r3
 8006f2c:	69ba      	ldr	r2, [r7, #24]
 8006f2e:	429a      	cmp	r2, r3
 8006f30:	d21d      	bcs.n	8006f6e <UART_WaitOnFlagUntilTimeout+0x6c>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8006f32:	68fb      	ldr	r3, [r7, #12]
 8006f34:	681b      	ldr	r3, [r3, #0]
 8006f36:	68da      	ldr	r2, [r3, #12]
 8006f38:	68fb      	ldr	r3, [r7, #12]
 8006f3a:	681b      	ldr	r3, [r3, #0]
 8006f3c:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8006f40:	60da      	str	r2, [r3, #12]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006f42:	68fb      	ldr	r3, [r7, #12]
 8006f44:	681b      	ldr	r3, [r3, #0]
 8006f46:	695a      	ldr	r2, [r3, #20]
 8006f48:	68fb      	ldr	r3, [r7, #12]
 8006f4a:	681b      	ldr	r3, [r3, #0]
 8006f4c:	f022 0201 	bic.w	r2, r2, #1
 8006f50:	615a      	str	r2, [r3, #20]

        huart->gState  = HAL_UART_STATE_READY;
 8006f52:	68fb      	ldr	r3, [r7, #12]
 8006f54:	2220      	movs	r2, #32
 8006f56:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
        huart->RxState = HAL_UART_STATE_READY;
 8006f5a:	68fb      	ldr	r3, [r7, #12]
 8006f5c:	2220      	movs	r2, #32
 8006f5e:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 8006f62:	68fb      	ldr	r3, [r7, #12]
 8006f64:	2200      	movs	r2, #0
 8006f66:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

        return HAL_TIMEOUT;
 8006f6a:	2303      	movs	r3, #3
 8006f6c:	e00f      	b.n	8006f8e <UART_WaitOnFlagUntilTimeout+0x8c>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006f6e:	68fb      	ldr	r3, [r7, #12]
 8006f70:	681b      	ldr	r3, [r3, #0]
 8006f72:	681a      	ldr	r2, [r3, #0]
 8006f74:	68bb      	ldr	r3, [r7, #8]
 8006f76:	4013      	ands	r3, r2
 8006f78:	68ba      	ldr	r2, [r7, #8]
 8006f7a:	429a      	cmp	r2, r3
 8006f7c:	bf0c      	ite	eq
 8006f7e:	2301      	moveq	r3, #1
 8006f80:	2300      	movne	r3, #0
 8006f82:	b2db      	uxtb	r3, r3
 8006f84:	461a      	mov	r2, r3
 8006f86:	79fb      	ldrb	r3, [r7, #7]
 8006f88:	429a      	cmp	r2, r3
 8006f8a:	d0c3      	beq.n	8006f14 <UART_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 8006f8c:	2300      	movs	r3, #0
}
 8006f8e:	4618      	mov	r0, r3
 8006f90:	3710      	adds	r7, #16
 8006f92:	46bd      	mov	sp, r7
 8006f94:	bd80      	pop	{r7, pc}

08006f96 <UART_EndTxTransfer>:
  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
 8006f96:	b480      	push	{r7}
 8006f98:	b083      	sub	sp, #12
 8006f9a:	af00      	add	r7, sp, #0
 8006f9c:	6078      	str	r0, [r7, #4]
  /* Disable TXEIE and TCIE interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 8006f9e:	687b      	ldr	r3, [r7, #4]
 8006fa0:	681b      	ldr	r3, [r3, #0]
 8006fa2:	68da      	ldr	r2, [r3, #12]
 8006fa4:	687b      	ldr	r3, [r7, #4]
 8006fa6:	681b      	ldr	r3, [r3, #0]
 8006fa8:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8006fac:	60da      	str	r2, [r3, #12]

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8006fae:	687b      	ldr	r3, [r7, #4]
 8006fb0:	2220      	movs	r2, #32
 8006fb2:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
}
 8006fb6:	bf00      	nop
 8006fb8:	370c      	adds	r7, #12
 8006fba:	46bd      	mov	sp, r7
 8006fbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006fc0:	4770      	bx	lr

08006fc2 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8006fc2:	b480      	push	{r7}
 8006fc4:	b083      	sub	sp, #12
 8006fc6:	af00      	add	r7, sp, #0
 8006fc8:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8006fca:	687b      	ldr	r3, [r7, #4]
 8006fcc:	681b      	ldr	r3, [r3, #0]
 8006fce:	68da      	ldr	r2, [r3, #12]
 8006fd0:	687b      	ldr	r3, [r7, #4]
 8006fd2:	681b      	ldr	r3, [r3, #0]
 8006fd4:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 8006fd8:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006fda:	687b      	ldr	r3, [r7, #4]
 8006fdc:	681b      	ldr	r3, [r3, #0]
 8006fde:	695a      	ldr	r2, [r3, #20]
 8006fe0:	687b      	ldr	r3, [r7, #4]
 8006fe2:	681b      	ldr	r3, [r3, #0]
 8006fe4:	f022 0201 	bic.w	r2, r2, #1
 8006fe8:	615a      	str	r2, [r3, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8006fea:	687b      	ldr	r3, [r7, #4]
 8006fec:	2220      	movs	r2, #32
 8006fee:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
}
 8006ff2:	bf00      	nop
 8006ff4:	370c      	adds	r7, #12
 8006ff6:	46bd      	mov	sp, r7
 8006ff8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ffc:	4770      	bx	lr

08006ffe <UART_DMAAbortOnError>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8006ffe:	b580      	push	{r7, lr}
 8007000:	b084      	sub	sp, #16
 8007002:	af00      	add	r7, sp, #0
 8007004:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8007006:	687b      	ldr	r3, [r7, #4]
 8007008:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800700a:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0x00U;
 800700c:	68fb      	ldr	r3, [r7, #12]
 800700e:	2200      	movs	r2, #0
 8007010:	85da      	strh	r2, [r3, #46]	; 0x2e
  huart->TxXferCount = 0x00U;
 8007012:	68fb      	ldr	r3, [r7, #12]
 8007014:	2200      	movs	r2, #0
 8007016:	84da      	strh	r2, [r3, #38]	; 0x26
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8007018:	68f8      	ldr	r0, [r7, #12]
 800701a:	f7ff fea5 	bl	8006d68 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800701e:	bf00      	nop
 8007020:	3710      	adds	r7, #16
 8007022:	46bd      	mov	sp, r7
 8007024:	bd80      	pop	{r7, pc}

08007026 <UART_Transmit_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
 8007026:	b480      	push	{r7}
 8007028:	b085      	sub	sp, #20
 800702a:	af00      	add	r7, sp, #0
 800702c:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 800702e:	687b      	ldr	r3, [r7, #4]
 8007030:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8007034:	b2db      	uxtb	r3, r3
 8007036:	2b21      	cmp	r3, #33	; 0x21
 8007038:	d144      	bne.n	80070c4 <UART_Transmit_IT+0x9e>
  {
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 800703a:	687b      	ldr	r3, [r7, #4]
 800703c:	689b      	ldr	r3, [r3, #8]
 800703e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8007042:	d11a      	bne.n	800707a <UART_Transmit_IT+0x54>
    {
      tmp = (uint16_t *) huart->pTxBuffPtr;
 8007044:	687b      	ldr	r3, [r7, #4]
 8007046:	6a1b      	ldr	r3, [r3, #32]
 8007048:	60fb      	str	r3, [r7, #12]
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 800704a:	68fb      	ldr	r3, [r7, #12]
 800704c:	881b      	ldrh	r3, [r3, #0]
 800704e:	461a      	mov	r2, r3
 8007050:	687b      	ldr	r3, [r7, #4]
 8007052:	681b      	ldr	r3, [r3, #0]
 8007054:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8007058:	605a      	str	r2, [r3, #4]
      if (huart->Init.Parity == UART_PARITY_NONE)
 800705a:	687b      	ldr	r3, [r7, #4]
 800705c:	691b      	ldr	r3, [r3, #16]
 800705e:	2b00      	cmp	r3, #0
 8007060:	d105      	bne.n	800706e <UART_Transmit_IT+0x48>
      {
        huart->pTxBuffPtr += 2U;
 8007062:	687b      	ldr	r3, [r7, #4]
 8007064:	6a1b      	ldr	r3, [r3, #32]
 8007066:	1c9a      	adds	r2, r3, #2
 8007068:	687b      	ldr	r3, [r7, #4]
 800706a:	621a      	str	r2, [r3, #32]
 800706c:	e00e      	b.n	800708c <UART_Transmit_IT+0x66>
      }
      else
      {
        huart->pTxBuffPtr += 1U;
 800706e:	687b      	ldr	r3, [r7, #4]
 8007070:	6a1b      	ldr	r3, [r3, #32]
 8007072:	1c5a      	adds	r2, r3, #1
 8007074:	687b      	ldr	r3, [r7, #4]
 8007076:	621a      	str	r2, [r3, #32]
 8007078:	e008      	b.n	800708c <UART_Transmit_IT+0x66>
      }
    }
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 800707a:	687b      	ldr	r3, [r7, #4]
 800707c:	6a1b      	ldr	r3, [r3, #32]
 800707e:	1c59      	adds	r1, r3, #1
 8007080:	687a      	ldr	r2, [r7, #4]
 8007082:	6211      	str	r1, [r2, #32]
 8007084:	781a      	ldrb	r2, [r3, #0]
 8007086:	687b      	ldr	r3, [r7, #4]
 8007088:	681b      	ldr	r3, [r3, #0]
 800708a:	605a      	str	r2, [r3, #4]
    }

    if (--huart->TxXferCount == 0U)
 800708c:	687b      	ldr	r3, [r7, #4]
 800708e:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8007090:	b29b      	uxth	r3, r3
 8007092:	3b01      	subs	r3, #1
 8007094:	b29b      	uxth	r3, r3
 8007096:	687a      	ldr	r2, [r7, #4]
 8007098:	4619      	mov	r1, r3
 800709a:	84d1      	strh	r1, [r2, #38]	; 0x26
 800709c:	2b00      	cmp	r3, #0
 800709e:	d10f      	bne.n	80070c0 <UART_Transmit_IT+0x9a>
    {
      /* Disable the UART Transmit Complete Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 80070a0:	687b      	ldr	r3, [r7, #4]
 80070a2:	681b      	ldr	r3, [r3, #0]
 80070a4:	68da      	ldr	r2, [r3, #12]
 80070a6:	687b      	ldr	r3, [r7, #4]
 80070a8:	681b      	ldr	r3, [r3, #0]
 80070aa:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80070ae:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 80070b0:	687b      	ldr	r3, [r7, #4]
 80070b2:	681b      	ldr	r3, [r3, #0]
 80070b4:	68da      	ldr	r2, [r3, #12]
 80070b6:	687b      	ldr	r3, [r7, #4]
 80070b8:	681b      	ldr	r3, [r3, #0]
 80070ba:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80070be:	60da      	str	r2, [r3, #12]
    }
    return HAL_OK;
 80070c0:	2300      	movs	r3, #0
 80070c2:	e000      	b.n	80070c6 <UART_Transmit_IT+0xa0>
  }
  else
  {
    return HAL_BUSY;
 80070c4:	2302      	movs	r3, #2
  }
}
 80070c6:	4618      	mov	r0, r3
 80070c8:	3714      	adds	r7, #20
 80070ca:	46bd      	mov	sp, r7
 80070cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80070d0:	4770      	bx	lr

080070d2 <UART_EndTransmit_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 80070d2:	b580      	push	{r7, lr}
 80070d4:	b082      	sub	sp, #8
 80070d6:	af00      	add	r7, sp, #0
 80070d8:	6078      	str	r0, [r7, #4]
  /* Disable the UART Transmit Complete Interrupt */
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 80070da:	687b      	ldr	r3, [r7, #4]
 80070dc:	681b      	ldr	r3, [r3, #0]
 80070de:	68da      	ldr	r2, [r3, #12]
 80070e0:	687b      	ldr	r3, [r7, #4]
 80070e2:	681b      	ldr	r3, [r3, #0]
 80070e4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80070e8:	60da      	str	r2, [r3, #12]

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 80070ea:	687b      	ldr	r3, [r7, #4]
 80070ec:	2220      	movs	r2, #32
 80070ee:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 80070f2:	6878      	ldr	r0, [r7, #4]
 80070f4:	f7fa feae 	bl	8001e54 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

  return HAL_OK;
 80070f8:	2300      	movs	r3, #0
}
 80070fa:	4618      	mov	r0, r3
 80070fc:	3708      	adds	r7, #8
 80070fe:	46bd      	mov	sp, r7
 8007100:	bd80      	pop	{r7, pc}

08007102 <UART_Receive_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
 8007102:	b580      	push	{r7, lr}
 8007104:	b084      	sub	sp, #16
 8007106:	af00      	add	r7, sp, #0
 8007108:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800710a:	687b      	ldr	r3, [r7, #4]
 800710c:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 8007110:	b2db      	uxtb	r3, r3
 8007112:	2b22      	cmp	r3, #34	; 0x22
 8007114:	d171      	bne.n	80071fa <UART_Receive_IT+0xf8>
  {
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 8007116:	687b      	ldr	r3, [r7, #4]
 8007118:	689b      	ldr	r3, [r3, #8]
 800711a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800711e:	d123      	bne.n	8007168 <UART_Receive_IT+0x66>
    {
      tmp = (uint16_t *) huart->pRxBuffPtr;
 8007120:	687b      	ldr	r3, [r7, #4]
 8007122:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007124:	60fb      	str	r3, [r7, #12]
      if (huart->Init.Parity == UART_PARITY_NONE)
 8007126:	687b      	ldr	r3, [r7, #4]
 8007128:	691b      	ldr	r3, [r3, #16]
 800712a:	2b00      	cmp	r3, #0
 800712c:	d10e      	bne.n	800714c <UART_Receive_IT+0x4a>
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 800712e:	687b      	ldr	r3, [r7, #4]
 8007130:	681b      	ldr	r3, [r3, #0]
 8007132:	685b      	ldr	r3, [r3, #4]
 8007134:	b29b      	uxth	r3, r3
 8007136:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800713a:	b29a      	uxth	r2, r3
 800713c:	68fb      	ldr	r3, [r7, #12]
 800713e:	801a      	strh	r2, [r3, #0]
        huart->pRxBuffPtr += 2U;
 8007140:	687b      	ldr	r3, [r7, #4]
 8007142:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007144:	1c9a      	adds	r2, r3, #2
 8007146:	687b      	ldr	r3, [r7, #4]
 8007148:	629a      	str	r2, [r3, #40]	; 0x28
 800714a:	e029      	b.n	80071a0 <UART_Receive_IT+0x9e>
      }
      else
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
 800714c:	687b      	ldr	r3, [r7, #4]
 800714e:	681b      	ldr	r3, [r3, #0]
 8007150:	685b      	ldr	r3, [r3, #4]
 8007152:	b29b      	uxth	r3, r3
 8007154:	b2db      	uxtb	r3, r3
 8007156:	b29a      	uxth	r2, r3
 8007158:	68fb      	ldr	r3, [r7, #12]
 800715a:	801a      	strh	r2, [r3, #0]
        huart->pRxBuffPtr += 1U;
 800715c:	687b      	ldr	r3, [r7, #4]
 800715e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007160:	1c5a      	adds	r2, r3, #1
 8007162:	687b      	ldr	r3, [r7, #4]
 8007164:	629a      	str	r2, [r3, #40]	; 0x28
 8007166:	e01b      	b.n	80071a0 <UART_Receive_IT+0x9e>
      }
    }
    else
    {
      if (huart->Init.Parity == UART_PARITY_NONE)
 8007168:	687b      	ldr	r3, [r7, #4]
 800716a:	691b      	ldr	r3, [r3, #16]
 800716c:	2b00      	cmp	r3, #0
 800716e:	d10a      	bne.n	8007186 <UART_Receive_IT+0x84>
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8007170:	687b      	ldr	r3, [r7, #4]
 8007172:	681b      	ldr	r3, [r3, #0]
 8007174:	6858      	ldr	r0, [r3, #4]
 8007176:	687b      	ldr	r3, [r7, #4]
 8007178:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800717a:	1c59      	adds	r1, r3, #1
 800717c:	687a      	ldr	r2, [r7, #4]
 800717e:	6291      	str	r1, [r2, #40]	; 0x28
 8007180:	b2c2      	uxtb	r2, r0
 8007182:	701a      	strb	r2, [r3, #0]
 8007184:	e00c      	b.n	80071a0 <UART_Receive_IT+0x9e>
      }
      else
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8007186:	687b      	ldr	r3, [r7, #4]
 8007188:	681b      	ldr	r3, [r3, #0]
 800718a:	685b      	ldr	r3, [r3, #4]
 800718c:	b2da      	uxtb	r2, r3
 800718e:	687b      	ldr	r3, [r7, #4]
 8007190:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007192:	1c58      	adds	r0, r3, #1
 8007194:	6879      	ldr	r1, [r7, #4]
 8007196:	6288      	str	r0, [r1, #40]	; 0x28
 8007198:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800719c:	b2d2      	uxtb	r2, r2
 800719e:	701a      	strb	r2, [r3, #0]
      }
    }

    if (--huart->RxXferCount == 0U)
 80071a0:	687b      	ldr	r3, [r7, #4]
 80071a2:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 80071a4:	b29b      	uxth	r3, r3
 80071a6:	3b01      	subs	r3, #1
 80071a8:	b29b      	uxth	r3, r3
 80071aa:	687a      	ldr	r2, [r7, #4]
 80071ac:	4619      	mov	r1, r3
 80071ae:	85d1      	strh	r1, [r2, #46]	; 0x2e
 80071b0:	2b00      	cmp	r3, #0
 80071b2:	d120      	bne.n	80071f6 <UART_Receive_IT+0xf4>
    {
      /* Disable the UART Data Register not empty Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 80071b4:	687b      	ldr	r3, [r7, #4]
 80071b6:	681b      	ldr	r3, [r3, #0]
 80071b8:	68da      	ldr	r2, [r3, #12]
 80071ba:	687b      	ldr	r3, [r7, #4]
 80071bc:	681b      	ldr	r3, [r3, #0]
 80071be:	f022 0220 	bic.w	r2, r2, #32
 80071c2:	60da      	str	r2, [r3, #12]

      /* Disable the UART Parity Error Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 80071c4:	687b      	ldr	r3, [r7, #4]
 80071c6:	681b      	ldr	r3, [r3, #0]
 80071c8:	68da      	ldr	r2, [r3, #12]
 80071ca:	687b      	ldr	r3, [r7, #4]
 80071cc:	681b      	ldr	r3, [r3, #0]
 80071ce:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80071d2:	60da      	str	r2, [r3, #12]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 80071d4:	687b      	ldr	r3, [r7, #4]
 80071d6:	681b      	ldr	r3, [r3, #0]
 80071d8:	695a      	ldr	r2, [r3, #20]
 80071da:	687b      	ldr	r3, [r7, #4]
 80071dc:	681b      	ldr	r3, [r3, #0]
 80071de:	f022 0201 	bic.w	r2, r2, #1
 80071e2:	615a      	str	r2, [r3, #20]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 80071e4:	687b      	ldr	r3, [r7, #4]
 80071e6:	2220      	movs	r2, #32
 80071e8:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
      /*Call registered Rx complete callback*/
      huart->RxCpltCallback(huart);
#else
      /*Call legacy weak Rx complete callback*/
      HAL_UART_RxCpltCallback(huart);
 80071ec:	6878      	ldr	r0, [r7, #4]
 80071ee:	f7fa fe45 	bl	8001e7c <HAL_UART_RxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

      return HAL_OK;
 80071f2:	2300      	movs	r3, #0
 80071f4:	e002      	b.n	80071fc <UART_Receive_IT+0xfa>
    }
    return HAL_OK;
 80071f6:	2300      	movs	r3, #0
 80071f8:	e000      	b.n	80071fc <UART_Receive_IT+0xfa>
  }
  else
  {
    return HAL_BUSY;
 80071fa:	2302      	movs	r3, #2
  }
}
 80071fc:	4618      	mov	r0, r3
 80071fe:	3710      	adds	r7, #16
 8007200:	46bd      	mov	sp, r7
 8007202:	bd80      	pop	{r7, pc}

08007204 <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8007204:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007208:	b085      	sub	sp, #20
 800720a:	af00      	add	r7, sp, #0
 800720c:	6078      	str	r0, [r7, #4]
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800720e:	687b      	ldr	r3, [r7, #4]
 8007210:	681b      	ldr	r3, [r3, #0]
 8007212:	691b      	ldr	r3, [r3, #16]
 8007214:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 8007218:	687b      	ldr	r3, [r7, #4]
 800721a:	68da      	ldr	r2, [r3, #12]
 800721c:	687b      	ldr	r3, [r7, #4]
 800721e:	681b      	ldr	r3, [r3, #0]
 8007220:	430a      	orrs	r2, r1
 8007222:	611a      	str	r2, [r3, #16]
     Set the M bits according to huart->Init.WordLength value
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */

  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8007224:	687b      	ldr	r3, [r7, #4]
 8007226:	689a      	ldr	r2, [r3, #8]
 8007228:	687b      	ldr	r3, [r7, #4]
 800722a:	691b      	ldr	r3, [r3, #16]
 800722c:	431a      	orrs	r2, r3
 800722e:	687b      	ldr	r3, [r7, #4]
 8007230:	695b      	ldr	r3, [r3, #20]
 8007232:	431a      	orrs	r2, r3
 8007234:	687b      	ldr	r3, [r7, #4]
 8007236:	69db      	ldr	r3, [r3, #28]
 8007238:	4313      	orrs	r3, r2
 800723a:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(huart->Instance->CR1,
 800723c:	687b      	ldr	r3, [r7, #4]
 800723e:	681b      	ldr	r3, [r3, #0]
 8007240:	68db      	ldr	r3, [r3, #12]
 8007242:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
 8007246:	f023 030c 	bic.w	r3, r3, #12
 800724a:	687a      	ldr	r2, [r7, #4]
 800724c:	6812      	ldr	r2, [r2, #0]
 800724e:	68f9      	ldr	r1, [r7, #12]
 8007250:	430b      	orrs	r3, r1
 8007252:	60d3      	str	r3, [r2, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8007254:	687b      	ldr	r3, [r7, #4]
 8007256:	681b      	ldr	r3, [r3, #0]
 8007258:	695b      	ldr	r3, [r3, #20]
 800725a:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 800725e:	687b      	ldr	r3, [r7, #4]
 8007260:	699a      	ldr	r2, [r3, #24]
 8007262:	687b      	ldr	r3, [r7, #4]
 8007264:	681b      	ldr	r3, [r3, #0]
 8007266:	430a      	orrs	r2, r1
 8007268:	615a      	str	r2, [r3, #20]

  /* Check the Over Sampling */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800726a:	687b      	ldr	r3, [r7, #4]
 800726c:	69db      	ldr	r3, [r3, #28]
 800726e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8007272:	f040 818b 	bne.w	800758c <UART_SetConfig+0x388>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
    }
#elif defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 8007276:	687b      	ldr	r3, [r7, #4]
 8007278:	681b      	ldr	r3, [r3, #0]
 800727a:	4ac1      	ldr	r2, [pc, #772]	; (8007580 <UART_SetConfig+0x37c>)
 800727c:	4293      	cmp	r3, r2
 800727e:	d005      	beq.n	800728c <UART_SetConfig+0x88>
 8007280:	687b      	ldr	r3, [r7, #4]
 8007282:	681b      	ldr	r3, [r3, #0]
 8007284:	4abf      	ldr	r2, [pc, #764]	; (8007584 <UART_SetConfig+0x380>)
 8007286:	4293      	cmp	r3, r2
 8007288:	f040 80bd 	bne.w	8007406 <UART_SetConfig+0x202>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
 800728c:	f7fe fa66 	bl	800575c <HAL_RCC_GetPCLK2Freq>
 8007290:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 8007292:	68bb      	ldr	r3, [r7, #8]
 8007294:	461d      	mov	r5, r3
 8007296:	f04f 0600 	mov.w	r6, #0
 800729a:	46a8      	mov	r8, r5
 800729c:	46b1      	mov	r9, r6
 800729e:	eb18 0308 	adds.w	r3, r8, r8
 80072a2:	eb49 0409 	adc.w	r4, r9, r9
 80072a6:	4698      	mov	r8, r3
 80072a8:	46a1      	mov	r9, r4
 80072aa:	eb18 0805 	adds.w	r8, r8, r5
 80072ae:	eb49 0906 	adc.w	r9, r9, r6
 80072b2:	f04f 0100 	mov.w	r1, #0
 80072b6:	f04f 0200 	mov.w	r2, #0
 80072ba:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 80072be:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 80072c2:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 80072c6:	4688      	mov	r8, r1
 80072c8:	4691      	mov	r9, r2
 80072ca:	eb18 0005 	adds.w	r0, r8, r5
 80072ce:	eb49 0106 	adc.w	r1, r9, r6
 80072d2:	687b      	ldr	r3, [r7, #4]
 80072d4:	685b      	ldr	r3, [r3, #4]
 80072d6:	461d      	mov	r5, r3
 80072d8:	f04f 0600 	mov.w	r6, #0
 80072dc:	196b      	adds	r3, r5, r5
 80072de:	eb46 0406 	adc.w	r4, r6, r6
 80072e2:	461a      	mov	r2, r3
 80072e4:	4623      	mov	r3, r4
 80072e6:	f7f8 ffd3 	bl	8000290 <__aeabi_uldivmod>
 80072ea:	4603      	mov	r3, r0
 80072ec:	460c      	mov	r4, r1
 80072ee:	461a      	mov	r2, r3
 80072f0:	4ba5      	ldr	r3, [pc, #660]	; (8007588 <UART_SetConfig+0x384>)
 80072f2:	fba3 2302 	umull	r2, r3, r3, r2
 80072f6:	095b      	lsrs	r3, r3, #5
 80072f8:	ea4f 1803 	mov.w	r8, r3, lsl #4
 80072fc:	68bb      	ldr	r3, [r7, #8]
 80072fe:	461d      	mov	r5, r3
 8007300:	f04f 0600 	mov.w	r6, #0
 8007304:	46a9      	mov	r9, r5
 8007306:	46b2      	mov	sl, r6
 8007308:	eb19 0309 	adds.w	r3, r9, r9
 800730c:	eb4a 040a 	adc.w	r4, sl, sl
 8007310:	4699      	mov	r9, r3
 8007312:	46a2      	mov	sl, r4
 8007314:	eb19 0905 	adds.w	r9, r9, r5
 8007318:	eb4a 0a06 	adc.w	sl, sl, r6
 800731c:	f04f 0100 	mov.w	r1, #0
 8007320:	f04f 0200 	mov.w	r2, #0
 8007324:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 8007328:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 800732c:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 8007330:	4689      	mov	r9, r1
 8007332:	4692      	mov	sl, r2
 8007334:	eb19 0005 	adds.w	r0, r9, r5
 8007338:	eb4a 0106 	adc.w	r1, sl, r6
 800733c:	687b      	ldr	r3, [r7, #4]
 800733e:	685b      	ldr	r3, [r3, #4]
 8007340:	461d      	mov	r5, r3
 8007342:	f04f 0600 	mov.w	r6, #0
 8007346:	196b      	adds	r3, r5, r5
 8007348:	eb46 0406 	adc.w	r4, r6, r6
 800734c:	461a      	mov	r2, r3
 800734e:	4623      	mov	r3, r4
 8007350:	f7f8 ff9e 	bl	8000290 <__aeabi_uldivmod>
 8007354:	4603      	mov	r3, r0
 8007356:	460c      	mov	r4, r1
 8007358:	461a      	mov	r2, r3
 800735a:	4b8b      	ldr	r3, [pc, #556]	; (8007588 <UART_SetConfig+0x384>)
 800735c:	fba3 1302 	umull	r1, r3, r3, r2
 8007360:	095b      	lsrs	r3, r3, #5
 8007362:	2164      	movs	r1, #100	; 0x64
 8007364:	fb01 f303 	mul.w	r3, r1, r3
 8007368:	1ad3      	subs	r3, r2, r3
 800736a:	00db      	lsls	r3, r3, #3
 800736c:	3332      	adds	r3, #50	; 0x32
 800736e:	4a86      	ldr	r2, [pc, #536]	; (8007588 <UART_SetConfig+0x384>)
 8007370:	fba2 2303 	umull	r2, r3, r2, r3
 8007374:	095b      	lsrs	r3, r3, #5
 8007376:	005b      	lsls	r3, r3, #1
 8007378:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 800737c:	4498      	add	r8, r3
 800737e:	68bb      	ldr	r3, [r7, #8]
 8007380:	461d      	mov	r5, r3
 8007382:	f04f 0600 	mov.w	r6, #0
 8007386:	46a9      	mov	r9, r5
 8007388:	46b2      	mov	sl, r6
 800738a:	eb19 0309 	adds.w	r3, r9, r9
 800738e:	eb4a 040a 	adc.w	r4, sl, sl
 8007392:	4699      	mov	r9, r3
 8007394:	46a2      	mov	sl, r4
 8007396:	eb19 0905 	adds.w	r9, r9, r5
 800739a:	eb4a 0a06 	adc.w	sl, sl, r6
 800739e:	f04f 0100 	mov.w	r1, #0
 80073a2:	f04f 0200 	mov.w	r2, #0
 80073a6:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 80073aa:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 80073ae:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 80073b2:	4689      	mov	r9, r1
 80073b4:	4692      	mov	sl, r2
 80073b6:	eb19 0005 	adds.w	r0, r9, r5
 80073ba:	eb4a 0106 	adc.w	r1, sl, r6
 80073be:	687b      	ldr	r3, [r7, #4]
 80073c0:	685b      	ldr	r3, [r3, #4]
 80073c2:	461d      	mov	r5, r3
 80073c4:	f04f 0600 	mov.w	r6, #0
 80073c8:	196b      	adds	r3, r5, r5
 80073ca:	eb46 0406 	adc.w	r4, r6, r6
 80073ce:	461a      	mov	r2, r3
 80073d0:	4623      	mov	r3, r4
 80073d2:	f7f8 ff5d 	bl	8000290 <__aeabi_uldivmod>
 80073d6:	4603      	mov	r3, r0
 80073d8:	460c      	mov	r4, r1
 80073da:	461a      	mov	r2, r3
 80073dc:	4b6a      	ldr	r3, [pc, #424]	; (8007588 <UART_SetConfig+0x384>)
 80073de:	fba3 1302 	umull	r1, r3, r3, r2
 80073e2:	095b      	lsrs	r3, r3, #5
 80073e4:	2164      	movs	r1, #100	; 0x64
 80073e6:	fb01 f303 	mul.w	r3, r1, r3
 80073ea:	1ad3      	subs	r3, r2, r3
 80073ec:	00db      	lsls	r3, r3, #3
 80073ee:	3332      	adds	r3, #50	; 0x32
 80073f0:	4a65      	ldr	r2, [pc, #404]	; (8007588 <UART_SetConfig+0x384>)
 80073f2:	fba2 2303 	umull	r2, r3, r2, r3
 80073f6:	095b      	lsrs	r3, r3, #5
 80073f8:	f003 0207 	and.w	r2, r3, #7
 80073fc:	687b      	ldr	r3, [r7, #4]
 80073fe:	681b      	ldr	r3, [r3, #0]
 8007400:	4442      	add	r2, r8
 8007402:	609a      	str	r2, [r3, #8]
 8007404:	e26f      	b.n	80078e6 <UART_SetConfig+0x6e2>
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
    }
#endif /* USART6 */
    else
    {
      pclk = HAL_RCC_GetPCLK1Freq();
 8007406:	f7fe f995 	bl	8005734 <HAL_RCC_GetPCLK1Freq>
 800740a:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 800740c:	68bb      	ldr	r3, [r7, #8]
 800740e:	461d      	mov	r5, r3
 8007410:	f04f 0600 	mov.w	r6, #0
 8007414:	46a8      	mov	r8, r5
 8007416:	46b1      	mov	r9, r6
 8007418:	eb18 0308 	adds.w	r3, r8, r8
 800741c:	eb49 0409 	adc.w	r4, r9, r9
 8007420:	4698      	mov	r8, r3
 8007422:	46a1      	mov	r9, r4
 8007424:	eb18 0805 	adds.w	r8, r8, r5
 8007428:	eb49 0906 	adc.w	r9, r9, r6
 800742c:	f04f 0100 	mov.w	r1, #0
 8007430:	f04f 0200 	mov.w	r2, #0
 8007434:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 8007438:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 800743c:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 8007440:	4688      	mov	r8, r1
 8007442:	4691      	mov	r9, r2
 8007444:	eb18 0005 	adds.w	r0, r8, r5
 8007448:	eb49 0106 	adc.w	r1, r9, r6
 800744c:	687b      	ldr	r3, [r7, #4]
 800744e:	685b      	ldr	r3, [r3, #4]
 8007450:	461d      	mov	r5, r3
 8007452:	f04f 0600 	mov.w	r6, #0
 8007456:	196b      	adds	r3, r5, r5
 8007458:	eb46 0406 	adc.w	r4, r6, r6
 800745c:	461a      	mov	r2, r3
 800745e:	4623      	mov	r3, r4
 8007460:	f7f8 ff16 	bl	8000290 <__aeabi_uldivmod>
 8007464:	4603      	mov	r3, r0
 8007466:	460c      	mov	r4, r1
 8007468:	461a      	mov	r2, r3
 800746a:	4b47      	ldr	r3, [pc, #284]	; (8007588 <UART_SetConfig+0x384>)
 800746c:	fba3 2302 	umull	r2, r3, r3, r2
 8007470:	095b      	lsrs	r3, r3, #5
 8007472:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8007476:	68bb      	ldr	r3, [r7, #8]
 8007478:	461d      	mov	r5, r3
 800747a:	f04f 0600 	mov.w	r6, #0
 800747e:	46a9      	mov	r9, r5
 8007480:	46b2      	mov	sl, r6
 8007482:	eb19 0309 	adds.w	r3, r9, r9
 8007486:	eb4a 040a 	adc.w	r4, sl, sl
 800748a:	4699      	mov	r9, r3
 800748c:	46a2      	mov	sl, r4
 800748e:	eb19 0905 	adds.w	r9, r9, r5
 8007492:	eb4a 0a06 	adc.w	sl, sl, r6
 8007496:	f04f 0100 	mov.w	r1, #0
 800749a:	f04f 0200 	mov.w	r2, #0
 800749e:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 80074a2:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 80074a6:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 80074aa:	4689      	mov	r9, r1
 80074ac:	4692      	mov	sl, r2
 80074ae:	eb19 0005 	adds.w	r0, r9, r5
 80074b2:	eb4a 0106 	adc.w	r1, sl, r6
 80074b6:	687b      	ldr	r3, [r7, #4]
 80074b8:	685b      	ldr	r3, [r3, #4]
 80074ba:	461d      	mov	r5, r3
 80074bc:	f04f 0600 	mov.w	r6, #0
 80074c0:	196b      	adds	r3, r5, r5
 80074c2:	eb46 0406 	adc.w	r4, r6, r6
 80074c6:	461a      	mov	r2, r3
 80074c8:	4623      	mov	r3, r4
 80074ca:	f7f8 fee1 	bl	8000290 <__aeabi_uldivmod>
 80074ce:	4603      	mov	r3, r0
 80074d0:	460c      	mov	r4, r1
 80074d2:	461a      	mov	r2, r3
 80074d4:	4b2c      	ldr	r3, [pc, #176]	; (8007588 <UART_SetConfig+0x384>)
 80074d6:	fba3 1302 	umull	r1, r3, r3, r2
 80074da:	095b      	lsrs	r3, r3, #5
 80074dc:	2164      	movs	r1, #100	; 0x64
 80074de:	fb01 f303 	mul.w	r3, r1, r3
 80074e2:	1ad3      	subs	r3, r2, r3
 80074e4:	00db      	lsls	r3, r3, #3
 80074e6:	3332      	adds	r3, #50	; 0x32
 80074e8:	4a27      	ldr	r2, [pc, #156]	; (8007588 <UART_SetConfig+0x384>)
 80074ea:	fba2 2303 	umull	r2, r3, r2, r3
 80074ee:	095b      	lsrs	r3, r3, #5
 80074f0:	005b      	lsls	r3, r3, #1
 80074f2:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 80074f6:	4498      	add	r8, r3
 80074f8:	68bb      	ldr	r3, [r7, #8]
 80074fa:	461d      	mov	r5, r3
 80074fc:	f04f 0600 	mov.w	r6, #0
 8007500:	46a9      	mov	r9, r5
 8007502:	46b2      	mov	sl, r6
 8007504:	eb19 0309 	adds.w	r3, r9, r9
 8007508:	eb4a 040a 	adc.w	r4, sl, sl
 800750c:	4699      	mov	r9, r3
 800750e:	46a2      	mov	sl, r4
 8007510:	eb19 0905 	adds.w	r9, r9, r5
 8007514:	eb4a 0a06 	adc.w	sl, sl, r6
 8007518:	f04f 0100 	mov.w	r1, #0
 800751c:	f04f 0200 	mov.w	r2, #0
 8007520:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 8007524:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 8007528:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 800752c:	4689      	mov	r9, r1
 800752e:	4692      	mov	sl, r2
 8007530:	eb19 0005 	adds.w	r0, r9, r5
 8007534:	eb4a 0106 	adc.w	r1, sl, r6
 8007538:	687b      	ldr	r3, [r7, #4]
 800753a:	685b      	ldr	r3, [r3, #4]
 800753c:	461d      	mov	r5, r3
 800753e:	f04f 0600 	mov.w	r6, #0
 8007542:	196b      	adds	r3, r5, r5
 8007544:	eb46 0406 	adc.w	r4, r6, r6
 8007548:	461a      	mov	r2, r3
 800754a:	4623      	mov	r3, r4
 800754c:	f7f8 fea0 	bl	8000290 <__aeabi_uldivmod>
 8007550:	4603      	mov	r3, r0
 8007552:	460c      	mov	r4, r1
 8007554:	461a      	mov	r2, r3
 8007556:	4b0c      	ldr	r3, [pc, #48]	; (8007588 <UART_SetConfig+0x384>)
 8007558:	fba3 1302 	umull	r1, r3, r3, r2
 800755c:	095b      	lsrs	r3, r3, #5
 800755e:	2164      	movs	r1, #100	; 0x64
 8007560:	fb01 f303 	mul.w	r3, r1, r3
 8007564:	1ad3      	subs	r3, r2, r3
 8007566:	00db      	lsls	r3, r3, #3
 8007568:	3332      	adds	r3, #50	; 0x32
 800756a:	4a07      	ldr	r2, [pc, #28]	; (8007588 <UART_SetConfig+0x384>)
 800756c:	fba2 2303 	umull	r2, r3, r2, r3
 8007570:	095b      	lsrs	r3, r3, #5
 8007572:	f003 0207 	and.w	r2, r3, #7
 8007576:	687b      	ldr	r3, [r7, #4]
 8007578:	681b      	ldr	r3, [r3, #0]
 800757a:	4442      	add	r2, r8
 800757c:	609a      	str	r2, [r3, #8]
    {
      pclk = HAL_RCC_GetPCLK1Freq();
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
    }
  }
}
 800757e:	e1b2      	b.n	80078e6 <UART_SetConfig+0x6e2>
 8007580:	40011000 	.word	0x40011000
 8007584:	40011400 	.word	0x40011400
 8007588:	51eb851f 	.word	0x51eb851f
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 800758c:	687b      	ldr	r3, [r7, #4]
 800758e:	681b      	ldr	r3, [r3, #0]
 8007590:	4ad7      	ldr	r2, [pc, #860]	; (80078f0 <UART_SetConfig+0x6ec>)
 8007592:	4293      	cmp	r3, r2
 8007594:	d005      	beq.n	80075a2 <UART_SetConfig+0x39e>
 8007596:	687b      	ldr	r3, [r7, #4]
 8007598:	681b      	ldr	r3, [r3, #0]
 800759a:	4ad6      	ldr	r2, [pc, #856]	; (80078f4 <UART_SetConfig+0x6f0>)
 800759c:	4293      	cmp	r3, r2
 800759e:	f040 80d1 	bne.w	8007744 <UART_SetConfig+0x540>
      pclk = HAL_RCC_GetPCLK2Freq();
 80075a2:	f7fe f8db 	bl	800575c <HAL_RCC_GetPCLK2Freq>
 80075a6:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 80075a8:	68bb      	ldr	r3, [r7, #8]
 80075aa:	469a      	mov	sl, r3
 80075ac:	f04f 0b00 	mov.w	fp, #0
 80075b0:	46d0      	mov	r8, sl
 80075b2:	46d9      	mov	r9, fp
 80075b4:	eb18 0308 	adds.w	r3, r8, r8
 80075b8:	eb49 0409 	adc.w	r4, r9, r9
 80075bc:	4698      	mov	r8, r3
 80075be:	46a1      	mov	r9, r4
 80075c0:	eb18 080a 	adds.w	r8, r8, sl
 80075c4:	eb49 090b 	adc.w	r9, r9, fp
 80075c8:	f04f 0100 	mov.w	r1, #0
 80075cc:	f04f 0200 	mov.w	r2, #0
 80075d0:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 80075d4:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 80075d8:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 80075dc:	4688      	mov	r8, r1
 80075de:	4691      	mov	r9, r2
 80075e0:	eb1a 0508 	adds.w	r5, sl, r8
 80075e4:	eb4b 0609 	adc.w	r6, fp, r9
 80075e8:	687b      	ldr	r3, [r7, #4]
 80075ea:	685b      	ldr	r3, [r3, #4]
 80075ec:	4619      	mov	r1, r3
 80075ee:	f04f 0200 	mov.w	r2, #0
 80075f2:	f04f 0300 	mov.w	r3, #0
 80075f6:	f04f 0400 	mov.w	r4, #0
 80075fa:	0094      	lsls	r4, r2, #2
 80075fc:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 8007600:	008b      	lsls	r3, r1, #2
 8007602:	461a      	mov	r2, r3
 8007604:	4623      	mov	r3, r4
 8007606:	4628      	mov	r0, r5
 8007608:	4631      	mov	r1, r6
 800760a:	f7f8 fe41 	bl	8000290 <__aeabi_uldivmod>
 800760e:	4603      	mov	r3, r0
 8007610:	460c      	mov	r4, r1
 8007612:	461a      	mov	r2, r3
 8007614:	4bb8      	ldr	r3, [pc, #736]	; (80078f8 <UART_SetConfig+0x6f4>)
 8007616:	fba3 2302 	umull	r2, r3, r3, r2
 800761a:	095b      	lsrs	r3, r3, #5
 800761c:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8007620:	68bb      	ldr	r3, [r7, #8]
 8007622:	469b      	mov	fp, r3
 8007624:	f04f 0c00 	mov.w	ip, #0
 8007628:	46d9      	mov	r9, fp
 800762a:	46e2      	mov	sl, ip
 800762c:	eb19 0309 	adds.w	r3, r9, r9
 8007630:	eb4a 040a 	adc.w	r4, sl, sl
 8007634:	4699      	mov	r9, r3
 8007636:	46a2      	mov	sl, r4
 8007638:	eb19 090b 	adds.w	r9, r9, fp
 800763c:	eb4a 0a0c 	adc.w	sl, sl, ip
 8007640:	f04f 0100 	mov.w	r1, #0
 8007644:	f04f 0200 	mov.w	r2, #0
 8007648:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 800764c:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 8007650:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 8007654:	4689      	mov	r9, r1
 8007656:	4692      	mov	sl, r2
 8007658:	eb1b 0509 	adds.w	r5, fp, r9
 800765c:	eb4c 060a 	adc.w	r6, ip, sl
 8007660:	687b      	ldr	r3, [r7, #4]
 8007662:	685b      	ldr	r3, [r3, #4]
 8007664:	4619      	mov	r1, r3
 8007666:	f04f 0200 	mov.w	r2, #0
 800766a:	f04f 0300 	mov.w	r3, #0
 800766e:	f04f 0400 	mov.w	r4, #0
 8007672:	0094      	lsls	r4, r2, #2
 8007674:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 8007678:	008b      	lsls	r3, r1, #2
 800767a:	461a      	mov	r2, r3
 800767c:	4623      	mov	r3, r4
 800767e:	4628      	mov	r0, r5
 8007680:	4631      	mov	r1, r6
 8007682:	f7f8 fe05 	bl	8000290 <__aeabi_uldivmod>
 8007686:	4603      	mov	r3, r0
 8007688:	460c      	mov	r4, r1
 800768a:	461a      	mov	r2, r3
 800768c:	4b9a      	ldr	r3, [pc, #616]	; (80078f8 <UART_SetConfig+0x6f4>)
 800768e:	fba3 1302 	umull	r1, r3, r3, r2
 8007692:	095b      	lsrs	r3, r3, #5
 8007694:	2164      	movs	r1, #100	; 0x64
 8007696:	fb01 f303 	mul.w	r3, r1, r3
 800769a:	1ad3      	subs	r3, r2, r3
 800769c:	011b      	lsls	r3, r3, #4
 800769e:	3332      	adds	r3, #50	; 0x32
 80076a0:	4a95      	ldr	r2, [pc, #596]	; (80078f8 <UART_SetConfig+0x6f4>)
 80076a2:	fba2 2303 	umull	r2, r3, r2, r3
 80076a6:	095b      	lsrs	r3, r3, #5
 80076a8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80076ac:	4498      	add	r8, r3
 80076ae:	68bb      	ldr	r3, [r7, #8]
 80076b0:	469b      	mov	fp, r3
 80076b2:	f04f 0c00 	mov.w	ip, #0
 80076b6:	46d9      	mov	r9, fp
 80076b8:	46e2      	mov	sl, ip
 80076ba:	eb19 0309 	adds.w	r3, r9, r9
 80076be:	eb4a 040a 	adc.w	r4, sl, sl
 80076c2:	4699      	mov	r9, r3
 80076c4:	46a2      	mov	sl, r4
 80076c6:	eb19 090b 	adds.w	r9, r9, fp
 80076ca:	eb4a 0a0c 	adc.w	sl, sl, ip
 80076ce:	f04f 0100 	mov.w	r1, #0
 80076d2:	f04f 0200 	mov.w	r2, #0
 80076d6:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 80076da:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 80076de:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 80076e2:	4689      	mov	r9, r1
 80076e4:	4692      	mov	sl, r2
 80076e6:	eb1b 0509 	adds.w	r5, fp, r9
 80076ea:	eb4c 060a 	adc.w	r6, ip, sl
 80076ee:	687b      	ldr	r3, [r7, #4]
 80076f0:	685b      	ldr	r3, [r3, #4]
 80076f2:	4619      	mov	r1, r3
 80076f4:	f04f 0200 	mov.w	r2, #0
 80076f8:	f04f 0300 	mov.w	r3, #0
 80076fc:	f04f 0400 	mov.w	r4, #0
 8007700:	0094      	lsls	r4, r2, #2
 8007702:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 8007706:	008b      	lsls	r3, r1, #2
 8007708:	461a      	mov	r2, r3
 800770a:	4623      	mov	r3, r4
 800770c:	4628      	mov	r0, r5
 800770e:	4631      	mov	r1, r6
 8007710:	f7f8 fdbe 	bl	8000290 <__aeabi_uldivmod>
 8007714:	4603      	mov	r3, r0
 8007716:	460c      	mov	r4, r1
 8007718:	461a      	mov	r2, r3
 800771a:	4b77      	ldr	r3, [pc, #476]	; (80078f8 <UART_SetConfig+0x6f4>)
 800771c:	fba3 1302 	umull	r1, r3, r3, r2
 8007720:	095b      	lsrs	r3, r3, #5
 8007722:	2164      	movs	r1, #100	; 0x64
 8007724:	fb01 f303 	mul.w	r3, r1, r3
 8007728:	1ad3      	subs	r3, r2, r3
 800772a:	011b      	lsls	r3, r3, #4
 800772c:	3332      	adds	r3, #50	; 0x32
 800772e:	4a72      	ldr	r2, [pc, #456]	; (80078f8 <UART_SetConfig+0x6f4>)
 8007730:	fba2 2303 	umull	r2, r3, r2, r3
 8007734:	095b      	lsrs	r3, r3, #5
 8007736:	f003 020f 	and.w	r2, r3, #15
 800773a:	687b      	ldr	r3, [r7, #4]
 800773c:	681b      	ldr	r3, [r3, #0]
 800773e:	4442      	add	r2, r8
 8007740:	609a      	str	r2, [r3, #8]
 8007742:	e0d0      	b.n	80078e6 <UART_SetConfig+0x6e2>
      pclk = HAL_RCC_GetPCLK1Freq();
 8007744:	f7fd fff6 	bl	8005734 <HAL_RCC_GetPCLK1Freq>
 8007748:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 800774a:	68bb      	ldr	r3, [r7, #8]
 800774c:	469a      	mov	sl, r3
 800774e:	f04f 0b00 	mov.w	fp, #0
 8007752:	46d0      	mov	r8, sl
 8007754:	46d9      	mov	r9, fp
 8007756:	eb18 0308 	adds.w	r3, r8, r8
 800775a:	eb49 0409 	adc.w	r4, r9, r9
 800775e:	4698      	mov	r8, r3
 8007760:	46a1      	mov	r9, r4
 8007762:	eb18 080a 	adds.w	r8, r8, sl
 8007766:	eb49 090b 	adc.w	r9, r9, fp
 800776a:	f04f 0100 	mov.w	r1, #0
 800776e:	f04f 0200 	mov.w	r2, #0
 8007772:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 8007776:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 800777a:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 800777e:	4688      	mov	r8, r1
 8007780:	4691      	mov	r9, r2
 8007782:	eb1a 0508 	adds.w	r5, sl, r8
 8007786:	eb4b 0609 	adc.w	r6, fp, r9
 800778a:	687b      	ldr	r3, [r7, #4]
 800778c:	685b      	ldr	r3, [r3, #4]
 800778e:	4619      	mov	r1, r3
 8007790:	f04f 0200 	mov.w	r2, #0
 8007794:	f04f 0300 	mov.w	r3, #0
 8007798:	f04f 0400 	mov.w	r4, #0
 800779c:	0094      	lsls	r4, r2, #2
 800779e:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 80077a2:	008b      	lsls	r3, r1, #2
 80077a4:	461a      	mov	r2, r3
 80077a6:	4623      	mov	r3, r4
 80077a8:	4628      	mov	r0, r5
 80077aa:	4631      	mov	r1, r6
 80077ac:	f7f8 fd70 	bl	8000290 <__aeabi_uldivmod>
 80077b0:	4603      	mov	r3, r0
 80077b2:	460c      	mov	r4, r1
 80077b4:	461a      	mov	r2, r3
 80077b6:	4b50      	ldr	r3, [pc, #320]	; (80078f8 <UART_SetConfig+0x6f4>)
 80077b8:	fba3 2302 	umull	r2, r3, r3, r2
 80077bc:	095b      	lsrs	r3, r3, #5
 80077be:	ea4f 1803 	mov.w	r8, r3, lsl #4
 80077c2:	68bb      	ldr	r3, [r7, #8]
 80077c4:	469b      	mov	fp, r3
 80077c6:	f04f 0c00 	mov.w	ip, #0
 80077ca:	46d9      	mov	r9, fp
 80077cc:	46e2      	mov	sl, ip
 80077ce:	eb19 0309 	adds.w	r3, r9, r9
 80077d2:	eb4a 040a 	adc.w	r4, sl, sl
 80077d6:	4699      	mov	r9, r3
 80077d8:	46a2      	mov	sl, r4
 80077da:	eb19 090b 	adds.w	r9, r9, fp
 80077de:	eb4a 0a0c 	adc.w	sl, sl, ip
 80077e2:	f04f 0100 	mov.w	r1, #0
 80077e6:	f04f 0200 	mov.w	r2, #0
 80077ea:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 80077ee:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 80077f2:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 80077f6:	4689      	mov	r9, r1
 80077f8:	4692      	mov	sl, r2
 80077fa:	eb1b 0509 	adds.w	r5, fp, r9
 80077fe:	eb4c 060a 	adc.w	r6, ip, sl
 8007802:	687b      	ldr	r3, [r7, #4]
 8007804:	685b      	ldr	r3, [r3, #4]
 8007806:	4619      	mov	r1, r3
 8007808:	f04f 0200 	mov.w	r2, #0
 800780c:	f04f 0300 	mov.w	r3, #0
 8007810:	f04f 0400 	mov.w	r4, #0
 8007814:	0094      	lsls	r4, r2, #2
 8007816:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 800781a:	008b      	lsls	r3, r1, #2
 800781c:	461a      	mov	r2, r3
 800781e:	4623      	mov	r3, r4
 8007820:	4628      	mov	r0, r5
 8007822:	4631      	mov	r1, r6
 8007824:	f7f8 fd34 	bl	8000290 <__aeabi_uldivmod>
 8007828:	4603      	mov	r3, r0
 800782a:	460c      	mov	r4, r1
 800782c:	461a      	mov	r2, r3
 800782e:	4b32      	ldr	r3, [pc, #200]	; (80078f8 <UART_SetConfig+0x6f4>)
 8007830:	fba3 1302 	umull	r1, r3, r3, r2
 8007834:	095b      	lsrs	r3, r3, #5
 8007836:	2164      	movs	r1, #100	; 0x64
 8007838:	fb01 f303 	mul.w	r3, r1, r3
 800783c:	1ad3      	subs	r3, r2, r3
 800783e:	011b      	lsls	r3, r3, #4
 8007840:	3332      	adds	r3, #50	; 0x32
 8007842:	4a2d      	ldr	r2, [pc, #180]	; (80078f8 <UART_SetConfig+0x6f4>)
 8007844:	fba2 2303 	umull	r2, r3, r2, r3
 8007848:	095b      	lsrs	r3, r3, #5
 800784a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800784e:	4498      	add	r8, r3
 8007850:	68bb      	ldr	r3, [r7, #8]
 8007852:	469b      	mov	fp, r3
 8007854:	f04f 0c00 	mov.w	ip, #0
 8007858:	46d9      	mov	r9, fp
 800785a:	46e2      	mov	sl, ip
 800785c:	eb19 0309 	adds.w	r3, r9, r9
 8007860:	eb4a 040a 	adc.w	r4, sl, sl
 8007864:	4699      	mov	r9, r3
 8007866:	46a2      	mov	sl, r4
 8007868:	eb19 090b 	adds.w	r9, r9, fp
 800786c:	eb4a 0a0c 	adc.w	sl, sl, ip
 8007870:	f04f 0100 	mov.w	r1, #0
 8007874:	f04f 0200 	mov.w	r2, #0
 8007878:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 800787c:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 8007880:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 8007884:	4689      	mov	r9, r1
 8007886:	4692      	mov	sl, r2
 8007888:	eb1b 0509 	adds.w	r5, fp, r9
 800788c:	eb4c 060a 	adc.w	r6, ip, sl
 8007890:	687b      	ldr	r3, [r7, #4]
 8007892:	685b      	ldr	r3, [r3, #4]
 8007894:	4619      	mov	r1, r3
 8007896:	f04f 0200 	mov.w	r2, #0
 800789a:	f04f 0300 	mov.w	r3, #0
 800789e:	f04f 0400 	mov.w	r4, #0
 80078a2:	0094      	lsls	r4, r2, #2
 80078a4:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 80078a8:	008b      	lsls	r3, r1, #2
 80078aa:	461a      	mov	r2, r3
 80078ac:	4623      	mov	r3, r4
 80078ae:	4628      	mov	r0, r5
 80078b0:	4631      	mov	r1, r6
 80078b2:	f7f8 fced 	bl	8000290 <__aeabi_uldivmod>
 80078b6:	4603      	mov	r3, r0
 80078b8:	460c      	mov	r4, r1
 80078ba:	461a      	mov	r2, r3
 80078bc:	4b0e      	ldr	r3, [pc, #56]	; (80078f8 <UART_SetConfig+0x6f4>)
 80078be:	fba3 1302 	umull	r1, r3, r3, r2
 80078c2:	095b      	lsrs	r3, r3, #5
 80078c4:	2164      	movs	r1, #100	; 0x64
 80078c6:	fb01 f303 	mul.w	r3, r1, r3
 80078ca:	1ad3      	subs	r3, r2, r3
 80078cc:	011b      	lsls	r3, r3, #4
 80078ce:	3332      	adds	r3, #50	; 0x32
 80078d0:	4a09      	ldr	r2, [pc, #36]	; (80078f8 <UART_SetConfig+0x6f4>)
 80078d2:	fba2 2303 	umull	r2, r3, r2, r3
 80078d6:	095b      	lsrs	r3, r3, #5
 80078d8:	f003 020f 	and.w	r2, r3, #15
 80078dc:	687b      	ldr	r3, [r7, #4]
 80078de:	681b      	ldr	r3, [r3, #0]
 80078e0:	4442      	add	r2, r8
 80078e2:	609a      	str	r2, [r3, #8]
}
 80078e4:	e7ff      	b.n	80078e6 <UART_SetConfig+0x6e2>
 80078e6:	bf00      	nop
 80078e8:	3714      	adds	r7, #20
 80078ea:	46bd      	mov	sp, r7
 80078ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80078f0:	40011000 	.word	0x40011000
 80078f4:	40011400 	.word	0x40011400
 80078f8:	51eb851f 	.word	0x51eb851f

080078fc <SVC_Setup>:
#endif /* SysTick */

/*
  Setup SVC to reset value.
*/
__STATIC_INLINE void SVC_Setup (void) {
 80078fc:	b480      	push	{r7}
 80078fe:	af00      	add	r7, sp, #0
  * The issue was logged under:https://github.com/ARM-software/CMSIS-FreeRTOS/issues/35
  * until it is correctly fixed, the code below is commented
  */
/*    NVIC_SetPriority (SVCall_IRQn, 0U); */
#endif
}
 8007900:	bf00      	nop
 8007902:	46bd      	mov	sp, r7
 8007904:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007908:	4770      	bx	lr
	...

0800790c <osKernelInitialize>:

/*---------------------------------------------------------------------------*/

osStatus_t osKernelInitialize (void) {
 800790c:	b480      	push	{r7}
 800790e:	b085      	sub	sp, #20
 8007910:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8007912:	f3ef 8305 	mrs	r3, IPSR
 8007916:	60bb      	str	r3, [r7, #8]
  return(result);
 8007918:	68bb      	ldr	r3, [r7, #8]
  osStatus_t stat;

  if (IS_IRQ()) {
 800791a:	2b00      	cmp	r3, #0
 800791c:	d10f      	bne.n	800793e <osKernelInitialize+0x32>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800791e:	f3ef 8310 	mrs	r3, PRIMASK
 8007922:	607b      	str	r3, [r7, #4]
  return(result);
 8007924:	687b      	ldr	r3, [r7, #4]
 8007926:	2b00      	cmp	r3, #0
 8007928:	d105      	bne.n	8007936 <osKernelInitialize+0x2a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800792a:	f3ef 8311 	mrs	r3, BASEPRI
 800792e:	603b      	str	r3, [r7, #0]
  return(result);
 8007930:	683b      	ldr	r3, [r7, #0]
 8007932:	2b00      	cmp	r3, #0
 8007934:	d007      	beq.n	8007946 <osKernelInitialize+0x3a>
 8007936:	4b0e      	ldr	r3, [pc, #56]	; (8007970 <osKernelInitialize+0x64>)
 8007938:	681b      	ldr	r3, [r3, #0]
 800793a:	2b02      	cmp	r3, #2
 800793c:	d103      	bne.n	8007946 <osKernelInitialize+0x3a>
    stat = osErrorISR;
 800793e:	f06f 0305 	mvn.w	r3, #5
 8007942:	60fb      	str	r3, [r7, #12]
 8007944:	e00c      	b.n	8007960 <osKernelInitialize+0x54>
  }
  else {
    if (KernelState == osKernelInactive) {
 8007946:	4b0a      	ldr	r3, [pc, #40]	; (8007970 <osKernelInitialize+0x64>)
 8007948:	681b      	ldr	r3, [r3, #0]
 800794a:	2b00      	cmp	r3, #0
 800794c:	d105      	bne.n	800795a <osKernelInitialize+0x4e>
      #if defined(USE_FREERTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
        vPortDefineHeapRegions (configHEAP_5_REGIONS);
      #endif
      KernelState = osKernelReady;
 800794e:	4b08      	ldr	r3, [pc, #32]	; (8007970 <osKernelInitialize+0x64>)
 8007950:	2201      	movs	r2, #1
 8007952:	601a      	str	r2, [r3, #0]
      stat = osOK;
 8007954:	2300      	movs	r3, #0
 8007956:	60fb      	str	r3, [r7, #12]
 8007958:	e002      	b.n	8007960 <osKernelInitialize+0x54>
    } else {
      stat = osError;
 800795a:	f04f 33ff 	mov.w	r3, #4294967295
 800795e:	60fb      	str	r3, [r7, #12]
    }
  }

  return (stat);
 8007960:	68fb      	ldr	r3, [r7, #12]
}
 8007962:	4618      	mov	r0, r3
 8007964:	3714      	adds	r7, #20
 8007966:	46bd      	mov	sp, r7
 8007968:	f85d 7b04 	ldr.w	r7, [sp], #4
 800796c:	4770      	bx	lr
 800796e:	bf00      	nop
 8007970:	20000410 	.word	0x20000410

08007974 <osKernelStart>:
  }

  return (state);
}

osStatus_t osKernelStart (void) {
 8007974:	b580      	push	{r7, lr}
 8007976:	b084      	sub	sp, #16
 8007978:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800797a:	f3ef 8305 	mrs	r3, IPSR
 800797e:	60bb      	str	r3, [r7, #8]
  return(result);
 8007980:	68bb      	ldr	r3, [r7, #8]
  osStatus_t stat;

  if (IS_IRQ()) {
 8007982:	2b00      	cmp	r3, #0
 8007984:	d10f      	bne.n	80079a6 <osKernelStart+0x32>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8007986:	f3ef 8310 	mrs	r3, PRIMASK
 800798a:	607b      	str	r3, [r7, #4]
  return(result);
 800798c:	687b      	ldr	r3, [r7, #4]
 800798e:	2b00      	cmp	r3, #0
 8007990:	d105      	bne.n	800799e <osKernelStart+0x2a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8007992:	f3ef 8311 	mrs	r3, BASEPRI
 8007996:	603b      	str	r3, [r7, #0]
  return(result);
 8007998:	683b      	ldr	r3, [r7, #0]
 800799a:	2b00      	cmp	r3, #0
 800799c:	d007      	beq.n	80079ae <osKernelStart+0x3a>
 800799e:	4b0f      	ldr	r3, [pc, #60]	; (80079dc <osKernelStart+0x68>)
 80079a0:	681b      	ldr	r3, [r3, #0]
 80079a2:	2b02      	cmp	r3, #2
 80079a4:	d103      	bne.n	80079ae <osKernelStart+0x3a>
    stat = osErrorISR;
 80079a6:	f06f 0305 	mvn.w	r3, #5
 80079aa:	60fb      	str	r3, [r7, #12]
 80079ac:	e010      	b.n	80079d0 <osKernelStart+0x5c>
  }
  else {
    if (KernelState == osKernelReady) {
 80079ae:	4b0b      	ldr	r3, [pc, #44]	; (80079dc <osKernelStart+0x68>)
 80079b0:	681b      	ldr	r3, [r3, #0]
 80079b2:	2b01      	cmp	r3, #1
 80079b4:	d109      	bne.n	80079ca <osKernelStart+0x56>
      /* Ensure SVC priority is at the reset value */
      SVC_Setup();
 80079b6:	f7ff ffa1 	bl	80078fc <SVC_Setup>
      /* Change state to enable IRQ masking check */
      KernelState = osKernelRunning;
 80079ba:	4b08      	ldr	r3, [pc, #32]	; (80079dc <osKernelStart+0x68>)
 80079bc:	2202      	movs	r2, #2
 80079be:	601a      	str	r2, [r3, #0]
      /* Start the kernel scheduler */
      vTaskStartScheduler();
 80079c0:	f001 faba 	bl	8008f38 <vTaskStartScheduler>
      stat = osOK;
 80079c4:	2300      	movs	r3, #0
 80079c6:	60fb      	str	r3, [r7, #12]
 80079c8:	e002      	b.n	80079d0 <osKernelStart+0x5c>
    } else {
      stat = osError;
 80079ca:	f04f 33ff 	mov.w	r3, #4294967295
 80079ce:	60fb      	str	r3, [r7, #12]
    }
  }

  return (stat);
 80079d0:	68fb      	ldr	r3, [r7, #12]
}
 80079d2:	4618      	mov	r0, r3
 80079d4:	3710      	adds	r7, #16
 80079d6:	46bd      	mov	sp, r7
 80079d8:	bd80      	pop	{r7, pc}
 80079da:	bf00      	nop
 80079dc:	20000410 	.word	0x20000410

080079e0 <osThreadNew>:
  return (configCPU_CLOCK_HZ);
}

/*---------------------------------------------------------------------------*/

osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 80079e0:	b580      	push	{r7, lr}
 80079e2:	b090      	sub	sp, #64	; 0x40
 80079e4:	af04      	add	r7, sp, #16
 80079e6:	60f8      	str	r0, [r7, #12]
 80079e8:	60b9      	str	r1, [r7, #8]
 80079ea:	607a      	str	r2, [r7, #4]
  uint32_t stack;
  TaskHandle_t hTask;
  UBaseType_t prio;
  int32_t mem;

  hTask = NULL;
 80079ec:	2300      	movs	r3, #0
 80079ee:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80079f0:	f3ef 8305 	mrs	r3, IPSR
 80079f4:	61fb      	str	r3, [r7, #28]
  return(result);
 80079f6:	69fb      	ldr	r3, [r7, #28]

  if (!IS_IRQ() && (func != NULL)) {
 80079f8:	2b00      	cmp	r3, #0
 80079fa:	f040 808f 	bne.w	8007b1c <osThreadNew+0x13c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80079fe:	f3ef 8310 	mrs	r3, PRIMASK
 8007a02:	61bb      	str	r3, [r7, #24]
  return(result);
 8007a04:	69bb      	ldr	r3, [r7, #24]
 8007a06:	2b00      	cmp	r3, #0
 8007a08:	d105      	bne.n	8007a16 <osThreadNew+0x36>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8007a0a:	f3ef 8311 	mrs	r3, BASEPRI
 8007a0e:	617b      	str	r3, [r7, #20]
  return(result);
 8007a10:	697b      	ldr	r3, [r7, #20]
 8007a12:	2b00      	cmp	r3, #0
 8007a14:	d003      	beq.n	8007a1e <osThreadNew+0x3e>
 8007a16:	4b44      	ldr	r3, [pc, #272]	; (8007b28 <osThreadNew+0x148>)
 8007a18:	681b      	ldr	r3, [r3, #0]
 8007a1a:	2b02      	cmp	r3, #2
 8007a1c:	d07e      	beq.n	8007b1c <osThreadNew+0x13c>
 8007a1e:	68fb      	ldr	r3, [r7, #12]
 8007a20:	2b00      	cmp	r3, #0
 8007a22:	d07b      	beq.n	8007b1c <osThreadNew+0x13c>
    stack = configMINIMAL_STACK_SIZE;
 8007a24:	2380      	movs	r3, #128	; 0x80
 8007a26:	62bb      	str	r3, [r7, #40]	; 0x28
    prio  = (UBaseType_t)osPriorityNormal;
 8007a28:	2318      	movs	r3, #24
 8007a2a:	627b      	str	r3, [r7, #36]	; 0x24

    name = NULL;
 8007a2c:	2300      	movs	r3, #0
 8007a2e:	62fb      	str	r3, [r7, #44]	; 0x2c
    mem  = -1;
 8007a30:	f04f 33ff 	mov.w	r3, #4294967295
 8007a34:	623b      	str	r3, [r7, #32]

    if (attr != NULL) {
 8007a36:	687b      	ldr	r3, [r7, #4]
 8007a38:	2b00      	cmp	r3, #0
 8007a3a:	d045      	beq.n	8007ac8 <osThreadNew+0xe8>
      if (attr->name != NULL) {
 8007a3c:	687b      	ldr	r3, [r7, #4]
 8007a3e:	681b      	ldr	r3, [r3, #0]
 8007a40:	2b00      	cmp	r3, #0
 8007a42:	d002      	beq.n	8007a4a <osThreadNew+0x6a>
        name = attr->name;
 8007a44:	687b      	ldr	r3, [r7, #4]
 8007a46:	681b      	ldr	r3, [r3, #0]
 8007a48:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
      if (attr->priority != osPriorityNone) {
 8007a4a:	687b      	ldr	r3, [r7, #4]
 8007a4c:	699b      	ldr	r3, [r3, #24]
 8007a4e:	2b00      	cmp	r3, #0
 8007a50:	d002      	beq.n	8007a58 <osThreadNew+0x78>
        prio = (UBaseType_t)attr->priority;
 8007a52:	687b      	ldr	r3, [r7, #4]
 8007a54:	699b      	ldr	r3, [r3, #24]
 8007a56:	627b      	str	r3, [r7, #36]	; 0x24
      }

      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 8007a58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007a5a:	2b00      	cmp	r3, #0
 8007a5c:	d008      	beq.n	8007a70 <osThreadNew+0x90>
 8007a5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007a60:	2b38      	cmp	r3, #56	; 0x38
 8007a62:	d805      	bhi.n	8007a70 <osThreadNew+0x90>
 8007a64:	687b      	ldr	r3, [r7, #4]
 8007a66:	685b      	ldr	r3, [r3, #4]
 8007a68:	f003 0301 	and.w	r3, r3, #1
 8007a6c:	2b00      	cmp	r3, #0
 8007a6e:	d001      	beq.n	8007a74 <osThreadNew+0x94>
        return (NULL);
 8007a70:	2300      	movs	r3, #0
 8007a72:	e054      	b.n	8007b1e <osThreadNew+0x13e>
      }

      if (attr->stack_size > 0U) {
 8007a74:	687b      	ldr	r3, [r7, #4]
 8007a76:	695b      	ldr	r3, [r3, #20]
 8007a78:	2b00      	cmp	r3, #0
 8007a7a:	d003      	beq.n	8007a84 <osThreadNew+0xa4>
        /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
        /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
        stack = attr->stack_size / sizeof(StackType_t);
 8007a7c:	687b      	ldr	r3, [r7, #4]
 8007a7e:	695b      	ldr	r3, [r3, #20]
 8007a80:	089b      	lsrs	r3, r3, #2
 8007a82:	62bb      	str	r3, [r7, #40]	; 0x28
      }

      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 8007a84:	687b      	ldr	r3, [r7, #4]
 8007a86:	689b      	ldr	r3, [r3, #8]
 8007a88:	2b00      	cmp	r3, #0
 8007a8a:	d00e      	beq.n	8007aaa <osThreadNew+0xca>
 8007a8c:	687b      	ldr	r3, [r7, #4]
 8007a8e:	68db      	ldr	r3, [r3, #12]
 8007a90:	2b5b      	cmp	r3, #91	; 0x5b
 8007a92:	d90a      	bls.n	8007aaa <osThreadNew+0xca>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 8007a94:	687b      	ldr	r3, [r7, #4]
 8007a96:	691b      	ldr	r3, [r3, #16]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 8007a98:	2b00      	cmp	r3, #0
 8007a9a:	d006      	beq.n	8007aaa <osThreadNew+0xca>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 8007a9c:	687b      	ldr	r3, [r7, #4]
 8007a9e:	695b      	ldr	r3, [r3, #20]
 8007aa0:	2b00      	cmp	r3, #0
 8007aa2:	d002      	beq.n	8007aaa <osThreadNew+0xca>
        mem = 1;
 8007aa4:	2301      	movs	r3, #1
 8007aa6:	623b      	str	r3, [r7, #32]
 8007aa8:	e010      	b.n	8007acc <osThreadNew+0xec>
      }
      else {
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 8007aaa:	687b      	ldr	r3, [r7, #4]
 8007aac:	689b      	ldr	r3, [r3, #8]
 8007aae:	2b00      	cmp	r3, #0
 8007ab0:	d10c      	bne.n	8007acc <osThreadNew+0xec>
 8007ab2:	687b      	ldr	r3, [r7, #4]
 8007ab4:	68db      	ldr	r3, [r3, #12]
 8007ab6:	2b00      	cmp	r3, #0
 8007ab8:	d108      	bne.n	8007acc <osThreadNew+0xec>
 8007aba:	687b      	ldr	r3, [r7, #4]
 8007abc:	691b      	ldr	r3, [r3, #16]
 8007abe:	2b00      	cmp	r3, #0
 8007ac0:	d104      	bne.n	8007acc <osThreadNew+0xec>
          mem = 0;
 8007ac2:	2300      	movs	r3, #0
 8007ac4:	623b      	str	r3, [r7, #32]
 8007ac6:	e001      	b.n	8007acc <osThreadNew+0xec>
        }
      }
    }
    else {
      mem = 0;
 8007ac8:	2300      	movs	r3, #0
 8007aca:	623b      	str	r3, [r7, #32]
    }

    if (mem == 1) {
 8007acc:	6a3b      	ldr	r3, [r7, #32]
 8007ace:	2b01      	cmp	r3, #1
 8007ad0:	d110      	bne.n	8007af4 <osThreadNew+0x114>
      hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 8007ad2:	687b      	ldr	r3, [r7, #4]
 8007ad4:	691b      	ldr	r3, [r3, #16]
                                                                                    (StaticTask_t *)attr->cb_mem);
 8007ad6:	687a      	ldr	r2, [r7, #4]
 8007ad8:	6892      	ldr	r2, [r2, #8]
      hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 8007ada:	9202      	str	r2, [sp, #8]
 8007adc:	9301      	str	r3, [sp, #4]
 8007ade:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007ae0:	9300      	str	r3, [sp, #0]
 8007ae2:	68bb      	ldr	r3, [r7, #8]
 8007ae4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007ae6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8007ae8:	68f8      	ldr	r0, [r7, #12]
 8007aea:	f000 ff07 	bl	80088fc <xTaskCreateStatic>
 8007aee:	4603      	mov	r3, r0
 8007af0:	613b      	str	r3, [r7, #16]
 8007af2:	e013      	b.n	8007b1c <osThreadNew+0x13c>
    }
    else {
      if (mem == 0) {
 8007af4:	6a3b      	ldr	r3, [r7, #32]
 8007af6:	2b00      	cmp	r3, #0
 8007af8:	d110      	bne.n	8007b1c <osThreadNew+0x13c>
        if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
 8007afa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007afc:	b29a      	uxth	r2, r3
 8007afe:	f107 0310 	add.w	r3, r7, #16
 8007b02:	9301      	str	r3, [sp, #4]
 8007b04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b06:	9300      	str	r3, [sp, #0]
 8007b08:	68bb      	ldr	r3, [r7, #8]
 8007b0a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8007b0c:	68f8      	ldr	r0, [r7, #12]
 8007b0e:	f000 ff4f 	bl	80089b0 <xTaskCreate>
 8007b12:	4603      	mov	r3, r0
 8007b14:	2b01      	cmp	r3, #1
 8007b16:	d001      	beq.n	8007b1c <osThreadNew+0x13c>
          hTask = NULL;
 8007b18:	2300      	movs	r3, #0
 8007b1a:	613b      	str	r3, [r7, #16]
        }
      }
    }
  }

  return ((osThreadId_t)hTask);
 8007b1c:	693b      	ldr	r3, [r7, #16]
}
 8007b1e:	4618      	mov	r0, r3
 8007b20:	3730      	adds	r7, #48	; 0x30
 8007b22:	46bd      	mov	sp, r7
 8007b24:	bd80      	pop	{r7, pc}
 8007b26:	bf00      	nop
 8007b28:	20000410 	.word	0x20000410

08007b2c <osThreadSuspend>:
  }

  return (stat);
}

osStatus_t osThreadSuspend (osThreadId_t thread_id) {
 8007b2c:	b580      	push	{r7, lr}
 8007b2e:	b088      	sub	sp, #32
 8007b30:	af00      	add	r7, sp, #0
 8007b32:	6078      	str	r0, [r7, #4]
  TaskHandle_t hTask = (TaskHandle_t)thread_id;
 8007b34:	687b      	ldr	r3, [r7, #4]
 8007b36:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8007b38:	f3ef 8305 	mrs	r3, IPSR
 8007b3c:	617b      	str	r3, [r7, #20]
  return(result);
 8007b3e:	697b      	ldr	r3, [r7, #20]
  osStatus_t stat;

  if (IS_IRQ()) {
 8007b40:	2b00      	cmp	r3, #0
 8007b42:	d10f      	bne.n	8007b64 <osThreadSuspend+0x38>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8007b44:	f3ef 8310 	mrs	r3, PRIMASK
 8007b48:	613b      	str	r3, [r7, #16]
  return(result);
 8007b4a:	693b      	ldr	r3, [r7, #16]
 8007b4c:	2b00      	cmp	r3, #0
 8007b4e:	d105      	bne.n	8007b5c <osThreadSuspend+0x30>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8007b50:	f3ef 8311 	mrs	r3, BASEPRI
 8007b54:	60fb      	str	r3, [r7, #12]
  return(result);
 8007b56:	68fb      	ldr	r3, [r7, #12]
 8007b58:	2b00      	cmp	r3, #0
 8007b5a:	d007      	beq.n	8007b6c <osThreadSuspend+0x40>
 8007b5c:	4b0c      	ldr	r3, [pc, #48]	; (8007b90 <osThreadSuspend+0x64>)
 8007b5e:	681b      	ldr	r3, [r3, #0]
 8007b60:	2b02      	cmp	r3, #2
 8007b62:	d103      	bne.n	8007b6c <osThreadSuspend+0x40>
    stat = osErrorISR;
 8007b64:	f06f 0305 	mvn.w	r3, #5
 8007b68:	61fb      	str	r3, [r7, #28]
 8007b6a:	e00b      	b.n	8007b84 <osThreadSuspend+0x58>
  }
  else if (hTask == NULL) {
 8007b6c:	69bb      	ldr	r3, [r7, #24]
 8007b6e:	2b00      	cmp	r3, #0
 8007b70:	d103      	bne.n	8007b7a <osThreadSuspend+0x4e>
    stat = osErrorParameter;
 8007b72:	f06f 0303 	mvn.w	r3, #3
 8007b76:	61fb      	str	r3, [r7, #28]
 8007b78:	e004      	b.n	8007b84 <osThreadSuspend+0x58>
  }
  else {
    stat = osOK;
 8007b7a:	2300      	movs	r3, #0
 8007b7c:	61fb      	str	r3, [r7, #28]
    vTaskSuspend (hTask);
 8007b7e:	69b8      	ldr	r0, [r7, #24]
 8007b80:	f001 f966 	bl	8008e50 <vTaskSuspend>
  }

  return (stat);
 8007b84:	69fb      	ldr	r3, [r7, #28]
}
 8007b86:	4618      	mov	r0, r3
 8007b88:	3720      	adds	r7, #32
 8007b8a:	46bd      	mov	sp, r7
 8007b8c:	bd80      	pop	{r7, pc}
 8007b8e:	bf00      	nop
 8007b90:	20000410 	.word	0x20000410

08007b94 <osThreadTerminate>:
  vTaskDelete (NULL);
#endif
  for (;;);
}

osStatus_t osThreadTerminate (osThreadId_t thread_id) {
 8007b94:	b580      	push	{r7, lr}
 8007b96:	b088      	sub	sp, #32
 8007b98:	af00      	add	r7, sp, #0
 8007b9a:	6078      	str	r0, [r7, #4]
  TaskHandle_t hTask = (TaskHandle_t)thread_id;
 8007b9c:	687b      	ldr	r3, [r7, #4]
 8007b9e:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8007ba0:	f3ef 8305 	mrs	r3, IPSR
 8007ba4:	613b      	str	r3, [r7, #16]
  return(result);
 8007ba6:	693b      	ldr	r3, [r7, #16]
  osStatus_t stat;
#ifndef USE_FreeRTOS_HEAP_1
  eTaskState tstate;

  if (IS_IRQ()) {
 8007ba8:	2b00      	cmp	r3, #0
 8007baa:	d10f      	bne.n	8007bcc <osThreadTerminate+0x38>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8007bac:	f3ef 8310 	mrs	r3, PRIMASK
 8007bb0:	60fb      	str	r3, [r7, #12]
  return(result);
 8007bb2:	68fb      	ldr	r3, [r7, #12]
 8007bb4:	2b00      	cmp	r3, #0
 8007bb6:	d105      	bne.n	8007bc4 <osThreadTerminate+0x30>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8007bb8:	f3ef 8311 	mrs	r3, BASEPRI
 8007bbc:	60bb      	str	r3, [r7, #8]
  return(result);
 8007bbe:	68bb      	ldr	r3, [r7, #8]
 8007bc0:	2b00      	cmp	r3, #0
 8007bc2:	d007      	beq.n	8007bd4 <osThreadTerminate+0x40>
 8007bc4:	4b12      	ldr	r3, [pc, #72]	; (8007c10 <osThreadTerminate+0x7c>)
 8007bc6:	681b      	ldr	r3, [r3, #0]
 8007bc8:	2b02      	cmp	r3, #2
 8007bca:	d103      	bne.n	8007bd4 <osThreadTerminate+0x40>
    stat = osErrorISR;
 8007bcc:	f06f 0305 	mvn.w	r3, #5
 8007bd0:	61fb      	str	r3, [r7, #28]
 8007bd2:	e017      	b.n	8007c04 <osThreadTerminate+0x70>
  }
  else if (hTask == NULL) {
 8007bd4:	69bb      	ldr	r3, [r7, #24]
 8007bd6:	2b00      	cmp	r3, #0
 8007bd8:	d103      	bne.n	8007be2 <osThreadTerminate+0x4e>
    stat = osErrorParameter;
 8007bda:	f06f 0303 	mvn.w	r3, #3
 8007bde:	61fb      	str	r3, [r7, #28]
 8007be0:	e010      	b.n	8007c04 <osThreadTerminate+0x70>
  }
  else {
    tstate = eTaskGetState (hTask);
 8007be2:	69b8      	ldr	r0, [r7, #24]
 8007be4:	f001 f8ce 	bl	8008d84 <eTaskGetState>
 8007be8:	4603      	mov	r3, r0
 8007bea:	75fb      	strb	r3, [r7, #23]

    if (tstate != eDeleted) {
 8007bec:	7dfb      	ldrb	r3, [r7, #23]
 8007bee:	2b04      	cmp	r3, #4
 8007bf0:	d005      	beq.n	8007bfe <osThreadTerminate+0x6a>
      stat = osOK;
 8007bf2:	2300      	movs	r3, #0
 8007bf4:	61fb      	str	r3, [r7, #28]
      vTaskDelete (hTask);
 8007bf6:	69b8      	ldr	r0, [r7, #24]
 8007bf8:	f001 f81e 	bl	8008c38 <vTaskDelete>
 8007bfc:	e002      	b.n	8007c04 <osThreadTerminate+0x70>
    } else {
      stat = osErrorResource;
 8007bfe:	f06f 0302 	mvn.w	r3, #2
 8007c02:	61fb      	str	r3, [r7, #28]
  }
#else
  stat = osError;
#endif

  return (stat);
 8007c04:	69fb      	ldr	r3, [r7, #28]
}
 8007c06:	4618      	mov	r0, r3
 8007c08:	3720      	adds	r7, #32
 8007c0a:	46bd      	mov	sp, r7
 8007c0c:	bd80      	pop	{r7, pc}
 8007c0e:	bf00      	nop
 8007c10:	20000410 	.word	0x20000410

08007c14 <osDelay>:

  /* Return flags before clearing */
  return (rflags);
}

osStatus_t osDelay (uint32_t ticks) {
 8007c14:	b580      	push	{r7, lr}
 8007c16:	b086      	sub	sp, #24
 8007c18:	af00      	add	r7, sp, #0
 8007c1a:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8007c1c:	f3ef 8305 	mrs	r3, IPSR
 8007c20:	613b      	str	r3, [r7, #16]
  return(result);
 8007c22:	693b      	ldr	r3, [r7, #16]
  osStatus_t stat;

  if (IS_IRQ()) {
 8007c24:	2b00      	cmp	r3, #0
 8007c26:	d10f      	bne.n	8007c48 <osDelay+0x34>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8007c28:	f3ef 8310 	mrs	r3, PRIMASK
 8007c2c:	60fb      	str	r3, [r7, #12]
  return(result);
 8007c2e:	68fb      	ldr	r3, [r7, #12]
 8007c30:	2b00      	cmp	r3, #0
 8007c32:	d105      	bne.n	8007c40 <osDelay+0x2c>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8007c34:	f3ef 8311 	mrs	r3, BASEPRI
 8007c38:	60bb      	str	r3, [r7, #8]
  return(result);
 8007c3a:	68bb      	ldr	r3, [r7, #8]
 8007c3c:	2b00      	cmp	r3, #0
 8007c3e:	d007      	beq.n	8007c50 <osDelay+0x3c>
 8007c40:	4b0a      	ldr	r3, [pc, #40]	; (8007c6c <osDelay+0x58>)
 8007c42:	681b      	ldr	r3, [r3, #0]
 8007c44:	2b02      	cmp	r3, #2
 8007c46:	d103      	bne.n	8007c50 <osDelay+0x3c>
    stat = osErrorISR;
 8007c48:	f06f 0305 	mvn.w	r3, #5
 8007c4c:	617b      	str	r3, [r7, #20]
 8007c4e:	e007      	b.n	8007c60 <osDelay+0x4c>
  }
  else {
    stat = osOK;
 8007c50:	2300      	movs	r3, #0
 8007c52:	617b      	str	r3, [r7, #20]

    if (ticks != 0U) {
 8007c54:	687b      	ldr	r3, [r7, #4]
 8007c56:	2b00      	cmp	r3, #0
 8007c58:	d002      	beq.n	8007c60 <osDelay+0x4c>
      vTaskDelay(ticks);
 8007c5a:	6878      	ldr	r0, [r7, #4]
 8007c5c:	f001 f85e 	bl	8008d1c <vTaskDelay>
    }
  }

  return (stat);
 8007c60:	697b      	ldr	r3, [r7, #20]
}
 8007c62:	4618      	mov	r0, r3
 8007c64:	3718      	adds	r7, #24
 8007c66:	46bd      	mov	sp, r7
 8007c68:	bd80      	pop	{r7, pc}
 8007c6a:	bf00      	nop
 8007c6c:	20000410 	.word	0x20000410

08007c70 <vApplicationGetIdleTaskMemory>:

/*
  vApplicationGetIdleTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
 8007c70:	b480      	push	{r7}
 8007c72:	b085      	sub	sp, #20
 8007c74:	af00      	add	r7, sp, #0
 8007c76:	60f8      	str	r0, [r7, #12]
 8007c78:	60b9      	str	r1, [r7, #8]
 8007c7a:	607a      	str	r2, [r7, #4]
  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 8007c7c:	68fb      	ldr	r3, [r7, #12]
 8007c7e:	4a07      	ldr	r2, [pc, #28]	; (8007c9c <vApplicationGetIdleTaskMemory+0x2c>)
 8007c80:	601a      	str	r2, [r3, #0]
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
 8007c82:	68bb      	ldr	r3, [r7, #8]
 8007c84:	4a06      	ldr	r2, [pc, #24]	; (8007ca0 <vApplicationGetIdleTaskMemory+0x30>)
 8007c86:	601a      	str	r2, [r3, #0]
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 8007c88:	687b      	ldr	r3, [r7, #4]
 8007c8a:	2280      	movs	r2, #128	; 0x80
 8007c8c:	601a      	str	r2, [r3, #0]
}
 8007c8e:	bf00      	nop
 8007c90:	3714      	adds	r7, #20
 8007c92:	46bd      	mov	sp, r7
 8007c94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c98:	4770      	bx	lr
 8007c9a:	bf00      	nop
 8007c9c:	20000414 	.word	0x20000414
 8007ca0:	20000470 	.word	0x20000470

08007ca4 <vApplicationGetTimerTaskMemory>:

/*
  vApplicationGetTimerTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
 8007ca4:	b480      	push	{r7}
 8007ca6:	b085      	sub	sp, #20
 8007ca8:	af00      	add	r7, sp, #0
 8007caa:	60f8      	str	r0, [r7, #12]
 8007cac:	60b9      	str	r1, [r7, #8]
 8007cae:	607a      	str	r2, [r7, #4]
  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 8007cb0:	68fb      	ldr	r3, [r7, #12]
 8007cb2:	4a07      	ldr	r2, [pc, #28]	; (8007cd0 <vApplicationGetTimerTaskMemory+0x2c>)
 8007cb4:	601a      	str	r2, [r3, #0]
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
 8007cb6:	68bb      	ldr	r3, [r7, #8]
 8007cb8:	4a06      	ldr	r2, [pc, #24]	; (8007cd4 <vApplicationGetTimerTaskMemory+0x30>)
 8007cba:	601a      	str	r2, [r3, #0]
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 8007cbc:	687b      	ldr	r3, [r7, #4]
 8007cbe:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007cc2:	601a      	str	r2, [r3, #0]
}
 8007cc4:	bf00      	nop
 8007cc6:	3714      	adds	r7, #20
 8007cc8:	46bd      	mov	sp, r7
 8007cca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007cce:	4770      	bx	lr
 8007cd0:	20000670 	.word	0x20000670
 8007cd4:	200006cc 	.word	0x200006cc

08007cd8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 8007cd8:	b480      	push	{r7}
 8007cda:	b083      	sub	sp, #12
 8007cdc:	af00      	add	r7, sp, #0
 8007cde:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8007ce0:	687b      	ldr	r3, [r7, #4]
 8007ce2:	f103 0208 	add.w	r2, r3, #8
 8007ce6:	687b      	ldr	r3, [r7, #4]
 8007ce8:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8007cea:	687b      	ldr	r3, [r7, #4]
 8007cec:	f04f 32ff 	mov.w	r2, #4294967295
 8007cf0:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8007cf2:	687b      	ldr	r3, [r7, #4]
 8007cf4:	f103 0208 	add.w	r2, r3, #8
 8007cf8:	687b      	ldr	r3, [r7, #4]
 8007cfa:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8007cfc:	687b      	ldr	r3, [r7, #4]
 8007cfe:	f103 0208 	add.w	r2, r3, #8
 8007d02:	687b      	ldr	r3, [r7, #4]
 8007d04:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8007d06:	687b      	ldr	r3, [r7, #4]
 8007d08:	2200      	movs	r2, #0
 8007d0a:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8007d0c:	bf00      	nop
 8007d0e:	370c      	adds	r7, #12
 8007d10:	46bd      	mov	sp, r7
 8007d12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d16:	4770      	bx	lr

08007d18 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 8007d18:	b480      	push	{r7}
 8007d1a:	b083      	sub	sp, #12
 8007d1c:	af00      	add	r7, sp, #0
 8007d1e:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 8007d20:	687b      	ldr	r3, [r7, #4]
 8007d22:	2200      	movs	r2, #0
 8007d24:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8007d26:	bf00      	nop
 8007d28:	370c      	adds	r7, #12
 8007d2a:	46bd      	mov	sp, r7
 8007d2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d30:	4770      	bx	lr

08007d32 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8007d32:	b480      	push	{r7}
 8007d34:	b085      	sub	sp, #20
 8007d36:	af00      	add	r7, sp, #0
 8007d38:	6078      	str	r0, [r7, #4]
 8007d3a:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 8007d3c:	687b      	ldr	r3, [r7, #4]
 8007d3e:	685b      	ldr	r3, [r3, #4]
 8007d40:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8007d42:	683b      	ldr	r3, [r7, #0]
 8007d44:	68fa      	ldr	r2, [r7, #12]
 8007d46:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8007d48:	68fb      	ldr	r3, [r7, #12]
 8007d4a:	689a      	ldr	r2, [r3, #8]
 8007d4c:	683b      	ldr	r3, [r7, #0]
 8007d4e:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8007d50:	68fb      	ldr	r3, [r7, #12]
 8007d52:	689b      	ldr	r3, [r3, #8]
 8007d54:	683a      	ldr	r2, [r7, #0]
 8007d56:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8007d58:	68fb      	ldr	r3, [r7, #12]
 8007d5a:	683a      	ldr	r2, [r7, #0]
 8007d5c:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 8007d5e:	683b      	ldr	r3, [r7, #0]
 8007d60:	687a      	ldr	r2, [r7, #4]
 8007d62:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8007d64:	687b      	ldr	r3, [r7, #4]
 8007d66:	681b      	ldr	r3, [r3, #0]
 8007d68:	1c5a      	adds	r2, r3, #1
 8007d6a:	687b      	ldr	r3, [r7, #4]
 8007d6c:	601a      	str	r2, [r3, #0]
}
 8007d6e:	bf00      	nop
 8007d70:	3714      	adds	r7, #20
 8007d72:	46bd      	mov	sp, r7
 8007d74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d78:	4770      	bx	lr

08007d7a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8007d7a:	b480      	push	{r7}
 8007d7c:	b085      	sub	sp, #20
 8007d7e:	af00      	add	r7, sp, #0
 8007d80:	6078      	str	r0, [r7, #4]
 8007d82:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8007d84:	683b      	ldr	r3, [r7, #0]
 8007d86:	681b      	ldr	r3, [r3, #0]
 8007d88:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8007d8a:	68bb      	ldr	r3, [r7, #8]
 8007d8c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007d90:	d103      	bne.n	8007d9a <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8007d92:	687b      	ldr	r3, [r7, #4]
 8007d94:	691b      	ldr	r3, [r3, #16]
 8007d96:	60fb      	str	r3, [r7, #12]
 8007d98:	e00c      	b.n	8007db4 <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8007d9a:	687b      	ldr	r3, [r7, #4]
 8007d9c:	3308      	adds	r3, #8
 8007d9e:	60fb      	str	r3, [r7, #12]
 8007da0:	e002      	b.n	8007da8 <vListInsert+0x2e>
 8007da2:	68fb      	ldr	r3, [r7, #12]
 8007da4:	685b      	ldr	r3, [r3, #4]
 8007da6:	60fb      	str	r3, [r7, #12]
 8007da8:	68fb      	ldr	r3, [r7, #12]
 8007daa:	685b      	ldr	r3, [r3, #4]
 8007dac:	681b      	ldr	r3, [r3, #0]
 8007dae:	68ba      	ldr	r2, [r7, #8]
 8007db0:	429a      	cmp	r2, r3
 8007db2:	d2f6      	bcs.n	8007da2 <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8007db4:	68fb      	ldr	r3, [r7, #12]
 8007db6:	685a      	ldr	r2, [r3, #4]
 8007db8:	683b      	ldr	r3, [r7, #0]
 8007dba:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8007dbc:	683b      	ldr	r3, [r7, #0]
 8007dbe:	685b      	ldr	r3, [r3, #4]
 8007dc0:	683a      	ldr	r2, [r7, #0]
 8007dc2:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8007dc4:	683b      	ldr	r3, [r7, #0]
 8007dc6:	68fa      	ldr	r2, [r7, #12]
 8007dc8:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
 8007dca:	68fb      	ldr	r3, [r7, #12]
 8007dcc:	683a      	ldr	r2, [r7, #0]
 8007dce:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 8007dd0:	683b      	ldr	r3, [r7, #0]
 8007dd2:	687a      	ldr	r2, [r7, #4]
 8007dd4:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8007dd6:	687b      	ldr	r3, [r7, #4]
 8007dd8:	681b      	ldr	r3, [r3, #0]
 8007dda:	1c5a      	adds	r2, r3, #1
 8007ddc:	687b      	ldr	r3, [r7, #4]
 8007dde:	601a      	str	r2, [r3, #0]
}
 8007de0:	bf00      	nop
 8007de2:	3714      	adds	r7, #20
 8007de4:	46bd      	mov	sp, r7
 8007de6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007dea:	4770      	bx	lr

08007dec <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 8007dec:	b480      	push	{r7}
 8007dee:	b085      	sub	sp, #20
 8007df0:	af00      	add	r7, sp, #0
 8007df2:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 8007df4:	687b      	ldr	r3, [r7, #4]
 8007df6:	691b      	ldr	r3, [r3, #16]
 8007df8:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8007dfa:	687b      	ldr	r3, [r7, #4]
 8007dfc:	685b      	ldr	r3, [r3, #4]
 8007dfe:	687a      	ldr	r2, [r7, #4]
 8007e00:	6892      	ldr	r2, [r2, #8]
 8007e02:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8007e04:	687b      	ldr	r3, [r7, #4]
 8007e06:	689b      	ldr	r3, [r3, #8]
 8007e08:	687a      	ldr	r2, [r7, #4]
 8007e0a:	6852      	ldr	r2, [r2, #4]
 8007e0c:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8007e0e:	68fb      	ldr	r3, [r7, #12]
 8007e10:	685b      	ldr	r3, [r3, #4]
 8007e12:	687a      	ldr	r2, [r7, #4]
 8007e14:	429a      	cmp	r2, r3
 8007e16:	d103      	bne.n	8007e20 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8007e18:	687b      	ldr	r3, [r7, #4]
 8007e1a:	689a      	ldr	r2, [r3, #8]
 8007e1c:	68fb      	ldr	r3, [r7, #12]
 8007e1e:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 8007e20:	687b      	ldr	r3, [r7, #4]
 8007e22:	2200      	movs	r2, #0
 8007e24:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8007e26:	68fb      	ldr	r3, [r7, #12]
 8007e28:	681b      	ldr	r3, [r3, #0]
 8007e2a:	1e5a      	subs	r2, r3, #1
 8007e2c:	68fb      	ldr	r3, [r7, #12]
 8007e2e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8007e30:	68fb      	ldr	r3, [r7, #12]
 8007e32:	681b      	ldr	r3, [r3, #0]
}
 8007e34:	4618      	mov	r0, r3
 8007e36:	3714      	adds	r7, #20
 8007e38:	46bd      	mov	sp, r7
 8007e3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e3e:	4770      	bx	lr

08007e40 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 8007e40:	b580      	push	{r7, lr}
 8007e42:	b084      	sub	sp, #16
 8007e44:	af00      	add	r7, sp, #0
 8007e46:	6078      	str	r0, [r7, #4]
 8007e48:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = xQueue;
 8007e4a:	687b      	ldr	r3, [r7, #4]
 8007e4c:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
 8007e4e:	68fb      	ldr	r3, [r7, #12]
 8007e50:	2b00      	cmp	r3, #0
 8007e52:	d109      	bne.n	8007e68 <xQueueGenericReset+0x28>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8007e54:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007e58:	f383 8811 	msr	BASEPRI, r3
 8007e5c:	f3bf 8f6f 	isb	sy
 8007e60:	f3bf 8f4f 	dsb	sy
 8007e64:	60bb      	str	r3, [r7, #8]
 8007e66:	e7fe      	b.n	8007e66 <xQueueGenericReset+0x26>

	taskENTER_CRITICAL();
 8007e68:	f002 fa70 	bl	800a34c <vPortEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8007e6c:	68fb      	ldr	r3, [r7, #12]
 8007e6e:	681a      	ldr	r2, [r3, #0]
 8007e70:	68fb      	ldr	r3, [r7, #12]
 8007e72:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007e74:	68f9      	ldr	r1, [r7, #12]
 8007e76:	6c09      	ldr	r1, [r1, #64]	; 0x40
 8007e78:	fb01 f303 	mul.w	r3, r1, r3
 8007e7c:	441a      	add	r2, r3
 8007e7e:	68fb      	ldr	r3, [r7, #12]
 8007e80:	609a      	str	r2, [r3, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8007e82:	68fb      	ldr	r3, [r7, #12]
 8007e84:	2200      	movs	r2, #0
 8007e86:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8007e88:	68fb      	ldr	r3, [r7, #12]
 8007e8a:	681a      	ldr	r2, [r3, #0]
 8007e8c:	68fb      	ldr	r3, [r7, #12]
 8007e8e:	605a      	str	r2, [r3, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8007e90:	68fb      	ldr	r3, [r7, #12]
 8007e92:	681a      	ldr	r2, [r3, #0]
 8007e94:	68fb      	ldr	r3, [r7, #12]
 8007e96:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007e98:	3b01      	subs	r3, #1
 8007e9a:	68f9      	ldr	r1, [r7, #12]
 8007e9c:	6c09      	ldr	r1, [r1, #64]	; 0x40
 8007e9e:	fb01 f303 	mul.w	r3, r1, r3
 8007ea2:	441a      	add	r2, r3
 8007ea4:	68fb      	ldr	r3, [r7, #12]
 8007ea6:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8007ea8:	68fb      	ldr	r3, [r7, #12]
 8007eaa:	22ff      	movs	r2, #255	; 0xff
 8007eac:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8007eb0:	68fb      	ldr	r3, [r7, #12]
 8007eb2:	22ff      	movs	r2, #255	; 0xff
 8007eb4:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
 8007eb8:	683b      	ldr	r3, [r7, #0]
 8007eba:	2b00      	cmp	r3, #0
 8007ebc:	d114      	bne.n	8007ee8 <xQueueGenericReset+0xa8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8007ebe:	68fb      	ldr	r3, [r7, #12]
 8007ec0:	691b      	ldr	r3, [r3, #16]
 8007ec2:	2b00      	cmp	r3, #0
 8007ec4:	d01a      	beq.n	8007efc <xQueueGenericReset+0xbc>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8007ec6:	68fb      	ldr	r3, [r7, #12]
 8007ec8:	3310      	adds	r3, #16
 8007eca:	4618      	mov	r0, r3
 8007ecc:	f001 fb12 	bl	80094f4 <xTaskRemoveFromEventList>
 8007ed0:	4603      	mov	r3, r0
 8007ed2:	2b00      	cmp	r3, #0
 8007ed4:	d012      	beq.n	8007efc <xQueueGenericReset+0xbc>
				{
					queueYIELD_IF_USING_PREEMPTION();
 8007ed6:	4b0d      	ldr	r3, [pc, #52]	; (8007f0c <xQueueGenericReset+0xcc>)
 8007ed8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8007edc:	601a      	str	r2, [r3, #0]
 8007ede:	f3bf 8f4f 	dsb	sy
 8007ee2:	f3bf 8f6f 	isb	sy
 8007ee6:	e009      	b.n	8007efc <xQueueGenericReset+0xbc>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8007ee8:	68fb      	ldr	r3, [r7, #12]
 8007eea:	3310      	adds	r3, #16
 8007eec:	4618      	mov	r0, r3
 8007eee:	f7ff fef3 	bl	8007cd8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8007ef2:	68fb      	ldr	r3, [r7, #12]
 8007ef4:	3324      	adds	r3, #36	; 0x24
 8007ef6:	4618      	mov	r0, r3
 8007ef8:	f7ff feee 	bl	8007cd8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 8007efc:	f002 fa54 	bl	800a3a8 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 8007f00:	2301      	movs	r3, #1
}
 8007f02:	4618      	mov	r0, r3
 8007f04:	3710      	adds	r7, #16
 8007f06:	46bd      	mov	sp, r7
 8007f08:	bd80      	pop	{r7, pc}
 8007f0a:	bf00      	nop
 8007f0c:	e000ed04 	.word	0xe000ed04

08007f10 <xQueueGenericCreateStatic>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_STATIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
	{
 8007f10:	b580      	push	{r7, lr}
 8007f12:	b08e      	sub	sp, #56	; 0x38
 8007f14:	af02      	add	r7, sp, #8
 8007f16:	60f8      	str	r0, [r7, #12]
 8007f18:	60b9      	str	r1, [r7, #8]
 8007f1a:	607a      	str	r2, [r7, #4]
 8007f1c:	603b      	str	r3, [r7, #0]
	Queue_t *pxNewQueue;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8007f1e:	68fb      	ldr	r3, [r7, #12]
 8007f20:	2b00      	cmp	r3, #0
 8007f22:	d109      	bne.n	8007f38 <xQueueGenericCreateStatic+0x28>
 8007f24:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007f28:	f383 8811 	msr	BASEPRI, r3
 8007f2c:	f3bf 8f6f 	isb	sy
 8007f30:	f3bf 8f4f 	dsb	sy
 8007f34:	62bb      	str	r3, [r7, #40]	; 0x28
 8007f36:	e7fe      	b.n	8007f36 <xQueueGenericCreateStatic+0x26>

		/* The StaticQueue_t structure and the queue storage area must be
		supplied. */
		configASSERT( pxStaticQueue != NULL );
 8007f38:	683b      	ldr	r3, [r7, #0]
 8007f3a:	2b00      	cmp	r3, #0
 8007f3c:	d109      	bne.n	8007f52 <xQueueGenericCreateStatic+0x42>
 8007f3e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007f42:	f383 8811 	msr	BASEPRI, r3
 8007f46:	f3bf 8f6f 	isb	sy
 8007f4a:	f3bf 8f4f 	dsb	sy
 8007f4e:	627b      	str	r3, [r7, #36]	; 0x24
 8007f50:	e7fe      	b.n	8007f50 <xQueueGenericCreateStatic+0x40>

		/* A queue storage area should be provided if the item size is not 0, and
		should not be provided if the item size is 0. */
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 8007f52:	687b      	ldr	r3, [r7, #4]
 8007f54:	2b00      	cmp	r3, #0
 8007f56:	d002      	beq.n	8007f5e <xQueueGenericCreateStatic+0x4e>
 8007f58:	68bb      	ldr	r3, [r7, #8]
 8007f5a:	2b00      	cmp	r3, #0
 8007f5c:	d001      	beq.n	8007f62 <xQueueGenericCreateStatic+0x52>
 8007f5e:	2301      	movs	r3, #1
 8007f60:	e000      	b.n	8007f64 <xQueueGenericCreateStatic+0x54>
 8007f62:	2300      	movs	r3, #0
 8007f64:	2b00      	cmp	r3, #0
 8007f66:	d109      	bne.n	8007f7c <xQueueGenericCreateStatic+0x6c>
 8007f68:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007f6c:	f383 8811 	msr	BASEPRI, r3
 8007f70:	f3bf 8f6f 	isb	sy
 8007f74:	f3bf 8f4f 	dsb	sy
 8007f78:	623b      	str	r3, [r7, #32]
 8007f7a:	e7fe      	b.n	8007f7a <xQueueGenericCreateStatic+0x6a>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 8007f7c:	687b      	ldr	r3, [r7, #4]
 8007f7e:	2b00      	cmp	r3, #0
 8007f80:	d102      	bne.n	8007f88 <xQueueGenericCreateStatic+0x78>
 8007f82:	68bb      	ldr	r3, [r7, #8]
 8007f84:	2b00      	cmp	r3, #0
 8007f86:	d101      	bne.n	8007f8c <xQueueGenericCreateStatic+0x7c>
 8007f88:	2301      	movs	r3, #1
 8007f8a:	e000      	b.n	8007f8e <xQueueGenericCreateStatic+0x7e>
 8007f8c:	2300      	movs	r3, #0
 8007f8e:	2b00      	cmp	r3, #0
 8007f90:	d109      	bne.n	8007fa6 <xQueueGenericCreateStatic+0x96>
 8007f92:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007f96:	f383 8811 	msr	BASEPRI, r3
 8007f9a:	f3bf 8f6f 	isb	sy
 8007f9e:	f3bf 8f4f 	dsb	sy
 8007fa2:	61fb      	str	r3, [r7, #28]
 8007fa4:	e7fe      	b.n	8007fa4 <xQueueGenericCreateStatic+0x94>
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
			the real queue and semaphore structures. */
			volatile size_t xSize = sizeof( StaticQueue_t );
 8007fa6:	2350      	movs	r3, #80	; 0x50
 8007fa8:	617b      	str	r3, [r7, #20]
			configASSERT( xSize == sizeof( Queue_t ) );
 8007faa:	697b      	ldr	r3, [r7, #20]
 8007fac:	2b50      	cmp	r3, #80	; 0x50
 8007fae:	d009      	beq.n	8007fc4 <xQueueGenericCreateStatic+0xb4>
 8007fb0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007fb4:	f383 8811 	msr	BASEPRI, r3
 8007fb8:	f3bf 8f6f 	isb	sy
 8007fbc:	f3bf 8f4f 	dsb	sy
 8007fc0:	61bb      	str	r3, [r7, #24]
 8007fc2:	e7fe      	b.n	8007fc2 <xQueueGenericCreateStatic+0xb2>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 8007fc4:	697b      	ldr	r3, [r7, #20]
		#endif /* configASSERT_DEFINED */

		/* The address of a statically allocated queue was passed in, use it.
		The address of a statically allocated storage area was also passed in
		but is already set. */
		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
 8007fc6:	683b      	ldr	r3, [r7, #0]
 8007fc8:	62fb      	str	r3, [r7, #44]	; 0x2c

		if( pxNewQueue != NULL )
 8007fca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007fcc:	2b00      	cmp	r3, #0
 8007fce:	d00d      	beq.n	8007fec <xQueueGenericCreateStatic+0xdc>
			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
			{
				/* Queues can be allocated wither statically or dynamically, so
				note this queue was allocated statically in case the queue is
				later deleted. */
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8007fd0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007fd2:	2201      	movs	r2, #1
 8007fd4:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 8007fd8:	f897 2038 	ldrb.w	r2, [r7, #56]	; 0x38
 8007fdc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007fde:	9300      	str	r3, [sp, #0]
 8007fe0:	4613      	mov	r3, r2
 8007fe2:	687a      	ldr	r2, [r7, #4]
 8007fe4:	68b9      	ldr	r1, [r7, #8]
 8007fe6:	68f8      	ldr	r0, [r7, #12]
 8007fe8:	f000 f805 	bl	8007ff6 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 8007fec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	}
 8007fee:	4618      	mov	r0, r3
 8007ff0:	3730      	adds	r7, #48	; 0x30
 8007ff2:	46bd      	mov	sp, r7
 8007ff4:	bd80      	pop	{r7, pc}

08007ff6 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 8007ff6:	b580      	push	{r7, lr}
 8007ff8:	b084      	sub	sp, #16
 8007ffa:	af00      	add	r7, sp, #0
 8007ffc:	60f8      	str	r0, [r7, #12]
 8007ffe:	60b9      	str	r1, [r7, #8]
 8008000:	607a      	str	r2, [r7, #4]
 8008002:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 8008004:	68bb      	ldr	r3, [r7, #8]
 8008006:	2b00      	cmp	r3, #0
 8008008:	d103      	bne.n	8008012 <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800800a:	69bb      	ldr	r3, [r7, #24]
 800800c:	69ba      	ldr	r2, [r7, #24]
 800800e:	601a      	str	r2, [r3, #0]
 8008010:	e002      	b.n	8008018 <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8008012:	69bb      	ldr	r3, [r7, #24]
 8008014:	687a      	ldr	r2, [r7, #4]
 8008016:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 8008018:	69bb      	ldr	r3, [r7, #24]
 800801a:	68fa      	ldr	r2, [r7, #12]
 800801c:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 800801e:	69bb      	ldr	r3, [r7, #24]
 8008020:	68ba      	ldr	r2, [r7, #8]
 8008022:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8008024:	2101      	movs	r1, #1
 8008026:	69b8      	ldr	r0, [r7, #24]
 8008028:	f7ff ff0a 	bl	8007e40 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
 800802c:	69bb      	ldr	r3, [r7, #24]
 800802e:	78fa      	ldrb	r2, [r7, #3]
 8008030:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 8008034:	bf00      	nop
 8008036:	3710      	adds	r7, #16
 8008038:	46bd      	mov	sp, r7
 800803a:	bd80      	pop	{r7, pc}

0800803c <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 800803c:	b580      	push	{r7, lr}
 800803e:	b08e      	sub	sp, #56	; 0x38
 8008040:	af00      	add	r7, sp, #0
 8008042:	60f8      	str	r0, [r7, #12]
 8008044:	60b9      	str	r1, [r7, #8]
 8008046:	607a      	str	r2, [r7, #4]
 8008048:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 800804a:	2300      	movs	r3, #0
 800804c:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 800804e:	68fb      	ldr	r3, [r7, #12]
 8008050:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
 8008052:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008054:	2b00      	cmp	r3, #0
 8008056:	d109      	bne.n	800806c <xQueueGenericSend+0x30>
 8008058:	f04f 0350 	mov.w	r3, #80	; 0x50
 800805c:	f383 8811 	msr	BASEPRI, r3
 8008060:	f3bf 8f6f 	isb	sy
 8008064:	f3bf 8f4f 	dsb	sy
 8008068:	62bb      	str	r3, [r7, #40]	; 0x28
 800806a:	e7fe      	b.n	800806a <xQueueGenericSend+0x2e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800806c:	68bb      	ldr	r3, [r7, #8]
 800806e:	2b00      	cmp	r3, #0
 8008070:	d103      	bne.n	800807a <xQueueGenericSend+0x3e>
 8008072:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008074:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008076:	2b00      	cmp	r3, #0
 8008078:	d101      	bne.n	800807e <xQueueGenericSend+0x42>
 800807a:	2301      	movs	r3, #1
 800807c:	e000      	b.n	8008080 <xQueueGenericSend+0x44>
 800807e:	2300      	movs	r3, #0
 8008080:	2b00      	cmp	r3, #0
 8008082:	d109      	bne.n	8008098 <xQueueGenericSend+0x5c>
 8008084:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008088:	f383 8811 	msr	BASEPRI, r3
 800808c:	f3bf 8f6f 	isb	sy
 8008090:	f3bf 8f4f 	dsb	sy
 8008094:	627b      	str	r3, [r7, #36]	; 0x24
 8008096:	e7fe      	b.n	8008096 <xQueueGenericSend+0x5a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8008098:	683b      	ldr	r3, [r7, #0]
 800809a:	2b02      	cmp	r3, #2
 800809c:	d103      	bne.n	80080a6 <xQueueGenericSend+0x6a>
 800809e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80080a0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80080a2:	2b01      	cmp	r3, #1
 80080a4:	d101      	bne.n	80080aa <xQueueGenericSend+0x6e>
 80080a6:	2301      	movs	r3, #1
 80080a8:	e000      	b.n	80080ac <xQueueGenericSend+0x70>
 80080aa:	2300      	movs	r3, #0
 80080ac:	2b00      	cmp	r3, #0
 80080ae:	d109      	bne.n	80080c4 <xQueueGenericSend+0x88>
 80080b0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80080b4:	f383 8811 	msr	BASEPRI, r3
 80080b8:	f3bf 8f6f 	isb	sy
 80080bc:	f3bf 8f4f 	dsb	sy
 80080c0:	623b      	str	r3, [r7, #32]
 80080c2:	e7fe      	b.n	80080c2 <xQueueGenericSend+0x86>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80080c4:	f001 fbf6 	bl	80098b4 <xTaskGetSchedulerState>
 80080c8:	4603      	mov	r3, r0
 80080ca:	2b00      	cmp	r3, #0
 80080cc:	d102      	bne.n	80080d4 <xQueueGenericSend+0x98>
 80080ce:	687b      	ldr	r3, [r7, #4]
 80080d0:	2b00      	cmp	r3, #0
 80080d2:	d101      	bne.n	80080d8 <xQueueGenericSend+0x9c>
 80080d4:	2301      	movs	r3, #1
 80080d6:	e000      	b.n	80080da <xQueueGenericSend+0x9e>
 80080d8:	2300      	movs	r3, #0
 80080da:	2b00      	cmp	r3, #0
 80080dc:	d109      	bne.n	80080f2 <xQueueGenericSend+0xb6>
 80080de:	f04f 0350 	mov.w	r3, #80	; 0x50
 80080e2:	f383 8811 	msr	BASEPRI, r3
 80080e6:	f3bf 8f6f 	isb	sy
 80080ea:	f3bf 8f4f 	dsb	sy
 80080ee:	61fb      	str	r3, [r7, #28]
 80080f0:	e7fe      	b.n	80080f0 <xQueueGenericSend+0xb4>
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 80080f2:	f002 f92b 	bl	800a34c <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80080f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80080f8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80080fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80080fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80080fe:	429a      	cmp	r2, r3
 8008100:	d302      	bcc.n	8008108 <xQueueGenericSend+0xcc>
 8008102:	683b      	ldr	r3, [r7, #0]
 8008104:	2b02      	cmp	r3, #2
 8008106:	d129      	bne.n	800815c <xQueueGenericSend+0x120>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8008108:	683a      	ldr	r2, [r7, #0]
 800810a:	68b9      	ldr	r1, [r7, #8]
 800810c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800810e:	f000 fa89 	bl	8008624 <prvCopyDataToQueue>
 8008112:	62f8      	str	r0, [r7, #44]	; 0x2c

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8008114:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008116:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008118:	2b00      	cmp	r3, #0
 800811a:	d010      	beq.n	800813e <xQueueGenericSend+0x102>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800811c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800811e:	3324      	adds	r3, #36	; 0x24
 8008120:	4618      	mov	r0, r3
 8008122:	f001 f9e7 	bl	80094f4 <xTaskRemoveFromEventList>
 8008126:	4603      	mov	r3, r0
 8008128:	2b00      	cmp	r3, #0
 800812a:	d013      	beq.n	8008154 <xQueueGenericSend+0x118>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 800812c:	4b3f      	ldr	r3, [pc, #252]	; (800822c <xQueueGenericSend+0x1f0>)
 800812e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008132:	601a      	str	r2, [r3, #0]
 8008134:	f3bf 8f4f 	dsb	sy
 8008138:	f3bf 8f6f 	isb	sy
 800813c:	e00a      	b.n	8008154 <xQueueGenericSend+0x118>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 800813e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008140:	2b00      	cmp	r3, #0
 8008142:	d007      	beq.n	8008154 <xQueueGenericSend+0x118>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 8008144:	4b39      	ldr	r3, [pc, #228]	; (800822c <xQueueGenericSend+0x1f0>)
 8008146:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800814a:	601a      	str	r2, [r3, #0]
 800814c:	f3bf 8f4f 	dsb	sy
 8008150:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 8008154:	f002 f928 	bl	800a3a8 <vPortExitCritical>
				return pdPASS;
 8008158:	2301      	movs	r3, #1
 800815a:	e063      	b.n	8008224 <xQueueGenericSend+0x1e8>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 800815c:	687b      	ldr	r3, [r7, #4]
 800815e:	2b00      	cmp	r3, #0
 8008160:	d103      	bne.n	800816a <xQueueGenericSend+0x12e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8008162:	f002 f921 	bl	800a3a8 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 8008166:	2300      	movs	r3, #0
 8008168:	e05c      	b.n	8008224 <xQueueGenericSend+0x1e8>
				}
				else if( xEntryTimeSet == pdFALSE )
 800816a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800816c:	2b00      	cmp	r3, #0
 800816e:	d106      	bne.n	800817e <xQueueGenericSend+0x142>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 8008170:	f107 0314 	add.w	r3, r7, #20
 8008174:	4618      	mov	r0, r3
 8008176:	f001 fa21 	bl	80095bc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800817a:	2301      	movs	r3, #1
 800817c:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 800817e:	f002 f913 	bl	800a3a8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8008182:	f000 ff3d 	bl	8009000 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8008186:	f002 f8e1 	bl	800a34c <vPortEnterCritical>
 800818a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800818c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8008190:	b25b      	sxtb	r3, r3
 8008192:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008196:	d103      	bne.n	80081a0 <xQueueGenericSend+0x164>
 8008198:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800819a:	2200      	movs	r2, #0
 800819c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 80081a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081a2:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 80081a6:	b25b      	sxtb	r3, r3
 80081a8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80081ac:	d103      	bne.n	80081b6 <xQueueGenericSend+0x17a>
 80081ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081b0:	2200      	movs	r2, #0
 80081b2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 80081b6:	f002 f8f7 	bl	800a3a8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80081ba:	1d3a      	adds	r2, r7, #4
 80081bc:	f107 0314 	add.w	r3, r7, #20
 80081c0:	4611      	mov	r1, r2
 80081c2:	4618      	mov	r0, r3
 80081c4:	f001 fa10 	bl	80095e8 <xTaskCheckForTimeOut>
 80081c8:	4603      	mov	r3, r0
 80081ca:	2b00      	cmp	r3, #0
 80081cc:	d124      	bne.n	8008218 <xQueueGenericSend+0x1dc>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 80081ce:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80081d0:	f000 fb20 	bl	8008814 <prvIsQueueFull>
 80081d4:	4603      	mov	r3, r0
 80081d6:	2b00      	cmp	r3, #0
 80081d8:	d018      	beq.n	800820c <xQueueGenericSend+0x1d0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80081da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081dc:	3310      	adds	r3, #16
 80081de:	687a      	ldr	r2, [r7, #4]
 80081e0:	4611      	mov	r1, r2
 80081e2:	4618      	mov	r0, r3
 80081e4:	f001 f938 	bl	8009458 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 80081e8:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80081ea:	f000 faab 	bl	8008744 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 80081ee:	f000 ff4d 	bl	800908c <xTaskResumeAll>
 80081f2:	4603      	mov	r3, r0
 80081f4:	2b00      	cmp	r3, #0
 80081f6:	f47f af7c 	bne.w	80080f2 <xQueueGenericSend+0xb6>
				{
					portYIELD_WITHIN_API();
 80081fa:	4b0c      	ldr	r3, [pc, #48]	; (800822c <xQueueGenericSend+0x1f0>)
 80081fc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008200:	601a      	str	r2, [r3, #0]
 8008202:	f3bf 8f4f 	dsb	sy
 8008206:	f3bf 8f6f 	isb	sy
 800820a:	e772      	b.n	80080f2 <xQueueGenericSend+0xb6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 800820c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800820e:	f000 fa99 	bl	8008744 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8008212:	f000 ff3b 	bl	800908c <xTaskResumeAll>
 8008216:	e76c      	b.n	80080f2 <xQueueGenericSend+0xb6>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 8008218:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800821a:	f000 fa93 	bl	8008744 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800821e:	f000 ff35 	bl	800908c <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 8008222:	2300      	movs	r3, #0
		}
	} /*lint -restore */
}
 8008224:	4618      	mov	r0, r3
 8008226:	3738      	adds	r7, #56	; 0x38
 8008228:	46bd      	mov	sp, r7
 800822a:	bd80      	pop	{r7, pc}
 800822c:	e000ed04 	.word	0xe000ed04

08008230 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 8008230:	b580      	push	{r7, lr}
 8008232:	b08e      	sub	sp, #56	; 0x38
 8008234:	af00      	add	r7, sp, #0
 8008236:	60f8      	str	r0, [r7, #12]
 8008238:	60b9      	str	r1, [r7, #8]
 800823a:	607a      	str	r2, [r7, #4]
 800823c:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 800823e:	68fb      	ldr	r3, [r7, #12]
 8008240:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
 8008242:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008244:	2b00      	cmp	r3, #0
 8008246:	d109      	bne.n	800825c <xQueueGenericSendFromISR+0x2c>
 8008248:	f04f 0350 	mov.w	r3, #80	; 0x50
 800824c:	f383 8811 	msr	BASEPRI, r3
 8008250:	f3bf 8f6f 	isb	sy
 8008254:	f3bf 8f4f 	dsb	sy
 8008258:	627b      	str	r3, [r7, #36]	; 0x24
 800825a:	e7fe      	b.n	800825a <xQueueGenericSendFromISR+0x2a>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800825c:	68bb      	ldr	r3, [r7, #8]
 800825e:	2b00      	cmp	r3, #0
 8008260:	d103      	bne.n	800826a <xQueueGenericSendFromISR+0x3a>
 8008262:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008264:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008266:	2b00      	cmp	r3, #0
 8008268:	d101      	bne.n	800826e <xQueueGenericSendFromISR+0x3e>
 800826a:	2301      	movs	r3, #1
 800826c:	e000      	b.n	8008270 <xQueueGenericSendFromISR+0x40>
 800826e:	2300      	movs	r3, #0
 8008270:	2b00      	cmp	r3, #0
 8008272:	d109      	bne.n	8008288 <xQueueGenericSendFromISR+0x58>
 8008274:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008278:	f383 8811 	msr	BASEPRI, r3
 800827c:	f3bf 8f6f 	isb	sy
 8008280:	f3bf 8f4f 	dsb	sy
 8008284:	623b      	str	r3, [r7, #32]
 8008286:	e7fe      	b.n	8008286 <xQueueGenericSendFromISR+0x56>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8008288:	683b      	ldr	r3, [r7, #0]
 800828a:	2b02      	cmp	r3, #2
 800828c:	d103      	bne.n	8008296 <xQueueGenericSendFromISR+0x66>
 800828e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008290:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008292:	2b01      	cmp	r3, #1
 8008294:	d101      	bne.n	800829a <xQueueGenericSendFromISR+0x6a>
 8008296:	2301      	movs	r3, #1
 8008298:	e000      	b.n	800829c <xQueueGenericSendFromISR+0x6c>
 800829a:	2300      	movs	r3, #0
 800829c:	2b00      	cmp	r3, #0
 800829e:	d109      	bne.n	80082b4 <xQueueGenericSendFromISR+0x84>
 80082a0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80082a4:	f383 8811 	msr	BASEPRI, r3
 80082a8:	f3bf 8f6f 	isb	sy
 80082ac:	f3bf 8f4f 	dsb	sy
 80082b0:	61fb      	str	r3, [r7, #28]
 80082b2:	e7fe      	b.n	80082b2 <xQueueGenericSendFromISR+0x82>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80082b4:	f002 f926 	bl	800a504 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 80082b8:	f3ef 8211 	mrs	r2, BASEPRI
 80082bc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80082c0:	f383 8811 	msr	BASEPRI, r3
 80082c4:	f3bf 8f6f 	isb	sy
 80082c8:	f3bf 8f4f 	dsb	sy
 80082cc:	61ba      	str	r2, [r7, #24]
 80082ce:	617b      	str	r3, [r7, #20]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
 80082d0:	69bb      	ldr	r3, [r7, #24]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80082d2:	62fb      	str	r3, [r7, #44]	; 0x2c
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80082d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80082d6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80082d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80082da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80082dc:	429a      	cmp	r2, r3
 80082de:	d302      	bcc.n	80082e6 <xQueueGenericSendFromISR+0xb6>
 80082e0:	683b      	ldr	r3, [r7, #0]
 80082e2:	2b02      	cmp	r3, #2
 80082e4:	d12c      	bne.n	8008340 <xQueueGenericSendFromISR+0x110>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 80082e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80082e8:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 80082ec:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80082f0:	683a      	ldr	r2, [r7, #0]
 80082f2:	68b9      	ldr	r1, [r7, #8]
 80082f4:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80082f6:	f000 f995 	bl	8008624 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 80082fa:	f997 302b 	ldrsb.w	r3, [r7, #43]	; 0x2b
 80082fe:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008302:	d112      	bne.n	800832a <xQueueGenericSendFromISR+0xfa>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8008304:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008306:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008308:	2b00      	cmp	r3, #0
 800830a:	d016      	beq.n	800833a <xQueueGenericSendFromISR+0x10a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800830c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800830e:	3324      	adds	r3, #36	; 0x24
 8008310:	4618      	mov	r0, r3
 8008312:	f001 f8ef 	bl	80094f4 <xTaskRemoveFromEventList>
 8008316:	4603      	mov	r3, r0
 8008318:	2b00      	cmp	r3, #0
 800831a:	d00e      	beq.n	800833a <xQueueGenericSendFromISR+0x10a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 800831c:	687b      	ldr	r3, [r7, #4]
 800831e:	2b00      	cmp	r3, #0
 8008320:	d00b      	beq.n	800833a <xQueueGenericSendFromISR+0x10a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8008322:	687b      	ldr	r3, [r7, #4]
 8008324:	2201      	movs	r2, #1
 8008326:	601a      	str	r2, [r3, #0]
 8008328:	e007      	b.n	800833a <xQueueGenericSendFromISR+0x10a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800832a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800832e:	3301      	adds	r3, #1
 8008330:	b2db      	uxtb	r3, r3
 8008332:	b25a      	sxtb	r2, r3
 8008334:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008336:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
 800833a:	2301      	movs	r3, #1
 800833c:	637b      	str	r3, [r7, #52]	; 0x34
		{
 800833e:	e001      	b.n	8008344 <xQueueGenericSendFromISR+0x114>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 8008340:	2300      	movs	r3, #0
 8008342:	637b      	str	r3, [r7, #52]	; 0x34
 8008344:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008346:	613b      	str	r3, [r7, #16]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8008348:	693b      	ldr	r3, [r7, #16]
 800834a:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 800834e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 8008350:	4618      	mov	r0, r3
 8008352:	3738      	adds	r7, #56	; 0x38
 8008354:	46bd      	mov	sp, r7
 8008356:	bd80      	pop	{r7, pc}

08008358 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
 8008358:	b580      	push	{r7, lr}
 800835a:	b08e      	sub	sp, #56	; 0x38
 800835c:	af00      	add	r7, sp, #0
 800835e:	6078      	str	r0, [r7, #4]
 8008360:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 8008362:	687b      	ldr	r3, [r7, #4]
 8008364:	633b      	str	r3, [r7, #48]	; 0x30
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
 8008366:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008368:	2b00      	cmp	r3, #0
 800836a:	d109      	bne.n	8008380 <xQueueGiveFromISR+0x28>
	__asm volatile
 800836c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008370:	f383 8811 	msr	BASEPRI, r3
 8008374:	f3bf 8f6f 	isb	sy
 8008378:	f3bf 8f4f 	dsb	sy
 800837c:	623b      	str	r3, [r7, #32]
 800837e:	e7fe      	b.n	800837e <xQueueGiveFromISR+0x26>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
 8008380:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008382:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008384:	2b00      	cmp	r3, #0
 8008386:	d009      	beq.n	800839c <xQueueGiveFromISR+0x44>
 8008388:	f04f 0350 	mov.w	r3, #80	; 0x50
 800838c:	f383 8811 	msr	BASEPRI, r3
 8008390:	f3bf 8f6f 	isb	sy
 8008394:	f3bf 8f4f 	dsb	sy
 8008398:	61fb      	str	r3, [r7, #28]
 800839a:	e7fe      	b.n	800839a <xQueueGiveFromISR+0x42>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 800839c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800839e:	681b      	ldr	r3, [r3, #0]
 80083a0:	2b00      	cmp	r3, #0
 80083a2:	d103      	bne.n	80083ac <xQueueGiveFromISR+0x54>
 80083a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80083a6:	689b      	ldr	r3, [r3, #8]
 80083a8:	2b00      	cmp	r3, #0
 80083aa:	d101      	bne.n	80083b0 <xQueueGiveFromISR+0x58>
 80083ac:	2301      	movs	r3, #1
 80083ae:	e000      	b.n	80083b2 <xQueueGiveFromISR+0x5a>
 80083b0:	2300      	movs	r3, #0
 80083b2:	2b00      	cmp	r3, #0
 80083b4:	d109      	bne.n	80083ca <xQueueGiveFromISR+0x72>
 80083b6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80083ba:	f383 8811 	msr	BASEPRI, r3
 80083be:	f3bf 8f6f 	isb	sy
 80083c2:	f3bf 8f4f 	dsb	sy
 80083c6:	61bb      	str	r3, [r7, #24]
 80083c8:	e7fe      	b.n	80083c8 <xQueueGiveFromISR+0x70>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80083ca:	f002 f89b 	bl	800a504 <vPortValidateInterruptPriority>
	__asm volatile
 80083ce:	f3ef 8211 	mrs	r2, BASEPRI
 80083d2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80083d6:	f383 8811 	msr	BASEPRI, r3
 80083da:	f3bf 8f6f 	isb	sy
 80083de:	f3bf 8f4f 	dsb	sy
 80083e2:	617a      	str	r2, [r7, #20]
 80083e4:	613b      	str	r3, [r7, #16]
	return ulOriginalBASEPRI;
 80083e6:	697b      	ldr	r3, [r7, #20]

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80083e8:	62fb      	str	r3, [r7, #44]	; 0x2c
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80083ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80083ec:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80083ee:	62bb      	str	r3, [r7, #40]	; 0x28

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
 80083f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80083f2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80083f4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80083f6:	429a      	cmp	r2, r3
 80083f8:	d22b      	bcs.n	8008452 <xQueueGiveFromISR+0xfa>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 80083fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80083fc:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8008400:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8008404:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008406:	1c5a      	adds	r2, r3, #1
 8008408:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800840a:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 800840c:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
 8008410:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008414:	d112      	bne.n	800843c <xQueueGiveFromISR+0xe4>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8008416:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008418:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800841a:	2b00      	cmp	r3, #0
 800841c:	d016      	beq.n	800844c <xQueueGiveFromISR+0xf4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800841e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008420:	3324      	adds	r3, #36	; 0x24
 8008422:	4618      	mov	r0, r3
 8008424:	f001 f866 	bl	80094f4 <xTaskRemoveFromEventList>
 8008428:	4603      	mov	r3, r0
 800842a:	2b00      	cmp	r3, #0
 800842c:	d00e      	beq.n	800844c <xQueueGiveFromISR+0xf4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 800842e:	683b      	ldr	r3, [r7, #0]
 8008430:	2b00      	cmp	r3, #0
 8008432:	d00b      	beq.n	800844c <xQueueGiveFromISR+0xf4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8008434:	683b      	ldr	r3, [r7, #0]
 8008436:	2201      	movs	r2, #1
 8008438:	601a      	str	r2, [r3, #0]
 800843a:	e007      	b.n	800844c <xQueueGiveFromISR+0xf4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800843c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8008440:	3301      	adds	r3, #1
 8008442:	b2db      	uxtb	r3, r3
 8008444:	b25a      	sxtb	r2, r3
 8008446:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008448:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
 800844c:	2301      	movs	r3, #1
 800844e:	637b      	str	r3, [r7, #52]	; 0x34
 8008450:	e001      	b.n	8008456 <xQueueGiveFromISR+0xfe>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 8008452:	2300      	movs	r3, #0
 8008454:	637b      	str	r3, [r7, #52]	; 0x34
 8008456:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008458:	60fb      	str	r3, [r7, #12]
	__asm volatile
 800845a:	68fb      	ldr	r3, [r7, #12]
 800845c:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 8008460:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 8008462:	4618      	mov	r0, r3
 8008464:	3738      	adds	r7, #56	; 0x38
 8008466:	46bd      	mov	sp, r7
 8008468:	bd80      	pop	{r7, pc}
	...

0800846c <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 800846c:	b580      	push	{r7, lr}
 800846e:	b08c      	sub	sp, #48	; 0x30
 8008470:	af00      	add	r7, sp, #0
 8008472:	60f8      	str	r0, [r7, #12]
 8008474:	60b9      	str	r1, [r7, #8]
 8008476:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
 8008478:	2300      	movs	r3, #0
 800847a:	62fb      	str	r3, [r7, #44]	; 0x2c
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 800847c:	68fb      	ldr	r3, [r7, #12]
 800847e:	62bb      	str	r3, [r7, #40]	; 0x28

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
 8008480:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008482:	2b00      	cmp	r3, #0
 8008484:	d109      	bne.n	800849a <xQueueReceive+0x2e>
	__asm volatile
 8008486:	f04f 0350 	mov.w	r3, #80	; 0x50
 800848a:	f383 8811 	msr	BASEPRI, r3
 800848e:	f3bf 8f6f 	isb	sy
 8008492:	f3bf 8f4f 	dsb	sy
 8008496:	623b      	str	r3, [r7, #32]
 8008498:	e7fe      	b.n	8008498 <xQueueReceive+0x2c>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800849a:	68bb      	ldr	r3, [r7, #8]
 800849c:	2b00      	cmp	r3, #0
 800849e:	d103      	bne.n	80084a8 <xQueueReceive+0x3c>
 80084a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80084a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80084a4:	2b00      	cmp	r3, #0
 80084a6:	d101      	bne.n	80084ac <xQueueReceive+0x40>
 80084a8:	2301      	movs	r3, #1
 80084aa:	e000      	b.n	80084ae <xQueueReceive+0x42>
 80084ac:	2300      	movs	r3, #0
 80084ae:	2b00      	cmp	r3, #0
 80084b0:	d109      	bne.n	80084c6 <xQueueReceive+0x5a>
 80084b2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80084b6:	f383 8811 	msr	BASEPRI, r3
 80084ba:	f3bf 8f6f 	isb	sy
 80084be:	f3bf 8f4f 	dsb	sy
 80084c2:	61fb      	str	r3, [r7, #28]
 80084c4:	e7fe      	b.n	80084c4 <xQueueReceive+0x58>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80084c6:	f001 f9f5 	bl	80098b4 <xTaskGetSchedulerState>
 80084ca:	4603      	mov	r3, r0
 80084cc:	2b00      	cmp	r3, #0
 80084ce:	d102      	bne.n	80084d6 <xQueueReceive+0x6a>
 80084d0:	687b      	ldr	r3, [r7, #4]
 80084d2:	2b00      	cmp	r3, #0
 80084d4:	d101      	bne.n	80084da <xQueueReceive+0x6e>
 80084d6:	2301      	movs	r3, #1
 80084d8:	e000      	b.n	80084dc <xQueueReceive+0x70>
 80084da:	2300      	movs	r3, #0
 80084dc:	2b00      	cmp	r3, #0
 80084de:	d109      	bne.n	80084f4 <xQueueReceive+0x88>
 80084e0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80084e4:	f383 8811 	msr	BASEPRI, r3
 80084e8:	f3bf 8f6f 	isb	sy
 80084ec:	f3bf 8f4f 	dsb	sy
 80084f0:	61bb      	str	r3, [r7, #24]
 80084f2:	e7fe      	b.n	80084f2 <xQueueReceive+0x86>
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 80084f4:	f001 ff2a 	bl	800a34c <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80084f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80084fa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80084fc:	627b      	str	r3, [r7, #36]	; 0x24

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80084fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008500:	2b00      	cmp	r3, #0
 8008502:	d01f      	beq.n	8008544 <xQueueReceive+0xd8>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8008504:	68b9      	ldr	r1, [r7, #8]
 8008506:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8008508:	f000 f8f6 	bl	80086f8 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800850c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800850e:	1e5a      	subs	r2, r3, #1
 8008510:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008512:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8008514:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008516:	691b      	ldr	r3, [r3, #16]
 8008518:	2b00      	cmp	r3, #0
 800851a:	d00f      	beq.n	800853c <xQueueReceive+0xd0>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800851c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800851e:	3310      	adds	r3, #16
 8008520:	4618      	mov	r0, r3
 8008522:	f000 ffe7 	bl	80094f4 <xTaskRemoveFromEventList>
 8008526:	4603      	mov	r3, r0
 8008528:	2b00      	cmp	r3, #0
 800852a:	d007      	beq.n	800853c <xQueueReceive+0xd0>
					{
						queueYIELD_IF_USING_PREEMPTION();
 800852c:	4b3c      	ldr	r3, [pc, #240]	; (8008620 <xQueueReceive+0x1b4>)
 800852e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008532:	601a      	str	r2, [r3, #0]
 8008534:	f3bf 8f4f 	dsb	sy
 8008538:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 800853c:	f001 ff34 	bl	800a3a8 <vPortExitCritical>
				return pdPASS;
 8008540:	2301      	movs	r3, #1
 8008542:	e069      	b.n	8008618 <xQueueReceive+0x1ac>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8008544:	687b      	ldr	r3, [r7, #4]
 8008546:	2b00      	cmp	r3, #0
 8008548:	d103      	bne.n	8008552 <xQueueReceive+0xe6>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800854a:	f001 ff2d 	bl	800a3a8 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 800854e:	2300      	movs	r3, #0
 8008550:	e062      	b.n	8008618 <xQueueReceive+0x1ac>
				}
				else if( xEntryTimeSet == pdFALSE )
 8008552:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008554:	2b00      	cmp	r3, #0
 8008556:	d106      	bne.n	8008566 <xQueueReceive+0xfa>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 8008558:	f107 0310 	add.w	r3, r7, #16
 800855c:	4618      	mov	r0, r3
 800855e:	f001 f82d 	bl	80095bc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8008562:	2301      	movs	r3, #1
 8008564:	62fb      	str	r3, [r7, #44]	; 0x2c
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 8008566:	f001 ff1f 	bl	800a3a8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800856a:	f000 fd49 	bl	8009000 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800856e:	f001 feed 	bl	800a34c <vPortEnterCritical>
 8008572:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008574:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8008578:	b25b      	sxtb	r3, r3
 800857a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800857e:	d103      	bne.n	8008588 <xQueueReceive+0x11c>
 8008580:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008582:	2200      	movs	r2, #0
 8008584:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8008588:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800858a:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800858e:	b25b      	sxtb	r3, r3
 8008590:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008594:	d103      	bne.n	800859e <xQueueReceive+0x132>
 8008596:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008598:	2200      	movs	r2, #0
 800859a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800859e:	f001 ff03 	bl	800a3a8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80085a2:	1d3a      	adds	r2, r7, #4
 80085a4:	f107 0310 	add.w	r3, r7, #16
 80085a8:	4611      	mov	r1, r2
 80085aa:	4618      	mov	r0, r3
 80085ac:	f001 f81c 	bl	80095e8 <xTaskCheckForTimeOut>
 80085b0:	4603      	mov	r3, r0
 80085b2:	2b00      	cmp	r3, #0
 80085b4:	d123      	bne.n	80085fe <xQueueReceive+0x192>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80085b6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80085b8:	f000 f916 	bl	80087e8 <prvIsQueueEmpty>
 80085bc:	4603      	mov	r3, r0
 80085be:	2b00      	cmp	r3, #0
 80085c0:	d017      	beq.n	80085f2 <xQueueReceive+0x186>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80085c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80085c4:	3324      	adds	r3, #36	; 0x24
 80085c6:	687a      	ldr	r2, [r7, #4]
 80085c8:	4611      	mov	r1, r2
 80085ca:	4618      	mov	r0, r3
 80085cc:	f000 ff44 	bl	8009458 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80085d0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80085d2:	f000 f8b7 	bl	8008744 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80085d6:	f000 fd59 	bl	800908c <xTaskResumeAll>
 80085da:	4603      	mov	r3, r0
 80085dc:	2b00      	cmp	r3, #0
 80085de:	d189      	bne.n	80084f4 <xQueueReceive+0x88>
				{
					portYIELD_WITHIN_API();
 80085e0:	4b0f      	ldr	r3, [pc, #60]	; (8008620 <xQueueReceive+0x1b4>)
 80085e2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80085e6:	601a      	str	r2, [r3, #0]
 80085e8:	f3bf 8f4f 	dsb	sy
 80085ec:	f3bf 8f6f 	isb	sy
 80085f0:	e780      	b.n	80084f4 <xQueueReceive+0x88>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
 80085f2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80085f4:	f000 f8a6 	bl	8008744 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80085f8:	f000 fd48 	bl	800908c <xTaskResumeAll>
 80085fc:	e77a      	b.n	80084f4 <xQueueReceive+0x88>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
 80085fe:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8008600:	f000 f8a0 	bl	8008744 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8008604:	f000 fd42 	bl	800908c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8008608:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800860a:	f000 f8ed 	bl	80087e8 <prvIsQueueEmpty>
 800860e:	4603      	mov	r3, r0
 8008610:	2b00      	cmp	r3, #0
 8008612:	f43f af6f 	beq.w	80084f4 <xQueueReceive+0x88>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 8008616:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 8008618:	4618      	mov	r0, r3
 800861a:	3730      	adds	r7, #48	; 0x30
 800861c:	46bd      	mov	sp, r7
 800861e:	bd80      	pop	{r7, pc}
 8008620:	e000ed04 	.word	0xe000ed04

08008624 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8008624:	b580      	push	{r7, lr}
 8008626:	b086      	sub	sp, #24
 8008628:	af00      	add	r7, sp, #0
 800862a:	60f8      	str	r0, [r7, #12]
 800862c:	60b9      	str	r1, [r7, #8]
 800862e:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
 8008630:	2300      	movs	r3, #0
 8008632:	617b      	str	r3, [r7, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8008634:	68fb      	ldr	r3, [r7, #12]
 8008636:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8008638:	613b      	str	r3, [r7, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800863a:	68fb      	ldr	r3, [r7, #12]
 800863c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800863e:	2b00      	cmp	r3, #0
 8008640:	d10d      	bne.n	800865e <prvCopyDataToQueue+0x3a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8008642:	68fb      	ldr	r3, [r7, #12]
 8008644:	681b      	ldr	r3, [r3, #0]
 8008646:	2b00      	cmp	r3, #0
 8008648:	d14d      	bne.n	80086e6 <prvCopyDataToQueue+0xc2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 800864a:	68fb      	ldr	r3, [r7, #12]
 800864c:	689b      	ldr	r3, [r3, #8]
 800864e:	4618      	mov	r0, r3
 8008650:	f001 f94e 	bl	80098f0 <xTaskPriorityDisinherit>
 8008654:	6178      	str	r0, [r7, #20]
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 8008656:	68fb      	ldr	r3, [r7, #12]
 8008658:	2200      	movs	r2, #0
 800865a:	609a      	str	r2, [r3, #8]
 800865c:	e043      	b.n	80086e6 <prvCopyDataToQueue+0xc2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 800865e:	687b      	ldr	r3, [r7, #4]
 8008660:	2b00      	cmp	r3, #0
 8008662:	d119      	bne.n	8008698 <prvCopyDataToQueue+0x74>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8008664:	68fb      	ldr	r3, [r7, #12]
 8008666:	6858      	ldr	r0, [r3, #4]
 8008668:	68fb      	ldr	r3, [r7, #12]
 800866a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800866c:	461a      	mov	r2, r3
 800866e:	68b9      	ldr	r1, [r7, #8]
 8008670:	f01f fa03 	bl	8027a7a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8008674:	68fb      	ldr	r3, [r7, #12]
 8008676:	685a      	ldr	r2, [r3, #4]
 8008678:	68fb      	ldr	r3, [r7, #12]
 800867a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800867c:	441a      	add	r2, r3
 800867e:	68fb      	ldr	r3, [r7, #12]
 8008680:	605a      	str	r2, [r3, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8008682:	68fb      	ldr	r3, [r7, #12]
 8008684:	685a      	ldr	r2, [r3, #4]
 8008686:	68fb      	ldr	r3, [r7, #12]
 8008688:	689b      	ldr	r3, [r3, #8]
 800868a:	429a      	cmp	r2, r3
 800868c:	d32b      	bcc.n	80086e6 <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800868e:	68fb      	ldr	r3, [r7, #12]
 8008690:	681a      	ldr	r2, [r3, #0]
 8008692:	68fb      	ldr	r3, [r7, #12]
 8008694:	605a      	str	r2, [r3, #4]
 8008696:	e026      	b.n	80086e6 <prvCopyDataToQueue+0xc2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 8008698:	68fb      	ldr	r3, [r7, #12]
 800869a:	68d8      	ldr	r0, [r3, #12]
 800869c:	68fb      	ldr	r3, [r7, #12]
 800869e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80086a0:	461a      	mov	r2, r3
 80086a2:	68b9      	ldr	r1, [r7, #8]
 80086a4:	f01f f9e9 	bl	8027a7a <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 80086a8:	68fb      	ldr	r3, [r7, #12]
 80086aa:	68da      	ldr	r2, [r3, #12]
 80086ac:	68fb      	ldr	r3, [r7, #12]
 80086ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80086b0:	425b      	negs	r3, r3
 80086b2:	441a      	add	r2, r3
 80086b4:	68fb      	ldr	r3, [r7, #12]
 80086b6:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80086b8:	68fb      	ldr	r3, [r7, #12]
 80086ba:	68da      	ldr	r2, [r3, #12]
 80086bc:	68fb      	ldr	r3, [r7, #12]
 80086be:	681b      	ldr	r3, [r3, #0]
 80086c0:	429a      	cmp	r2, r3
 80086c2:	d207      	bcs.n	80086d4 <prvCopyDataToQueue+0xb0>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 80086c4:	68fb      	ldr	r3, [r7, #12]
 80086c6:	689a      	ldr	r2, [r3, #8]
 80086c8:	68fb      	ldr	r3, [r7, #12]
 80086ca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80086cc:	425b      	negs	r3, r3
 80086ce:	441a      	add	r2, r3
 80086d0:	68fb      	ldr	r3, [r7, #12]
 80086d2:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 80086d4:	687b      	ldr	r3, [r7, #4]
 80086d6:	2b02      	cmp	r3, #2
 80086d8:	d105      	bne.n	80086e6 <prvCopyDataToQueue+0xc2>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80086da:	693b      	ldr	r3, [r7, #16]
 80086dc:	2b00      	cmp	r3, #0
 80086de:	d002      	beq.n	80086e6 <prvCopyDataToQueue+0xc2>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 80086e0:	693b      	ldr	r3, [r7, #16]
 80086e2:	3b01      	subs	r3, #1
 80086e4:	613b      	str	r3, [r7, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80086e6:	693b      	ldr	r3, [r7, #16]
 80086e8:	1c5a      	adds	r2, r3, #1
 80086ea:	68fb      	ldr	r3, [r7, #12]
 80086ec:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
 80086ee:	697b      	ldr	r3, [r7, #20]
}
 80086f0:	4618      	mov	r0, r3
 80086f2:	3718      	adds	r7, #24
 80086f4:	46bd      	mov	sp, r7
 80086f6:	bd80      	pop	{r7, pc}

080086f8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 80086f8:	b580      	push	{r7, lr}
 80086fa:	b082      	sub	sp, #8
 80086fc:	af00      	add	r7, sp, #0
 80086fe:	6078      	str	r0, [r7, #4]
 8008700:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8008702:	687b      	ldr	r3, [r7, #4]
 8008704:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008706:	2b00      	cmp	r3, #0
 8008708:	d018      	beq.n	800873c <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800870a:	687b      	ldr	r3, [r7, #4]
 800870c:	68da      	ldr	r2, [r3, #12]
 800870e:	687b      	ldr	r3, [r7, #4]
 8008710:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008712:	441a      	add	r2, r3
 8008714:	687b      	ldr	r3, [r7, #4]
 8008716:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8008718:	687b      	ldr	r3, [r7, #4]
 800871a:	68da      	ldr	r2, [r3, #12]
 800871c:	687b      	ldr	r3, [r7, #4]
 800871e:	689b      	ldr	r3, [r3, #8]
 8008720:	429a      	cmp	r2, r3
 8008722:	d303      	bcc.n	800872c <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8008724:	687b      	ldr	r3, [r7, #4]
 8008726:	681a      	ldr	r2, [r3, #0]
 8008728:	687b      	ldr	r3, [r7, #4]
 800872a:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800872c:	687b      	ldr	r3, [r7, #4]
 800872e:	68d9      	ldr	r1, [r3, #12]
 8008730:	687b      	ldr	r3, [r7, #4]
 8008732:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008734:	461a      	mov	r2, r3
 8008736:	6838      	ldr	r0, [r7, #0]
 8008738:	f01f f99f 	bl	8027a7a <memcpy>
	}
}
 800873c:	bf00      	nop
 800873e:	3708      	adds	r7, #8
 8008740:	46bd      	mov	sp, r7
 8008742:	bd80      	pop	{r7, pc}

08008744 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8008744:	b580      	push	{r7, lr}
 8008746:	b084      	sub	sp, #16
 8008748:	af00      	add	r7, sp, #0
 800874a:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 800874c:	f001 fdfe 	bl	800a34c <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8008750:	687b      	ldr	r3, [r7, #4]
 8008752:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8008756:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8008758:	e011      	b.n	800877e <prvUnlockQueue+0x3a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800875a:	687b      	ldr	r3, [r7, #4]
 800875c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800875e:	2b00      	cmp	r3, #0
 8008760:	d012      	beq.n	8008788 <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8008762:	687b      	ldr	r3, [r7, #4]
 8008764:	3324      	adds	r3, #36	; 0x24
 8008766:	4618      	mov	r0, r3
 8008768:	f000 fec4 	bl	80094f4 <xTaskRemoveFromEventList>
 800876c:	4603      	mov	r3, r0
 800876e:	2b00      	cmp	r3, #0
 8008770:	d001      	beq.n	8008776 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 8008772:	f000 ff99 	bl	80096a8 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 8008776:	7bfb      	ldrb	r3, [r7, #15]
 8008778:	3b01      	subs	r3, #1
 800877a:	b2db      	uxtb	r3, r3
 800877c:	73fb      	strb	r3, [r7, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800877e:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8008782:	2b00      	cmp	r3, #0
 8008784:	dce9      	bgt.n	800875a <prvUnlockQueue+0x16>
 8008786:	e000      	b.n	800878a <prvUnlockQueue+0x46>
					break;
 8008788:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
 800878a:	687b      	ldr	r3, [r7, #4]
 800878c:	22ff      	movs	r2, #255	; 0xff
 800878e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 8008792:	f001 fe09 	bl	800a3a8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8008796:	f001 fdd9 	bl	800a34c <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 800879a:	687b      	ldr	r3, [r7, #4]
 800879c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 80087a0:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
 80087a2:	e011      	b.n	80087c8 <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80087a4:	687b      	ldr	r3, [r7, #4]
 80087a6:	691b      	ldr	r3, [r3, #16]
 80087a8:	2b00      	cmp	r3, #0
 80087aa:	d012      	beq.n	80087d2 <prvUnlockQueue+0x8e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80087ac:	687b      	ldr	r3, [r7, #4]
 80087ae:	3310      	adds	r3, #16
 80087b0:	4618      	mov	r0, r3
 80087b2:	f000 fe9f 	bl	80094f4 <xTaskRemoveFromEventList>
 80087b6:	4603      	mov	r3, r0
 80087b8:	2b00      	cmp	r3, #0
 80087ba:	d001      	beq.n	80087c0 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
 80087bc:	f000 ff74 	bl	80096a8 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 80087c0:	7bbb      	ldrb	r3, [r7, #14]
 80087c2:	3b01      	subs	r3, #1
 80087c4:	b2db      	uxtb	r3, r3
 80087c6:	73bb      	strb	r3, [r7, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80087c8:	f997 300e 	ldrsb.w	r3, [r7, #14]
 80087cc:	2b00      	cmp	r3, #0
 80087ce:	dce9      	bgt.n	80087a4 <prvUnlockQueue+0x60>
 80087d0:	e000      	b.n	80087d4 <prvUnlockQueue+0x90>
			}
			else
			{
				break;
 80087d2:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 80087d4:	687b      	ldr	r3, [r7, #4]
 80087d6:	22ff      	movs	r2, #255	; 0xff
 80087d8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 80087dc:	f001 fde4 	bl	800a3a8 <vPortExitCritical>
}
 80087e0:	bf00      	nop
 80087e2:	3710      	adds	r7, #16
 80087e4:	46bd      	mov	sp, r7
 80087e6:	bd80      	pop	{r7, pc}

080087e8 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 80087e8:	b580      	push	{r7, lr}
 80087ea:	b084      	sub	sp, #16
 80087ec:	af00      	add	r7, sp, #0
 80087ee:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80087f0:	f001 fdac 	bl	800a34c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80087f4:	687b      	ldr	r3, [r7, #4]
 80087f6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80087f8:	2b00      	cmp	r3, #0
 80087fa:	d102      	bne.n	8008802 <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
 80087fc:	2301      	movs	r3, #1
 80087fe:	60fb      	str	r3, [r7, #12]
 8008800:	e001      	b.n	8008806 <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
 8008802:	2300      	movs	r3, #0
 8008804:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 8008806:	f001 fdcf 	bl	800a3a8 <vPortExitCritical>

	return xReturn;
 800880a:	68fb      	ldr	r3, [r7, #12]
}
 800880c:	4618      	mov	r0, r3
 800880e:	3710      	adds	r7, #16
 8008810:	46bd      	mov	sp, r7
 8008812:	bd80      	pop	{r7, pc}

08008814 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 8008814:	b580      	push	{r7, lr}
 8008816:	b084      	sub	sp, #16
 8008818:	af00      	add	r7, sp, #0
 800881a:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800881c:	f001 fd96 	bl	800a34c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8008820:	687b      	ldr	r3, [r7, #4]
 8008822:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8008824:	687b      	ldr	r3, [r7, #4]
 8008826:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008828:	429a      	cmp	r2, r3
 800882a:	d102      	bne.n	8008832 <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
 800882c:	2301      	movs	r3, #1
 800882e:	60fb      	str	r3, [r7, #12]
 8008830:	e001      	b.n	8008836 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
 8008832:	2300      	movs	r3, #0
 8008834:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 8008836:	f001 fdb7 	bl	800a3a8 <vPortExitCritical>

	return xReturn;
 800883a:	68fb      	ldr	r3, [r7, #12]
}
 800883c:	4618      	mov	r0, r3
 800883e:	3710      	adds	r7, #16
 8008840:	46bd      	mov	sp, r7
 8008842:	bd80      	pop	{r7, pc}

08008844 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8008844:	b480      	push	{r7}
 8008846:	b085      	sub	sp, #20
 8008848:	af00      	add	r7, sp, #0
 800884a:	6078      	str	r0, [r7, #4]
 800884c:	6039      	str	r1, [r7, #0]
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800884e:	2300      	movs	r3, #0
 8008850:	60fb      	str	r3, [r7, #12]
 8008852:	e014      	b.n	800887e <vQueueAddToRegistry+0x3a>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8008854:	4a0e      	ldr	r2, [pc, #56]	; (8008890 <vQueueAddToRegistry+0x4c>)
 8008856:	68fb      	ldr	r3, [r7, #12]
 8008858:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 800885c:	2b00      	cmp	r3, #0
 800885e:	d10b      	bne.n	8008878 <vQueueAddToRegistry+0x34>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8008860:	490b      	ldr	r1, [pc, #44]	; (8008890 <vQueueAddToRegistry+0x4c>)
 8008862:	68fb      	ldr	r3, [r7, #12]
 8008864:	683a      	ldr	r2, [r7, #0]
 8008866:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 800886a:	4a09      	ldr	r2, [pc, #36]	; (8008890 <vQueueAddToRegistry+0x4c>)
 800886c:	68fb      	ldr	r3, [r7, #12]
 800886e:	00db      	lsls	r3, r3, #3
 8008870:	4413      	add	r3, r2
 8008872:	687a      	ldr	r2, [r7, #4]
 8008874:	605a      	str	r2, [r3, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
 8008876:	e005      	b.n	8008884 <vQueueAddToRegistry+0x40>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8008878:	68fb      	ldr	r3, [r7, #12]
 800887a:	3301      	adds	r3, #1
 800887c:	60fb      	str	r3, [r7, #12]
 800887e:	68fb      	ldr	r3, [r7, #12]
 8008880:	2b07      	cmp	r3, #7
 8008882:	d9e7      	bls.n	8008854 <vQueueAddToRegistry+0x10>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 8008884:	bf00      	nop
 8008886:	3714      	adds	r7, #20
 8008888:	46bd      	mov	sp, r7
 800888a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800888e:	4770      	bx	lr
 8008890:	2000a6b4 	.word	0x2000a6b4

08008894 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8008894:	b580      	push	{r7, lr}
 8008896:	b086      	sub	sp, #24
 8008898:	af00      	add	r7, sp, #0
 800889a:	60f8      	str	r0, [r7, #12]
 800889c:	60b9      	str	r1, [r7, #8]
 800889e:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = xQueue;
 80088a0:	68fb      	ldr	r3, [r7, #12]
 80088a2:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 80088a4:	f001 fd52 	bl	800a34c <vPortEnterCritical>
 80088a8:	697b      	ldr	r3, [r7, #20]
 80088aa:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 80088ae:	b25b      	sxtb	r3, r3
 80088b0:	f1b3 3fff 	cmp.w	r3, #4294967295
 80088b4:	d103      	bne.n	80088be <vQueueWaitForMessageRestricted+0x2a>
 80088b6:	697b      	ldr	r3, [r7, #20]
 80088b8:	2200      	movs	r2, #0
 80088ba:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 80088be:	697b      	ldr	r3, [r7, #20]
 80088c0:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 80088c4:	b25b      	sxtb	r3, r3
 80088c6:	f1b3 3fff 	cmp.w	r3, #4294967295
 80088ca:	d103      	bne.n	80088d4 <vQueueWaitForMessageRestricted+0x40>
 80088cc:	697b      	ldr	r3, [r7, #20]
 80088ce:	2200      	movs	r2, #0
 80088d0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 80088d4:	f001 fd68 	bl	800a3a8 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 80088d8:	697b      	ldr	r3, [r7, #20]
 80088da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80088dc:	2b00      	cmp	r3, #0
 80088de:	d106      	bne.n	80088ee <vQueueWaitForMessageRestricted+0x5a>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 80088e0:	697b      	ldr	r3, [r7, #20]
 80088e2:	3324      	adds	r3, #36	; 0x24
 80088e4:	687a      	ldr	r2, [r7, #4]
 80088e6:	68b9      	ldr	r1, [r7, #8]
 80088e8:	4618      	mov	r0, r3
 80088ea:	f000 fdd9 	bl	80094a0 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 80088ee:	6978      	ldr	r0, [r7, #20]
 80088f0:	f7ff ff28 	bl	8008744 <prvUnlockQueue>
	}
 80088f4:	bf00      	nop
 80088f6:	3718      	adds	r7, #24
 80088f8:	46bd      	mov	sp, r7
 80088fa:	bd80      	pop	{r7, pc}

080088fc <xTaskCreateStatic>:
									const uint32_t ulStackDepth,
									void * const pvParameters,
									UBaseType_t uxPriority,
									StackType_t * const puxStackBuffer,
									StaticTask_t * const pxTaskBuffer )
	{
 80088fc:	b580      	push	{r7, lr}
 80088fe:	b08e      	sub	sp, #56	; 0x38
 8008900:	af04      	add	r7, sp, #16
 8008902:	60f8      	str	r0, [r7, #12]
 8008904:	60b9      	str	r1, [r7, #8]
 8008906:	607a      	str	r2, [r7, #4]
 8008908:	603b      	str	r3, [r7, #0]
	TCB_t *pxNewTCB;
	TaskHandle_t xReturn;

		configASSERT( puxStackBuffer != NULL );
 800890a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800890c:	2b00      	cmp	r3, #0
 800890e:	d109      	bne.n	8008924 <xTaskCreateStatic+0x28>
 8008910:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008914:	f383 8811 	msr	BASEPRI, r3
 8008918:	f3bf 8f6f 	isb	sy
 800891c:	f3bf 8f4f 	dsb	sy
 8008920:	623b      	str	r3, [r7, #32]
 8008922:	e7fe      	b.n	8008922 <xTaskCreateStatic+0x26>
		configASSERT( pxTaskBuffer != NULL );
 8008924:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008926:	2b00      	cmp	r3, #0
 8008928:	d109      	bne.n	800893e <xTaskCreateStatic+0x42>
 800892a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800892e:	f383 8811 	msr	BASEPRI, r3
 8008932:	f3bf 8f6f 	isb	sy
 8008936:	f3bf 8f4f 	dsb	sy
 800893a:	61fb      	str	r3, [r7, #28]
 800893c:	e7fe      	b.n	800893c <xTaskCreateStatic+0x40>
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticTask_t equals the size of the real task
			structure. */
			volatile size_t xSize = sizeof( StaticTask_t );
 800893e:	235c      	movs	r3, #92	; 0x5c
 8008940:	613b      	str	r3, [r7, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 8008942:	693b      	ldr	r3, [r7, #16]
 8008944:	2b5c      	cmp	r3, #92	; 0x5c
 8008946:	d009      	beq.n	800895c <xTaskCreateStatic+0x60>
 8008948:	f04f 0350 	mov.w	r3, #80	; 0x50
 800894c:	f383 8811 	msr	BASEPRI, r3
 8008950:	f3bf 8f6f 	isb	sy
 8008954:	f3bf 8f4f 	dsb	sy
 8008958:	61bb      	str	r3, [r7, #24]
 800895a:	e7fe      	b.n	800895a <xTaskCreateStatic+0x5e>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 800895c:	693b      	ldr	r3, [r7, #16]
		}
		#endif /* configASSERT_DEFINED */


		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 800895e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008960:	2b00      	cmp	r3, #0
 8008962:	d01e      	beq.n	80089a2 <xTaskCreateStatic+0xa6>
 8008964:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008966:	2b00      	cmp	r3, #0
 8008968:	d01b      	beq.n	80089a2 <xTaskCreateStatic+0xa6>
		{
			/* The memory used for the task's TCB and stack are passed into this
			function - use them. */
			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
 800896a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800896c:	627b      	str	r3, [r7, #36]	; 0x24
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800896e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008970:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008972:	631a      	str	r2, [r3, #48]	; 0x30

			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created statically in case the task is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8008974:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008976:	2202      	movs	r2, #2
 8008978:	f883 2059 	strb.w	r2, [r3, #89]	; 0x59
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 800897c:	2300      	movs	r3, #0
 800897e:	9303      	str	r3, [sp, #12]
 8008980:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008982:	9302      	str	r3, [sp, #8]
 8008984:	f107 0314 	add.w	r3, r7, #20
 8008988:	9301      	str	r3, [sp, #4]
 800898a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800898c:	9300      	str	r3, [sp, #0]
 800898e:	683b      	ldr	r3, [r7, #0]
 8008990:	687a      	ldr	r2, [r7, #4]
 8008992:	68b9      	ldr	r1, [r7, #8]
 8008994:	68f8      	ldr	r0, [r7, #12]
 8008996:	f000 f850 	bl	8008a3a <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 800899a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800899c:	f000 f8dc 	bl	8008b58 <prvAddNewTaskToReadyList>
 80089a0:	e001      	b.n	80089a6 <xTaskCreateStatic+0xaa>
		}
		else
		{
			xReturn = NULL;
 80089a2:	2300      	movs	r3, #0
 80089a4:	617b      	str	r3, [r7, #20]
		}

		return xReturn;
 80089a6:	697b      	ldr	r3, [r7, #20]
	}
 80089a8:	4618      	mov	r0, r3
 80089aa:	3728      	adds	r7, #40	; 0x28
 80089ac:	46bd      	mov	sp, r7
 80089ae:	bd80      	pop	{r7, pc}

080089b0 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
 80089b0:	b580      	push	{r7, lr}
 80089b2:	b08c      	sub	sp, #48	; 0x30
 80089b4:	af04      	add	r7, sp, #16
 80089b6:	60f8      	str	r0, [r7, #12]
 80089b8:	60b9      	str	r1, [r7, #8]
 80089ba:	603b      	str	r3, [r7, #0]
 80089bc:	4613      	mov	r3, r2
 80089be:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 80089c0:	88fb      	ldrh	r3, [r7, #6]
 80089c2:	009b      	lsls	r3, r3, #2
 80089c4:	4618      	mov	r0, r3
 80089c6:	f001 fddb 	bl	800a580 <pvPortMalloc>
 80089ca:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
 80089cc:	697b      	ldr	r3, [r7, #20]
 80089ce:	2b00      	cmp	r3, #0
 80089d0:	d00e      	beq.n	80089f0 <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 80089d2:	205c      	movs	r0, #92	; 0x5c
 80089d4:	f001 fdd4 	bl	800a580 <pvPortMalloc>
 80089d8:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
 80089da:	69fb      	ldr	r3, [r7, #28]
 80089dc:	2b00      	cmp	r3, #0
 80089de:	d003      	beq.n	80089e8 <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 80089e0:	69fb      	ldr	r3, [r7, #28]
 80089e2:	697a      	ldr	r2, [r7, #20]
 80089e4:	631a      	str	r2, [r3, #48]	; 0x30
 80089e6:	e005      	b.n	80089f4 <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 80089e8:	6978      	ldr	r0, [r7, #20]
 80089ea:	f001 fe8b 	bl	800a704 <vPortFree>
 80089ee:	e001      	b.n	80089f4 <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
 80089f0:	2300      	movs	r3, #0
 80089f2:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 80089f4:	69fb      	ldr	r3, [r7, #28]
 80089f6:	2b00      	cmp	r3, #0
 80089f8:	d017      	beq.n	8008a2a <xTaskCreate+0x7a>
		{
			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 80089fa:	69fb      	ldr	r3, [r7, #28]
 80089fc:	2200      	movs	r2, #0
 80089fe:	f883 2059 	strb.w	r2, [r3, #89]	; 0x59
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8008a02:	88fa      	ldrh	r2, [r7, #6]
 8008a04:	2300      	movs	r3, #0
 8008a06:	9303      	str	r3, [sp, #12]
 8008a08:	69fb      	ldr	r3, [r7, #28]
 8008a0a:	9302      	str	r3, [sp, #8]
 8008a0c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008a0e:	9301      	str	r3, [sp, #4]
 8008a10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008a12:	9300      	str	r3, [sp, #0]
 8008a14:	683b      	ldr	r3, [r7, #0]
 8008a16:	68b9      	ldr	r1, [r7, #8]
 8008a18:	68f8      	ldr	r0, [r7, #12]
 8008a1a:	f000 f80e 	bl	8008a3a <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 8008a1e:	69f8      	ldr	r0, [r7, #28]
 8008a20:	f000 f89a 	bl	8008b58 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 8008a24:	2301      	movs	r3, #1
 8008a26:	61bb      	str	r3, [r7, #24]
 8008a28:	e002      	b.n	8008a30 <xTaskCreate+0x80>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8008a2a:	f04f 33ff 	mov.w	r3, #4294967295
 8008a2e:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
 8008a30:	69bb      	ldr	r3, [r7, #24]
	}
 8008a32:	4618      	mov	r0, r3
 8008a34:	3720      	adds	r7, #32
 8008a36:	46bd      	mov	sp, r7
 8008a38:	bd80      	pop	{r7, pc}

08008a3a <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
 8008a3a:	b580      	push	{r7, lr}
 8008a3c:	b088      	sub	sp, #32
 8008a3e:	af00      	add	r7, sp, #0
 8008a40:	60f8      	str	r0, [r7, #12]
 8008a42:	60b9      	str	r1, [r7, #8]
 8008a44:	607a      	str	r2, [r7, #4]
 8008a46:	603b      	str	r3, [r7, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8008a48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008a4a:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8008a4c:	687b      	ldr	r3, [r7, #4]
 8008a4e:	009b      	lsls	r3, r3, #2
 8008a50:	461a      	mov	r2, r3
 8008a52:	21a5      	movs	r1, #165	; 0xa5
 8008a54:	f01f f835 	bl	8027ac2 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8008a58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008a5a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8008a5c:	687b      	ldr	r3, [r7, #4]
 8008a5e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8008a62:	3b01      	subs	r3, #1
 8008a64:	009b      	lsls	r3, r3, #2
 8008a66:	4413      	add	r3, r2
 8008a68:	61bb      	str	r3, [r7, #24]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8008a6a:	69bb      	ldr	r3, [r7, #24]
 8008a6c:	f023 0307 	bic.w	r3, r3, #7
 8008a70:	61bb      	str	r3, [r7, #24]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 8008a72:	69bb      	ldr	r3, [r7, #24]
 8008a74:	f003 0307 	and.w	r3, r3, #7
 8008a78:	2b00      	cmp	r3, #0
 8008a7a:	d009      	beq.n	8008a90 <prvInitialiseNewTask+0x56>
 8008a7c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008a80:	f383 8811 	msr	BASEPRI, r3
 8008a84:	f3bf 8f6f 	isb	sy
 8008a88:	f3bf 8f4f 	dsb	sy
 8008a8c:	617b      	str	r3, [r7, #20]
 8008a8e:	e7fe      	b.n	8008a8e <prvInitialiseNewTask+0x54>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
 8008a90:	68bb      	ldr	r3, [r7, #8]
 8008a92:	2b00      	cmp	r3, #0
 8008a94:	d01f      	beq.n	8008ad6 <prvInitialiseNewTask+0x9c>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8008a96:	2300      	movs	r3, #0
 8008a98:	61fb      	str	r3, [r7, #28]
 8008a9a:	e012      	b.n	8008ac2 <prvInitialiseNewTask+0x88>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8008a9c:	68ba      	ldr	r2, [r7, #8]
 8008a9e:	69fb      	ldr	r3, [r7, #28]
 8008aa0:	4413      	add	r3, r2
 8008aa2:	7819      	ldrb	r1, [r3, #0]
 8008aa4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008aa6:	69fb      	ldr	r3, [r7, #28]
 8008aa8:	4413      	add	r3, r2
 8008aaa:	3334      	adds	r3, #52	; 0x34
 8008aac:	460a      	mov	r2, r1
 8008aae:	701a      	strb	r2, [r3, #0]

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
 8008ab0:	68ba      	ldr	r2, [r7, #8]
 8008ab2:	69fb      	ldr	r3, [r7, #28]
 8008ab4:	4413      	add	r3, r2
 8008ab6:	781b      	ldrb	r3, [r3, #0]
 8008ab8:	2b00      	cmp	r3, #0
 8008aba:	d006      	beq.n	8008aca <prvInitialiseNewTask+0x90>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8008abc:	69fb      	ldr	r3, [r7, #28]
 8008abe:	3301      	adds	r3, #1
 8008ac0:	61fb      	str	r3, [r7, #28]
 8008ac2:	69fb      	ldr	r3, [r7, #28]
 8008ac4:	2b0f      	cmp	r3, #15
 8008ac6:	d9e9      	bls.n	8008a9c <prvInitialiseNewTask+0x62>
 8008ac8:	e000      	b.n	8008acc <prvInitialiseNewTask+0x92>
			{
				break;
 8008aca:	bf00      	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8008acc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ace:	2200      	movs	r2, #0
 8008ad0:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
 8008ad4:	e003      	b.n	8008ade <prvInitialiseNewTask+0xa4>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8008ad6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ad8:	2200      	movs	r2, #0
 8008ada:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8008ade:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008ae0:	2b37      	cmp	r3, #55	; 0x37
 8008ae2:	d901      	bls.n	8008ae8 <prvInitialiseNewTask+0xae>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 8008ae4:	2337      	movs	r3, #55	; 0x37
 8008ae6:	62bb      	str	r3, [r7, #40]	; 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 8008ae8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008aea:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008aec:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 8008aee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008af0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008af2:	64da      	str	r2, [r3, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 8008af4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008af6:	2200      	movs	r2, #0
 8008af8:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8008afa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008afc:	3304      	adds	r3, #4
 8008afe:	4618      	mov	r0, r3
 8008b00:	f7ff f90a 	bl	8007d18 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8008b04:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008b06:	3318      	adds	r3, #24
 8008b08:	4618      	mov	r0, r3
 8008b0a:	f7ff f905 	bl	8007d18 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8008b0e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008b10:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008b12:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8008b14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008b16:	f1c3 0238 	rsb	r2, r3, #56	; 0x38
 8008b1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008b1c:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8008b1e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008b20:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008b22:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 8008b24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008b26:	2200      	movs	r2, #0
 8008b28:	655a      	str	r2, [r3, #84]	; 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8008b2a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008b2c:	2200      	movs	r2, #0
 8008b2e:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8008b32:	683a      	ldr	r2, [r7, #0]
 8008b34:	68f9      	ldr	r1, [r7, #12]
 8008b36:	69b8      	ldr	r0, [r7, #24]
 8008b38:	f001 fae0 	bl	800a0fc <pxPortInitialiseStack>
 8008b3c:	4602      	mov	r2, r0
 8008b3e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008b40:	601a      	str	r2, [r3, #0]
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
 8008b42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008b44:	2b00      	cmp	r3, #0
 8008b46:	d002      	beq.n	8008b4e <prvInitialiseNewTask+0x114>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8008b48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008b4a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008b4c:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8008b4e:	bf00      	nop
 8008b50:	3720      	adds	r7, #32
 8008b52:	46bd      	mov	sp, r7
 8008b54:	bd80      	pop	{r7, pc}
	...

08008b58 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 8008b58:	b580      	push	{r7, lr}
 8008b5a:	b082      	sub	sp, #8
 8008b5c:	af00      	add	r7, sp, #0
 8008b5e:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 8008b60:	f001 fbf4 	bl	800a34c <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 8008b64:	4b2d      	ldr	r3, [pc, #180]	; (8008c1c <prvAddNewTaskToReadyList+0xc4>)
 8008b66:	681b      	ldr	r3, [r3, #0]
 8008b68:	3301      	adds	r3, #1
 8008b6a:	4a2c      	ldr	r2, [pc, #176]	; (8008c1c <prvAddNewTaskToReadyList+0xc4>)
 8008b6c:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8008b6e:	4b2c      	ldr	r3, [pc, #176]	; (8008c20 <prvAddNewTaskToReadyList+0xc8>)
 8008b70:	681b      	ldr	r3, [r3, #0]
 8008b72:	2b00      	cmp	r3, #0
 8008b74:	d109      	bne.n	8008b8a <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 8008b76:	4a2a      	ldr	r2, [pc, #168]	; (8008c20 <prvAddNewTaskToReadyList+0xc8>)
 8008b78:	687b      	ldr	r3, [r7, #4]
 8008b7a:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8008b7c:	4b27      	ldr	r3, [pc, #156]	; (8008c1c <prvAddNewTaskToReadyList+0xc4>)
 8008b7e:	681b      	ldr	r3, [r3, #0]
 8008b80:	2b01      	cmp	r3, #1
 8008b82:	d110      	bne.n	8008ba6 <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 8008b84:	f000 fddc 	bl	8009740 <prvInitialiseTaskLists>
 8008b88:	e00d      	b.n	8008ba6 <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 8008b8a:	4b26      	ldr	r3, [pc, #152]	; (8008c24 <prvAddNewTaskToReadyList+0xcc>)
 8008b8c:	681b      	ldr	r3, [r3, #0]
 8008b8e:	2b00      	cmp	r3, #0
 8008b90:	d109      	bne.n	8008ba6 <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8008b92:	4b23      	ldr	r3, [pc, #140]	; (8008c20 <prvAddNewTaskToReadyList+0xc8>)
 8008b94:	681b      	ldr	r3, [r3, #0]
 8008b96:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008b98:	687b      	ldr	r3, [r7, #4]
 8008b9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008b9c:	429a      	cmp	r2, r3
 8008b9e:	d802      	bhi.n	8008ba6 <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
 8008ba0:	4a1f      	ldr	r2, [pc, #124]	; (8008c20 <prvAddNewTaskToReadyList+0xc8>)
 8008ba2:	687b      	ldr	r3, [r7, #4]
 8008ba4:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 8008ba6:	4b20      	ldr	r3, [pc, #128]	; (8008c28 <prvAddNewTaskToReadyList+0xd0>)
 8008ba8:	681b      	ldr	r3, [r3, #0]
 8008baa:	3301      	adds	r3, #1
 8008bac:	4a1e      	ldr	r2, [pc, #120]	; (8008c28 <prvAddNewTaskToReadyList+0xd0>)
 8008bae:	6013      	str	r3, [r2, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8008bb0:	4b1d      	ldr	r3, [pc, #116]	; (8008c28 <prvAddNewTaskToReadyList+0xd0>)
 8008bb2:	681a      	ldr	r2, [r3, #0]
 8008bb4:	687b      	ldr	r3, [r7, #4]
 8008bb6:	645a      	str	r2, [r3, #68]	; 0x44
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 8008bb8:	687b      	ldr	r3, [r7, #4]
 8008bba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008bbc:	4b1b      	ldr	r3, [pc, #108]	; (8008c2c <prvAddNewTaskToReadyList+0xd4>)
 8008bbe:	681b      	ldr	r3, [r3, #0]
 8008bc0:	429a      	cmp	r2, r3
 8008bc2:	d903      	bls.n	8008bcc <prvAddNewTaskToReadyList+0x74>
 8008bc4:	687b      	ldr	r3, [r7, #4]
 8008bc6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008bc8:	4a18      	ldr	r2, [pc, #96]	; (8008c2c <prvAddNewTaskToReadyList+0xd4>)
 8008bca:	6013      	str	r3, [r2, #0]
 8008bcc:	687b      	ldr	r3, [r7, #4]
 8008bce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008bd0:	4613      	mov	r3, r2
 8008bd2:	009b      	lsls	r3, r3, #2
 8008bd4:	4413      	add	r3, r2
 8008bd6:	009b      	lsls	r3, r3, #2
 8008bd8:	4a15      	ldr	r2, [pc, #84]	; (8008c30 <prvAddNewTaskToReadyList+0xd8>)
 8008bda:	441a      	add	r2, r3
 8008bdc:	687b      	ldr	r3, [r7, #4]
 8008bde:	3304      	adds	r3, #4
 8008be0:	4619      	mov	r1, r3
 8008be2:	4610      	mov	r0, r2
 8008be4:	f7ff f8a5 	bl	8007d32 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 8008be8:	f001 fbde 	bl	800a3a8 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 8008bec:	4b0d      	ldr	r3, [pc, #52]	; (8008c24 <prvAddNewTaskToReadyList+0xcc>)
 8008bee:	681b      	ldr	r3, [r3, #0]
 8008bf0:	2b00      	cmp	r3, #0
 8008bf2:	d00e      	beq.n	8008c12 <prvAddNewTaskToReadyList+0xba>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8008bf4:	4b0a      	ldr	r3, [pc, #40]	; (8008c20 <prvAddNewTaskToReadyList+0xc8>)
 8008bf6:	681b      	ldr	r3, [r3, #0]
 8008bf8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008bfa:	687b      	ldr	r3, [r7, #4]
 8008bfc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008bfe:	429a      	cmp	r2, r3
 8008c00:	d207      	bcs.n	8008c12 <prvAddNewTaskToReadyList+0xba>
		{
			taskYIELD_IF_USING_PREEMPTION();
 8008c02:	4b0c      	ldr	r3, [pc, #48]	; (8008c34 <prvAddNewTaskToReadyList+0xdc>)
 8008c04:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008c08:	601a      	str	r2, [r3, #0]
 8008c0a:	f3bf 8f4f 	dsb	sy
 8008c0e:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8008c12:	bf00      	nop
 8008c14:	3708      	adds	r7, #8
 8008c16:	46bd      	mov	sp, r7
 8008c18:	bd80      	pop	{r7, pc}
 8008c1a:	bf00      	nop
 8008c1c:	20000fa0 	.word	0x20000fa0
 8008c20:	20000acc 	.word	0x20000acc
 8008c24:	20000fac 	.word	0x20000fac
 8008c28:	20000fbc 	.word	0x20000fbc
 8008c2c:	20000fa8 	.word	0x20000fa8
 8008c30:	20000ad0 	.word	0x20000ad0
 8008c34:	e000ed04 	.word	0xe000ed04

08008c38 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
 8008c38:	b580      	push	{r7, lr}
 8008c3a:	b084      	sub	sp, #16
 8008c3c:	af00      	add	r7, sp, #0
 8008c3e:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 8008c40:	f001 fb84 	bl	800a34c <vPortEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8008c44:	687b      	ldr	r3, [r7, #4]
 8008c46:	2b00      	cmp	r3, #0
 8008c48:	d102      	bne.n	8008c50 <vTaskDelete+0x18>
 8008c4a:	4b2c      	ldr	r3, [pc, #176]	; (8008cfc <vTaskDelete+0xc4>)
 8008c4c:	681b      	ldr	r3, [r3, #0]
 8008c4e:	e000      	b.n	8008c52 <vTaskDelete+0x1a>
 8008c50:	687b      	ldr	r3, [r7, #4]
 8008c52:	60fb      	str	r3, [r7, #12]

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8008c54:	68fb      	ldr	r3, [r7, #12]
 8008c56:	3304      	adds	r3, #4
 8008c58:	4618      	mov	r0, r3
 8008c5a:	f7ff f8c7 	bl	8007dec <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8008c5e:	68fb      	ldr	r3, [r7, #12]
 8008c60:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008c62:	2b00      	cmp	r3, #0
 8008c64:	d004      	beq.n	8008c70 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8008c66:	68fb      	ldr	r3, [r7, #12]
 8008c68:	3318      	adds	r3, #24
 8008c6a:	4618      	mov	r0, r3
 8008c6c:	f7ff f8be 	bl	8007dec <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
 8008c70:	4b23      	ldr	r3, [pc, #140]	; (8008d00 <vTaskDelete+0xc8>)
 8008c72:	681b      	ldr	r3, [r3, #0]
 8008c74:	3301      	adds	r3, #1
 8008c76:	4a22      	ldr	r2, [pc, #136]	; (8008d00 <vTaskDelete+0xc8>)
 8008c78:	6013      	str	r3, [r2, #0]

			if( pxTCB == pxCurrentTCB )
 8008c7a:	4b20      	ldr	r3, [pc, #128]	; (8008cfc <vTaskDelete+0xc4>)
 8008c7c:	681b      	ldr	r3, [r3, #0]
 8008c7e:	68fa      	ldr	r2, [r7, #12]
 8008c80:	429a      	cmp	r2, r3
 8008c82:	d10b      	bne.n	8008c9c <vTaskDelete+0x64>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 8008c84:	68fb      	ldr	r3, [r7, #12]
 8008c86:	3304      	adds	r3, #4
 8008c88:	4619      	mov	r1, r3
 8008c8a:	481e      	ldr	r0, [pc, #120]	; (8008d04 <vTaskDelete+0xcc>)
 8008c8c:	f7ff f851 	bl	8007d32 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
 8008c90:	4b1d      	ldr	r3, [pc, #116]	; (8008d08 <vTaskDelete+0xd0>)
 8008c92:	681b      	ldr	r3, [r3, #0]
 8008c94:	3301      	adds	r3, #1
 8008c96:	4a1c      	ldr	r2, [pc, #112]	; (8008d08 <vTaskDelete+0xd0>)
 8008c98:	6013      	str	r3, [r2, #0]
 8008c9a:	e009      	b.n	8008cb0 <vTaskDelete+0x78>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
 8008c9c:	4b1b      	ldr	r3, [pc, #108]	; (8008d0c <vTaskDelete+0xd4>)
 8008c9e:	681b      	ldr	r3, [r3, #0]
 8008ca0:	3b01      	subs	r3, #1
 8008ca2:	4a1a      	ldr	r2, [pc, #104]	; (8008d0c <vTaskDelete+0xd4>)
 8008ca4:	6013      	str	r3, [r2, #0]
				prvDeleteTCB( pxTCB );
 8008ca6:	68f8      	ldr	r0, [r7, #12]
 8008ca8:	f000 fdb6 	bl	8009818 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
 8008cac:	f000 fde2 	bl	8009874 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 8008cb0:	f001 fb7a 	bl	800a3a8 <vPortExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
 8008cb4:	4b16      	ldr	r3, [pc, #88]	; (8008d10 <vTaskDelete+0xd8>)
 8008cb6:	681b      	ldr	r3, [r3, #0]
 8008cb8:	2b00      	cmp	r3, #0
 8008cba:	d01a      	beq.n	8008cf2 <vTaskDelete+0xba>
		{
			if( pxTCB == pxCurrentTCB )
 8008cbc:	4b0f      	ldr	r3, [pc, #60]	; (8008cfc <vTaskDelete+0xc4>)
 8008cbe:	681b      	ldr	r3, [r3, #0]
 8008cc0:	68fa      	ldr	r2, [r7, #12]
 8008cc2:	429a      	cmp	r2, r3
 8008cc4:	d115      	bne.n	8008cf2 <vTaskDelete+0xba>
			{
				configASSERT( uxSchedulerSuspended == 0 );
 8008cc6:	4b13      	ldr	r3, [pc, #76]	; (8008d14 <vTaskDelete+0xdc>)
 8008cc8:	681b      	ldr	r3, [r3, #0]
 8008cca:	2b00      	cmp	r3, #0
 8008ccc:	d009      	beq.n	8008ce2 <vTaskDelete+0xaa>
 8008cce:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008cd2:	f383 8811 	msr	BASEPRI, r3
 8008cd6:	f3bf 8f6f 	isb	sy
 8008cda:	f3bf 8f4f 	dsb	sy
 8008cde:	60bb      	str	r3, [r7, #8]
 8008ce0:	e7fe      	b.n	8008ce0 <vTaskDelete+0xa8>
				portYIELD_WITHIN_API();
 8008ce2:	4b0d      	ldr	r3, [pc, #52]	; (8008d18 <vTaskDelete+0xe0>)
 8008ce4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008ce8:	601a      	str	r2, [r3, #0]
 8008cea:	f3bf 8f4f 	dsb	sy
 8008cee:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 8008cf2:	bf00      	nop
 8008cf4:	3710      	adds	r7, #16
 8008cf6:	46bd      	mov	sp, r7
 8008cf8:	bd80      	pop	{r7, pc}
 8008cfa:	bf00      	nop
 8008cfc:	20000acc 	.word	0x20000acc
 8008d00:	20000fbc 	.word	0x20000fbc
 8008d04:	20000f74 	.word	0x20000f74
 8008d08:	20000f88 	.word	0x20000f88
 8008d0c:	20000fa0 	.word	0x20000fa0
 8008d10:	20000fac 	.word	0x20000fac
 8008d14:	20000fc8 	.word	0x20000fc8
 8008d18:	e000ed04 	.word	0xe000ed04

08008d1c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 8008d1c:	b580      	push	{r7, lr}
 8008d1e:	b084      	sub	sp, #16
 8008d20:	af00      	add	r7, sp, #0
 8008d22:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
 8008d24:	2300      	movs	r3, #0
 8008d26:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 8008d28:	687b      	ldr	r3, [r7, #4]
 8008d2a:	2b00      	cmp	r3, #0
 8008d2c:	d016      	beq.n	8008d5c <vTaskDelay+0x40>
		{
			configASSERT( uxSchedulerSuspended == 0 );
 8008d2e:	4b13      	ldr	r3, [pc, #76]	; (8008d7c <vTaskDelay+0x60>)
 8008d30:	681b      	ldr	r3, [r3, #0]
 8008d32:	2b00      	cmp	r3, #0
 8008d34:	d009      	beq.n	8008d4a <vTaskDelay+0x2e>
 8008d36:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008d3a:	f383 8811 	msr	BASEPRI, r3
 8008d3e:	f3bf 8f6f 	isb	sy
 8008d42:	f3bf 8f4f 	dsb	sy
 8008d46:	60bb      	str	r3, [r7, #8]
 8008d48:	e7fe      	b.n	8008d48 <vTaskDelay+0x2c>
			vTaskSuspendAll();
 8008d4a:	f000 f959 	bl	8009000 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8008d4e:	2100      	movs	r1, #0
 8008d50:	6878      	ldr	r0, [r7, #4]
 8008d52:	f000 fe39 	bl	80099c8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8008d56:	f000 f999 	bl	800908c <xTaskResumeAll>
 8008d5a:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8008d5c:	68fb      	ldr	r3, [r7, #12]
 8008d5e:	2b00      	cmp	r3, #0
 8008d60:	d107      	bne.n	8008d72 <vTaskDelay+0x56>
		{
			portYIELD_WITHIN_API();
 8008d62:	4b07      	ldr	r3, [pc, #28]	; (8008d80 <vTaskDelay+0x64>)
 8008d64:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008d68:	601a      	str	r2, [r3, #0]
 8008d6a:	f3bf 8f4f 	dsb	sy
 8008d6e:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8008d72:	bf00      	nop
 8008d74:	3710      	adds	r7, #16
 8008d76:	46bd      	mov	sp, r7
 8008d78:	bd80      	pop	{r7, pc}
 8008d7a:	bf00      	nop
 8008d7c:	20000fc8 	.word	0x20000fc8
 8008d80:	e000ed04 	.word	0xe000ed04

08008d84 <eTaskGetState>:
/*-----------------------------------------------------------*/

#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )

	eTaskState eTaskGetState( TaskHandle_t xTask )
	{
 8008d84:	b580      	push	{r7, lr}
 8008d86:	b088      	sub	sp, #32
 8008d88:	af00      	add	r7, sp, #0
 8008d8a:	6078      	str	r0, [r7, #4]
	eTaskState eReturn;
	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
	const TCB_t * const pxTCB = xTask;
 8008d8c:	687b      	ldr	r3, [r7, #4]
 8008d8e:	61bb      	str	r3, [r7, #24]

		configASSERT( pxTCB );
 8008d90:	69bb      	ldr	r3, [r7, #24]
 8008d92:	2b00      	cmp	r3, #0
 8008d94:	d109      	bne.n	8008daa <eTaskGetState+0x26>
 8008d96:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008d9a:	f383 8811 	msr	BASEPRI, r3
 8008d9e:	f3bf 8f6f 	isb	sy
 8008da2:	f3bf 8f4f 	dsb	sy
 8008da6:	60bb      	str	r3, [r7, #8]
 8008da8:	e7fe      	b.n	8008da8 <eTaskGetState+0x24>

		if( pxTCB == pxCurrentTCB )
 8008daa:	4b24      	ldr	r3, [pc, #144]	; (8008e3c <eTaskGetState+0xb8>)
 8008dac:	681b      	ldr	r3, [r3, #0]
 8008dae:	69ba      	ldr	r2, [r7, #24]
 8008db0:	429a      	cmp	r2, r3
 8008db2:	d102      	bne.n	8008dba <eTaskGetState+0x36>
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
 8008db4:	2300      	movs	r3, #0
 8008db6:	77fb      	strb	r3, [r7, #31]
 8008db8:	e03a      	b.n	8008e30 <eTaskGetState+0xac>
		}
		else
		{
			taskENTER_CRITICAL();
 8008dba:	f001 fac7 	bl	800a34c <vPortEnterCritical>
			{
				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 8008dbe:	69bb      	ldr	r3, [r7, #24]
 8008dc0:	695b      	ldr	r3, [r3, #20]
 8008dc2:	617b      	str	r3, [r7, #20]
				pxDelayedList = pxDelayedTaskList;
 8008dc4:	4b1e      	ldr	r3, [pc, #120]	; (8008e40 <eTaskGetState+0xbc>)
 8008dc6:	681b      	ldr	r3, [r3, #0]
 8008dc8:	613b      	str	r3, [r7, #16]
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 8008dca:	4b1e      	ldr	r3, [pc, #120]	; (8008e44 <eTaskGetState+0xc0>)
 8008dcc:	681b      	ldr	r3, [r3, #0]
 8008dce:	60fb      	str	r3, [r7, #12]
			}
			taskEXIT_CRITICAL();
 8008dd0:	f001 faea 	bl	800a3a8 <vPortExitCritical>

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
 8008dd4:	697a      	ldr	r2, [r7, #20]
 8008dd6:	693b      	ldr	r3, [r7, #16]
 8008dd8:	429a      	cmp	r2, r3
 8008dda:	d003      	beq.n	8008de4 <eTaskGetState+0x60>
 8008ddc:	697a      	ldr	r2, [r7, #20]
 8008dde:	68fb      	ldr	r3, [r7, #12]
 8008de0:	429a      	cmp	r2, r3
 8008de2:	d102      	bne.n	8008dea <eTaskGetState+0x66>
			{
				/* The task being queried is referenced from one of the Blocked
				lists. */
				eReturn = eBlocked;
 8008de4:	2302      	movs	r3, #2
 8008de6:	77fb      	strb	r3, [r7, #31]
 8008de8:	e022      	b.n	8008e30 <eTaskGetState+0xac>
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
 8008dea:	697b      	ldr	r3, [r7, #20]
 8008dec:	4a16      	ldr	r2, [pc, #88]	; (8008e48 <eTaskGetState+0xc4>)
 8008dee:	4293      	cmp	r3, r2
 8008df0:	d112      	bne.n	8008e18 <eTaskGetState+0x94>
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it blocked
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 8008df2:	69bb      	ldr	r3, [r7, #24]
 8008df4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008df6:	2b00      	cmp	r3, #0
 8008df8:	d10b      	bne.n	8008e12 <eTaskGetState+0x8e>
						{
							/* The task does not appear on the event list item of
							and of the RTOS objects, but could still be in the
							blocked state if it is waiting on its notification
							rather than waiting on an object. */
							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 8008dfa:	69bb      	ldr	r3, [r7, #24]
 8008dfc:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8008e00:	b2db      	uxtb	r3, r3
 8008e02:	2b01      	cmp	r3, #1
 8008e04:	d102      	bne.n	8008e0c <eTaskGetState+0x88>
							{
								eReturn = eBlocked;
 8008e06:	2302      	movs	r3, #2
 8008e08:	77fb      	strb	r3, [r7, #31]
 8008e0a:	e011      	b.n	8008e30 <eTaskGetState+0xac>
							}
							else
							{
								eReturn = eSuspended;
 8008e0c:	2303      	movs	r3, #3
 8008e0e:	77fb      	strb	r3, [r7, #31]
 8008e10:	e00e      	b.n	8008e30 <eTaskGetState+0xac>
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
 8008e12:	2302      	movs	r3, #2
 8008e14:	77fb      	strb	r3, [r7, #31]
 8008e16:	e00b      	b.n	8008e30 <eTaskGetState+0xac>
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 8008e18:	697b      	ldr	r3, [r7, #20]
 8008e1a:	4a0c      	ldr	r2, [pc, #48]	; (8008e4c <eTaskGetState+0xc8>)
 8008e1c:	4293      	cmp	r3, r2
 8008e1e:	d002      	beq.n	8008e26 <eTaskGetState+0xa2>
 8008e20:	697b      	ldr	r3, [r7, #20]
 8008e22:	2b00      	cmp	r3, #0
 8008e24:	d102      	bne.n	8008e2c <eTaskGetState+0xa8>
				{
					/* The task being queried is referenced from the deleted
					tasks list, or it is not referenced from any lists at
					all. */
					eReturn = eDeleted;
 8008e26:	2304      	movs	r3, #4
 8008e28:	77fb      	strb	r3, [r7, #31]
 8008e2a:	e001      	b.n	8008e30 <eTaskGetState+0xac>

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
 8008e2c:	2301      	movs	r3, #1
 8008e2e:	77fb      	strb	r3, [r7, #31]
			}
		}

		return eReturn;
 8008e30:	7ffb      	ldrb	r3, [r7, #31]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 8008e32:	4618      	mov	r0, r3
 8008e34:	3720      	adds	r7, #32
 8008e36:	46bd      	mov	sp, r7
 8008e38:	bd80      	pop	{r7, pc}
 8008e3a:	bf00      	nop
 8008e3c:	20000acc 	.word	0x20000acc
 8008e40:	20000f58 	.word	0x20000f58
 8008e44:	20000f5c 	.word	0x20000f5c
 8008e48:	20000f8c 	.word	0x20000f8c
 8008e4c:	20000f74 	.word	0x20000f74

08008e50 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 8008e50:	b580      	push	{r7, lr}
 8008e52:	b084      	sub	sp, #16
 8008e54:	af00      	add	r7, sp, #0
 8008e56:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 8008e58:	f001 fa78 	bl	800a34c <vPortEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8008e5c:	687b      	ldr	r3, [r7, #4]
 8008e5e:	2b00      	cmp	r3, #0
 8008e60:	d102      	bne.n	8008e68 <vTaskSuspend+0x18>
 8008e62:	4b2f      	ldr	r3, [pc, #188]	; (8008f20 <vTaskSuspend+0xd0>)
 8008e64:	681b      	ldr	r3, [r3, #0]
 8008e66:	e000      	b.n	8008e6a <vTaskSuspend+0x1a>
 8008e68:	687b      	ldr	r3, [r7, #4]
 8008e6a:	60fb      	str	r3, [r7, #12]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8008e6c:	68fb      	ldr	r3, [r7, #12]
 8008e6e:	3304      	adds	r3, #4
 8008e70:	4618      	mov	r0, r3
 8008e72:	f7fe ffbb 	bl	8007dec <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8008e76:	68fb      	ldr	r3, [r7, #12]
 8008e78:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008e7a:	2b00      	cmp	r3, #0
 8008e7c:	d004      	beq.n	8008e88 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8008e7e:	68fb      	ldr	r3, [r7, #12]
 8008e80:	3318      	adds	r3, #24
 8008e82:	4618      	mov	r0, r3
 8008e84:	f7fe ffb2 	bl	8007dec <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 8008e88:	68fb      	ldr	r3, [r7, #12]
 8008e8a:	3304      	adds	r3, #4
 8008e8c:	4619      	mov	r1, r3
 8008e8e:	4825      	ldr	r0, [pc, #148]	; (8008f24 <vTaskSuspend+0xd4>)
 8008e90:	f7fe ff4f 	bl	8007d32 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 8008e94:	68fb      	ldr	r3, [r7, #12]
 8008e96:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8008e9a:	b2db      	uxtb	r3, r3
 8008e9c:	2b01      	cmp	r3, #1
 8008e9e:	d103      	bne.n	8008ea8 <vTaskSuspend+0x58>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8008ea0:	68fb      	ldr	r3, [r7, #12]
 8008ea2:	2200      	movs	r2, #0
 8008ea4:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
 8008ea8:	f001 fa7e 	bl	800a3a8 <vPortExitCritical>

		if( xSchedulerRunning != pdFALSE )
 8008eac:	4b1e      	ldr	r3, [pc, #120]	; (8008f28 <vTaskSuspend+0xd8>)
 8008eae:	681b      	ldr	r3, [r3, #0]
 8008eb0:	2b00      	cmp	r3, #0
 8008eb2:	d005      	beq.n	8008ec0 <vTaskSuspend+0x70>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
 8008eb4:	f001 fa4a 	bl	800a34c <vPortEnterCritical>
			{
				prvResetNextTaskUnblockTime();
 8008eb8:	f000 fcdc 	bl	8009874 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
 8008ebc:	f001 fa74 	bl	800a3a8 <vPortExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
 8008ec0:	4b17      	ldr	r3, [pc, #92]	; (8008f20 <vTaskSuspend+0xd0>)
 8008ec2:	681b      	ldr	r3, [r3, #0]
 8008ec4:	68fa      	ldr	r2, [r7, #12]
 8008ec6:	429a      	cmp	r2, r3
 8008ec8:	d126      	bne.n	8008f18 <vTaskSuspend+0xc8>
		{
			if( xSchedulerRunning != pdFALSE )
 8008eca:	4b17      	ldr	r3, [pc, #92]	; (8008f28 <vTaskSuspend+0xd8>)
 8008ecc:	681b      	ldr	r3, [r3, #0]
 8008ece:	2b00      	cmp	r3, #0
 8008ed0:	d016      	beq.n	8008f00 <vTaskSuspend+0xb0>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
 8008ed2:	4b16      	ldr	r3, [pc, #88]	; (8008f2c <vTaskSuspend+0xdc>)
 8008ed4:	681b      	ldr	r3, [r3, #0]
 8008ed6:	2b00      	cmp	r3, #0
 8008ed8:	d009      	beq.n	8008eee <vTaskSuspend+0x9e>
 8008eda:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008ede:	f383 8811 	msr	BASEPRI, r3
 8008ee2:	f3bf 8f6f 	isb	sy
 8008ee6:	f3bf 8f4f 	dsb	sy
 8008eea:	60bb      	str	r3, [r7, #8]
 8008eec:	e7fe      	b.n	8008eec <vTaskSuspend+0x9c>
				portYIELD_WITHIN_API();
 8008eee:	4b10      	ldr	r3, [pc, #64]	; (8008f30 <vTaskSuspend+0xe0>)
 8008ef0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008ef4:	601a      	str	r2, [r3, #0]
 8008ef6:	f3bf 8f4f 	dsb	sy
 8008efa:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8008efe:	e00b      	b.n	8008f18 <vTaskSuspend+0xc8>
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 8008f00:	4b08      	ldr	r3, [pc, #32]	; (8008f24 <vTaskSuspend+0xd4>)
 8008f02:	681a      	ldr	r2, [r3, #0]
 8008f04:	4b0b      	ldr	r3, [pc, #44]	; (8008f34 <vTaskSuspend+0xe4>)
 8008f06:	681b      	ldr	r3, [r3, #0]
 8008f08:	429a      	cmp	r2, r3
 8008f0a:	d103      	bne.n	8008f14 <vTaskSuspend+0xc4>
					pxCurrentTCB = NULL;
 8008f0c:	4b04      	ldr	r3, [pc, #16]	; (8008f20 <vTaskSuspend+0xd0>)
 8008f0e:	2200      	movs	r2, #0
 8008f10:	601a      	str	r2, [r3, #0]
	}
 8008f12:	e001      	b.n	8008f18 <vTaskSuspend+0xc8>
					vTaskSwitchContext();
 8008f14:	f000 fa1e 	bl	8009354 <vTaskSwitchContext>
	}
 8008f18:	bf00      	nop
 8008f1a:	3710      	adds	r7, #16
 8008f1c:	46bd      	mov	sp, r7
 8008f1e:	bd80      	pop	{r7, pc}
 8008f20:	20000acc 	.word	0x20000acc
 8008f24:	20000f8c 	.word	0x20000f8c
 8008f28:	20000fac 	.word	0x20000fac
 8008f2c:	20000fc8 	.word	0x20000fc8
 8008f30:	e000ed04 	.word	0xe000ed04
 8008f34:	20000fa0 	.word	0x20000fa0

08008f38 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8008f38:	b580      	push	{r7, lr}
 8008f3a:	b08a      	sub	sp, #40	; 0x28
 8008f3c:	af04      	add	r7, sp, #16
BaseType_t xReturn;

	/* Add the idle task at the lowest priority. */
	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 8008f3e:	2300      	movs	r3, #0
 8008f40:	60bb      	str	r3, [r7, #8]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 8008f42:	2300      	movs	r3, #0
 8008f44:	607b      	str	r3, [r7, #4]
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8008f46:	463a      	mov	r2, r7
 8008f48:	1d39      	adds	r1, r7, #4
 8008f4a:	f107 0308 	add.w	r3, r7, #8
 8008f4e:	4618      	mov	r0, r3
 8008f50:	f7fe fe8e 	bl	8007c70 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 8008f54:	6839      	ldr	r1, [r7, #0]
 8008f56:	687b      	ldr	r3, [r7, #4]
 8008f58:	68ba      	ldr	r2, [r7, #8]
 8008f5a:	9202      	str	r2, [sp, #8]
 8008f5c:	9301      	str	r3, [sp, #4]
 8008f5e:	2300      	movs	r3, #0
 8008f60:	9300      	str	r3, [sp, #0]
 8008f62:	2300      	movs	r3, #0
 8008f64:	460a      	mov	r2, r1
 8008f66:	4920      	ldr	r1, [pc, #128]	; (8008fe8 <vTaskStartScheduler+0xb0>)
 8008f68:	4820      	ldr	r0, [pc, #128]	; (8008fec <vTaskStartScheduler+0xb4>)
 8008f6a:	f7ff fcc7 	bl	80088fc <xTaskCreateStatic>
 8008f6e:	4602      	mov	r2, r0
 8008f70:	4b1f      	ldr	r3, [pc, #124]	; (8008ff0 <vTaskStartScheduler+0xb8>)
 8008f72:	601a      	str	r2, [r3, #0]
												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if( xIdleTaskHandle != NULL )
 8008f74:	4b1e      	ldr	r3, [pc, #120]	; (8008ff0 <vTaskStartScheduler+0xb8>)
 8008f76:	681b      	ldr	r3, [r3, #0]
 8008f78:	2b00      	cmp	r3, #0
 8008f7a:	d002      	beq.n	8008f82 <vTaskStartScheduler+0x4a>
		{
			xReturn = pdPASS;
 8008f7c:	2301      	movs	r3, #1
 8008f7e:	617b      	str	r3, [r7, #20]
 8008f80:	e001      	b.n	8008f86 <vTaskStartScheduler+0x4e>
		}
		else
		{
			xReturn = pdFAIL;
 8008f82:	2300      	movs	r3, #0
 8008f84:	617b      	str	r3, [r7, #20]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 8008f86:	697b      	ldr	r3, [r7, #20]
 8008f88:	2b01      	cmp	r3, #1
 8008f8a:	d102      	bne.n	8008f92 <vTaskStartScheduler+0x5a>
		{
			xReturn = xTimerCreateTimerTask();
 8008f8c:	f000 fd70 	bl	8009a70 <xTimerCreateTimerTask>
 8008f90:	6178      	str	r0, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8008f92:	697b      	ldr	r3, [r7, #20]
 8008f94:	2b01      	cmp	r3, #1
 8008f96:	d115      	bne.n	8008fc4 <vTaskStartScheduler+0x8c>
 8008f98:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008f9c:	f383 8811 	msr	BASEPRI, r3
 8008fa0:	f3bf 8f6f 	isb	sy
 8008fa4:	f3bf 8f4f 	dsb	sy
 8008fa8:	613b      	str	r3, [r7, #16]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 8008faa:	4b12      	ldr	r3, [pc, #72]	; (8008ff4 <vTaskStartScheduler+0xbc>)
 8008fac:	f04f 32ff 	mov.w	r2, #4294967295
 8008fb0:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8008fb2:	4b11      	ldr	r3, [pc, #68]	; (8008ff8 <vTaskStartScheduler+0xc0>)
 8008fb4:	2201      	movs	r2, #1
 8008fb6:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8008fb8:	4b10      	ldr	r3, [pc, #64]	; (8008ffc <vTaskStartScheduler+0xc4>)
 8008fba:	2200      	movs	r2, #0
 8008fbc:	601a      	str	r2, [r3, #0]

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 8008fbe:	f001 f927 	bl	800a210 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 8008fc2:	e00d      	b.n	8008fe0 <vTaskStartScheduler+0xa8>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8008fc4:	697b      	ldr	r3, [r7, #20]
 8008fc6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008fca:	d109      	bne.n	8008fe0 <vTaskStartScheduler+0xa8>
 8008fcc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008fd0:	f383 8811 	msr	BASEPRI, r3
 8008fd4:	f3bf 8f6f 	isb	sy
 8008fd8:	f3bf 8f4f 	dsb	sy
 8008fdc:	60fb      	str	r3, [r7, #12]
 8008fde:	e7fe      	b.n	8008fde <vTaskStartScheduler+0xa6>
}
 8008fe0:	bf00      	nop
 8008fe2:	3718      	adds	r7, #24
 8008fe4:	46bd      	mov	sp, r7
 8008fe6:	bd80      	pop	{r7, pc}
 8008fe8:	08028c18 	.word	0x08028c18
 8008fec:	080096c1 	.word	0x080096c1
 8008ff0:	20000fc4 	.word	0x20000fc4
 8008ff4:	20000fc0 	.word	0x20000fc0
 8008ff8:	20000fac 	.word	0x20000fac
 8008ffc:	20000fa4 	.word	0x20000fa4

08009000 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 8009000:	b480      	push	{r7}
 8009002:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8009004:	4b04      	ldr	r3, [pc, #16]	; (8009018 <vTaskSuspendAll+0x18>)
 8009006:	681b      	ldr	r3, [r3, #0]
 8009008:	3301      	adds	r3, #1
 800900a:	4a03      	ldr	r2, [pc, #12]	; (8009018 <vTaskSuspendAll+0x18>)
 800900c:	6013      	str	r3, [r2, #0]
	portMEMORY_BARRIER();
}
 800900e:	bf00      	nop
 8009010:	46bd      	mov	sp, r7
 8009012:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009016:	4770      	bx	lr
 8009018:	20000fc8 	.word	0x20000fc8

0800901c <prvGetExpectedIdleTime>:
/*----------------------------------------------------------*/

#if ( configUSE_TICKLESS_IDLE != 0 )

	static TickType_t prvGetExpectedIdleTime( void )
	{
 800901c:	b480      	push	{r7}
 800901e:	b083      	sub	sp, #12
 8009020:	af00      	add	r7, sp, #0
	TickType_t xReturn;
	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
 8009022:	2300      	movs	r3, #0
 8009024:	603b      	str	r3, [r7, #0]
		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
		task that are in the Ready state, even though the idle task is
		running. */
		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
		{
			if( uxTopReadyPriority > tskIDLE_PRIORITY )
 8009026:	4b14      	ldr	r3, [pc, #80]	; (8009078 <prvGetExpectedIdleTime+0x5c>)
 8009028:	681b      	ldr	r3, [r3, #0]
 800902a:	2b00      	cmp	r3, #0
 800902c:	d001      	beq.n	8009032 <prvGetExpectedIdleTime+0x16>
			{
				uxHigherPriorityReadyTasks = pdTRUE;
 800902e:	2301      	movs	r3, #1
 8009030:	603b      	str	r3, [r7, #0]
				uxHigherPriorityReadyTasks = pdTRUE;
			}
		}
		#endif

		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 8009032:	4b12      	ldr	r3, [pc, #72]	; (800907c <prvGetExpectedIdleTime+0x60>)
 8009034:	681b      	ldr	r3, [r3, #0]
 8009036:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009038:	2b00      	cmp	r3, #0
 800903a:	d002      	beq.n	8009042 <prvGetExpectedIdleTime+0x26>
		{
			xReturn = 0;
 800903c:	2300      	movs	r3, #0
 800903e:	607b      	str	r3, [r7, #4]
 8009040:	e012      	b.n	8009068 <prvGetExpectedIdleTime+0x4c>
		}
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
 8009042:	4b0f      	ldr	r3, [pc, #60]	; (8009080 <prvGetExpectedIdleTime+0x64>)
 8009044:	681b      	ldr	r3, [r3, #0]
 8009046:	2b01      	cmp	r3, #1
 8009048:	d902      	bls.n	8009050 <prvGetExpectedIdleTime+0x34>
		{
			/* There are other idle priority tasks in the ready state.  If
			time slicing is used then the very next tick interrupt must be
			processed. */
			xReturn = 0;
 800904a:	2300      	movs	r3, #0
 800904c:	607b      	str	r3, [r7, #4]
 800904e:	e00b      	b.n	8009068 <prvGetExpectedIdleTime+0x4c>
		}
		else if( uxHigherPriorityReadyTasks != pdFALSE )
 8009050:	683b      	ldr	r3, [r7, #0]
 8009052:	2b00      	cmp	r3, #0
 8009054:	d002      	beq.n	800905c <prvGetExpectedIdleTime+0x40>
		{
			/* There are tasks in the Ready state that have a priority above the
			idle priority.  This path can only be reached if
			configUSE_PREEMPTION is 0. */
			xReturn = 0;
 8009056:	2300      	movs	r3, #0
 8009058:	607b      	str	r3, [r7, #4]
 800905a:	e005      	b.n	8009068 <prvGetExpectedIdleTime+0x4c>
		}
		else
		{
			xReturn = xNextTaskUnblockTime - xTickCount;
 800905c:	4b09      	ldr	r3, [pc, #36]	; (8009084 <prvGetExpectedIdleTime+0x68>)
 800905e:	681a      	ldr	r2, [r3, #0]
 8009060:	4b09      	ldr	r3, [pc, #36]	; (8009088 <prvGetExpectedIdleTime+0x6c>)
 8009062:	681b      	ldr	r3, [r3, #0]
 8009064:	1ad3      	subs	r3, r2, r3
 8009066:	607b      	str	r3, [r7, #4]
		}

		return xReturn;
 8009068:	687b      	ldr	r3, [r7, #4]
	}
 800906a:	4618      	mov	r0, r3
 800906c:	370c      	adds	r7, #12
 800906e:	46bd      	mov	sp, r7
 8009070:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009074:	4770      	bx	lr
 8009076:	bf00      	nop
 8009078:	20000fa8 	.word	0x20000fa8
 800907c:	20000acc 	.word	0x20000acc
 8009080:	20000ad0 	.word	0x20000ad0
 8009084:	20000fc0 	.word	0x20000fc0
 8009088:	20000fa4 	.word	0x20000fa4

0800908c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 800908c:	b580      	push	{r7, lr}
 800908e:	b084      	sub	sp, #16
 8009090:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
 8009092:	2300      	movs	r3, #0
 8009094:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
 8009096:	2300      	movs	r3, #0
 8009098:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 800909a:	4b41      	ldr	r3, [pc, #260]	; (80091a0 <xTaskResumeAll+0x114>)
 800909c:	681b      	ldr	r3, [r3, #0]
 800909e:	2b00      	cmp	r3, #0
 80090a0:	d109      	bne.n	80090b6 <xTaskResumeAll+0x2a>
 80090a2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80090a6:	f383 8811 	msr	BASEPRI, r3
 80090aa:	f3bf 8f6f 	isb	sy
 80090ae:	f3bf 8f4f 	dsb	sy
 80090b2:	603b      	str	r3, [r7, #0]
 80090b4:	e7fe      	b.n	80090b4 <xTaskResumeAll+0x28>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 80090b6:	f001 f949 	bl	800a34c <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 80090ba:	4b39      	ldr	r3, [pc, #228]	; (80091a0 <xTaskResumeAll+0x114>)
 80090bc:	681b      	ldr	r3, [r3, #0]
 80090be:	3b01      	subs	r3, #1
 80090c0:	4a37      	ldr	r2, [pc, #220]	; (80091a0 <xTaskResumeAll+0x114>)
 80090c2:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80090c4:	4b36      	ldr	r3, [pc, #216]	; (80091a0 <xTaskResumeAll+0x114>)
 80090c6:	681b      	ldr	r3, [r3, #0]
 80090c8:	2b00      	cmp	r3, #0
 80090ca:	d162      	bne.n	8009192 <xTaskResumeAll+0x106>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 80090cc:	4b35      	ldr	r3, [pc, #212]	; (80091a4 <xTaskResumeAll+0x118>)
 80090ce:	681b      	ldr	r3, [r3, #0]
 80090d0:	2b00      	cmp	r3, #0
 80090d2:	d05e      	beq.n	8009192 <xTaskResumeAll+0x106>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80090d4:	e02f      	b.n	8009136 <xTaskResumeAll+0xaa>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80090d6:	4b34      	ldr	r3, [pc, #208]	; (80091a8 <xTaskResumeAll+0x11c>)
 80090d8:	68db      	ldr	r3, [r3, #12]
 80090da:	68db      	ldr	r3, [r3, #12]
 80090dc:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80090de:	68fb      	ldr	r3, [r7, #12]
 80090e0:	3318      	adds	r3, #24
 80090e2:	4618      	mov	r0, r3
 80090e4:	f7fe fe82 	bl	8007dec <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80090e8:	68fb      	ldr	r3, [r7, #12]
 80090ea:	3304      	adds	r3, #4
 80090ec:	4618      	mov	r0, r3
 80090ee:	f7fe fe7d 	bl	8007dec <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80090f2:	68fb      	ldr	r3, [r7, #12]
 80090f4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80090f6:	4b2d      	ldr	r3, [pc, #180]	; (80091ac <xTaskResumeAll+0x120>)
 80090f8:	681b      	ldr	r3, [r3, #0]
 80090fa:	429a      	cmp	r2, r3
 80090fc:	d903      	bls.n	8009106 <xTaskResumeAll+0x7a>
 80090fe:	68fb      	ldr	r3, [r7, #12]
 8009100:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009102:	4a2a      	ldr	r2, [pc, #168]	; (80091ac <xTaskResumeAll+0x120>)
 8009104:	6013      	str	r3, [r2, #0]
 8009106:	68fb      	ldr	r3, [r7, #12]
 8009108:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800910a:	4613      	mov	r3, r2
 800910c:	009b      	lsls	r3, r3, #2
 800910e:	4413      	add	r3, r2
 8009110:	009b      	lsls	r3, r3, #2
 8009112:	4a27      	ldr	r2, [pc, #156]	; (80091b0 <xTaskResumeAll+0x124>)
 8009114:	441a      	add	r2, r3
 8009116:	68fb      	ldr	r3, [r7, #12]
 8009118:	3304      	adds	r3, #4
 800911a:	4619      	mov	r1, r3
 800911c:	4610      	mov	r0, r2
 800911e:	f7fe fe08 	bl	8007d32 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8009122:	68fb      	ldr	r3, [r7, #12]
 8009124:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009126:	4b23      	ldr	r3, [pc, #140]	; (80091b4 <xTaskResumeAll+0x128>)
 8009128:	681b      	ldr	r3, [r3, #0]
 800912a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800912c:	429a      	cmp	r2, r3
 800912e:	d302      	bcc.n	8009136 <xTaskResumeAll+0xaa>
					{
						xYieldPending = pdTRUE;
 8009130:	4b21      	ldr	r3, [pc, #132]	; (80091b8 <xTaskResumeAll+0x12c>)
 8009132:	2201      	movs	r2, #1
 8009134:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8009136:	4b1c      	ldr	r3, [pc, #112]	; (80091a8 <xTaskResumeAll+0x11c>)
 8009138:	681b      	ldr	r3, [r3, #0]
 800913a:	2b00      	cmp	r3, #0
 800913c:	d1cb      	bne.n	80090d6 <xTaskResumeAll+0x4a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 800913e:	68fb      	ldr	r3, [r7, #12]
 8009140:	2b00      	cmp	r3, #0
 8009142:	d001      	beq.n	8009148 <xTaskResumeAll+0xbc>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 8009144:	f000 fb96 	bl	8009874 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8009148:	4b1c      	ldr	r3, [pc, #112]	; (80091bc <xTaskResumeAll+0x130>)
 800914a:	681b      	ldr	r3, [r3, #0]
 800914c:	607b      	str	r3, [r7, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 800914e:	687b      	ldr	r3, [r7, #4]
 8009150:	2b00      	cmp	r3, #0
 8009152:	d010      	beq.n	8009176 <xTaskResumeAll+0xea>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 8009154:	f000 f846 	bl	80091e4 <xTaskIncrementTick>
 8009158:	4603      	mov	r3, r0
 800915a:	2b00      	cmp	r3, #0
 800915c:	d002      	beq.n	8009164 <xTaskResumeAll+0xd8>
							{
								xYieldPending = pdTRUE;
 800915e:	4b16      	ldr	r3, [pc, #88]	; (80091b8 <xTaskResumeAll+0x12c>)
 8009160:	2201      	movs	r2, #1
 8009162:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
 8009164:	687b      	ldr	r3, [r7, #4]
 8009166:	3b01      	subs	r3, #1
 8009168:	607b      	str	r3, [r7, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 800916a:	687b      	ldr	r3, [r7, #4]
 800916c:	2b00      	cmp	r3, #0
 800916e:	d1f1      	bne.n	8009154 <xTaskResumeAll+0xc8>

						uxPendedTicks = 0;
 8009170:	4b12      	ldr	r3, [pc, #72]	; (80091bc <xTaskResumeAll+0x130>)
 8009172:	2200      	movs	r2, #0
 8009174:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 8009176:	4b10      	ldr	r3, [pc, #64]	; (80091b8 <xTaskResumeAll+0x12c>)
 8009178:	681b      	ldr	r3, [r3, #0]
 800917a:	2b00      	cmp	r3, #0
 800917c:	d009      	beq.n	8009192 <xTaskResumeAll+0x106>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 800917e:	2301      	movs	r3, #1
 8009180:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 8009182:	4b0f      	ldr	r3, [pc, #60]	; (80091c0 <xTaskResumeAll+0x134>)
 8009184:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009188:	601a      	str	r2, [r3, #0]
 800918a:	f3bf 8f4f 	dsb	sy
 800918e:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8009192:	f001 f909 	bl	800a3a8 <vPortExitCritical>

	return xAlreadyYielded;
 8009196:	68bb      	ldr	r3, [r7, #8]
}
 8009198:	4618      	mov	r0, r3
 800919a:	3710      	adds	r7, #16
 800919c:	46bd      	mov	sp, r7
 800919e:	bd80      	pop	{r7, pc}
 80091a0:	20000fc8 	.word	0x20000fc8
 80091a4:	20000fa0 	.word	0x20000fa0
 80091a8:	20000f60 	.word	0x20000f60
 80091ac:	20000fa8 	.word	0x20000fa8
 80091b0:	20000ad0 	.word	0x20000ad0
 80091b4:	20000acc 	.word	0x20000acc
 80091b8:	20000fb4 	.word	0x20000fb4
 80091bc:	20000fb0 	.word	0x20000fb0
 80091c0:	e000ed04 	.word	0xe000ed04

080091c4 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 80091c4:	b480      	push	{r7}
 80091c6:	b083      	sub	sp, #12
 80091c8:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 80091ca:	4b05      	ldr	r3, [pc, #20]	; (80091e0 <xTaskGetTickCount+0x1c>)
 80091cc:	681b      	ldr	r3, [r3, #0]
 80091ce:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 80091d0:	687b      	ldr	r3, [r7, #4]
}
 80091d2:	4618      	mov	r0, r3
 80091d4:	370c      	adds	r7, #12
 80091d6:	46bd      	mov	sp, r7
 80091d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80091dc:	4770      	bx	lr
 80091de:	bf00      	nop
 80091e0:	20000fa4 	.word	0x20000fa4

080091e4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 80091e4:	b580      	push	{r7, lr}
 80091e6:	b086      	sub	sp, #24
 80091e8:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 80091ea:	2300      	movs	r3, #0
 80091ec:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80091ee:	4b4e      	ldr	r3, [pc, #312]	; (8009328 <xTaskIncrementTick+0x144>)
 80091f0:	681b      	ldr	r3, [r3, #0]
 80091f2:	2b00      	cmp	r3, #0
 80091f4:	f040 8088 	bne.w	8009308 <xTaskIncrementTick+0x124>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 80091f8:	4b4c      	ldr	r3, [pc, #304]	; (800932c <xTaskIncrementTick+0x148>)
 80091fa:	681b      	ldr	r3, [r3, #0]
 80091fc:	3301      	adds	r3, #1
 80091fe:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 8009200:	4a4a      	ldr	r2, [pc, #296]	; (800932c <xTaskIncrementTick+0x148>)
 8009202:	693b      	ldr	r3, [r7, #16]
 8009204:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8009206:	693b      	ldr	r3, [r7, #16]
 8009208:	2b00      	cmp	r3, #0
 800920a:	d11f      	bne.n	800924c <xTaskIncrementTick+0x68>
		{
			taskSWITCH_DELAYED_LISTS();
 800920c:	4b48      	ldr	r3, [pc, #288]	; (8009330 <xTaskIncrementTick+0x14c>)
 800920e:	681b      	ldr	r3, [r3, #0]
 8009210:	681b      	ldr	r3, [r3, #0]
 8009212:	2b00      	cmp	r3, #0
 8009214:	d009      	beq.n	800922a <xTaskIncrementTick+0x46>
 8009216:	f04f 0350 	mov.w	r3, #80	; 0x50
 800921a:	f383 8811 	msr	BASEPRI, r3
 800921e:	f3bf 8f6f 	isb	sy
 8009222:	f3bf 8f4f 	dsb	sy
 8009226:	603b      	str	r3, [r7, #0]
 8009228:	e7fe      	b.n	8009228 <xTaskIncrementTick+0x44>
 800922a:	4b41      	ldr	r3, [pc, #260]	; (8009330 <xTaskIncrementTick+0x14c>)
 800922c:	681b      	ldr	r3, [r3, #0]
 800922e:	60fb      	str	r3, [r7, #12]
 8009230:	4b40      	ldr	r3, [pc, #256]	; (8009334 <xTaskIncrementTick+0x150>)
 8009232:	681b      	ldr	r3, [r3, #0]
 8009234:	4a3e      	ldr	r2, [pc, #248]	; (8009330 <xTaskIncrementTick+0x14c>)
 8009236:	6013      	str	r3, [r2, #0]
 8009238:	4a3e      	ldr	r2, [pc, #248]	; (8009334 <xTaskIncrementTick+0x150>)
 800923a:	68fb      	ldr	r3, [r7, #12]
 800923c:	6013      	str	r3, [r2, #0]
 800923e:	4b3e      	ldr	r3, [pc, #248]	; (8009338 <xTaskIncrementTick+0x154>)
 8009240:	681b      	ldr	r3, [r3, #0]
 8009242:	3301      	adds	r3, #1
 8009244:	4a3c      	ldr	r2, [pc, #240]	; (8009338 <xTaskIncrementTick+0x154>)
 8009246:	6013      	str	r3, [r2, #0]
 8009248:	f000 fb14 	bl	8009874 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 800924c:	4b3b      	ldr	r3, [pc, #236]	; (800933c <xTaskIncrementTick+0x158>)
 800924e:	681b      	ldr	r3, [r3, #0]
 8009250:	693a      	ldr	r2, [r7, #16]
 8009252:	429a      	cmp	r2, r3
 8009254:	d349      	bcc.n	80092ea <xTaskIncrementTick+0x106>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8009256:	4b36      	ldr	r3, [pc, #216]	; (8009330 <xTaskIncrementTick+0x14c>)
 8009258:	681b      	ldr	r3, [r3, #0]
 800925a:	681b      	ldr	r3, [r3, #0]
 800925c:	2b00      	cmp	r3, #0
 800925e:	d104      	bne.n	800926a <xTaskIncrementTick+0x86>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009260:	4b36      	ldr	r3, [pc, #216]	; (800933c <xTaskIncrementTick+0x158>)
 8009262:	f04f 32ff 	mov.w	r2, #4294967295
 8009266:	601a      	str	r2, [r3, #0]
					break;
 8009268:	e03f      	b.n	80092ea <xTaskIncrementTick+0x106>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800926a:	4b31      	ldr	r3, [pc, #196]	; (8009330 <xTaskIncrementTick+0x14c>)
 800926c:	681b      	ldr	r3, [r3, #0]
 800926e:	68db      	ldr	r3, [r3, #12]
 8009270:	68db      	ldr	r3, [r3, #12]
 8009272:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8009274:	68bb      	ldr	r3, [r7, #8]
 8009276:	685b      	ldr	r3, [r3, #4]
 8009278:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
 800927a:	693a      	ldr	r2, [r7, #16]
 800927c:	687b      	ldr	r3, [r7, #4]
 800927e:	429a      	cmp	r2, r3
 8009280:	d203      	bcs.n	800928a <xTaskIncrementTick+0xa6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 8009282:	4a2e      	ldr	r2, [pc, #184]	; (800933c <xTaskIncrementTick+0x158>)
 8009284:	687b      	ldr	r3, [r7, #4]
 8009286:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 8009288:	e02f      	b.n	80092ea <xTaskIncrementTick+0x106>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800928a:	68bb      	ldr	r3, [r7, #8]
 800928c:	3304      	adds	r3, #4
 800928e:	4618      	mov	r0, r3
 8009290:	f7fe fdac 	bl	8007dec <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8009294:	68bb      	ldr	r3, [r7, #8]
 8009296:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009298:	2b00      	cmp	r3, #0
 800929a:	d004      	beq.n	80092a6 <xTaskIncrementTick+0xc2>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800929c:	68bb      	ldr	r3, [r7, #8]
 800929e:	3318      	adds	r3, #24
 80092a0:	4618      	mov	r0, r3
 80092a2:	f7fe fda3 	bl	8007dec <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 80092a6:	68bb      	ldr	r3, [r7, #8]
 80092a8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80092aa:	4b25      	ldr	r3, [pc, #148]	; (8009340 <xTaskIncrementTick+0x15c>)
 80092ac:	681b      	ldr	r3, [r3, #0]
 80092ae:	429a      	cmp	r2, r3
 80092b0:	d903      	bls.n	80092ba <xTaskIncrementTick+0xd6>
 80092b2:	68bb      	ldr	r3, [r7, #8]
 80092b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80092b6:	4a22      	ldr	r2, [pc, #136]	; (8009340 <xTaskIncrementTick+0x15c>)
 80092b8:	6013      	str	r3, [r2, #0]
 80092ba:	68bb      	ldr	r3, [r7, #8]
 80092bc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80092be:	4613      	mov	r3, r2
 80092c0:	009b      	lsls	r3, r3, #2
 80092c2:	4413      	add	r3, r2
 80092c4:	009b      	lsls	r3, r3, #2
 80092c6:	4a1f      	ldr	r2, [pc, #124]	; (8009344 <xTaskIncrementTick+0x160>)
 80092c8:	441a      	add	r2, r3
 80092ca:	68bb      	ldr	r3, [r7, #8]
 80092cc:	3304      	adds	r3, #4
 80092ce:	4619      	mov	r1, r3
 80092d0:	4610      	mov	r0, r2
 80092d2:	f7fe fd2e 	bl	8007d32 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80092d6:	68bb      	ldr	r3, [r7, #8]
 80092d8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80092da:	4b1b      	ldr	r3, [pc, #108]	; (8009348 <xTaskIncrementTick+0x164>)
 80092dc:	681b      	ldr	r3, [r3, #0]
 80092de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80092e0:	429a      	cmp	r2, r3
 80092e2:	d3b8      	bcc.n	8009256 <xTaskIncrementTick+0x72>
						{
							xSwitchRequired = pdTRUE;
 80092e4:	2301      	movs	r3, #1
 80092e6:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80092e8:	e7b5      	b.n	8009256 <xTaskIncrementTick+0x72>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80092ea:	4b17      	ldr	r3, [pc, #92]	; (8009348 <xTaskIncrementTick+0x164>)
 80092ec:	681b      	ldr	r3, [r3, #0]
 80092ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80092f0:	4914      	ldr	r1, [pc, #80]	; (8009344 <xTaskIncrementTick+0x160>)
 80092f2:	4613      	mov	r3, r2
 80092f4:	009b      	lsls	r3, r3, #2
 80092f6:	4413      	add	r3, r2
 80092f8:	009b      	lsls	r3, r3, #2
 80092fa:	440b      	add	r3, r1
 80092fc:	681b      	ldr	r3, [r3, #0]
 80092fe:	2b01      	cmp	r3, #1
 8009300:	d907      	bls.n	8009312 <xTaskIncrementTick+0x12e>
			{
				xSwitchRequired = pdTRUE;
 8009302:	2301      	movs	r3, #1
 8009304:	617b      	str	r3, [r7, #20]
 8009306:	e004      	b.n	8009312 <xTaskIncrementTick+0x12e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 8009308:	4b10      	ldr	r3, [pc, #64]	; (800934c <xTaskIncrementTick+0x168>)
 800930a:	681b      	ldr	r3, [r3, #0]
 800930c:	3301      	adds	r3, #1
 800930e:	4a0f      	ldr	r2, [pc, #60]	; (800934c <xTaskIncrementTick+0x168>)
 8009310:	6013      	str	r3, [r2, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8009312:	4b0f      	ldr	r3, [pc, #60]	; (8009350 <xTaskIncrementTick+0x16c>)
 8009314:	681b      	ldr	r3, [r3, #0]
 8009316:	2b00      	cmp	r3, #0
 8009318:	d001      	beq.n	800931e <xTaskIncrementTick+0x13a>
		{
			xSwitchRequired = pdTRUE;
 800931a:	2301      	movs	r3, #1
 800931c:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
 800931e:	697b      	ldr	r3, [r7, #20]
}
 8009320:	4618      	mov	r0, r3
 8009322:	3718      	adds	r7, #24
 8009324:	46bd      	mov	sp, r7
 8009326:	bd80      	pop	{r7, pc}
 8009328:	20000fc8 	.word	0x20000fc8
 800932c:	20000fa4 	.word	0x20000fa4
 8009330:	20000f58 	.word	0x20000f58
 8009334:	20000f5c 	.word	0x20000f5c
 8009338:	20000fb8 	.word	0x20000fb8
 800933c:	20000fc0 	.word	0x20000fc0
 8009340:	20000fa8 	.word	0x20000fa8
 8009344:	20000ad0 	.word	0x20000ad0
 8009348:	20000acc 	.word	0x20000acc
 800934c:	20000fb0 	.word	0x20000fb0
 8009350:	20000fb4 	.word	0x20000fb4

08009354 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8009354:	b580      	push	{r7, lr}
 8009356:	b086      	sub	sp, #24
 8009358:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800935a:	4b3a      	ldr	r3, [pc, #232]	; (8009444 <vTaskSwitchContext+0xf0>)
 800935c:	681b      	ldr	r3, [r3, #0]
 800935e:	2b00      	cmp	r3, #0
 8009360:	d003      	beq.n	800936a <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 8009362:	4b39      	ldr	r3, [pc, #228]	; (8009448 <vTaskSwitchContext+0xf4>)
 8009364:	2201      	movs	r2, #1
 8009366:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 8009368:	e067      	b.n	800943a <vTaskSwitchContext+0xe6>
		xYieldPending = pdFALSE;
 800936a:	4b37      	ldr	r3, [pc, #220]	; (8009448 <vTaskSwitchContext+0xf4>)
 800936c:	2200      	movs	r2, #0
 800936e:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
 8009370:	4b36      	ldr	r3, [pc, #216]	; (800944c <vTaskSwitchContext+0xf8>)
 8009372:	681b      	ldr	r3, [r3, #0]
 8009374:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009376:	613b      	str	r3, [r7, #16]
 8009378:	f04f 33a5 	mov.w	r3, #2779096485	; 0xa5a5a5a5
 800937c:	60fb      	str	r3, [r7, #12]
 800937e:	693b      	ldr	r3, [r7, #16]
 8009380:	681b      	ldr	r3, [r3, #0]
 8009382:	68fa      	ldr	r2, [r7, #12]
 8009384:	429a      	cmp	r2, r3
 8009386:	d111      	bne.n	80093ac <vTaskSwitchContext+0x58>
 8009388:	693b      	ldr	r3, [r7, #16]
 800938a:	3304      	adds	r3, #4
 800938c:	681b      	ldr	r3, [r3, #0]
 800938e:	68fa      	ldr	r2, [r7, #12]
 8009390:	429a      	cmp	r2, r3
 8009392:	d10b      	bne.n	80093ac <vTaskSwitchContext+0x58>
 8009394:	693b      	ldr	r3, [r7, #16]
 8009396:	3308      	adds	r3, #8
 8009398:	681b      	ldr	r3, [r3, #0]
 800939a:	68fa      	ldr	r2, [r7, #12]
 800939c:	429a      	cmp	r2, r3
 800939e:	d105      	bne.n	80093ac <vTaskSwitchContext+0x58>
 80093a0:	693b      	ldr	r3, [r7, #16]
 80093a2:	330c      	adds	r3, #12
 80093a4:	681b      	ldr	r3, [r3, #0]
 80093a6:	68fa      	ldr	r2, [r7, #12]
 80093a8:	429a      	cmp	r2, r3
 80093aa:	d008      	beq.n	80093be <vTaskSwitchContext+0x6a>
 80093ac:	4b27      	ldr	r3, [pc, #156]	; (800944c <vTaskSwitchContext+0xf8>)
 80093ae:	681a      	ldr	r2, [r3, #0]
 80093b0:	4b26      	ldr	r3, [pc, #152]	; (800944c <vTaskSwitchContext+0xf8>)
 80093b2:	681b      	ldr	r3, [r3, #0]
 80093b4:	3334      	adds	r3, #52	; 0x34
 80093b6:	4619      	mov	r1, r3
 80093b8:	4610      	mov	r0, r2
 80093ba:	f7f7 f918 	bl	80005ee <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80093be:	4b24      	ldr	r3, [pc, #144]	; (8009450 <vTaskSwitchContext+0xfc>)
 80093c0:	681b      	ldr	r3, [r3, #0]
 80093c2:	617b      	str	r3, [r7, #20]
 80093c4:	e00f      	b.n	80093e6 <vTaskSwitchContext+0x92>
 80093c6:	697b      	ldr	r3, [r7, #20]
 80093c8:	2b00      	cmp	r3, #0
 80093ca:	d109      	bne.n	80093e0 <vTaskSwitchContext+0x8c>
 80093cc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80093d0:	f383 8811 	msr	BASEPRI, r3
 80093d4:	f3bf 8f6f 	isb	sy
 80093d8:	f3bf 8f4f 	dsb	sy
 80093dc:	607b      	str	r3, [r7, #4]
 80093de:	e7fe      	b.n	80093de <vTaskSwitchContext+0x8a>
 80093e0:	697b      	ldr	r3, [r7, #20]
 80093e2:	3b01      	subs	r3, #1
 80093e4:	617b      	str	r3, [r7, #20]
 80093e6:	491b      	ldr	r1, [pc, #108]	; (8009454 <vTaskSwitchContext+0x100>)
 80093e8:	697a      	ldr	r2, [r7, #20]
 80093ea:	4613      	mov	r3, r2
 80093ec:	009b      	lsls	r3, r3, #2
 80093ee:	4413      	add	r3, r2
 80093f0:	009b      	lsls	r3, r3, #2
 80093f2:	440b      	add	r3, r1
 80093f4:	681b      	ldr	r3, [r3, #0]
 80093f6:	2b00      	cmp	r3, #0
 80093f8:	d0e5      	beq.n	80093c6 <vTaskSwitchContext+0x72>
 80093fa:	697a      	ldr	r2, [r7, #20]
 80093fc:	4613      	mov	r3, r2
 80093fe:	009b      	lsls	r3, r3, #2
 8009400:	4413      	add	r3, r2
 8009402:	009b      	lsls	r3, r3, #2
 8009404:	4a13      	ldr	r2, [pc, #76]	; (8009454 <vTaskSwitchContext+0x100>)
 8009406:	4413      	add	r3, r2
 8009408:	60bb      	str	r3, [r7, #8]
 800940a:	68bb      	ldr	r3, [r7, #8]
 800940c:	685b      	ldr	r3, [r3, #4]
 800940e:	685a      	ldr	r2, [r3, #4]
 8009410:	68bb      	ldr	r3, [r7, #8]
 8009412:	605a      	str	r2, [r3, #4]
 8009414:	68bb      	ldr	r3, [r7, #8]
 8009416:	685a      	ldr	r2, [r3, #4]
 8009418:	68bb      	ldr	r3, [r7, #8]
 800941a:	3308      	adds	r3, #8
 800941c:	429a      	cmp	r2, r3
 800941e:	d104      	bne.n	800942a <vTaskSwitchContext+0xd6>
 8009420:	68bb      	ldr	r3, [r7, #8]
 8009422:	685b      	ldr	r3, [r3, #4]
 8009424:	685a      	ldr	r2, [r3, #4]
 8009426:	68bb      	ldr	r3, [r7, #8]
 8009428:	605a      	str	r2, [r3, #4]
 800942a:	68bb      	ldr	r3, [r7, #8]
 800942c:	685b      	ldr	r3, [r3, #4]
 800942e:	68db      	ldr	r3, [r3, #12]
 8009430:	4a06      	ldr	r2, [pc, #24]	; (800944c <vTaskSwitchContext+0xf8>)
 8009432:	6013      	str	r3, [r2, #0]
 8009434:	4a06      	ldr	r2, [pc, #24]	; (8009450 <vTaskSwitchContext+0xfc>)
 8009436:	697b      	ldr	r3, [r7, #20]
 8009438:	6013      	str	r3, [r2, #0]
}
 800943a:	bf00      	nop
 800943c:	3718      	adds	r7, #24
 800943e:	46bd      	mov	sp, r7
 8009440:	bd80      	pop	{r7, pc}
 8009442:	bf00      	nop
 8009444:	20000fc8 	.word	0x20000fc8
 8009448:	20000fb4 	.word	0x20000fb4
 800944c:	20000acc 	.word	0x20000acc
 8009450:	20000fa8 	.word	0x20000fa8
 8009454:	20000ad0 	.word	0x20000ad0

08009458 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 8009458:	b580      	push	{r7, lr}
 800945a:	b084      	sub	sp, #16
 800945c:	af00      	add	r7, sp, #0
 800945e:	6078      	str	r0, [r7, #4]
 8009460:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
 8009462:	687b      	ldr	r3, [r7, #4]
 8009464:	2b00      	cmp	r3, #0
 8009466:	d109      	bne.n	800947c <vTaskPlaceOnEventList+0x24>
 8009468:	f04f 0350 	mov.w	r3, #80	; 0x50
 800946c:	f383 8811 	msr	BASEPRI, r3
 8009470:	f3bf 8f6f 	isb	sy
 8009474:	f3bf 8f4f 	dsb	sy
 8009478:	60fb      	str	r3, [r7, #12]
 800947a:	e7fe      	b.n	800947a <vTaskPlaceOnEventList+0x22>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800947c:	4b07      	ldr	r3, [pc, #28]	; (800949c <vTaskPlaceOnEventList+0x44>)
 800947e:	681b      	ldr	r3, [r3, #0]
 8009480:	3318      	adds	r3, #24
 8009482:	4619      	mov	r1, r3
 8009484:	6878      	ldr	r0, [r7, #4]
 8009486:	f7fe fc78 	bl	8007d7a <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800948a:	2101      	movs	r1, #1
 800948c:	6838      	ldr	r0, [r7, #0]
 800948e:	f000 fa9b 	bl	80099c8 <prvAddCurrentTaskToDelayedList>
}
 8009492:	bf00      	nop
 8009494:	3710      	adds	r7, #16
 8009496:	46bd      	mov	sp, r7
 8009498:	bd80      	pop	{r7, pc}
 800949a:	bf00      	nop
 800949c:	20000acc 	.word	0x20000acc

080094a0 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 80094a0:	b580      	push	{r7, lr}
 80094a2:	b086      	sub	sp, #24
 80094a4:	af00      	add	r7, sp, #0
 80094a6:	60f8      	str	r0, [r7, #12]
 80094a8:	60b9      	str	r1, [r7, #8]
 80094aa:	607a      	str	r2, [r7, #4]
		configASSERT( pxEventList );
 80094ac:	68fb      	ldr	r3, [r7, #12]
 80094ae:	2b00      	cmp	r3, #0
 80094b0:	d109      	bne.n	80094c6 <vTaskPlaceOnEventListRestricted+0x26>
 80094b2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80094b6:	f383 8811 	msr	BASEPRI, r3
 80094ba:	f3bf 8f6f 	isb	sy
 80094be:	f3bf 8f4f 	dsb	sy
 80094c2:	617b      	str	r3, [r7, #20]
 80094c4:	e7fe      	b.n	80094c4 <vTaskPlaceOnEventListRestricted+0x24>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80094c6:	4b0a      	ldr	r3, [pc, #40]	; (80094f0 <vTaskPlaceOnEventListRestricted+0x50>)
 80094c8:	681b      	ldr	r3, [r3, #0]
 80094ca:	3318      	adds	r3, #24
 80094cc:	4619      	mov	r1, r3
 80094ce:	68f8      	ldr	r0, [r7, #12]
 80094d0:	f7fe fc2f 	bl	8007d32 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
 80094d4:	687b      	ldr	r3, [r7, #4]
 80094d6:	2b00      	cmp	r3, #0
 80094d8:	d002      	beq.n	80094e0 <vTaskPlaceOnEventListRestricted+0x40>
		{
			xTicksToWait = portMAX_DELAY;
 80094da:	f04f 33ff 	mov.w	r3, #4294967295
 80094de:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 80094e0:	6879      	ldr	r1, [r7, #4]
 80094e2:	68b8      	ldr	r0, [r7, #8]
 80094e4:	f000 fa70 	bl	80099c8 <prvAddCurrentTaskToDelayedList>
	}
 80094e8:	bf00      	nop
 80094ea:	3718      	adds	r7, #24
 80094ec:	46bd      	mov	sp, r7
 80094ee:	bd80      	pop	{r7, pc}
 80094f0:	20000acc 	.word	0x20000acc

080094f4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 80094f4:	b580      	push	{r7, lr}
 80094f6:	b086      	sub	sp, #24
 80094f8:	af00      	add	r7, sp, #0
 80094fa:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80094fc:	687b      	ldr	r3, [r7, #4]
 80094fe:	68db      	ldr	r3, [r3, #12]
 8009500:	68db      	ldr	r3, [r3, #12]
 8009502:	613b      	str	r3, [r7, #16]
	configASSERT( pxUnblockedTCB );
 8009504:	693b      	ldr	r3, [r7, #16]
 8009506:	2b00      	cmp	r3, #0
 8009508:	d109      	bne.n	800951e <xTaskRemoveFromEventList+0x2a>
 800950a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800950e:	f383 8811 	msr	BASEPRI, r3
 8009512:	f3bf 8f6f 	isb	sy
 8009516:	f3bf 8f4f 	dsb	sy
 800951a:	60fb      	str	r3, [r7, #12]
 800951c:	e7fe      	b.n	800951c <xTaskRemoveFromEventList+0x28>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800951e:	693b      	ldr	r3, [r7, #16]
 8009520:	3318      	adds	r3, #24
 8009522:	4618      	mov	r0, r3
 8009524:	f7fe fc62 	bl	8007dec <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8009528:	4b1e      	ldr	r3, [pc, #120]	; (80095a4 <xTaskRemoveFromEventList+0xb0>)
 800952a:	681b      	ldr	r3, [r3, #0]
 800952c:	2b00      	cmp	r3, #0
 800952e:	d11f      	bne.n	8009570 <xTaskRemoveFromEventList+0x7c>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8009530:	693b      	ldr	r3, [r7, #16]
 8009532:	3304      	adds	r3, #4
 8009534:	4618      	mov	r0, r3
 8009536:	f7fe fc59 	bl	8007dec <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800953a:	693b      	ldr	r3, [r7, #16]
 800953c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800953e:	4b1a      	ldr	r3, [pc, #104]	; (80095a8 <xTaskRemoveFromEventList+0xb4>)
 8009540:	681b      	ldr	r3, [r3, #0]
 8009542:	429a      	cmp	r2, r3
 8009544:	d903      	bls.n	800954e <xTaskRemoveFromEventList+0x5a>
 8009546:	693b      	ldr	r3, [r7, #16]
 8009548:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800954a:	4a17      	ldr	r2, [pc, #92]	; (80095a8 <xTaskRemoveFromEventList+0xb4>)
 800954c:	6013      	str	r3, [r2, #0]
 800954e:	693b      	ldr	r3, [r7, #16]
 8009550:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009552:	4613      	mov	r3, r2
 8009554:	009b      	lsls	r3, r3, #2
 8009556:	4413      	add	r3, r2
 8009558:	009b      	lsls	r3, r3, #2
 800955a:	4a14      	ldr	r2, [pc, #80]	; (80095ac <xTaskRemoveFromEventList+0xb8>)
 800955c:	441a      	add	r2, r3
 800955e:	693b      	ldr	r3, [r7, #16]
 8009560:	3304      	adds	r3, #4
 8009562:	4619      	mov	r1, r3
 8009564:	4610      	mov	r0, r2
 8009566:	f7fe fbe4 	bl	8007d32 <vListInsertEnd>
			normally left unchanged, because it is automatically reset to a new
			value when the tick count equals xNextTaskUnblockTime.  However if
			tickless idling is used it might be more important to enter sleep mode
			at the earliest possible time - so reset xNextTaskUnblockTime here to
			ensure it is updated at the earliest possible time. */
			prvResetNextTaskUnblockTime();
 800956a:	f000 f983 	bl	8009874 <prvResetNextTaskUnblockTime>
 800956e:	e005      	b.n	800957c <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8009570:	693b      	ldr	r3, [r7, #16]
 8009572:	3318      	adds	r3, #24
 8009574:	4619      	mov	r1, r3
 8009576:	480e      	ldr	r0, [pc, #56]	; (80095b0 <xTaskRemoveFromEventList+0xbc>)
 8009578:	f7fe fbdb 	bl	8007d32 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800957c:	693b      	ldr	r3, [r7, #16]
 800957e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009580:	4b0c      	ldr	r3, [pc, #48]	; (80095b4 <xTaskRemoveFromEventList+0xc0>)
 8009582:	681b      	ldr	r3, [r3, #0]
 8009584:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009586:	429a      	cmp	r2, r3
 8009588:	d905      	bls.n	8009596 <xTaskRemoveFromEventList+0xa2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 800958a:	2301      	movs	r3, #1
 800958c:	617b      	str	r3, [r7, #20]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 800958e:	4b0a      	ldr	r3, [pc, #40]	; (80095b8 <xTaskRemoveFromEventList+0xc4>)
 8009590:	2201      	movs	r2, #1
 8009592:	601a      	str	r2, [r3, #0]
 8009594:	e001      	b.n	800959a <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
 8009596:	2300      	movs	r3, #0
 8009598:	617b      	str	r3, [r7, #20]
	}

	return xReturn;
 800959a:	697b      	ldr	r3, [r7, #20]
}
 800959c:	4618      	mov	r0, r3
 800959e:	3718      	adds	r7, #24
 80095a0:	46bd      	mov	sp, r7
 80095a2:	bd80      	pop	{r7, pc}
 80095a4:	20000fc8 	.word	0x20000fc8
 80095a8:	20000fa8 	.word	0x20000fa8
 80095ac:	20000ad0 	.word	0x20000ad0
 80095b0:	20000f60 	.word	0x20000f60
 80095b4:	20000acc 	.word	0x20000acc
 80095b8:	20000fb4 	.word	0x20000fb4

080095bc <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 80095bc:	b480      	push	{r7}
 80095be:	b083      	sub	sp, #12
 80095c0:	af00      	add	r7, sp, #0
 80095c2:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80095c4:	4b06      	ldr	r3, [pc, #24]	; (80095e0 <vTaskInternalSetTimeOutState+0x24>)
 80095c6:	681a      	ldr	r2, [r3, #0]
 80095c8:	687b      	ldr	r3, [r7, #4]
 80095ca:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80095cc:	4b05      	ldr	r3, [pc, #20]	; (80095e4 <vTaskInternalSetTimeOutState+0x28>)
 80095ce:	681a      	ldr	r2, [r3, #0]
 80095d0:	687b      	ldr	r3, [r7, #4]
 80095d2:	605a      	str	r2, [r3, #4]
}
 80095d4:	bf00      	nop
 80095d6:	370c      	adds	r7, #12
 80095d8:	46bd      	mov	sp, r7
 80095da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80095de:	4770      	bx	lr
 80095e0:	20000fb8 	.word	0x20000fb8
 80095e4:	20000fa4 	.word	0x20000fa4

080095e8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 80095e8:	b580      	push	{r7, lr}
 80095ea:	b088      	sub	sp, #32
 80095ec:	af00      	add	r7, sp, #0
 80095ee:	6078      	str	r0, [r7, #4]
 80095f0:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
 80095f2:	687b      	ldr	r3, [r7, #4]
 80095f4:	2b00      	cmp	r3, #0
 80095f6:	d109      	bne.n	800960c <xTaskCheckForTimeOut+0x24>
 80095f8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80095fc:	f383 8811 	msr	BASEPRI, r3
 8009600:	f3bf 8f6f 	isb	sy
 8009604:	f3bf 8f4f 	dsb	sy
 8009608:	613b      	str	r3, [r7, #16]
 800960a:	e7fe      	b.n	800960a <xTaskCheckForTimeOut+0x22>
	configASSERT( pxTicksToWait );
 800960c:	683b      	ldr	r3, [r7, #0]
 800960e:	2b00      	cmp	r3, #0
 8009610:	d109      	bne.n	8009626 <xTaskCheckForTimeOut+0x3e>
 8009612:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009616:	f383 8811 	msr	BASEPRI, r3
 800961a:	f3bf 8f6f 	isb	sy
 800961e:	f3bf 8f4f 	dsb	sy
 8009622:	60fb      	str	r3, [r7, #12]
 8009624:	e7fe      	b.n	8009624 <xTaskCheckForTimeOut+0x3c>

	taskENTER_CRITICAL();
 8009626:	f000 fe91 	bl	800a34c <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 800962a:	4b1d      	ldr	r3, [pc, #116]	; (80096a0 <xTaskCheckForTimeOut+0xb8>)
 800962c:	681b      	ldr	r3, [r3, #0]
 800962e:	61bb      	str	r3, [r7, #24]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8009630:	687b      	ldr	r3, [r7, #4]
 8009632:	685b      	ldr	r3, [r3, #4]
 8009634:	69ba      	ldr	r2, [r7, #24]
 8009636:	1ad3      	subs	r3, r2, r3
 8009638:	617b      	str	r3, [r7, #20]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 800963a:	683b      	ldr	r3, [r7, #0]
 800963c:	681b      	ldr	r3, [r3, #0]
 800963e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009642:	d102      	bne.n	800964a <xTaskCheckForTimeOut+0x62>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 8009644:	2300      	movs	r3, #0
 8009646:	61fb      	str	r3, [r7, #28]
 8009648:	e023      	b.n	8009692 <xTaskCheckForTimeOut+0xaa>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800964a:	687b      	ldr	r3, [r7, #4]
 800964c:	681a      	ldr	r2, [r3, #0]
 800964e:	4b15      	ldr	r3, [pc, #84]	; (80096a4 <xTaskCheckForTimeOut+0xbc>)
 8009650:	681b      	ldr	r3, [r3, #0]
 8009652:	429a      	cmp	r2, r3
 8009654:	d007      	beq.n	8009666 <xTaskCheckForTimeOut+0x7e>
 8009656:	687b      	ldr	r3, [r7, #4]
 8009658:	685b      	ldr	r3, [r3, #4]
 800965a:	69ba      	ldr	r2, [r7, #24]
 800965c:	429a      	cmp	r2, r3
 800965e:	d302      	bcc.n	8009666 <xTaskCheckForTimeOut+0x7e>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 8009660:	2301      	movs	r3, #1
 8009662:	61fb      	str	r3, [r7, #28]
 8009664:	e015      	b.n	8009692 <xTaskCheckForTimeOut+0xaa>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8009666:	683b      	ldr	r3, [r7, #0]
 8009668:	681b      	ldr	r3, [r3, #0]
 800966a:	697a      	ldr	r2, [r7, #20]
 800966c:	429a      	cmp	r2, r3
 800966e:	d20b      	bcs.n	8009688 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
 8009670:	683b      	ldr	r3, [r7, #0]
 8009672:	681a      	ldr	r2, [r3, #0]
 8009674:	697b      	ldr	r3, [r7, #20]
 8009676:	1ad2      	subs	r2, r2, r3
 8009678:	683b      	ldr	r3, [r7, #0]
 800967a:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 800967c:	6878      	ldr	r0, [r7, #4]
 800967e:	f7ff ff9d 	bl	80095bc <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 8009682:	2300      	movs	r3, #0
 8009684:	61fb      	str	r3, [r7, #28]
 8009686:	e004      	b.n	8009692 <xTaskCheckForTimeOut+0xaa>
		}
		else
		{
			*pxTicksToWait = 0;
 8009688:	683b      	ldr	r3, [r7, #0]
 800968a:	2200      	movs	r2, #0
 800968c:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
 800968e:	2301      	movs	r3, #1
 8009690:	61fb      	str	r3, [r7, #28]
		}
	}
	taskEXIT_CRITICAL();
 8009692:	f000 fe89 	bl	800a3a8 <vPortExitCritical>

	return xReturn;
 8009696:	69fb      	ldr	r3, [r7, #28]
}
 8009698:	4618      	mov	r0, r3
 800969a:	3720      	adds	r7, #32
 800969c:	46bd      	mov	sp, r7
 800969e:	bd80      	pop	{r7, pc}
 80096a0:	20000fa4 	.word	0x20000fa4
 80096a4:	20000fb8 	.word	0x20000fb8

080096a8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 80096a8:	b480      	push	{r7}
 80096aa:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
 80096ac:	4b03      	ldr	r3, [pc, #12]	; (80096bc <vTaskMissedYield+0x14>)
 80096ae:	2201      	movs	r2, #1
 80096b0:	601a      	str	r2, [r3, #0]
}
 80096b2:	bf00      	nop
 80096b4:	46bd      	mov	sp, r7
 80096b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80096ba:	4770      	bx	lr
 80096bc:	20000fb4 	.word	0x20000fb4

080096c0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 80096c0:	b580      	push	{r7, lr}
 80096c2:	b084      	sub	sp, #16
 80096c4:	af00      	add	r7, sp, #0
 80096c6:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 80096c8:	f000 f87a 	bl	80097c0 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 80096cc:	4b18      	ldr	r3, [pc, #96]	; (8009730 <prvIdleTask+0x70>)
 80096ce:	681b      	ldr	r3, [r3, #0]
 80096d0:	2b01      	cmp	r3, #1
 80096d2:	d907      	bls.n	80096e4 <prvIdleTask+0x24>
			{
				taskYIELD();
 80096d4:	4b17      	ldr	r3, [pc, #92]	; (8009734 <prvIdleTask+0x74>)
 80096d6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80096da:	601a      	str	r2, [r3, #0]
 80096dc:	f3bf 8f4f 	dsb	sy
 80096e0:	f3bf 8f6f 	isb	sy
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 80096e4:	f7f6 ff7c 	bl	80005e0 <vApplicationIdleHook>
			/* It is not desirable to suspend then resume the scheduler on
			each iteration of the idle task.  Therefore, a preliminary
			test of the expected idle time is performed without the
			scheduler suspended.  The result here is not necessarily
			valid. */
			xExpectedIdleTime = prvGetExpectedIdleTime();
 80096e8:	f7ff fc98 	bl	800901c <prvGetExpectedIdleTime>
 80096ec:	60f8      	str	r0, [r7, #12]

			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
 80096ee:	68fb      	ldr	r3, [r7, #12]
 80096f0:	2b01      	cmp	r3, #1
 80096f2:	d9e9      	bls.n	80096c8 <prvIdleTask+0x8>
			{
				vTaskSuspendAll();
 80096f4:	f7ff fc84 	bl	8009000 <vTaskSuspendAll>
				{
					/* Now the scheduler is suspended, the expected idle
					time can be sampled again, and this time its value can
					be used. */
					configASSERT( xNextTaskUnblockTime >= xTickCount );
 80096f8:	4b0f      	ldr	r3, [pc, #60]	; (8009738 <prvIdleTask+0x78>)
 80096fa:	681a      	ldr	r2, [r3, #0]
 80096fc:	4b0f      	ldr	r3, [pc, #60]	; (800973c <prvIdleTask+0x7c>)
 80096fe:	681b      	ldr	r3, [r3, #0]
 8009700:	429a      	cmp	r2, r3
 8009702:	d209      	bcs.n	8009718 <prvIdleTask+0x58>
 8009704:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009708:	f383 8811 	msr	BASEPRI, r3
 800970c:	f3bf 8f6f 	isb	sy
 8009710:	f3bf 8f4f 	dsb	sy
 8009714:	60bb      	str	r3, [r7, #8]
 8009716:	e7fe      	b.n	8009716 <prvIdleTask+0x56>
					xExpectedIdleTime = prvGetExpectedIdleTime();
 8009718:	f7ff fc80 	bl	800901c <prvGetExpectedIdleTime>
 800971c:	60f8      	str	r0, [r7, #12]
					/* Define the following macro to set xExpectedIdleTime to 0
					if the application does not want
					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );

					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
 800971e:	68fb      	ldr	r3, [r7, #12]
 8009720:	2b01      	cmp	r3, #1
 8009722:	d902      	bls.n	800972a <prvIdleTask+0x6a>
					{
						traceLOW_POWER_IDLE_BEGIN();
						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
 8009724:	68f8      	ldr	r0, [r7, #12]
 8009726:	f7f6 ff68 	bl	80005fa <vPortSuppressTicksAndSleep>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				( void ) xTaskResumeAll();
 800972a:	f7ff fcaf 	bl	800908c <xTaskResumeAll>
		prvCheckTasksWaitingTermination();
 800972e:	e7cb      	b.n	80096c8 <prvIdleTask+0x8>
 8009730:	20000ad0 	.word	0x20000ad0
 8009734:	e000ed04 	.word	0xe000ed04
 8009738:	20000fc0 	.word	0x20000fc0
 800973c:	20000fa4 	.word	0x20000fa4

08009740 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 8009740:	b580      	push	{r7, lr}
 8009742:	b082      	sub	sp, #8
 8009744:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8009746:	2300      	movs	r3, #0
 8009748:	607b      	str	r3, [r7, #4]
 800974a:	e00c      	b.n	8009766 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800974c:	687a      	ldr	r2, [r7, #4]
 800974e:	4613      	mov	r3, r2
 8009750:	009b      	lsls	r3, r3, #2
 8009752:	4413      	add	r3, r2
 8009754:	009b      	lsls	r3, r3, #2
 8009756:	4a12      	ldr	r2, [pc, #72]	; (80097a0 <prvInitialiseTaskLists+0x60>)
 8009758:	4413      	add	r3, r2
 800975a:	4618      	mov	r0, r3
 800975c:	f7fe fabc 	bl	8007cd8 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8009760:	687b      	ldr	r3, [r7, #4]
 8009762:	3301      	adds	r3, #1
 8009764:	607b      	str	r3, [r7, #4]
 8009766:	687b      	ldr	r3, [r7, #4]
 8009768:	2b37      	cmp	r3, #55	; 0x37
 800976a:	d9ef      	bls.n	800974c <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
 800976c:	480d      	ldr	r0, [pc, #52]	; (80097a4 <prvInitialiseTaskLists+0x64>)
 800976e:	f7fe fab3 	bl	8007cd8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8009772:	480d      	ldr	r0, [pc, #52]	; (80097a8 <prvInitialiseTaskLists+0x68>)
 8009774:	f7fe fab0 	bl	8007cd8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8009778:	480c      	ldr	r0, [pc, #48]	; (80097ac <prvInitialiseTaskLists+0x6c>)
 800977a:	f7fe faad 	bl	8007cd8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 800977e:	480c      	ldr	r0, [pc, #48]	; (80097b0 <prvInitialiseTaskLists+0x70>)
 8009780:	f7fe faaa 	bl	8007cd8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8009784:	480b      	ldr	r0, [pc, #44]	; (80097b4 <prvInitialiseTaskLists+0x74>)
 8009786:	f7fe faa7 	bl	8007cd8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800978a:	4b0b      	ldr	r3, [pc, #44]	; (80097b8 <prvInitialiseTaskLists+0x78>)
 800978c:	4a05      	ldr	r2, [pc, #20]	; (80097a4 <prvInitialiseTaskLists+0x64>)
 800978e:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8009790:	4b0a      	ldr	r3, [pc, #40]	; (80097bc <prvInitialiseTaskLists+0x7c>)
 8009792:	4a05      	ldr	r2, [pc, #20]	; (80097a8 <prvInitialiseTaskLists+0x68>)
 8009794:	601a      	str	r2, [r3, #0]
}
 8009796:	bf00      	nop
 8009798:	3708      	adds	r7, #8
 800979a:	46bd      	mov	sp, r7
 800979c:	bd80      	pop	{r7, pc}
 800979e:	bf00      	nop
 80097a0:	20000ad0 	.word	0x20000ad0
 80097a4:	20000f30 	.word	0x20000f30
 80097a8:	20000f44 	.word	0x20000f44
 80097ac:	20000f60 	.word	0x20000f60
 80097b0:	20000f74 	.word	0x20000f74
 80097b4:	20000f8c 	.word	0x20000f8c
 80097b8:	20000f58 	.word	0x20000f58
 80097bc:	20000f5c 	.word	0x20000f5c

080097c0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 80097c0:	b580      	push	{r7, lr}
 80097c2:	b082      	sub	sp, #8
 80097c4:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 80097c6:	e019      	b.n	80097fc <prvCheckTasksWaitingTermination+0x3c>
		{
			taskENTER_CRITICAL();
 80097c8:	f000 fdc0 	bl	800a34c <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80097cc:	4b0f      	ldr	r3, [pc, #60]	; (800980c <prvCheckTasksWaitingTermination+0x4c>)
 80097ce:	68db      	ldr	r3, [r3, #12]
 80097d0:	68db      	ldr	r3, [r3, #12]
 80097d2:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80097d4:	687b      	ldr	r3, [r7, #4]
 80097d6:	3304      	adds	r3, #4
 80097d8:	4618      	mov	r0, r3
 80097da:	f7fe fb07 	bl	8007dec <uxListRemove>
				--uxCurrentNumberOfTasks;
 80097de:	4b0c      	ldr	r3, [pc, #48]	; (8009810 <prvCheckTasksWaitingTermination+0x50>)
 80097e0:	681b      	ldr	r3, [r3, #0]
 80097e2:	3b01      	subs	r3, #1
 80097e4:	4a0a      	ldr	r2, [pc, #40]	; (8009810 <prvCheckTasksWaitingTermination+0x50>)
 80097e6:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 80097e8:	4b0a      	ldr	r3, [pc, #40]	; (8009814 <prvCheckTasksWaitingTermination+0x54>)
 80097ea:	681b      	ldr	r3, [r3, #0]
 80097ec:	3b01      	subs	r3, #1
 80097ee:	4a09      	ldr	r2, [pc, #36]	; (8009814 <prvCheckTasksWaitingTermination+0x54>)
 80097f0:	6013      	str	r3, [r2, #0]
			}
			taskEXIT_CRITICAL();
 80097f2:	f000 fdd9 	bl	800a3a8 <vPortExitCritical>

			prvDeleteTCB( pxTCB );
 80097f6:	6878      	ldr	r0, [r7, #4]
 80097f8:	f000 f80e 	bl	8009818 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 80097fc:	4b05      	ldr	r3, [pc, #20]	; (8009814 <prvCheckTasksWaitingTermination+0x54>)
 80097fe:	681b      	ldr	r3, [r3, #0]
 8009800:	2b00      	cmp	r3, #0
 8009802:	d1e1      	bne.n	80097c8 <prvCheckTasksWaitingTermination+0x8>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 8009804:	bf00      	nop
 8009806:	3708      	adds	r7, #8
 8009808:	46bd      	mov	sp, r7
 800980a:	bd80      	pop	{r7, pc}
 800980c:	20000f74 	.word	0x20000f74
 8009810:	20000fa0 	.word	0x20000fa0
 8009814:	20000f88 	.word	0x20000f88

08009818 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 8009818:	b580      	push	{r7, lr}
 800981a:	b084      	sub	sp, #16
 800981c:	af00      	add	r7, sp, #0
 800981e:	6078      	str	r0, [r7, #4]
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8009820:	687b      	ldr	r3, [r7, #4]
 8009822:	f893 3059 	ldrb.w	r3, [r3, #89]	; 0x59
 8009826:	2b00      	cmp	r3, #0
 8009828:	d108      	bne.n	800983c <prvDeleteTCB+0x24>
			{
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
 800982a:	687b      	ldr	r3, [r7, #4]
 800982c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800982e:	4618      	mov	r0, r3
 8009830:	f000 ff68 	bl	800a704 <vPortFree>
				vPortFree( pxTCB );
 8009834:	6878      	ldr	r0, [r7, #4]
 8009836:	f000 ff65 	bl	800a704 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 800983a:	e017      	b.n	800986c <prvDeleteTCB+0x54>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 800983c:	687b      	ldr	r3, [r7, #4]
 800983e:	f893 3059 	ldrb.w	r3, [r3, #89]	; 0x59
 8009842:	2b01      	cmp	r3, #1
 8009844:	d103      	bne.n	800984e <prvDeleteTCB+0x36>
				vPortFree( pxTCB );
 8009846:	6878      	ldr	r0, [r7, #4]
 8009848:	f000 ff5c 	bl	800a704 <vPortFree>
	}
 800984c:	e00e      	b.n	800986c <prvDeleteTCB+0x54>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 800984e:	687b      	ldr	r3, [r7, #4]
 8009850:	f893 3059 	ldrb.w	r3, [r3, #89]	; 0x59
 8009854:	2b02      	cmp	r3, #2
 8009856:	d009      	beq.n	800986c <prvDeleteTCB+0x54>
 8009858:	f04f 0350 	mov.w	r3, #80	; 0x50
 800985c:	f383 8811 	msr	BASEPRI, r3
 8009860:	f3bf 8f6f 	isb	sy
 8009864:	f3bf 8f4f 	dsb	sy
 8009868:	60fb      	str	r3, [r7, #12]
 800986a:	e7fe      	b.n	800986a <prvDeleteTCB+0x52>
	}
 800986c:	bf00      	nop
 800986e:	3710      	adds	r7, #16
 8009870:	46bd      	mov	sp, r7
 8009872:	bd80      	pop	{r7, pc}

08009874 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 8009874:	b480      	push	{r7}
 8009876:	b083      	sub	sp, #12
 8009878:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800987a:	4b0c      	ldr	r3, [pc, #48]	; (80098ac <prvResetNextTaskUnblockTime+0x38>)
 800987c:	681b      	ldr	r3, [r3, #0]
 800987e:	681b      	ldr	r3, [r3, #0]
 8009880:	2b00      	cmp	r3, #0
 8009882:	d104      	bne.n	800988e <prvResetNextTaskUnblockTime+0x1a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8009884:	4b0a      	ldr	r3, [pc, #40]	; (80098b0 <prvResetNextTaskUnblockTime+0x3c>)
 8009886:	f04f 32ff 	mov.w	r2, #4294967295
 800988a:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 800988c:	e008      	b.n	80098a0 <prvResetNextTaskUnblockTime+0x2c>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800988e:	4b07      	ldr	r3, [pc, #28]	; (80098ac <prvResetNextTaskUnblockTime+0x38>)
 8009890:	681b      	ldr	r3, [r3, #0]
 8009892:	68db      	ldr	r3, [r3, #12]
 8009894:	68db      	ldr	r3, [r3, #12]
 8009896:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8009898:	687b      	ldr	r3, [r7, #4]
 800989a:	685b      	ldr	r3, [r3, #4]
 800989c:	4a04      	ldr	r2, [pc, #16]	; (80098b0 <prvResetNextTaskUnblockTime+0x3c>)
 800989e:	6013      	str	r3, [r2, #0]
}
 80098a0:	bf00      	nop
 80098a2:	370c      	adds	r7, #12
 80098a4:	46bd      	mov	sp, r7
 80098a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80098aa:	4770      	bx	lr
 80098ac:	20000f58 	.word	0x20000f58
 80098b0:	20000fc0 	.word	0x20000fc0

080098b4 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 80098b4:	b480      	push	{r7}
 80098b6:	b083      	sub	sp, #12
 80098b8:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 80098ba:	4b0b      	ldr	r3, [pc, #44]	; (80098e8 <xTaskGetSchedulerState+0x34>)
 80098bc:	681b      	ldr	r3, [r3, #0]
 80098be:	2b00      	cmp	r3, #0
 80098c0:	d102      	bne.n	80098c8 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 80098c2:	2301      	movs	r3, #1
 80098c4:	607b      	str	r3, [r7, #4]
 80098c6:	e008      	b.n	80098da <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80098c8:	4b08      	ldr	r3, [pc, #32]	; (80098ec <xTaskGetSchedulerState+0x38>)
 80098ca:	681b      	ldr	r3, [r3, #0]
 80098cc:	2b00      	cmp	r3, #0
 80098ce:	d102      	bne.n	80098d6 <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
 80098d0:	2302      	movs	r3, #2
 80098d2:	607b      	str	r3, [r7, #4]
 80098d4:	e001      	b.n	80098da <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 80098d6:	2300      	movs	r3, #0
 80098d8:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
 80098da:	687b      	ldr	r3, [r7, #4]
	}
 80098dc:	4618      	mov	r0, r3
 80098de:	370c      	adds	r7, #12
 80098e0:	46bd      	mov	sp, r7
 80098e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80098e6:	4770      	bx	lr
 80098e8:	20000fac 	.word	0x20000fac
 80098ec:	20000fc8 	.word	0x20000fc8

080098f0 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 80098f0:	b580      	push	{r7, lr}
 80098f2:	b086      	sub	sp, #24
 80098f4:	af00      	add	r7, sp, #0
 80098f6:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = pxMutexHolder;
 80098f8:	687b      	ldr	r3, [r7, #4]
 80098fa:	613b      	str	r3, [r7, #16]
	BaseType_t xReturn = pdFALSE;
 80098fc:	2300      	movs	r3, #0
 80098fe:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
 8009900:	687b      	ldr	r3, [r7, #4]
 8009902:	2b00      	cmp	r3, #0
 8009904:	d054      	beq.n	80099b0 <xTaskPriorityDisinherit+0xc0>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
 8009906:	4b2d      	ldr	r3, [pc, #180]	; (80099bc <xTaskPriorityDisinherit+0xcc>)
 8009908:	681b      	ldr	r3, [r3, #0]
 800990a:	693a      	ldr	r2, [r7, #16]
 800990c:	429a      	cmp	r2, r3
 800990e:	d009      	beq.n	8009924 <xTaskPriorityDisinherit+0x34>
 8009910:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009914:	f383 8811 	msr	BASEPRI, r3
 8009918:	f3bf 8f6f 	isb	sy
 800991c:	f3bf 8f4f 	dsb	sy
 8009920:	60fb      	str	r3, [r7, #12]
 8009922:	e7fe      	b.n	8009922 <xTaskPriorityDisinherit+0x32>
			configASSERT( pxTCB->uxMutexesHeld );
 8009924:	693b      	ldr	r3, [r7, #16]
 8009926:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009928:	2b00      	cmp	r3, #0
 800992a:	d109      	bne.n	8009940 <xTaskPriorityDisinherit+0x50>
 800992c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009930:	f383 8811 	msr	BASEPRI, r3
 8009934:	f3bf 8f6f 	isb	sy
 8009938:	f3bf 8f4f 	dsb	sy
 800993c:	60bb      	str	r3, [r7, #8]
 800993e:	e7fe      	b.n	800993e <xTaskPriorityDisinherit+0x4e>
			( pxTCB->uxMutexesHeld )--;
 8009940:	693b      	ldr	r3, [r7, #16]
 8009942:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009944:	1e5a      	subs	r2, r3, #1
 8009946:	693b      	ldr	r3, [r7, #16]
 8009948:	651a      	str	r2, [r3, #80]	; 0x50

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800994a:	693b      	ldr	r3, [r7, #16]
 800994c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800994e:	693b      	ldr	r3, [r7, #16]
 8009950:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8009952:	429a      	cmp	r2, r3
 8009954:	d02c      	beq.n	80099b0 <xTaskPriorityDisinherit+0xc0>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8009956:	693b      	ldr	r3, [r7, #16]
 8009958:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800995a:	2b00      	cmp	r3, #0
 800995c:	d128      	bne.n	80099b0 <xTaskPriorityDisinherit+0xc0>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800995e:	693b      	ldr	r3, [r7, #16]
 8009960:	3304      	adds	r3, #4
 8009962:	4618      	mov	r0, r3
 8009964:	f7fe fa42 	bl	8007dec <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8009968:	693b      	ldr	r3, [r7, #16]
 800996a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800996c:	693b      	ldr	r3, [r7, #16]
 800996e:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009970:	693b      	ldr	r3, [r7, #16]
 8009972:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009974:	f1c3 0238 	rsb	r2, r3, #56	; 0x38
 8009978:	693b      	ldr	r3, [r7, #16]
 800997a:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
 800997c:	693b      	ldr	r3, [r7, #16]
 800997e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009980:	4b0f      	ldr	r3, [pc, #60]	; (80099c0 <xTaskPriorityDisinherit+0xd0>)
 8009982:	681b      	ldr	r3, [r3, #0]
 8009984:	429a      	cmp	r2, r3
 8009986:	d903      	bls.n	8009990 <xTaskPriorityDisinherit+0xa0>
 8009988:	693b      	ldr	r3, [r7, #16]
 800998a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800998c:	4a0c      	ldr	r2, [pc, #48]	; (80099c0 <xTaskPriorityDisinherit+0xd0>)
 800998e:	6013      	str	r3, [r2, #0]
 8009990:	693b      	ldr	r3, [r7, #16]
 8009992:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009994:	4613      	mov	r3, r2
 8009996:	009b      	lsls	r3, r3, #2
 8009998:	4413      	add	r3, r2
 800999a:	009b      	lsls	r3, r3, #2
 800999c:	4a09      	ldr	r2, [pc, #36]	; (80099c4 <xTaskPriorityDisinherit+0xd4>)
 800999e:	441a      	add	r2, r3
 80099a0:	693b      	ldr	r3, [r7, #16]
 80099a2:	3304      	adds	r3, #4
 80099a4:	4619      	mov	r1, r3
 80099a6:	4610      	mov	r0, r2
 80099a8:	f7fe f9c3 	bl	8007d32 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 80099ac:	2301      	movs	r3, #1
 80099ae:	617b      	str	r3, [r7, #20]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 80099b0:	697b      	ldr	r3, [r7, #20]
	}
 80099b2:	4618      	mov	r0, r3
 80099b4:	3718      	adds	r7, #24
 80099b6:	46bd      	mov	sp, r7
 80099b8:	bd80      	pop	{r7, pc}
 80099ba:	bf00      	nop
 80099bc:	20000acc 	.word	0x20000acc
 80099c0:	20000fa8 	.word	0x20000fa8
 80099c4:	20000ad0 	.word	0x20000ad0

080099c8 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80099c8:	b580      	push	{r7, lr}
 80099ca:	b084      	sub	sp, #16
 80099cc:	af00      	add	r7, sp, #0
 80099ce:	6078      	str	r0, [r7, #4]
 80099d0:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80099d2:	4b21      	ldr	r3, [pc, #132]	; (8009a58 <prvAddCurrentTaskToDelayedList+0x90>)
 80099d4:	681b      	ldr	r3, [r3, #0]
 80099d6:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80099d8:	4b20      	ldr	r3, [pc, #128]	; (8009a5c <prvAddCurrentTaskToDelayedList+0x94>)
 80099da:	681b      	ldr	r3, [r3, #0]
 80099dc:	3304      	adds	r3, #4
 80099de:	4618      	mov	r0, r3
 80099e0:	f7fe fa04 	bl	8007dec <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80099e4:	687b      	ldr	r3, [r7, #4]
 80099e6:	f1b3 3fff 	cmp.w	r3, #4294967295
 80099ea:	d10a      	bne.n	8009a02 <prvAddCurrentTaskToDelayedList+0x3a>
 80099ec:	683b      	ldr	r3, [r7, #0]
 80099ee:	2b00      	cmp	r3, #0
 80099f0:	d007      	beq.n	8009a02 <prvAddCurrentTaskToDelayedList+0x3a>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80099f2:	4b1a      	ldr	r3, [pc, #104]	; (8009a5c <prvAddCurrentTaskToDelayedList+0x94>)
 80099f4:	681b      	ldr	r3, [r3, #0]
 80099f6:	3304      	adds	r3, #4
 80099f8:	4619      	mov	r1, r3
 80099fa:	4819      	ldr	r0, [pc, #100]	; (8009a60 <prvAddCurrentTaskToDelayedList+0x98>)
 80099fc:	f7fe f999 	bl	8007d32 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8009a00:	e026      	b.n	8009a50 <prvAddCurrentTaskToDelayedList+0x88>
			xTimeToWake = xConstTickCount + xTicksToWait;
 8009a02:	68fa      	ldr	r2, [r7, #12]
 8009a04:	687b      	ldr	r3, [r7, #4]
 8009a06:	4413      	add	r3, r2
 8009a08:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8009a0a:	4b14      	ldr	r3, [pc, #80]	; (8009a5c <prvAddCurrentTaskToDelayedList+0x94>)
 8009a0c:	681b      	ldr	r3, [r3, #0]
 8009a0e:	68ba      	ldr	r2, [r7, #8]
 8009a10:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 8009a12:	68ba      	ldr	r2, [r7, #8]
 8009a14:	68fb      	ldr	r3, [r7, #12]
 8009a16:	429a      	cmp	r2, r3
 8009a18:	d209      	bcs.n	8009a2e <prvAddCurrentTaskToDelayedList+0x66>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8009a1a:	4b12      	ldr	r3, [pc, #72]	; (8009a64 <prvAddCurrentTaskToDelayedList+0x9c>)
 8009a1c:	681a      	ldr	r2, [r3, #0]
 8009a1e:	4b0f      	ldr	r3, [pc, #60]	; (8009a5c <prvAddCurrentTaskToDelayedList+0x94>)
 8009a20:	681b      	ldr	r3, [r3, #0]
 8009a22:	3304      	adds	r3, #4
 8009a24:	4619      	mov	r1, r3
 8009a26:	4610      	mov	r0, r2
 8009a28:	f7fe f9a7 	bl	8007d7a <vListInsert>
}
 8009a2c:	e010      	b.n	8009a50 <prvAddCurrentTaskToDelayedList+0x88>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8009a2e:	4b0e      	ldr	r3, [pc, #56]	; (8009a68 <prvAddCurrentTaskToDelayedList+0xa0>)
 8009a30:	681a      	ldr	r2, [r3, #0]
 8009a32:	4b0a      	ldr	r3, [pc, #40]	; (8009a5c <prvAddCurrentTaskToDelayedList+0x94>)
 8009a34:	681b      	ldr	r3, [r3, #0]
 8009a36:	3304      	adds	r3, #4
 8009a38:	4619      	mov	r1, r3
 8009a3a:	4610      	mov	r0, r2
 8009a3c:	f7fe f99d 	bl	8007d7a <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8009a40:	4b0a      	ldr	r3, [pc, #40]	; (8009a6c <prvAddCurrentTaskToDelayedList+0xa4>)
 8009a42:	681b      	ldr	r3, [r3, #0]
 8009a44:	68ba      	ldr	r2, [r7, #8]
 8009a46:	429a      	cmp	r2, r3
 8009a48:	d202      	bcs.n	8009a50 <prvAddCurrentTaskToDelayedList+0x88>
					xNextTaskUnblockTime = xTimeToWake;
 8009a4a:	4a08      	ldr	r2, [pc, #32]	; (8009a6c <prvAddCurrentTaskToDelayedList+0xa4>)
 8009a4c:	68bb      	ldr	r3, [r7, #8]
 8009a4e:	6013      	str	r3, [r2, #0]
}
 8009a50:	bf00      	nop
 8009a52:	3710      	adds	r7, #16
 8009a54:	46bd      	mov	sp, r7
 8009a56:	bd80      	pop	{r7, pc}
 8009a58:	20000fa4 	.word	0x20000fa4
 8009a5c:	20000acc 	.word	0x20000acc
 8009a60:	20000f8c 	.word	0x20000f8c
 8009a64:	20000f5c 	.word	0x20000f5c
 8009a68:	20000f58 	.word	0x20000f58
 8009a6c:	20000fc0 	.word	0x20000fc0

08009a70 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 8009a70:	b580      	push	{r7, lr}
 8009a72:	b08a      	sub	sp, #40	; 0x28
 8009a74:	af04      	add	r7, sp, #16
BaseType_t xReturn = pdFAIL;
 8009a76:	2300      	movs	r3, #0
 8009a78:	617b      	str	r3, [r7, #20]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 8009a7a:	f000 faff 	bl	800a07c <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 8009a7e:	4b1c      	ldr	r3, [pc, #112]	; (8009af0 <xTimerCreateTimerTask+0x80>)
 8009a80:	681b      	ldr	r3, [r3, #0]
 8009a82:	2b00      	cmp	r3, #0
 8009a84:	d021      	beq.n	8009aca <xTimerCreateTimerTask+0x5a>
	{
		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
		{
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 8009a86:	2300      	movs	r3, #0
 8009a88:	60fb      	str	r3, [r7, #12]
			StackType_t *pxTimerTaskStackBuffer = NULL;
 8009a8a:	2300      	movs	r3, #0
 8009a8c:	60bb      	str	r3, [r7, #8]
			uint32_t ulTimerTaskStackSize;

			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 8009a8e:	1d3a      	adds	r2, r7, #4
 8009a90:	f107 0108 	add.w	r1, r7, #8
 8009a94:	f107 030c 	add.w	r3, r7, #12
 8009a98:	4618      	mov	r0, r3
 8009a9a:	f7fe f903 	bl	8007ca4 <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 8009a9e:	6879      	ldr	r1, [r7, #4]
 8009aa0:	68bb      	ldr	r3, [r7, #8]
 8009aa2:	68fa      	ldr	r2, [r7, #12]
 8009aa4:	9202      	str	r2, [sp, #8]
 8009aa6:	9301      	str	r3, [sp, #4]
 8009aa8:	2302      	movs	r3, #2
 8009aaa:	9300      	str	r3, [sp, #0]
 8009aac:	2300      	movs	r3, #0
 8009aae:	460a      	mov	r2, r1
 8009ab0:	4910      	ldr	r1, [pc, #64]	; (8009af4 <xTimerCreateTimerTask+0x84>)
 8009ab2:	4811      	ldr	r0, [pc, #68]	; (8009af8 <xTimerCreateTimerTask+0x88>)
 8009ab4:	f7fe ff22 	bl	80088fc <xTaskCreateStatic>
 8009ab8:	4602      	mov	r2, r0
 8009aba:	4b10      	ldr	r3, [pc, #64]	; (8009afc <xTimerCreateTimerTask+0x8c>)
 8009abc:	601a      	str	r2, [r3, #0]
													NULL,
													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
													pxTimerTaskStackBuffer,
													pxTimerTaskTCBBuffer );

			if( xTimerTaskHandle != NULL )
 8009abe:	4b0f      	ldr	r3, [pc, #60]	; (8009afc <xTimerCreateTimerTask+0x8c>)
 8009ac0:	681b      	ldr	r3, [r3, #0]
 8009ac2:	2b00      	cmp	r3, #0
 8009ac4:	d001      	beq.n	8009aca <xTimerCreateTimerTask+0x5a>
			{
				xReturn = pdPASS;
 8009ac6:	2301      	movs	r3, #1
 8009ac8:	617b      	str	r3, [r7, #20]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 8009aca:	697b      	ldr	r3, [r7, #20]
 8009acc:	2b00      	cmp	r3, #0
 8009ace:	d109      	bne.n	8009ae4 <xTimerCreateTimerTask+0x74>
 8009ad0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009ad4:	f383 8811 	msr	BASEPRI, r3
 8009ad8:	f3bf 8f6f 	isb	sy
 8009adc:	f3bf 8f4f 	dsb	sy
 8009ae0:	613b      	str	r3, [r7, #16]
 8009ae2:	e7fe      	b.n	8009ae2 <xTimerCreateTimerTask+0x72>
	return xReturn;
 8009ae4:	697b      	ldr	r3, [r7, #20]
}
 8009ae6:	4618      	mov	r0, r3
 8009ae8:	3718      	adds	r7, #24
 8009aea:	46bd      	mov	sp, r7
 8009aec:	bd80      	pop	{r7, pc}
 8009aee:	bf00      	nop
 8009af0:	20000ffc 	.word	0x20000ffc
 8009af4:	08028c20 	.word	0x08028c20
 8009af8:	08009c31 	.word	0x08009c31
 8009afc:	20001000 	.word	0x20001000

08009b00 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 8009b00:	b580      	push	{r7, lr}
 8009b02:	b08a      	sub	sp, #40	; 0x28
 8009b04:	af00      	add	r7, sp, #0
 8009b06:	60f8      	str	r0, [r7, #12]
 8009b08:	60b9      	str	r1, [r7, #8]
 8009b0a:	607a      	str	r2, [r7, #4]
 8009b0c:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
 8009b0e:	2300      	movs	r3, #0
 8009b10:	627b      	str	r3, [r7, #36]	; 0x24
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
 8009b12:	68fb      	ldr	r3, [r7, #12]
 8009b14:	2b00      	cmp	r3, #0
 8009b16:	d109      	bne.n	8009b2c <xTimerGenericCommand+0x2c>
 8009b18:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009b1c:	f383 8811 	msr	BASEPRI, r3
 8009b20:	f3bf 8f6f 	isb	sy
 8009b24:	f3bf 8f4f 	dsb	sy
 8009b28:	623b      	str	r3, [r7, #32]
 8009b2a:	e7fe      	b.n	8009b2a <xTimerGenericCommand+0x2a>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8009b2c:	4b19      	ldr	r3, [pc, #100]	; (8009b94 <xTimerGenericCommand+0x94>)
 8009b2e:	681b      	ldr	r3, [r3, #0]
 8009b30:	2b00      	cmp	r3, #0
 8009b32:	d02a      	beq.n	8009b8a <xTimerGenericCommand+0x8a>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8009b34:	68bb      	ldr	r3, [r7, #8]
 8009b36:	613b      	str	r3, [r7, #16]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8009b38:	687b      	ldr	r3, [r7, #4]
 8009b3a:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 8009b3c:	68fb      	ldr	r3, [r7, #12]
 8009b3e:	61bb      	str	r3, [r7, #24]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8009b40:	68bb      	ldr	r3, [r7, #8]
 8009b42:	2b05      	cmp	r3, #5
 8009b44:	dc18      	bgt.n	8009b78 <xTimerGenericCommand+0x78>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8009b46:	f7ff feb5 	bl	80098b4 <xTaskGetSchedulerState>
 8009b4a:	4603      	mov	r3, r0
 8009b4c:	2b02      	cmp	r3, #2
 8009b4e:	d109      	bne.n	8009b64 <xTimerGenericCommand+0x64>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8009b50:	4b10      	ldr	r3, [pc, #64]	; (8009b94 <xTimerGenericCommand+0x94>)
 8009b52:	6818      	ldr	r0, [r3, #0]
 8009b54:	f107 0110 	add.w	r1, r7, #16
 8009b58:	2300      	movs	r3, #0
 8009b5a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8009b5c:	f7fe fa6e 	bl	800803c <xQueueGenericSend>
 8009b60:	6278      	str	r0, [r7, #36]	; 0x24
 8009b62:	e012      	b.n	8009b8a <xTimerGenericCommand+0x8a>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8009b64:	4b0b      	ldr	r3, [pc, #44]	; (8009b94 <xTimerGenericCommand+0x94>)
 8009b66:	6818      	ldr	r0, [r3, #0]
 8009b68:	f107 0110 	add.w	r1, r7, #16
 8009b6c:	2300      	movs	r3, #0
 8009b6e:	2200      	movs	r2, #0
 8009b70:	f7fe fa64 	bl	800803c <xQueueGenericSend>
 8009b74:	6278      	str	r0, [r7, #36]	; 0x24
 8009b76:	e008      	b.n	8009b8a <xTimerGenericCommand+0x8a>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8009b78:	4b06      	ldr	r3, [pc, #24]	; (8009b94 <xTimerGenericCommand+0x94>)
 8009b7a:	6818      	ldr	r0, [r3, #0]
 8009b7c:	f107 0110 	add.w	r1, r7, #16
 8009b80:	2300      	movs	r3, #0
 8009b82:	683a      	ldr	r2, [r7, #0]
 8009b84:	f7fe fb54 	bl	8008230 <xQueueGenericSendFromISR>
 8009b88:	6278      	str	r0, [r7, #36]	; 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
 8009b8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8009b8c:	4618      	mov	r0, r3
 8009b8e:	3728      	adds	r7, #40	; 0x28
 8009b90:	46bd      	mov	sp, r7
 8009b92:	bd80      	pop	{r7, pc}
 8009b94:	20000ffc 	.word	0x20000ffc

08009b98 <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
 8009b98:	b580      	push	{r7, lr}
 8009b9a:	b088      	sub	sp, #32
 8009b9c:	af02      	add	r7, sp, #8
 8009b9e:	6078      	str	r0, [r7, #4]
 8009ba0:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8009ba2:	4b22      	ldr	r3, [pc, #136]	; (8009c2c <prvProcessExpiredTimer+0x94>)
 8009ba4:	681b      	ldr	r3, [r3, #0]
 8009ba6:	68db      	ldr	r3, [r3, #12]
 8009ba8:	68db      	ldr	r3, [r3, #12]
 8009baa:	617b      	str	r3, [r7, #20]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8009bac:	697b      	ldr	r3, [r7, #20]
 8009bae:	3304      	adds	r3, #4
 8009bb0:	4618      	mov	r0, r3
 8009bb2:	f7fe f91b 	bl	8007dec <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8009bb6:	697b      	ldr	r3, [r7, #20]
 8009bb8:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8009bbc:	f003 0304 	and.w	r3, r3, #4
 8009bc0:	2b00      	cmp	r3, #0
 8009bc2:	d021      	beq.n	8009c08 <prvProcessExpiredTimer+0x70>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8009bc4:	697b      	ldr	r3, [r7, #20]
 8009bc6:	699a      	ldr	r2, [r3, #24]
 8009bc8:	687b      	ldr	r3, [r7, #4]
 8009bca:	18d1      	adds	r1, r2, r3
 8009bcc:	687b      	ldr	r3, [r7, #4]
 8009bce:	683a      	ldr	r2, [r7, #0]
 8009bd0:	6978      	ldr	r0, [r7, #20]
 8009bd2:	f000 f8d1 	bl	8009d78 <prvInsertTimerInActiveList>
 8009bd6:	4603      	mov	r3, r0
 8009bd8:	2b00      	cmp	r3, #0
 8009bda:	d01e      	beq.n	8009c1a <prvProcessExpiredTimer+0x82>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8009bdc:	2300      	movs	r3, #0
 8009bde:	9300      	str	r3, [sp, #0]
 8009be0:	2300      	movs	r3, #0
 8009be2:	687a      	ldr	r2, [r7, #4]
 8009be4:	2100      	movs	r1, #0
 8009be6:	6978      	ldr	r0, [r7, #20]
 8009be8:	f7ff ff8a 	bl	8009b00 <xTimerGenericCommand>
 8009bec:	6138      	str	r0, [r7, #16]
			configASSERT( xResult );
 8009bee:	693b      	ldr	r3, [r7, #16]
 8009bf0:	2b00      	cmp	r3, #0
 8009bf2:	d112      	bne.n	8009c1a <prvProcessExpiredTimer+0x82>
 8009bf4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009bf8:	f383 8811 	msr	BASEPRI, r3
 8009bfc:	f3bf 8f6f 	isb	sy
 8009c00:	f3bf 8f4f 	dsb	sy
 8009c04:	60fb      	str	r3, [r7, #12]
 8009c06:	e7fe      	b.n	8009c06 <prvProcessExpiredTimer+0x6e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8009c08:	697b      	ldr	r3, [r7, #20]
 8009c0a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8009c0e:	f023 0301 	bic.w	r3, r3, #1
 8009c12:	b2da      	uxtb	r2, r3
 8009c14:	697b      	ldr	r3, [r7, #20]
 8009c16:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8009c1a:	697b      	ldr	r3, [r7, #20]
 8009c1c:	6a1b      	ldr	r3, [r3, #32]
 8009c1e:	6978      	ldr	r0, [r7, #20]
 8009c20:	4798      	blx	r3
}
 8009c22:	bf00      	nop
 8009c24:	3718      	adds	r7, #24
 8009c26:	46bd      	mov	sp, r7
 8009c28:	bd80      	pop	{r7, pc}
 8009c2a:	bf00      	nop
 8009c2c:	20000ff4 	.word	0x20000ff4

08009c30 <prvTimerTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
 8009c30:	b580      	push	{r7, lr}
 8009c32:	b084      	sub	sp, #16
 8009c34:	af00      	add	r7, sp, #0
 8009c36:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 8009c38:	f107 0308 	add.w	r3, r7, #8
 8009c3c:	4618      	mov	r0, r3
 8009c3e:	f000 f857 	bl	8009cf0 <prvGetNextExpireTime>
 8009c42:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 8009c44:	68bb      	ldr	r3, [r7, #8]
 8009c46:	4619      	mov	r1, r3
 8009c48:	68f8      	ldr	r0, [r7, #12]
 8009c4a:	f000 f803 	bl	8009c54 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
 8009c4e:	f000 f8d5 	bl	8009dfc <prvProcessReceivedCommands>
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 8009c52:	e7f1      	b.n	8009c38 <prvTimerTask+0x8>

08009c54 <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
 8009c54:	b580      	push	{r7, lr}
 8009c56:	b084      	sub	sp, #16
 8009c58:	af00      	add	r7, sp, #0
 8009c5a:	6078      	str	r0, [r7, #4]
 8009c5c:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 8009c5e:	f7ff f9cf 	bl	8009000 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8009c62:	f107 0308 	add.w	r3, r7, #8
 8009c66:	4618      	mov	r0, r3
 8009c68:	f000 f866 	bl	8009d38 <prvSampleTimeNow>
 8009c6c:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
 8009c6e:	68bb      	ldr	r3, [r7, #8]
 8009c70:	2b00      	cmp	r3, #0
 8009c72:	d130      	bne.n	8009cd6 <prvProcessTimerOrBlockTask+0x82>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8009c74:	683b      	ldr	r3, [r7, #0]
 8009c76:	2b00      	cmp	r3, #0
 8009c78:	d10a      	bne.n	8009c90 <prvProcessTimerOrBlockTask+0x3c>
 8009c7a:	687a      	ldr	r2, [r7, #4]
 8009c7c:	68fb      	ldr	r3, [r7, #12]
 8009c7e:	429a      	cmp	r2, r3
 8009c80:	d806      	bhi.n	8009c90 <prvProcessTimerOrBlockTask+0x3c>
			{
				( void ) xTaskResumeAll();
 8009c82:	f7ff fa03 	bl	800908c <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 8009c86:	68f9      	ldr	r1, [r7, #12]
 8009c88:	6878      	ldr	r0, [r7, #4]
 8009c8a:	f7ff ff85 	bl	8009b98 <prvProcessExpiredTimer>
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 8009c8e:	e024      	b.n	8009cda <prvProcessTimerOrBlockTask+0x86>
				if( xListWasEmpty != pdFALSE )
 8009c90:	683b      	ldr	r3, [r7, #0]
 8009c92:	2b00      	cmp	r3, #0
 8009c94:	d008      	beq.n	8009ca8 <prvProcessTimerOrBlockTask+0x54>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8009c96:	4b13      	ldr	r3, [pc, #76]	; (8009ce4 <prvProcessTimerOrBlockTask+0x90>)
 8009c98:	681b      	ldr	r3, [r3, #0]
 8009c9a:	681b      	ldr	r3, [r3, #0]
 8009c9c:	2b00      	cmp	r3, #0
 8009c9e:	d101      	bne.n	8009ca4 <prvProcessTimerOrBlockTask+0x50>
 8009ca0:	2301      	movs	r3, #1
 8009ca2:	e000      	b.n	8009ca6 <prvProcessTimerOrBlockTask+0x52>
 8009ca4:	2300      	movs	r3, #0
 8009ca6:	603b      	str	r3, [r7, #0]
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8009ca8:	4b0f      	ldr	r3, [pc, #60]	; (8009ce8 <prvProcessTimerOrBlockTask+0x94>)
 8009caa:	6818      	ldr	r0, [r3, #0]
 8009cac:	687a      	ldr	r2, [r7, #4]
 8009cae:	68fb      	ldr	r3, [r7, #12]
 8009cb0:	1ad3      	subs	r3, r2, r3
 8009cb2:	683a      	ldr	r2, [r7, #0]
 8009cb4:	4619      	mov	r1, r3
 8009cb6:	f7fe fded 	bl	8008894 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 8009cba:	f7ff f9e7 	bl	800908c <xTaskResumeAll>
 8009cbe:	4603      	mov	r3, r0
 8009cc0:	2b00      	cmp	r3, #0
 8009cc2:	d10a      	bne.n	8009cda <prvProcessTimerOrBlockTask+0x86>
					portYIELD_WITHIN_API();
 8009cc4:	4b09      	ldr	r3, [pc, #36]	; (8009cec <prvProcessTimerOrBlockTask+0x98>)
 8009cc6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009cca:	601a      	str	r2, [r3, #0]
 8009ccc:	f3bf 8f4f 	dsb	sy
 8009cd0:	f3bf 8f6f 	isb	sy
}
 8009cd4:	e001      	b.n	8009cda <prvProcessTimerOrBlockTask+0x86>
			( void ) xTaskResumeAll();
 8009cd6:	f7ff f9d9 	bl	800908c <xTaskResumeAll>
}
 8009cda:	bf00      	nop
 8009cdc:	3710      	adds	r7, #16
 8009cde:	46bd      	mov	sp, r7
 8009ce0:	bd80      	pop	{r7, pc}
 8009ce2:	bf00      	nop
 8009ce4:	20000ff8 	.word	0x20000ff8
 8009ce8:	20000ffc 	.word	0x20000ffc
 8009cec:	e000ed04 	.word	0xe000ed04

08009cf0 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
 8009cf0:	b480      	push	{r7}
 8009cf2:	b085      	sub	sp, #20
 8009cf4:	af00      	add	r7, sp, #0
 8009cf6:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8009cf8:	4b0e      	ldr	r3, [pc, #56]	; (8009d34 <prvGetNextExpireTime+0x44>)
 8009cfa:	681b      	ldr	r3, [r3, #0]
 8009cfc:	681b      	ldr	r3, [r3, #0]
 8009cfe:	2b00      	cmp	r3, #0
 8009d00:	d101      	bne.n	8009d06 <prvGetNextExpireTime+0x16>
 8009d02:	2201      	movs	r2, #1
 8009d04:	e000      	b.n	8009d08 <prvGetNextExpireTime+0x18>
 8009d06:	2200      	movs	r2, #0
 8009d08:	687b      	ldr	r3, [r7, #4]
 8009d0a:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
 8009d0c:	687b      	ldr	r3, [r7, #4]
 8009d0e:	681b      	ldr	r3, [r3, #0]
 8009d10:	2b00      	cmp	r3, #0
 8009d12:	d105      	bne.n	8009d20 <prvGetNextExpireTime+0x30>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8009d14:	4b07      	ldr	r3, [pc, #28]	; (8009d34 <prvGetNextExpireTime+0x44>)
 8009d16:	681b      	ldr	r3, [r3, #0]
 8009d18:	68db      	ldr	r3, [r3, #12]
 8009d1a:	681b      	ldr	r3, [r3, #0]
 8009d1c:	60fb      	str	r3, [r7, #12]
 8009d1e:	e001      	b.n	8009d24 <prvGetNextExpireTime+0x34>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 8009d20:	2300      	movs	r3, #0
 8009d22:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
 8009d24:	68fb      	ldr	r3, [r7, #12]
}
 8009d26:	4618      	mov	r0, r3
 8009d28:	3714      	adds	r7, #20
 8009d2a:	46bd      	mov	sp, r7
 8009d2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d30:	4770      	bx	lr
 8009d32:	bf00      	nop
 8009d34:	20000ff4 	.word	0x20000ff4

08009d38 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
 8009d38:	b580      	push	{r7, lr}
 8009d3a:	b084      	sub	sp, #16
 8009d3c:	af00      	add	r7, sp, #0
 8009d3e:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8009d40:	f7ff fa40 	bl	80091c4 <xTaskGetTickCount>
 8009d44:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
 8009d46:	4b0b      	ldr	r3, [pc, #44]	; (8009d74 <prvSampleTimeNow+0x3c>)
 8009d48:	681b      	ldr	r3, [r3, #0]
 8009d4a:	68fa      	ldr	r2, [r7, #12]
 8009d4c:	429a      	cmp	r2, r3
 8009d4e:	d205      	bcs.n	8009d5c <prvSampleTimeNow+0x24>
	{
		prvSwitchTimerLists();
 8009d50:	f000 f930 	bl	8009fb4 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 8009d54:	687b      	ldr	r3, [r7, #4]
 8009d56:	2201      	movs	r2, #1
 8009d58:	601a      	str	r2, [r3, #0]
 8009d5a:	e002      	b.n	8009d62 <prvSampleTimeNow+0x2a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 8009d5c:	687b      	ldr	r3, [r7, #4]
 8009d5e:	2200      	movs	r2, #0
 8009d60:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
 8009d62:	4a04      	ldr	r2, [pc, #16]	; (8009d74 <prvSampleTimeNow+0x3c>)
 8009d64:	68fb      	ldr	r3, [r7, #12]
 8009d66:	6013      	str	r3, [r2, #0]

	return xTimeNow;
 8009d68:	68fb      	ldr	r3, [r7, #12]
}
 8009d6a:	4618      	mov	r0, r3
 8009d6c:	3710      	adds	r7, #16
 8009d6e:	46bd      	mov	sp, r7
 8009d70:	bd80      	pop	{r7, pc}
 8009d72:	bf00      	nop
 8009d74:	20001004 	.word	0x20001004

08009d78 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 8009d78:	b580      	push	{r7, lr}
 8009d7a:	b086      	sub	sp, #24
 8009d7c:	af00      	add	r7, sp, #0
 8009d7e:	60f8      	str	r0, [r7, #12]
 8009d80:	60b9      	str	r1, [r7, #8]
 8009d82:	607a      	str	r2, [r7, #4]
 8009d84:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
 8009d86:	2300      	movs	r3, #0
 8009d88:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8009d8a:	68fb      	ldr	r3, [r7, #12]
 8009d8c:	68ba      	ldr	r2, [r7, #8]
 8009d8e:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8009d90:	68fb      	ldr	r3, [r7, #12]
 8009d92:	68fa      	ldr	r2, [r7, #12]
 8009d94:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
 8009d96:	68ba      	ldr	r2, [r7, #8]
 8009d98:	687b      	ldr	r3, [r7, #4]
 8009d9a:	429a      	cmp	r2, r3
 8009d9c:	d812      	bhi.n	8009dc4 <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009d9e:	687a      	ldr	r2, [r7, #4]
 8009da0:	683b      	ldr	r3, [r7, #0]
 8009da2:	1ad2      	subs	r2, r2, r3
 8009da4:	68fb      	ldr	r3, [r7, #12]
 8009da6:	699b      	ldr	r3, [r3, #24]
 8009da8:	429a      	cmp	r2, r3
 8009daa:	d302      	bcc.n	8009db2 <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 8009dac:	2301      	movs	r3, #1
 8009dae:	617b      	str	r3, [r7, #20]
 8009db0:	e01b      	b.n	8009dea <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8009db2:	4b10      	ldr	r3, [pc, #64]	; (8009df4 <prvInsertTimerInActiveList+0x7c>)
 8009db4:	681a      	ldr	r2, [r3, #0]
 8009db6:	68fb      	ldr	r3, [r7, #12]
 8009db8:	3304      	adds	r3, #4
 8009dba:	4619      	mov	r1, r3
 8009dbc:	4610      	mov	r0, r2
 8009dbe:	f7fd ffdc 	bl	8007d7a <vListInsert>
 8009dc2:	e012      	b.n	8009dea <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8009dc4:	687a      	ldr	r2, [r7, #4]
 8009dc6:	683b      	ldr	r3, [r7, #0]
 8009dc8:	429a      	cmp	r2, r3
 8009dca:	d206      	bcs.n	8009dda <prvInsertTimerInActiveList+0x62>
 8009dcc:	68ba      	ldr	r2, [r7, #8]
 8009dce:	683b      	ldr	r3, [r7, #0]
 8009dd0:	429a      	cmp	r2, r3
 8009dd2:	d302      	bcc.n	8009dda <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
 8009dd4:	2301      	movs	r3, #1
 8009dd6:	617b      	str	r3, [r7, #20]
 8009dd8:	e007      	b.n	8009dea <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8009dda:	4b07      	ldr	r3, [pc, #28]	; (8009df8 <prvInsertTimerInActiveList+0x80>)
 8009ddc:	681a      	ldr	r2, [r3, #0]
 8009dde:	68fb      	ldr	r3, [r7, #12]
 8009de0:	3304      	adds	r3, #4
 8009de2:	4619      	mov	r1, r3
 8009de4:	4610      	mov	r0, r2
 8009de6:	f7fd ffc8 	bl	8007d7a <vListInsert>
		}
	}

	return xProcessTimerNow;
 8009dea:	697b      	ldr	r3, [r7, #20]
}
 8009dec:	4618      	mov	r0, r3
 8009dee:	3718      	adds	r7, #24
 8009df0:	46bd      	mov	sp, r7
 8009df2:	bd80      	pop	{r7, pc}
 8009df4:	20000ff8 	.word	0x20000ff8
 8009df8:	20000ff4 	.word	0x20000ff4

08009dfc <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
 8009dfc:	b580      	push	{r7, lr}
 8009dfe:	b08e      	sub	sp, #56	; 0x38
 8009e00:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8009e02:	e0c6      	b.n	8009f92 <prvProcessReceivedCommands+0x196>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
 8009e04:	687b      	ldr	r3, [r7, #4]
 8009e06:	2b00      	cmp	r3, #0
 8009e08:	da17      	bge.n	8009e3a <prvProcessReceivedCommands+0x3e>
			{
				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
 8009e0a:	1d3b      	adds	r3, r7, #4
 8009e0c:	3304      	adds	r3, #4
 8009e0e:	62fb      	str	r3, [r7, #44]	; 0x2c

				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );
 8009e10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009e12:	2b00      	cmp	r3, #0
 8009e14:	d109      	bne.n	8009e2a <prvProcessReceivedCommands+0x2e>
 8009e16:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009e1a:	f383 8811 	msr	BASEPRI, r3
 8009e1e:	f3bf 8f6f 	isb	sy
 8009e22:	f3bf 8f4f 	dsb	sy
 8009e26:	61fb      	str	r3, [r7, #28]
 8009e28:	e7fe      	b.n	8009e28 <prvProcessReceivedCommands+0x2c>

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 8009e2a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009e2c:	681b      	ldr	r3, [r3, #0]
 8009e2e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009e30:	6850      	ldr	r0, [r2, #4]
 8009e32:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009e34:	6892      	ldr	r2, [r2, #8]
 8009e36:	4611      	mov	r1, r2
 8009e38:	4798      	blx	r3
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8009e3a:	687b      	ldr	r3, [r7, #4]
 8009e3c:	2b00      	cmp	r3, #0
 8009e3e:	f2c0 80a7 	blt.w	8009f90 <prvProcessReceivedCommands+0x194>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8009e42:	68fb      	ldr	r3, [r7, #12]
 8009e44:	62bb      	str	r3, [r7, #40]	; 0x28

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 8009e46:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009e48:	695b      	ldr	r3, [r3, #20]
 8009e4a:	2b00      	cmp	r3, #0
 8009e4c:	d004      	beq.n	8009e58 <prvProcessReceivedCommands+0x5c>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8009e4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009e50:	3304      	adds	r3, #4
 8009e52:	4618      	mov	r0, r3
 8009e54:	f7fd ffca 	bl	8007dec <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8009e58:	463b      	mov	r3, r7
 8009e5a:	4618      	mov	r0, r3
 8009e5c:	f7ff ff6c 	bl	8009d38 <prvSampleTimeNow>
 8009e60:	6278      	str	r0, [r7, #36]	; 0x24

			switch( xMessage.xMessageID )
 8009e62:	687b      	ldr	r3, [r7, #4]
 8009e64:	2b09      	cmp	r3, #9
 8009e66:	f200 8094 	bhi.w	8009f92 <prvProcessReceivedCommands+0x196>
 8009e6a:	a201      	add	r2, pc, #4	; (adr r2, 8009e70 <prvProcessReceivedCommands+0x74>)
 8009e6c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009e70:	08009e99 	.word	0x08009e99
 8009e74:	08009e99 	.word	0x08009e99
 8009e78:	08009e99 	.word	0x08009e99
 8009e7c:	08009f0b 	.word	0x08009f0b
 8009e80:	08009f1f 	.word	0x08009f1f
 8009e84:	08009f67 	.word	0x08009f67
 8009e88:	08009e99 	.word	0x08009e99
 8009e8c:	08009e99 	.word	0x08009e99
 8009e90:	08009f0b 	.word	0x08009f0b
 8009e94:	08009f1f 	.word	0x08009f1f
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8009e98:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009e9a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8009e9e:	f043 0301 	orr.w	r3, r3, #1
 8009ea2:	b2da      	uxtb	r2, r3
 8009ea4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009ea6:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8009eaa:	68ba      	ldr	r2, [r7, #8]
 8009eac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009eae:	699b      	ldr	r3, [r3, #24]
 8009eb0:	18d1      	adds	r1, r2, r3
 8009eb2:	68bb      	ldr	r3, [r7, #8]
 8009eb4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009eb6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8009eb8:	f7ff ff5e 	bl	8009d78 <prvInsertTimerInActiveList>
 8009ebc:	4603      	mov	r3, r0
 8009ebe:	2b00      	cmp	r3, #0
 8009ec0:	d067      	beq.n	8009f92 <prvProcessReceivedCommands+0x196>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8009ec2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009ec4:	6a1b      	ldr	r3, [r3, #32]
 8009ec6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8009ec8:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8009eca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009ecc:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8009ed0:	f003 0304 	and.w	r3, r3, #4
 8009ed4:	2b00      	cmp	r3, #0
 8009ed6:	d05c      	beq.n	8009f92 <prvProcessReceivedCommands+0x196>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8009ed8:	68ba      	ldr	r2, [r7, #8]
 8009eda:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009edc:	699b      	ldr	r3, [r3, #24]
 8009ede:	441a      	add	r2, r3
 8009ee0:	2300      	movs	r3, #0
 8009ee2:	9300      	str	r3, [sp, #0]
 8009ee4:	2300      	movs	r3, #0
 8009ee6:	2100      	movs	r1, #0
 8009ee8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8009eea:	f7ff fe09 	bl	8009b00 <xTimerGenericCommand>
 8009eee:	6238      	str	r0, [r7, #32]
							configASSERT( xResult );
 8009ef0:	6a3b      	ldr	r3, [r7, #32]
 8009ef2:	2b00      	cmp	r3, #0
 8009ef4:	d14d      	bne.n	8009f92 <prvProcessReceivedCommands+0x196>
 8009ef6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009efa:	f383 8811 	msr	BASEPRI, r3
 8009efe:	f3bf 8f6f 	isb	sy
 8009f02:	f3bf 8f4f 	dsb	sy
 8009f06:	61bb      	str	r3, [r7, #24]
 8009f08:	e7fe      	b.n	8009f08 <prvProcessReceivedCommands+0x10c>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8009f0a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f0c:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8009f10:	f023 0301 	bic.w	r3, r3, #1
 8009f14:	b2da      	uxtb	r2, r3
 8009f16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f18:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
					break;
 8009f1c:	e039      	b.n	8009f92 <prvProcessReceivedCommands+0x196>

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8009f1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f20:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8009f24:	f043 0301 	orr.w	r3, r3, #1
 8009f28:	b2da      	uxtb	r2, r3
 8009f2a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f2c:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8009f30:	68ba      	ldr	r2, [r7, #8]
 8009f32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f34:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8009f36:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f38:	699b      	ldr	r3, [r3, #24]
 8009f3a:	2b00      	cmp	r3, #0
 8009f3c:	d109      	bne.n	8009f52 <prvProcessReceivedCommands+0x156>
 8009f3e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009f42:	f383 8811 	msr	BASEPRI, r3
 8009f46:	f3bf 8f6f 	isb	sy
 8009f4a:	f3bf 8f4f 	dsb	sy
 8009f4e:	617b      	str	r3, [r7, #20]
 8009f50:	e7fe      	b.n	8009f50 <prvProcessReceivedCommands+0x154>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8009f52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f54:	699a      	ldr	r2, [r3, #24]
 8009f56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009f58:	18d1      	adds	r1, r2, r3
 8009f5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009f5c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009f5e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8009f60:	f7ff ff0a 	bl	8009d78 <prvInsertTimerInActiveList>
					break;
 8009f64:	e015      	b.n	8009f92 <prvProcessReceivedCommands+0x196>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 8009f66:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f68:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8009f6c:	f003 0302 	and.w	r3, r3, #2
 8009f70:	2b00      	cmp	r3, #0
 8009f72:	d103      	bne.n	8009f7c <prvProcessReceivedCommands+0x180>
						{
							vPortFree( pxTimer );
 8009f74:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8009f76:	f000 fbc5 	bl	800a704 <vPortFree>
 8009f7a:	e00a      	b.n	8009f92 <prvProcessReceivedCommands+0x196>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8009f7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f7e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8009f82:	f023 0301 	bic.w	r3, r3, #1
 8009f86:	b2da      	uxtb	r2, r3
 8009f88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f8a:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
						no need to free the memory - just mark the timer as
						"not active". */
						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
 8009f8e:	e000      	b.n	8009f92 <prvProcessReceivedCommands+0x196>

				default	:
					/* Don't expect to get here. */
					break;
			}
		}
 8009f90:	bf00      	nop
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8009f92:	4b07      	ldr	r3, [pc, #28]	; (8009fb0 <prvProcessReceivedCommands+0x1b4>)
 8009f94:	681b      	ldr	r3, [r3, #0]
 8009f96:	1d39      	adds	r1, r7, #4
 8009f98:	2200      	movs	r2, #0
 8009f9a:	4618      	mov	r0, r3
 8009f9c:	f7fe fa66 	bl	800846c <xQueueReceive>
 8009fa0:	4603      	mov	r3, r0
 8009fa2:	2b00      	cmp	r3, #0
 8009fa4:	f47f af2e 	bne.w	8009e04 <prvProcessReceivedCommands+0x8>
	}
}
 8009fa8:	bf00      	nop
 8009faa:	3730      	adds	r7, #48	; 0x30
 8009fac:	46bd      	mov	sp, r7
 8009fae:	bd80      	pop	{r7, pc}
 8009fb0:	20000ffc 	.word	0x20000ffc

08009fb4 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 8009fb4:	b580      	push	{r7, lr}
 8009fb6:	b088      	sub	sp, #32
 8009fb8:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8009fba:	e047      	b.n	800a04c <prvSwitchTimerLists+0x98>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8009fbc:	4b2d      	ldr	r3, [pc, #180]	; (800a074 <prvSwitchTimerLists+0xc0>)
 8009fbe:	681b      	ldr	r3, [r3, #0]
 8009fc0:	68db      	ldr	r3, [r3, #12]
 8009fc2:	681b      	ldr	r3, [r3, #0]
 8009fc4:	613b      	str	r3, [r7, #16]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8009fc6:	4b2b      	ldr	r3, [pc, #172]	; (800a074 <prvSwitchTimerLists+0xc0>)
 8009fc8:	681b      	ldr	r3, [r3, #0]
 8009fca:	68db      	ldr	r3, [r3, #12]
 8009fcc:	68db      	ldr	r3, [r3, #12]
 8009fce:	60fb      	str	r3, [r7, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8009fd0:	68fb      	ldr	r3, [r7, #12]
 8009fd2:	3304      	adds	r3, #4
 8009fd4:	4618      	mov	r0, r3
 8009fd6:	f7fd ff09 	bl	8007dec <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8009fda:	68fb      	ldr	r3, [r7, #12]
 8009fdc:	6a1b      	ldr	r3, [r3, #32]
 8009fde:	68f8      	ldr	r0, [r7, #12]
 8009fe0:	4798      	blx	r3

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8009fe2:	68fb      	ldr	r3, [r7, #12]
 8009fe4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8009fe8:	f003 0304 	and.w	r3, r3, #4
 8009fec:	2b00      	cmp	r3, #0
 8009fee:	d02d      	beq.n	800a04c <prvSwitchTimerLists+0x98>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8009ff0:	68fb      	ldr	r3, [r7, #12]
 8009ff2:	699b      	ldr	r3, [r3, #24]
 8009ff4:	693a      	ldr	r2, [r7, #16]
 8009ff6:	4413      	add	r3, r2
 8009ff8:	60bb      	str	r3, [r7, #8]
			if( xReloadTime > xNextExpireTime )
 8009ffa:	68ba      	ldr	r2, [r7, #8]
 8009ffc:	693b      	ldr	r3, [r7, #16]
 8009ffe:	429a      	cmp	r2, r3
 800a000:	d90e      	bls.n	800a020 <prvSwitchTimerLists+0x6c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 800a002:	68fb      	ldr	r3, [r7, #12]
 800a004:	68ba      	ldr	r2, [r7, #8]
 800a006:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800a008:	68fb      	ldr	r3, [r7, #12]
 800a00a:	68fa      	ldr	r2, [r7, #12]
 800a00c:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800a00e:	4b19      	ldr	r3, [pc, #100]	; (800a074 <prvSwitchTimerLists+0xc0>)
 800a010:	681a      	ldr	r2, [r3, #0]
 800a012:	68fb      	ldr	r3, [r7, #12]
 800a014:	3304      	adds	r3, #4
 800a016:	4619      	mov	r1, r3
 800a018:	4610      	mov	r0, r2
 800a01a:	f7fd feae 	bl	8007d7a <vListInsert>
 800a01e:	e015      	b.n	800a04c <prvSwitchTimerLists+0x98>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 800a020:	2300      	movs	r3, #0
 800a022:	9300      	str	r3, [sp, #0]
 800a024:	2300      	movs	r3, #0
 800a026:	693a      	ldr	r2, [r7, #16]
 800a028:	2100      	movs	r1, #0
 800a02a:	68f8      	ldr	r0, [r7, #12]
 800a02c:	f7ff fd68 	bl	8009b00 <xTimerGenericCommand>
 800a030:	6078      	str	r0, [r7, #4]
				configASSERT( xResult );
 800a032:	687b      	ldr	r3, [r7, #4]
 800a034:	2b00      	cmp	r3, #0
 800a036:	d109      	bne.n	800a04c <prvSwitchTimerLists+0x98>
 800a038:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a03c:	f383 8811 	msr	BASEPRI, r3
 800a040:	f3bf 8f6f 	isb	sy
 800a044:	f3bf 8f4f 	dsb	sy
 800a048:	603b      	str	r3, [r7, #0]
 800a04a:	e7fe      	b.n	800a04a <prvSwitchTimerLists+0x96>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800a04c:	4b09      	ldr	r3, [pc, #36]	; (800a074 <prvSwitchTimerLists+0xc0>)
 800a04e:	681b      	ldr	r3, [r3, #0]
 800a050:	681b      	ldr	r3, [r3, #0]
 800a052:	2b00      	cmp	r3, #0
 800a054:	d1b2      	bne.n	8009fbc <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
 800a056:	4b07      	ldr	r3, [pc, #28]	; (800a074 <prvSwitchTimerLists+0xc0>)
 800a058:	681b      	ldr	r3, [r3, #0]
 800a05a:	617b      	str	r3, [r7, #20]
	pxCurrentTimerList = pxOverflowTimerList;
 800a05c:	4b06      	ldr	r3, [pc, #24]	; (800a078 <prvSwitchTimerLists+0xc4>)
 800a05e:	681b      	ldr	r3, [r3, #0]
 800a060:	4a04      	ldr	r2, [pc, #16]	; (800a074 <prvSwitchTimerLists+0xc0>)
 800a062:	6013      	str	r3, [r2, #0]
	pxOverflowTimerList = pxTemp;
 800a064:	4a04      	ldr	r2, [pc, #16]	; (800a078 <prvSwitchTimerLists+0xc4>)
 800a066:	697b      	ldr	r3, [r7, #20]
 800a068:	6013      	str	r3, [r2, #0]
}
 800a06a:	bf00      	nop
 800a06c:	3718      	adds	r7, #24
 800a06e:	46bd      	mov	sp, r7
 800a070:	bd80      	pop	{r7, pc}
 800a072:	bf00      	nop
 800a074:	20000ff4 	.word	0x20000ff4
 800a078:	20000ff8 	.word	0x20000ff8

0800a07c <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 800a07c:	b580      	push	{r7, lr}
 800a07e:	b082      	sub	sp, #8
 800a080:	af02      	add	r7, sp, #8
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 800a082:	f000 f963 	bl	800a34c <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 800a086:	4b15      	ldr	r3, [pc, #84]	; (800a0dc <prvCheckForValidListAndQueue+0x60>)
 800a088:	681b      	ldr	r3, [r3, #0]
 800a08a:	2b00      	cmp	r3, #0
 800a08c:	d120      	bne.n	800a0d0 <prvCheckForValidListAndQueue+0x54>
		{
			vListInitialise( &xActiveTimerList1 );
 800a08e:	4814      	ldr	r0, [pc, #80]	; (800a0e0 <prvCheckForValidListAndQueue+0x64>)
 800a090:	f7fd fe22 	bl	8007cd8 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 800a094:	4813      	ldr	r0, [pc, #76]	; (800a0e4 <prvCheckForValidListAndQueue+0x68>)
 800a096:	f7fd fe1f 	bl	8007cd8 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 800a09a:	4b13      	ldr	r3, [pc, #76]	; (800a0e8 <prvCheckForValidListAndQueue+0x6c>)
 800a09c:	4a10      	ldr	r2, [pc, #64]	; (800a0e0 <prvCheckForValidListAndQueue+0x64>)
 800a09e:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 800a0a0:	4b12      	ldr	r3, [pc, #72]	; (800a0ec <prvCheckForValidListAndQueue+0x70>)
 800a0a2:	4a10      	ldr	r2, [pc, #64]	; (800a0e4 <prvCheckForValidListAndQueue+0x68>)
 800a0a4:	601a      	str	r2, [r3, #0]
				/* The timer queue is allocated statically in case
				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 800a0a6:	2300      	movs	r3, #0
 800a0a8:	9300      	str	r3, [sp, #0]
 800a0aa:	4b11      	ldr	r3, [pc, #68]	; (800a0f0 <prvCheckForValidListAndQueue+0x74>)
 800a0ac:	4a11      	ldr	r2, [pc, #68]	; (800a0f4 <prvCheckForValidListAndQueue+0x78>)
 800a0ae:	2110      	movs	r1, #16
 800a0b0:	200a      	movs	r0, #10
 800a0b2:	f7fd ff2d 	bl	8007f10 <xQueueGenericCreateStatic>
 800a0b6:	4602      	mov	r2, r0
 800a0b8:	4b08      	ldr	r3, [pc, #32]	; (800a0dc <prvCheckForValidListAndQueue+0x60>)
 800a0ba:	601a      	str	r2, [r3, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
 800a0bc:	4b07      	ldr	r3, [pc, #28]	; (800a0dc <prvCheckForValidListAndQueue+0x60>)
 800a0be:	681b      	ldr	r3, [r3, #0]
 800a0c0:	2b00      	cmp	r3, #0
 800a0c2:	d005      	beq.n	800a0d0 <prvCheckForValidListAndQueue+0x54>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 800a0c4:	4b05      	ldr	r3, [pc, #20]	; (800a0dc <prvCheckForValidListAndQueue+0x60>)
 800a0c6:	681b      	ldr	r3, [r3, #0]
 800a0c8:	490b      	ldr	r1, [pc, #44]	; (800a0f8 <prvCheckForValidListAndQueue+0x7c>)
 800a0ca:	4618      	mov	r0, r3
 800a0cc:	f7fe fbba 	bl	8008844 <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800a0d0:	f000 f96a 	bl	800a3a8 <vPortExitCritical>
}
 800a0d4:	bf00      	nop
 800a0d6:	46bd      	mov	sp, r7
 800a0d8:	bd80      	pop	{r7, pc}
 800a0da:	bf00      	nop
 800a0dc:	20000ffc 	.word	0x20000ffc
 800a0e0:	20000fcc 	.word	0x20000fcc
 800a0e4:	20000fe0 	.word	0x20000fe0
 800a0e8:	20000ff4 	.word	0x20000ff4
 800a0ec:	20000ff8 	.word	0x20000ff8
 800a0f0:	200010a8 	.word	0x200010a8
 800a0f4:	20001008 	.word	0x20001008
 800a0f8:	08028c28 	.word	0x08028c28

0800a0fc <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 800a0fc:	b480      	push	{r7}
 800a0fe:	b085      	sub	sp, #20
 800a100:	af00      	add	r7, sp, #0
 800a102:	60f8      	str	r0, [r7, #12]
 800a104:	60b9      	str	r1, [r7, #8]
 800a106:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
 800a108:	68fb      	ldr	r3, [r7, #12]
 800a10a:	3b04      	subs	r3, #4
 800a10c:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800a10e:	68fb      	ldr	r3, [r7, #12]
 800a110:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800a114:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 800a116:	68fb      	ldr	r3, [r7, #12]
 800a118:	3b04      	subs	r3, #4
 800a11a:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 800a11c:	68bb      	ldr	r3, [r7, #8]
 800a11e:	f023 0201 	bic.w	r2, r3, #1
 800a122:	68fb      	ldr	r3, [r7, #12]
 800a124:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 800a126:	68fb      	ldr	r3, [r7, #12]
 800a128:	3b04      	subs	r3, #4
 800a12a:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800a12c:	4a0c      	ldr	r2, [pc, #48]	; (800a160 <pxPortInitialiseStack+0x64>)
 800a12e:	68fb      	ldr	r3, [r7, #12]
 800a130:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 800a132:	68fb      	ldr	r3, [r7, #12]
 800a134:	3b14      	subs	r3, #20
 800a136:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800a138:	687a      	ldr	r2, [r7, #4]
 800a13a:	68fb      	ldr	r3, [r7, #12]
 800a13c:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
 800a13e:	68fb      	ldr	r3, [r7, #12]
 800a140:	3b04      	subs	r3, #4
 800a142:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 800a144:	68fb      	ldr	r3, [r7, #12]
 800a146:	f06f 0202 	mvn.w	r2, #2
 800a14a:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 800a14c:	68fb      	ldr	r3, [r7, #12]
 800a14e:	3b20      	subs	r3, #32
 800a150:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 800a152:	68fb      	ldr	r3, [r7, #12]
}
 800a154:	4618      	mov	r0, r3
 800a156:	3714      	adds	r7, #20
 800a158:	46bd      	mov	sp, r7
 800a15a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a15e:	4770      	bx	lr
 800a160:	0800a165 	.word	0x0800a165

0800a164 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 800a164:	b480      	push	{r7}
 800a166:	b085      	sub	sp, #20
 800a168:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0;
 800a16a:	2300      	movs	r3, #0
 800a16c:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800a16e:	4b11      	ldr	r3, [pc, #68]	; (800a1b4 <prvTaskExitError+0x50>)
 800a170:	681b      	ldr	r3, [r3, #0]
 800a172:	f1b3 3fff 	cmp.w	r3, #4294967295
 800a176:	d009      	beq.n	800a18c <prvTaskExitError+0x28>
 800a178:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a17c:	f383 8811 	msr	BASEPRI, r3
 800a180:	f3bf 8f6f 	isb	sy
 800a184:	f3bf 8f4f 	dsb	sy
 800a188:	60fb      	str	r3, [r7, #12]
 800a18a:	e7fe      	b.n	800a18a <prvTaskExitError+0x26>
 800a18c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a190:	f383 8811 	msr	BASEPRI, r3
 800a194:	f3bf 8f6f 	isb	sy
 800a198:	f3bf 8f4f 	dsb	sy
 800a19c:	60bb      	str	r3, [r7, #8]
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 800a19e:	bf00      	nop
 800a1a0:	687b      	ldr	r3, [r7, #4]
 800a1a2:	2b00      	cmp	r3, #0
 800a1a4:	d0fc      	beq.n	800a1a0 <prvTaskExitError+0x3c>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 800a1a6:	bf00      	nop
 800a1a8:	3714      	adds	r7, #20
 800a1aa:	46bd      	mov	sp, r7
 800a1ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a1b0:	4770      	bx	lr
 800a1b2:	bf00      	nop
 800a1b4:	20000014 	.word	0x20000014
	...

0800a1c0 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 800a1c0:	4b07      	ldr	r3, [pc, #28]	; (800a1e0 <pxCurrentTCBConst2>)
 800a1c2:	6819      	ldr	r1, [r3, #0]
 800a1c4:	6808      	ldr	r0, [r1, #0]
 800a1c6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a1ca:	f380 8809 	msr	PSP, r0
 800a1ce:	f3bf 8f6f 	isb	sy
 800a1d2:	f04f 0000 	mov.w	r0, #0
 800a1d6:	f380 8811 	msr	BASEPRI, r0
 800a1da:	4770      	bx	lr
 800a1dc:	f3af 8000 	nop.w

0800a1e0 <pxCurrentTCBConst2>:
 800a1e0:	20000acc 	.word	0x20000acc
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
 800a1e4:	bf00      	nop
 800a1e6:	bf00      	nop

0800a1e8 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 800a1e8:	4808      	ldr	r0, [pc, #32]	; (800a20c <prvPortStartFirstTask+0x24>)
 800a1ea:	6800      	ldr	r0, [r0, #0]
 800a1ec:	6800      	ldr	r0, [r0, #0]
 800a1ee:	f380 8808 	msr	MSP, r0
 800a1f2:	f04f 0000 	mov.w	r0, #0
 800a1f6:	f380 8814 	msr	CONTROL, r0
 800a1fa:	b662      	cpsie	i
 800a1fc:	b661      	cpsie	f
 800a1fe:	f3bf 8f4f 	dsb	sy
 800a202:	f3bf 8f6f 	isb	sy
 800a206:	df00      	svc	0
 800a208:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 800a20a:	bf00      	nop
 800a20c:	e000ed08 	.word	0xe000ed08

0800a210 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 800a210:	b580      	push	{r7, lr}
 800a212:	b086      	sub	sp, #24
 800a214:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* This port can be used on all revisions of the Cortex-M7 core other than
	the r0p1 parts.  r0p1 parts should use the port from the
	/source/portable/GCC/ARM_CM7/r0p1 directory. */
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 800a216:	4b44      	ldr	r3, [pc, #272]	; (800a328 <xPortStartScheduler+0x118>)
 800a218:	681b      	ldr	r3, [r3, #0]
 800a21a:	4a44      	ldr	r2, [pc, #272]	; (800a32c <xPortStartScheduler+0x11c>)
 800a21c:	4293      	cmp	r3, r2
 800a21e:	d109      	bne.n	800a234 <xPortStartScheduler+0x24>
 800a220:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a224:	f383 8811 	msr	BASEPRI, r3
 800a228:	f3bf 8f6f 	isb	sy
 800a22c:	f3bf 8f4f 	dsb	sy
 800a230:	613b      	str	r3, [r7, #16]
 800a232:	e7fe      	b.n	800a232 <xPortStartScheduler+0x22>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 800a234:	4b3c      	ldr	r3, [pc, #240]	; (800a328 <xPortStartScheduler+0x118>)
 800a236:	681b      	ldr	r3, [r3, #0]
 800a238:	4a3d      	ldr	r2, [pc, #244]	; (800a330 <xPortStartScheduler+0x120>)
 800a23a:	4293      	cmp	r3, r2
 800a23c:	d109      	bne.n	800a252 <xPortStartScheduler+0x42>
 800a23e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a242:	f383 8811 	msr	BASEPRI, r3
 800a246:	f3bf 8f6f 	isb	sy
 800a24a:	f3bf 8f4f 	dsb	sy
 800a24e:	60fb      	str	r3, [r7, #12]
 800a250:	e7fe      	b.n	800a250 <xPortStartScheduler+0x40>

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
 800a252:	4b38      	ldr	r3, [pc, #224]	; (800a334 <xPortStartScheduler+0x124>)
 800a254:	617b      	str	r3, [r7, #20]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800a256:	697b      	ldr	r3, [r7, #20]
 800a258:	781b      	ldrb	r3, [r3, #0]
 800a25a:	b2db      	uxtb	r3, r3
 800a25c:	607b      	str	r3, [r7, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800a25e:	697b      	ldr	r3, [r7, #20]
 800a260:	22ff      	movs	r2, #255	; 0xff
 800a262:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800a264:	697b      	ldr	r3, [r7, #20]
 800a266:	781b      	ldrb	r3, [r3, #0]
 800a268:	b2db      	uxtb	r3, r3
 800a26a:	70fb      	strb	r3, [r7, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800a26c:	78fb      	ldrb	r3, [r7, #3]
 800a26e:	b2db      	uxtb	r3, r3
 800a270:	f003 0350 	and.w	r3, r3, #80	; 0x50
 800a274:	b2da      	uxtb	r2, r3
 800a276:	4b30      	ldr	r3, [pc, #192]	; (800a338 <xPortStartScheduler+0x128>)
 800a278:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800a27a:	4b30      	ldr	r3, [pc, #192]	; (800a33c <xPortStartScheduler+0x12c>)
 800a27c:	2207      	movs	r2, #7
 800a27e:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800a280:	e009      	b.n	800a296 <xPortStartScheduler+0x86>
		{
			ulMaxPRIGROUPValue--;
 800a282:	4b2e      	ldr	r3, [pc, #184]	; (800a33c <xPortStartScheduler+0x12c>)
 800a284:	681b      	ldr	r3, [r3, #0]
 800a286:	3b01      	subs	r3, #1
 800a288:	4a2c      	ldr	r2, [pc, #176]	; (800a33c <xPortStartScheduler+0x12c>)
 800a28a:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800a28c:	78fb      	ldrb	r3, [r7, #3]
 800a28e:	b2db      	uxtb	r3, r3
 800a290:	005b      	lsls	r3, r3, #1
 800a292:	b2db      	uxtb	r3, r3
 800a294:	70fb      	strb	r3, [r7, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800a296:	78fb      	ldrb	r3, [r7, #3]
 800a298:	b2db      	uxtb	r3, r3
 800a29a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a29e:	2b80      	cmp	r3, #128	; 0x80
 800a2a0:	d0ef      	beq.n	800a282 <xPortStartScheduler+0x72>
		#ifdef configPRIO_BITS
		{
			/* Check the FreeRTOS configuration that defines the number of
			priority bits matches the number of priority bits actually queried
			from the hardware. */
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 800a2a2:	4b26      	ldr	r3, [pc, #152]	; (800a33c <xPortStartScheduler+0x12c>)
 800a2a4:	681b      	ldr	r3, [r3, #0]
 800a2a6:	f1c3 0307 	rsb	r3, r3, #7
 800a2aa:	2b04      	cmp	r3, #4
 800a2ac:	d009      	beq.n	800a2c2 <xPortStartScheduler+0xb2>
 800a2ae:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a2b2:	f383 8811 	msr	BASEPRI, r3
 800a2b6:	f3bf 8f6f 	isb	sy
 800a2ba:	f3bf 8f4f 	dsb	sy
 800a2be:	60bb      	str	r3, [r7, #8]
 800a2c0:	e7fe      	b.n	800a2c0 <xPortStartScheduler+0xb0>
		}
		#endif

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 800a2c2:	4b1e      	ldr	r3, [pc, #120]	; (800a33c <xPortStartScheduler+0x12c>)
 800a2c4:	681b      	ldr	r3, [r3, #0]
 800a2c6:	021b      	lsls	r3, r3, #8
 800a2c8:	4a1c      	ldr	r2, [pc, #112]	; (800a33c <xPortStartScheduler+0x12c>)
 800a2ca:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800a2cc:	4b1b      	ldr	r3, [pc, #108]	; (800a33c <xPortStartScheduler+0x12c>)
 800a2ce:	681b      	ldr	r3, [r3, #0]
 800a2d0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800a2d4:	4a19      	ldr	r2, [pc, #100]	; (800a33c <xPortStartScheduler+0x12c>)
 800a2d6:	6013      	str	r3, [r2, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 800a2d8:	687b      	ldr	r3, [r7, #4]
 800a2da:	b2da      	uxtb	r2, r3
 800a2dc:	697b      	ldr	r3, [r7, #20]
 800a2de:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800a2e0:	4b17      	ldr	r3, [pc, #92]	; (800a340 <xPortStartScheduler+0x130>)
 800a2e2:	681b      	ldr	r3, [r3, #0]
 800a2e4:	4a16      	ldr	r2, [pc, #88]	; (800a340 <xPortStartScheduler+0x130>)
 800a2e6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800a2ea:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 800a2ec:	4b14      	ldr	r3, [pc, #80]	; (800a340 <xPortStartScheduler+0x130>)
 800a2ee:	681b      	ldr	r3, [r3, #0]
 800a2f0:	4a13      	ldr	r2, [pc, #76]	; (800a340 <xPortStartScheduler+0x130>)
 800a2f2:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
 800a2f6:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 800a2f8:	f000 f8d6 	bl	800a4a8 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 800a2fc:	4b11      	ldr	r3, [pc, #68]	; (800a344 <xPortStartScheduler+0x134>)
 800a2fe:	2200      	movs	r2, #0
 800a300:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 800a302:	f000 f8f5 	bl	800a4f0 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 800a306:	4b10      	ldr	r3, [pc, #64]	; (800a348 <xPortStartScheduler+0x138>)
 800a308:	681b      	ldr	r3, [r3, #0]
 800a30a:	4a0f      	ldr	r2, [pc, #60]	; (800a348 <xPortStartScheduler+0x138>)
 800a30c:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 800a310:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 800a312:	f7ff ff69 	bl	800a1e8 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
 800a316:	f7ff f81d 	bl	8009354 <vTaskSwitchContext>
	prvTaskExitError();
 800a31a:	f7ff ff23 	bl	800a164 <prvTaskExitError>

	/* Should not get here! */
	return 0;
 800a31e:	2300      	movs	r3, #0
}
 800a320:	4618      	mov	r0, r3
 800a322:	3718      	adds	r7, #24
 800a324:	46bd      	mov	sp, r7
 800a326:	bd80      	pop	{r7, pc}
 800a328:	e000ed00 	.word	0xe000ed00
 800a32c:	410fc271 	.word	0x410fc271
 800a330:	410fc270 	.word	0x410fc270
 800a334:	e000e400 	.word	0xe000e400
 800a338:	200010f8 	.word	0x200010f8
 800a33c:	200010fc 	.word	0x200010fc
 800a340:	e000ed20 	.word	0xe000ed20
 800a344:	20000014 	.word	0x20000014
 800a348:	e000ef34 	.word	0xe000ef34

0800a34c <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 800a34c:	b480      	push	{r7}
 800a34e:	b083      	sub	sp, #12
 800a350:	af00      	add	r7, sp, #0
 800a352:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a356:	f383 8811 	msr	BASEPRI, r3
 800a35a:	f3bf 8f6f 	isb	sy
 800a35e:	f3bf 8f4f 	dsb	sy
 800a362:	607b      	str	r3, [r7, #4]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 800a364:	4b0e      	ldr	r3, [pc, #56]	; (800a3a0 <vPortEnterCritical+0x54>)
 800a366:	681b      	ldr	r3, [r3, #0]
 800a368:	3301      	adds	r3, #1
 800a36a:	4a0d      	ldr	r2, [pc, #52]	; (800a3a0 <vPortEnterCritical+0x54>)
 800a36c:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 800a36e:	4b0c      	ldr	r3, [pc, #48]	; (800a3a0 <vPortEnterCritical+0x54>)
 800a370:	681b      	ldr	r3, [r3, #0]
 800a372:	2b01      	cmp	r3, #1
 800a374:	d10e      	bne.n	800a394 <vPortEnterCritical+0x48>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 800a376:	4b0b      	ldr	r3, [pc, #44]	; (800a3a4 <vPortEnterCritical+0x58>)
 800a378:	681b      	ldr	r3, [r3, #0]
 800a37a:	b2db      	uxtb	r3, r3
 800a37c:	2b00      	cmp	r3, #0
 800a37e:	d009      	beq.n	800a394 <vPortEnterCritical+0x48>
 800a380:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a384:	f383 8811 	msr	BASEPRI, r3
 800a388:	f3bf 8f6f 	isb	sy
 800a38c:	f3bf 8f4f 	dsb	sy
 800a390:	603b      	str	r3, [r7, #0]
 800a392:	e7fe      	b.n	800a392 <vPortEnterCritical+0x46>
	}
}
 800a394:	bf00      	nop
 800a396:	370c      	adds	r7, #12
 800a398:	46bd      	mov	sp, r7
 800a39a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a39e:	4770      	bx	lr
 800a3a0:	20000014 	.word	0x20000014
 800a3a4:	e000ed04 	.word	0xe000ed04

0800a3a8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 800a3a8:	b480      	push	{r7}
 800a3aa:	b083      	sub	sp, #12
 800a3ac:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
 800a3ae:	4b11      	ldr	r3, [pc, #68]	; (800a3f4 <vPortExitCritical+0x4c>)
 800a3b0:	681b      	ldr	r3, [r3, #0]
 800a3b2:	2b00      	cmp	r3, #0
 800a3b4:	d109      	bne.n	800a3ca <vPortExitCritical+0x22>
 800a3b6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a3ba:	f383 8811 	msr	BASEPRI, r3
 800a3be:	f3bf 8f6f 	isb	sy
 800a3c2:	f3bf 8f4f 	dsb	sy
 800a3c6:	607b      	str	r3, [r7, #4]
 800a3c8:	e7fe      	b.n	800a3c8 <vPortExitCritical+0x20>
	uxCriticalNesting--;
 800a3ca:	4b0a      	ldr	r3, [pc, #40]	; (800a3f4 <vPortExitCritical+0x4c>)
 800a3cc:	681b      	ldr	r3, [r3, #0]
 800a3ce:	3b01      	subs	r3, #1
 800a3d0:	4a08      	ldr	r2, [pc, #32]	; (800a3f4 <vPortExitCritical+0x4c>)
 800a3d2:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 800a3d4:	4b07      	ldr	r3, [pc, #28]	; (800a3f4 <vPortExitCritical+0x4c>)
 800a3d6:	681b      	ldr	r3, [r3, #0]
 800a3d8:	2b00      	cmp	r3, #0
 800a3da:	d104      	bne.n	800a3e6 <vPortExitCritical+0x3e>
 800a3dc:	2300      	movs	r3, #0
 800a3de:	603b      	str	r3, [r7, #0]
	__asm volatile
 800a3e0:	683b      	ldr	r3, [r7, #0]
 800a3e2:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
 800a3e6:	bf00      	nop
 800a3e8:	370c      	adds	r7, #12
 800a3ea:	46bd      	mov	sp, r7
 800a3ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a3f0:	4770      	bx	lr
 800a3f2:	bf00      	nop
 800a3f4:	20000014 	.word	0x20000014
	...

0800a400 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800a400:	f3ef 8009 	mrs	r0, PSP
 800a404:	f3bf 8f6f 	isb	sy
 800a408:	4b15      	ldr	r3, [pc, #84]	; (800a460 <pxCurrentTCBConst>)
 800a40a:	681a      	ldr	r2, [r3, #0]
 800a40c:	f01e 0f10 	tst.w	lr, #16
 800a410:	bf08      	it	eq
 800a412:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 800a416:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a41a:	6010      	str	r0, [r2, #0]
 800a41c:	e92d 0009 	stmdb	sp!, {r0, r3}
 800a420:	f04f 0050 	mov.w	r0, #80	; 0x50
 800a424:	f380 8811 	msr	BASEPRI, r0
 800a428:	f3bf 8f4f 	dsb	sy
 800a42c:	f3bf 8f6f 	isb	sy
 800a430:	f7fe ff90 	bl	8009354 <vTaskSwitchContext>
 800a434:	f04f 0000 	mov.w	r0, #0
 800a438:	f380 8811 	msr	BASEPRI, r0
 800a43c:	bc09      	pop	{r0, r3}
 800a43e:	6819      	ldr	r1, [r3, #0]
 800a440:	6808      	ldr	r0, [r1, #0]
 800a442:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a446:	f01e 0f10 	tst.w	lr, #16
 800a44a:	bf08      	it	eq
 800a44c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 800a450:	f380 8809 	msr	PSP, r0
 800a454:	f3bf 8f6f 	isb	sy
 800a458:	4770      	bx	lr
 800a45a:	bf00      	nop
 800a45c:	f3af 8000 	nop.w

0800a460 <pxCurrentTCBConst>:
 800a460:	20000acc 	.word	0x20000acc
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
 800a464:	bf00      	nop
 800a466:	bf00      	nop

0800a468 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800a468:	b580      	push	{r7, lr}
 800a46a:	b082      	sub	sp, #8
 800a46c:	af00      	add	r7, sp, #0
	__asm volatile
 800a46e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a472:	f383 8811 	msr	BASEPRI, r3
 800a476:	f3bf 8f6f 	isb	sy
 800a47a:	f3bf 8f4f 	dsb	sy
 800a47e:	607b      	str	r3, [r7, #4]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800a480:	f7fe feb0 	bl	80091e4 <xTaskIncrementTick>
 800a484:	4603      	mov	r3, r0
 800a486:	2b00      	cmp	r3, #0
 800a488:	d003      	beq.n	800a492 <SysTick_Handler+0x2a>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800a48a:	4b06      	ldr	r3, [pc, #24]	; (800a4a4 <SysTick_Handler+0x3c>)
 800a48c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a490:	601a      	str	r2, [r3, #0]
 800a492:	2300      	movs	r3, #0
 800a494:	603b      	str	r3, [r7, #0]
	__asm volatile
 800a496:	683b      	ldr	r3, [r7, #0]
 800a498:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
 800a49c:	bf00      	nop
 800a49e:	3708      	adds	r7, #8
 800a4a0:	46bd      	mov	sp, r7
 800a4a2:	bd80      	pop	{r7, pc}
 800a4a4:	e000ed04 	.word	0xe000ed04

0800a4a8 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
 800a4a8:	b480      	push	{r7}
 800a4aa:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 800a4ac:	4b0b      	ldr	r3, [pc, #44]	; (800a4dc <vPortSetupTimerInterrupt+0x34>)
 800a4ae:	2200      	movs	r2, #0
 800a4b0:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800a4b2:	4b0b      	ldr	r3, [pc, #44]	; (800a4e0 <vPortSetupTimerInterrupt+0x38>)
 800a4b4:	2200      	movs	r2, #0
 800a4b6:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800a4b8:	4b0a      	ldr	r3, [pc, #40]	; (800a4e4 <vPortSetupTimerInterrupt+0x3c>)
 800a4ba:	681b      	ldr	r3, [r3, #0]
 800a4bc:	4a0a      	ldr	r2, [pc, #40]	; (800a4e8 <vPortSetupTimerInterrupt+0x40>)
 800a4be:	fba2 2303 	umull	r2, r3, r2, r3
 800a4c2:	099b      	lsrs	r3, r3, #6
 800a4c4:	4a09      	ldr	r2, [pc, #36]	; (800a4ec <vPortSetupTimerInterrupt+0x44>)
 800a4c6:	3b01      	subs	r3, #1
 800a4c8:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800a4ca:	4b04      	ldr	r3, [pc, #16]	; (800a4dc <vPortSetupTimerInterrupt+0x34>)
 800a4cc:	2207      	movs	r2, #7
 800a4ce:	601a      	str	r2, [r3, #0]
}
 800a4d0:	bf00      	nop
 800a4d2:	46bd      	mov	sp, r7
 800a4d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4d8:	4770      	bx	lr
 800a4da:	bf00      	nop
 800a4dc:	e000e010 	.word	0xe000e010
 800a4e0:	e000e018 	.word	0xe000e018
 800a4e4:	20000000 	.word	0x20000000
 800a4e8:	10624dd3 	.word	0x10624dd3
 800a4ec:	e000e014 	.word	0xe000e014

0800a4f0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 800a4f0:	f8df 000c 	ldr.w	r0, [pc, #12]	; 800a500 <vPortEnableVFP+0x10>
 800a4f4:	6801      	ldr	r1, [r0, #0]
 800a4f6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800a4fa:	6001      	str	r1, [r0, #0]
 800a4fc:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 800a4fe:	bf00      	nop
 800a500:	e000ed88 	.word	0xe000ed88

0800a504 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 800a504:	b480      	push	{r7}
 800a506:	b085      	sub	sp, #20
 800a508:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 800a50a:	f3ef 8305 	mrs	r3, IPSR
 800a50e:	60fb      	str	r3, [r7, #12]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 800a510:	68fb      	ldr	r3, [r7, #12]
 800a512:	2b0f      	cmp	r3, #15
 800a514:	d913      	bls.n	800a53e <vPortValidateInterruptPriority+0x3a>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 800a516:	4a16      	ldr	r2, [pc, #88]	; (800a570 <vPortValidateInterruptPriority+0x6c>)
 800a518:	68fb      	ldr	r3, [r7, #12]
 800a51a:	4413      	add	r3, r2
 800a51c:	781b      	ldrb	r3, [r3, #0]
 800a51e:	72fb      	strb	r3, [r7, #11]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 800a520:	4b14      	ldr	r3, [pc, #80]	; (800a574 <vPortValidateInterruptPriority+0x70>)
 800a522:	781b      	ldrb	r3, [r3, #0]
 800a524:	7afa      	ldrb	r2, [r7, #11]
 800a526:	429a      	cmp	r2, r3
 800a528:	d209      	bcs.n	800a53e <vPortValidateInterruptPriority+0x3a>
	__asm volatile
 800a52a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a52e:	f383 8811 	msr	BASEPRI, r3
 800a532:	f3bf 8f6f 	isb	sy
 800a536:	f3bf 8f4f 	dsb	sy
 800a53a:	607b      	str	r3, [r7, #4]
 800a53c:	e7fe      	b.n	800a53c <vPortValidateInterruptPriority+0x38>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 800a53e:	4b0e      	ldr	r3, [pc, #56]	; (800a578 <vPortValidateInterruptPriority+0x74>)
 800a540:	681b      	ldr	r3, [r3, #0]
 800a542:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 800a546:	4b0d      	ldr	r3, [pc, #52]	; (800a57c <vPortValidateInterruptPriority+0x78>)
 800a548:	681b      	ldr	r3, [r3, #0]
 800a54a:	429a      	cmp	r2, r3
 800a54c:	d909      	bls.n	800a562 <vPortValidateInterruptPriority+0x5e>
 800a54e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a552:	f383 8811 	msr	BASEPRI, r3
 800a556:	f3bf 8f6f 	isb	sy
 800a55a:	f3bf 8f4f 	dsb	sy
 800a55e:	603b      	str	r3, [r7, #0]
 800a560:	e7fe      	b.n	800a560 <vPortValidateInterruptPriority+0x5c>
	}
 800a562:	bf00      	nop
 800a564:	3714      	adds	r7, #20
 800a566:	46bd      	mov	sp, r7
 800a568:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a56c:	4770      	bx	lr
 800a56e:	bf00      	nop
 800a570:	e000e3f0 	.word	0xe000e3f0
 800a574:	200010f8 	.word	0x200010f8
 800a578:	e000ed0c 	.word	0xe000ed0c
 800a57c:	200010fc 	.word	0x200010fc

0800a580 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 800a580:	b580      	push	{r7, lr}
 800a582:	b08a      	sub	sp, #40	; 0x28
 800a584:	af00      	add	r7, sp, #0
 800a586:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 800a588:	2300      	movs	r3, #0
 800a58a:	61fb      	str	r3, [r7, #28]

	vTaskSuspendAll();
 800a58c:	f7fe fd38 	bl	8009000 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 800a590:	4b57      	ldr	r3, [pc, #348]	; (800a6f0 <pvPortMalloc+0x170>)
 800a592:	681b      	ldr	r3, [r3, #0]
 800a594:	2b00      	cmp	r3, #0
 800a596:	d101      	bne.n	800a59c <pvPortMalloc+0x1c>
		{
			prvHeapInit();
 800a598:	f000 f90c 	bl	800a7b4 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800a59c:	4b55      	ldr	r3, [pc, #340]	; (800a6f4 <pvPortMalloc+0x174>)
 800a59e:	681a      	ldr	r2, [r3, #0]
 800a5a0:	687b      	ldr	r3, [r7, #4]
 800a5a2:	4013      	ands	r3, r2
 800a5a4:	2b00      	cmp	r3, #0
 800a5a6:	f040 808c 	bne.w	800a6c2 <pvPortMalloc+0x142>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 800a5aa:	687b      	ldr	r3, [r7, #4]
 800a5ac:	2b00      	cmp	r3, #0
 800a5ae:	d01c      	beq.n	800a5ea <pvPortMalloc+0x6a>
			{
				xWantedSize += xHeapStructSize;
 800a5b0:	2208      	movs	r2, #8
 800a5b2:	687b      	ldr	r3, [r7, #4]
 800a5b4:	4413      	add	r3, r2
 800a5b6:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800a5b8:	687b      	ldr	r3, [r7, #4]
 800a5ba:	f003 0307 	and.w	r3, r3, #7
 800a5be:	2b00      	cmp	r3, #0
 800a5c0:	d013      	beq.n	800a5ea <pvPortMalloc+0x6a>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800a5c2:	687b      	ldr	r3, [r7, #4]
 800a5c4:	f023 0307 	bic.w	r3, r3, #7
 800a5c8:	3308      	adds	r3, #8
 800a5ca:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
 800a5cc:	687b      	ldr	r3, [r7, #4]
 800a5ce:	f003 0307 	and.w	r3, r3, #7
 800a5d2:	2b00      	cmp	r3, #0
 800a5d4:	d009      	beq.n	800a5ea <pvPortMalloc+0x6a>
 800a5d6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a5da:	f383 8811 	msr	BASEPRI, r3
 800a5de:	f3bf 8f6f 	isb	sy
 800a5e2:	f3bf 8f4f 	dsb	sy
 800a5e6:	617b      	str	r3, [r7, #20]
 800a5e8:	e7fe      	b.n	800a5e8 <pvPortMalloc+0x68>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800a5ea:	687b      	ldr	r3, [r7, #4]
 800a5ec:	2b00      	cmp	r3, #0
 800a5ee:	d068      	beq.n	800a6c2 <pvPortMalloc+0x142>
 800a5f0:	4b41      	ldr	r3, [pc, #260]	; (800a6f8 <pvPortMalloc+0x178>)
 800a5f2:	681b      	ldr	r3, [r3, #0]
 800a5f4:	687a      	ldr	r2, [r7, #4]
 800a5f6:	429a      	cmp	r2, r3
 800a5f8:	d863      	bhi.n	800a6c2 <pvPortMalloc+0x142>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 800a5fa:	4b40      	ldr	r3, [pc, #256]	; (800a6fc <pvPortMalloc+0x17c>)
 800a5fc:	623b      	str	r3, [r7, #32]
				pxBlock = xStart.pxNextFreeBlock;
 800a5fe:	4b3f      	ldr	r3, [pc, #252]	; (800a6fc <pvPortMalloc+0x17c>)
 800a600:	681b      	ldr	r3, [r3, #0]
 800a602:	627b      	str	r3, [r7, #36]	; 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800a604:	e004      	b.n	800a610 <pvPortMalloc+0x90>
				{
					pxPreviousBlock = pxBlock;
 800a606:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a608:	623b      	str	r3, [r7, #32]
					pxBlock = pxBlock->pxNextFreeBlock;
 800a60a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a60c:	681b      	ldr	r3, [r3, #0]
 800a60e:	627b      	str	r3, [r7, #36]	; 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800a610:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a612:	685b      	ldr	r3, [r3, #4]
 800a614:	687a      	ldr	r2, [r7, #4]
 800a616:	429a      	cmp	r2, r3
 800a618:	d903      	bls.n	800a622 <pvPortMalloc+0xa2>
 800a61a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a61c:	681b      	ldr	r3, [r3, #0]
 800a61e:	2b00      	cmp	r3, #0
 800a620:	d1f1      	bne.n	800a606 <pvPortMalloc+0x86>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 800a622:	4b33      	ldr	r3, [pc, #204]	; (800a6f0 <pvPortMalloc+0x170>)
 800a624:	681b      	ldr	r3, [r3, #0]
 800a626:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a628:	429a      	cmp	r2, r3
 800a62a:	d04a      	beq.n	800a6c2 <pvPortMalloc+0x142>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800a62c:	6a3b      	ldr	r3, [r7, #32]
 800a62e:	681b      	ldr	r3, [r3, #0]
 800a630:	2208      	movs	r2, #8
 800a632:	4413      	add	r3, r2
 800a634:	61fb      	str	r3, [r7, #28]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800a636:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a638:	681a      	ldr	r2, [r3, #0]
 800a63a:	6a3b      	ldr	r3, [r7, #32]
 800a63c:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800a63e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a640:	685a      	ldr	r2, [r3, #4]
 800a642:	687b      	ldr	r3, [r7, #4]
 800a644:	1ad2      	subs	r2, r2, r3
 800a646:	2308      	movs	r3, #8
 800a648:	005b      	lsls	r3, r3, #1
 800a64a:	429a      	cmp	r2, r3
 800a64c:	d91e      	bls.n	800a68c <pvPortMalloc+0x10c>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800a64e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a650:	687b      	ldr	r3, [r7, #4]
 800a652:	4413      	add	r3, r2
 800a654:	61bb      	str	r3, [r7, #24]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 800a656:	69bb      	ldr	r3, [r7, #24]
 800a658:	f003 0307 	and.w	r3, r3, #7
 800a65c:	2b00      	cmp	r3, #0
 800a65e:	d009      	beq.n	800a674 <pvPortMalloc+0xf4>
 800a660:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a664:	f383 8811 	msr	BASEPRI, r3
 800a668:	f3bf 8f6f 	isb	sy
 800a66c:	f3bf 8f4f 	dsb	sy
 800a670:	613b      	str	r3, [r7, #16]
 800a672:	e7fe      	b.n	800a672 <pvPortMalloc+0xf2>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800a674:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a676:	685a      	ldr	r2, [r3, #4]
 800a678:	687b      	ldr	r3, [r7, #4]
 800a67a:	1ad2      	subs	r2, r2, r3
 800a67c:	69bb      	ldr	r3, [r7, #24]
 800a67e:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
 800a680:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a682:	687a      	ldr	r2, [r7, #4]
 800a684:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 800a686:	69b8      	ldr	r0, [r7, #24]
 800a688:	f000 f8f6 	bl	800a878 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800a68c:	4b1a      	ldr	r3, [pc, #104]	; (800a6f8 <pvPortMalloc+0x178>)
 800a68e:	681a      	ldr	r2, [r3, #0]
 800a690:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a692:	685b      	ldr	r3, [r3, #4]
 800a694:	1ad3      	subs	r3, r2, r3
 800a696:	4a18      	ldr	r2, [pc, #96]	; (800a6f8 <pvPortMalloc+0x178>)
 800a698:	6013      	str	r3, [r2, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800a69a:	4b17      	ldr	r3, [pc, #92]	; (800a6f8 <pvPortMalloc+0x178>)
 800a69c:	681a      	ldr	r2, [r3, #0]
 800a69e:	4b18      	ldr	r3, [pc, #96]	; (800a700 <pvPortMalloc+0x180>)
 800a6a0:	681b      	ldr	r3, [r3, #0]
 800a6a2:	429a      	cmp	r2, r3
 800a6a4:	d203      	bcs.n	800a6ae <pvPortMalloc+0x12e>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800a6a6:	4b14      	ldr	r3, [pc, #80]	; (800a6f8 <pvPortMalloc+0x178>)
 800a6a8:	681b      	ldr	r3, [r3, #0]
 800a6aa:	4a15      	ldr	r2, [pc, #84]	; (800a700 <pvPortMalloc+0x180>)
 800a6ac:	6013      	str	r3, [r2, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800a6ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a6b0:	685a      	ldr	r2, [r3, #4]
 800a6b2:	4b10      	ldr	r3, [pc, #64]	; (800a6f4 <pvPortMalloc+0x174>)
 800a6b4:	681b      	ldr	r3, [r3, #0]
 800a6b6:	431a      	orrs	r2, r3
 800a6b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a6ba:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
 800a6bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a6be:	2200      	movs	r2, #0
 800a6c0:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 800a6c2:	f7fe fce3 	bl	800908c <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800a6c6:	69fb      	ldr	r3, [r7, #28]
 800a6c8:	f003 0307 	and.w	r3, r3, #7
 800a6cc:	2b00      	cmp	r3, #0
 800a6ce:	d009      	beq.n	800a6e4 <pvPortMalloc+0x164>
 800a6d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a6d4:	f383 8811 	msr	BASEPRI, r3
 800a6d8:	f3bf 8f6f 	isb	sy
 800a6dc:	f3bf 8f4f 	dsb	sy
 800a6e0:	60fb      	str	r3, [r7, #12]
 800a6e2:	e7fe      	b.n	800a6e2 <pvPortMalloc+0x162>
	return pvReturn;
 800a6e4:	69fb      	ldr	r3, [r7, #28]
}
 800a6e6:	4618      	mov	r0, r3
 800a6e8:	3728      	adds	r7, #40	; 0x28
 800a6ea:	46bd      	mov	sp, r7
 800a6ec:	bd80      	pop	{r7, pc}
 800a6ee:	bf00      	nop
 800a6f0:	20006108 	.word	0x20006108
 800a6f4:	20006114 	.word	0x20006114
 800a6f8:	2000610c 	.word	0x2000610c
 800a6fc:	20006100 	.word	0x20006100
 800a700:	20006110 	.word	0x20006110

0800a704 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 800a704:	b580      	push	{r7, lr}
 800a706:	b086      	sub	sp, #24
 800a708:	af00      	add	r7, sp, #0
 800a70a:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
 800a70c:	687b      	ldr	r3, [r7, #4]
 800a70e:	617b      	str	r3, [r7, #20]
BlockLink_t *pxLink;

	if( pv != NULL )
 800a710:	687b      	ldr	r3, [r7, #4]
 800a712:	2b00      	cmp	r3, #0
 800a714:	d046      	beq.n	800a7a4 <vPortFree+0xa0>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
 800a716:	2308      	movs	r3, #8
 800a718:	425b      	negs	r3, r3
 800a71a:	697a      	ldr	r2, [r7, #20]
 800a71c:	4413      	add	r3, r2
 800a71e:	617b      	str	r3, [r7, #20]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 800a720:	697b      	ldr	r3, [r7, #20]
 800a722:	613b      	str	r3, [r7, #16]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800a724:	693b      	ldr	r3, [r7, #16]
 800a726:	685a      	ldr	r2, [r3, #4]
 800a728:	4b20      	ldr	r3, [pc, #128]	; (800a7ac <vPortFree+0xa8>)
 800a72a:	681b      	ldr	r3, [r3, #0]
 800a72c:	4013      	ands	r3, r2
 800a72e:	2b00      	cmp	r3, #0
 800a730:	d109      	bne.n	800a746 <vPortFree+0x42>
 800a732:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a736:	f383 8811 	msr	BASEPRI, r3
 800a73a:	f3bf 8f6f 	isb	sy
 800a73e:	f3bf 8f4f 	dsb	sy
 800a742:	60fb      	str	r3, [r7, #12]
 800a744:	e7fe      	b.n	800a744 <vPortFree+0x40>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800a746:	693b      	ldr	r3, [r7, #16]
 800a748:	681b      	ldr	r3, [r3, #0]
 800a74a:	2b00      	cmp	r3, #0
 800a74c:	d009      	beq.n	800a762 <vPortFree+0x5e>
 800a74e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a752:	f383 8811 	msr	BASEPRI, r3
 800a756:	f3bf 8f6f 	isb	sy
 800a75a:	f3bf 8f4f 	dsb	sy
 800a75e:	60bb      	str	r3, [r7, #8]
 800a760:	e7fe      	b.n	800a760 <vPortFree+0x5c>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 800a762:	693b      	ldr	r3, [r7, #16]
 800a764:	685a      	ldr	r2, [r3, #4]
 800a766:	4b11      	ldr	r3, [pc, #68]	; (800a7ac <vPortFree+0xa8>)
 800a768:	681b      	ldr	r3, [r3, #0]
 800a76a:	4013      	ands	r3, r2
 800a76c:	2b00      	cmp	r3, #0
 800a76e:	d019      	beq.n	800a7a4 <vPortFree+0xa0>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 800a770:	693b      	ldr	r3, [r7, #16]
 800a772:	681b      	ldr	r3, [r3, #0]
 800a774:	2b00      	cmp	r3, #0
 800a776:	d115      	bne.n	800a7a4 <vPortFree+0xa0>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800a778:	693b      	ldr	r3, [r7, #16]
 800a77a:	685a      	ldr	r2, [r3, #4]
 800a77c:	4b0b      	ldr	r3, [pc, #44]	; (800a7ac <vPortFree+0xa8>)
 800a77e:	681b      	ldr	r3, [r3, #0]
 800a780:	43db      	mvns	r3, r3
 800a782:	401a      	ands	r2, r3
 800a784:	693b      	ldr	r3, [r7, #16]
 800a786:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
 800a788:	f7fe fc3a 	bl	8009000 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 800a78c:	693b      	ldr	r3, [r7, #16]
 800a78e:	685a      	ldr	r2, [r3, #4]
 800a790:	4b07      	ldr	r3, [pc, #28]	; (800a7b0 <vPortFree+0xac>)
 800a792:	681b      	ldr	r3, [r3, #0]
 800a794:	4413      	add	r3, r2
 800a796:	4a06      	ldr	r2, [pc, #24]	; (800a7b0 <vPortFree+0xac>)
 800a798:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800a79a:	6938      	ldr	r0, [r7, #16]
 800a79c:	f000 f86c 	bl	800a878 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
 800a7a0:	f7fe fc74 	bl	800908c <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 800a7a4:	bf00      	nop
 800a7a6:	3718      	adds	r7, #24
 800a7a8:	46bd      	mov	sp, r7
 800a7aa:	bd80      	pop	{r7, pc}
 800a7ac:	20006114 	.word	0x20006114
 800a7b0:	2000610c 	.word	0x2000610c

0800a7b4 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 800a7b4:	b480      	push	{r7}
 800a7b6:	b085      	sub	sp, #20
 800a7b8:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 800a7ba:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
 800a7be:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 800a7c0:	4b27      	ldr	r3, [pc, #156]	; (800a860 <prvHeapInit+0xac>)
 800a7c2:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800a7c4:	68fb      	ldr	r3, [r7, #12]
 800a7c6:	f003 0307 	and.w	r3, r3, #7
 800a7ca:	2b00      	cmp	r3, #0
 800a7cc:	d00c      	beq.n	800a7e8 <prvHeapInit+0x34>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800a7ce:	68fb      	ldr	r3, [r7, #12]
 800a7d0:	3307      	adds	r3, #7
 800a7d2:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800a7d4:	68fb      	ldr	r3, [r7, #12]
 800a7d6:	f023 0307 	bic.w	r3, r3, #7
 800a7da:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 800a7dc:	68ba      	ldr	r2, [r7, #8]
 800a7de:	68fb      	ldr	r3, [r7, #12]
 800a7e0:	1ad3      	subs	r3, r2, r3
 800a7e2:	4a1f      	ldr	r2, [pc, #124]	; (800a860 <prvHeapInit+0xac>)
 800a7e4:	4413      	add	r3, r2
 800a7e6:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
 800a7e8:	68fb      	ldr	r3, [r7, #12]
 800a7ea:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800a7ec:	4a1d      	ldr	r2, [pc, #116]	; (800a864 <prvHeapInit+0xb0>)
 800a7ee:	687b      	ldr	r3, [r7, #4]
 800a7f0:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 800a7f2:	4b1c      	ldr	r3, [pc, #112]	; (800a864 <prvHeapInit+0xb0>)
 800a7f4:	2200      	movs	r2, #0
 800a7f6:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 800a7f8:	687b      	ldr	r3, [r7, #4]
 800a7fa:	68ba      	ldr	r2, [r7, #8]
 800a7fc:	4413      	add	r3, r2
 800a7fe:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
 800a800:	2208      	movs	r2, #8
 800a802:	68fb      	ldr	r3, [r7, #12]
 800a804:	1a9b      	subs	r3, r3, r2
 800a806:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800a808:	68fb      	ldr	r3, [r7, #12]
 800a80a:	f023 0307 	bic.w	r3, r3, #7
 800a80e:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
 800a810:	68fb      	ldr	r3, [r7, #12]
 800a812:	4a15      	ldr	r2, [pc, #84]	; (800a868 <prvHeapInit+0xb4>)
 800a814:	6013      	str	r3, [r2, #0]
	pxEnd->xBlockSize = 0;
 800a816:	4b14      	ldr	r3, [pc, #80]	; (800a868 <prvHeapInit+0xb4>)
 800a818:	681b      	ldr	r3, [r3, #0]
 800a81a:	2200      	movs	r2, #0
 800a81c:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 800a81e:	4b12      	ldr	r3, [pc, #72]	; (800a868 <prvHeapInit+0xb4>)
 800a820:	681b      	ldr	r3, [r3, #0]
 800a822:	2200      	movs	r2, #0
 800a824:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 800a826:	687b      	ldr	r3, [r7, #4]
 800a828:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800a82a:	683b      	ldr	r3, [r7, #0]
 800a82c:	68fa      	ldr	r2, [r7, #12]
 800a82e:	1ad2      	subs	r2, r2, r3
 800a830:	683b      	ldr	r3, [r7, #0]
 800a832:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800a834:	4b0c      	ldr	r3, [pc, #48]	; (800a868 <prvHeapInit+0xb4>)
 800a836:	681a      	ldr	r2, [r3, #0]
 800a838:	683b      	ldr	r3, [r7, #0]
 800a83a:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800a83c:	683b      	ldr	r3, [r7, #0]
 800a83e:	685b      	ldr	r3, [r3, #4]
 800a840:	4a0a      	ldr	r2, [pc, #40]	; (800a86c <prvHeapInit+0xb8>)
 800a842:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800a844:	683b      	ldr	r3, [r7, #0]
 800a846:	685b      	ldr	r3, [r3, #4]
 800a848:	4a09      	ldr	r2, [pc, #36]	; (800a870 <prvHeapInit+0xbc>)
 800a84a:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800a84c:	4b09      	ldr	r3, [pc, #36]	; (800a874 <prvHeapInit+0xc0>)
 800a84e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800a852:	601a      	str	r2, [r3, #0]
}
 800a854:	bf00      	nop
 800a856:	3714      	adds	r7, #20
 800a858:	46bd      	mov	sp, r7
 800a85a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a85e:	4770      	bx	lr
 800a860:	20001100 	.word	0x20001100
 800a864:	20006100 	.word	0x20006100
 800a868:	20006108 	.word	0x20006108
 800a86c:	20006110 	.word	0x20006110
 800a870:	2000610c 	.word	0x2000610c
 800a874:	20006114 	.word	0x20006114

0800a878 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 800a878:	b480      	push	{r7}
 800a87a:	b085      	sub	sp, #20
 800a87c:	af00      	add	r7, sp, #0
 800a87e:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800a880:	4b28      	ldr	r3, [pc, #160]	; (800a924 <prvInsertBlockIntoFreeList+0xac>)
 800a882:	60fb      	str	r3, [r7, #12]
 800a884:	e002      	b.n	800a88c <prvInsertBlockIntoFreeList+0x14>
 800a886:	68fb      	ldr	r3, [r7, #12]
 800a888:	681b      	ldr	r3, [r3, #0]
 800a88a:	60fb      	str	r3, [r7, #12]
 800a88c:	68fb      	ldr	r3, [r7, #12]
 800a88e:	681b      	ldr	r3, [r3, #0]
 800a890:	687a      	ldr	r2, [r7, #4]
 800a892:	429a      	cmp	r2, r3
 800a894:	d8f7      	bhi.n	800a886 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
 800a896:	68fb      	ldr	r3, [r7, #12]
 800a898:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800a89a:	68fb      	ldr	r3, [r7, #12]
 800a89c:	685b      	ldr	r3, [r3, #4]
 800a89e:	68ba      	ldr	r2, [r7, #8]
 800a8a0:	4413      	add	r3, r2
 800a8a2:	687a      	ldr	r2, [r7, #4]
 800a8a4:	429a      	cmp	r2, r3
 800a8a6:	d108      	bne.n	800a8ba <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800a8a8:	68fb      	ldr	r3, [r7, #12]
 800a8aa:	685a      	ldr	r2, [r3, #4]
 800a8ac:	687b      	ldr	r3, [r7, #4]
 800a8ae:	685b      	ldr	r3, [r3, #4]
 800a8b0:	441a      	add	r2, r3
 800a8b2:	68fb      	ldr	r3, [r7, #12]
 800a8b4:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
 800a8b6:	68fb      	ldr	r3, [r7, #12]
 800a8b8:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
 800a8ba:	687b      	ldr	r3, [r7, #4]
 800a8bc:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800a8be:	687b      	ldr	r3, [r7, #4]
 800a8c0:	685b      	ldr	r3, [r3, #4]
 800a8c2:	68ba      	ldr	r2, [r7, #8]
 800a8c4:	441a      	add	r2, r3
 800a8c6:	68fb      	ldr	r3, [r7, #12]
 800a8c8:	681b      	ldr	r3, [r3, #0]
 800a8ca:	429a      	cmp	r2, r3
 800a8cc:	d118      	bne.n	800a900 <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800a8ce:	68fb      	ldr	r3, [r7, #12]
 800a8d0:	681a      	ldr	r2, [r3, #0]
 800a8d2:	4b15      	ldr	r3, [pc, #84]	; (800a928 <prvInsertBlockIntoFreeList+0xb0>)
 800a8d4:	681b      	ldr	r3, [r3, #0]
 800a8d6:	429a      	cmp	r2, r3
 800a8d8:	d00d      	beq.n	800a8f6 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800a8da:	687b      	ldr	r3, [r7, #4]
 800a8dc:	685a      	ldr	r2, [r3, #4]
 800a8de:	68fb      	ldr	r3, [r7, #12]
 800a8e0:	681b      	ldr	r3, [r3, #0]
 800a8e2:	685b      	ldr	r3, [r3, #4]
 800a8e4:	441a      	add	r2, r3
 800a8e6:	687b      	ldr	r3, [r7, #4]
 800a8e8:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800a8ea:	68fb      	ldr	r3, [r7, #12]
 800a8ec:	681b      	ldr	r3, [r3, #0]
 800a8ee:	681a      	ldr	r2, [r3, #0]
 800a8f0:	687b      	ldr	r3, [r7, #4]
 800a8f2:	601a      	str	r2, [r3, #0]
 800a8f4:	e008      	b.n	800a908 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 800a8f6:	4b0c      	ldr	r3, [pc, #48]	; (800a928 <prvInsertBlockIntoFreeList+0xb0>)
 800a8f8:	681a      	ldr	r2, [r3, #0]
 800a8fa:	687b      	ldr	r3, [r7, #4]
 800a8fc:	601a      	str	r2, [r3, #0]
 800a8fe:	e003      	b.n	800a908 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800a900:	68fb      	ldr	r3, [r7, #12]
 800a902:	681a      	ldr	r2, [r3, #0]
 800a904:	687b      	ldr	r3, [r7, #4]
 800a906:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800a908:	68fa      	ldr	r2, [r7, #12]
 800a90a:	687b      	ldr	r3, [r7, #4]
 800a90c:	429a      	cmp	r2, r3
 800a90e:	d002      	beq.n	800a916 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800a910:	68fb      	ldr	r3, [r7, #12]
 800a912:	687a      	ldr	r2, [r7, #4]
 800a914:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800a916:	bf00      	nop
 800a918:	3714      	adds	r7, #20
 800a91a:	46bd      	mov	sp, r7
 800a91c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a920:	4770      	bx	lr
 800a922:	bf00      	nop
 800a924:	20006100 	.word	0x20006100
 800a928:	20006108 	.word	0x20006108

0800a92c <default_RNG>:
    return 1;
}

#else /* Some other platform */

static int default_RNG(uint8_t *dest, unsigned size) {
 800a92c:	b480      	push	{r7}
 800a92e:	b083      	sub	sp, #12
 800a930:	af00      	add	r7, sp, #0
 800a932:	6078      	str	r0, [r7, #4]
 800a934:	6039      	str	r1, [r7, #0]
    (void) dest;
    (void) size;
    return 0;
 800a936:	2300      	movs	r3, #0
}
 800a938:	4618      	mov	r0, r3
 800a93a:	370c      	adds	r7, #12
 800a93c:	46bd      	mov	sp, r7
 800a93e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a942:	4770      	bx	lr

0800a944 <uECC_set_rng>:

#endif

static uECC_RNG_Function g_rng_function = &default_RNG;

void uECC_set_rng(uECC_RNG_Function rng_function) {
 800a944:	b480      	push	{r7}
 800a946:	b083      	sub	sp, #12
 800a948:	af00      	add	r7, sp, #0
 800a94a:	6078      	str	r0, [r7, #4]
    g_rng_function = rng_function;
 800a94c:	4a04      	ldr	r2, [pc, #16]	; (800a960 <uECC_set_rng+0x1c>)
 800a94e:	687b      	ldr	r3, [r7, #4]
 800a950:	6013      	str	r3, [r2, #0]
}
 800a952:	bf00      	nop
 800a954:	370c      	adds	r7, #12
 800a956:	46bd      	mov	sp, r7
 800a958:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a95c:	4770      	bx	lr
 800a95e:	bf00      	nop
 800a960:	20000018 	.word	0x20000018

0800a964 <vli_clear>:
        #include "asm_arm.inc"
    #endif
#endif

#if !asm_clear
static void vli_clear(uECC_word_t *vli) {
 800a964:	b480      	push	{r7}
 800a966:	b085      	sub	sp, #20
 800a968:	af00      	add	r7, sp, #0
 800a96a:	6078      	str	r0, [r7, #4]
    wordcount_t i;
    for (i = 0; i < uECC_WORDS; ++i) {
 800a96c:	2300      	movs	r3, #0
 800a96e:	60fb      	str	r3, [r7, #12]
 800a970:	e008      	b.n	800a984 <vli_clear+0x20>
        vli[i] = 0;
 800a972:	68fb      	ldr	r3, [r7, #12]
 800a974:	009b      	lsls	r3, r3, #2
 800a976:	687a      	ldr	r2, [r7, #4]
 800a978:	4413      	add	r3, r2
 800a97a:	2200      	movs	r2, #0
 800a97c:	601a      	str	r2, [r3, #0]
    for (i = 0; i < uECC_WORDS; ++i) {
 800a97e:	68fb      	ldr	r3, [r7, #12]
 800a980:	3301      	adds	r3, #1
 800a982:	60fb      	str	r3, [r7, #12]
 800a984:	68fb      	ldr	r3, [r7, #12]
 800a986:	2b07      	cmp	r3, #7
 800a988:	d9f3      	bls.n	800a972 <vli_clear+0xe>
    }
}
 800a98a:	bf00      	nop
 800a98c:	3714      	adds	r7, #20
 800a98e:	46bd      	mov	sp, r7
 800a990:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a994:	4770      	bx	lr

0800a996 <vli_isZero>:
#endif

/* Returns 1 if vli == 0, 0 otherwise. */
#if !asm_isZero
static uECC_word_t vli_isZero(const uECC_word_t *vli) {
 800a996:	b480      	push	{r7}
 800a998:	b085      	sub	sp, #20
 800a99a:	af00      	add	r7, sp, #0
 800a99c:	6078      	str	r0, [r7, #4]
    wordcount_t i;
    for (i = 0; i < uECC_WORDS; ++i) {
 800a99e:	2300      	movs	r3, #0
 800a9a0:	60fb      	str	r3, [r7, #12]
 800a9a2:	e00b      	b.n	800a9bc <vli_isZero+0x26>
        if (vli[i]) {
 800a9a4:	68fb      	ldr	r3, [r7, #12]
 800a9a6:	009b      	lsls	r3, r3, #2
 800a9a8:	687a      	ldr	r2, [r7, #4]
 800a9aa:	4413      	add	r3, r2
 800a9ac:	681b      	ldr	r3, [r3, #0]
 800a9ae:	2b00      	cmp	r3, #0
 800a9b0:	d001      	beq.n	800a9b6 <vli_isZero+0x20>
            return 0;
 800a9b2:	2300      	movs	r3, #0
 800a9b4:	e006      	b.n	800a9c4 <vli_isZero+0x2e>
    for (i = 0; i < uECC_WORDS; ++i) {
 800a9b6:	68fb      	ldr	r3, [r7, #12]
 800a9b8:	3301      	adds	r3, #1
 800a9ba:	60fb      	str	r3, [r7, #12]
 800a9bc:	68fb      	ldr	r3, [r7, #12]
 800a9be:	2b07      	cmp	r3, #7
 800a9c0:	d9f0      	bls.n	800a9a4 <vli_isZero+0xe>
        }
    }
    return 1;
 800a9c2:	2301      	movs	r3, #1
}
 800a9c4:	4618      	mov	r0, r3
 800a9c6:	3714      	adds	r7, #20
 800a9c8:	46bd      	mov	sp, r7
 800a9ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a9ce:	4770      	bx	lr

0800a9d0 <vli_testBit>:
#endif

/* Returns nonzero if bit 'bit' of vli is set. */
#if !asm_testBit
static uECC_word_t vli_testBit(const uECC_word_t *vli, bitcount_t bit) {
 800a9d0:	b480      	push	{r7}
 800a9d2:	b083      	sub	sp, #12
 800a9d4:	af00      	add	r7, sp, #0
 800a9d6:	6078      	str	r0, [r7, #4]
 800a9d8:	6039      	str	r1, [r7, #0]
    return (vli[bit >> uECC_WORD_BITS_SHIFT] & ((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
 800a9da:	683b      	ldr	r3, [r7, #0]
 800a9dc:	115b      	asrs	r3, r3, #5
 800a9de:	009b      	lsls	r3, r3, #2
 800a9e0:	687a      	ldr	r2, [r7, #4]
 800a9e2:	4413      	add	r3, r2
 800a9e4:	681a      	ldr	r2, [r3, #0]
 800a9e6:	683b      	ldr	r3, [r7, #0]
 800a9e8:	f003 031f 	and.w	r3, r3, #31
 800a9ec:	2101      	movs	r1, #1
 800a9ee:	fa01 f303 	lsl.w	r3, r1, r3
 800a9f2:	4013      	ands	r3, r2
}
 800a9f4:	4618      	mov	r0, r3
 800a9f6:	370c      	adds	r7, #12
 800a9f8:	46bd      	mov	sp, r7
 800a9fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a9fe:	4770      	bx	lr

0800aa00 <vli_set>:

#endif /* !asm_numBits */

/* Sets dest = src. */
#if !asm_set
static void vli_set(uECC_word_t *dest, const uECC_word_t *src) {
 800aa00:	b480      	push	{r7}
 800aa02:	b085      	sub	sp, #20
 800aa04:	af00      	add	r7, sp, #0
 800aa06:	6078      	str	r0, [r7, #4]
 800aa08:	6039      	str	r1, [r7, #0]
    wordcount_t i;
    for (i = 0; i < uECC_WORDS; ++i) {
 800aa0a:	2300      	movs	r3, #0
 800aa0c:	60fb      	str	r3, [r7, #12]
 800aa0e:	e00c      	b.n	800aa2a <vli_set+0x2a>
        dest[i] = src[i];
 800aa10:	68fb      	ldr	r3, [r7, #12]
 800aa12:	009b      	lsls	r3, r3, #2
 800aa14:	683a      	ldr	r2, [r7, #0]
 800aa16:	441a      	add	r2, r3
 800aa18:	68fb      	ldr	r3, [r7, #12]
 800aa1a:	009b      	lsls	r3, r3, #2
 800aa1c:	6879      	ldr	r1, [r7, #4]
 800aa1e:	440b      	add	r3, r1
 800aa20:	6812      	ldr	r2, [r2, #0]
 800aa22:	601a      	str	r2, [r3, #0]
    for (i = 0; i < uECC_WORDS; ++i) {
 800aa24:	68fb      	ldr	r3, [r7, #12]
 800aa26:	3301      	adds	r3, #1
 800aa28:	60fb      	str	r3, [r7, #12]
 800aa2a:	68fb      	ldr	r3, [r7, #12]
 800aa2c:	2b07      	cmp	r3, #7
 800aa2e:	d9ef      	bls.n	800aa10 <vli_set+0x10>
    }
}
 800aa30:	bf00      	nop
 800aa32:	3714      	adds	r7, #20
 800aa34:	46bd      	mov	sp, r7
 800aa36:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aa3a:	4770      	bx	lr

0800aa3c <vli_cmp>:
#endif

/* Returns sign of left - right. */
#if !asm_cmp
static cmpresult_t vli_cmp(const uECC_word_t *left, const uECC_word_t *right) {
 800aa3c:	b480      	push	{r7}
 800aa3e:	b085      	sub	sp, #20
 800aa40:	af00      	add	r7, sp, #0
 800aa42:	6078      	str	r0, [r7, #4]
 800aa44:	6039      	str	r1, [r7, #0]
    swordcount_t i;
    for (i = uECC_WORDS - 1; i >= 0; --i) {
 800aa46:	2307      	movs	r3, #7
 800aa48:	60fb      	str	r3, [r7, #12]
 800aa4a:	e01f      	b.n	800aa8c <vli_cmp+0x50>
        if (left[i] > right[i]) {
 800aa4c:	68fb      	ldr	r3, [r7, #12]
 800aa4e:	009b      	lsls	r3, r3, #2
 800aa50:	687a      	ldr	r2, [r7, #4]
 800aa52:	4413      	add	r3, r2
 800aa54:	681a      	ldr	r2, [r3, #0]
 800aa56:	68fb      	ldr	r3, [r7, #12]
 800aa58:	009b      	lsls	r3, r3, #2
 800aa5a:	6839      	ldr	r1, [r7, #0]
 800aa5c:	440b      	add	r3, r1
 800aa5e:	681b      	ldr	r3, [r3, #0]
 800aa60:	429a      	cmp	r2, r3
 800aa62:	d901      	bls.n	800aa68 <vli_cmp+0x2c>
            return 1;
 800aa64:	2301      	movs	r3, #1
 800aa66:	e015      	b.n	800aa94 <vli_cmp+0x58>
        } else if (left[i] < right[i]) {
 800aa68:	68fb      	ldr	r3, [r7, #12]
 800aa6a:	009b      	lsls	r3, r3, #2
 800aa6c:	687a      	ldr	r2, [r7, #4]
 800aa6e:	4413      	add	r3, r2
 800aa70:	681a      	ldr	r2, [r3, #0]
 800aa72:	68fb      	ldr	r3, [r7, #12]
 800aa74:	009b      	lsls	r3, r3, #2
 800aa76:	6839      	ldr	r1, [r7, #0]
 800aa78:	440b      	add	r3, r1
 800aa7a:	681b      	ldr	r3, [r3, #0]
 800aa7c:	429a      	cmp	r2, r3
 800aa7e:	d202      	bcs.n	800aa86 <vli_cmp+0x4a>
            return -1;
 800aa80:	f04f 33ff 	mov.w	r3, #4294967295
 800aa84:	e006      	b.n	800aa94 <vli_cmp+0x58>
    for (i = uECC_WORDS - 1; i >= 0; --i) {
 800aa86:	68fb      	ldr	r3, [r7, #12]
 800aa88:	3b01      	subs	r3, #1
 800aa8a:	60fb      	str	r3, [r7, #12]
 800aa8c:	68fb      	ldr	r3, [r7, #12]
 800aa8e:	2b00      	cmp	r3, #0
 800aa90:	dadc      	bge.n	800aa4c <vli_cmp+0x10>
        }
    }
    return 0;
 800aa92:	2300      	movs	r3, #0
}
 800aa94:	4618      	mov	r0, r3
 800aa96:	3714      	adds	r7, #20
 800aa98:	46bd      	mov	sp, r7
 800aa9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aa9e:	4770      	bx	lr

0800aaa0 <vli_rshift1>:

#endif

/* Computes vli = vli >> 1. */
#if !asm_rshift1
static void vli_rshift1(uECC_word_t *vli) {
 800aaa0:	b480      	push	{r7}
 800aaa2:	b087      	sub	sp, #28
 800aaa4:	af00      	add	r7, sp, #0
 800aaa6:	6078      	str	r0, [r7, #4]
    uECC_word_t *end = vli;
 800aaa8:	687b      	ldr	r3, [r7, #4]
 800aaaa:	613b      	str	r3, [r7, #16]
    uECC_word_t carry = 0;
 800aaac:	2300      	movs	r3, #0
 800aaae:	617b      	str	r3, [r7, #20]

    vli += uECC_WORDS;
 800aab0:	687b      	ldr	r3, [r7, #4]
 800aab2:	3320      	adds	r3, #32
 800aab4:	607b      	str	r3, [r7, #4]
    while (vli-- > end) {
 800aab6:	e00b      	b.n	800aad0 <vli_rshift1+0x30>
        uECC_word_t temp = *vli;
 800aab8:	687b      	ldr	r3, [r7, #4]
 800aaba:	681b      	ldr	r3, [r3, #0]
 800aabc:	60fb      	str	r3, [r7, #12]
        *vli = (temp >> 1) | carry;
 800aabe:	68fb      	ldr	r3, [r7, #12]
 800aac0:	085a      	lsrs	r2, r3, #1
 800aac2:	697b      	ldr	r3, [r7, #20]
 800aac4:	431a      	orrs	r2, r3
 800aac6:	687b      	ldr	r3, [r7, #4]
 800aac8:	601a      	str	r2, [r3, #0]
        carry = temp << (uECC_WORD_BITS - 1);
 800aaca:	68fb      	ldr	r3, [r7, #12]
 800aacc:	07db      	lsls	r3, r3, #31
 800aace:	617b      	str	r3, [r7, #20]
    while (vli-- > end) {
 800aad0:	687b      	ldr	r3, [r7, #4]
 800aad2:	1f1a      	subs	r2, r3, #4
 800aad4:	607a      	str	r2, [r7, #4]
 800aad6:	693a      	ldr	r2, [r7, #16]
 800aad8:	429a      	cmp	r2, r3
 800aada:	d3ed      	bcc.n	800aab8 <vli_rshift1+0x18>
    }
}
 800aadc:	bf00      	nop
 800aade:	371c      	adds	r7, #28
 800aae0:	46bd      	mov	sp, r7
 800aae2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aae6:	4770      	bx	lr

0800aae8 <vli_add>:
#endif

/* Computes result = left + right, returning carry. Can modify in place. */
#if !asm_add
static uECC_word_t vli_add(uECC_word_t *result, const uECC_word_t *left, const uECC_word_t *right) {
 800aae8:	b480      	push	{r7}
 800aaea:	b089      	sub	sp, #36	; 0x24
 800aaec:	af00      	add	r7, sp, #0
 800aaee:	60f8      	str	r0, [r7, #12]
 800aaf0:	60b9      	str	r1, [r7, #8]
 800aaf2:	607a      	str	r2, [r7, #4]
    uECC_word_t carry = 0;
 800aaf4:	2300      	movs	r3, #0
 800aaf6:	61fb      	str	r3, [r7, #28]
    wordcount_t i;
    for (i = 0; i < uECC_WORDS; ++i) {
 800aaf8:	2300      	movs	r3, #0
 800aafa:	61bb      	str	r3, [r7, #24]
 800aafc:	e02a      	b.n	800ab54 <vli_add+0x6c>
        uECC_word_t sum = left[i] + right[i] + carry;
 800aafe:	69bb      	ldr	r3, [r7, #24]
 800ab00:	009b      	lsls	r3, r3, #2
 800ab02:	68ba      	ldr	r2, [r7, #8]
 800ab04:	4413      	add	r3, r2
 800ab06:	681a      	ldr	r2, [r3, #0]
 800ab08:	69bb      	ldr	r3, [r7, #24]
 800ab0a:	009b      	lsls	r3, r3, #2
 800ab0c:	6879      	ldr	r1, [r7, #4]
 800ab0e:	440b      	add	r3, r1
 800ab10:	681b      	ldr	r3, [r3, #0]
 800ab12:	4413      	add	r3, r2
 800ab14:	69fa      	ldr	r2, [r7, #28]
 800ab16:	4413      	add	r3, r2
 800ab18:	617b      	str	r3, [r7, #20]
        if (sum != left[i]) {
 800ab1a:	69bb      	ldr	r3, [r7, #24]
 800ab1c:	009b      	lsls	r3, r3, #2
 800ab1e:	68ba      	ldr	r2, [r7, #8]
 800ab20:	4413      	add	r3, r2
 800ab22:	681b      	ldr	r3, [r3, #0]
 800ab24:	697a      	ldr	r2, [r7, #20]
 800ab26:	429a      	cmp	r2, r3
 800ab28:	d00b      	beq.n	800ab42 <vli_add+0x5a>
            carry = (sum < left[i]);
 800ab2a:	69bb      	ldr	r3, [r7, #24]
 800ab2c:	009b      	lsls	r3, r3, #2
 800ab2e:	68ba      	ldr	r2, [r7, #8]
 800ab30:	4413      	add	r3, r2
 800ab32:	681b      	ldr	r3, [r3, #0]
 800ab34:	697a      	ldr	r2, [r7, #20]
 800ab36:	429a      	cmp	r2, r3
 800ab38:	bf34      	ite	cc
 800ab3a:	2301      	movcc	r3, #1
 800ab3c:	2300      	movcs	r3, #0
 800ab3e:	b2db      	uxtb	r3, r3
 800ab40:	61fb      	str	r3, [r7, #28]
        }
        result[i] = sum;
 800ab42:	69bb      	ldr	r3, [r7, #24]
 800ab44:	009b      	lsls	r3, r3, #2
 800ab46:	68fa      	ldr	r2, [r7, #12]
 800ab48:	4413      	add	r3, r2
 800ab4a:	697a      	ldr	r2, [r7, #20]
 800ab4c:	601a      	str	r2, [r3, #0]
    for (i = 0; i < uECC_WORDS; ++i) {
 800ab4e:	69bb      	ldr	r3, [r7, #24]
 800ab50:	3301      	adds	r3, #1
 800ab52:	61bb      	str	r3, [r7, #24]
 800ab54:	69bb      	ldr	r3, [r7, #24]
 800ab56:	2b07      	cmp	r3, #7
 800ab58:	d9d1      	bls.n	800aafe <vli_add+0x16>
    }
    return carry;
 800ab5a:	69fb      	ldr	r3, [r7, #28]
}
 800ab5c:	4618      	mov	r0, r3
 800ab5e:	3724      	adds	r7, #36	; 0x24
 800ab60:	46bd      	mov	sp, r7
 800ab62:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ab66:	4770      	bx	lr

0800ab68 <vli_sub>:
#endif

/* Computes result = left - right, returning borrow. Can modify in place. */
#if !asm_sub
static uECC_word_t vli_sub(uECC_word_t *result, const uECC_word_t *left, const uECC_word_t *right) {
 800ab68:	b480      	push	{r7}
 800ab6a:	b089      	sub	sp, #36	; 0x24
 800ab6c:	af00      	add	r7, sp, #0
 800ab6e:	60f8      	str	r0, [r7, #12]
 800ab70:	60b9      	str	r1, [r7, #8]
 800ab72:	607a      	str	r2, [r7, #4]
    uECC_word_t borrow = 0;
 800ab74:	2300      	movs	r3, #0
 800ab76:	61fb      	str	r3, [r7, #28]
    wordcount_t i;
    for (i = 0; i < uECC_WORDS; ++i) {
 800ab78:	2300      	movs	r3, #0
 800ab7a:	61bb      	str	r3, [r7, #24]
 800ab7c:	e02a      	b.n	800abd4 <vli_sub+0x6c>
        uECC_word_t diff = left[i] - right[i] - borrow;
 800ab7e:	69bb      	ldr	r3, [r7, #24]
 800ab80:	009b      	lsls	r3, r3, #2
 800ab82:	68ba      	ldr	r2, [r7, #8]
 800ab84:	4413      	add	r3, r2
 800ab86:	681a      	ldr	r2, [r3, #0]
 800ab88:	69bb      	ldr	r3, [r7, #24]
 800ab8a:	009b      	lsls	r3, r3, #2
 800ab8c:	6879      	ldr	r1, [r7, #4]
 800ab8e:	440b      	add	r3, r1
 800ab90:	681b      	ldr	r3, [r3, #0]
 800ab92:	1ad2      	subs	r2, r2, r3
 800ab94:	69fb      	ldr	r3, [r7, #28]
 800ab96:	1ad3      	subs	r3, r2, r3
 800ab98:	617b      	str	r3, [r7, #20]
        if (diff != left[i]) {
 800ab9a:	69bb      	ldr	r3, [r7, #24]
 800ab9c:	009b      	lsls	r3, r3, #2
 800ab9e:	68ba      	ldr	r2, [r7, #8]
 800aba0:	4413      	add	r3, r2
 800aba2:	681b      	ldr	r3, [r3, #0]
 800aba4:	697a      	ldr	r2, [r7, #20]
 800aba6:	429a      	cmp	r2, r3
 800aba8:	d00b      	beq.n	800abc2 <vli_sub+0x5a>
            borrow = (diff > left[i]);
 800abaa:	69bb      	ldr	r3, [r7, #24]
 800abac:	009b      	lsls	r3, r3, #2
 800abae:	68ba      	ldr	r2, [r7, #8]
 800abb0:	4413      	add	r3, r2
 800abb2:	681b      	ldr	r3, [r3, #0]
 800abb4:	697a      	ldr	r2, [r7, #20]
 800abb6:	429a      	cmp	r2, r3
 800abb8:	bf8c      	ite	hi
 800abba:	2301      	movhi	r3, #1
 800abbc:	2300      	movls	r3, #0
 800abbe:	b2db      	uxtb	r3, r3
 800abc0:	61fb      	str	r3, [r7, #28]
        }
        result[i] = diff;
 800abc2:	69bb      	ldr	r3, [r7, #24]
 800abc4:	009b      	lsls	r3, r3, #2
 800abc6:	68fa      	ldr	r2, [r7, #12]
 800abc8:	4413      	add	r3, r2
 800abca:	697a      	ldr	r2, [r7, #20]
 800abcc:	601a      	str	r2, [r3, #0]
    for (i = 0; i < uECC_WORDS; ++i) {
 800abce:	69bb      	ldr	r3, [r7, #24]
 800abd0:	3301      	adds	r3, #1
 800abd2:	61bb      	str	r3, [r7, #24]
 800abd4:	69bb      	ldr	r3, [r7, #24]
 800abd6:	2b07      	cmp	r3, #7
 800abd8:	d9d1      	bls.n	800ab7e <vli_sub+0x16>
    }
    return borrow;
 800abda:	69fb      	ldr	r3, [r7, #28]
}
 800abdc:	4618      	mov	r0, r3
 800abde:	3724      	adds	r7, #36	; 0x24
 800abe0:	46bd      	mov	sp, r7
 800abe2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800abe6:	4770      	bx	lr

0800abe8 <muladd>:
#if (!asm_mult || (uECC_SQUARE_FUNC && !asm_square) || uECC_CURVE == uECC_secp256k1)
static void muladd(uECC_word_t a,
                   uECC_word_t b,
                   uECC_word_t *r0,
                   uECC_word_t *r1,
                   uECC_word_t *r2) {
 800abe8:	b4f0      	push	{r4, r5, r6, r7}
 800abea:	b088      	sub	sp, #32
 800abec:	af00      	add	r7, sp, #0
 800abee:	60f8      	str	r0, [r7, #12]
 800abf0:	60b9      	str	r1, [r7, #8]
 800abf2:	607a      	str	r2, [r7, #4]
 800abf4:	603b      	str	r3, [r7, #0]

    *r0 += p0;
    *r1 += (p1 + (*r0 < p0));
    *r2 += ((*r1 < p1) || (*r1 == p1 && *r0 < p0));
#else
    uECC_dword_t p = (uECC_dword_t)a * b;
 800abf6:	68fb      	ldr	r3, [r7, #12]
 800abf8:	4619      	mov	r1, r3
 800abfa:	f04f 0200 	mov.w	r2, #0
 800abfe:	68bb      	ldr	r3, [r7, #8]
 800ac00:	f04f 0400 	mov.w	r4, #0
 800ac04:	fb03 f502 	mul.w	r5, r3, r2
 800ac08:	fb01 f004 	mul.w	r0, r1, r4
 800ac0c:	4428      	add	r0, r5
 800ac0e:	fba1 3403 	umull	r3, r4, r1, r3
 800ac12:	1902      	adds	r2, r0, r4
 800ac14:	4614      	mov	r4, r2
 800ac16:	e9c7 3406 	strd	r3, r4, [r7, #24]
 800ac1a:	e9c7 3406 	strd	r3, r4, [r7, #24]
    uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
 800ac1e:	683b      	ldr	r3, [r7, #0]
 800ac20:	681b      	ldr	r3, [r3, #0]
 800ac22:	4619      	mov	r1, r3
 800ac24:	f04f 0200 	mov.w	r2, #0
 800ac28:	f04f 0500 	mov.w	r5, #0
 800ac2c:	f04f 0600 	mov.w	r6, #0
 800ac30:	000e      	movs	r6, r1
 800ac32:	2500      	movs	r5, #0
 800ac34:	687a      	ldr	r2, [r7, #4]
 800ac36:	6812      	ldr	r2, [r2, #0]
 800ac38:	4611      	mov	r1, r2
 800ac3a:	f04f 0200 	mov.w	r2, #0
 800ac3e:	ea45 0301 	orr.w	r3, r5, r1
 800ac42:	ea46 0402 	orr.w	r4, r6, r2
 800ac46:	e9c7 3404 	strd	r3, r4, [r7, #16]
    r01 += p;
 800ac4a:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 800ac4e:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 800ac52:	185d      	adds	r5, r3, r1
 800ac54:	eb44 0602 	adc.w	r6, r4, r2
 800ac58:	e9c7 5604 	strd	r5, r6, [r7, #16]
    *r2 += (r01 < p);
 800ac5c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ac5e:	6818      	ldr	r0, [r3, #0]
 800ac60:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 800ac64:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 800ac68:	42a2      	cmp	r2, r4
 800ac6a:	bf08      	it	eq
 800ac6c:	4299      	cmpeq	r1, r3
 800ac6e:	bf34      	ite	cc
 800ac70:	2301      	movcc	r3, #1
 800ac72:	2300      	movcs	r3, #0
 800ac74:	b2db      	uxtb	r3, r3
 800ac76:	18c2      	adds	r2, r0, r3
 800ac78:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ac7a:	601a      	str	r2, [r3, #0]
    *r1 = r01 >> uECC_WORD_BITS;
 800ac7c:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 800ac80:	f04f 0300 	mov.w	r3, #0
 800ac84:	f04f 0400 	mov.w	r4, #0
 800ac88:	0013      	movs	r3, r2
 800ac8a:	2400      	movs	r4, #0
 800ac8c:	461a      	mov	r2, r3
 800ac8e:	683b      	ldr	r3, [r7, #0]
 800ac90:	601a      	str	r2, [r3, #0]
    *r0 = (uECC_word_t)r01;
 800ac92:	693a      	ldr	r2, [r7, #16]
 800ac94:	687b      	ldr	r3, [r7, #4]
 800ac96:	601a      	str	r2, [r3, #0]
#endif
}
 800ac98:	bf00      	nop
 800ac9a:	3720      	adds	r7, #32
 800ac9c:	46bd      	mov	sp, r7
 800ac9e:	bcf0      	pop	{r4, r5, r6, r7}
 800aca0:	4770      	bx	lr

0800aca2 <vli_mult>:
#define muladd_exists 1
#endif

#if !asm_mult
static void vli_mult(uECC_word_t *result, const uECC_word_t *left, const uECC_word_t *right) {
 800aca2:	b590      	push	{r4, r7, lr}
 800aca4:	b08d      	sub	sp, #52	; 0x34
 800aca6:	af02      	add	r7, sp, #8
 800aca8:	60f8      	str	r0, [r7, #12]
 800acaa:	60b9      	str	r1, [r7, #8]
 800acac:	607a      	str	r2, [r7, #4]
    uECC_word_t r0 = 0;
 800acae:	2300      	movs	r3, #0
 800acb0:	61fb      	str	r3, [r7, #28]
    uECC_word_t r1 = 0;
 800acb2:	2300      	movs	r3, #0
 800acb4:	61bb      	str	r3, [r7, #24]
    uECC_word_t r2 = 0;
 800acb6:	2300      	movs	r3, #0
 800acb8:	617b      	str	r3, [r7, #20]
    wordcount_t i, k;

    /* Compute each digit of result in sequence, maintaining the carries. */
    for (k = 0; k < uECC_WORDS; ++k) {
 800acba:	2300      	movs	r3, #0
 800acbc:	623b      	str	r3, [r7, #32]
 800acbe:	e02e      	b.n	800ad1e <vli_mult+0x7c>
        for (i = 0; i <= k; ++i) {
 800acc0:	2300      	movs	r3, #0
 800acc2:	627b      	str	r3, [r7, #36]	; 0x24
 800acc4:	e018      	b.n	800acf8 <vli_mult+0x56>
            muladd(left[i], right[k - i], &r0, &r1, &r2);
 800acc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800acc8:	009b      	lsls	r3, r3, #2
 800acca:	68ba      	ldr	r2, [r7, #8]
 800accc:	4413      	add	r3, r2
 800acce:	6818      	ldr	r0, [r3, #0]
 800acd0:	6a3a      	ldr	r2, [r7, #32]
 800acd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800acd4:	1ad3      	subs	r3, r2, r3
 800acd6:	009b      	lsls	r3, r3, #2
 800acd8:	687a      	ldr	r2, [r7, #4]
 800acda:	4413      	add	r3, r2
 800acdc:	6819      	ldr	r1, [r3, #0]
 800acde:	f107 0418 	add.w	r4, r7, #24
 800ace2:	f107 021c 	add.w	r2, r7, #28
 800ace6:	f107 0314 	add.w	r3, r7, #20
 800acea:	9300      	str	r3, [sp, #0]
 800acec:	4623      	mov	r3, r4
 800acee:	f7ff ff7b 	bl	800abe8 <muladd>
        for (i = 0; i <= k; ++i) {
 800acf2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800acf4:	3301      	adds	r3, #1
 800acf6:	627b      	str	r3, [r7, #36]	; 0x24
 800acf8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800acfa:	6a3b      	ldr	r3, [r7, #32]
 800acfc:	429a      	cmp	r2, r3
 800acfe:	d9e2      	bls.n	800acc6 <vli_mult+0x24>
        }
        result[k] = r0;
 800ad00:	6a3b      	ldr	r3, [r7, #32]
 800ad02:	009b      	lsls	r3, r3, #2
 800ad04:	68fa      	ldr	r2, [r7, #12]
 800ad06:	4413      	add	r3, r2
 800ad08:	69fa      	ldr	r2, [r7, #28]
 800ad0a:	601a      	str	r2, [r3, #0]
        r0 = r1;
 800ad0c:	69bb      	ldr	r3, [r7, #24]
 800ad0e:	61fb      	str	r3, [r7, #28]
        r1 = r2;
 800ad10:	697b      	ldr	r3, [r7, #20]
 800ad12:	61bb      	str	r3, [r7, #24]
        r2 = 0;
 800ad14:	2300      	movs	r3, #0
 800ad16:	617b      	str	r3, [r7, #20]
    for (k = 0; k < uECC_WORDS; ++k) {
 800ad18:	6a3b      	ldr	r3, [r7, #32]
 800ad1a:	3301      	adds	r3, #1
 800ad1c:	623b      	str	r3, [r7, #32]
 800ad1e:	6a3b      	ldr	r3, [r7, #32]
 800ad20:	2b07      	cmp	r3, #7
 800ad22:	d9cd      	bls.n	800acc0 <vli_mult+0x1e>
    }
    for (k = uECC_WORDS; k < uECC_WORDS * 2 - 1; ++k) {
 800ad24:	2308      	movs	r3, #8
 800ad26:	623b      	str	r3, [r7, #32]
 800ad28:	e02e      	b.n	800ad88 <vli_mult+0xe6>
        for (i = (k + 1) - uECC_WORDS; i < uECC_WORDS; ++i) {
 800ad2a:	6a3b      	ldr	r3, [r7, #32]
 800ad2c:	3b07      	subs	r3, #7
 800ad2e:	627b      	str	r3, [r7, #36]	; 0x24
 800ad30:	e018      	b.n	800ad64 <vli_mult+0xc2>
            muladd(left[i], right[k - i], &r0, &r1, &r2);
 800ad32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ad34:	009b      	lsls	r3, r3, #2
 800ad36:	68ba      	ldr	r2, [r7, #8]
 800ad38:	4413      	add	r3, r2
 800ad3a:	6818      	ldr	r0, [r3, #0]
 800ad3c:	6a3a      	ldr	r2, [r7, #32]
 800ad3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ad40:	1ad3      	subs	r3, r2, r3
 800ad42:	009b      	lsls	r3, r3, #2
 800ad44:	687a      	ldr	r2, [r7, #4]
 800ad46:	4413      	add	r3, r2
 800ad48:	6819      	ldr	r1, [r3, #0]
 800ad4a:	f107 0418 	add.w	r4, r7, #24
 800ad4e:	f107 021c 	add.w	r2, r7, #28
 800ad52:	f107 0314 	add.w	r3, r7, #20
 800ad56:	9300      	str	r3, [sp, #0]
 800ad58:	4623      	mov	r3, r4
 800ad5a:	f7ff ff45 	bl	800abe8 <muladd>
        for (i = (k + 1) - uECC_WORDS; i < uECC_WORDS; ++i) {
 800ad5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ad60:	3301      	adds	r3, #1
 800ad62:	627b      	str	r3, [r7, #36]	; 0x24
 800ad64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ad66:	2b07      	cmp	r3, #7
 800ad68:	d9e3      	bls.n	800ad32 <vli_mult+0x90>
        }
        result[k] = r0;
 800ad6a:	6a3b      	ldr	r3, [r7, #32]
 800ad6c:	009b      	lsls	r3, r3, #2
 800ad6e:	68fa      	ldr	r2, [r7, #12]
 800ad70:	4413      	add	r3, r2
 800ad72:	69fa      	ldr	r2, [r7, #28]
 800ad74:	601a      	str	r2, [r3, #0]
        r0 = r1;
 800ad76:	69bb      	ldr	r3, [r7, #24]
 800ad78:	61fb      	str	r3, [r7, #28]
        r1 = r2;
 800ad7a:	697b      	ldr	r3, [r7, #20]
 800ad7c:	61bb      	str	r3, [r7, #24]
        r2 = 0;
 800ad7e:	2300      	movs	r3, #0
 800ad80:	617b      	str	r3, [r7, #20]
    for (k = uECC_WORDS; k < uECC_WORDS * 2 - 1; ++k) {
 800ad82:	6a3b      	ldr	r3, [r7, #32]
 800ad84:	3301      	adds	r3, #1
 800ad86:	623b      	str	r3, [r7, #32]
 800ad88:	6a3b      	ldr	r3, [r7, #32]
 800ad8a:	2b0e      	cmp	r3, #14
 800ad8c:	d9cd      	bls.n	800ad2a <vli_mult+0x88>
    }
    result[uECC_WORDS * 2 - 1] = r0;
 800ad8e:	68fb      	ldr	r3, [r7, #12]
 800ad90:	333c      	adds	r3, #60	; 0x3c
 800ad92:	69fa      	ldr	r2, [r7, #28]
 800ad94:	601a      	str	r2, [r3, #0]
}
 800ad96:	bf00      	nop
 800ad98:	372c      	adds	r7, #44	; 0x2c
 800ad9a:	46bd      	mov	sp, r7
 800ad9c:	bd90      	pop	{r4, r7, pc}

0800ad9e <vli_modAdd>:
   Assumes that left < mod and right < mod, and that result does not overlap mod. */
#if !asm_modAdd
static void vli_modAdd(uECC_word_t *result,
                       const uECC_word_t *left,
                       const uECC_word_t *right,
                       const uECC_word_t *mod) {
 800ad9e:	b580      	push	{r7, lr}
 800ada0:	b086      	sub	sp, #24
 800ada2:	af00      	add	r7, sp, #0
 800ada4:	60f8      	str	r0, [r7, #12]
 800ada6:	60b9      	str	r1, [r7, #8]
 800ada8:	607a      	str	r2, [r7, #4]
 800adaa:	603b      	str	r3, [r7, #0]
    uECC_word_t carry = vli_add(result, left, right);
 800adac:	687a      	ldr	r2, [r7, #4]
 800adae:	68b9      	ldr	r1, [r7, #8]
 800adb0:	68f8      	ldr	r0, [r7, #12]
 800adb2:	f7ff fe99 	bl	800aae8 <vli_add>
 800adb6:	6178      	str	r0, [r7, #20]
    if (carry || vli_cmp(result, mod) >= 0) {
 800adb8:	697b      	ldr	r3, [r7, #20]
 800adba:	2b00      	cmp	r3, #0
 800adbc:	d106      	bne.n	800adcc <vli_modAdd+0x2e>
 800adbe:	6839      	ldr	r1, [r7, #0]
 800adc0:	68f8      	ldr	r0, [r7, #12]
 800adc2:	f7ff fe3b 	bl	800aa3c <vli_cmp>
 800adc6:	4603      	mov	r3, r0
 800adc8:	2b00      	cmp	r3, #0
 800adca:	db04      	blt.n	800add6 <vli_modAdd+0x38>
        /* result > mod (result = mod + remainder), so subtract mod to get remainder. */
        vli_sub(result, result, mod);
 800adcc:	683a      	ldr	r2, [r7, #0]
 800adce:	68f9      	ldr	r1, [r7, #12]
 800add0:	68f8      	ldr	r0, [r7, #12]
 800add2:	f7ff fec9 	bl	800ab68 <vli_sub>
    }
}
 800add6:	bf00      	nop
 800add8:	3718      	adds	r7, #24
 800adda:	46bd      	mov	sp, r7
 800addc:	bd80      	pop	{r7, pc}

0800adde <vli_modSub>:
   Assumes that left < mod and right < mod, and that result does not overlap mod. */
#if !asm_modSub
static void vli_modSub(uECC_word_t *result,
                       const uECC_word_t *left,
                       const uECC_word_t *right,
                       const uECC_word_t *mod) {
 800adde:	b580      	push	{r7, lr}
 800ade0:	b086      	sub	sp, #24
 800ade2:	af00      	add	r7, sp, #0
 800ade4:	60f8      	str	r0, [r7, #12]
 800ade6:	60b9      	str	r1, [r7, #8]
 800ade8:	607a      	str	r2, [r7, #4]
 800adea:	603b      	str	r3, [r7, #0]
    uECC_word_t l_borrow = vli_sub(result, left, right);
 800adec:	687a      	ldr	r2, [r7, #4]
 800adee:	68b9      	ldr	r1, [r7, #8]
 800adf0:	68f8      	ldr	r0, [r7, #12]
 800adf2:	f7ff feb9 	bl	800ab68 <vli_sub>
 800adf6:	6178      	str	r0, [r7, #20]
    if (l_borrow) {
 800adf8:	697b      	ldr	r3, [r7, #20]
 800adfa:	2b00      	cmp	r3, #0
 800adfc:	d004      	beq.n	800ae08 <vli_modSub+0x2a>
        /* In this case, result == -diff == (max int) - diff. Since -x % d == d - x,
           we can get the correct result from result + mod (with overflow). */
        vli_add(result, result, mod);
 800adfe:	683a      	ldr	r2, [r7, #0]
 800ae00:	68f9      	ldr	r1, [r7, #12]
 800ae02:	68f8      	ldr	r0, [r7, #12]
 800ae04:	f7ff fe70 	bl	800aae8 <vli_add>
    }
}
 800ae08:	bf00      	nop
 800ae0a:	3718      	adds	r7, #24
 800ae0c:	46bd      	mov	sp, r7
 800ae0e:	bd80      	pop	{r7, pc}

0800ae10 <vli_mmod_fast>:
            carry -= vli_sub(result, result, curve_p);
        }
    }
}
#elif uECC_WORD_SIZE == 4
static void vli_mmod_fast(uint32_t *RESTRICT result, uint32_t *RESTRICT product) {
 800ae10:	b580      	push	{r7, lr}
 800ae12:	b08c      	sub	sp, #48	; 0x30
 800ae14:	af00      	add	r7, sp, #0
 800ae16:	6078      	str	r0, [r7, #4]
 800ae18:	6039      	str	r1, [r7, #0]
    uint32_t tmp[uECC_WORDS];
    int carry;

    /* t */
    vli_set(result, product);
 800ae1a:	6839      	ldr	r1, [r7, #0]
 800ae1c:	6878      	ldr	r0, [r7, #4]
 800ae1e:	f7ff fdef 	bl	800aa00 <vli_set>

    /* s1 */
    tmp[0] = tmp[1] = tmp[2] = 0;
 800ae22:	2300      	movs	r3, #0
 800ae24:	617b      	str	r3, [r7, #20]
 800ae26:	697b      	ldr	r3, [r7, #20]
 800ae28:	613b      	str	r3, [r7, #16]
 800ae2a:	693b      	ldr	r3, [r7, #16]
 800ae2c:	60fb      	str	r3, [r7, #12]
    tmp[3] = product[11];
 800ae2e:	683b      	ldr	r3, [r7, #0]
 800ae30:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ae32:	61bb      	str	r3, [r7, #24]
    tmp[4] = product[12];
 800ae34:	683b      	ldr	r3, [r7, #0]
 800ae36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ae38:	61fb      	str	r3, [r7, #28]
    tmp[5] = product[13];
 800ae3a:	683b      	ldr	r3, [r7, #0]
 800ae3c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ae3e:	623b      	str	r3, [r7, #32]
    tmp[6] = product[14];
 800ae40:	683b      	ldr	r3, [r7, #0]
 800ae42:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ae44:	627b      	str	r3, [r7, #36]	; 0x24
    tmp[7] = product[15];
 800ae46:	683b      	ldr	r3, [r7, #0]
 800ae48:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ae4a:	62bb      	str	r3, [r7, #40]	; 0x28
    carry = vli_add(tmp, tmp, tmp);
 800ae4c:	f107 020c 	add.w	r2, r7, #12
 800ae50:	f107 010c 	add.w	r1, r7, #12
 800ae54:	f107 030c 	add.w	r3, r7, #12
 800ae58:	4618      	mov	r0, r3
 800ae5a:	f7ff fe45 	bl	800aae8 <vli_add>
 800ae5e:	4603      	mov	r3, r0
 800ae60:	62fb      	str	r3, [r7, #44]	; 0x2c
    carry += vli_add(result, result, tmp);
 800ae62:	f107 030c 	add.w	r3, r7, #12
 800ae66:	461a      	mov	r2, r3
 800ae68:	6879      	ldr	r1, [r7, #4]
 800ae6a:	6878      	ldr	r0, [r7, #4]
 800ae6c:	f7ff fe3c 	bl	800aae8 <vli_add>
 800ae70:	4602      	mov	r2, r0
 800ae72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae74:	4413      	add	r3, r2
 800ae76:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* s2 */
    tmp[3] = product[12];
 800ae78:	683b      	ldr	r3, [r7, #0]
 800ae7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ae7c:	61bb      	str	r3, [r7, #24]
    tmp[4] = product[13];
 800ae7e:	683b      	ldr	r3, [r7, #0]
 800ae80:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ae82:	61fb      	str	r3, [r7, #28]
    tmp[5] = product[14];
 800ae84:	683b      	ldr	r3, [r7, #0]
 800ae86:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ae88:	623b      	str	r3, [r7, #32]
    tmp[6] = product[15];
 800ae8a:	683b      	ldr	r3, [r7, #0]
 800ae8c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ae8e:	627b      	str	r3, [r7, #36]	; 0x24
    tmp[7] = 0;
 800ae90:	2300      	movs	r3, #0
 800ae92:	62bb      	str	r3, [r7, #40]	; 0x28
    carry += vli_add(tmp, tmp, tmp);
 800ae94:	f107 020c 	add.w	r2, r7, #12
 800ae98:	f107 010c 	add.w	r1, r7, #12
 800ae9c:	f107 030c 	add.w	r3, r7, #12
 800aea0:	4618      	mov	r0, r3
 800aea2:	f7ff fe21 	bl	800aae8 <vli_add>
 800aea6:	4602      	mov	r2, r0
 800aea8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aeaa:	4413      	add	r3, r2
 800aeac:	62fb      	str	r3, [r7, #44]	; 0x2c
    carry += vli_add(result, result, tmp);
 800aeae:	f107 030c 	add.w	r3, r7, #12
 800aeb2:	461a      	mov	r2, r3
 800aeb4:	6879      	ldr	r1, [r7, #4]
 800aeb6:	6878      	ldr	r0, [r7, #4]
 800aeb8:	f7ff fe16 	bl	800aae8 <vli_add>
 800aebc:	4602      	mov	r2, r0
 800aebe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aec0:	4413      	add	r3, r2
 800aec2:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* s3 */
    tmp[0] = product[8];
 800aec4:	683b      	ldr	r3, [r7, #0]
 800aec6:	6a1b      	ldr	r3, [r3, #32]
 800aec8:	60fb      	str	r3, [r7, #12]
    tmp[1] = product[9];
 800aeca:	683b      	ldr	r3, [r7, #0]
 800aecc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aece:	613b      	str	r3, [r7, #16]
    tmp[2] = product[10];
 800aed0:	683b      	ldr	r3, [r7, #0]
 800aed2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800aed4:	617b      	str	r3, [r7, #20]
    tmp[3] = tmp[4] = tmp[5] = 0;
 800aed6:	2300      	movs	r3, #0
 800aed8:	623b      	str	r3, [r7, #32]
 800aeda:	6a3b      	ldr	r3, [r7, #32]
 800aedc:	61fb      	str	r3, [r7, #28]
 800aede:	69fb      	ldr	r3, [r7, #28]
 800aee0:	61bb      	str	r3, [r7, #24]
    tmp[6] = product[14];
 800aee2:	683b      	ldr	r3, [r7, #0]
 800aee4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800aee6:	627b      	str	r3, [r7, #36]	; 0x24
    tmp[7] = product[15];
 800aee8:	683b      	ldr	r3, [r7, #0]
 800aeea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800aeec:	62bb      	str	r3, [r7, #40]	; 0x28
    carry += vli_add(result, result, tmp);
 800aeee:	f107 030c 	add.w	r3, r7, #12
 800aef2:	461a      	mov	r2, r3
 800aef4:	6879      	ldr	r1, [r7, #4]
 800aef6:	6878      	ldr	r0, [r7, #4]
 800aef8:	f7ff fdf6 	bl	800aae8 <vli_add>
 800aefc:	4602      	mov	r2, r0
 800aefe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af00:	4413      	add	r3, r2
 800af02:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* s4 */
    tmp[0] = product[9];
 800af04:	683b      	ldr	r3, [r7, #0]
 800af06:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800af08:	60fb      	str	r3, [r7, #12]
    tmp[1] = product[10];
 800af0a:	683b      	ldr	r3, [r7, #0]
 800af0c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800af0e:	613b      	str	r3, [r7, #16]
    tmp[2] = product[11];
 800af10:	683b      	ldr	r3, [r7, #0]
 800af12:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af14:	617b      	str	r3, [r7, #20]
    tmp[3] = product[13];
 800af16:	683b      	ldr	r3, [r7, #0]
 800af18:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800af1a:	61bb      	str	r3, [r7, #24]
    tmp[4] = product[14];
 800af1c:	683b      	ldr	r3, [r7, #0]
 800af1e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800af20:	61fb      	str	r3, [r7, #28]
    tmp[5] = product[15];
 800af22:	683b      	ldr	r3, [r7, #0]
 800af24:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800af26:	623b      	str	r3, [r7, #32]
    tmp[6] = product[13];
 800af28:	683b      	ldr	r3, [r7, #0]
 800af2a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800af2c:	627b      	str	r3, [r7, #36]	; 0x24
    tmp[7] = product[8];
 800af2e:	683b      	ldr	r3, [r7, #0]
 800af30:	6a1b      	ldr	r3, [r3, #32]
 800af32:	62bb      	str	r3, [r7, #40]	; 0x28
    carry += vli_add(result, result, tmp);
 800af34:	f107 030c 	add.w	r3, r7, #12
 800af38:	461a      	mov	r2, r3
 800af3a:	6879      	ldr	r1, [r7, #4]
 800af3c:	6878      	ldr	r0, [r7, #4]
 800af3e:	f7ff fdd3 	bl	800aae8 <vli_add>
 800af42:	4602      	mov	r2, r0
 800af44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af46:	4413      	add	r3, r2
 800af48:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* d1 */
    tmp[0] = product[11];
 800af4a:	683b      	ldr	r3, [r7, #0]
 800af4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af4e:	60fb      	str	r3, [r7, #12]
    tmp[1] = product[12];
 800af50:	683b      	ldr	r3, [r7, #0]
 800af52:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af54:	613b      	str	r3, [r7, #16]
    tmp[2] = product[13];
 800af56:	683b      	ldr	r3, [r7, #0]
 800af58:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800af5a:	617b      	str	r3, [r7, #20]
    tmp[3] = tmp[4] = tmp[5] = 0;
 800af5c:	2300      	movs	r3, #0
 800af5e:	623b      	str	r3, [r7, #32]
 800af60:	6a3b      	ldr	r3, [r7, #32]
 800af62:	61fb      	str	r3, [r7, #28]
 800af64:	69fb      	ldr	r3, [r7, #28]
 800af66:	61bb      	str	r3, [r7, #24]
    tmp[6] = product[8];
 800af68:	683b      	ldr	r3, [r7, #0]
 800af6a:	6a1b      	ldr	r3, [r3, #32]
 800af6c:	627b      	str	r3, [r7, #36]	; 0x24
    tmp[7] = product[10];
 800af6e:	683b      	ldr	r3, [r7, #0]
 800af70:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800af72:	62bb      	str	r3, [r7, #40]	; 0x28
    carry -= vli_sub(result, result, tmp);
 800af74:	f107 030c 	add.w	r3, r7, #12
 800af78:	461a      	mov	r2, r3
 800af7a:	6879      	ldr	r1, [r7, #4]
 800af7c:	6878      	ldr	r0, [r7, #4]
 800af7e:	f7ff fdf3 	bl	800ab68 <vli_sub>
 800af82:	4602      	mov	r2, r0
 800af84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af86:	1a9b      	subs	r3, r3, r2
 800af88:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* d2 */
    tmp[0] = product[12];
 800af8a:	683b      	ldr	r3, [r7, #0]
 800af8c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af8e:	60fb      	str	r3, [r7, #12]
    tmp[1] = product[13];
 800af90:	683b      	ldr	r3, [r7, #0]
 800af92:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800af94:	613b      	str	r3, [r7, #16]
    tmp[2] = product[14];
 800af96:	683b      	ldr	r3, [r7, #0]
 800af98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800af9a:	617b      	str	r3, [r7, #20]
    tmp[3] = product[15];
 800af9c:	683b      	ldr	r3, [r7, #0]
 800af9e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800afa0:	61bb      	str	r3, [r7, #24]
    tmp[4] = tmp[5] = 0;
 800afa2:	2300      	movs	r3, #0
 800afa4:	623b      	str	r3, [r7, #32]
 800afa6:	6a3b      	ldr	r3, [r7, #32]
 800afa8:	61fb      	str	r3, [r7, #28]
    tmp[6] = product[9];
 800afaa:	683b      	ldr	r3, [r7, #0]
 800afac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800afae:	627b      	str	r3, [r7, #36]	; 0x24
    tmp[7] = product[11];
 800afb0:	683b      	ldr	r3, [r7, #0]
 800afb2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800afb4:	62bb      	str	r3, [r7, #40]	; 0x28
    carry -= vli_sub(result, result, tmp);
 800afb6:	f107 030c 	add.w	r3, r7, #12
 800afba:	461a      	mov	r2, r3
 800afbc:	6879      	ldr	r1, [r7, #4]
 800afbe:	6878      	ldr	r0, [r7, #4]
 800afc0:	f7ff fdd2 	bl	800ab68 <vli_sub>
 800afc4:	4602      	mov	r2, r0
 800afc6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afc8:	1a9b      	subs	r3, r3, r2
 800afca:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* d3 */
    tmp[0] = product[13];
 800afcc:	683b      	ldr	r3, [r7, #0]
 800afce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800afd0:	60fb      	str	r3, [r7, #12]
    tmp[1] = product[14];
 800afd2:	683b      	ldr	r3, [r7, #0]
 800afd4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800afd6:	613b      	str	r3, [r7, #16]
    tmp[2] = product[15];
 800afd8:	683b      	ldr	r3, [r7, #0]
 800afda:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800afdc:	617b      	str	r3, [r7, #20]
    tmp[3] = product[8];
 800afde:	683b      	ldr	r3, [r7, #0]
 800afe0:	6a1b      	ldr	r3, [r3, #32]
 800afe2:	61bb      	str	r3, [r7, #24]
    tmp[4] = product[9];
 800afe4:	683b      	ldr	r3, [r7, #0]
 800afe6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800afe8:	61fb      	str	r3, [r7, #28]
    tmp[5] = product[10];
 800afea:	683b      	ldr	r3, [r7, #0]
 800afec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800afee:	623b      	str	r3, [r7, #32]
    tmp[6] = 0;
 800aff0:	2300      	movs	r3, #0
 800aff2:	627b      	str	r3, [r7, #36]	; 0x24
    tmp[7] = product[12];
 800aff4:	683b      	ldr	r3, [r7, #0]
 800aff6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aff8:	62bb      	str	r3, [r7, #40]	; 0x28
    carry -= vli_sub(result, result, tmp);
 800affa:	f107 030c 	add.w	r3, r7, #12
 800affe:	461a      	mov	r2, r3
 800b000:	6879      	ldr	r1, [r7, #4]
 800b002:	6878      	ldr	r0, [r7, #4]
 800b004:	f7ff fdb0 	bl	800ab68 <vli_sub>
 800b008:	4602      	mov	r2, r0
 800b00a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b00c:	1a9b      	subs	r3, r3, r2
 800b00e:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* d4 */
    tmp[0] = product[14];
 800b010:	683b      	ldr	r3, [r7, #0]
 800b012:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b014:	60fb      	str	r3, [r7, #12]
    tmp[1] = product[15];
 800b016:	683b      	ldr	r3, [r7, #0]
 800b018:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b01a:	613b      	str	r3, [r7, #16]
    tmp[2] = 0;
 800b01c:	2300      	movs	r3, #0
 800b01e:	617b      	str	r3, [r7, #20]
    tmp[3] = product[9];
 800b020:	683b      	ldr	r3, [r7, #0]
 800b022:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b024:	61bb      	str	r3, [r7, #24]
    tmp[4] = product[10];
 800b026:	683b      	ldr	r3, [r7, #0]
 800b028:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b02a:	61fb      	str	r3, [r7, #28]
    tmp[5] = product[11];
 800b02c:	683b      	ldr	r3, [r7, #0]
 800b02e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b030:	623b      	str	r3, [r7, #32]
    tmp[6] = 0;
 800b032:	2300      	movs	r3, #0
 800b034:	627b      	str	r3, [r7, #36]	; 0x24
    tmp[7] = product[13];
 800b036:	683b      	ldr	r3, [r7, #0]
 800b038:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800b03a:	62bb      	str	r3, [r7, #40]	; 0x28
    carry -= vli_sub(result, result, tmp);
 800b03c:	f107 030c 	add.w	r3, r7, #12
 800b040:	461a      	mov	r2, r3
 800b042:	6879      	ldr	r1, [r7, #4]
 800b044:	6878      	ldr	r0, [r7, #4]
 800b046:	f7ff fd8f 	bl	800ab68 <vli_sub>
 800b04a:	4602      	mov	r2, r0
 800b04c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b04e:	1a9b      	subs	r3, r3, r2
 800b050:	62fb      	str	r3, [r7, #44]	; 0x2c

    if (carry < 0) {
 800b052:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b054:	2b00      	cmp	r3, #0
 800b056:	da15      	bge.n	800b084 <vli_mmod_fast+0x274>
        do {
            carry += vli_add(result, result, curve_p);
 800b058:	4a11      	ldr	r2, [pc, #68]	; (800b0a0 <vli_mmod_fast+0x290>)
 800b05a:	6879      	ldr	r1, [r7, #4]
 800b05c:	6878      	ldr	r0, [r7, #4]
 800b05e:	f7ff fd43 	bl	800aae8 <vli_add>
 800b062:	4602      	mov	r2, r0
 800b064:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b066:	4413      	add	r3, r2
 800b068:	62fb      	str	r3, [r7, #44]	; 0x2c
        } while (carry < 0);
 800b06a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b06c:	2b00      	cmp	r3, #0
 800b06e:	dbf3      	blt.n	800b058 <vli_mmod_fast+0x248>
    } else {
        while (carry || vli_cmp(curve_p, result) != 1) {
            carry -= vli_sub(result, result, curve_p);
        }
    }
}
 800b070:	e012      	b.n	800b098 <vli_mmod_fast+0x288>
            carry -= vli_sub(result, result, curve_p);
 800b072:	4a0b      	ldr	r2, [pc, #44]	; (800b0a0 <vli_mmod_fast+0x290>)
 800b074:	6879      	ldr	r1, [r7, #4]
 800b076:	6878      	ldr	r0, [r7, #4]
 800b078:	f7ff fd76 	bl	800ab68 <vli_sub>
 800b07c:	4602      	mov	r2, r0
 800b07e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b080:	1a9b      	subs	r3, r3, r2
 800b082:	62fb      	str	r3, [r7, #44]	; 0x2c
        while (carry || vli_cmp(curve_p, result) != 1) {
 800b084:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b086:	2b00      	cmp	r3, #0
 800b088:	d1f3      	bne.n	800b072 <vli_mmod_fast+0x262>
 800b08a:	6879      	ldr	r1, [r7, #4]
 800b08c:	4804      	ldr	r0, [pc, #16]	; (800b0a0 <vli_mmod_fast+0x290>)
 800b08e:	f7ff fcd5 	bl	800aa3c <vli_cmp>
 800b092:	4603      	mov	r3, r0
 800b094:	2b01      	cmp	r3, #1
 800b096:	d1ec      	bne.n	800b072 <vli_mmod_fast+0x262>
}
 800b098:	bf00      	nop
 800b09a:	3730      	adds	r7, #48	; 0x30
 800b09c:	46bd      	mov	sp, r7
 800b09e:	bd80      	pop	{r7, pc}
 800b0a0:	0803088c 	.word	0x0803088c

0800b0a4 <vli_modMult_fast>:
#endif /* !asm_mmod_fast */

/* Computes result = (left * right) % curve_p. */
static void vli_modMult_fast(uECC_word_t *result,
                             const uECC_word_t *left,
                             const uECC_word_t *right) {
 800b0a4:	b580      	push	{r7, lr}
 800b0a6:	b094      	sub	sp, #80	; 0x50
 800b0a8:	af00      	add	r7, sp, #0
 800b0aa:	60f8      	str	r0, [r7, #12]
 800b0ac:	60b9      	str	r1, [r7, #8]
 800b0ae:	607a      	str	r2, [r7, #4]
    uECC_word_t product[2 * uECC_WORDS];
    vli_mult(product, left, right);
 800b0b0:	f107 0310 	add.w	r3, r7, #16
 800b0b4:	687a      	ldr	r2, [r7, #4]
 800b0b6:	68b9      	ldr	r1, [r7, #8]
 800b0b8:	4618      	mov	r0, r3
 800b0ba:	f7ff fdf2 	bl	800aca2 <vli_mult>
    vli_mmod_fast(result, product);
 800b0be:	f107 0310 	add.w	r3, r7, #16
 800b0c2:	4619      	mov	r1, r3
 800b0c4:	68f8      	ldr	r0, [r7, #12]
 800b0c6:	f7ff fea3 	bl	800ae10 <vli_mmod_fast>
}
 800b0ca:	bf00      	nop
 800b0cc:	3750      	adds	r7, #80	; 0x50
 800b0ce:	46bd      	mov	sp, r7
 800b0d0:	bd80      	pop	{r7, pc}

0800b0d2 <vli_modInv>:
#define EVEN(vli) (!(vli[0] & 1))
/* Computes result = (1 / input) % mod. All VLIs are the same size.
   See "From Euclid's GCD to Montgomery Multiplication to the Great Divide"
   https://labs.oracle.com/techrep/2001/smli_tr-2001-95.pdf */
#if !asm_modInv
static void vli_modInv(uECC_word_t *result, const uECC_word_t *input, const uECC_word_t *mod) {
 800b0d2:	b580      	push	{r7, lr}
 800b0d4:	b0a6      	sub	sp, #152	; 0x98
 800b0d6:	af00      	add	r7, sp, #0
 800b0d8:	60f8      	str	r0, [r7, #12]
 800b0da:	60b9      	str	r1, [r7, #8]
 800b0dc:	607a      	str	r2, [r7, #4]
    uECC_word_t a[uECC_WORDS], b[uECC_WORDS], u[uECC_WORDS], v[uECC_WORDS];
    uECC_word_t carry;
    cmpresult_t cmpResult;

    if (vli_isZero(input)) {
 800b0de:	68b8      	ldr	r0, [r7, #8]
 800b0e0:	f7ff fc59 	bl	800a996 <vli_isZero>
 800b0e4:	4603      	mov	r3, r0
 800b0e6:	2b00      	cmp	r3, #0
 800b0e8:	d003      	beq.n	800b0f2 <vli_modInv+0x20>
        vli_clear(result);
 800b0ea:	68f8      	ldr	r0, [r7, #12]
 800b0ec:	f7ff fc3a 	bl	800a964 <vli_clear>
 800b0f0:	e111      	b.n	800b316 <vli_modInv+0x244>
        return;
    }

    vli_set(a, input);
 800b0f2:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800b0f6:	68b9      	ldr	r1, [r7, #8]
 800b0f8:	4618      	mov	r0, r3
 800b0fa:	f7ff fc81 	bl	800aa00 <vli_set>
    vli_set(b, mod);
 800b0fe:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800b102:	6879      	ldr	r1, [r7, #4]
 800b104:	4618      	mov	r0, r3
 800b106:	f7ff fc7b 	bl	800aa00 <vli_set>
    vli_clear(u);
 800b10a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b10e:	4618      	mov	r0, r3
 800b110:	f7ff fc28 	bl	800a964 <vli_clear>
    u[0] = 1;
 800b114:	2301      	movs	r3, #1
 800b116:	633b      	str	r3, [r7, #48]	; 0x30
    vli_clear(v);
 800b118:	f107 0310 	add.w	r3, r7, #16
 800b11c:	4618      	mov	r0, r3
 800b11e:	f7ff fc21 	bl	800a964 <vli_clear>
    while ((cmpResult = vli_cmp(a, b)) != 0) {
 800b122:	e0e3      	b.n	800b2ec <vli_modInv+0x21a>
        carry = 0;
 800b124:	2300      	movs	r3, #0
 800b126:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
        if (EVEN(a)) {
 800b12a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800b12c:	f003 0301 	and.w	r3, r3, #1
 800b130:	2b00      	cmp	r3, #0
 800b132:	d122      	bne.n	800b17a <vli_modInv+0xa8>
            vli_rshift1(a);
 800b134:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800b138:	4618      	mov	r0, r3
 800b13a:	f7ff fcb1 	bl	800aaa0 <vli_rshift1>
            if (!EVEN(u)) {
 800b13e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b140:	f003 0301 	and.w	r3, r3, #1
 800b144:	2b00      	cmp	r3, #0
 800b146:	d009      	beq.n	800b15c <vli_modInv+0x8a>
                carry = vli_add(u, u, mod);
 800b148:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800b14c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b150:	687a      	ldr	r2, [r7, #4]
 800b152:	4618      	mov	r0, r3
 800b154:	f7ff fcc8 	bl	800aae8 <vli_add>
 800b158:	f8c7 0094 	str.w	r0, [r7, #148]	; 0x94
            }
            vli_rshift1(u);
 800b15c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b160:	4618      	mov	r0, r3
 800b162:	f7ff fc9d 	bl	800aaa0 <vli_rshift1>
            if (carry) {
 800b166:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800b16a:	2b00      	cmp	r3, #0
 800b16c:	f000 80be 	beq.w	800b2ec <vli_modInv+0x21a>
                u[uECC_WORDS - 1] |= HIGH_BIT_SET;
 800b170:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b172:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800b176:	64fb      	str	r3, [r7, #76]	; 0x4c
 800b178:	e0b8      	b.n	800b2ec <vli_modInv+0x21a>
            }
        } else if (EVEN(b)) {
 800b17a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b17c:	f003 0301 	and.w	r3, r3, #1
 800b180:	2b00      	cmp	r3, #0
 800b182:	d122      	bne.n	800b1ca <vli_modInv+0xf8>
            vli_rshift1(b);
 800b184:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800b188:	4618      	mov	r0, r3
 800b18a:	f7ff fc89 	bl	800aaa0 <vli_rshift1>
            if (!EVEN(v)) {
 800b18e:	693b      	ldr	r3, [r7, #16]
 800b190:	f003 0301 	and.w	r3, r3, #1
 800b194:	2b00      	cmp	r3, #0
 800b196:	d009      	beq.n	800b1ac <vli_modInv+0xda>
                carry = vli_add(v, v, mod);
 800b198:	f107 0110 	add.w	r1, r7, #16
 800b19c:	f107 0310 	add.w	r3, r7, #16
 800b1a0:	687a      	ldr	r2, [r7, #4]
 800b1a2:	4618      	mov	r0, r3
 800b1a4:	f7ff fca0 	bl	800aae8 <vli_add>
 800b1a8:	f8c7 0094 	str.w	r0, [r7, #148]	; 0x94
            }
            vli_rshift1(v);
 800b1ac:	f107 0310 	add.w	r3, r7, #16
 800b1b0:	4618      	mov	r0, r3
 800b1b2:	f7ff fc75 	bl	800aaa0 <vli_rshift1>
            if (carry) {
 800b1b6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800b1ba:	2b00      	cmp	r3, #0
 800b1bc:	f000 8096 	beq.w	800b2ec <vli_modInv+0x21a>
                v[uECC_WORDS - 1] |= HIGH_BIT_SET;
 800b1c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1c2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800b1c6:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b1c8:	e090      	b.n	800b2ec <vli_modInv+0x21a>
            }
        } else if (cmpResult > 0) {
 800b1ca:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b1ce:	2b00      	cmp	r3, #0
 800b1d0:	dd46      	ble.n	800b260 <vli_modInv+0x18e>
            vli_sub(a, a, b);
 800b1d2:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b1d6:	f107 0170 	add.w	r1, r7, #112	; 0x70
 800b1da:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800b1de:	4618      	mov	r0, r3
 800b1e0:	f7ff fcc2 	bl	800ab68 <vli_sub>
            vli_rshift1(a);
 800b1e4:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800b1e8:	4618      	mov	r0, r3
 800b1ea:	f7ff fc59 	bl	800aaa0 <vli_rshift1>
            if (vli_cmp(u, v) < 0) {
 800b1ee:	f107 0210 	add.w	r2, r7, #16
 800b1f2:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b1f6:	4611      	mov	r1, r2
 800b1f8:	4618      	mov	r0, r3
 800b1fa:	f7ff fc1f 	bl	800aa3c <vli_cmp>
 800b1fe:	4603      	mov	r3, r0
 800b200:	2b00      	cmp	r3, #0
 800b202:	da07      	bge.n	800b214 <vli_modInv+0x142>
                vli_add(u, u, mod);
 800b204:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800b208:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b20c:	687a      	ldr	r2, [r7, #4]
 800b20e:	4618      	mov	r0, r3
 800b210:	f7ff fc6a 	bl	800aae8 <vli_add>
            }
            vli_sub(u, u, v);
 800b214:	f107 0210 	add.w	r2, r7, #16
 800b218:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800b21c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b220:	4618      	mov	r0, r3
 800b222:	f7ff fca1 	bl	800ab68 <vli_sub>
            if (!EVEN(u)) {
 800b226:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b228:	f003 0301 	and.w	r3, r3, #1
 800b22c:	2b00      	cmp	r3, #0
 800b22e:	d009      	beq.n	800b244 <vli_modInv+0x172>
                carry = vli_add(u, u, mod);
 800b230:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800b234:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b238:	687a      	ldr	r2, [r7, #4]
 800b23a:	4618      	mov	r0, r3
 800b23c:	f7ff fc54 	bl	800aae8 <vli_add>
 800b240:	f8c7 0094 	str.w	r0, [r7, #148]	; 0x94
            }
            vli_rshift1(u);
 800b244:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b248:	4618      	mov	r0, r3
 800b24a:	f7ff fc29 	bl	800aaa0 <vli_rshift1>
            if (carry) {
 800b24e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800b252:	2b00      	cmp	r3, #0
 800b254:	d04a      	beq.n	800b2ec <vli_modInv+0x21a>
                u[uECC_WORDS - 1] |= HIGH_BIT_SET;
 800b256:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b258:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800b25c:	64fb      	str	r3, [r7, #76]	; 0x4c
 800b25e:	e045      	b.n	800b2ec <vli_modInv+0x21a>
            }
        } else {
            vli_sub(b, b, a);
 800b260:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b264:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800b268:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800b26c:	4618      	mov	r0, r3
 800b26e:	f7ff fc7b 	bl	800ab68 <vli_sub>
            vli_rshift1(b);
 800b272:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800b276:	4618      	mov	r0, r3
 800b278:	f7ff fc12 	bl	800aaa0 <vli_rshift1>
            if (vli_cmp(v, u) < 0) {
 800b27c:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b280:	f107 0310 	add.w	r3, r7, #16
 800b284:	4611      	mov	r1, r2
 800b286:	4618      	mov	r0, r3
 800b288:	f7ff fbd8 	bl	800aa3c <vli_cmp>
 800b28c:	4603      	mov	r3, r0
 800b28e:	2b00      	cmp	r3, #0
 800b290:	da07      	bge.n	800b2a2 <vli_modInv+0x1d0>
                vli_add(v, v, mod);
 800b292:	f107 0110 	add.w	r1, r7, #16
 800b296:	f107 0310 	add.w	r3, r7, #16
 800b29a:	687a      	ldr	r2, [r7, #4]
 800b29c:	4618      	mov	r0, r3
 800b29e:	f7ff fc23 	bl	800aae8 <vli_add>
            }
            vli_sub(v, v, u);
 800b2a2:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b2a6:	f107 0110 	add.w	r1, r7, #16
 800b2aa:	f107 0310 	add.w	r3, r7, #16
 800b2ae:	4618      	mov	r0, r3
 800b2b0:	f7ff fc5a 	bl	800ab68 <vli_sub>
            if (!EVEN(v)) {
 800b2b4:	693b      	ldr	r3, [r7, #16]
 800b2b6:	f003 0301 	and.w	r3, r3, #1
 800b2ba:	2b00      	cmp	r3, #0
 800b2bc:	d009      	beq.n	800b2d2 <vli_modInv+0x200>
                carry = vli_add(v, v, mod);
 800b2be:	f107 0110 	add.w	r1, r7, #16
 800b2c2:	f107 0310 	add.w	r3, r7, #16
 800b2c6:	687a      	ldr	r2, [r7, #4]
 800b2c8:	4618      	mov	r0, r3
 800b2ca:	f7ff fc0d 	bl	800aae8 <vli_add>
 800b2ce:	f8c7 0094 	str.w	r0, [r7, #148]	; 0x94
            }
            vli_rshift1(v);
 800b2d2:	f107 0310 	add.w	r3, r7, #16
 800b2d6:	4618      	mov	r0, r3
 800b2d8:	f7ff fbe2 	bl	800aaa0 <vli_rshift1>
            if (carry) {
 800b2dc:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800b2e0:	2b00      	cmp	r3, #0
 800b2e2:	d003      	beq.n	800b2ec <vli_modInv+0x21a>
                v[uECC_WORDS - 1] |= HIGH_BIT_SET;
 800b2e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2e6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800b2ea:	62fb      	str	r3, [r7, #44]	; 0x2c
    while ((cmpResult = vli_cmp(a, b)) != 0) {
 800b2ec:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b2f0:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800b2f4:	4611      	mov	r1, r2
 800b2f6:	4618      	mov	r0, r3
 800b2f8:	f7ff fba0 	bl	800aa3c <vli_cmp>
 800b2fc:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
 800b300:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800b304:	2b00      	cmp	r3, #0
 800b306:	f47f af0d 	bne.w	800b124 <vli_modInv+0x52>
            }
        }
    }
    vli_set(result, u);
 800b30a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b30e:	4619      	mov	r1, r3
 800b310:	68f8      	ldr	r0, [r7, #12]
 800b312:	f7ff fb75 	bl	800aa00 <vli_set>
}
 800b316:	3798      	adds	r7, #152	; 0x98
 800b318:	46bd      	mov	sp, r7
 800b31a:	bd80      	pop	{r7, pc}

0800b31c <EccPoint_isZero>:
#endif /* !asm_modInv */

/* ------ Point operations ------ */

/* Returns 1 if 'point' is the point at infinity, 0 otherwise. */
static cmpresult_t EccPoint_isZero(const EccPoint *point) {
 800b31c:	b580      	push	{r7, lr}
 800b31e:	b082      	sub	sp, #8
 800b320:	af00      	add	r7, sp, #0
 800b322:	6078      	str	r0, [r7, #4]
    return (vli_isZero(point->x) && vli_isZero(point->y));
 800b324:	687b      	ldr	r3, [r7, #4]
 800b326:	4618      	mov	r0, r3
 800b328:	f7ff fb35 	bl	800a996 <vli_isZero>
 800b32c:	4603      	mov	r3, r0
 800b32e:	2b00      	cmp	r3, #0
 800b330:	d009      	beq.n	800b346 <EccPoint_isZero+0x2a>
 800b332:	687b      	ldr	r3, [r7, #4]
 800b334:	3320      	adds	r3, #32
 800b336:	4618      	mov	r0, r3
 800b338:	f7ff fb2d 	bl	800a996 <vli_isZero>
 800b33c:	4603      	mov	r3, r0
 800b33e:	2b00      	cmp	r3, #0
 800b340:	d001      	beq.n	800b346 <EccPoint_isZero+0x2a>
 800b342:	2301      	movs	r3, #1
 800b344:	e000      	b.n	800b348 <EccPoint_isZero+0x2c>
 800b346:	2300      	movs	r3, #0
}
 800b348:	4618      	mov	r0, r3
 800b34a:	3708      	adds	r7, #8
 800b34c:	46bd      	mov	sp, r7
 800b34e:	bd80      	pop	{r7, pc}

0800b350 <EccPoint_double_jacobian>:
    vli_modSub(Y1, Y1, t5, curve_p); /* t2 = B * (A - x3) - y1^4 = y3 */
}
#else
static void EccPoint_double_jacobian(uECC_word_t * RESTRICT X1,
                                     uECC_word_t * RESTRICT Y1,
                                     uECC_word_t * RESTRICT Z1) {
 800b350:	b580      	push	{r7, lr}
 800b352:	b096      	sub	sp, #88	; 0x58
 800b354:	af00      	add	r7, sp, #0
 800b356:	60f8      	str	r0, [r7, #12]
 800b358:	60b9      	str	r1, [r7, #8]
 800b35a:	607a      	str	r2, [r7, #4]
    /* t1 = X, t2 = Y, t3 = Z */
    uECC_word_t t4[uECC_WORDS];
    uECC_word_t t5[uECC_WORDS];

    if (vli_isZero(Z1)) {
 800b35c:	6878      	ldr	r0, [r7, #4]
 800b35e:	f7ff fb1a 	bl	800a996 <vli_isZero>
 800b362:	4603      	mov	r3, r0
 800b364:	2b00      	cmp	r3, #0
 800b366:	f040 809b 	bne.w	800b4a0 <EccPoint_double_jacobian+0x150>
        return;
    }

    vli_modSquare_fast(t4, Y1);   /* t4 = y1^2 */
 800b36a:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800b36e:	68ba      	ldr	r2, [r7, #8]
 800b370:	68b9      	ldr	r1, [r7, #8]
 800b372:	4618      	mov	r0, r3
 800b374:	f7ff fe96 	bl	800b0a4 <vli_modMult_fast>
    vli_modMult_fast(t5, X1, t4); /* t5 = x1*y1^2 = A */
 800b378:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800b37c:	f107 0314 	add.w	r3, r7, #20
 800b380:	68f9      	ldr	r1, [r7, #12]
 800b382:	4618      	mov	r0, r3
 800b384:	f7ff fe8e 	bl	800b0a4 <vli_modMult_fast>
    vli_modSquare_fast(t4, t4);   /* t4 = y1^4 */
 800b388:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800b38c:	f107 0134 	add.w	r1, r7, #52	; 0x34
 800b390:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800b394:	4618      	mov	r0, r3
 800b396:	f7ff fe85 	bl	800b0a4 <vli_modMult_fast>
    vli_modMult_fast(Y1, Y1, Z1); /* t2 = y1*z1 = z3 */
 800b39a:	687a      	ldr	r2, [r7, #4]
 800b39c:	68b9      	ldr	r1, [r7, #8]
 800b39e:	68b8      	ldr	r0, [r7, #8]
 800b3a0:	f7ff fe80 	bl	800b0a4 <vli_modMult_fast>
    vli_modSquare_fast(Z1, Z1);   /* t3 = z1^2 */
 800b3a4:	687a      	ldr	r2, [r7, #4]
 800b3a6:	6879      	ldr	r1, [r7, #4]
 800b3a8:	6878      	ldr	r0, [r7, #4]
 800b3aa:	f7ff fe7b 	bl	800b0a4 <vli_modMult_fast>

    vli_modAdd(X1, X1, Z1, curve_p); /* t1 = x1 + z1^2 */
 800b3ae:	4b3e      	ldr	r3, [pc, #248]	; (800b4a8 <EccPoint_double_jacobian+0x158>)
 800b3b0:	687a      	ldr	r2, [r7, #4]
 800b3b2:	68f9      	ldr	r1, [r7, #12]
 800b3b4:	68f8      	ldr	r0, [r7, #12]
 800b3b6:	f7ff fcf2 	bl	800ad9e <vli_modAdd>
    vli_modAdd(Z1, Z1, Z1, curve_p); /* t3 = 2*z1^2 */
 800b3ba:	4b3b      	ldr	r3, [pc, #236]	; (800b4a8 <EccPoint_double_jacobian+0x158>)
 800b3bc:	687a      	ldr	r2, [r7, #4]
 800b3be:	6879      	ldr	r1, [r7, #4]
 800b3c0:	6878      	ldr	r0, [r7, #4]
 800b3c2:	f7ff fcec 	bl	800ad9e <vli_modAdd>
    vli_modSub_fast(Z1, X1, Z1);     /* t3 = x1 - z1^2 */
 800b3c6:	4b38      	ldr	r3, [pc, #224]	; (800b4a8 <EccPoint_double_jacobian+0x158>)
 800b3c8:	687a      	ldr	r2, [r7, #4]
 800b3ca:	68f9      	ldr	r1, [r7, #12]
 800b3cc:	6878      	ldr	r0, [r7, #4]
 800b3ce:	f7ff fd06 	bl	800adde <vli_modSub>
    vli_modMult_fast(X1, X1, Z1);    /* t1 = x1^2 - z1^4 */
 800b3d2:	687a      	ldr	r2, [r7, #4]
 800b3d4:	68f9      	ldr	r1, [r7, #12]
 800b3d6:	68f8      	ldr	r0, [r7, #12]
 800b3d8:	f7ff fe64 	bl	800b0a4 <vli_modMult_fast>

    vli_modAdd(Z1, X1, X1, curve_p); /* t3 = 2*(x1^2 - z1^4) */
 800b3dc:	4b32      	ldr	r3, [pc, #200]	; (800b4a8 <EccPoint_double_jacobian+0x158>)
 800b3de:	68fa      	ldr	r2, [r7, #12]
 800b3e0:	68f9      	ldr	r1, [r7, #12]
 800b3e2:	6878      	ldr	r0, [r7, #4]
 800b3e4:	f7ff fcdb 	bl	800ad9e <vli_modAdd>
    vli_modAdd(X1, X1, Z1, curve_p); /* t1 = 3*(x1^2 - z1^4) */
 800b3e8:	4b2f      	ldr	r3, [pc, #188]	; (800b4a8 <EccPoint_double_jacobian+0x158>)
 800b3ea:	687a      	ldr	r2, [r7, #4]
 800b3ec:	68f9      	ldr	r1, [r7, #12]
 800b3ee:	68f8      	ldr	r0, [r7, #12]
 800b3f0:	f7ff fcd5 	bl	800ad9e <vli_modAdd>
    if (vli_testBit(X1, 0)) {
 800b3f4:	2100      	movs	r1, #0
 800b3f6:	68f8      	ldr	r0, [r7, #12]
 800b3f8:	f7ff faea 	bl	800a9d0 <vli_testBit>
 800b3fc:	4603      	mov	r3, r0
 800b3fe:	2b00      	cmp	r3, #0
 800b400:	d012      	beq.n	800b428 <EccPoint_double_jacobian+0xd8>
        uECC_word_t l_carry = vli_add(X1, X1, curve_p);
 800b402:	4a29      	ldr	r2, [pc, #164]	; (800b4a8 <EccPoint_double_jacobian+0x158>)
 800b404:	68f9      	ldr	r1, [r7, #12]
 800b406:	68f8      	ldr	r0, [r7, #12]
 800b408:	f7ff fb6e 	bl	800aae8 <vli_add>
 800b40c:	6578      	str	r0, [r7, #84]	; 0x54
        vli_rshift1(X1);
 800b40e:	68f8      	ldr	r0, [r7, #12]
 800b410:	f7ff fb46 	bl	800aaa0 <vli_rshift1>
        X1[uECC_WORDS - 1] |= l_carry << (uECC_WORD_BITS - 1);
 800b414:	68fb      	ldr	r3, [r7, #12]
 800b416:	331c      	adds	r3, #28
 800b418:	6819      	ldr	r1, [r3, #0]
 800b41a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b41c:	07da      	lsls	r2, r3, #31
 800b41e:	68fb      	ldr	r3, [r7, #12]
 800b420:	331c      	adds	r3, #28
 800b422:	430a      	orrs	r2, r1
 800b424:	601a      	str	r2, [r3, #0]
 800b426:	e002      	b.n	800b42e <EccPoint_double_jacobian+0xde>
    } else {
        vli_rshift1(X1);
 800b428:	68f8      	ldr	r0, [r7, #12]
 800b42a:	f7ff fb39 	bl	800aaa0 <vli_rshift1>
    }
    /* t1 = 3/2*(x1^2 - z1^4) = B */

    vli_modSquare_fast(Z1, X1);   /* t3 = B^2 */
 800b42e:	68fa      	ldr	r2, [r7, #12]
 800b430:	68f9      	ldr	r1, [r7, #12]
 800b432:	6878      	ldr	r0, [r7, #4]
 800b434:	f7ff fe36 	bl	800b0a4 <vli_modMult_fast>
    vli_modSub_fast(Z1, Z1, t5);  /* t3 = B^2 - A */
 800b438:	f107 0214 	add.w	r2, r7, #20
 800b43c:	4b1a      	ldr	r3, [pc, #104]	; (800b4a8 <EccPoint_double_jacobian+0x158>)
 800b43e:	6879      	ldr	r1, [r7, #4]
 800b440:	6878      	ldr	r0, [r7, #4]
 800b442:	f7ff fccc 	bl	800adde <vli_modSub>
    vli_modSub_fast(Z1, Z1, t5);  /* t3 = B^2 - 2A = x3 */
 800b446:	f107 0214 	add.w	r2, r7, #20
 800b44a:	4b17      	ldr	r3, [pc, #92]	; (800b4a8 <EccPoint_double_jacobian+0x158>)
 800b44c:	6879      	ldr	r1, [r7, #4]
 800b44e:	6878      	ldr	r0, [r7, #4]
 800b450:	f7ff fcc5 	bl	800adde <vli_modSub>
    vli_modSub_fast(t5, t5, Z1);  /* t5 = A - x3 */
 800b454:	f107 0114 	add.w	r1, r7, #20
 800b458:	f107 0014 	add.w	r0, r7, #20
 800b45c:	4b12      	ldr	r3, [pc, #72]	; (800b4a8 <EccPoint_double_jacobian+0x158>)
 800b45e:	687a      	ldr	r2, [r7, #4]
 800b460:	f7ff fcbd 	bl	800adde <vli_modSub>
    vli_modMult_fast(X1, X1, t5); /* t1 = B * (A - x3) */
 800b464:	f107 0314 	add.w	r3, r7, #20
 800b468:	461a      	mov	r2, r3
 800b46a:	68f9      	ldr	r1, [r7, #12]
 800b46c:	68f8      	ldr	r0, [r7, #12]
 800b46e:	f7ff fe19 	bl	800b0a4 <vli_modMult_fast>
    vli_modSub_fast(t4, X1, t4);  /* t4 = B * (A - x3) - y1^4 = y3 */
 800b472:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800b476:	f107 0034 	add.w	r0, r7, #52	; 0x34
 800b47a:	4b0b      	ldr	r3, [pc, #44]	; (800b4a8 <EccPoint_double_jacobian+0x158>)
 800b47c:	68f9      	ldr	r1, [r7, #12]
 800b47e:	f7ff fcae 	bl	800adde <vli_modSub>

    vli_set(X1, Z1);
 800b482:	6879      	ldr	r1, [r7, #4]
 800b484:	68f8      	ldr	r0, [r7, #12]
 800b486:	f7ff fabb 	bl	800aa00 <vli_set>
    vli_set(Z1, Y1);
 800b48a:	68b9      	ldr	r1, [r7, #8]
 800b48c:	6878      	ldr	r0, [r7, #4]
 800b48e:	f7ff fab7 	bl	800aa00 <vli_set>
    vli_set(Y1, t4);
 800b492:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800b496:	4619      	mov	r1, r3
 800b498:	68b8      	ldr	r0, [r7, #8]
 800b49a:	f7ff fab1 	bl	800aa00 <vli_set>
 800b49e:	e000      	b.n	800b4a2 <EccPoint_double_jacobian+0x152>
        return;
 800b4a0:	bf00      	nop
}
 800b4a2:	3758      	adds	r7, #88	; 0x58
 800b4a4:	46bd      	mov	sp, r7
 800b4a6:	bd80      	pop	{r7, pc}
 800b4a8:	0803088c 	.word	0x0803088c

0800b4ac <apply_z>:
#endif

/* Modify (x1, y1) => (x1 * z^2, y1 * z^3) */
static void apply_z(uECC_word_t * RESTRICT X1,
                    uECC_word_t * RESTRICT Y1,
                    const uECC_word_t * RESTRICT Z) {
 800b4ac:	b580      	push	{r7, lr}
 800b4ae:	b08c      	sub	sp, #48	; 0x30
 800b4b0:	af00      	add	r7, sp, #0
 800b4b2:	60f8      	str	r0, [r7, #12]
 800b4b4:	60b9      	str	r1, [r7, #8]
 800b4b6:	607a      	str	r2, [r7, #4]
    uECC_word_t t1[uECC_WORDS];

    vli_modSquare_fast(t1, Z);    /* z^2 */
 800b4b8:	f107 0310 	add.w	r3, r7, #16
 800b4bc:	687a      	ldr	r2, [r7, #4]
 800b4be:	6879      	ldr	r1, [r7, #4]
 800b4c0:	4618      	mov	r0, r3
 800b4c2:	f7ff fdef 	bl	800b0a4 <vli_modMult_fast>
    vli_modMult_fast(X1, X1, t1); /* x1 * z^2 */
 800b4c6:	f107 0310 	add.w	r3, r7, #16
 800b4ca:	461a      	mov	r2, r3
 800b4cc:	68f9      	ldr	r1, [r7, #12]
 800b4ce:	68f8      	ldr	r0, [r7, #12]
 800b4d0:	f7ff fde8 	bl	800b0a4 <vli_modMult_fast>
    vli_modMult_fast(t1, t1, Z);  /* z^3 */
 800b4d4:	f107 0110 	add.w	r1, r7, #16
 800b4d8:	f107 0310 	add.w	r3, r7, #16
 800b4dc:	687a      	ldr	r2, [r7, #4]
 800b4de:	4618      	mov	r0, r3
 800b4e0:	f7ff fde0 	bl	800b0a4 <vli_modMult_fast>
    vli_modMult_fast(Y1, Y1, t1); /* y1 * z^3 */
 800b4e4:	f107 0310 	add.w	r3, r7, #16
 800b4e8:	461a      	mov	r2, r3
 800b4ea:	68b9      	ldr	r1, [r7, #8]
 800b4ec:	68b8      	ldr	r0, [r7, #8]
 800b4ee:	f7ff fdd9 	bl	800b0a4 <vli_modMult_fast>
}
 800b4f2:	bf00      	nop
 800b4f4:	3730      	adds	r7, #48	; 0x30
 800b4f6:	46bd      	mov	sp, r7
 800b4f8:	bd80      	pop	{r7, pc}

0800b4fa <XYcZ_initial_double>:
/* P = (x1, y1) => 2P, (x2, y2) => P' */
static void XYcZ_initial_double(uECC_word_t * RESTRICT X1,
                                uECC_word_t * RESTRICT Y1,
                                uECC_word_t * RESTRICT X2,
                                uECC_word_t * RESTRICT Y2,
                                const uECC_word_t * RESTRICT initial_Z) {
 800b4fa:	b580      	push	{r7, lr}
 800b4fc:	b08c      	sub	sp, #48	; 0x30
 800b4fe:	af00      	add	r7, sp, #0
 800b500:	60f8      	str	r0, [r7, #12]
 800b502:	60b9      	str	r1, [r7, #8]
 800b504:	607a      	str	r2, [r7, #4]
 800b506:	603b      	str	r3, [r7, #0]
    uECC_word_t z[uECC_WORDS];
    if (initial_Z) {
 800b508:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b50a:	2b00      	cmp	r3, #0
 800b50c:	d006      	beq.n	800b51c <XYcZ_initial_double+0x22>
        vli_set(z, initial_Z);
 800b50e:	f107 0310 	add.w	r3, r7, #16
 800b512:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800b514:	4618      	mov	r0, r3
 800b516:	f7ff fa73 	bl	800aa00 <vli_set>
 800b51a:	e006      	b.n	800b52a <XYcZ_initial_double+0x30>
    } else {
        vli_clear(z);
 800b51c:	f107 0310 	add.w	r3, r7, #16
 800b520:	4618      	mov	r0, r3
 800b522:	f7ff fa1f 	bl	800a964 <vli_clear>
        z[0] = 1;
 800b526:	2301      	movs	r3, #1
 800b528:	613b      	str	r3, [r7, #16]
    }

    vli_set(X2, X1);
 800b52a:	68f9      	ldr	r1, [r7, #12]
 800b52c:	6878      	ldr	r0, [r7, #4]
 800b52e:	f7ff fa67 	bl	800aa00 <vli_set>
    vli_set(Y2, Y1);
 800b532:	68b9      	ldr	r1, [r7, #8]
 800b534:	6838      	ldr	r0, [r7, #0]
 800b536:	f7ff fa63 	bl	800aa00 <vli_set>

    apply_z(X1, Y1, z);
 800b53a:	f107 0310 	add.w	r3, r7, #16
 800b53e:	461a      	mov	r2, r3
 800b540:	68b9      	ldr	r1, [r7, #8]
 800b542:	68f8      	ldr	r0, [r7, #12]
 800b544:	f7ff ffb2 	bl	800b4ac <apply_z>
    EccPoint_double_jacobian(X1, Y1, z);
 800b548:	f107 0310 	add.w	r3, r7, #16
 800b54c:	461a      	mov	r2, r3
 800b54e:	68b9      	ldr	r1, [r7, #8]
 800b550:	68f8      	ldr	r0, [r7, #12]
 800b552:	f7ff fefd 	bl	800b350 <EccPoint_double_jacobian>
    apply_z(X2, Y2, z);
 800b556:	f107 0310 	add.w	r3, r7, #16
 800b55a:	461a      	mov	r2, r3
 800b55c:	6839      	ldr	r1, [r7, #0]
 800b55e:	6878      	ldr	r0, [r7, #4]
 800b560:	f7ff ffa4 	bl	800b4ac <apply_z>
}
 800b564:	bf00      	nop
 800b566:	3730      	adds	r7, #48	; 0x30
 800b568:	46bd      	mov	sp, r7
 800b56a:	bd80      	pop	{r7, pc}

0800b56c <XYcZ_add>:
   or P => P', Q => P + Q
*/
static void XYcZ_add(uECC_word_t * RESTRICT X1,
                     uECC_word_t * RESTRICT Y1,
                     uECC_word_t * RESTRICT X2,
                     uECC_word_t * RESTRICT Y2) {
 800b56c:	b580      	push	{r7, lr}
 800b56e:	b08c      	sub	sp, #48	; 0x30
 800b570:	af00      	add	r7, sp, #0
 800b572:	60f8      	str	r0, [r7, #12]
 800b574:	60b9      	str	r1, [r7, #8]
 800b576:	607a      	str	r2, [r7, #4]
 800b578:	603b      	str	r3, [r7, #0]
    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
    uECC_word_t t5[uECC_WORDS];

    vli_modSub_fast(t5, X2, X1);  /* t5 = x2 - x1 */
 800b57a:	f107 0010 	add.w	r0, r7, #16
 800b57e:	4b30      	ldr	r3, [pc, #192]	; (800b640 <XYcZ_add+0xd4>)
 800b580:	68fa      	ldr	r2, [r7, #12]
 800b582:	6879      	ldr	r1, [r7, #4]
 800b584:	f7ff fc2b 	bl	800adde <vli_modSub>
    vli_modSquare_fast(t5, t5);   /* t5 = (x2 - x1)^2 = A */
 800b588:	f107 0210 	add.w	r2, r7, #16
 800b58c:	f107 0110 	add.w	r1, r7, #16
 800b590:	f107 0310 	add.w	r3, r7, #16
 800b594:	4618      	mov	r0, r3
 800b596:	f7ff fd85 	bl	800b0a4 <vli_modMult_fast>
    vli_modMult_fast(X1, X1, t5); /* t1 = x1*A = B */
 800b59a:	f107 0310 	add.w	r3, r7, #16
 800b59e:	461a      	mov	r2, r3
 800b5a0:	68f9      	ldr	r1, [r7, #12]
 800b5a2:	68f8      	ldr	r0, [r7, #12]
 800b5a4:	f7ff fd7e 	bl	800b0a4 <vli_modMult_fast>
    vli_modMult_fast(X2, X2, t5); /* t3 = x2*A = C */
 800b5a8:	f107 0310 	add.w	r3, r7, #16
 800b5ac:	461a      	mov	r2, r3
 800b5ae:	6879      	ldr	r1, [r7, #4]
 800b5b0:	6878      	ldr	r0, [r7, #4]
 800b5b2:	f7ff fd77 	bl	800b0a4 <vli_modMult_fast>
    vli_modSub_fast(Y2, Y2, Y1);  /* t4 = y2 - y1 */
 800b5b6:	4b22      	ldr	r3, [pc, #136]	; (800b640 <XYcZ_add+0xd4>)
 800b5b8:	68ba      	ldr	r2, [r7, #8]
 800b5ba:	6839      	ldr	r1, [r7, #0]
 800b5bc:	6838      	ldr	r0, [r7, #0]
 800b5be:	f7ff fc0e 	bl	800adde <vli_modSub>
    vli_modSquare_fast(t5, Y2);   /* t5 = (y2 - y1)^2 = D */
 800b5c2:	f107 0310 	add.w	r3, r7, #16
 800b5c6:	683a      	ldr	r2, [r7, #0]
 800b5c8:	6839      	ldr	r1, [r7, #0]
 800b5ca:	4618      	mov	r0, r3
 800b5cc:	f7ff fd6a 	bl	800b0a4 <vli_modMult_fast>

    vli_modSub_fast(t5, t5, X1);  /* t5 = D - B */
 800b5d0:	f107 0110 	add.w	r1, r7, #16
 800b5d4:	f107 0010 	add.w	r0, r7, #16
 800b5d8:	4b19      	ldr	r3, [pc, #100]	; (800b640 <XYcZ_add+0xd4>)
 800b5da:	68fa      	ldr	r2, [r7, #12]
 800b5dc:	f7ff fbff 	bl	800adde <vli_modSub>
    vli_modSub_fast(t5, t5, X2);  /* t5 = D - B - C = x3 */
 800b5e0:	f107 0110 	add.w	r1, r7, #16
 800b5e4:	f107 0010 	add.w	r0, r7, #16
 800b5e8:	4b15      	ldr	r3, [pc, #84]	; (800b640 <XYcZ_add+0xd4>)
 800b5ea:	687a      	ldr	r2, [r7, #4]
 800b5ec:	f7ff fbf7 	bl	800adde <vli_modSub>
    vli_modSub_fast(X2, X2, X1);  /* t3 = C - B */
 800b5f0:	4b13      	ldr	r3, [pc, #76]	; (800b640 <XYcZ_add+0xd4>)
 800b5f2:	68fa      	ldr	r2, [r7, #12]
 800b5f4:	6879      	ldr	r1, [r7, #4]
 800b5f6:	6878      	ldr	r0, [r7, #4]
 800b5f8:	f7ff fbf1 	bl	800adde <vli_modSub>
    vli_modMult_fast(Y1, Y1, X2); /* t2 = y1*(C - B) */
 800b5fc:	687a      	ldr	r2, [r7, #4]
 800b5fe:	68b9      	ldr	r1, [r7, #8]
 800b600:	68b8      	ldr	r0, [r7, #8]
 800b602:	f7ff fd4f 	bl	800b0a4 <vli_modMult_fast>
    vli_modSub_fast(X2, X1, t5);  /* t3 = B - x3 */
 800b606:	f107 0210 	add.w	r2, r7, #16
 800b60a:	4b0d      	ldr	r3, [pc, #52]	; (800b640 <XYcZ_add+0xd4>)
 800b60c:	68f9      	ldr	r1, [r7, #12]
 800b60e:	6878      	ldr	r0, [r7, #4]
 800b610:	f7ff fbe5 	bl	800adde <vli_modSub>
    vli_modMult_fast(Y2, Y2, X2); /* t4 = (y2 - y1)*(B - x3) */
 800b614:	687a      	ldr	r2, [r7, #4]
 800b616:	6839      	ldr	r1, [r7, #0]
 800b618:	6838      	ldr	r0, [r7, #0]
 800b61a:	f7ff fd43 	bl	800b0a4 <vli_modMult_fast>
    vli_modSub_fast(Y2, Y2, Y1);  /* t4 = y3 */
 800b61e:	4b08      	ldr	r3, [pc, #32]	; (800b640 <XYcZ_add+0xd4>)
 800b620:	68ba      	ldr	r2, [r7, #8]
 800b622:	6839      	ldr	r1, [r7, #0]
 800b624:	6838      	ldr	r0, [r7, #0]
 800b626:	f7ff fbda 	bl	800adde <vli_modSub>

    vli_set(X2, t5);
 800b62a:	f107 0310 	add.w	r3, r7, #16
 800b62e:	4619      	mov	r1, r3
 800b630:	6878      	ldr	r0, [r7, #4]
 800b632:	f7ff f9e5 	bl	800aa00 <vli_set>
}
 800b636:	bf00      	nop
 800b638:	3730      	adds	r7, #48	; 0x30
 800b63a:	46bd      	mov	sp, r7
 800b63c:	bd80      	pop	{r7, pc}
 800b63e:	bf00      	nop
 800b640:	0803088c 	.word	0x0803088c

0800b644 <XYcZ_addC>:
   or P => P - Q, Q => P + Q
*/
static void XYcZ_addC(uECC_word_t * RESTRICT X1,
                      uECC_word_t * RESTRICT Y1,
                      uECC_word_t * RESTRICT X2,
                      uECC_word_t * RESTRICT Y2) {
 800b644:	b580      	push	{r7, lr}
 800b646:	b09c      	sub	sp, #112	; 0x70
 800b648:	af00      	add	r7, sp, #0
 800b64a:	60f8      	str	r0, [r7, #12]
 800b64c:	60b9      	str	r1, [r7, #8]
 800b64e:	607a      	str	r2, [r7, #4]
 800b650:	603b      	str	r3, [r7, #0]
    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
    uECC_word_t t5[uECC_WORDS];
    uECC_word_t t6[uECC_WORDS];
    uECC_word_t t7[uECC_WORDS];

    vli_modSub_fast(t5, X2, X1);     /* t5 = x2 - x1 */
 800b652:	f107 0050 	add.w	r0, r7, #80	; 0x50
 800b656:	4b49      	ldr	r3, [pc, #292]	; (800b77c <XYcZ_addC+0x138>)
 800b658:	68fa      	ldr	r2, [r7, #12]
 800b65a:	6879      	ldr	r1, [r7, #4]
 800b65c:	f7ff fbbf 	bl	800adde <vli_modSub>
    vli_modSquare_fast(t5, t5);      /* t5 = (x2 - x1)^2 = A */
 800b660:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b664:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800b668:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800b66c:	4618      	mov	r0, r3
 800b66e:	f7ff fd19 	bl	800b0a4 <vli_modMult_fast>
    vli_modMult_fast(X1, X1, t5);    /* t1 = x1*A = B */
 800b672:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800b676:	461a      	mov	r2, r3
 800b678:	68f9      	ldr	r1, [r7, #12]
 800b67a:	68f8      	ldr	r0, [r7, #12]
 800b67c:	f7ff fd12 	bl	800b0a4 <vli_modMult_fast>
    vli_modMult_fast(X2, X2, t5);    /* t3 = x2*A = C */
 800b680:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800b684:	461a      	mov	r2, r3
 800b686:	6879      	ldr	r1, [r7, #4]
 800b688:	6878      	ldr	r0, [r7, #4]
 800b68a:	f7ff fd0b 	bl	800b0a4 <vli_modMult_fast>
    vli_modAdd(t5, Y2, Y1, curve_p); /* t5 = y2 + y1 */
 800b68e:	f107 0050 	add.w	r0, r7, #80	; 0x50
 800b692:	4b3a      	ldr	r3, [pc, #232]	; (800b77c <XYcZ_addC+0x138>)
 800b694:	68ba      	ldr	r2, [r7, #8]
 800b696:	6839      	ldr	r1, [r7, #0]
 800b698:	f7ff fb81 	bl	800ad9e <vli_modAdd>
    vli_modSub_fast(Y2, Y2, Y1);     /* t4 = y2 - y1 */
 800b69c:	4b37      	ldr	r3, [pc, #220]	; (800b77c <XYcZ_addC+0x138>)
 800b69e:	68ba      	ldr	r2, [r7, #8]
 800b6a0:	6839      	ldr	r1, [r7, #0]
 800b6a2:	6838      	ldr	r0, [r7, #0]
 800b6a4:	f7ff fb9b 	bl	800adde <vli_modSub>

    vli_modSub_fast(t6, X2, X1);     /* t6 = C - B */
 800b6a8:	f107 0030 	add.w	r0, r7, #48	; 0x30
 800b6ac:	4b33      	ldr	r3, [pc, #204]	; (800b77c <XYcZ_addC+0x138>)
 800b6ae:	68fa      	ldr	r2, [r7, #12]
 800b6b0:	6879      	ldr	r1, [r7, #4]
 800b6b2:	f7ff fb94 	bl	800adde <vli_modSub>
    vli_modMult_fast(Y1, Y1, t6);    /* t2 = y1 * (C - B) = E */
 800b6b6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b6ba:	461a      	mov	r2, r3
 800b6bc:	68b9      	ldr	r1, [r7, #8]
 800b6be:	68b8      	ldr	r0, [r7, #8]
 800b6c0:	f7ff fcf0 	bl	800b0a4 <vli_modMult_fast>
    vli_modAdd(t6, X1, X2, curve_p); /* t6 = B + C */
 800b6c4:	f107 0030 	add.w	r0, r7, #48	; 0x30
 800b6c8:	4b2c      	ldr	r3, [pc, #176]	; (800b77c <XYcZ_addC+0x138>)
 800b6ca:	687a      	ldr	r2, [r7, #4]
 800b6cc:	68f9      	ldr	r1, [r7, #12]
 800b6ce:	f7ff fb66 	bl	800ad9e <vli_modAdd>
    vli_modSquare_fast(X2, Y2);      /* t3 = (y2 - y1)^2 = D */
 800b6d2:	683a      	ldr	r2, [r7, #0]
 800b6d4:	6839      	ldr	r1, [r7, #0]
 800b6d6:	6878      	ldr	r0, [r7, #4]
 800b6d8:	f7ff fce4 	bl	800b0a4 <vli_modMult_fast>
    vli_modSub_fast(X2, X2, t6);     /* t3 = D - (B + C) = x3 */
 800b6dc:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b6e0:	4b26      	ldr	r3, [pc, #152]	; (800b77c <XYcZ_addC+0x138>)
 800b6e2:	6879      	ldr	r1, [r7, #4]
 800b6e4:	6878      	ldr	r0, [r7, #4]
 800b6e6:	f7ff fb7a 	bl	800adde <vli_modSub>

    vli_modSub_fast(t7, X1, X2);  /* t7 = B - x3 */
 800b6ea:	f107 0010 	add.w	r0, r7, #16
 800b6ee:	4b23      	ldr	r3, [pc, #140]	; (800b77c <XYcZ_addC+0x138>)
 800b6f0:	687a      	ldr	r2, [r7, #4]
 800b6f2:	68f9      	ldr	r1, [r7, #12]
 800b6f4:	f7ff fb73 	bl	800adde <vli_modSub>
    vli_modMult_fast(Y2, Y2, t7); /* t4 = (y2 - y1)*(B - x3) */
 800b6f8:	f107 0310 	add.w	r3, r7, #16
 800b6fc:	461a      	mov	r2, r3
 800b6fe:	6839      	ldr	r1, [r7, #0]
 800b700:	6838      	ldr	r0, [r7, #0]
 800b702:	f7ff fccf 	bl	800b0a4 <vli_modMult_fast>
    vli_modSub_fast(Y2, Y2, Y1);  /* t4 = (y2 - y1)*(B - x3) - E = y3 */
 800b706:	4b1d      	ldr	r3, [pc, #116]	; (800b77c <XYcZ_addC+0x138>)
 800b708:	68ba      	ldr	r2, [r7, #8]
 800b70a:	6839      	ldr	r1, [r7, #0]
 800b70c:	6838      	ldr	r0, [r7, #0]
 800b70e:	f7ff fb66 	bl	800adde <vli_modSub>

    vli_modSquare_fast(t7, t5);   /* t7 = (y2 + y1)^2 = F */
 800b712:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b716:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800b71a:	f107 0310 	add.w	r3, r7, #16
 800b71e:	4618      	mov	r0, r3
 800b720:	f7ff fcc0 	bl	800b0a4 <vli_modMult_fast>
    vli_modSub_fast(t7, t7, t6);  /* t7 = F - (B + C) = x3' */
 800b724:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b728:	f107 0110 	add.w	r1, r7, #16
 800b72c:	f107 0010 	add.w	r0, r7, #16
 800b730:	4b12      	ldr	r3, [pc, #72]	; (800b77c <XYcZ_addC+0x138>)
 800b732:	f7ff fb54 	bl	800adde <vli_modSub>
    vli_modSub_fast(t6, t7, X1);  /* t6 = x3' - B */
 800b736:	f107 0110 	add.w	r1, r7, #16
 800b73a:	f107 0030 	add.w	r0, r7, #48	; 0x30
 800b73e:	4b0f      	ldr	r3, [pc, #60]	; (800b77c <XYcZ_addC+0x138>)
 800b740:	68fa      	ldr	r2, [r7, #12]
 800b742:	f7ff fb4c 	bl	800adde <vli_modSub>
    vli_modMult_fast(t6, t6, t5); /* t6 = (y2 + y1)*(x3' - B) */
 800b746:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b74a:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800b74e:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b752:	4618      	mov	r0, r3
 800b754:	f7ff fca6 	bl	800b0a4 <vli_modMult_fast>
    vli_modSub_fast(Y1, t6, Y1);  /* t2 = (y2 + y1)*(x3' - B) - E = y3' */
 800b758:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800b75c:	4b07      	ldr	r3, [pc, #28]	; (800b77c <XYcZ_addC+0x138>)
 800b75e:	68ba      	ldr	r2, [r7, #8]
 800b760:	68b8      	ldr	r0, [r7, #8]
 800b762:	f7ff fb3c 	bl	800adde <vli_modSub>

    vli_set(X1, t7);
 800b766:	f107 0310 	add.w	r3, r7, #16
 800b76a:	4619      	mov	r1, r3
 800b76c:	68f8      	ldr	r0, [r7, #12]
 800b76e:	f7ff f947 	bl	800aa00 <vli_set>
}
 800b772:	bf00      	nop
 800b774:	3770      	adds	r7, #112	; 0x70
 800b776:	46bd      	mov	sp, r7
 800b778:	bd80      	pop	{r7, pc}
 800b77a:	bf00      	nop
 800b77c:	0803088c 	.word	0x0803088c

0800b780 <EccPoint_mult>:

static void EccPoint_mult(EccPoint * RESTRICT result,
                          const EccPoint * RESTRICT point,
                          const uECC_word_t * RESTRICT scalar,
                          const uECC_word_t * RESTRICT initialZ,
                          bitcount_t numBits) {
 800b780:	b590      	push	{r4, r7, lr}
 800b782:	b0b1      	sub	sp, #196	; 0xc4
 800b784:	af02      	add	r7, sp, #8
 800b786:	60f8      	str	r0, [r7, #12]
 800b788:	60b9      	str	r1, [r7, #8]
 800b78a:	607a      	str	r2, [r7, #4]
 800b78c:	603b      	str	r3, [r7, #0]
    uECC_word_t Ry[2][uECC_WORDS];
    uECC_word_t z[uECC_WORDS];
    bitcount_t i;
    uECC_word_t nb;

    vli_set(Rx[1], point->x);
 800b78e:	68ba      	ldr	r2, [r7, #8]
 800b790:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800b794:	3320      	adds	r3, #32
 800b796:	4611      	mov	r1, r2
 800b798:	4618      	mov	r0, r3
 800b79a:	f7ff f931 	bl	800aa00 <vli_set>
    vli_set(Ry[1], point->y);
 800b79e:	68bb      	ldr	r3, [r7, #8]
 800b7a0:	f103 0220 	add.w	r2, r3, #32
 800b7a4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b7a8:	3320      	adds	r3, #32
 800b7aa:	4611      	mov	r1, r2
 800b7ac:	4618      	mov	r0, r3
 800b7ae:	f7ff f927 	bl	800aa00 <vli_set>

    XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initialZ);
 800b7b2:	f107 0430 	add.w	r4, r7, #48	; 0x30
 800b7b6:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b7ba:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800b7be:	f103 0120 	add.w	r1, r3, #32
 800b7c2:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800b7c6:	f103 0020 	add.w	r0, r3, #32
 800b7ca:	683b      	ldr	r3, [r7, #0]
 800b7cc:	9300      	str	r3, [sp, #0]
 800b7ce:	4623      	mov	r3, r4
 800b7d0:	f7ff fe93 	bl	800b4fa <XYcZ_initial_double>

    for (i = numBits - 2; i > 0; --i) {
 800b7d4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800b7d8:	3b02      	subs	r3, #2
 800b7da:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800b7de:	e04f      	b.n	800b880 <EccPoint_mult+0x100>
        nb = !vli_testBit(scalar, i);
 800b7e0:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
 800b7e4:	6878      	ldr	r0, [r7, #4]
 800b7e6:	f7ff f8f3 	bl	800a9d0 <vli_testBit>
 800b7ea:	4603      	mov	r3, r0
 800b7ec:	2b00      	cmp	r3, #0
 800b7ee:	bf0c      	ite	eq
 800b7f0:	2301      	moveq	r3, #1
 800b7f2:	2300      	movne	r3, #0
 800b7f4:	b2db      	uxtb	r3, r3
 800b7f6:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
        XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb]);
 800b7fa:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b7fe:	f1c3 0301 	rsb	r3, r3, #1
 800b802:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b806:	015b      	lsls	r3, r3, #5
 800b808:	18d0      	adds	r0, r2, r3
 800b80a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b80e:	f1c3 0301 	rsb	r3, r3, #1
 800b812:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b816:	015b      	lsls	r3, r3, #5
 800b818:	18d1      	adds	r1, r2, r3
 800b81a:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b81e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b822:	015b      	lsls	r3, r3, #5
 800b824:	18d4      	adds	r4, r2, r3
 800b826:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b82a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b82e:	015b      	lsls	r3, r3, #5
 800b830:	4413      	add	r3, r2
 800b832:	4622      	mov	r2, r4
 800b834:	f7ff ff06 	bl	800b644 <XYcZ_addC>
        XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb]);
 800b838:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b83c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b840:	015b      	lsls	r3, r3, #5
 800b842:	18d0      	adds	r0, r2, r3
 800b844:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b848:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b84c:	015b      	lsls	r3, r3, #5
 800b84e:	18d1      	adds	r1, r2, r3
 800b850:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b854:	f1c3 0301 	rsb	r3, r3, #1
 800b858:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b85c:	015b      	lsls	r3, r3, #5
 800b85e:	18d4      	adds	r4, r2, r3
 800b860:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b864:	f1c3 0301 	rsb	r3, r3, #1
 800b868:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b86c:	015b      	lsls	r3, r3, #5
 800b86e:	4413      	add	r3, r2
 800b870:	4622      	mov	r2, r4
 800b872:	f7ff fe7b 	bl	800b56c <XYcZ_add>
    for (i = numBits - 2; i > 0; --i) {
 800b876:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800b87a:	3b01      	subs	r3, #1
 800b87c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800b880:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800b884:	2b00      	cmp	r3, #0
 800b886:	dcab      	bgt.n	800b7e0 <EccPoint_mult+0x60>
    }

    nb = !vli_testBit(scalar, 0);
 800b888:	2100      	movs	r1, #0
 800b88a:	6878      	ldr	r0, [r7, #4]
 800b88c:	f7ff f8a0 	bl	800a9d0 <vli_testBit>
 800b890:	4603      	mov	r3, r0
 800b892:	2b00      	cmp	r3, #0
 800b894:	bf0c      	ite	eq
 800b896:	2301      	moveq	r3, #1
 800b898:	2300      	movne	r3, #0
 800b89a:	b2db      	uxtb	r3, r3
 800b89c:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb]);
 800b8a0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b8a4:	f1c3 0301 	rsb	r3, r3, #1
 800b8a8:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b8ac:	015b      	lsls	r3, r3, #5
 800b8ae:	18d0      	adds	r0, r2, r3
 800b8b0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b8b4:	f1c3 0301 	rsb	r3, r3, #1
 800b8b8:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b8bc:	015b      	lsls	r3, r3, #5
 800b8be:	18d1      	adds	r1, r2, r3
 800b8c0:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b8c4:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b8c8:	015b      	lsls	r3, r3, #5
 800b8ca:	18d4      	adds	r4, r2, r3
 800b8cc:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b8d0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b8d4:	015b      	lsls	r3, r3, #5
 800b8d6:	4413      	add	r3, r2
 800b8d8:	4622      	mov	r2, r4
 800b8da:	f7ff feb3 	bl	800b644 <XYcZ_addC>

    /* Find final 1/Z value. */
    vli_modSub_fast(z, Rx[1], Rx[0]);   /* X1 - X0 */
 800b8de:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b8e2:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800b8e6:	f103 0120 	add.w	r1, r3, #32
 800b8ea:	f107 0010 	add.w	r0, r7, #16
 800b8ee:	4b3b      	ldr	r3, [pc, #236]	; (800b9dc <EccPoint_mult+0x25c>)
 800b8f0:	f7ff fa75 	bl	800adde <vli_modSub>
    vli_modMult_fast(z, z, Ry[1 - nb]); /* Yb * (X1 - X0) */
 800b8f4:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b8f8:	f1c3 0301 	rsb	r3, r3, #1
 800b8fc:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b900:	015b      	lsls	r3, r3, #5
 800b902:	441a      	add	r2, r3
 800b904:	f107 0110 	add.w	r1, r7, #16
 800b908:	f107 0310 	add.w	r3, r7, #16
 800b90c:	4618      	mov	r0, r3
 800b90e:	f7ff fbc9 	bl	800b0a4 <vli_modMult_fast>
    vli_modMult_fast(z, z, point->x); /* xP * Yb * (X1 - X0) */
 800b912:	68ba      	ldr	r2, [r7, #8]
 800b914:	f107 0110 	add.w	r1, r7, #16
 800b918:	f107 0310 	add.w	r3, r7, #16
 800b91c:	4618      	mov	r0, r3
 800b91e:	f7ff fbc1 	bl	800b0a4 <vli_modMult_fast>
    vli_modInv(z, z, curve_p);          /* 1 / (xP * Yb * (X1 - X0)) */
 800b922:	f107 0110 	add.w	r1, r7, #16
 800b926:	f107 0310 	add.w	r3, r7, #16
 800b92a:	4a2c      	ldr	r2, [pc, #176]	; (800b9dc <EccPoint_mult+0x25c>)
 800b92c:	4618      	mov	r0, r3
 800b92e:	f7ff fbd0 	bl	800b0d2 <vli_modInv>
    vli_modMult_fast(z, z, point->y); /* yP / (xP * Yb * (X1 - X0)) */
 800b932:	68bb      	ldr	r3, [r7, #8]
 800b934:	f103 0220 	add.w	r2, r3, #32
 800b938:	f107 0110 	add.w	r1, r7, #16
 800b93c:	f107 0310 	add.w	r3, r7, #16
 800b940:	4618      	mov	r0, r3
 800b942:	f7ff fbaf 	bl	800b0a4 <vli_modMult_fast>
    vli_modMult_fast(z, z, Rx[1 - nb]); /* Xb * yP / (xP * Yb * (X1 - X0)) */
 800b946:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b94a:	f1c3 0301 	rsb	r3, r3, #1
 800b94e:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b952:	015b      	lsls	r3, r3, #5
 800b954:	441a      	add	r2, r3
 800b956:	f107 0110 	add.w	r1, r7, #16
 800b95a:	f107 0310 	add.w	r3, r7, #16
 800b95e:	4618      	mov	r0, r3
 800b960:	f7ff fba0 	bl	800b0a4 <vli_modMult_fast>
    /* End 1/Z calculation */

    XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb]);
 800b964:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b968:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b96c:	015b      	lsls	r3, r3, #5
 800b96e:	18d0      	adds	r0, r2, r3
 800b970:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b974:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b978:	015b      	lsls	r3, r3, #5
 800b97a:	18d1      	adds	r1, r2, r3
 800b97c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b980:	f1c3 0301 	rsb	r3, r3, #1
 800b984:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b988:	015b      	lsls	r3, r3, #5
 800b98a:	18d4      	adds	r4, r2, r3
 800b98c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b990:	f1c3 0301 	rsb	r3, r3, #1
 800b994:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b998:	015b      	lsls	r3, r3, #5
 800b99a:	4413      	add	r3, r2
 800b99c:	4622      	mov	r2, r4
 800b99e:	f7ff fde5 	bl	800b56c <XYcZ_add>
    apply_z(Rx[0], Ry[0], z);
 800b9a2:	f107 0210 	add.w	r2, r7, #16
 800b9a6:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800b9aa:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800b9ae:	4618      	mov	r0, r3
 800b9b0:	f7ff fd7c 	bl	800b4ac <apply_z>

    vli_set(result->x, Rx[0]);
 800b9b4:	68fb      	ldr	r3, [r7, #12]
 800b9b6:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800b9ba:	4611      	mov	r1, r2
 800b9bc:	4618      	mov	r0, r3
 800b9be:	f7ff f81f 	bl	800aa00 <vli_set>
    vli_set(result->y, Ry[0]);
 800b9c2:	68fb      	ldr	r3, [r7, #12]
 800b9c4:	3320      	adds	r3, #32
 800b9c6:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800b9ca:	4611      	mov	r1, r2
 800b9cc:	4618      	mov	r0, r3
 800b9ce:	f7ff f817 	bl	800aa00 <vli_set>
}
 800b9d2:	bf00      	nop
 800b9d4:	37bc      	adds	r7, #188	; 0xbc
 800b9d6:	46bd      	mov	sp, r7
 800b9d8:	bd90      	pop	{r4, r7, pc}
 800b9da:	bf00      	nop
 800b9dc:	0803088c 	.word	0x0803088c

0800b9e0 <EccPoint_compute_public_key>:

static int EccPoint_compute_public_key(EccPoint *result, uECC_word_t *private) {
 800b9e0:	b580      	push	{r7, lr}
 800b9e2:	b098      	sub	sp, #96	; 0x60
 800b9e4:	af02      	add	r7, sp, #8
 800b9e6:	6078      	str	r0, [r7, #4]
 800b9e8:	6039      	str	r1, [r7, #0]
    uECC_word_t tmp1[uECC_WORDS];
    uECC_word_t tmp2[uECC_WORDS];
    uECC_word_t *p2[2] = {tmp1, tmp2};
 800b9ea:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800b9ee:	60fb      	str	r3, [r7, #12]
 800b9f0:	f107 0314 	add.w	r3, r7, #20
 800b9f4:	613b      	str	r3, [r7, #16]
    uECC_word_t carry;

    /* Make sure the private key is in the range [1, n-1]. */
    if (vli_isZero(private)) {
 800b9f6:	6838      	ldr	r0, [r7, #0]
 800b9f8:	f7fe ffcd 	bl	800a996 <vli_isZero>
 800b9fc:	4603      	mov	r3, r0
 800b9fe:	2b00      	cmp	r3, #0
 800ba00:	d001      	beq.n	800ba06 <EccPoint_compute_public_key+0x26>
        return 0;
 800ba02:	2300      	movs	r3, #0
 800ba04:	e035      	b.n	800ba72 <EccPoint_compute_public_key+0x92>
    // impact (about 2% slower on average) and requires the vli_xxx_n functions, leading to
    // a significant increase in code size.

    EccPoint_mult(result, &curve_G, private, NULL, vli_numBits(private, uECC_WORDS));
#else
    if (vli_cmp(curve_n, private) != 1) {
 800ba06:	6839      	ldr	r1, [r7, #0]
 800ba08:	481c      	ldr	r0, [pc, #112]	; (800ba7c <EccPoint_compute_public_key+0x9c>)
 800ba0a:	f7ff f817 	bl	800aa3c <vli_cmp>
 800ba0e:	4603      	mov	r3, r0
 800ba10:	2b01      	cmp	r3, #1
 800ba12:	d001      	beq.n	800ba18 <EccPoint_compute_public_key+0x38>
        return 0;
 800ba14:	2300      	movs	r3, #0
 800ba16:	e02c      	b.n	800ba72 <EccPoint_compute_public_key+0x92>
    }

    // Regularize the bitcount for the private key so that attackers cannot use a side channel
    // attack to learn the number of leading zeros.
    carry = vli_add(tmp1, private, curve_n);
 800ba18:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800ba1c:	4a17      	ldr	r2, [pc, #92]	; (800ba7c <EccPoint_compute_public_key+0x9c>)
 800ba1e:	6839      	ldr	r1, [r7, #0]
 800ba20:	4618      	mov	r0, r3
 800ba22:	f7ff f861 	bl	800aae8 <vli_add>
 800ba26:	6578      	str	r0, [r7, #84]	; 0x54
    vli_add(tmp2, tmp1, curve_n);
 800ba28:	f107 0134 	add.w	r1, r7, #52	; 0x34
 800ba2c:	f107 0314 	add.w	r3, r7, #20
 800ba30:	4a12      	ldr	r2, [pc, #72]	; (800ba7c <EccPoint_compute_public_key+0x9c>)
 800ba32:	4618      	mov	r0, r3
 800ba34:	f7ff f858 	bl	800aae8 <vli_add>
    EccPoint_mult(result, &curve_G, p2[!carry], NULL, (uECC_BYTES * 8) + 1);
 800ba38:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ba3a:	2b00      	cmp	r3, #0
 800ba3c:	bf0c      	ite	eq
 800ba3e:	2301      	moveq	r3, #1
 800ba40:	2300      	movne	r3, #0
 800ba42:	b2db      	uxtb	r3, r3
 800ba44:	009b      	lsls	r3, r3, #2
 800ba46:	f107 0258 	add.w	r2, r7, #88	; 0x58
 800ba4a:	4413      	add	r3, r2
 800ba4c:	f853 2c4c 	ldr.w	r2, [r3, #-76]
 800ba50:	f240 1301 	movw	r3, #257	; 0x101
 800ba54:	9300      	str	r3, [sp, #0]
 800ba56:	2300      	movs	r3, #0
 800ba58:	4909      	ldr	r1, [pc, #36]	; (800ba80 <EccPoint_compute_public_key+0xa0>)
 800ba5a:	6878      	ldr	r0, [r7, #4]
 800ba5c:	f7ff fe90 	bl	800b780 <EccPoint_mult>
#endif

    if (EccPoint_isZero(result)) {
 800ba60:	6878      	ldr	r0, [r7, #4]
 800ba62:	f7ff fc5b 	bl	800b31c <EccPoint_isZero>
 800ba66:	4603      	mov	r3, r0
 800ba68:	2b00      	cmp	r3, #0
 800ba6a:	d001      	beq.n	800ba70 <EccPoint_compute_public_key+0x90>
        return 0;
 800ba6c:	2300      	movs	r3, #0
 800ba6e:	e000      	b.n	800ba72 <EccPoint_compute_public_key+0x92>
    }
    return 1;
 800ba70:	2301      	movs	r3, #1
}
 800ba72:	4618      	mov	r0, r3
 800ba74:	3758      	adds	r7, #88	; 0x58
 800ba76:	46bd      	mov	sp, r7
 800ba78:	bd80      	pop	{r7, pc}
 800ba7a:	bf00      	nop
 800ba7c:	080308ec 	.word	0x080308ec
 800ba80:	080308ac 	.word	0x080308ac

0800ba84 <vli_nativeToBytes>:

#define vli_bytesToNative(dest, src) vli_nativeToBytes((dest), (src))

#elif uECC_WORD_SIZE == 4

static void vli_nativeToBytes(uint8_t *bytes, const uint32_t *native) {
 800ba84:	b480      	push	{r7}
 800ba86:	b085      	sub	sp, #20
 800ba88:	af00      	add	r7, sp, #0
 800ba8a:	6078      	str	r0, [r7, #4]
 800ba8c:	6039      	str	r1, [r7, #0]
    unsigned i;
    for (i = 0; i < uECC_WORDS; ++i) {
 800ba8e:	2300      	movs	r3, #0
 800ba90:	60fb      	str	r3, [r7, #12]
 800ba92:	e031      	b.n	800baf8 <vli_nativeToBytes+0x74>
        uint8_t *digit = bytes + 4 * (uECC_WORDS - 1 - i);
 800ba94:	68fa      	ldr	r2, [r7, #12]
 800ba96:	4613      	mov	r3, r2
 800ba98:	079b      	lsls	r3, r3, #30
 800ba9a:	1a9b      	subs	r3, r3, r2
 800ba9c:	009b      	lsls	r3, r3, #2
 800ba9e:	331c      	adds	r3, #28
 800baa0:	687a      	ldr	r2, [r7, #4]
 800baa2:	4413      	add	r3, r2
 800baa4:	60bb      	str	r3, [r7, #8]
        digit[0] = native[i] >> 24;
 800baa6:	68fb      	ldr	r3, [r7, #12]
 800baa8:	009b      	lsls	r3, r3, #2
 800baaa:	683a      	ldr	r2, [r7, #0]
 800baac:	4413      	add	r3, r2
 800baae:	681b      	ldr	r3, [r3, #0]
 800bab0:	0e1b      	lsrs	r3, r3, #24
 800bab2:	b2da      	uxtb	r2, r3
 800bab4:	68bb      	ldr	r3, [r7, #8]
 800bab6:	701a      	strb	r2, [r3, #0]
        digit[1] = native[i] >> 16;
 800bab8:	68fb      	ldr	r3, [r7, #12]
 800baba:	009b      	lsls	r3, r3, #2
 800babc:	683a      	ldr	r2, [r7, #0]
 800babe:	4413      	add	r3, r2
 800bac0:	681b      	ldr	r3, [r3, #0]
 800bac2:	0c1a      	lsrs	r2, r3, #16
 800bac4:	68bb      	ldr	r3, [r7, #8]
 800bac6:	3301      	adds	r3, #1
 800bac8:	b2d2      	uxtb	r2, r2
 800baca:	701a      	strb	r2, [r3, #0]
        digit[2] = native[i] >> 8;
 800bacc:	68fb      	ldr	r3, [r7, #12]
 800bace:	009b      	lsls	r3, r3, #2
 800bad0:	683a      	ldr	r2, [r7, #0]
 800bad2:	4413      	add	r3, r2
 800bad4:	681b      	ldr	r3, [r3, #0]
 800bad6:	0a1a      	lsrs	r2, r3, #8
 800bad8:	68bb      	ldr	r3, [r7, #8]
 800bada:	3302      	adds	r3, #2
 800badc:	b2d2      	uxtb	r2, r2
 800bade:	701a      	strb	r2, [r3, #0]
        digit[3] = native[i];
 800bae0:	68fb      	ldr	r3, [r7, #12]
 800bae2:	009b      	lsls	r3, r3, #2
 800bae4:	683a      	ldr	r2, [r7, #0]
 800bae6:	4413      	add	r3, r2
 800bae8:	681a      	ldr	r2, [r3, #0]
 800baea:	68bb      	ldr	r3, [r7, #8]
 800baec:	3303      	adds	r3, #3
 800baee:	b2d2      	uxtb	r2, r2
 800baf0:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < uECC_WORDS; ++i) {
 800baf2:	68fb      	ldr	r3, [r7, #12]
 800baf4:	3301      	adds	r3, #1
 800baf6:	60fb      	str	r3, [r7, #12]
 800baf8:	68fb      	ldr	r3, [r7, #12]
 800bafa:	2b07      	cmp	r3, #7
 800bafc:	d9ca      	bls.n	800ba94 <vli_nativeToBytes+0x10>
    }
}
 800bafe:	bf00      	nop
 800bb00:	3714      	adds	r7, #20
 800bb02:	46bd      	mov	sp, r7
 800bb04:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb08:	4770      	bx	lr

0800bb0a <vli_bytesToNative>:

static void vli_bytesToNative(uint32_t *native, const uint8_t *bytes) {
 800bb0a:	b480      	push	{r7}
 800bb0c:	b085      	sub	sp, #20
 800bb0e:	af00      	add	r7, sp, #0
 800bb10:	6078      	str	r0, [r7, #4]
 800bb12:	6039      	str	r1, [r7, #0]
    unsigned i;
    for (i = 0; i < uECC_WORDS; ++i) {
 800bb14:	2300      	movs	r3, #0
 800bb16:	60fb      	str	r3, [r7, #12]
 800bb18:	e022      	b.n	800bb60 <vli_bytesToNative+0x56>
        const uint8_t *digit = bytes + 4 * (uECC_WORDS - 1 - i);
 800bb1a:	68fa      	ldr	r2, [r7, #12]
 800bb1c:	4613      	mov	r3, r2
 800bb1e:	079b      	lsls	r3, r3, #30
 800bb20:	1a9b      	subs	r3, r3, r2
 800bb22:	009b      	lsls	r3, r3, #2
 800bb24:	331c      	adds	r3, #28
 800bb26:	683a      	ldr	r2, [r7, #0]
 800bb28:	4413      	add	r3, r2
 800bb2a:	60bb      	str	r3, [r7, #8]
        native[i] = ((uint32_t)digit[0] << 24) | ((uint32_t)digit[1] << 16) |
 800bb2c:	68bb      	ldr	r3, [r7, #8]
 800bb2e:	781b      	ldrb	r3, [r3, #0]
 800bb30:	061a      	lsls	r2, r3, #24
 800bb32:	68bb      	ldr	r3, [r7, #8]
 800bb34:	3301      	adds	r3, #1
 800bb36:	781b      	ldrb	r3, [r3, #0]
 800bb38:	041b      	lsls	r3, r3, #16
 800bb3a:	431a      	orrs	r2, r3
                    ((uint32_t)digit[2] << 8) | (uint32_t)digit[3];
 800bb3c:	68bb      	ldr	r3, [r7, #8]
 800bb3e:	3302      	adds	r3, #2
 800bb40:	781b      	ldrb	r3, [r3, #0]
 800bb42:	021b      	lsls	r3, r3, #8
        native[i] = ((uint32_t)digit[0] << 24) | ((uint32_t)digit[1] << 16) |
 800bb44:	431a      	orrs	r2, r3
                    ((uint32_t)digit[2] << 8) | (uint32_t)digit[3];
 800bb46:	68bb      	ldr	r3, [r7, #8]
 800bb48:	3303      	adds	r3, #3
 800bb4a:	781b      	ldrb	r3, [r3, #0]
 800bb4c:	4618      	mov	r0, r3
        native[i] = ((uint32_t)digit[0] << 24) | ((uint32_t)digit[1] << 16) |
 800bb4e:	68fb      	ldr	r3, [r7, #12]
 800bb50:	009b      	lsls	r3, r3, #2
 800bb52:	6879      	ldr	r1, [r7, #4]
 800bb54:	440b      	add	r3, r1
                    ((uint32_t)digit[2] << 8) | (uint32_t)digit[3];
 800bb56:	4302      	orrs	r2, r0
        native[i] = ((uint32_t)digit[0] << 24) | ((uint32_t)digit[1] << 16) |
 800bb58:	601a      	str	r2, [r3, #0]
    for (i = 0; i < uECC_WORDS; ++i) {
 800bb5a:	68fb      	ldr	r3, [r7, #12]
 800bb5c:	3301      	adds	r3, #1
 800bb5e:	60fb      	str	r3, [r7, #12]
 800bb60:	68fb      	ldr	r3, [r7, #12]
 800bb62:	2b07      	cmp	r3, #7
 800bb64:	d9d9      	bls.n	800bb1a <vli_bytesToNative+0x10>
    }
}
 800bb66:	bf00      	nop
 800bb68:	3714      	adds	r7, #20
 800bb6a:	46bd      	mov	sp, r7
 800bb6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb70:	4770      	bx	lr
	...

0800bb74 <uECC_make_key>:
    }
}

#endif /* uECC_WORD_SIZE */

int uECC_make_key(uint8_t public_key[uECC_BYTES*2], uint8_t private_key[uECC_BYTES]) {
 800bb74:	b580      	push	{r7, lr}
 800bb76:	b09c      	sub	sp, #112	; 0x70
 800bb78:	af00      	add	r7, sp, #0
 800bb7a:	6078      	str	r0, [r7, #4]
 800bb7c:	6039      	str	r1, [r7, #0]
    uECC_word_t private[uECC_WORDS];
    EccPoint public;
    uECC_word_t tries;
    for (tries = 0; tries < MAX_TRIES; ++tries) {
 800bb7e:	2300      	movs	r3, #0
 800bb80:	66fb      	str	r3, [r7, #108]	; 0x6c
 800bb82:	e02f      	b.n	800bbe4 <uECC_make_key+0x70>
        if (g_rng_function((uint8_t *)private, sizeof(private)) &&
 800bb84:	4b1b      	ldr	r3, [pc, #108]	; (800bbf4 <uECC_make_key+0x80>)
 800bb86:	681b      	ldr	r3, [r3, #0]
 800bb88:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 800bb8c:	2120      	movs	r1, #32
 800bb8e:	4610      	mov	r0, r2
 800bb90:	4798      	blx	r3
 800bb92:	4603      	mov	r3, r0
 800bb94:	2b00      	cmp	r3, #0
 800bb96:	d022      	beq.n	800bbde <uECC_make_key+0x6a>
                EccPoint_compute_public_key(&public, private)) {
 800bb98:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 800bb9c:	f107 030c 	add.w	r3, r7, #12
 800bba0:	4611      	mov	r1, r2
 800bba2:	4618      	mov	r0, r3
 800bba4:	f7ff ff1c 	bl	800b9e0 <EccPoint_compute_public_key>
 800bba8:	4603      	mov	r3, r0
        if (g_rng_function((uint8_t *)private, sizeof(private)) &&
 800bbaa:	2b00      	cmp	r3, #0
 800bbac:	d017      	beq.n	800bbde <uECC_make_key+0x6a>
            vli_nativeToBytes(private_key, private);
 800bbae:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800bbb2:	4619      	mov	r1, r3
 800bbb4:	6838      	ldr	r0, [r7, #0]
 800bbb6:	f7ff ff65 	bl	800ba84 <vli_nativeToBytes>
            vli_nativeToBytes(public_key, public.x);
 800bbba:	f107 030c 	add.w	r3, r7, #12
 800bbbe:	4619      	mov	r1, r3
 800bbc0:	6878      	ldr	r0, [r7, #4]
 800bbc2:	f7ff ff5f 	bl	800ba84 <vli_nativeToBytes>
            vli_nativeToBytes(public_key + uECC_BYTES, public.y);
 800bbc6:	687b      	ldr	r3, [r7, #4]
 800bbc8:	f103 0220 	add.w	r2, r3, #32
 800bbcc:	f107 030c 	add.w	r3, r7, #12
 800bbd0:	3320      	adds	r3, #32
 800bbd2:	4619      	mov	r1, r3
 800bbd4:	4610      	mov	r0, r2
 800bbd6:	f7ff ff55 	bl	800ba84 <vli_nativeToBytes>
            return 1;
 800bbda:	2301      	movs	r3, #1
 800bbdc:	e006      	b.n	800bbec <uECC_make_key+0x78>
    for (tries = 0; tries < MAX_TRIES; ++tries) {
 800bbde:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800bbe0:	3301      	adds	r3, #1
 800bbe2:	66fb      	str	r3, [r7, #108]	; 0x6c
 800bbe4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800bbe6:	2b3f      	cmp	r3, #63	; 0x3f
 800bbe8:	d9cc      	bls.n	800bb84 <uECC_make_key+0x10>
        }
    }
    return 0;
 800bbea:	2300      	movs	r3, #0
}
 800bbec:	4618      	mov	r0, r3
 800bbee:	3770      	adds	r7, #112	; 0x70
 800bbf0:	46bd      	mov	sp, r7
 800bbf2:	bd80      	pop	{r7, pc}
 800bbf4:	20000018 	.word	0x20000018

0800bbf8 <uECC_shared_secret>:

int uECC_shared_secret(const uint8_t public_key[uECC_BYTES*2],
                       const uint8_t private_key[uECC_BYTES],
                       uint8_t secret[uECC_BYTES]) {
 800bbf8:	b580      	push	{r7, lr}
 800bbfa:	b0c4      	sub	sp, #272	; 0x110
 800bbfc:	af02      	add	r7, sp, #8
 800bbfe:	60f8      	str	r0, [r7, #12]
 800bc00:	f107 0308 	add.w	r3, r7, #8
 800bc04:	6019      	str	r1, [r3, #0]
 800bc06:	1d3b      	adds	r3, r7, #4
 800bc08:	601a      	str	r2, [r3, #0]
    EccPoint public;
    EccPoint product;
    uECC_word_t private[uECC_WORDS];
    uECC_word_t tmp[uECC_WORDS];
    uECC_word_t *p2[2] = {private, tmp};
 800bc0a:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 800bc0e:	637b      	str	r3, [r7, #52]	; 0x34
 800bc10:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800bc14:	63bb      	str	r3, [r7, #56]	; 0x38
    uECC_word_t random[uECC_WORDS];
    uECC_word_t *initial_Z = NULL;
 800bc16:	2300      	movs	r3, #0
 800bc18:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    uECC_word_t carry;

    // Try to get a random initial Z value to improve protection against side-channel
    // attacks. If the RNG fails every time (eg it was not defined), we continue so that
    // uECC_shared_secret() can still work without an RNG defined.
    for (tries = 0; tries < MAX_TRIES; ++tries) {
 800bc1c:	2300      	movs	r3, #0
 800bc1e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 800bc22:	e01b      	b.n	800bc5c <uECC_shared_secret+0x64>
        if (g_rng_function((uint8_t *)random, sizeof(random)) && !vli_isZero(random)) {
 800bc24:	4b3c      	ldr	r3, [pc, #240]	; (800bd18 <uECC_shared_secret+0x120>)
 800bc26:	681b      	ldr	r3, [r3, #0]
 800bc28:	f107 0214 	add.w	r2, r7, #20
 800bc2c:	2120      	movs	r1, #32
 800bc2e:	4610      	mov	r0, r2
 800bc30:	4798      	blx	r3
 800bc32:	4603      	mov	r3, r0
 800bc34:	2b00      	cmp	r3, #0
 800bc36:	d00c      	beq.n	800bc52 <uECC_shared_secret+0x5a>
 800bc38:	f107 0314 	add.w	r3, r7, #20
 800bc3c:	4618      	mov	r0, r3
 800bc3e:	f7fe feaa 	bl	800a996 <vli_isZero>
 800bc42:	4603      	mov	r3, r0
 800bc44:	2b00      	cmp	r3, #0
 800bc46:	d104      	bne.n	800bc52 <uECC_shared_secret+0x5a>
            initial_Z = random;
 800bc48:	f107 0314 	add.w	r3, r7, #20
 800bc4c:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
            break;
 800bc50:	e008      	b.n	800bc64 <uECC_shared_secret+0x6c>
    for (tries = 0; tries < MAX_TRIES; ++tries) {
 800bc52:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800bc56:	3301      	adds	r3, #1
 800bc58:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 800bc5c:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800bc60:	2b3f      	cmp	r3, #63	; 0x3f
 800bc62:	d9df      	bls.n	800bc24 <uECC_shared_secret+0x2c>
        }
    }

    vli_bytesToNative(private, private_key);
 800bc64:	f107 0308 	add.w	r3, r7, #8
 800bc68:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 800bc6c:	6819      	ldr	r1, [r3, #0]
 800bc6e:	4610      	mov	r0, r2
 800bc70:	f7ff ff4b 	bl	800bb0a <vli_bytesToNative>
    vli_bytesToNative(public.x, public_key);
 800bc74:	f107 03bc 	add.w	r3, r7, #188	; 0xbc
 800bc78:	68f9      	ldr	r1, [r7, #12]
 800bc7a:	4618      	mov	r0, r3
 800bc7c:	f7ff ff45 	bl	800bb0a <vli_bytesToNative>
    vli_bytesToNative(public.y, public_key + uECC_BYTES);
 800bc80:	68fb      	ldr	r3, [r7, #12]
 800bc82:	f103 0220 	add.w	r2, r3, #32
 800bc86:	f107 03bc 	add.w	r3, r7, #188	; 0xbc
 800bc8a:	3320      	adds	r3, #32
 800bc8c:	4611      	mov	r1, r2
 800bc8e:	4618      	mov	r0, r3
 800bc90:	f7ff ff3b 	bl	800bb0a <vli_bytesToNative>
    // Don't regularize the bitcount for secp160r1.
    EccPoint_mult(&product, &public, private, initial_Z, vli_numBits(private, uECC_WORDS));
#else
    // Regularize the bitcount for the private key so that attackers cannot use a side channel
    // attack to learn the number of leading zeros.
    carry = vli_add(private, private, curve_n);
 800bc94:	f107 015c 	add.w	r1, r7, #92	; 0x5c
 800bc98:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 800bc9c:	4a1f      	ldr	r2, [pc, #124]	; (800bd1c <uECC_shared_secret+0x124>)
 800bc9e:	4618      	mov	r0, r3
 800bca0:	f7fe ff22 	bl	800aae8 <vli_add>
 800bca4:	f8c7 00fc 	str.w	r0, [r7, #252]	; 0xfc
    vli_add(tmp, private, curve_n);
 800bca8:	f107 015c 	add.w	r1, r7, #92	; 0x5c
 800bcac:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800bcb0:	4a1a      	ldr	r2, [pc, #104]	; (800bd1c <uECC_shared_secret+0x124>)
 800bcb2:	4618      	mov	r0, r3
 800bcb4:	f7fe ff18 	bl	800aae8 <vli_add>
    EccPoint_mult(&product, &public, p2[!carry], initial_Z, (uECC_BYTES * 8) + 1);
 800bcb8:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800bcbc:	2b00      	cmp	r3, #0
 800bcbe:	bf0c      	ite	eq
 800bcc0:	2301      	moveq	r3, #1
 800bcc2:	2300      	movne	r3, #0
 800bcc4:	b2db      	uxtb	r3, r3
 800bcc6:	009b      	lsls	r3, r3, #2
 800bcc8:	f507 7284 	add.w	r2, r7, #264	; 0x108
 800bccc:	4413      	add	r3, r2
 800bcce:	f853 2cd4 	ldr.w	r2, [r3, #-212]
 800bcd2:	f107 01bc 	add.w	r1, r7, #188	; 0xbc
 800bcd6:	f107 007c 	add.w	r0, r7, #124	; 0x7c
 800bcda:	f240 1301 	movw	r3, #257	; 0x101
 800bcde:	9300      	str	r3, [sp, #0]
 800bce0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800bce4:	f7ff fd4c 	bl	800b780 <EccPoint_mult>
#endif

    vli_nativeToBytes(secret, product.x);
 800bce8:	f107 027c 	add.w	r2, r7, #124	; 0x7c
 800bcec:	1d3b      	adds	r3, r7, #4
 800bcee:	4611      	mov	r1, r2
 800bcf0:	6818      	ldr	r0, [r3, #0]
 800bcf2:	f7ff fec7 	bl	800ba84 <vli_nativeToBytes>
    return !EccPoint_isZero(&product);
 800bcf6:	f107 037c 	add.w	r3, r7, #124	; 0x7c
 800bcfa:	4618      	mov	r0, r3
 800bcfc:	f7ff fb0e 	bl	800b31c <EccPoint_isZero>
 800bd00:	4603      	mov	r3, r0
 800bd02:	2b00      	cmp	r3, #0
 800bd04:	bf0c      	ite	eq
 800bd06:	2301      	moveq	r3, #1
 800bd08:	2300      	movne	r3, #0
 800bd0a:	b2db      	uxtb	r3, r3
}
 800bd0c:	4618      	mov	r0, r3
 800bd0e:	f507 7784 	add.w	r7, r7, #264	; 0x108
 800bd12:	46bd      	mov	sp, r7
 800bd14:	bd80      	pop	{r7, pc}
 800bd16:	bf00      	nop
 800bd18:	20000018 	.word	0x20000018
 800bd1c:	080308ec 	.word	0x080308ec

0800bd20 <curve_x_side>:
}

#endif

/* Computes result = x^3 + ax + b. result must not overlap x. */
static void curve_x_side(uECC_word_t * RESTRICT result, const uECC_word_t * RESTRICT x) {
 800bd20:	b580      	push	{r7, lr}
 800bd22:	b08a      	sub	sp, #40	; 0x28
 800bd24:	af00      	add	r7, sp, #0
 800bd26:	6078      	str	r0, [r7, #4]
 800bd28:	6039      	str	r1, [r7, #0]
#if (uECC_CURVE == uECC_secp256k1)
    vli_modSquare_fast(result, x); /* r = x^2 */
    vli_modMult_fast(result, result, x); /* r = x^3 */
    vli_modAdd(result, result, curve_b, curve_p); /* r = x^3 + b */
#else
    uECC_word_t _3[uECC_WORDS] = {3}; /* -a = 3 */
 800bd2a:	f107 0308 	add.w	r3, r7, #8
 800bd2e:	2220      	movs	r2, #32
 800bd30:	2100      	movs	r1, #0
 800bd32:	4618      	mov	r0, r3
 800bd34:	f01b fec5 	bl	8027ac2 <memset>
 800bd38:	2303      	movs	r3, #3
 800bd3a:	60bb      	str	r3, [r7, #8]

    vli_modSquare_fast(result, x); /* r = x^2 */
 800bd3c:	683a      	ldr	r2, [r7, #0]
 800bd3e:	6839      	ldr	r1, [r7, #0]
 800bd40:	6878      	ldr	r0, [r7, #4]
 800bd42:	f7ff f9af 	bl	800b0a4 <vli_modMult_fast>
    vli_modSub_fast(result, result, _3); /* r = x^2 - 3 */
 800bd46:	f107 0208 	add.w	r2, r7, #8
 800bd4a:	4b0a      	ldr	r3, [pc, #40]	; (800bd74 <curve_x_side+0x54>)
 800bd4c:	6879      	ldr	r1, [r7, #4]
 800bd4e:	6878      	ldr	r0, [r7, #4]
 800bd50:	f7ff f845 	bl	800adde <vli_modSub>
    vli_modMult_fast(result, result, x); /* r = x^3 - 3x */
 800bd54:	683a      	ldr	r2, [r7, #0]
 800bd56:	6879      	ldr	r1, [r7, #4]
 800bd58:	6878      	ldr	r0, [r7, #4]
 800bd5a:	f7ff f9a3 	bl	800b0a4 <vli_modMult_fast>
    vli_modAdd(result, result, curve_b, curve_p); /* r = x^3 - 3x + b */
 800bd5e:	4b05      	ldr	r3, [pc, #20]	; (800bd74 <curve_x_side+0x54>)
 800bd60:	4a05      	ldr	r2, [pc, #20]	; (800bd78 <curve_x_side+0x58>)
 800bd62:	6879      	ldr	r1, [r7, #4]
 800bd64:	6878      	ldr	r0, [r7, #4]
 800bd66:	f7ff f81a 	bl	800ad9e <vli_modAdd>
#endif
}
 800bd6a:	bf00      	nop
 800bd6c:	3728      	adds	r7, #40	; 0x28
 800bd6e:	46bd      	mov	sp, r7
 800bd70:	bd80      	pop	{r7, pc}
 800bd72:	bf00      	nop
 800bd74:	0803088c 	.word	0x0803088c
 800bd78:	0803090c 	.word	0x0803090c

0800bd7c <uECC_valid_public_key>:
    vli_nativeToBytes(public_key + uECC_BYTES, point.y);
}

#endif /* ENABLE_MICRO_ECC_COMPRESSION */

int uECC_valid_public_key(const uint8_t public_key[uECC_BYTES*2]) {
 800bd7c:	b580      	push	{r7, lr}
 800bd7e:	b0a2      	sub	sp, #136	; 0x88
 800bd80:	af00      	add	r7, sp, #0
 800bd82:	6078      	str	r0, [r7, #4]
    uECC_word_t tmp1[uECC_WORDS];
    uECC_word_t tmp2[uECC_WORDS];
    EccPoint public;

    vli_bytesToNative(public.x, public_key);
 800bd84:	f107 0308 	add.w	r3, r7, #8
 800bd88:	6879      	ldr	r1, [r7, #4]
 800bd8a:	4618      	mov	r0, r3
 800bd8c:	f7ff febd 	bl	800bb0a <vli_bytesToNative>
    vli_bytesToNative(public.y, public_key + uECC_BYTES);
 800bd90:	687b      	ldr	r3, [r7, #4]
 800bd92:	f103 0220 	add.w	r2, r3, #32
 800bd96:	f107 0308 	add.w	r3, r7, #8
 800bd9a:	3320      	adds	r3, #32
 800bd9c:	4611      	mov	r1, r2
 800bd9e:	4618      	mov	r0, r3
 800bda0:	f7ff feb3 	bl	800bb0a <vli_bytesToNative>

    // The point at infinity is invalid.
    if (EccPoint_isZero(&public)) {
 800bda4:	f107 0308 	add.w	r3, r7, #8
 800bda8:	4618      	mov	r0, r3
 800bdaa:	f7ff fab7 	bl	800b31c <EccPoint_isZero>
 800bdae:	4603      	mov	r3, r0
 800bdb0:	2b00      	cmp	r3, #0
 800bdb2:	d001      	beq.n	800bdb8 <uECC_valid_public_key+0x3c>
        return 0;
 800bdb4:	2300      	movs	r3, #0
 800bdb6:	e037      	b.n	800be28 <uECC_valid_public_key+0xac>
    }

    // x and y must be smaller than p.
    if (vli_cmp(curve_p, public.x) != 1 || vli_cmp(curve_p, public.y) != 1) {
 800bdb8:	f107 0308 	add.w	r3, r7, #8
 800bdbc:	4619      	mov	r1, r3
 800bdbe:	481c      	ldr	r0, [pc, #112]	; (800be30 <uECC_valid_public_key+0xb4>)
 800bdc0:	f7fe fe3c 	bl	800aa3c <vli_cmp>
 800bdc4:	4603      	mov	r3, r0
 800bdc6:	2b01      	cmp	r3, #1
 800bdc8:	d109      	bne.n	800bdde <uECC_valid_public_key+0x62>
 800bdca:	f107 0308 	add.w	r3, r7, #8
 800bdce:	3320      	adds	r3, #32
 800bdd0:	4619      	mov	r1, r3
 800bdd2:	4817      	ldr	r0, [pc, #92]	; (800be30 <uECC_valid_public_key+0xb4>)
 800bdd4:	f7fe fe32 	bl	800aa3c <vli_cmp>
 800bdd8:	4603      	mov	r3, r0
 800bdda:	2b01      	cmp	r3, #1
 800bddc:	d001      	beq.n	800bde2 <uECC_valid_public_key+0x66>
        return 0;
 800bdde:	2300      	movs	r3, #0
 800bde0:	e022      	b.n	800be28 <uECC_valid_public_key+0xac>
    }

    vli_modSquare_fast(tmp1, public.y); /* tmp1 = y^2 */
 800bde2:	f107 0308 	add.w	r3, r7, #8
 800bde6:	f103 0220 	add.w	r2, r3, #32
 800bdea:	f107 0308 	add.w	r3, r7, #8
 800bdee:	f103 0120 	add.w	r1, r3, #32
 800bdf2:	f107 0368 	add.w	r3, r7, #104	; 0x68
 800bdf6:	4618      	mov	r0, r3
 800bdf8:	f7ff f954 	bl	800b0a4 <vli_modMult_fast>
    curve_x_side(tmp2, public.x); /* tmp2 = x^3 + ax + b */
 800bdfc:	f107 0208 	add.w	r2, r7, #8
 800be00:	f107 0348 	add.w	r3, r7, #72	; 0x48
 800be04:	4611      	mov	r1, r2
 800be06:	4618      	mov	r0, r3
 800be08:	f7ff ff8a 	bl	800bd20 <curve_x_side>

    /* Make sure that y^2 == x^3 + ax + b */
    return (vli_cmp(tmp1, tmp2) == 0);
 800be0c:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800be10:	f107 0368 	add.w	r3, r7, #104	; 0x68
 800be14:	4611      	mov	r1, r2
 800be16:	4618      	mov	r0, r3
 800be18:	f7fe fe10 	bl	800aa3c <vli_cmp>
 800be1c:	4603      	mov	r3, r0
 800be1e:	2b00      	cmp	r3, #0
 800be20:	bf0c      	ite	eq
 800be22:	2301      	moveq	r3, #1
 800be24:	2300      	movne	r3, #0
 800be26:	b2db      	uxtb	r3, r3
}
 800be28:	4618      	mov	r0, r3
 800be2a:	3788      	adds	r7, #136	; 0x88
 800be2c:	46bd      	mov	sp, r7
 800be2e:	bd80      	pop	{r7, pc}
 800be30:	0803088c 	.word	0x0803088c

0800be34 <chipset_init>:
        0x00,                    // PCM channel 2 in edge = falling
        0x00,                    // Reserved
};
#endif

static void chipset_init(const void * config){
 800be34:	b580      	push	{r7, lr}
 800be36:	b082      	sub	sp, #8
 800be38:	af00      	add	r7, sp, #0
 800be3a:	6078      	str	r0, [r7, #4]
    init_script_offset = 0;
 800be3c:	4b14      	ldr	r3, [pc, #80]	; (800be90 <chipset_init+0x5c>)
 800be3e:	2200      	movs	r2, #0
 800be40:	601a      	str	r2, [r3, #0]
#if defined(__GNUC__) && defined(__MSP430X__) && (__MSP430X__ > 0)
    // On MSP430, custom init script is not supported
    init_script_size = cc256x_init_script_size;
#else
    if (custom_init_script){
 800be42:	4b14      	ldr	r3, [pc, #80]	; (800be94 <chipset_init+0x60>)
 800be44:	681b      	ldr	r3, [r3, #0]
 800be46:	2b00      	cmp	r3, #0
 800be48:	d00e      	beq.n	800be68 <chipset_init+0x34>
        log_info("cc256x: using custom init script");
 800be4a:	23a3      	movs	r3, #163	; 0xa3
 800be4c:	4a12      	ldr	r2, [pc, #72]	; (800be98 <chipset_init+0x64>)
 800be4e:	4913      	ldr	r1, [pc, #76]	; (800be9c <chipset_init+0x68>)
 800be50:	2001      	movs	r0, #1
 800be52:	f00b faf5 	bl	8017440 <hci_dump_log>
        init_script      = custom_init_script;
 800be56:	4b0f      	ldr	r3, [pc, #60]	; (800be94 <chipset_init+0x60>)
 800be58:	681b      	ldr	r3, [r3, #0]
 800be5a:	4a11      	ldr	r2, [pc, #68]	; (800bea0 <chipset_init+0x6c>)
 800be5c:	6013      	str	r3, [r2, #0]
        init_script_size = custom_init_script_size;
 800be5e:	4b11      	ldr	r3, [pc, #68]	; (800bea4 <chipset_init+0x70>)
 800be60:	681b      	ldr	r3, [r3, #0]
 800be62:	4a11      	ldr	r2, [pc, #68]	; (800bea8 <chipset_init+0x74>)
 800be64:	6013      	str	r3, [r2, #0]
 800be66:	e00c      	b.n	800be82 <chipset_init+0x4e>
    } else {
        log_info("cc256x: using default init script");
 800be68:	23a7      	movs	r3, #167	; 0xa7
 800be6a:	4a0b      	ldr	r2, [pc, #44]	; (800be98 <chipset_init+0x64>)
 800be6c:	490f      	ldr	r1, [pc, #60]	; (800beac <chipset_init+0x78>)
 800be6e:	2001      	movs	r0, #1
 800be70:	f00b fae6 	bl	8017440 <hci_dump_log>
        init_script      = cc256x_init_script;
 800be74:	4b0a      	ldr	r3, [pc, #40]	; (800bea0 <chipset_init+0x6c>)
 800be76:	4a0e      	ldr	r2, [pc, #56]	; (800beb0 <chipset_init+0x7c>)
 800be78:	601a      	str	r2, [r3, #0]
        init_script_size = cc256x_init_script_size;
 800be7a:	4b0e      	ldr	r3, [pc, #56]	; (800beb4 <chipset_init+0x80>)
 800be7c:	681b      	ldr	r3, [r3, #0]
 800be7e:	4a0a      	ldr	r2, [pc, #40]	; (800bea8 <chipset_init+0x74>)
 800be80:	6013      	str	r3, [r2, #0]
    }
#endif
#ifdef ENABLE_SCO_OVER_HCI
    init_send_route_sco_over_hci = 1;
 800be82:	4b0d      	ldr	r3, [pc, #52]	; (800beb8 <chipset_init+0x84>)
 800be84:	2201      	movs	r2, #1
 800be86:	601a      	str	r2, [r3, #0]
#endif
#ifdef ENABLE_SCO_OVER_PCM
    init_send_sco_i2s_config_cvsd = 1;
#endif
}
 800be88:	bf00      	nop
 800be8a:	3708      	adds	r7, #8
 800be8c:	46bd      	mov	sp, r7
 800be8e:	bd80      	pop	{r7, pc}
 800be90:	20006134 	.word	0x20006134
 800be94:	20006118 	.word	0x20006118
 800be98:	08028c30 	.word	0x08028c30
 800be9c:	08028c4c 	.word	0x08028c4c
 800bea0:	20006120 	.word	0x20006120
 800bea4:	2000611c 	.word	0x2000611c
 800bea8:	20006124 	.word	0x20006124
 800beac:	08028c74 	.word	0x08028c74
 800beb0:	0802e63c 	.word	0x0802e63c
 800beb4:	080307ac 	.word	0x080307ac
 800beb8:	20006138 	.word	0x20006138

0800bebc <chipset_set_baudrate_command>:

static void chipset_set_baudrate_command(uint32_t baudrate, uint8_t *hci_cmd_buffer){
 800bebc:	b480      	push	{r7}
 800bebe:	b083      	sub	sp, #12
 800bec0:	af00      	add	r7, sp, #0
 800bec2:	6078      	str	r0, [r7, #4]
 800bec4:	6039      	str	r1, [r7, #0]
    hci_cmd_buffer[0] = 0x36;
 800bec6:	683b      	ldr	r3, [r7, #0]
 800bec8:	2236      	movs	r2, #54	; 0x36
 800beca:	701a      	strb	r2, [r3, #0]
    hci_cmd_buffer[1] = 0xFF;
 800becc:	683b      	ldr	r3, [r7, #0]
 800bece:	3301      	adds	r3, #1
 800bed0:	22ff      	movs	r2, #255	; 0xff
 800bed2:	701a      	strb	r2, [r3, #0]
    hci_cmd_buffer[2] = 0x04;
 800bed4:	683b      	ldr	r3, [r7, #0]
 800bed6:	3302      	adds	r3, #2
 800bed8:	2204      	movs	r2, #4
 800beda:	701a      	strb	r2, [r3, #0]
    hci_cmd_buffer[3] =  baudrate        & 0xff;
 800bedc:	683b      	ldr	r3, [r7, #0]
 800bede:	3303      	adds	r3, #3
 800bee0:	687a      	ldr	r2, [r7, #4]
 800bee2:	b2d2      	uxtb	r2, r2
 800bee4:	701a      	strb	r2, [r3, #0]
    hci_cmd_buffer[4] = (baudrate >>  8) & 0xff;
 800bee6:	687b      	ldr	r3, [r7, #4]
 800bee8:	0a1a      	lsrs	r2, r3, #8
 800beea:	683b      	ldr	r3, [r7, #0]
 800beec:	3304      	adds	r3, #4
 800beee:	b2d2      	uxtb	r2, r2
 800bef0:	701a      	strb	r2, [r3, #0]
    hci_cmd_buffer[5] = (baudrate >> 16) & 0xff;
 800bef2:	687b      	ldr	r3, [r7, #4]
 800bef4:	0c1a      	lsrs	r2, r3, #16
 800bef6:	683b      	ldr	r3, [r7, #0]
 800bef8:	3305      	adds	r3, #5
 800befa:	b2d2      	uxtb	r2, r2
 800befc:	701a      	strb	r2, [r3, #0]
    hci_cmd_buffer[6] = 0;
 800befe:	683b      	ldr	r3, [r7, #0]
 800bf00:	3306      	adds	r3, #6
 800bf02:	2200      	movs	r2, #0
 800bf04:	701a      	strb	r2, [r3, #0]
}
 800bf06:	bf00      	nop
 800bf08:	370c      	adds	r7, #12
 800bf0a:	46bd      	mov	sp, r7
 800bf0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf10:	4770      	bx	lr

0800bf12 <chipset_set_bd_addr_command>:

static void chipset_set_bd_addr_command(bd_addr_t addr, uint8_t *hci_cmd_buffer){
 800bf12:	b580      	push	{r7, lr}
 800bf14:	b082      	sub	sp, #8
 800bf16:	af00      	add	r7, sp, #0
 800bf18:	6078      	str	r0, [r7, #4]
 800bf1a:	6039      	str	r1, [r7, #0]
    hci_cmd_buffer[0] = 0x06;
 800bf1c:	683b      	ldr	r3, [r7, #0]
 800bf1e:	2206      	movs	r2, #6
 800bf20:	701a      	strb	r2, [r3, #0]
    hci_cmd_buffer[1] = 0xFC;
 800bf22:	683b      	ldr	r3, [r7, #0]
 800bf24:	3301      	adds	r3, #1
 800bf26:	22fc      	movs	r2, #252	; 0xfc
 800bf28:	701a      	strb	r2, [r3, #0]
    hci_cmd_buffer[2] = 0x06;
 800bf2a:	683b      	ldr	r3, [r7, #0]
 800bf2c:	3302      	adds	r3, #2
 800bf2e:	2206      	movs	r2, #6
 800bf30:	701a      	strb	r2, [r3, #0]
    reverse_bd_addr(addr, &hci_cmd_buffer[3]);
 800bf32:	683b      	ldr	r3, [r7, #0]
 800bf34:	3303      	adds	r3, #3
 800bf36:	4619      	mov	r1, r3
 800bf38:	6878      	ldr	r0, [r7, #4]
 800bf3a:	f003 f8da 	bl	800f0f2 <reverse_bd_addr>
}
 800bf3e:	bf00      	nop
 800bf40:	3708      	adds	r7, #8
 800bf42:	46bd      	mov	sp, r7
 800bf44:	bd80      	pop	{r7, pc}
	...

0800bf48 <get_max_power_for_modulation_type>:
#define NUM_POWER_LEVELS 16
#define DB_MIN_LEVEL -35
#define DB_PER_LEVEL 5
#define DB_DYNAMIC_RANGE 30

static int get_max_power_for_modulation_type(int type){
 800bf48:	b480      	push	{r7}
 800bf4a:	b085      	sub	sp, #20
 800bf4c:	af00      	add	r7, sp, #0
 800bf4e:	6078      	str	r0, [r7, #4]
    // a) limit max output power
    int power_db;
    switch (type){
 800bf50:	687b      	ldr	r3, [r7, #4]
 800bf52:	2b00      	cmp	r3, #0
 800bf54:	d102      	bne.n	800bf5c <get_max_power_for_modulation_type+0x14>
        case 0:     // GFSK
            power_db = 12;
 800bf56:	230c      	movs	r3, #12
 800bf58:	60fb      	str	r3, [r7, #12]
            break;
 800bf5a:	e002      	b.n	800bf62 <get_max_power_for_modulation_type+0x1a>
        default:    // EDRx
            power_db = 10;
 800bf5c:	230a      	movs	r3, #10
 800bf5e:	60fb      	str	r3, [r7, #12]
            break;
 800bf60:	bf00      	nop
    }
    if (power_db > init_power_in_dB) {
 800bf62:	4b09      	ldr	r3, [pc, #36]	; (800bf88 <get_max_power_for_modulation_type+0x40>)
 800bf64:	f9b3 3000 	ldrsh.w	r3, [r3]
 800bf68:	461a      	mov	r2, r3
 800bf6a:	68fb      	ldr	r3, [r7, #12]
 800bf6c:	4293      	cmp	r3, r2
 800bf6e:	dd03      	ble.n	800bf78 <get_max_power_for_modulation_type+0x30>
        power_db = init_power_in_dB;
 800bf70:	4b05      	ldr	r3, [pc, #20]	; (800bf88 <get_max_power_for_modulation_type+0x40>)
 800bf72:	f9b3 3000 	ldrsh.w	r3, [r3]
 800bf76:	60fb      	str	r3, [r7, #12]
    }
    return power_db;
 800bf78:	68fb      	ldr	r3, [r7, #12]
}
 800bf7a:	4618      	mov	r0, r3
 800bf7c:	3714      	adds	r7, #20
 800bf7e:	46bd      	mov	sp, r7
 800bf80:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf84:	4770      	bx	lr
 800bf86:	bf00      	nop
 800bf88:	2000001c 	.word	0x2000001c

0800bf8c <get_highest_level_for_given_power>:

static int get_highest_level_for_given_power(int power_db, int recommended_db){
 800bf8c:	b480      	push	{r7}
 800bf8e:	b085      	sub	sp, #20
 800bf90:	af00      	add	r7, sp, #0
 800bf92:	6078      	str	r0, [r7, #4]
 800bf94:	6039      	str	r1, [r7, #0]
    int i = NUM_POWER_LEVELS-1;
 800bf96:	230f      	movs	r3, #15
 800bf98:	60fb      	str	r3, [r7, #12]
    while (i) {
 800bf9a:	e00b      	b.n	800bfb4 <get_highest_level_for_given_power+0x28>
        if (power_db <= recommended_db) {
 800bf9c:	687a      	ldr	r2, [r7, #4]
 800bf9e:	683b      	ldr	r3, [r7, #0]
 800bfa0:	429a      	cmp	r2, r3
 800bfa2:	dc01      	bgt.n	800bfa8 <get_highest_level_for_given_power+0x1c>
            return i;
 800bfa4:	68fb      	ldr	r3, [r7, #12]
 800bfa6:	e009      	b.n	800bfbc <get_highest_level_for_given_power+0x30>
        }
        power_db -= DB_PER_LEVEL;
 800bfa8:	687b      	ldr	r3, [r7, #4]
 800bfaa:	3b05      	subs	r3, #5
 800bfac:	607b      	str	r3, [r7, #4]
        i--;
 800bfae:	68fb      	ldr	r3, [r7, #12]
 800bfb0:	3b01      	subs	r3, #1
 800bfb2:	60fb      	str	r3, [r7, #12]
    while (i) {
 800bfb4:	68fb      	ldr	r3, [r7, #12]
 800bfb6:	2b00      	cmp	r3, #0
 800bfb8:	d1f0      	bne.n	800bf9c <get_highest_level_for_given_power+0x10>
    }
    return 0;
 800bfba:	2300      	movs	r3, #0
}
 800bfbc:	4618      	mov	r0, r3
 800bfbe:	3714      	adds	r7, #20
 800bfc0:	46bd      	mov	sp, r7
 800bfc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bfc6:	4770      	bx	lr

0800bfc8 <update_set_power_vector>:

static void update_set_power_vector(uint8_t *hci_cmd_buffer){
 800bfc8:	b580      	push	{r7, lr}
 800bfca:	b086      	sub	sp, #24
 800bfcc:	af00      	add	r7, sp, #0
 800bfce:	6078      	str	r0, [r7, #4]
    uint8_t modulation_type = hci_cmd_buffer[3];
 800bfd0:	687b      	ldr	r3, [r7, #4]
 800bfd2:	78db      	ldrb	r3, [r3, #3]
 800bfd4:	72fb      	strb	r3, [r7, #11]
    btstack_assert(modulation_type <= 2);

    // explicit power vector provided by user
    if (init_power_vectors[modulation_type] != NULL){
 800bfd6:	7afb      	ldrb	r3, [r7, #11]
 800bfd8:	4a29      	ldr	r2, [pc, #164]	; (800c080 <update_set_power_vector+0xb8>)
 800bfda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800bfde:	2b00      	cmp	r3, #0
 800bfe0:	d00a      	beq.n	800bff8 <update_set_power_vector+0x30>
        (void)memcpy(&hci_cmd_buffer[4], init_power_vectors[modulation_type], 16);
 800bfe2:	687b      	ldr	r3, [r7, #4]
 800bfe4:	1d18      	adds	r0, r3, #4
 800bfe6:	7afb      	ldrb	r3, [r7, #11]
 800bfe8:	4a25      	ldr	r2, [pc, #148]	; (800c080 <update_set_power_vector+0xb8>)
 800bfea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800bfee:	2210      	movs	r2, #16
 800bff0:	4619      	mov	r1, r3
 800bff2:	f01b fd42 	bl	8027a7a <memcpy>
        return;
 800bff6:	e03f      	b.n	800c078 <update_set_power_vector+0xb0>
    }

    unsigned int i;
    int power_db = get_max_power_for_modulation_type(modulation_type);
 800bff8:	7afb      	ldrb	r3, [r7, #11]
 800bffa:	4618      	mov	r0, r3
 800bffc:	f7ff ffa4 	bl	800bf48 <get_max_power_for_modulation_type>
 800c000:	6138      	str	r0, [r7, #16]
    int dynamic_range = 0;
 800c002:	2300      	movs	r3, #0
 800c004:	60fb      	str	r3, [r7, #12]

    // f) don't touch level 0
    for ( i = (NUM_POWER_LEVELS-1) ; i >= 1 ; i--){
 800c006:	230f      	movs	r3, #15
 800c008:	617b      	str	r3, [r7, #20]
 800c00a:	e032      	b.n	800c072 <update_set_power_vector+0xaa>

#ifdef ENABLE_BLE
        // level 1 is BLE transmit power for GFSK
        if (i == 1 && modulation_type == 0) {
 800c00c:	697b      	ldr	r3, [r7, #20]
 800c00e:	2b01      	cmp	r3, #1
 800c010:	d10e      	bne.n	800c030 <update_set_power_vector+0x68>
 800c012:	7afb      	ldrb	r3, [r7, #11]
 800c014:	2b00      	cmp	r3, #0
 800c016:	d10b      	bne.n	800c030 <update_set_power_vector+0x68>
            hci_cmd_buffer[4+1] = 2 * get_max_power_for_modulation_type(modulation_type);
 800c018:	7afb      	ldrb	r3, [r7, #11]
 800c01a:	4618      	mov	r0, r3
 800c01c:	f7ff ff94 	bl	800bf48 <get_max_power_for_modulation_type>
 800c020:	4603      	mov	r3, r0
 800c022:	b2da      	uxtb	r2, r3
 800c024:	687b      	ldr	r3, [r7, #4]
 800c026:	3305      	adds	r3, #5
 800c028:	0052      	lsls	r2, r2, #1
 800c02a:	b2d2      	uxtb	r2, r2
 800c02c:	701a      	strb	r2, [r3, #0]
            // as level 0 isn't set, we're done
            continue;
 800c02e:	e01d      	b.n	800c06c <update_set_power_vector+0xa4>
        }
#endif
        hci_cmd_buffer[4+i] = 2 * power_db;
 800c030:	693b      	ldr	r3, [r7, #16]
 800c032:	b2da      	uxtb	r2, r3
 800c034:	697b      	ldr	r3, [r7, #20]
 800c036:	3304      	adds	r3, #4
 800c038:	6879      	ldr	r1, [r7, #4]
 800c03a:	440b      	add	r3, r1
 800c03c:	0052      	lsls	r2, r2, #1
 800c03e:	b2d2      	uxtb	r2, r2
 800c040:	701a      	strb	r2, [r3, #0]

        if (dynamic_range + DB_PER_LEVEL > DB_DYNAMIC_RANGE) continue;  // e)
 800c042:	68fb      	ldr	r3, [r7, #12]
 800c044:	3305      	adds	r3, #5
 800c046:	2b1e      	cmp	r3, #30
 800c048:	dc0d      	bgt.n	800c066 <update_set_power_vector+0x9e>

        power_db      -= DB_PER_LEVEL;   // d)
 800c04a:	693b      	ldr	r3, [r7, #16]
 800c04c:	3b05      	subs	r3, #5
 800c04e:	613b      	str	r3, [r7, #16]
        dynamic_range += DB_PER_LEVEL;
 800c050:	68fb      	ldr	r3, [r7, #12]
 800c052:	3305      	adds	r3, #5
 800c054:	60fb      	str	r3, [r7, #12]

        if (power_db > DB_MIN_LEVEL) continue;
 800c056:	693b      	ldr	r3, [r7, #16]
 800c058:	f113 0f22 	cmn.w	r3, #34	; 0x22
 800c05c:	da05      	bge.n	800c06a <update_set_power_vector+0xa2>

        power_db = DB_MIN_LEVEL;    // b) 
 800c05e:	f06f 0322 	mvn.w	r3, #34	; 0x22
 800c062:	613b      	str	r3, [r7, #16]
 800c064:	e002      	b.n	800c06c <update_set_power_vector+0xa4>
        if (dynamic_range + DB_PER_LEVEL > DB_DYNAMIC_RANGE) continue;  // e)
 800c066:	bf00      	nop
 800c068:	e000      	b.n	800c06c <update_set_power_vector+0xa4>
        if (power_db > DB_MIN_LEVEL) continue;
 800c06a:	bf00      	nop
    for ( i = (NUM_POWER_LEVELS-1) ; i >= 1 ; i--){
 800c06c:	697b      	ldr	r3, [r7, #20]
 800c06e:	3b01      	subs	r3, #1
 800c070:	617b      	str	r3, [r7, #20]
 800c072:	697b      	ldr	r3, [r7, #20]
 800c074:	2b00      	cmp	r3, #0
 800c076:	d1c9      	bne.n	800c00c <update_set_power_vector+0x44>
    } 
}
 800c078:	3718      	adds	r7, #24
 800c07a:	46bd      	mov	sp, r7
 800c07c:	bd80      	pop	{r7, pc}
 800c07e:	bf00      	nop
 800c080:	20006128 	.word	0x20006128

0800c084 <update_set_class2_single_power>:

// max permitted power for class 2 devices: 4 dBm
static void update_set_class2_single_power(uint8_t * hci_cmd_buffer){
 800c084:	b580      	push	{r7, lr}
 800c086:	b084      	sub	sp, #16
 800c088:	af00      	add	r7, sp, #0
 800c08a:	6078      	str	r0, [r7, #4]
    const int max_power_class_2 = 4;
 800c08c:	2304      	movs	r3, #4
 800c08e:	60bb      	str	r3, [r7, #8]
    int i = 0;
 800c090:	2300      	movs	r3, #0
 800c092:	60fb      	str	r3, [r7, #12]
    for (i=0;i<3;i++){
 800c094:	2300      	movs	r3, #0
 800c096:	60fb      	str	r3, [r7, #12]
 800c098:	e012      	b.n	800c0c0 <update_set_class2_single_power+0x3c>
        hci_cmd_buffer[3+i] = get_highest_level_for_given_power(get_max_power_for_modulation_type(i), max_power_class_2);
 800c09a:	68f8      	ldr	r0, [r7, #12]
 800c09c:	f7ff ff54 	bl	800bf48 <get_max_power_for_modulation_type>
 800c0a0:	4603      	mov	r3, r0
 800c0a2:	68b9      	ldr	r1, [r7, #8]
 800c0a4:	4618      	mov	r0, r3
 800c0a6:	f7ff ff71 	bl	800bf8c <get_highest_level_for_given_power>
 800c0aa:	4601      	mov	r1, r0
 800c0ac:	68fb      	ldr	r3, [r7, #12]
 800c0ae:	3303      	adds	r3, #3
 800c0b0:	461a      	mov	r2, r3
 800c0b2:	687b      	ldr	r3, [r7, #4]
 800c0b4:	4413      	add	r3, r2
 800c0b6:	b2ca      	uxtb	r2, r1
 800c0b8:	701a      	strb	r2, [r3, #0]
    for (i=0;i<3;i++){
 800c0ba:	68fb      	ldr	r3, [r7, #12]
 800c0bc:	3301      	adds	r3, #1
 800c0be:	60fb      	str	r3, [r7, #12]
 800c0c0:	68fb      	ldr	r3, [r7, #12]
 800c0c2:	2b02      	cmp	r3, #2
 800c0c4:	dde9      	ble.n	800c09a <update_set_class2_single_power+0x16>
    }
}
 800c0c6:	bf00      	nop
 800c0c8:	3710      	adds	r7, #16
 800c0ca:	46bd      	mov	sp, r7
 800c0cc:	bd80      	pop	{r7, pc}

0800c0ce <update_sleep_mode_configurations>:

// eHCILL activate from http://e2e.ti.com/support/low_power_rf/f/660/p/134855/484776.aspx
static void update_sleep_mode_configurations(uint8_t * hci_cmd_buffer){
 800c0ce:	b480      	push	{r7}
 800c0d0:	b083      	sub	sp, #12
 800c0d2:	af00      	add	r7, sp, #0
 800c0d4:	6078      	str	r0, [r7, #4]
#ifdef ENABLE_EHCILL  
    hci_cmd_buffer[4] = 1;
#else
    hci_cmd_buffer[4] = 0;
 800c0d6:	687b      	ldr	r3, [r7, #4]
 800c0d8:	3304      	adds	r3, #4
 800c0da:	2200      	movs	r2, #0
 800c0dc:	701a      	strb	r2, [r3, #0]
#endif
}
 800c0de:	bf00      	nop
 800c0e0:	370c      	adds	r7, #12
 800c0e2:	46bd      	mov	sp, r7
 800c0e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c0e8:	4770      	bx	lr

0800c0ea <update_init_script_command>:

static void update_init_script_command(uint8_t *hci_cmd_buffer){
 800c0ea:	b580      	push	{r7, lr}
 800c0ec:	b084      	sub	sp, #16
 800c0ee:	af00      	add	r7, sp, #0
 800c0f0:	6078      	str	r0, [r7, #4]

    uint16_t opcode = hci_cmd_buffer[0] | (hci_cmd_buffer[1] << 8);
 800c0f2:	687b      	ldr	r3, [r7, #4]
 800c0f4:	781b      	ldrb	r3, [r3, #0]
 800c0f6:	b21a      	sxth	r2, r3
 800c0f8:	687b      	ldr	r3, [r7, #4]
 800c0fa:	3301      	adds	r3, #1
 800c0fc:	781b      	ldrb	r3, [r3, #0]
 800c0fe:	021b      	lsls	r3, r3, #8
 800c100:	b21b      	sxth	r3, r3
 800c102:	4313      	orrs	r3, r2
 800c104:	b21b      	sxth	r3, r3
 800c106:	81fb      	strh	r3, [r7, #14]

    switch (opcode){
 800c108:	89fb      	ldrh	r3, [r7, #14]
 800c10a:	f64f 5282 	movw	r2, #64898	; 0xfd82
 800c10e:	4293      	cmp	r3, r2
 800c110:	d00c      	beq.n	800c12c <update_init_script_command+0x42>
 800c112:	f64f 5287 	movw	r2, #64903	; 0xfd87
 800c116:	4293      	cmp	r3, r2
 800c118:	d004      	beq.n	800c124 <update_init_script_command+0x3a>
 800c11a:	f64f 520c 	movw	r2, #64780	; 0xfd0c
 800c11e:	4293      	cmp	r3, r2
 800c120:	d008      	beq.n	800c134 <update_init_script_command+0x4a>
            break;
        case 0xFD0C:
            update_sleep_mode_configurations(hci_cmd_buffer);
            break;
        default:
            break;
 800c122:	e00b      	b.n	800c13c <update_init_script_command+0x52>
            update_set_class2_single_power(hci_cmd_buffer);
 800c124:	6878      	ldr	r0, [r7, #4]
 800c126:	f7ff ffad 	bl	800c084 <update_set_class2_single_power>
            break;
 800c12a:	e007      	b.n	800c13c <update_init_script_command+0x52>
            update_set_power_vector(hci_cmd_buffer);
 800c12c:	6878      	ldr	r0, [r7, #4]
 800c12e:	f7ff ff4b 	bl	800bfc8 <update_set_power_vector>
            break;
 800c132:	e003      	b.n	800c13c <update_init_script_command+0x52>
            update_sleep_mode_configurations(hci_cmd_buffer);
 800c134:	6878      	ldr	r0, [r7, #4]
 800c136:	f7ff ffca 	bl	800c0ce <update_sleep_mode_configurations>
            break;
 800c13a:	bf00      	nop
    }
}
 800c13c:	bf00      	nop
 800c13e:	3710      	adds	r7, #16
 800c140:	46bd      	mov	sp, r7
 800c142:	bd80      	pop	{r7, pc}

0800c144 <chipset_next_command>:

static btstack_chipset_result_t chipset_next_command(uint8_t * hci_cmd_buffer){
 800c144:	b580      	push	{r7, lr}
 800c146:	b084      	sub	sp, #16
 800c148:	af00      	add	r7, sp, #0
 800c14a:	6078      	str	r0, [r7, #4]
    if (init_script_offset >= init_script_size) {
 800c14c:	4b24      	ldr	r3, [pc, #144]	; (800c1e0 <chipset_next_command+0x9c>)
 800c14e:	681a      	ldr	r2, [r3, #0]
 800c150:	4b24      	ldr	r3, [pc, #144]	; (800c1e4 <chipset_next_command+0xa0>)
 800c152:	681b      	ldr	r3, [r3, #0]
 800c154:	429a      	cmp	r2, r3
 800c156:	d311      	bcc.n	800c17c <chipset_next_command+0x38>

#ifdef ENABLE_SCO_OVER_HCI
        // append send route SCO over HCI if requested
        if (init_send_route_sco_over_hci){
 800c158:	4b23      	ldr	r3, [pc, #140]	; (800c1e8 <chipset_next_command+0xa4>)
 800c15a:	681b      	ldr	r3, [r3, #0]
 800c15c:	2b00      	cmp	r3, #0
 800c15e:	d00b      	beq.n	800c178 <chipset_next_command+0x34>
            init_send_route_sco_over_hci = 0;
 800c160:	4b21      	ldr	r3, [pc, #132]	; (800c1e8 <chipset_next_command+0xa4>)
 800c162:	2200      	movs	r2, #0
 800c164:	601a      	str	r2, [r3, #0]
            memcpy(hci_cmd_buffer, hci_route_sco_over_hci, sizeof(hci_route_sco_over_hci));
 800c166:	687b      	ldr	r3, [r7, #4]
 800c168:	4920      	ldr	r1, [pc, #128]	; (800c1ec <chipset_next_command+0xa8>)
 800c16a:	461a      	mov	r2, r3
 800c16c:	460b      	mov	r3, r1
 800c16e:	cb03      	ldmia	r3!, {r0, r1}
 800c170:	6010      	str	r0, [r2, #0]
 800c172:	6051      	str	r1, [r2, #4]
            return BTSTACK_CHIPSET_VALID_COMMAND;
 800c174:	2301      	movs	r3, #1
 800c176:	e02f      	b.n	800c1d8 <chipset_next_command+0x94>
            init_send_sco_i2s_config_cvsd = 0;
            memcpy(hci_cmd_buffer, hci_write_codec_config_cvsd, sizeof(hci_write_codec_config_cvsd));
            return BTSTACK_CHIPSET_VALID_COMMAND;
        }
#endif
       return BTSTACK_CHIPSET_DONE;
 800c178:	2300      	movs	r3, #0
 800c17a:	e02d      	b.n	800c1d8 <chipset_next_command+0x94>
    }
    
    // extracted init script has 0x01 cmd packet type, but BTstack expects them without
    init_script_offset++;
 800c17c:	4b18      	ldr	r3, [pc, #96]	; (800c1e0 <chipset_next_command+0x9c>)
 800c17e:	681b      	ldr	r3, [r3, #0]
 800c180:	3301      	adds	r3, #1
 800c182:	4a17      	ldr	r2, [pc, #92]	; (800c1e0 <chipset_next_command+0x9c>)
 800c184:	6013      	str	r3, [r2, #0]
    memcpy_P(&hci_cmd_buffer[3], &init_script[init_script_offset], payload_len);

#else    

    // use memcpy with pointer
    uint8_t * init_script_ptr = (uint8_t*) &init_script[0];
 800c186:	4b1a      	ldr	r3, [pc, #104]	; (800c1f0 <chipset_next_command+0xac>)
 800c188:	681b      	ldr	r3, [r3, #0]
 800c18a:	60fb      	str	r3, [r7, #12]
    memcpy(&hci_cmd_buffer[0], init_script_ptr + init_script_offset, 3);  // cmd header
 800c18c:	4b14      	ldr	r3, [pc, #80]	; (800c1e0 <chipset_next_command+0x9c>)
 800c18e:	681b      	ldr	r3, [r3, #0]
 800c190:	68fa      	ldr	r2, [r7, #12]
 800c192:	4413      	add	r3, r2
 800c194:	2203      	movs	r2, #3
 800c196:	4619      	mov	r1, r3
 800c198:	6878      	ldr	r0, [r7, #4]
 800c19a:	f01b fc6e 	bl	8027a7a <memcpy>
    init_script_offset += 3;
 800c19e:	4b10      	ldr	r3, [pc, #64]	; (800c1e0 <chipset_next_command+0x9c>)
 800c1a0:	681b      	ldr	r3, [r3, #0]
 800c1a2:	3303      	adds	r3, #3
 800c1a4:	4a0e      	ldr	r2, [pc, #56]	; (800c1e0 <chipset_next_command+0x9c>)
 800c1a6:	6013      	str	r3, [r2, #0]
    int payload_len = hci_cmd_buffer[2];
 800c1a8:	687b      	ldr	r3, [r7, #4]
 800c1aa:	3302      	adds	r3, #2
 800c1ac:	781b      	ldrb	r3, [r3, #0]
 800c1ae:	60bb      	str	r3, [r7, #8]
    memcpy(&hci_cmd_buffer[3], init_script_ptr + init_script_offset, payload_len);  // cmd payload
 800c1b0:	687b      	ldr	r3, [r7, #4]
 800c1b2:	1cd8      	adds	r0, r3, #3
 800c1b4:	4b0a      	ldr	r3, [pc, #40]	; (800c1e0 <chipset_next_command+0x9c>)
 800c1b6:	681b      	ldr	r3, [r3, #0]
 800c1b8:	68fa      	ldr	r2, [r7, #12]
 800c1ba:	4413      	add	r3, r2
 800c1bc:	68ba      	ldr	r2, [r7, #8]
 800c1be:	4619      	mov	r1, r3
 800c1c0:	f01b fc5b 	bl	8027a7a <memcpy>

#endif

    init_script_offset += payload_len;
 800c1c4:	4b06      	ldr	r3, [pc, #24]	; (800c1e0 <chipset_next_command+0x9c>)
 800c1c6:	681a      	ldr	r2, [r3, #0]
 800c1c8:	68bb      	ldr	r3, [r7, #8]
 800c1ca:	4413      	add	r3, r2
 800c1cc:	4a04      	ldr	r2, [pc, #16]	; (800c1e0 <chipset_next_command+0x9c>)
 800c1ce:	6013      	str	r3, [r2, #0]

    // control power commands and ehcill 
    update_init_script_command(hci_cmd_buffer);
 800c1d0:	6878      	ldr	r0, [r7, #4]
 800c1d2:	f7ff ff8a 	bl	800c0ea <update_init_script_command>

    return BTSTACK_CHIPSET_VALID_COMMAND; 
 800c1d6:	2301      	movs	r3, #1
}
 800c1d8:	4618      	mov	r0, r3
 800c1da:	3710      	adds	r7, #16
 800c1dc:	46bd      	mov	sp, r7
 800c1de:	bd80      	pop	{r7, pc}
 800c1e0:	20006134 	.word	0x20006134
 800c1e4:	20006124 	.word	0x20006124
 800c1e8:	20006138 	.word	0x20006138
 800c1ec:	0803092c 	.word	0x0803092c
 800c1f0:	20006120 	.word	0x20006120

0800c1f4 <btstack_chipset_cc256x_instance>:
    chipset_next_command,
    chipset_set_baudrate_command,
    chipset_set_bd_addr_command,
};

const btstack_chipset_t * btstack_chipset_cc256x_instance(void){
 800c1f4:	b480      	push	{r7}
 800c1f6:	af00      	add	r7, sp, #0
    return &btstack_chipset_cc256x;
 800c1f8:	4b02      	ldr	r3, [pc, #8]	; (800c204 <btstack_chipset_cc256x_instance+0x10>)
}
 800c1fa:	4618      	mov	r0, r3
 800c1fc:	46bd      	mov	sp, r7
 800c1fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c202:	4770      	bx	lr
 800c204:	08030934 	.word	0x08030934

0800c208 <btstack_run_loop_embedded_add_data_source>:
static int trigger_event_received = 0;

/**
 * Add data_source to run_loop
 */
static void btstack_run_loop_embedded_add_data_source(btstack_data_source_t *ds){
 800c208:	b580      	push	{r7, lr}
 800c20a:	b082      	sub	sp, #8
 800c20c:	af00      	add	r7, sp, #0
 800c20e:	6078      	str	r0, [r7, #4]
    btstack_linked_list_add(&data_sources, (btstack_linked_item_t *) ds);
 800c210:	6879      	ldr	r1, [r7, #4]
 800c212:	4803      	ldr	r0, [pc, #12]	; (800c220 <btstack_run_loop_embedded_add_data_source+0x18>)
 800c214:	f002 fa0d 	bl	800e632 <btstack_linked_list_add>
}
 800c218:	bf00      	nop
 800c21a:	3708      	adds	r7, #8
 800c21c:	46bd      	mov	sp, r7
 800c21e:	bd80      	pop	{r7, pc}
 800c220:	2000613c 	.word	0x2000613c

0800c224 <btstack_run_loop_embedded_remove_data_source>:

/**
 * Remove data_source from run loop
 */
static bool btstack_run_loop_embedded_remove_data_source(btstack_data_source_t *ds){
 800c224:	b580      	push	{r7, lr}
 800c226:	b082      	sub	sp, #8
 800c228:	af00      	add	r7, sp, #0
 800c22a:	6078      	str	r0, [r7, #4]
    return btstack_linked_list_remove(&data_sources, (btstack_linked_item_t *) ds);
 800c22c:	6879      	ldr	r1, [r7, #4]
 800c22e:	4804      	ldr	r0, [pc, #16]	; (800c240 <btstack_run_loop_embedded_remove_data_source+0x1c>)
 800c230:	f002 fa45 	bl	800e6be <btstack_linked_list_remove>
 800c234:	4603      	mov	r3, r0
}
 800c236:	4618      	mov	r0, r3
 800c238:	3708      	adds	r7, #8
 800c23a:	46bd      	mov	sp, r7
 800c23c:	bd80      	pop	{r7, pc}
 800c23e:	bf00      	nop
 800c240:	2000613c 	.word	0x2000613c

0800c244 <btstack_run_loop_embedded_set_timer>:

// set timer
static void btstack_run_loop_embedded_set_timer(btstack_timer_source_t *ts, uint32_t timeout_in_ms){
 800c244:	b580      	push	{r7, lr}
 800c246:	b082      	sub	sp, #8
 800c248:	af00      	add	r7, sp, #0
 800c24a:	6078      	str	r0, [r7, #4]
 800c24c:	6039      	str	r1, [r7, #0]
    if (ticks == 0) ticks++;
    // time until next tick is < hal_tick_get_tick_period_in_ms() and we don't know, so we add one
    ts->timeout = system_ticks + 1 + ticks; 
#endif
#ifdef HAVE_EMBEDDED_TIME_MS
    ts->timeout = hal_time_ms() + timeout_in_ms + 1;
 800c24e:	f7f5 fdcd 	bl	8001dec <hal_time_ms>
 800c252:	4602      	mov	r2, r0
 800c254:	683b      	ldr	r3, [r7, #0]
 800c256:	4413      	add	r3, r2
 800c258:	1c5a      	adds	r2, r3, #1
 800c25a:	687b      	ldr	r3, [r7, #4]
 800c25c:	605a      	str	r2, [r3, #4]
#endif
}
 800c25e:	bf00      	nop
 800c260:	3708      	adds	r7, #8
 800c262:	46bd      	mov	sp, r7
 800c264:	bd80      	pop	{r7, pc}
	...

0800c268 <btstack_run_loop_embedded_add_timer>:

/**
 * Add timer to run_loop (keep list sorted)
 */
static void btstack_run_loop_embedded_add_timer(btstack_timer_source_t *ts){
 800c268:	b580      	push	{r7, lr}
 800c26a:	b086      	sub	sp, #24
 800c26c:	af00      	add	r7, sp, #0
 800c26e:	6078      	str	r0, [r7, #4]
#ifdef TIMER_SUPPORT
    btstack_linked_item_t *it;
    for (it = (btstack_linked_item_t *) &timers; it->next ; it = it->next){
 800c270:	4b17      	ldr	r3, [pc, #92]	; (800c2d0 <btstack_run_loop_embedded_add_timer+0x68>)
 800c272:	617b      	str	r3, [r7, #20]
 800c274:	e01c      	b.n	800c2b0 <btstack_run_loop_embedded_add_timer+0x48>
        // don't add timer that's already in there
        btstack_timer_source_t * next = (btstack_timer_source_t *) it->next;
 800c276:	697b      	ldr	r3, [r7, #20]
 800c278:	681b      	ldr	r3, [r3, #0]
 800c27a:	613b      	str	r3, [r7, #16]
        if (next == ts){
 800c27c:	693a      	ldr	r2, [r7, #16]
 800c27e:	687b      	ldr	r3, [r7, #4]
 800c280:	429a      	cmp	r2, r3
 800c282:	d106      	bne.n	800c292 <btstack_run_loop_embedded_add_timer+0x2a>
            log_error( "btstack_run_loop_timer_add error: timer to add already in list!");
 800c284:	2383      	movs	r3, #131	; 0x83
 800c286:	4a13      	ldr	r2, [pc, #76]	; (800c2d4 <btstack_run_loop_embedded_add_timer+0x6c>)
 800c288:	4913      	ldr	r1, [pc, #76]	; (800c2d8 <btstack_run_loop_embedded_add_timer+0x70>)
 800c28a:	2002      	movs	r0, #2
 800c28c:	f00b f8d8 	bl	8017440 <hci_dump_log>
            return;
 800c290:	e01b      	b.n	800c2ca <btstack_run_loop_embedded_add_timer+0x62>
        }
        // exit if new timeout before list timeout
        int32_t delta = btstack_time_delta(ts->timeout, next->timeout);
 800c292:	687b      	ldr	r3, [r7, #4]
 800c294:	685a      	ldr	r2, [r3, #4]
 800c296:	693b      	ldr	r3, [r7, #16]
 800c298:	685b      	ldr	r3, [r3, #4]
 800c29a:	4619      	mov	r1, r3
 800c29c:	4610      	mov	r0, r2
 800c29e:	f002 ff56 	bl	800f14e <btstack_time_delta>
 800c2a2:	60f8      	str	r0, [r7, #12]
        if (delta < 0) break;
 800c2a4:	68fb      	ldr	r3, [r7, #12]
 800c2a6:	2b00      	cmp	r3, #0
 800c2a8:	db07      	blt.n	800c2ba <btstack_run_loop_embedded_add_timer+0x52>
    for (it = (btstack_linked_item_t *) &timers; it->next ; it = it->next){
 800c2aa:	697b      	ldr	r3, [r7, #20]
 800c2ac:	681b      	ldr	r3, [r3, #0]
 800c2ae:	617b      	str	r3, [r7, #20]
 800c2b0:	697b      	ldr	r3, [r7, #20]
 800c2b2:	681b      	ldr	r3, [r3, #0]
 800c2b4:	2b00      	cmp	r3, #0
 800c2b6:	d1de      	bne.n	800c276 <btstack_run_loop_embedded_add_timer+0xe>
 800c2b8:	e000      	b.n	800c2bc <btstack_run_loop_embedded_add_timer+0x54>
        if (delta < 0) break;
 800c2ba:	bf00      	nop
    }

    ts->item.next = it->next;
 800c2bc:	697b      	ldr	r3, [r7, #20]
 800c2be:	681a      	ldr	r2, [r3, #0]
 800c2c0:	687b      	ldr	r3, [r7, #4]
 800c2c2:	601a      	str	r2, [r3, #0]
    it->next = (btstack_linked_item_t *) ts;
 800c2c4:	697b      	ldr	r3, [r7, #20]
 800c2c6:	687a      	ldr	r2, [r7, #4]
 800c2c8:	601a      	str	r2, [r3, #0]
#endif
}
 800c2ca:	3718      	adds	r7, #24
 800c2cc:	46bd      	mov	sp, r7
 800c2ce:	bd80      	pop	{r7, pc}
 800c2d0:	20006140 	.word	0x20006140
 800c2d4:	08028ca8 	.word	0x08028ca8
 800c2d8:	08028cc4 	.word	0x08028cc4

0800c2dc <btstack_run_loop_embedded_remove_timer>:

/**
 * Remove timer from run loop
 */
static bool btstack_run_loop_embedded_remove_timer(btstack_timer_source_t *ts){
 800c2dc:	b580      	push	{r7, lr}
 800c2de:	b082      	sub	sp, #8
 800c2e0:	af00      	add	r7, sp, #0
 800c2e2:	6078      	str	r0, [r7, #4]
#ifdef TIMER_SUPPORT
    return btstack_linked_list_remove(&timers, (btstack_linked_item_t *) ts);
 800c2e4:	6879      	ldr	r1, [r7, #4]
 800c2e6:	4804      	ldr	r0, [pc, #16]	; (800c2f8 <btstack_run_loop_embedded_remove_timer+0x1c>)
 800c2e8:	f002 f9e9 	bl	800e6be <btstack_linked_list_remove>
 800c2ec:	4603      	mov	r3, r0
#else
    return 0;
#endif
}
 800c2ee:	4618      	mov	r0, r3
 800c2f0:	3708      	adds	r7, #8
 800c2f2:	46bd      	mov	sp, r7
 800c2f4:	bd80      	pop	{r7, pc}
 800c2f6:	bf00      	nop
 800c2f8:	20006140 	.word	0x20006140

0800c2fc <btstack_run_loop_embedded_dump_timer>:

static void btstack_run_loop_embedded_dump_timer(void){
 800c2fc:	b580      	push	{r7, lr}
 800c2fe:	b086      	sub	sp, #24
 800c300:	af02      	add	r7, sp, #8
#ifdef TIMER_SUPPORT
#ifdef ENABLE_LOG_INFO 
    btstack_linked_item_t *it;
    int i = 0;
 800c302:	2300      	movs	r3, #0
 800c304:	60bb      	str	r3, [r7, #8]
    for (it = (btstack_linked_item_t *) timers; it ; it = it->next){
 800c306:	4b0d      	ldr	r3, [pc, #52]	; (800c33c <btstack_run_loop_embedded_dump_timer+0x40>)
 800c308:	681b      	ldr	r3, [r3, #0]
 800c30a:	60fb      	str	r3, [r7, #12]
 800c30c:	e00f      	b.n	800c32e <btstack_run_loop_embedded_dump_timer+0x32>
        btstack_timer_source_t *ts = (btstack_timer_source_t*) it;
 800c30e:	68fb      	ldr	r3, [r7, #12]
 800c310:	607b      	str	r3, [r7, #4]
        log_info("timer %u, timeout %u\n", i, (unsigned int) ts->timeout);
 800c312:	687b      	ldr	r3, [r7, #4]
 800c314:	685b      	ldr	r3, [r3, #4]
 800c316:	9301      	str	r3, [sp, #4]
 800c318:	68bb      	ldr	r3, [r7, #8]
 800c31a:	9300      	str	r3, [sp, #0]
 800c31c:	23a2      	movs	r3, #162	; 0xa2
 800c31e:	4a08      	ldr	r2, [pc, #32]	; (800c340 <btstack_run_loop_embedded_dump_timer+0x44>)
 800c320:	4908      	ldr	r1, [pc, #32]	; (800c344 <btstack_run_loop_embedded_dump_timer+0x48>)
 800c322:	2001      	movs	r0, #1
 800c324:	f00b f88c 	bl	8017440 <hci_dump_log>
    for (it = (btstack_linked_item_t *) timers; it ; it = it->next){
 800c328:	68fb      	ldr	r3, [r7, #12]
 800c32a:	681b      	ldr	r3, [r3, #0]
 800c32c:	60fb      	str	r3, [r7, #12]
 800c32e:	68fb      	ldr	r3, [r7, #12]
 800c330:	2b00      	cmp	r3, #0
 800c332:	d1ec      	bne.n	800c30e <btstack_run_loop_embedded_dump_timer+0x12>
    }
#endif
#endif
}
 800c334:	bf00      	nop
 800c336:	3710      	adds	r7, #16
 800c338:	46bd      	mov	sp, r7
 800c33a:	bd80      	pop	{r7, pc}
 800c33c:	20006140 	.word	0x20006140
 800c340:	08028ca8 	.word	0x08028ca8
 800c344:	08028d0c 	.word	0x08028d0c

0800c348 <btstack_run_loop_embedded_enable_data_source_callbacks>:

static void btstack_run_loop_embedded_enable_data_source_callbacks(btstack_data_source_t * ds, uint16_t callback_types){
 800c348:	b480      	push	{r7}
 800c34a:	b083      	sub	sp, #12
 800c34c:	af00      	add	r7, sp, #0
 800c34e:	6078      	str	r0, [r7, #4]
 800c350:	460b      	mov	r3, r1
 800c352:	807b      	strh	r3, [r7, #2]
    ds->flags |= callback_types;
 800c354:	687b      	ldr	r3, [r7, #4]
 800c356:	899a      	ldrh	r2, [r3, #12]
 800c358:	887b      	ldrh	r3, [r7, #2]
 800c35a:	4313      	orrs	r3, r2
 800c35c:	b29a      	uxth	r2, r3
 800c35e:	687b      	ldr	r3, [r7, #4]
 800c360:	819a      	strh	r2, [r3, #12]
}
 800c362:	bf00      	nop
 800c364:	370c      	adds	r7, #12
 800c366:	46bd      	mov	sp, r7
 800c368:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c36c:	4770      	bx	lr

0800c36e <btstack_run_loop_embedded_disable_data_source_callbacks>:

static void btstack_run_loop_embedded_disable_data_source_callbacks(btstack_data_source_t * ds, uint16_t callback_types){
 800c36e:	b480      	push	{r7}
 800c370:	b083      	sub	sp, #12
 800c372:	af00      	add	r7, sp, #0
 800c374:	6078      	str	r0, [r7, #4]
 800c376:	460b      	mov	r3, r1
 800c378:	807b      	strh	r3, [r7, #2]
    ds->flags &= ~callback_types;
 800c37a:	687b      	ldr	r3, [r7, #4]
 800c37c:	899b      	ldrh	r3, [r3, #12]
 800c37e:	b21a      	sxth	r2, r3
 800c380:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800c384:	43db      	mvns	r3, r3
 800c386:	b21b      	sxth	r3, r3
 800c388:	4013      	ands	r3, r2
 800c38a:	b21b      	sxth	r3, r3
 800c38c:	b29a      	uxth	r2, r3
 800c38e:	687b      	ldr	r3, [r7, #4]
 800c390:	819a      	strh	r2, [r3, #12]
}
 800c392:	bf00      	nop
 800c394:	370c      	adds	r7, #12
 800c396:	46bd      	mov	sp, r7
 800c398:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c39c:	4770      	bx	lr
	...

0800c3a0 <btstack_run_loop_embedded_execute_once>:

/**
 * Execute run_loop once
 */
void btstack_run_loop_embedded_execute_once(void) {
 800c3a0:	b580      	push	{r7, lr}
 800c3a2:	b086      	sub	sp, #24
 800c3a4:	af00      	add	r7, sp, #0
    btstack_data_source_t *ds;

    // process data sources
    btstack_data_source_t *next;
    for (ds = (btstack_data_source_t *) data_sources; ds != NULL ; ds = next){
 800c3a6:	4b23      	ldr	r3, [pc, #140]	; (800c434 <btstack_run_loop_embedded_execute_once+0x94>)
 800c3a8:	681b      	ldr	r3, [r3, #0]
 800c3aa:	617b      	str	r3, [r7, #20]
 800c3ac:	e00f      	b.n	800c3ce <btstack_run_loop_embedded_execute_once+0x2e>
        next = (btstack_data_source_t *) ds->item.next; // cache pointer to next data_source to allow data source to remove itself
 800c3ae:	697b      	ldr	r3, [r7, #20]
 800c3b0:	681b      	ldr	r3, [r3, #0]
 800c3b2:	607b      	str	r3, [r7, #4]
        if (ds->flags & DATA_SOURCE_CALLBACK_POLL){
 800c3b4:	697b      	ldr	r3, [r7, #20]
 800c3b6:	899b      	ldrh	r3, [r3, #12]
 800c3b8:	f003 0301 	and.w	r3, r3, #1
 800c3bc:	2b00      	cmp	r3, #0
 800c3be:	d004      	beq.n	800c3ca <btstack_run_loop_embedded_execute_once+0x2a>
            ds->process(ds, DATA_SOURCE_CALLBACK_POLL);
 800c3c0:	697b      	ldr	r3, [r7, #20]
 800c3c2:	689b      	ldr	r3, [r3, #8]
 800c3c4:	2101      	movs	r1, #1
 800c3c6:	6978      	ldr	r0, [r7, #20]
 800c3c8:	4798      	blx	r3
    for (ds = (btstack_data_source_t *) data_sources; ds != NULL ; ds = next){
 800c3ca:	687b      	ldr	r3, [r7, #4]
 800c3cc:	617b      	str	r3, [r7, #20]
 800c3ce:	697b      	ldr	r3, [r7, #20]
 800c3d0:	2b00      	cmp	r3, #0
 800c3d2:	d1ec      	bne.n	800c3ae <btstack_run_loop_embedded_execute_once+0xe>

#ifdef HAVE_EMBEDDED_TICK
    uint32_t now = system_ticks;
#endif
#ifdef HAVE_EMBEDDED_TIME_MS
    uint32_t now = hal_time_ms();
 800c3d4:	f7f5 fd0a 	bl	8001dec <hal_time_ms>
 800c3d8:	6138      	str	r0, [r7, #16]
#endif

    // process timers
    while (timers) {
 800c3da:	e013      	b.n	800c404 <btstack_run_loop_embedded_execute_once+0x64>
        btstack_timer_source_t * ts = (btstack_timer_source_t *) timers;
 800c3dc:	4b16      	ldr	r3, [pc, #88]	; (800c438 <btstack_run_loop_embedded_execute_once+0x98>)
 800c3de:	681b      	ldr	r3, [r3, #0]
 800c3e0:	60fb      	str	r3, [r7, #12]
        int32_t delta = btstack_time_delta(ts->timeout, now);
 800c3e2:	68fb      	ldr	r3, [r7, #12]
 800c3e4:	685b      	ldr	r3, [r3, #4]
 800c3e6:	6939      	ldr	r1, [r7, #16]
 800c3e8:	4618      	mov	r0, r3
 800c3ea:	f002 feb0 	bl	800f14e <btstack_time_delta>
 800c3ee:	60b8      	str	r0, [r7, #8]
        if (delta > 0) break;
 800c3f0:	68bb      	ldr	r3, [r7, #8]
 800c3f2:	2b00      	cmp	r3, #0
 800c3f4:	dc0b      	bgt.n	800c40e <btstack_run_loop_embedded_execute_once+0x6e>

        btstack_run_loop_embedded_remove_timer(ts);
 800c3f6:	68f8      	ldr	r0, [r7, #12]
 800c3f8:	f7ff ff70 	bl	800c2dc <btstack_run_loop_embedded_remove_timer>
        ts->process(ts);
 800c3fc:	68fb      	ldr	r3, [r7, #12]
 800c3fe:	689b      	ldr	r3, [r3, #8]
 800c400:	68f8      	ldr	r0, [r7, #12]
 800c402:	4798      	blx	r3
    while (timers) {
 800c404:	4b0c      	ldr	r3, [pc, #48]	; (800c438 <btstack_run_loop_embedded_execute_once+0x98>)
 800c406:	681b      	ldr	r3, [r3, #0]
 800c408:	2b00      	cmp	r3, #0
 800c40a:	d1e7      	bne.n	800c3dc <btstack_run_loop_embedded_execute_once+0x3c>
 800c40c:	e000      	b.n	800c410 <btstack_run_loop_embedded_execute_once+0x70>
        if (delta > 0) break;
 800c40e:	bf00      	nop
    }
#endif
    
    // disable IRQs and check if run loop iteration has been requested. if not, go to sleep
    hal_cpu_disable_irqs();
 800c410:	f7f5 fc00 	bl	8001c14 <hal_cpu_disable_irqs>
    if (trigger_event_received){
 800c414:	4b09      	ldr	r3, [pc, #36]	; (800c43c <btstack_run_loop_embedded_execute_once+0x9c>)
 800c416:	681b      	ldr	r3, [r3, #0]
 800c418:	2b00      	cmp	r3, #0
 800c41a:	d005      	beq.n	800c428 <btstack_run_loop_embedded_execute_once+0x88>
        trigger_event_received = 0;
 800c41c:	4b07      	ldr	r3, [pc, #28]	; (800c43c <btstack_run_loop_embedded_execute_once+0x9c>)
 800c41e:	2200      	movs	r2, #0
 800c420:	601a      	str	r2, [r3, #0]
        hal_cpu_enable_irqs();
 800c422:	f7f5 fbff 	bl	8001c24 <hal_cpu_enable_irqs>
    } else {
        hal_cpu_enable_irqs_and_sleep();
    }
}
 800c426:	e001      	b.n	800c42c <btstack_run_loop_embedded_execute_once+0x8c>
        hal_cpu_enable_irqs_and_sleep();
 800c428:	f7f5 fc04 	bl	8001c34 <hal_cpu_enable_irqs_and_sleep>
}
 800c42c:	bf00      	nop
 800c42e:	3718      	adds	r7, #24
 800c430:	46bd      	mov	sp, r7
 800c432:	bd80      	pop	{r7, pc}
 800c434:	2000613c 	.word	0x2000613c
 800c438:	20006140 	.word	0x20006140
 800c43c:	20006144 	.word	0x20006144

0800c440 <btstack_run_loop_embedded_execute>:

/**
 * Execute run_loop
 */
static void btstack_run_loop_embedded_execute(void) {
 800c440:	b580      	push	{r7, lr}
 800c442:	af00      	add	r7, sp, #0
    while (true) {
        btstack_run_loop_embedded_execute_once();
 800c444:	f7ff ffac 	bl	800c3a0 <btstack_run_loop_embedded_execute_once>
 800c448:	e7fc      	b.n	800c444 <btstack_run_loop_embedded_execute+0x4>

0800c44a <btstack_run_loop_embedded_get_time_ms>:
uint32_t btstack_run_loop_embedded_ticks_for_ms(uint32_t time_in_ms){
    return time_in_ms / hal_tick_get_tick_period_in_ms();
}
#endif

static uint32_t btstack_run_loop_embedded_get_time_ms(void){
 800c44a:	b580      	push	{r7, lr}
 800c44c:	af00      	add	r7, sp, #0
#if   defined(HAVE_EMBEDDED_TIME_MS)
    return hal_time_ms();
 800c44e:	f7f5 fccd 	bl	8001dec <hal_time_ms>
 800c452:	4603      	mov	r3, r0
#elif defined(HAVE_EMBEDDED_TICK)
    return system_ticks * hal_tick_get_tick_period_in_ms();
#else
    return 0;
#endif
}
 800c454:	4618      	mov	r0, r3
 800c456:	bd80      	pop	{r7, pc}

0800c458 <btstack_run_loop_embedded_trigger>:


/**
 * trigger run loop iteration
 */
void btstack_run_loop_embedded_trigger(void){
 800c458:	b480      	push	{r7}
 800c45a:	af00      	add	r7, sp, #0
    trigger_event_received = 1;
 800c45c:	4b03      	ldr	r3, [pc, #12]	; (800c46c <btstack_run_loop_embedded_trigger+0x14>)
 800c45e:	2201      	movs	r2, #1
 800c460:	601a      	str	r2, [r3, #0]
}
 800c462:	bf00      	nop
 800c464:	46bd      	mov	sp, r7
 800c466:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c46a:	4770      	bx	lr
 800c46c:	20006144 	.word	0x20006144

0800c470 <btstack_run_loop_embedded_init>:

static void btstack_run_loop_embedded_init(void){
 800c470:	b480      	push	{r7}
 800c472:	af00      	add	r7, sp, #0
    data_sources = NULL;
 800c474:	4b05      	ldr	r3, [pc, #20]	; (800c48c <btstack_run_loop_embedded_init+0x1c>)
 800c476:	2200      	movs	r2, #0
 800c478:	601a      	str	r2, [r3, #0]

#ifdef TIMER_SUPPORT
    timers = NULL;
 800c47a:	4b05      	ldr	r3, [pc, #20]	; (800c490 <btstack_run_loop_embedded_init+0x20>)
 800c47c:	2200      	movs	r2, #0
 800c47e:	601a      	str	r2, [r3, #0]
#ifdef HAVE_EMBEDDED_TICK
    system_ticks = 0;
    hal_tick_init();
    hal_tick_set_handler(&btstack_run_loop_embedded_tick_handler);
#endif
}
 800c480:	bf00      	nop
 800c482:	46bd      	mov	sp, r7
 800c484:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c488:	4770      	bx	lr
 800c48a:	bf00      	nop
 800c48c:	2000613c 	.word	0x2000613c
 800c490:	20006140 	.word	0x20006140

0800c494 <btstack_run_loop_embedded_get_instance>:
    &btstack_run_loop_embedded_execute,
    &btstack_run_loop_embedded_dump_timer,
    &btstack_run_loop_embedded_get_time_ms,
};

const btstack_run_loop_t * btstack_run_loop_embedded_get_instance(void){
 800c494:	b480      	push	{r7}
 800c496:	af00      	add	r7, sp, #0
    return &btstack_run_loop_embedded;
 800c498:	4b02      	ldr	r3, [pc, #8]	; (800c4a4 <btstack_run_loop_embedded_get_instance+0x10>)
}
 800c49a:	4618      	mov	r0, r3
 800c49c:	46bd      	mov	sp, r7
 800c49e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c4a2:	4770      	bx	lr
 800c4a4:	08030948 	.word	0x08030948

0800c4a8 <btstack_tlv_flash_bank_align_size>:
	uint32_t offset;
	uint32_t tag;
	uint32_t len;
} tlv_iterator_t;

static uint32_t btstack_tlv_flash_bank_align_size(btstack_tlv_flash_bank_t * self, uint32_t size){
 800c4a8:	b580      	push	{r7, lr}
 800c4aa:	b084      	sub	sp, #16
 800c4ac:	af00      	add	r7, sp, #0
 800c4ae:	6078      	str	r0, [r7, #4]
 800c4b0:	6039      	str	r1, [r7, #0]
	uint32_t aligment = self->hal_flash_bank_impl->get_alignment(self->hal_flash_bank_context);
 800c4b2:	687b      	ldr	r3, [r7, #4]
 800c4b4:	681b      	ldr	r3, [r3, #0]
 800c4b6:	685b      	ldr	r3, [r3, #4]
 800c4b8:	687a      	ldr	r2, [r7, #4]
 800c4ba:	6852      	ldr	r2, [r2, #4]
 800c4bc:	4610      	mov	r0, r2
 800c4be:	4798      	blx	r3
 800c4c0:	60f8      	str	r0, [r7, #12]
	return (size + aligment - 1) & ~(aligment - 1);
 800c4c2:	683a      	ldr	r2, [r7, #0]
 800c4c4:	68fb      	ldr	r3, [r7, #12]
 800c4c6:	4413      	add	r3, r2
 800c4c8:	1e5a      	subs	r2, r3, #1
 800c4ca:	68fb      	ldr	r3, [r7, #12]
 800c4cc:	425b      	negs	r3, r3
 800c4ce:	4013      	ands	r3, r2
}
 800c4d0:	4618      	mov	r0, r3
 800c4d2:	3710      	adds	r7, #16
 800c4d4:	46bd      	mov	sp, r7
 800c4d6:	bd80      	pop	{r7, pc}

0800c4d8 <btstack_tlv_flash_bank_read>:

// support unaligned flash read/writes
// strategy: increase size to meet alignment, perform unaligned read/write of last chunk with helper buffer

static void btstack_tlv_flash_bank_read(btstack_tlv_flash_bank_t * self, int bank, uint32_t offset, uint8_t * buffer, uint32_t size){
 800c4d8:	b590      	push	{r4, r7, lr}
 800c4da:	b08d      	sub	sp, #52	; 0x34
 800c4dc:	af02      	add	r7, sp, #8
 800c4de:	60f8      	str	r0, [r7, #12]
 800c4e0:	60b9      	str	r1, [r7, #8]
 800c4e2:	607a      	str	r2, [r7, #4]
 800c4e4:	603b      	str	r3, [r7, #0]

	// read main data
	uint32_t aligment = self->hal_flash_bank_impl->get_alignment(self->hal_flash_bank_context);
 800c4e6:	68fb      	ldr	r3, [r7, #12]
 800c4e8:	681b      	ldr	r3, [r3, #0]
 800c4ea:	685b      	ldr	r3, [r3, #4]
 800c4ec:	68fa      	ldr	r2, [r7, #12]
 800c4ee:	6852      	ldr	r2, [r2, #4]
 800c4f0:	4610      	mov	r0, r2
 800c4f2:	4798      	blx	r3
 800c4f4:	6278      	str	r0, [r7, #36]	; 0x24
	uint32_t lower_bits = size & (aligment - 1);
 800c4f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4f8:	3b01      	subs	r3, #1
 800c4fa:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c4fc:	4013      	ands	r3, r2
 800c4fe:	623b      	str	r3, [r7, #32]
	uint32_t size_aligned = size - lower_bits;
 800c500:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c502:	6a3b      	ldr	r3, [r7, #32]
 800c504:	1ad3      	subs	r3, r2, r3
 800c506:	61fb      	str	r3, [r7, #28]
	if (size_aligned){
 800c508:	69fb      	ldr	r3, [r7, #28]
 800c50a:	2b00      	cmp	r3, #0
 800c50c:	d016      	beq.n	800c53c <btstack_tlv_flash_bank_read+0x64>
		self->hal_flash_bank_impl->read(self->hal_flash_bank_context, bank, offset, buffer, size_aligned);
 800c50e:	68fb      	ldr	r3, [r7, #12]
 800c510:	681b      	ldr	r3, [r3, #0]
 800c512:	68dc      	ldr	r4, [r3, #12]
 800c514:	68fb      	ldr	r3, [r7, #12]
 800c516:	6858      	ldr	r0, [r3, #4]
 800c518:	69fb      	ldr	r3, [r7, #28]
 800c51a:	9300      	str	r3, [sp, #0]
 800c51c:	683b      	ldr	r3, [r7, #0]
 800c51e:	687a      	ldr	r2, [r7, #4]
 800c520:	68b9      	ldr	r1, [r7, #8]
 800c522:	47a0      	blx	r4
		buffer += size_aligned;
 800c524:	683a      	ldr	r2, [r7, #0]
 800c526:	69fb      	ldr	r3, [r7, #28]
 800c528:	4413      	add	r3, r2
 800c52a:	603b      	str	r3, [r7, #0]
		offset += size_aligned;
 800c52c:	687a      	ldr	r2, [r7, #4]
 800c52e:	69fb      	ldr	r3, [r7, #28]
 800c530:	4413      	add	r3, r2
 800c532:	607b      	str	r3, [r7, #4]
		size   -= size_aligned;
 800c534:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c536:	69fb      	ldr	r3, [r7, #28]
 800c538:	1ad3      	subs	r3, r2, r3
 800c53a:	63bb      	str	r3, [r7, #56]	; 0x38
	}

	// read last part
	if (size == 0) return;
 800c53c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c53e:	2b00      	cmp	r3, #0
 800c540:	d01c      	beq.n	800c57c <btstack_tlv_flash_bank_read+0xa4>
	uint8_t aligment_block[BTSTACK_FLASH_ALIGNMENT_MAX];
	self->hal_flash_bank_impl->read(self->hal_flash_bank_context, bank, offset, aligment_block, aligment);
 800c542:	68fb      	ldr	r3, [r7, #12]
 800c544:	681b      	ldr	r3, [r3, #0]
 800c546:	68dc      	ldr	r4, [r3, #12]
 800c548:	68fb      	ldr	r3, [r7, #12]
 800c54a:	6858      	ldr	r0, [r3, #4]
 800c54c:	f107 0210 	add.w	r2, r7, #16
 800c550:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c552:	9300      	str	r3, [sp, #0]
 800c554:	4613      	mov	r3, r2
 800c556:	687a      	ldr	r2, [r7, #4]
 800c558:	68b9      	ldr	r1, [r7, #8]
 800c55a:	47a0      	blx	r4
	uint32_t bytes_to_copy = btstack_min(aligment - lower_bits, size);
 800c55c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800c55e:	6a3b      	ldr	r3, [r7, #32]
 800c560:	1ad3      	subs	r3, r2, r3
 800c562:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800c564:	4618      	mov	r0, r3
 800c566:	f002 fdd2 	bl	800f10e <btstack_min>
 800c56a:	61b8      	str	r0, [r7, #24]
	memcpy(buffer, aligment_block, bytes_to_copy);
 800c56c:	f107 0310 	add.w	r3, r7, #16
 800c570:	69ba      	ldr	r2, [r7, #24]
 800c572:	4619      	mov	r1, r3
 800c574:	6838      	ldr	r0, [r7, #0]
 800c576:	f01b fa80 	bl	8027a7a <memcpy>
 800c57a:	e000      	b.n	800c57e <btstack_tlv_flash_bank_read+0xa6>
	if (size == 0) return;
 800c57c:	bf00      	nop
}
 800c57e:	372c      	adds	r7, #44	; 0x2c
 800c580:	46bd      	mov	sp, r7
 800c582:	bd90      	pop	{r4, r7, pc}

0800c584 <btstack_tlv_flash_bank_write>:

static void btstack_tlv_flash_bank_write(btstack_tlv_flash_bank_t * self, int bank, uint32_t offset, const uint8_t * buffer, uint32_t size){
 800c584:	b590      	push	{r4, r7, lr}
 800c586:	b08d      	sub	sp, #52	; 0x34
 800c588:	af02      	add	r7, sp, #8
 800c58a:	60f8      	str	r0, [r7, #12]
 800c58c:	60b9      	str	r1, [r7, #8]
 800c58e:	607a      	str	r2, [r7, #4]
 800c590:	603b      	str	r3, [r7, #0]

	// write main data
	uint32_t aligment = self->hal_flash_bank_impl->get_alignment(self->hal_flash_bank_context);
 800c592:	68fb      	ldr	r3, [r7, #12]
 800c594:	681b      	ldr	r3, [r3, #0]
 800c596:	685b      	ldr	r3, [r3, #4]
 800c598:	68fa      	ldr	r2, [r7, #12]
 800c59a:	6852      	ldr	r2, [r2, #4]
 800c59c:	4610      	mov	r0, r2
 800c59e:	4798      	blx	r3
 800c5a0:	6278      	str	r0, [r7, #36]	; 0x24
	uint32_t lower_bits = size & (aligment - 1);
 800c5a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c5a4:	3b01      	subs	r3, #1
 800c5a6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c5a8:	4013      	ands	r3, r2
 800c5aa:	623b      	str	r3, [r7, #32]
	uint32_t size_aligned = size - lower_bits;
 800c5ac:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c5ae:	6a3b      	ldr	r3, [r7, #32]
 800c5b0:	1ad3      	subs	r3, r2, r3
 800c5b2:	61fb      	str	r3, [r7, #28]
	if (size_aligned){
 800c5b4:	69fb      	ldr	r3, [r7, #28]
 800c5b6:	2b00      	cmp	r3, #0
 800c5b8:	d016      	beq.n	800c5e8 <btstack_tlv_flash_bank_write+0x64>
		self->hal_flash_bank_impl->write(self->hal_flash_bank_context, bank, offset, buffer, size_aligned);
 800c5ba:	68fb      	ldr	r3, [r7, #12]
 800c5bc:	681b      	ldr	r3, [r3, #0]
 800c5be:	691c      	ldr	r4, [r3, #16]
 800c5c0:	68fb      	ldr	r3, [r7, #12]
 800c5c2:	6858      	ldr	r0, [r3, #4]
 800c5c4:	69fb      	ldr	r3, [r7, #28]
 800c5c6:	9300      	str	r3, [sp, #0]
 800c5c8:	683b      	ldr	r3, [r7, #0]
 800c5ca:	687a      	ldr	r2, [r7, #4]
 800c5cc:	68b9      	ldr	r1, [r7, #8]
 800c5ce:	47a0      	blx	r4
		buffer += size_aligned;
 800c5d0:	683a      	ldr	r2, [r7, #0]
 800c5d2:	69fb      	ldr	r3, [r7, #28]
 800c5d4:	4413      	add	r3, r2
 800c5d6:	603b      	str	r3, [r7, #0]
		offset += size_aligned;
 800c5d8:	687a      	ldr	r2, [r7, #4]
 800c5da:	69fb      	ldr	r3, [r7, #28]
 800c5dc:	4413      	add	r3, r2
 800c5de:	607b      	str	r3, [r7, #4]
		size   -= size_aligned;
 800c5e0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c5e2:	69fb      	ldr	r3, [r7, #28]
 800c5e4:	1ad3      	subs	r3, r2, r3
 800c5e6:	63bb      	str	r3, [r7, #56]	; 0x38
	}

	// write last part
	if (size == 0) return;
 800c5e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c5ea:	2b00      	cmp	r3, #0
 800c5ec:	d01b      	beq.n	800c626 <btstack_tlv_flash_bank_write+0xa2>
	uint8_t aligment_block[BTSTACK_FLASH_ALIGNMENT_MAX];
	memset(aligment_block, 0xff, aligment);
 800c5ee:	f107 0314 	add.w	r3, r7, #20
 800c5f2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800c5f4:	21ff      	movs	r1, #255	; 0xff
 800c5f6:	4618      	mov	r0, r3
 800c5f8:	f01b fa63 	bl	8027ac2 <memset>
	memcpy(aligment_block, buffer, lower_bits);
 800c5fc:	f107 0314 	add.w	r3, r7, #20
 800c600:	6a3a      	ldr	r2, [r7, #32]
 800c602:	6839      	ldr	r1, [r7, #0]
 800c604:	4618      	mov	r0, r3
 800c606:	f01b fa38 	bl	8027a7a <memcpy>
	self->hal_flash_bank_impl->write(self->hal_flash_bank_context, bank, offset, aligment_block, aligment);
 800c60a:	68fb      	ldr	r3, [r7, #12]
 800c60c:	681b      	ldr	r3, [r3, #0]
 800c60e:	691c      	ldr	r4, [r3, #16]
 800c610:	68fb      	ldr	r3, [r7, #12]
 800c612:	6858      	ldr	r0, [r3, #4]
 800c614:	f107 0214 	add.w	r2, r7, #20
 800c618:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c61a:	9300      	str	r3, [sp, #0]
 800c61c:	4613      	mov	r3, r2
 800c61e:	687a      	ldr	r2, [r7, #4]
 800c620:	68b9      	ldr	r1, [r7, #8]
 800c622:	47a0      	blx	r4
 800c624:	e000      	b.n	800c628 <btstack_tlv_flash_bank_write+0xa4>
	if (size == 0) return;
 800c626:	bf00      	nop
}
 800c628:	372c      	adds	r7, #44	; 0x2c
 800c62a:	46bd      	mov	sp, r7
 800c62c:	bd90      	pop	{r4, r7, pc}

0800c62e <btstack_tlv_flash_bank_iterator_fetch_tag_len>:


// iterator

static void btstack_tlv_flash_bank_iterator_fetch_tag_len(btstack_tlv_flash_bank_t * self, tlv_iterator_t * it){
 800c62e:	b580      	push	{r7, lr}
 800c630:	b086      	sub	sp, #24
 800c632:	af02      	add	r7, sp, #8
 800c634:	6078      	str	r0, [r7, #4]
 800c636:	6039      	str	r1, [r7, #0]
	uint8_t entry[8];
	btstack_tlv_flash_bank_read(self, it->bank, it->offset, entry, 8);
 800c638:	683b      	ldr	r3, [r7, #0]
 800c63a:	6819      	ldr	r1, [r3, #0]
 800c63c:	683b      	ldr	r3, [r7, #0]
 800c63e:	685a      	ldr	r2, [r3, #4]
 800c640:	f107 0008 	add.w	r0, r7, #8
 800c644:	2308      	movs	r3, #8
 800c646:	9300      	str	r3, [sp, #0]
 800c648:	4603      	mov	r3, r0
 800c64a:	6878      	ldr	r0, [r7, #4]
 800c64c:	f7ff ff44 	bl	800c4d8 <btstack_tlv_flash_bank_read>
	it->tag = big_endian_read_32(entry, 0);
 800c650:	f107 0308 	add.w	r3, r7, #8
 800c654:	2100      	movs	r1, #0
 800c656:	4618      	mov	r0, r3
 800c658:	f002 fc75 	bl	800ef46 <big_endian_read_32>
 800c65c:	4602      	mov	r2, r0
 800c65e:	683b      	ldr	r3, [r7, #0]
 800c660:	609a      	str	r2, [r3, #8]
	it->len = big_endian_read_32(entry, 4);
 800c662:	f107 0308 	add.w	r3, r7, #8
 800c666:	2104      	movs	r1, #4
 800c668:	4618      	mov	r0, r3
 800c66a:	f002 fc6c 	bl	800ef46 <big_endian_read_32>
 800c66e:	4602      	mov	r2, r0
 800c670:	683b      	ldr	r3, [r7, #0]
 800c672:	60da      	str	r2, [r3, #12]
	btstack_tlv_flash_bank_read(self, it->bank, it->offset + 8, (uint8_t *) &delete_tag, 4);
	if (delete_tag == 0){
		it->tag = 0;
	}
#endif
}
 800c674:	bf00      	nop
 800c676:	3710      	adds	r7, #16
 800c678:	46bd      	mov	sp, r7
 800c67a:	bd80      	pop	{r7, pc}

0800c67c <btstack_tlv_flash_bank_iterator_init>:

static void btstack_tlv_flash_bank_iterator_init(btstack_tlv_flash_bank_t * self, tlv_iterator_t * it, int bank){
 800c67c:	b580      	push	{r7, lr}
 800c67e:	b084      	sub	sp, #16
 800c680:	af00      	add	r7, sp, #0
 800c682:	60f8      	str	r0, [r7, #12]
 800c684:	60b9      	str	r1, [r7, #8]
 800c686:	607a      	str	r2, [r7, #4]
	memset(it, 0, sizeof(tlv_iterator_t));
 800c688:	2210      	movs	r2, #16
 800c68a:	2100      	movs	r1, #0
 800c68c:	68b8      	ldr	r0, [r7, #8]
 800c68e:	f01b fa18 	bl	8027ac2 <memset>
	it->bank = bank;
 800c692:	68bb      	ldr	r3, [r7, #8]
 800c694:	687a      	ldr	r2, [r7, #4]
 800c696:	601a      	str	r2, [r3, #0]
	it->offset = BTSTACK_TLV_HEADER_LEN;
 800c698:	68bb      	ldr	r3, [r7, #8]
 800c69a:	2208      	movs	r2, #8
 800c69c:	605a      	str	r2, [r3, #4]
	btstack_tlv_flash_bank_iterator_fetch_tag_len(self, it);
 800c69e:	68b9      	ldr	r1, [r7, #8]
 800c6a0:	68f8      	ldr	r0, [r7, #12]
 800c6a2:	f7ff ffc4 	bl	800c62e <btstack_tlv_flash_bank_iterator_fetch_tag_len>
}
 800c6a6:	bf00      	nop
 800c6a8:	3710      	adds	r7, #16
 800c6aa:	46bd      	mov	sp, r7
 800c6ac:	bd80      	pop	{r7, pc}

0800c6ae <btstack_tlv_flash_bank_iterator_has_next>:

static int btstack_tlv_flash_bank_iterator_has_next(btstack_tlv_flash_bank_t * self, tlv_iterator_t * it){
 800c6ae:	b480      	push	{r7}
 800c6b0:	b083      	sub	sp, #12
 800c6b2:	af00      	add	r7, sp, #0
 800c6b4:	6078      	str	r0, [r7, #4]
 800c6b6:	6039      	str	r1, [r7, #0]
	if (it->tag == 0xffffffff) return 0;
 800c6b8:	683b      	ldr	r3, [r7, #0]
 800c6ba:	689b      	ldr	r3, [r3, #8]
 800c6bc:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c6c0:	d101      	bne.n	800c6c6 <btstack_tlv_flash_bank_iterator_has_next+0x18>
 800c6c2:	2300      	movs	r3, #0
 800c6c4:	e000      	b.n	800c6c8 <btstack_tlv_flash_bank_iterator_has_next+0x1a>
	return 1;
 800c6c6:	2301      	movs	r3, #1
}
 800c6c8:	4618      	mov	r0, r3
 800c6ca:	370c      	adds	r7, #12
 800c6cc:	46bd      	mov	sp, r7
 800c6ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c6d2:	4770      	bx	lr

0800c6d4 <tlv_iterator_fetch_next>:

static void tlv_iterator_fetch_next(btstack_tlv_flash_bank_t * self, tlv_iterator_t * it){
 800c6d4:	b590      	push	{r4, r7, lr}
 800c6d6:	b083      	sub	sp, #12
 800c6d8:	af00      	add	r7, sp, #0
 800c6da:	6078      	str	r0, [r7, #4]
 800c6dc:	6039      	str	r1, [r7, #0]
	it->offset += 8 + btstack_tlv_flash_bank_align_size(self, it->len);
 800c6de:	683b      	ldr	r3, [r7, #0]
 800c6e0:	68db      	ldr	r3, [r3, #12]
 800c6e2:	4619      	mov	r1, r3
 800c6e4:	6878      	ldr	r0, [r7, #4]
 800c6e6:	f7ff fedf 	bl	800c4a8 <btstack_tlv_flash_bank_align_size>
 800c6ea:	4603      	mov	r3, r0
 800c6ec:	f103 0208 	add.w	r2, r3, #8
 800c6f0:	683b      	ldr	r3, [r7, #0]
 800c6f2:	685b      	ldr	r3, [r3, #4]
 800c6f4:	441a      	add	r2, r3
 800c6f6:	683b      	ldr	r3, [r7, #0]
 800c6f8:	605a      	str	r2, [r3, #4]
#ifdef ENABLE_TLV_FLASH_EXPLICIT_DELETE_FIELD
	// skip delete field
	it->offset += self->delete_tag_len;
#endif

	if (it->offset >= self->hal_flash_bank_impl->get_size(self->hal_flash_bank_context)) {
 800c6fa:	683b      	ldr	r3, [r7, #0]
 800c6fc:	685c      	ldr	r4, [r3, #4]
 800c6fe:	687b      	ldr	r3, [r7, #4]
 800c700:	681b      	ldr	r3, [r3, #0]
 800c702:	681b      	ldr	r3, [r3, #0]
 800c704:	687a      	ldr	r2, [r7, #4]
 800c706:	6852      	ldr	r2, [r2, #4]
 800c708:	4610      	mov	r0, r2
 800c70a:	4798      	blx	r3
 800c70c:	4603      	mov	r3, r0
 800c70e:	429c      	cmp	r4, r3
 800c710:	d307      	bcc.n	800c722 <tlv_iterator_fetch_next+0x4e>
		it->tag = 0xffffffff;
 800c712:	683b      	ldr	r3, [r7, #0]
 800c714:	f04f 32ff 	mov.w	r2, #4294967295
 800c718:	609a      	str	r2, [r3, #8]
		it->len = 0;
 800c71a:	683b      	ldr	r3, [r7, #0]
 800c71c:	2200      	movs	r2, #0
 800c71e:	60da      	str	r2, [r3, #12]
		return;
 800c720:	e003      	b.n	800c72a <tlv_iterator_fetch_next+0x56>
	}
	btstack_tlv_flash_bank_iterator_fetch_tag_len(self, it);
 800c722:	6839      	ldr	r1, [r7, #0]
 800c724:	6878      	ldr	r0, [r7, #4]
 800c726:	f7ff ff82 	bl	800c62e <btstack_tlv_flash_bank_iterator_fetch_tag_len>
}
 800c72a:	370c      	adds	r7, #12
 800c72c:	46bd      	mov	sp, r7
 800c72e:	bd90      	pop	{r4, r7, pc}

0800c730 <btstack_tlv_flash_bank_get_latest_bank>:

//

// check both banks for headers and pick the one with the higher epoch % 4
// @returns bank or -1 if something is invalid
static int btstack_tlv_flash_bank_get_latest_bank(btstack_tlv_flash_bank_t * self){
 800c730:	b580      	push	{r7, lr}
 800c732:	b08c      	sub	sp, #48	; 0x30
 800c734:	af02      	add	r7, sp, #8
 800c736:	6078      	str	r0, [r7, #4]
 	uint8_t header0[BTSTACK_TLV_HEADER_LEN];
 	uint8_t header1[BTSTACK_TLV_HEADER_LEN];
 	btstack_tlv_flash_bank_read(self, 0, 0, &header0[0], BTSTACK_TLV_HEADER_LEN);
 800c738:	f107 0210 	add.w	r2, r7, #16
 800c73c:	2308      	movs	r3, #8
 800c73e:	9300      	str	r3, [sp, #0]
 800c740:	4613      	mov	r3, r2
 800c742:	2200      	movs	r2, #0
 800c744:	2100      	movs	r1, #0
 800c746:	6878      	ldr	r0, [r7, #4]
 800c748:	f7ff fec6 	bl	800c4d8 <btstack_tlv_flash_bank_read>
 	btstack_tlv_flash_bank_read(self, 1, 0, &header1[0], BTSTACK_TLV_HEADER_LEN);
 800c74c:	f107 0208 	add.w	r2, r7, #8
 800c750:	2308      	movs	r3, #8
 800c752:	9300      	str	r3, [sp, #0]
 800c754:	4613      	mov	r3, r2
 800c756:	2200      	movs	r2, #0
 800c758:	2101      	movs	r1, #1
 800c75a:	6878      	ldr	r0, [r7, #4]
 800c75c:	f7ff febc 	bl	800c4d8 <btstack_tlv_flash_bank_read>
 	int valid0 = memcmp(header0, btstack_tlv_header_magic, BTSTACK_TLV_HEADER_LEN-1) == 0;
 800c760:	4b2b      	ldr	r3, [pc, #172]	; (800c810 <btstack_tlv_flash_bank_get_latest_bank+0xe0>)
 800c762:	6819      	ldr	r1, [r3, #0]
 800c764:	f107 0310 	add.w	r3, r7, #16
 800c768:	2207      	movs	r2, #7
 800c76a:	4618      	mov	r0, r3
 800c76c:	f01b f976 	bl	8027a5c <memcmp>
 800c770:	4603      	mov	r3, r0
 800c772:	2b00      	cmp	r3, #0
 800c774:	bf0c      	ite	eq
 800c776:	2301      	moveq	r3, #1
 800c778:	2300      	movne	r3, #0
 800c77a:	b2db      	uxtb	r3, r3
 800c77c:	627b      	str	r3, [r7, #36]	; 0x24
 	int valid1 = memcmp(header1, btstack_tlv_header_magic, BTSTACK_TLV_HEADER_LEN-1) == 0;
 800c77e:	4b24      	ldr	r3, [pc, #144]	; (800c810 <btstack_tlv_flash_bank_get_latest_bank+0xe0>)
 800c780:	6819      	ldr	r1, [r3, #0]
 800c782:	f107 0308 	add.w	r3, r7, #8
 800c786:	2207      	movs	r2, #7
 800c788:	4618      	mov	r0, r3
 800c78a:	f01b f967 	bl	8027a5c <memcmp>
 800c78e:	4603      	mov	r3, r0
 800c790:	2b00      	cmp	r3, #0
 800c792:	bf0c      	ite	eq
 800c794:	2301      	moveq	r3, #1
 800c796:	2300      	movne	r3, #0
 800c798:	b2db      	uxtb	r3, r3
 800c79a:	623b      	str	r3, [r7, #32]
	if (!valid0 && !valid1) return -1;
 800c79c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c79e:	2b00      	cmp	r3, #0
 800c7a0:	d105      	bne.n	800c7ae <btstack_tlv_flash_bank_get_latest_bank+0x7e>
 800c7a2:	6a3b      	ldr	r3, [r7, #32]
 800c7a4:	2b00      	cmp	r3, #0
 800c7a6:	d102      	bne.n	800c7ae <btstack_tlv_flash_bank_get_latest_bank+0x7e>
 800c7a8:	f04f 33ff 	mov.w	r3, #4294967295
 800c7ac:	e02b      	b.n	800c806 <btstack_tlv_flash_bank_get_latest_bank+0xd6>
	if ( valid0 && !valid1) return 0;
 800c7ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c7b0:	2b00      	cmp	r3, #0
 800c7b2:	d004      	beq.n	800c7be <btstack_tlv_flash_bank_get_latest_bank+0x8e>
 800c7b4:	6a3b      	ldr	r3, [r7, #32]
 800c7b6:	2b00      	cmp	r3, #0
 800c7b8:	d101      	bne.n	800c7be <btstack_tlv_flash_bank_get_latest_bank+0x8e>
 800c7ba:	2300      	movs	r3, #0
 800c7bc:	e023      	b.n	800c806 <btstack_tlv_flash_bank_get_latest_bank+0xd6>
	if (!valid0 &&  valid1) return 1;
 800c7be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c7c0:	2b00      	cmp	r3, #0
 800c7c2:	d104      	bne.n	800c7ce <btstack_tlv_flash_bank_get_latest_bank+0x9e>
 800c7c4:	6a3b      	ldr	r3, [r7, #32]
 800c7c6:	2b00      	cmp	r3, #0
 800c7c8:	d001      	beq.n	800c7ce <btstack_tlv_flash_bank_get_latest_bank+0x9e>
 800c7ca:	2301      	movs	r3, #1
 800c7cc:	e01b      	b.n	800c806 <btstack_tlv_flash_bank_get_latest_bank+0xd6>
	int epoch0 = header0[BTSTACK_TLV_HEADER_LEN-1] & 0x03;
 800c7ce:	7dfb      	ldrb	r3, [r7, #23]
 800c7d0:	f003 0303 	and.w	r3, r3, #3
 800c7d4:	61fb      	str	r3, [r7, #28]
	int epoch1 = header1[BTSTACK_TLV_HEADER_LEN-1] & 0x03;
 800c7d6:	7bfb      	ldrb	r3, [r7, #15]
 800c7d8:	f003 0303 	and.w	r3, r3, #3
 800c7dc:	61bb      	str	r3, [r7, #24]
	if (epoch0 == ((epoch1 + 1) & 0x03)) return 0;
 800c7de:	69bb      	ldr	r3, [r7, #24]
 800c7e0:	3301      	adds	r3, #1
 800c7e2:	f003 0303 	and.w	r3, r3, #3
 800c7e6:	69fa      	ldr	r2, [r7, #28]
 800c7e8:	429a      	cmp	r2, r3
 800c7ea:	d101      	bne.n	800c7f0 <btstack_tlv_flash_bank_get_latest_bank+0xc0>
 800c7ec:	2300      	movs	r3, #0
 800c7ee:	e00a      	b.n	800c806 <btstack_tlv_flash_bank_get_latest_bank+0xd6>
	if (epoch1 == ((epoch0 + 1) & 0x03)) return 1;
 800c7f0:	69fb      	ldr	r3, [r7, #28]
 800c7f2:	3301      	adds	r3, #1
 800c7f4:	f003 0303 	and.w	r3, r3, #3
 800c7f8:	69ba      	ldr	r2, [r7, #24]
 800c7fa:	429a      	cmp	r2, r3
 800c7fc:	d101      	bne.n	800c802 <btstack_tlv_flash_bank_get_latest_bank+0xd2>
 800c7fe:	2301      	movs	r3, #1
 800c800:	e001      	b.n	800c806 <btstack_tlv_flash_bank_get_latest_bank+0xd6>
	return -1;	// invalid, must not happen
 800c802:	f04f 33ff 	mov.w	r3, #4294967295
}
 800c806:	4618      	mov	r0, r3
 800c808:	3728      	adds	r7, #40	; 0x28
 800c80a:	46bd      	mov	sp, r7
 800c80c:	bd80      	pop	{r7, pc}
 800c80e:	bf00      	nop
 800c810:	20000020 	.word	0x20000020

0800c814 <btstack_tlv_flash_bank_write_header>:

static void btstack_tlv_flash_bank_write_header(btstack_tlv_flash_bank_t * self, int bank, int epoch){
 800c814:	b580      	push	{r7, lr}
 800c816:	b088      	sub	sp, #32
 800c818:	af02      	add	r7, sp, #8
 800c81a:	60f8      	str	r0, [r7, #12]
 800c81c:	60b9      	str	r1, [r7, #8]
 800c81e:	607a      	str	r2, [r7, #4]
	uint8_t header[BTSTACK_TLV_HEADER_LEN];
	memcpy(&header[0], btstack_tlv_header_magic, BTSTACK_TLV_HEADER_LEN-1);
 800c820:	4b0c      	ldr	r3, [pc, #48]	; (800c854 <btstack_tlv_flash_bank_write_header+0x40>)
 800c822:	6819      	ldr	r1, [r3, #0]
 800c824:	f107 0310 	add.w	r3, r7, #16
 800c828:	2207      	movs	r2, #7
 800c82a:	4618      	mov	r0, r3
 800c82c:	f01b f925 	bl	8027a7a <memcpy>
	header[BTSTACK_TLV_HEADER_LEN-1] = epoch;
 800c830:	687b      	ldr	r3, [r7, #4]
 800c832:	b2db      	uxtb	r3, r3
 800c834:	75fb      	strb	r3, [r7, #23]
	btstack_tlv_flash_bank_write(self, bank, 0, header, BTSTACK_TLV_HEADER_LEN);
 800c836:	f107 0210 	add.w	r2, r7, #16
 800c83a:	2308      	movs	r3, #8
 800c83c:	9300      	str	r3, [sp, #0]
 800c83e:	4613      	mov	r3, r2
 800c840:	2200      	movs	r2, #0
 800c842:	68b9      	ldr	r1, [r7, #8]
 800c844:	68f8      	ldr	r0, [r7, #12]
 800c846:	f7ff fe9d 	bl	800c584 <btstack_tlv_flash_bank_write>
}
 800c84a:	bf00      	nop
 800c84c:	3718      	adds	r7, #24
 800c84e:	46bd      	mov	sp, r7
 800c850:	bd80      	pop	{r7, pc}
 800c852:	bf00      	nop
 800c854:	20000020 	.word	0x20000020

0800c858 <btstack_tlv_flash_bank_test_erased>:

/**
 * @brief Check if erased from offset
 */
static int btstack_tlv_flash_bank_test_erased(btstack_tlv_flash_bank_t * self, int bank, uint32_t offset){
 800c858:	b580      	push	{r7, lr}
 800c85a:	b090      	sub	sp, #64	; 0x40
 800c85c:	af02      	add	r7, sp, #8
 800c85e:	60f8      	str	r0, [r7, #12]
 800c860:	60b9      	str	r1, [r7, #8]
 800c862:	607a      	str	r2, [r7, #4]
	log_info("test erased: bank %u, offset %u", bank, (unsigned int) offset);
 800c864:	687b      	ldr	r3, [r7, #4]
 800c866:	9301      	str	r3, [sp, #4]
 800c868:	68bb      	ldr	r3, [r7, #8]
 800c86a:	9300      	str	r3, [sp, #0]
 800c86c:	23d3      	movs	r3, #211	; 0xd3
 800c86e:	4a28      	ldr	r2, [pc, #160]	; (800c910 <btstack_tlv_flash_bank_test_erased+0xb8>)
 800c870:	4928      	ldr	r1, [pc, #160]	; (800c914 <btstack_tlv_flash_bank_test_erased+0xbc>)
 800c872:	2001      	movs	r0, #1
 800c874:	f00a fde4 	bl	8017440 <hci_dump_log>
	uint32_t size = self->hal_flash_bank_impl->get_size(self->hal_flash_bank_context);
 800c878:	68fb      	ldr	r3, [r7, #12]
 800c87a:	681b      	ldr	r3, [r3, #0]
 800c87c:	681b      	ldr	r3, [r3, #0]
 800c87e:	68fa      	ldr	r2, [r7, #12]
 800c880:	6852      	ldr	r2, [r2, #4]
 800c882:	4610      	mov	r0, r2
 800c884:	4798      	blx	r3
 800c886:	6378      	str	r0, [r7, #52]	; 0x34
	uint8_t buffer[16];
	uint8_t empty16[16];
	memset(empty16, 0xff, sizeof(empty16));
 800c888:	f107 0310 	add.w	r3, r7, #16
 800c88c:	2210      	movs	r2, #16
 800c88e:	21ff      	movs	r1, #255	; 0xff
 800c890:	4618      	mov	r0, r3
 800c892:	f01b f916 	bl	8027ac2 <memset>
	while (offset < size){
 800c896:	e031      	b.n	800c8fc <btstack_tlv_flash_bank_test_erased+0xa4>
		uint32_t copy_size = (offset + sizeof(empty16) < size) ? sizeof(empty16) : (size - offset); 
 800c898:	687b      	ldr	r3, [r7, #4]
 800c89a:	3310      	adds	r3, #16
 800c89c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800c89e:	429a      	cmp	r2, r3
 800c8a0:	d803      	bhi.n	800c8aa <btstack_tlv_flash_bank_test_erased+0x52>
 800c8a2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800c8a4:	687b      	ldr	r3, [r7, #4]
 800c8a6:	1ad3      	subs	r3, r2, r3
 800c8a8:	e000      	b.n	800c8ac <btstack_tlv_flash_bank_test_erased+0x54>
 800c8aa:	2310      	movs	r3, #16
 800c8ac:	633b      	str	r3, [r7, #48]	; 0x30
		btstack_tlv_flash_bank_read(self, bank, offset, buffer, copy_size);
 800c8ae:	f107 0220 	add.w	r2, r7, #32
 800c8b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c8b4:	9300      	str	r3, [sp, #0]
 800c8b6:	4613      	mov	r3, r2
 800c8b8:	687a      	ldr	r2, [r7, #4]
 800c8ba:	68b9      	ldr	r1, [r7, #8]
 800c8bc:	68f8      	ldr	r0, [r7, #12]
 800c8be:	f7ff fe0b 	bl	800c4d8 <btstack_tlv_flash_bank_read>
		if (memcmp(buffer, empty16, copy_size)) {
 800c8c2:	f107 0110 	add.w	r1, r7, #16
 800c8c6:	f107 0320 	add.w	r3, r7, #32
 800c8ca:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800c8cc:	4618      	mov	r0, r3
 800c8ce:	f01b f8c5 	bl	8027a5c <memcmp>
 800c8d2:	4603      	mov	r3, r0
 800c8d4:	2b00      	cmp	r3, #0
 800c8d6:	d00d      	beq.n	800c8f4 <btstack_tlv_flash_bank_test_erased+0x9c>
			log_info("not erased %x - %x", (unsigned int) offset, (unsigned int) (offset + copy_size));
 800c8d8:	687a      	ldr	r2, [r7, #4]
 800c8da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c8dc:	4413      	add	r3, r2
 800c8de:	9301      	str	r3, [sp, #4]
 800c8e0:	687b      	ldr	r3, [r7, #4]
 800c8e2:	9300      	str	r3, [sp, #0]
 800c8e4:	23dc      	movs	r3, #220	; 0xdc
 800c8e6:	4a0a      	ldr	r2, [pc, #40]	; (800c910 <btstack_tlv_flash_bank_test_erased+0xb8>)
 800c8e8:	490b      	ldr	r1, [pc, #44]	; (800c918 <btstack_tlv_flash_bank_test_erased+0xc0>)
 800c8ea:	2001      	movs	r0, #1
 800c8ec:	f00a fda8 	bl	8017440 <hci_dump_log>
			return 0;
 800c8f0:	2300      	movs	r3, #0
 800c8f2:	e008      	b.n	800c906 <btstack_tlv_flash_bank_test_erased+0xae>
		}
		offset += copy_size;
 800c8f4:	687a      	ldr	r2, [r7, #4]
 800c8f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c8f8:	4413      	add	r3, r2
 800c8fa:	607b      	str	r3, [r7, #4]
	while (offset < size){
 800c8fc:	687a      	ldr	r2, [r7, #4]
 800c8fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c900:	429a      	cmp	r2, r3
 800c902:	d3c9      	bcc.n	800c898 <btstack_tlv_flash_bank_test_erased+0x40>
	}
	return 1;
 800c904:	2301      	movs	r3, #1
}
 800c906:	4618      	mov	r0, r3
 800c908:	3738      	adds	r7, #56	; 0x38
 800c90a:	46bd      	mov	sp, r7
 800c90c:	bd80      	pop	{r7, pc}
 800c90e:	bf00      	nop
 800c910:	08028d34 	.word	0x08028d34
 800c914:	08028d50 	.word	0x08028d50
 800c918:	08028d78 	.word	0x08028d78

0800c91c <btstack_tlv_flash_bank_erase_bank>:

/** 
 * @brief erase bank (only if not already erased)
 */
static void btstack_tlv_flash_bank_erase_bank(btstack_tlv_flash_bank_t * self, int bank){
 800c91c:	b580      	push	{r7, lr}
 800c91e:	b084      	sub	sp, #16
 800c920:	af02      	add	r7, sp, #8
 800c922:	6078      	str	r0, [r7, #4]
 800c924:	6039      	str	r1, [r7, #0]
	if (btstack_tlv_flash_bank_test_erased(self, bank, 0)){
 800c926:	2200      	movs	r2, #0
 800c928:	6839      	ldr	r1, [r7, #0]
 800c92a:	6878      	ldr	r0, [r7, #4]
 800c92c:	f7ff ff94 	bl	800c858 <btstack_tlv_flash_bank_test_erased>
 800c930:	4603      	mov	r3, r0
 800c932:	2b00      	cmp	r3, #0
 800c934:	d008      	beq.n	800c948 <btstack_tlv_flash_bank_erase_bank+0x2c>
		log_info("bank %u already erased", bank);
 800c936:	683b      	ldr	r3, [r7, #0]
 800c938:	9300      	str	r3, [sp, #0]
 800c93a:	23e9      	movs	r3, #233	; 0xe9
 800c93c:	4a0c      	ldr	r2, [pc, #48]	; (800c970 <btstack_tlv_flash_bank_erase_bank+0x54>)
 800c93e:	490d      	ldr	r1, [pc, #52]	; (800c974 <btstack_tlv_flash_bank_erase_bank+0x58>)
 800c940:	2001      	movs	r0, #1
 800c942:	f00a fd7d 	bl	8017440 <hci_dump_log>
	} else {
		log_info("bank %u not empty, erase bank", bank);
		self->hal_flash_bank_impl->erase(self->hal_flash_bank_context, bank);
	}
}
 800c946:	e00f      	b.n	800c968 <btstack_tlv_flash_bank_erase_bank+0x4c>
		log_info("bank %u not empty, erase bank", bank);
 800c948:	683b      	ldr	r3, [r7, #0]
 800c94a:	9300      	str	r3, [sp, #0]
 800c94c:	23eb      	movs	r3, #235	; 0xeb
 800c94e:	4a08      	ldr	r2, [pc, #32]	; (800c970 <btstack_tlv_flash_bank_erase_bank+0x54>)
 800c950:	4909      	ldr	r1, [pc, #36]	; (800c978 <btstack_tlv_flash_bank_erase_bank+0x5c>)
 800c952:	2001      	movs	r0, #1
 800c954:	f00a fd74 	bl	8017440 <hci_dump_log>
		self->hal_flash_bank_impl->erase(self->hal_flash_bank_context, bank);
 800c958:	687b      	ldr	r3, [r7, #4]
 800c95a:	681b      	ldr	r3, [r3, #0]
 800c95c:	689b      	ldr	r3, [r3, #8]
 800c95e:	687a      	ldr	r2, [r7, #4]
 800c960:	6852      	ldr	r2, [r2, #4]
 800c962:	6839      	ldr	r1, [r7, #0]
 800c964:	4610      	mov	r0, r2
 800c966:	4798      	blx	r3
}
 800c968:	bf00      	nop
 800c96a:	3708      	adds	r7, #8
 800c96c:	46bd      	mov	sp, r7
 800c96e:	bd80      	pop	{r7, pc}
 800c970:	08028d34 	.word	0x08028d34
 800c974:	08028d94 	.word	0x08028d94
 800c978:	08028db4 	.word	0x08028db4

0800c97c <btstack_tlv_flash_bank_migrate>:

static void btstack_tlv_flash_bank_migrate(btstack_tlv_flash_bank_t * self){
 800c97c:	b580      	push	{r7, lr}
 800c97e:	b09c      	sub	sp, #112	; 0x70
 800c980:	af04      	add	r7, sp, #16
 800c982:	6078      	str	r0, [r7, #4]

	int next_bank = 1 - self->current_bank;
 800c984:	687b      	ldr	r3, [r7, #4]
 800c986:	689b      	ldr	r3, [r3, #8]
 800c988:	f1c3 0301 	rsb	r3, r3, #1
 800c98c:	653b      	str	r3, [r7, #80]	; 0x50
	log_info("migrate bank %u -> bank %u", self->current_bank, next_bank);
 800c98e:	687b      	ldr	r3, [r7, #4]
 800c990:	689b      	ldr	r3, [r3, #8]
 800c992:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800c994:	9201      	str	r2, [sp, #4]
 800c996:	9300      	str	r3, [sp, #0]
 800c998:	23f3      	movs	r3, #243	; 0xf3
 800c99a:	4a50      	ldr	r2, [pc, #320]	; (800cadc <btstack_tlv_flash_bank_migrate+0x160>)
 800c99c:	4950      	ldr	r1, [pc, #320]	; (800cae0 <btstack_tlv_flash_bank_migrate+0x164>)
 800c99e:	2001      	movs	r0, #1
 800c9a0:	f00a fd4e 	bl	8017440 <hci_dump_log>
	// erase bank (if needed)
	btstack_tlv_flash_bank_erase_bank(self, next_bank);
 800c9a4:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800c9a6:	6878      	ldr	r0, [r7, #4]
 800c9a8:	f7ff ffb8 	bl	800c91c <btstack_tlv_flash_bank_erase_bank>
	int next_write_pos = 8;
 800c9ac:	2308      	movs	r3, #8
 800c9ae:	65fb      	str	r3, [r7, #92]	; 0x5c

	tlv_iterator_t it;
	btstack_tlv_flash_bank_iterator_init(self, &it, self->current_bank);
 800c9b0:	687b      	ldr	r3, [r7, #4]
 800c9b2:	689a      	ldr	r2, [r3, #8]
 800c9b4:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800c9b8:	4619      	mov	r1, r3
 800c9ba:	6878      	ldr	r0, [r7, #4]
 800c9bc:	f7ff fe5e 	bl	800c67c <btstack_tlv_flash_bank_iterator_init>
	while (btstack_tlv_flash_bank_iterator_has_next(self, &it)){
 800c9c0:	e064      	b.n	800ca8c <btstack_tlv_flash_bank_migrate+0x110>
		// skip deleted entries
		if (it.tag) {
 800c9c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c9c4:	2b00      	cmp	r3, #0
 800c9c6:	d05b      	beq.n	800ca80 <btstack_tlv_flash_bank_migrate+0x104>
			uint32_t tag_len = it.len;
 800c9c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c9ca:	64fb      	str	r3, [r7, #76]	; 0x4c
			uint32_t tag_index = it.offset;
 800c9cc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c9ce:	65bb      	str	r3, [r7, #88]	; 0x58

			log_info("migrate pos %u, tag '%x' len %u -> new pos %u",
 800c9d0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c9d2:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800c9d4:	9203      	str	r2, [sp, #12]
 800c9d6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800c9d8:	9202      	str	r2, [sp, #8]
 800c9da:	9301      	str	r3, [sp, #4]
 800c9dc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800c9de:	9300      	str	r3, [sp, #0]
 800c9e0:	f240 1301 	movw	r3, #257	; 0x101
 800c9e4:	4a3d      	ldr	r2, [pc, #244]	; (800cadc <btstack_tlv_flash_bank_migrate+0x160>)
 800c9e6:	493f      	ldr	r1, [pc, #252]	; (800cae4 <btstack_tlv_flash_bank_migrate+0x168>)
 800c9e8:	2001      	movs	r0, #1
 800c9ea:	f00a fd29 	bl	8017440 <hci_dump_log>
                (unsigned  int)  tag_index, (unsigned int)  it.tag, (unsigned int) tag_len, next_write_pos);

			// copy header
			uint8_t header_buffer[8];
			btstack_tlv_flash_bank_read(self, self->current_bank, tag_index,      header_buffer, 8);
 800c9ee:	687b      	ldr	r3, [r7, #4]
 800c9f0:	6899      	ldr	r1, [r3, #8]
 800c9f2:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800c9f6:	2308      	movs	r3, #8
 800c9f8:	9300      	str	r3, [sp, #0]
 800c9fa:	4613      	mov	r3, r2
 800c9fc:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800c9fe:	6878      	ldr	r0, [r7, #4]
 800ca00:	f7ff fd6a 	bl	800c4d8 <btstack_tlv_flash_bank_read>
			btstack_tlv_flash_bank_write(self, next_bank,         next_write_pos, header_buffer, 8);
 800ca04:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800ca06:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 800ca0a:	2308      	movs	r3, #8
 800ca0c:	9300      	str	r3, [sp, #0]
 800ca0e:	460b      	mov	r3, r1
 800ca10:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800ca12:	6878      	ldr	r0, [r7, #4]
 800ca14:	f7ff fdb6 	bl	800c584 <btstack_tlv_flash_bank_write>
			tag_index      += 8;
 800ca18:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800ca1a:	3308      	adds	r3, #8
 800ca1c:	65bb      	str	r3, [r7, #88]	; 0x58
			next_write_pos += 8;
 800ca1e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ca20:	3308      	adds	r3, #8
 800ca22:	65fb      	str	r3, [r7, #92]	; 0x5c
			// skip delete field
			tag_index      += self->delete_tag_len;
			next_write_pos += self->delete_tag_len;
#endif
			// copy value
			int bytes_to_copy = tag_len;
 800ca24:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ca26:	657b      	str	r3, [r7, #84]	; 0x54
			uint8_t copy_buffer[32];
			while (bytes_to_copy){
 800ca28:	e027      	b.n	800ca7a <btstack_tlv_flash_bank_migrate+0xfe>
				int bytes_this_iteration = btstack_min(bytes_to_copy, sizeof(copy_buffer));
 800ca2a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ca2c:	2120      	movs	r1, #32
 800ca2e:	4618      	mov	r0, r3
 800ca30:	f002 fb6d 	bl	800f10e <btstack_min>
 800ca34:	4603      	mov	r3, r0
 800ca36:	64bb      	str	r3, [r7, #72]	; 0x48
				btstack_tlv_flash_bank_read(self, self->current_bank, tag_index, copy_buffer, bytes_this_iteration);
 800ca38:	687b      	ldr	r3, [r7, #4]
 800ca3a:	6899      	ldr	r1, [r3, #8]
 800ca3c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ca3e:	f107 020c 	add.w	r2, r7, #12
 800ca42:	9300      	str	r3, [sp, #0]
 800ca44:	4613      	mov	r3, r2
 800ca46:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800ca48:	6878      	ldr	r0, [r7, #4]
 800ca4a:	f7ff fd45 	bl	800c4d8 <btstack_tlv_flash_bank_read>
				btstack_tlv_flash_bank_write(self, next_bank, next_write_pos, copy_buffer, bytes_this_iteration);
 800ca4e:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800ca50:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ca52:	f107 010c 	add.w	r1, r7, #12
 800ca56:	9300      	str	r3, [sp, #0]
 800ca58:	460b      	mov	r3, r1
 800ca5a:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800ca5c:	6878      	ldr	r0, [r7, #4]
 800ca5e:	f7ff fd91 	bl	800c584 <btstack_tlv_flash_bank_write>
				tag_index      += bytes_this_iteration;
 800ca62:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ca64:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800ca66:	4413      	add	r3, r2
 800ca68:	65bb      	str	r3, [r7, #88]	; 0x58
				next_write_pos += bytes_this_iteration;
 800ca6a:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800ca6c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ca6e:	4413      	add	r3, r2
 800ca70:	65fb      	str	r3, [r7, #92]	; 0x5c
				bytes_to_copy  -= bytes_this_iteration;
 800ca72:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800ca74:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ca76:	1ad3      	subs	r3, r2, r3
 800ca78:	657b      	str	r3, [r7, #84]	; 0x54
			while (bytes_to_copy){
 800ca7a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ca7c:	2b00      	cmp	r3, #0
 800ca7e:	d1d4      	bne.n	800ca2a <btstack_tlv_flash_bank_migrate+0xae>
			}
		}
		tlv_iterator_fetch_next(self, &it);
 800ca80:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800ca84:	4619      	mov	r1, r3
 800ca86:	6878      	ldr	r0, [r7, #4]
 800ca88:	f7ff fe24 	bl	800c6d4 <tlv_iterator_fetch_next>
	while (btstack_tlv_flash_bank_iterator_has_next(self, &it)){
 800ca8c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800ca90:	4619      	mov	r1, r3
 800ca92:	6878      	ldr	r0, [r7, #4]
 800ca94:	f7ff fe0b 	bl	800c6ae <btstack_tlv_flash_bank_iterator_has_next>
 800ca98:	4603      	mov	r3, r0
 800ca9a:	2b00      	cmp	r3, #0
 800ca9c:	d191      	bne.n	800c9c2 <btstack_tlv_flash_bank_migrate+0x46>
	}

	// prepare new one
	uint8_t epoch_buffer;
	btstack_tlv_flash_bank_read(self, self->current_bank, BTSTACK_TLV_HEADER_LEN-1, &epoch_buffer, 1);
 800ca9e:	687b      	ldr	r3, [r7, #4]
 800caa0:	6899      	ldr	r1, [r3, #8]
 800caa2:	f107 0237 	add.w	r2, r7, #55	; 0x37
 800caa6:	2301      	movs	r3, #1
 800caa8:	9300      	str	r3, [sp, #0]
 800caaa:	4613      	mov	r3, r2
 800caac:	2207      	movs	r2, #7
 800caae:	6878      	ldr	r0, [r7, #4]
 800cab0:	f7ff fd12 	bl	800c4d8 <btstack_tlv_flash_bank_read>
	btstack_tlv_flash_bank_write_header(self, next_bank, (epoch_buffer + 1) & 3);
 800cab4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800cab8:	3301      	adds	r3, #1
 800caba:	f003 0303 	and.w	r3, r3, #3
 800cabe:	461a      	mov	r2, r3
 800cac0:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800cac2:	6878      	ldr	r0, [r7, #4]
 800cac4:	f7ff fea6 	bl	800c814 <btstack_tlv_flash_bank_write_header>
	self->current_bank = next_bank;
 800cac8:	687b      	ldr	r3, [r7, #4]
 800caca:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800cacc:	609a      	str	r2, [r3, #8]
	self->write_offset = next_write_pos;
 800cace:	687b      	ldr	r3, [r7, #4]
 800cad0:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800cad2:	60da      	str	r2, [r3, #12]
}
 800cad4:	bf00      	nop
 800cad6:	3760      	adds	r7, #96	; 0x60
 800cad8:	46bd      	mov	sp, r7
 800cada:	bd80      	pop	{r7, pc}
 800cadc:	08028d34 	.word	0x08028d34
 800cae0:	08028ddc 	.word	0x08028ddc
 800cae4:	08028e00 	.word	0x08028e00

0800cae8 <btstack_tlv_flash_bank_delete_tag_until_offset>:

static void btstack_tlv_flash_bank_delete_tag_until_offset(btstack_tlv_flash_bank_t * self, uint32_t tag, uint32_t offset){
 800cae8:	b580      	push	{r7, lr}
 800caea:	b08c      	sub	sp, #48	; 0x30
 800caec:	af02      	add	r7, sp, #8
 800caee:	60f8      	str	r0, [r7, #12]
 800caf0:	60b9      	str	r1, [r7, #8]
 800caf2:	607a      	str	r2, [r7, #4]
	tlv_iterator_t it;
	btstack_tlv_flash_bank_iterator_init(self, &it, self->current_bank);
 800caf4:	68fb      	ldr	r3, [r7, #12]
 800caf6:	689a      	ldr	r2, [r3, #8]
 800caf8:	f107 0318 	add.w	r3, r7, #24
 800cafc:	4619      	mov	r1, r3
 800cafe:	68f8      	ldr	r0, [r7, #12]
 800cb00:	f7ff fdbc 	bl	800c67c <btstack_tlv_flash_bank_iterator_init>
	while (btstack_tlv_flash_bank_iterator_has_next(self, &it) && it.offset < offset){
 800cb04:	e021      	b.n	800cb4a <btstack_tlv_flash_bank_delete_tag_until_offset+0x62>
		if (it.tag == tag){
 800cb06:	6a3b      	ldr	r3, [r7, #32]
 800cb08:	68ba      	ldr	r2, [r7, #8]
 800cb0a:	429a      	cmp	r2, r3
 800cb0c:	d117      	bne.n	800cb3e <btstack_tlv_flash_bank_delete_tag_until_offset+0x56>
			log_info("Erase tag '%x' at position %u", (unsigned int) tag, (unsigned int) it.offset);
 800cb0e:	69fb      	ldr	r3, [r7, #28]
 800cb10:	9301      	str	r3, [sp, #4]
 800cb12:	68bb      	ldr	r3, [r7, #8]
 800cb14:	9300      	str	r3, [sp, #0]
 800cb16:	f240 132b 	movw	r3, #299	; 0x12b
 800cb1a:	4a14      	ldr	r2, [pc, #80]	; (800cb6c <btstack_tlv_flash_bank_delete_tag_until_offset+0x84>)
 800cb1c:	4914      	ldr	r1, [pc, #80]	; (800cb70 <btstack_tlv_flash_bank_delete_tag_until_offset+0x88>)
 800cb1e:	2001      	movs	r0, #1
 800cb20:	f00a fc8e 	bl	8017440 <hci_dump_log>

			// mark entry as invalid
			uint32_t zero_value = 0;
 800cb24:	2300      	movs	r3, #0
 800cb26:	617b      	str	r3, [r7, #20]
#ifdef ENABLE_TLV_FLASH_EXPLICIT_DELETE_FIELD
			// write delete field at offset 8
			btstack_tlv_flash_bank_write(self, self->current_bank, it.offset+8, (uint8_t*) &zero_value, sizeof(zero_value));
#else
			// overwrite tag with zero value
			btstack_tlv_flash_bank_write(self, self->current_bank, it.offset, (uint8_t*) &zero_value, sizeof(zero_value));
 800cb28:	68fb      	ldr	r3, [r7, #12]
 800cb2a:	6899      	ldr	r1, [r3, #8]
 800cb2c:	69fa      	ldr	r2, [r7, #28]
 800cb2e:	f107 0014 	add.w	r0, r7, #20
 800cb32:	2304      	movs	r3, #4
 800cb34:	9300      	str	r3, [sp, #0]
 800cb36:	4603      	mov	r3, r0
 800cb38:	68f8      	ldr	r0, [r7, #12]
 800cb3a:	f7ff fd23 	bl	800c584 <btstack_tlv_flash_bank_write>
#endif

		}
		tlv_iterator_fetch_next(self, &it);
 800cb3e:	f107 0318 	add.w	r3, r7, #24
 800cb42:	4619      	mov	r1, r3
 800cb44:	68f8      	ldr	r0, [r7, #12]
 800cb46:	f7ff fdc5 	bl	800c6d4 <tlv_iterator_fetch_next>
	while (btstack_tlv_flash_bank_iterator_has_next(self, &it) && it.offset < offset){
 800cb4a:	f107 0318 	add.w	r3, r7, #24
 800cb4e:	4619      	mov	r1, r3
 800cb50:	68f8      	ldr	r0, [r7, #12]
 800cb52:	f7ff fdac 	bl	800c6ae <btstack_tlv_flash_bank_iterator_has_next>
 800cb56:	4603      	mov	r3, r0
 800cb58:	2b00      	cmp	r3, #0
 800cb5a:	d003      	beq.n	800cb64 <btstack_tlv_flash_bank_delete_tag_until_offset+0x7c>
 800cb5c:	69fb      	ldr	r3, [r7, #28]
 800cb5e:	687a      	ldr	r2, [r7, #4]
 800cb60:	429a      	cmp	r2, r3
 800cb62:	d8d0      	bhi.n	800cb06 <btstack_tlv_flash_bank_delete_tag_until_offset+0x1e>
	}
}
 800cb64:	bf00      	nop
 800cb66:	3728      	adds	r7, #40	; 0x28
 800cb68:	46bd      	mov	sp, r7
 800cb6a:	bd80      	pop	{r7, pc}
 800cb6c:	08028d34 	.word	0x08028d34
 800cb70:	08028e38 	.word	0x08028e38

0800cb74 <btstack_tlv_flash_bank_get_tag>:
 * @param tag
 * @param buffer
 * @param buffer_size
 * @returns size of value
 */
static int btstack_tlv_flash_bank_get_tag(void * context, uint32_t tag, uint8_t * buffer, uint32_t buffer_size){
 800cb74:	b580      	push	{r7, lr}
 800cb76:	b090      	sub	sp, #64	; 0x40
 800cb78:	af02      	add	r7, sp, #8
 800cb7a:	60f8      	str	r0, [r7, #12]
 800cb7c:	60b9      	str	r1, [r7, #8]
 800cb7e:	607a      	str	r2, [r7, #4]
 800cb80:	603b      	str	r3, [r7, #0]

	btstack_tlv_flash_bank_t * self = (btstack_tlv_flash_bank_t *) context;
 800cb82:	68fb      	ldr	r3, [r7, #12]
 800cb84:	62fb      	str	r3, [r7, #44]	; 0x2c

	uint32_t tag_index = 0;
 800cb86:	2300      	movs	r3, #0
 800cb88:	637b      	str	r3, [r7, #52]	; 0x34
	uint32_t tag_len   = 0;
 800cb8a:	2300      	movs	r3, #0
 800cb8c:	633b      	str	r3, [r7, #48]	; 0x30
	tlv_iterator_t it;
	btstack_tlv_flash_bank_iterator_init(self, &it, self->current_bank);
 800cb8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cb90:	689a      	ldr	r2, [r3, #8]
 800cb92:	f107 0314 	add.w	r3, r7, #20
 800cb96:	4619      	mov	r1, r3
 800cb98:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800cb9a:	f7ff fd6f 	bl	800c67c <btstack_tlv_flash_bank_iterator_init>
	while (btstack_tlv_flash_bank_iterator_has_next(self, &it)){
 800cb9e:	e019      	b.n	800cbd4 <btstack_tlv_flash_bank_get_tag+0x60>
		if (it.tag == tag){
 800cba0:	69fb      	ldr	r3, [r7, #28]
 800cba2:	68ba      	ldr	r2, [r7, #8]
 800cba4:	429a      	cmp	r2, r3
 800cba6:	d10f      	bne.n	800cbc8 <btstack_tlv_flash_bank_get_tag+0x54>
			log_info("Found tag '%x' at position %u", (unsigned int) tag, (unsigned int) it.offset);
 800cba8:	69bb      	ldr	r3, [r7, #24]
 800cbaa:	9301      	str	r3, [sp, #4]
 800cbac:	68bb      	ldr	r3, [r7, #8]
 800cbae:	9300      	str	r3, [sp, #0]
 800cbb0:	f240 134d 	movw	r3, #333	; 0x14d
 800cbb4:	4a1c      	ldr	r2, [pc, #112]	; (800cc28 <btstack_tlv_flash_bank_get_tag+0xb4>)
 800cbb6:	491d      	ldr	r1, [pc, #116]	; (800cc2c <btstack_tlv_flash_bank_get_tag+0xb8>)
 800cbb8:	2001      	movs	r0, #1
 800cbba:	f00a fc41 	bl	8017440 <hci_dump_log>
			tag_index = it.offset;
 800cbbe:	69bb      	ldr	r3, [r7, #24]
 800cbc0:	637b      	str	r3, [r7, #52]	; 0x34
			tag_len   = it.len;
 800cbc2:	6a3b      	ldr	r3, [r7, #32]
 800cbc4:	633b      	str	r3, [r7, #48]	; 0x30
			break;
 800cbc6:	e00e      	b.n	800cbe6 <btstack_tlv_flash_bank_get_tag+0x72>
		}
		tlv_iterator_fetch_next(self, &it);
 800cbc8:	f107 0314 	add.w	r3, r7, #20
 800cbcc:	4619      	mov	r1, r3
 800cbce:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800cbd0:	f7ff fd80 	bl	800c6d4 <tlv_iterator_fetch_next>
	while (btstack_tlv_flash_bank_iterator_has_next(self, &it)){
 800cbd4:	f107 0314 	add.w	r3, r7, #20
 800cbd8:	4619      	mov	r1, r3
 800cbda:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800cbdc:	f7ff fd67 	bl	800c6ae <btstack_tlv_flash_bank_iterator_has_next>
 800cbe0:	4603      	mov	r3, r0
 800cbe2:	2b00      	cmp	r3, #0
 800cbe4:	d1dc      	bne.n	800cba0 <btstack_tlv_flash_bank_get_tag+0x2c>
	}
	if (tag_index == 0) return 0;
 800cbe6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cbe8:	2b00      	cmp	r3, #0
 800cbea:	d101      	bne.n	800cbf0 <btstack_tlv_flash_bank_get_tag+0x7c>
 800cbec:	2300      	movs	r3, #0
 800cbee:	e017      	b.n	800cc20 <btstack_tlv_flash_bank_get_tag+0xac>
	if (!buffer) return tag_len;
 800cbf0:	687b      	ldr	r3, [r7, #4]
 800cbf2:	2b00      	cmp	r3, #0
 800cbf4:	d101      	bne.n	800cbfa <btstack_tlv_flash_bank_get_tag+0x86>
 800cbf6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800cbf8:	e012      	b.n	800cc20 <btstack_tlv_flash_bank_get_tag+0xac>
	int copy_size = btstack_min(buffer_size, tag_len);
 800cbfa:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800cbfc:	6838      	ldr	r0, [r7, #0]
 800cbfe:	f002 fa86 	bl	800f10e <btstack_min>
 800cc02:	4603      	mov	r3, r0
 800cc04:	62bb      	str	r3, [r7, #40]	; 0x28
	uint32_t value_offset = tag_index + 8;
 800cc06:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cc08:	3308      	adds	r3, #8
 800cc0a:	627b      	str	r3, [r7, #36]	; 0x24
#ifdef ENABLE_TLV_FLASH_EXPLICIT_DELETE_FIELD
	// skip delete field
	value_offset += self->delete_tag_len;
#endif
	btstack_tlv_flash_bank_read(self, self->current_bank, value_offset, buffer, copy_size);
 800cc0c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cc0e:	6899      	ldr	r1, [r3, #8]
 800cc10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc12:	9300      	str	r3, [sp, #0]
 800cc14:	687b      	ldr	r3, [r7, #4]
 800cc16:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cc18:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800cc1a:	f7ff fc5d 	bl	800c4d8 <btstack_tlv_flash_bank_read>
	return copy_size;
 800cc1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
 800cc20:	4618      	mov	r0, r3
 800cc22:	3738      	adds	r7, #56	; 0x38
 800cc24:	46bd      	mov	sp, r7
 800cc26:	bd80      	pop	{r7, pc}
 800cc28:	08028d34 	.word	0x08028d34
 800cc2c:	08028e60 	.word	0x08028e60

0800cc30 <btstack_tlv_flash_bank_store_tag>:
 * Store Tag 
 * @param tag
 * @param data
 * @param data_size
 */
static int btstack_tlv_flash_bank_store_tag(void * context, uint32_t tag, const uint8_t * data, uint32_t data_size){
 800cc30:	b590      	push	{r4, r7, lr}
 800cc32:	b08f      	sub	sp, #60	; 0x3c
 800cc34:	af04      	add	r7, sp, #16
 800cc36:	60f8      	str	r0, [r7, #12]
 800cc38:	60b9      	str	r1, [r7, #8]
 800cc3a:	607a      	str	r2, [r7, #4]
 800cc3c:	603b      	str	r3, [r7, #0]

	btstack_tlv_flash_bank_t * self = (btstack_tlv_flash_bank_t *) context;
 800cc3e:	68fb      	ldr	r3, [r7, #12]
 800cc40:	627b      	str	r3, [r7, #36]	; 0x24

	// trigger migration if not enough space
	uint32_t required_space = 8 + self->delete_tag_len + data_size;
 800cc42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cc44:	691b      	ldr	r3, [r3, #16]
 800cc46:	461a      	mov	r2, r3
 800cc48:	683b      	ldr	r3, [r7, #0]
 800cc4a:	4413      	add	r3, r2
 800cc4c:	3308      	adds	r3, #8
 800cc4e:	623b      	str	r3, [r7, #32]
	if (self->write_offset + required_space > self->hal_flash_bank_impl->get_size(self->hal_flash_bank_context)){
 800cc50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cc52:	68db      	ldr	r3, [r3, #12]
 800cc54:	461a      	mov	r2, r3
 800cc56:	6a3b      	ldr	r3, [r7, #32]
 800cc58:	18d4      	adds	r4, r2, r3
 800cc5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cc5c:	681b      	ldr	r3, [r3, #0]
 800cc5e:	681b      	ldr	r3, [r3, #0]
 800cc60:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cc62:	6852      	ldr	r2, [r2, #4]
 800cc64:	4610      	mov	r0, r2
 800cc66:	4798      	blx	r3
 800cc68:	4603      	mov	r3, r0
 800cc6a:	429c      	cmp	r4, r3
 800cc6c:	d902      	bls.n	800cc74 <btstack_tlv_flash_bank_store_tag+0x44>
		btstack_tlv_flash_bank_migrate(self);
 800cc6e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800cc70:	f7ff fe84 	bl	800c97c <btstack_tlv_flash_bank_migrate>
	}

	if (self->write_offset + required_space > self->hal_flash_bank_impl->get_size(self->hal_flash_bank_context)){
 800cc74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cc76:	68db      	ldr	r3, [r3, #12]
 800cc78:	461a      	mov	r2, r3
 800cc7a:	6a3b      	ldr	r3, [r7, #32]
 800cc7c:	18d4      	adds	r4, r2, r3
 800cc7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cc80:	681b      	ldr	r3, [r3, #0]
 800cc82:	681b      	ldr	r3, [r3, #0]
 800cc84:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cc86:	6852      	ldr	r2, [r2, #4]
 800cc88:	4610      	mov	r0, r2
 800cc8a:	4798      	blx	r3
 800cc8c:	4603      	mov	r3, r0
 800cc8e:	429c      	cmp	r4, r3
 800cc90:	d908      	bls.n	800cca4 <btstack_tlv_flash_bank_store_tag+0x74>
		log_error("couldn't write entry, not enough space left");
 800cc92:	f240 1371 	movw	r3, #369	; 0x171
 800cc96:	4a2b      	ldr	r2, [pc, #172]	; (800cd44 <btstack_tlv_flash_bank_store_tag+0x114>)
 800cc98:	492b      	ldr	r1, [pc, #172]	; (800cd48 <btstack_tlv_flash_bank_store_tag+0x118>)
 800cc9a:	2002      	movs	r0, #2
 800cc9c:	f00a fbd0 	bl	8017440 <hci_dump_log>
		return 2;
 800cca0:	2302      	movs	r3, #2
 800cca2:	e04a      	b.n	800cd3a <btstack_tlv_flash_bank_store_tag+0x10a>
	}

	// prepare entry
	uint8_t entry[8];
	big_endian_store_32(entry, 0, tag);
 800cca4:	f107 0314 	add.w	r3, r7, #20
 800cca8:	68ba      	ldr	r2, [r7, #8]
 800ccaa:	2100      	movs	r1, #0
 800ccac:	4618      	mov	r0, r3
 800ccae:	f002 f992 	bl	800efd6 <big_endian_store_32>
	big_endian_store_32(entry, 4, data_size);
 800ccb2:	f107 0314 	add.w	r3, r7, #20
 800ccb6:	683a      	ldr	r2, [r7, #0]
 800ccb8:	2104      	movs	r1, #4
 800ccba:	4618      	mov	r0, r3
 800ccbc:	f002 f98b 	bl	800efd6 <big_endian_store_32>

	log_info("write '%x', len %u at %u", (unsigned int) tag, (unsigned int) data_size, self->write_offset);
 800ccc0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ccc2:	68db      	ldr	r3, [r3, #12]
 800ccc4:	9302      	str	r3, [sp, #8]
 800ccc6:	683b      	ldr	r3, [r7, #0]
 800ccc8:	9301      	str	r3, [sp, #4]
 800ccca:	68bb      	ldr	r3, [r7, #8]
 800cccc:	9300      	str	r3, [sp, #0]
 800ccce:	f44f 73bd 	mov.w	r3, #378	; 0x17a
 800ccd2:	4a1c      	ldr	r2, [pc, #112]	; (800cd44 <btstack_tlv_flash_bank_store_tag+0x114>)
 800ccd4:	491d      	ldr	r1, [pc, #116]	; (800cd4c <btstack_tlv_flash_bank_store_tag+0x11c>)
 800ccd6:	2001      	movs	r0, #1
 800ccd8:	f00a fbb2 	bl	8017440 <hci_dump_log>

	uint32_t value_offset = self->write_offset + 8;
 800ccdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ccde:	68db      	ldr	r3, [r3, #12]
 800cce0:	3308      	adds	r3, #8
 800cce2:	61fb      	str	r3, [r7, #28]
	// skip delete field
	value_offset += self->delete_tag_len;
#endif

	// write value first
	btstack_tlv_flash_bank_write(self, self->current_bank, value_offset, data, data_size);
 800cce4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cce6:	6899      	ldr	r1, [r3, #8]
 800cce8:	683b      	ldr	r3, [r7, #0]
 800ccea:	9300      	str	r3, [sp, #0]
 800ccec:	687b      	ldr	r3, [r7, #4]
 800ccee:	69fa      	ldr	r2, [r7, #28]
 800ccf0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800ccf2:	f7ff fc47 	bl	800c584 <btstack_tlv_flash_bank_write>

	// then entry
	btstack_tlv_flash_bank_write(self, self->current_bank, self->write_offset, entry, sizeof(entry));
 800ccf6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ccf8:	6899      	ldr	r1, [r3, #8]
 800ccfa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ccfc:	68db      	ldr	r3, [r3, #12]
 800ccfe:	4618      	mov	r0, r3
 800cd00:	f107 0214 	add.w	r2, r7, #20
 800cd04:	2308      	movs	r3, #8
 800cd06:	9300      	str	r3, [sp, #0]
 800cd08:	4613      	mov	r3, r2
 800cd0a:	4602      	mov	r2, r0
 800cd0c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800cd0e:	f7ff fc39 	bl	800c584 <btstack_tlv_flash_bank_write>

	// overwrite old entries (if exists)
	btstack_tlv_flash_bank_delete_tag_until_offset(self, tag, self->write_offset);
 800cd12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cd14:	68db      	ldr	r3, [r3, #12]
 800cd16:	461a      	mov	r2, r3
 800cd18:	68b9      	ldr	r1, [r7, #8]
 800cd1a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800cd1c:	f7ff fee4 	bl	800cae8 <btstack_tlv_flash_bank_delete_tag_until_offset>

	// done
	self->write_offset += sizeof(entry) + btstack_tlv_flash_bank_align_size(self, data_size);
 800cd20:	6839      	ldr	r1, [r7, #0]
 800cd22:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800cd24:	f7ff fbc0 	bl	800c4a8 <btstack_tlv_flash_bank_align_size>
 800cd28:	4603      	mov	r3, r0
 800cd2a:	3308      	adds	r3, #8
 800cd2c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cd2e:	68d2      	ldr	r2, [r2, #12]
 800cd30:	4413      	add	r3, r2
 800cd32:	461a      	mov	r2, r3
 800cd34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cd36:	60da      	str	r2, [r3, #12]
#ifdef ENABLE_TLV_FLASH_EXPLICIT_DELETE_FIELD
	// skip delete field
	self->write_offset += self->delete_tag_len;
#endif

	return 0;
 800cd38:	2300      	movs	r3, #0
}
 800cd3a:	4618      	mov	r0, r3
 800cd3c:	372c      	adds	r7, #44	; 0x2c
 800cd3e:	46bd      	mov	sp, r7
 800cd40:	bd90      	pop	{r4, r7, pc}
 800cd42:	bf00      	nop
 800cd44:	08028d34 	.word	0x08028d34
 800cd48:	08028e88 	.word	0x08028e88
 800cd4c:	08028ebc 	.word	0x08028ebc

0800cd50 <btstack_tlv_flash_bank_delete_tag>:

/**
 * Delete Tag
 * @param tag
 */
static void btstack_tlv_flash_bank_delete_tag(void * context, uint32_t tag){
 800cd50:	b580      	push	{r7, lr}
 800cd52:	b084      	sub	sp, #16
 800cd54:	af00      	add	r7, sp, #0
 800cd56:	6078      	str	r0, [r7, #4]
 800cd58:	6039      	str	r1, [r7, #0]
	btstack_tlv_flash_bank_t * self = (btstack_tlv_flash_bank_t *) context;
 800cd5a:	687b      	ldr	r3, [r7, #4]
 800cd5c:	60fb      	str	r3, [r7, #12]
	btstack_tlv_flash_bank_delete_tag_until_offset(self, tag, self->write_offset);
 800cd5e:	68fb      	ldr	r3, [r7, #12]
 800cd60:	68db      	ldr	r3, [r3, #12]
 800cd62:	461a      	mov	r2, r3
 800cd64:	6839      	ldr	r1, [r7, #0]
 800cd66:	68f8      	ldr	r0, [r7, #12]
 800cd68:	f7ff febe 	bl	800cae8 <btstack_tlv_flash_bank_delete_tag_until_offset>
}
 800cd6c:	bf00      	nop
 800cd6e:	3710      	adds	r7, #16
 800cd70:	46bd      	mov	sp, r7
 800cd72:	bd80      	pop	{r7, pc}

0800cd74 <btstack_tlv_flash_bank_init_instance>:
};

/**
 * Init Tag Length Value Store
 */
const btstack_tlv_t * btstack_tlv_flash_bank_init_instance(btstack_tlv_flash_bank_t * self, const hal_flash_bank_t * hal_flash_bank_impl, void * hal_flash_bank_context){
 800cd74:	b590      	push	{r4, r7, lr}
 800cd76:	b08d      	sub	sp, #52	; 0x34
 800cd78:	af02      	add	r7, sp, #8
 800cd7a:	60f8      	str	r0, [r7, #12]
 800cd7c:	60b9      	str	r1, [r7, #8]
 800cd7e:	607a      	str	r2, [r7, #4]

	self->hal_flash_bank_impl    = hal_flash_bank_impl;
 800cd80:	68fb      	ldr	r3, [r7, #12]
 800cd82:	68ba      	ldr	r2, [r7, #8]
 800cd84:	601a      	str	r2, [r3, #0]
	self->hal_flash_bank_context = hal_flash_bank_context;
 800cd86:	68fb      	ldr	r3, [r7, #12]
 800cd88:	687a      	ldr	r2, [r7, #4]
 800cd8a:	605a      	str	r2, [r3, #4]
	self->delete_tag_len = 0;
 800cd8c:	68fb      	ldr	r3, [r7, #12]
 800cd8e:	2200      	movs	r2, #0
 800cd90:	611a      	str	r2, [r3, #16]
	self->delete_tag_len = (uint8_t) btstack_max(4, aligment);
	log_info("delete tag len %u", self->delete_tag_len);
#endif

	// try to find current bank
	self->current_bank = btstack_tlv_flash_bank_get_latest_bank(self);
 800cd92:	68f8      	ldr	r0, [r7, #12]
 800cd94:	f7ff fccc 	bl	800c730 <btstack_tlv_flash_bank_get_latest_bank>
 800cd98:	4602      	mov	r2, r0
 800cd9a:	68fb      	ldr	r3, [r7, #12]
 800cd9c:	609a      	str	r2, [r3, #8]
	log_info("found bank %d", self->current_bank);
 800cd9e:	68fb      	ldr	r3, [r7, #12]
 800cda0:	689b      	ldr	r3, [r3, #8]
 800cda2:	9300      	str	r3, [sp, #0]
 800cda4:	f240 13bb 	movw	r3, #443	; 0x1bb
 800cda8:	4a43      	ldr	r2, [pc, #268]	; (800ceb8 <btstack_tlv_flash_bank_init_instance+0x144>)
 800cdaa:	4944      	ldr	r1, [pc, #272]	; (800cebc <btstack_tlv_flash_bank_init_instance+0x148>)
 800cdac:	2001      	movs	r0, #1
 800cdae:	f00a fb47 	bl	8017440 <hci_dump_log>
	if (self->current_bank >= 0){
 800cdb2:	68fb      	ldr	r3, [r7, #12]
 800cdb4:	689b      	ldr	r3, [r3, #8]
 800cdb6:	2b00      	cmp	r3, #0
 800cdb8:	db5a      	blt.n	800ce70 <btstack_tlv_flash_bank_init_instance+0xfc>

		// find last entry and write offset
		tlv_iterator_t it;
		uint32_t last_tag = 0;
 800cdba:	2300      	movs	r3, #0
 800cdbc:	627b      	str	r3, [r7, #36]	; 0x24
		uint32_t last_offset = 0;
 800cdbe:	2300      	movs	r3, #0
 800cdc0:	623b      	str	r3, [r7, #32]
		btstack_tlv_flash_bank_iterator_init(self, &it, self->current_bank);
 800cdc2:	68fb      	ldr	r3, [r7, #12]
 800cdc4:	689a      	ldr	r2, [r3, #8]
 800cdc6:	f107 0310 	add.w	r3, r7, #16
 800cdca:	4619      	mov	r1, r3
 800cdcc:	68f8      	ldr	r0, [r7, #12]
 800cdce:	f7ff fc55 	bl	800c67c <btstack_tlv_flash_bank_iterator_init>
		while (btstack_tlv_flash_bank_iterator_has_next(self, &it)){
 800cdd2:	e009      	b.n	800cde8 <btstack_tlv_flash_bank_init_instance+0x74>
			last_tag = it.tag;
 800cdd4:	69bb      	ldr	r3, [r7, #24]
 800cdd6:	627b      	str	r3, [r7, #36]	; 0x24
			last_offset = it.offset;
 800cdd8:	697b      	ldr	r3, [r7, #20]
 800cdda:	623b      	str	r3, [r7, #32]
			tlv_iterator_fetch_next(self, &it);
 800cddc:	f107 0310 	add.w	r3, r7, #16
 800cde0:	4619      	mov	r1, r3
 800cde2:	68f8      	ldr	r0, [r7, #12]
 800cde4:	f7ff fc76 	bl	800c6d4 <tlv_iterator_fetch_next>
		while (btstack_tlv_flash_bank_iterator_has_next(self, &it)){
 800cde8:	f107 0310 	add.w	r3, r7, #16
 800cdec:	4619      	mov	r1, r3
 800cdee:	68f8      	ldr	r0, [r7, #12]
 800cdf0:	f7ff fc5d 	bl	800c6ae <btstack_tlv_flash_bank_iterator_has_next>
 800cdf4:	4603      	mov	r3, r0
 800cdf6:	2b00      	cmp	r3, #0
 800cdf8:	d1ec      	bne.n	800cdd4 <btstack_tlv_flash_bank_init_instance+0x60>
		}
		self->write_offset = it.offset;
 800cdfa:	697b      	ldr	r3, [r7, #20]
 800cdfc:	461a      	mov	r2, r3
 800cdfe:	68fb      	ldr	r3, [r7, #12]
 800ce00:	60da      	str	r2, [r3, #12]

		if (self->write_offset < self->hal_flash_bank_impl->get_size(self->hal_flash_bank_context)){
 800ce02:	68fb      	ldr	r3, [r7, #12]
 800ce04:	68db      	ldr	r3, [r3, #12]
 800ce06:	461c      	mov	r4, r3
 800ce08:	68fb      	ldr	r3, [r7, #12]
 800ce0a:	681b      	ldr	r3, [r3, #0]
 800ce0c:	681b      	ldr	r3, [r3, #0]
 800ce0e:	68fa      	ldr	r2, [r7, #12]
 800ce10:	6852      	ldr	r2, [r2, #4]
 800ce12:	4610      	mov	r0, r2
 800ce14:	4798      	blx	r3
 800ce16:	4603      	mov	r3, r0
 800ce18:	429c      	cmp	r4, r3
 800ce1a:	d225      	bcs.n	800ce68 <btstack_tlv_flash_bank_init_instance+0xf4>

			// delete older instances of last_tag
			// this handles the unlikely case where MCU did reset after new value + header was written but before delete did complete
			if (last_tag){
 800ce1c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ce1e:	2b00      	cmp	r3, #0
 800ce20:	d004      	beq.n	800ce2c <btstack_tlv_flash_bank_init_instance+0xb8>
				btstack_tlv_flash_bank_delete_tag_until_offset(self, last_tag, last_offset);
 800ce22:	6a3a      	ldr	r2, [r7, #32]
 800ce24:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800ce26:	68f8      	ldr	r0, [r7, #12]
 800ce28:	f7ff fe5e 	bl	800cae8 <btstack_tlv_flash_bank_delete_tag_until_offset>
			}

			// verify that rest of bank is empty
			// this handles the unlikely case where MCU did reset after new value was written, but not the tag
			if (!btstack_tlv_flash_bank_test_erased(self, self->current_bank, self->write_offset)){
 800ce2c:	68fb      	ldr	r3, [r7, #12]
 800ce2e:	6899      	ldr	r1, [r3, #8]
 800ce30:	68fb      	ldr	r3, [r7, #12]
 800ce32:	68db      	ldr	r3, [r3, #12]
 800ce34:	461a      	mov	r2, r3
 800ce36:	68f8      	ldr	r0, [r7, #12]
 800ce38:	f7ff fd0e 	bl	800c858 <btstack_tlv_flash_bank_test_erased>
 800ce3c:	4603      	mov	r3, r0
 800ce3e:	2b00      	cmp	r3, #0
 800ce40:	d10a      	bne.n	800ce58 <btstack_tlv_flash_bank_init_instance+0xe4>
				log_info("Flash not empty after last found tag -> migrate");
 800ce42:	f240 13d5 	movw	r3, #469	; 0x1d5
 800ce46:	4a1c      	ldr	r2, [pc, #112]	; (800ceb8 <btstack_tlv_flash_bank_init_instance+0x144>)
 800ce48:	491d      	ldr	r1, [pc, #116]	; (800cec0 <btstack_tlv_flash_bank_init_instance+0x14c>)
 800ce4a:	2001      	movs	r0, #1
 800ce4c:	f00a faf8 	bl	8017440 <hci_dump_log>
				btstack_tlv_flash_bank_migrate(self);
 800ce50:	68f8      	ldr	r0, [r7, #12]
 800ce52:	f7ff fd93 	bl	800c97c <btstack_tlv_flash_bank_migrate>
 800ce56:	e00b      	b.n	800ce70 <btstack_tlv_flash_bank_init_instance+0xfc>
			} else {
				log_info("Flash clean after last found tag");
 800ce58:	f44f 73ec 	mov.w	r3, #472	; 0x1d8
 800ce5c:	4a16      	ldr	r2, [pc, #88]	; (800ceb8 <btstack_tlv_flash_bank_init_instance+0x144>)
 800ce5e:	4919      	ldr	r1, [pc, #100]	; (800cec4 <btstack_tlv_flash_bank_init_instance+0x150>)
 800ce60:	2001      	movs	r0, #1
 800ce62:	f00a faed 	bl	8017440 <hci_dump_log>
 800ce66:	e003      	b.n	800ce70 <btstack_tlv_flash_bank_init_instance+0xfc>
			}
		} else {
			// failure!
			self->current_bank = -1;
 800ce68:	68fb      	ldr	r3, [r7, #12]
 800ce6a:	f04f 32ff 	mov.w	r2, #4294967295
 800ce6e:	609a      	str	r2, [r3, #8]
		}
	} 

	if (self->current_bank < 0) {
 800ce70:	68fb      	ldr	r3, [r7, #12]
 800ce72:	689b      	ldr	r3, [r3, #8]
 800ce74:	2b00      	cmp	r3, #0
 800ce76:	da10      	bge.n	800ce9a <btstack_tlv_flash_bank_init_instance+0x126>
		btstack_tlv_flash_bank_erase_bank(self, 0);
 800ce78:	2100      	movs	r1, #0
 800ce7a:	68f8      	ldr	r0, [r7, #12]
 800ce7c:	f7ff fd4e 	bl	800c91c <btstack_tlv_flash_bank_erase_bank>
		self->current_bank = 0;
 800ce80:	68fb      	ldr	r3, [r7, #12]
 800ce82:	2200      	movs	r2, #0
 800ce84:	609a      	str	r2, [r3, #8]
		btstack_tlv_flash_bank_write_header(self, self->current_bank, 0);	// epoch = 0;
 800ce86:	68fb      	ldr	r3, [r7, #12]
 800ce88:	689b      	ldr	r3, [r3, #8]
 800ce8a:	2200      	movs	r2, #0
 800ce8c:	4619      	mov	r1, r3
 800ce8e:	68f8      	ldr	r0, [r7, #12]
 800ce90:	f7ff fcc0 	bl	800c814 <btstack_tlv_flash_bank_write_header>
		self->write_offset = 8;
 800ce94:	68fb      	ldr	r3, [r7, #12]
 800ce96:	2208      	movs	r2, #8
 800ce98:	60da      	str	r2, [r3, #12]
	}

	log_info("write offset %u", self->write_offset);
 800ce9a:	68fb      	ldr	r3, [r7, #12]
 800ce9c:	68db      	ldr	r3, [r3, #12]
 800ce9e:	9300      	str	r3, [sp, #0]
 800cea0:	f240 13e7 	movw	r3, #487	; 0x1e7
 800cea4:	4a04      	ldr	r2, [pc, #16]	; (800ceb8 <btstack_tlv_flash_bank_init_instance+0x144>)
 800cea6:	4908      	ldr	r1, [pc, #32]	; (800cec8 <btstack_tlv_flash_bank_init_instance+0x154>)
 800cea8:	2001      	movs	r0, #1
 800ceaa:	f00a fac9 	bl	8017440 <hci_dump_log>
	return &btstack_tlv_flash_bank;
 800ceae:	4b07      	ldr	r3, [pc, #28]	; (800cecc <btstack_tlv_flash_bank_init_instance+0x158>)
}
 800ceb0:	4618      	mov	r0, r3
 800ceb2:	372c      	adds	r7, #44	; 0x2c
 800ceb4:	46bd      	mov	sp, r7
 800ceb6:	bd90      	pop	{r4, r7, pc}
 800ceb8:	08028d34 	.word	0x08028d34
 800cebc:	08028edc 	.word	0x08028edc
 800cec0:	08028ef4 	.word	0x08028ef4
 800cec4:	08028f2c 	.word	0x08028f2c
 800cec8:	08028f54 	.word	0x08028f54
 800cecc:	08030974 	.word	0x08030974

0800ced0 <btstack_uart_block_received>:
static void (*block_sent)(void);
static void (*block_received)(void);
static void (*wakeup_handler)(void);


static void btstack_uart_block_received(void){
 800ced0:	b580      	push	{r7, lr}
 800ced2:	af00      	add	r7, sp, #0
    receive_complete = 1;
 800ced4:	4b03      	ldr	r3, [pc, #12]	; (800cee4 <btstack_uart_block_received+0x14>)
 800ced6:	2201      	movs	r2, #1
 800ced8:	601a      	str	r2, [r3, #0]
    btstack_run_loop_embedded_trigger();
 800ceda:	f7ff fabd 	bl	800c458 <btstack_run_loop_embedded_trigger>
}
 800cede:	bf00      	nop
 800cee0:	bd80      	pop	{r7, pc}
 800cee2:	bf00      	nop
 800cee4:	20006160 	.word	0x20006160

0800cee8 <btstack_uart_block_sent>:

static void btstack_uart_block_sent(void){
 800cee8:	b580      	push	{r7, lr}
 800ceea:	af00      	add	r7, sp, #0
    send_complete = 1;
 800ceec:	4b03      	ldr	r3, [pc, #12]	; (800cefc <btstack_uart_block_sent+0x14>)
 800ceee:	2201      	movs	r2, #1
 800cef0:	601a      	str	r2, [r3, #0]
    btstack_run_loop_embedded_trigger();
 800cef2:	f7ff fab1 	bl	800c458 <btstack_run_loop_embedded_trigger>
}
 800cef6:	bf00      	nop
 800cef8:	bd80      	pop	{r7, pc}
 800cefa:	bf00      	nop
 800cefc:	2000615c 	.word	0x2000615c

0800cf00 <btstack_uart_cts_pulse>:

static void btstack_uart_cts_pulse(void){
 800cf00:	b580      	push	{r7, lr}
 800cf02:	af00      	add	r7, sp, #0
    wakeup_event = 1;
 800cf04:	4b03      	ldr	r3, [pc, #12]	; (800cf14 <btstack_uart_cts_pulse+0x14>)
 800cf06:	2201      	movs	r2, #1
 800cf08:	601a      	str	r2, [r3, #0]
    btstack_run_loop_embedded_trigger();
 800cf0a:	f7ff faa5 	bl	800c458 <btstack_run_loop_embedded_trigger>
}
 800cf0e:	bf00      	nop
 800cf10:	bd80      	pop	{r7, pc}
 800cf12:	bf00      	nop
 800cf14:	20006164 	.word	0x20006164

0800cf18 <btstack_uart_embedded_init>:

static int btstack_uart_embedded_init(const btstack_uart_config_t * config){
 800cf18:	b580      	push	{r7, lr}
 800cf1a:	b082      	sub	sp, #8
 800cf1c:	af00      	add	r7, sp, #0
 800cf1e:	6078      	str	r0, [r7, #4]
    uart_config = config;
 800cf20:	4a06      	ldr	r2, [pc, #24]	; (800cf3c <btstack_uart_embedded_init+0x24>)
 800cf22:	687b      	ldr	r3, [r7, #4]
 800cf24:	6013      	str	r3, [r2, #0]
    hal_uart_dma_set_block_received(&btstack_uart_block_received);
 800cf26:	4806      	ldr	r0, [pc, #24]	; (800cf40 <btstack_uart_embedded_init+0x28>)
 800cf28:	f7f4 ffc2 	bl	8001eb0 <hal_uart_dma_set_block_received>
    hal_uart_dma_set_block_sent(&btstack_uart_block_sent);
 800cf2c:	4805      	ldr	r0, [pc, #20]	; (800cf44 <btstack_uart_embedded_init+0x2c>)
 800cf2e:	f7f4 ffcf 	bl	8001ed0 <hal_uart_dma_set_block_sent>
    return 0;
 800cf32:	2300      	movs	r3, #0
}
 800cf34:	4618      	mov	r0, r3
 800cf36:	3708      	adds	r7, #8
 800cf38:	46bd      	mov	sp, r7
 800cf3a:	bd80      	pop	{r7, pc}
 800cf3c:	20006148 	.word	0x20006148
 800cf40:	0800ced1 	.word	0x0800ced1
 800cf44:	0800cee9 	.word	0x0800cee9

0800cf48 <btstack_uart_embedded_process>:

static void btstack_uart_embedded_process(btstack_data_source_t *ds, btstack_data_source_callback_type_t callback_type) {
 800cf48:	b580      	push	{r7, lr}
 800cf4a:	b082      	sub	sp, #8
 800cf4c:	af00      	add	r7, sp, #0
 800cf4e:	6078      	str	r0, [r7, #4]
 800cf50:	460b      	mov	r3, r1
 800cf52:	70fb      	strb	r3, [r7, #3]
    switch (callback_type){
 800cf54:	78fb      	ldrb	r3, [r7, #3]
 800cf56:	2b01      	cmp	r3, #1
 800cf58:	d000      	beq.n	800cf5c <btstack_uart_embedded_process+0x14>
                    wakeup_handler();
                }
            }
            break;
        default:
            break;
 800cf5a:	e02a      	b.n	800cfb2 <btstack_uart_embedded_process+0x6a>
            if (send_complete){
 800cf5c:	4b17      	ldr	r3, [pc, #92]	; (800cfbc <btstack_uart_embedded_process+0x74>)
 800cf5e:	681b      	ldr	r3, [r3, #0]
 800cf60:	2b00      	cmp	r3, #0
 800cf62:	d009      	beq.n	800cf78 <btstack_uart_embedded_process+0x30>
                send_complete = 0;
 800cf64:	4b15      	ldr	r3, [pc, #84]	; (800cfbc <btstack_uart_embedded_process+0x74>)
 800cf66:	2200      	movs	r2, #0
 800cf68:	601a      	str	r2, [r3, #0]
                if (block_sent){
 800cf6a:	4b15      	ldr	r3, [pc, #84]	; (800cfc0 <btstack_uart_embedded_process+0x78>)
 800cf6c:	681b      	ldr	r3, [r3, #0]
 800cf6e:	2b00      	cmp	r3, #0
 800cf70:	d002      	beq.n	800cf78 <btstack_uart_embedded_process+0x30>
                    block_sent();
 800cf72:	4b13      	ldr	r3, [pc, #76]	; (800cfc0 <btstack_uart_embedded_process+0x78>)
 800cf74:	681b      	ldr	r3, [r3, #0]
 800cf76:	4798      	blx	r3
            if (receive_complete){
 800cf78:	4b12      	ldr	r3, [pc, #72]	; (800cfc4 <btstack_uart_embedded_process+0x7c>)
 800cf7a:	681b      	ldr	r3, [r3, #0]
 800cf7c:	2b00      	cmp	r3, #0
 800cf7e:	d009      	beq.n	800cf94 <btstack_uart_embedded_process+0x4c>
                receive_complete = 0;
 800cf80:	4b10      	ldr	r3, [pc, #64]	; (800cfc4 <btstack_uart_embedded_process+0x7c>)
 800cf82:	2200      	movs	r2, #0
 800cf84:	601a      	str	r2, [r3, #0]
                if (block_received){
 800cf86:	4b10      	ldr	r3, [pc, #64]	; (800cfc8 <btstack_uart_embedded_process+0x80>)
 800cf88:	681b      	ldr	r3, [r3, #0]
 800cf8a:	2b00      	cmp	r3, #0
 800cf8c:	d002      	beq.n	800cf94 <btstack_uart_embedded_process+0x4c>
                    block_received();
 800cf8e:	4b0e      	ldr	r3, [pc, #56]	; (800cfc8 <btstack_uart_embedded_process+0x80>)
 800cf90:	681b      	ldr	r3, [r3, #0]
 800cf92:	4798      	blx	r3
            if (wakeup_event){
 800cf94:	4b0d      	ldr	r3, [pc, #52]	; (800cfcc <btstack_uart_embedded_process+0x84>)
 800cf96:	681b      	ldr	r3, [r3, #0]
 800cf98:	2b00      	cmp	r3, #0
 800cf9a:	d009      	beq.n	800cfb0 <btstack_uart_embedded_process+0x68>
                wakeup_event = 0;
 800cf9c:	4b0b      	ldr	r3, [pc, #44]	; (800cfcc <btstack_uart_embedded_process+0x84>)
 800cf9e:	2200      	movs	r2, #0
 800cfa0:	601a      	str	r2, [r3, #0]
                if (wakeup_handler){
 800cfa2:	4b0b      	ldr	r3, [pc, #44]	; (800cfd0 <btstack_uart_embedded_process+0x88>)
 800cfa4:	681b      	ldr	r3, [r3, #0]
 800cfa6:	2b00      	cmp	r3, #0
 800cfa8:	d002      	beq.n	800cfb0 <btstack_uart_embedded_process+0x68>
                    wakeup_handler();
 800cfaa:	4b09      	ldr	r3, [pc, #36]	; (800cfd0 <btstack_uart_embedded_process+0x88>)
 800cfac:	681b      	ldr	r3, [r3, #0]
 800cfae:	4798      	blx	r3
            break;
 800cfb0:	bf00      	nop
    }
}
 800cfb2:	bf00      	nop
 800cfb4:	3708      	adds	r7, #8
 800cfb6:	46bd      	mov	sp, r7
 800cfb8:	bd80      	pop	{r7, pc}
 800cfba:	bf00      	nop
 800cfbc:	2000615c 	.word	0x2000615c
 800cfc0:	20006168 	.word	0x20006168
 800cfc4:	20006160 	.word	0x20006160
 800cfc8:	2000616c 	.word	0x2000616c
 800cfcc:	20006164 	.word	0x20006164
 800cfd0:	20006170 	.word	0x20006170

0800cfd4 <btstack_uart_embedded_open>:

static int btstack_uart_embedded_open(void){
 800cfd4:	b580      	push	{r7, lr}
 800cfd6:	af00      	add	r7, sp, #0
    hal_uart_dma_init();
 800cfd8:	f7f4 ff64 	bl	8001ea4 <hal_uart_dma_init>
    hal_uart_dma_set_baud(uart_config->baudrate);
 800cfdc:	4b09      	ldr	r3, [pc, #36]	; (800d004 <btstack_uart_embedded_open+0x30>)
 800cfde:	681b      	ldr	r3, [r3, #0]
 800cfe0:	681b      	ldr	r3, [r3, #0]
 800cfe2:	4618      	mov	r0, r3
 800cfe4:	f7f4 ff8e 	bl	8001f04 <hal_uart_dma_set_baud>

    // set up polling data_source
    btstack_run_loop_set_data_source_handler(&transport_data_source, &btstack_uart_embedded_process);
 800cfe8:	4907      	ldr	r1, [pc, #28]	; (800d008 <btstack_uart_embedded_open+0x34>)
 800cfea:	4808      	ldr	r0, [pc, #32]	; (800d00c <btstack_uart_embedded_open+0x38>)
 800cfec:	f001 fddc 	bl	800eba8 <btstack_run_loop_set_data_source_handler>
    btstack_run_loop_enable_data_source_callbacks(&transport_data_source, DATA_SOURCE_CALLBACK_POLL);
 800cff0:	2101      	movs	r1, #1
 800cff2:	4806      	ldr	r0, [pc, #24]	; (800d00c <btstack_uart_embedded_open+0x38>)
 800cff4:	f001 fde6 	bl	800ebc4 <btstack_run_loop_enable_data_source_callbacks>
    btstack_run_loop_add_data_source(&transport_data_source);
 800cff8:	4804      	ldr	r0, [pc, #16]	; (800d00c <btstack_uart_embedded_open+0x38>)
 800cffa:	f001 fe0b 	bl	800ec14 <btstack_run_loop_add_data_source>
    return 0;
 800cffe:	2300      	movs	r3, #0
} 
 800d000:	4618      	mov	r0, r3
 800d002:	bd80      	pop	{r7, pc}
 800d004:	20006148 	.word	0x20006148
 800d008:	0800cf49 	.word	0x0800cf49
 800d00c:	2000614c 	.word	0x2000614c

0800d010 <btstack_uart_embedded_close>:

static int btstack_uart_embedded_close(void){
 800d010:	b580      	push	{r7, lr}
 800d012:	af00      	add	r7, sp, #0

    // remove data source
    btstack_run_loop_disable_data_source_callbacks(&transport_data_source, DATA_SOURCE_CALLBACK_POLL);
 800d014:	2101      	movs	r1, #1
 800d016:	4804      	ldr	r0, [pc, #16]	; (800d028 <btstack_uart_embedded_close+0x18>)
 800d018:	f001 fde8 	bl	800ebec <btstack_run_loop_disable_data_source_callbacks>
    btstack_run_loop_remove_data_source(&transport_data_source);
 800d01c:	4802      	ldr	r0, [pc, #8]	; (800d028 <btstack_uart_embedded_close+0x18>)
 800d01e:	f001 fe09 	bl	800ec34 <btstack_run_loop_remove_data_source>

    // close device
    // ...
    return 0;
 800d022:	2300      	movs	r3, #0
}
 800d024:	4618      	mov	r0, r3
 800d026:	bd80      	pop	{r7, pc}
 800d028:	2000614c 	.word	0x2000614c

0800d02c <btstack_uart_embedded_set_block_received>:

static void btstack_uart_embedded_set_block_received( void (*block_handler)(void)){
 800d02c:	b480      	push	{r7}
 800d02e:	b083      	sub	sp, #12
 800d030:	af00      	add	r7, sp, #0
 800d032:	6078      	str	r0, [r7, #4]
    block_received = block_handler;
 800d034:	4a04      	ldr	r2, [pc, #16]	; (800d048 <btstack_uart_embedded_set_block_received+0x1c>)
 800d036:	687b      	ldr	r3, [r7, #4]
 800d038:	6013      	str	r3, [r2, #0]
}
 800d03a:	bf00      	nop
 800d03c:	370c      	adds	r7, #12
 800d03e:	46bd      	mov	sp, r7
 800d040:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d044:	4770      	bx	lr
 800d046:	bf00      	nop
 800d048:	2000616c 	.word	0x2000616c

0800d04c <btstack_uart_embedded_set_block_sent>:

static void btstack_uart_embedded_set_block_sent( void (*block_handler)(void)){
 800d04c:	b480      	push	{r7}
 800d04e:	b083      	sub	sp, #12
 800d050:	af00      	add	r7, sp, #0
 800d052:	6078      	str	r0, [r7, #4]
    block_sent = block_handler;
 800d054:	4a04      	ldr	r2, [pc, #16]	; (800d068 <btstack_uart_embedded_set_block_sent+0x1c>)
 800d056:	687b      	ldr	r3, [r7, #4]
 800d058:	6013      	str	r3, [r2, #0]
}
 800d05a:	bf00      	nop
 800d05c:	370c      	adds	r7, #12
 800d05e:	46bd      	mov	sp, r7
 800d060:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d064:	4770      	bx	lr
 800d066:	bf00      	nop
 800d068:	20006168 	.word	0x20006168

0800d06c <btstack_uart_embedded_set_wakeup_handler>:

static void btstack_uart_embedded_set_wakeup_handler( void (*the_wakeup_handler)(void)){
 800d06c:	b480      	push	{r7}
 800d06e:	b083      	sub	sp, #12
 800d070:	af00      	add	r7, sp, #0
 800d072:	6078      	str	r0, [r7, #4]
    wakeup_handler = the_wakeup_handler;
 800d074:	4a04      	ldr	r2, [pc, #16]	; (800d088 <btstack_uart_embedded_set_wakeup_handler+0x1c>)
 800d076:	687b      	ldr	r3, [r7, #4]
 800d078:	6013      	str	r3, [r2, #0]
}
 800d07a:	bf00      	nop
 800d07c:	370c      	adds	r7, #12
 800d07e:	46bd      	mov	sp, r7
 800d080:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d084:	4770      	bx	lr
 800d086:	bf00      	nop
 800d088:	20006170 	.word	0x20006170

0800d08c <btstack_uart_embedded_set_parity>:

static int btstack_uart_embedded_set_parity(int parity){
 800d08c:	b480      	push	{r7}
 800d08e:	b083      	sub	sp, #12
 800d090:	af00      	add	r7, sp, #0
 800d092:	6078      	str	r0, [r7, #4]
    return 0;
 800d094:	2300      	movs	r3, #0
}
 800d096:	4618      	mov	r0, r3
 800d098:	370c      	adds	r7, #12
 800d09a:	46bd      	mov	sp, r7
 800d09c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0a0:	4770      	bx	lr

0800d0a2 <btstack_uart_embedded_send_block>:

static void btstack_uart_embedded_send_block(const uint8_t *data, uint16_t size){
 800d0a2:	b580      	push	{r7, lr}
 800d0a4:	b082      	sub	sp, #8
 800d0a6:	af00      	add	r7, sp, #0
 800d0a8:	6078      	str	r0, [r7, #4]
 800d0aa:	460b      	mov	r3, r1
 800d0ac:	807b      	strh	r3, [r7, #2]
    hal_uart_dma_send_block(data, size);
 800d0ae:	887b      	ldrh	r3, [r7, #2]
 800d0b0:	4619      	mov	r1, r3
 800d0b2:	6878      	ldr	r0, [r7, #4]
 800d0b4:	f7f4 ff32 	bl	8001f1c <hal_uart_dma_send_block>
}
 800d0b8:	bf00      	nop
 800d0ba:	3708      	adds	r7, #8
 800d0bc:	46bd      	mov	sp, r7
 800d0be:	bd80      	pop	{r7, pc}

0800d0c0 <btstack_uart_embedded_receive_block>:

static void btstack_uart_embedded_receive_block(uint8_t *buffer, uint16_t len){
 800d0c0:	b580      	push	{r7, lr}
 800d0c2:	b082      	sub	sp, #8
 800d0c4:	af00      	add	r7, sp, #0
 800d0c6:	6078      	str	r0, [r7, #4]
 800d0c8:	460b      	mov	r3, r1
 800d0ca:	807b      	strh	r3, [r7, #2]
    hal_uart_dma_receive_block(buffer, len);
 800d0cc:	887b      	ldrh	r3, [r7, #2]
 800d0ce:	4619      	mov	r1, r3
 800d0d0:	6878      	ldr	r0, [r7, #4]
 800d0d2:	f7f4 ff35 	bl	8001f40 <hal_uart_dma_receive_block>
}
 800d0d6:	bf00      	nop
 800d0d8:	3708      	adds	r7, #8
 800d0da:	46bd      	mov	sp, r7
 800d0dc:	bd80      	pop	{r7, pc}

0800d0de <btstack_uart_embedded_get_supported_sleep_modes>:

static int btstack_uart_embedded_get_supported_sleep_modes(void){
 800d0de:	b480      	push	{r7}
 800d0e0:	af00      	add	r7, sp, #0
#ifdef HAVE_HAL_UART_DMA_SLEEP_MODES
	return hal_uart_dma_get_supported_sleep_modes();
#else
	return BTSTACK_UART_SLEEP_MASK_RTS_HIGH_WAKE_ON_CTS_PULSE;
 800d0e2:	2302      	movs	r3, #2
#endif
}
 800d0e4:	4618      	mov	r0, r3
 800d0e6:	46bd      	mov	sp, r7
 800d0e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0ec:	4770      	bx	lr
	...

0800d0f0 <btstack_uart_embedded_set_sleep>:

static void btstack_uart_embedded_set_sleep(btstack_uart_sleep_mode_t sleep_mode){
 800d0f0:	b580      	push	{r7, lr}
 800d0f2:	b084      	sub	sp, #16
 800d0f4:	af02      	add	r7, sp, #8
 800d0f6:	4603      	mov	r3, r0
 800d0f8:	71fb      	strb	r3, [r7, #7]
	log_info("set sleep %u", sleep_mode);
 800d0fa:	79fb      	ldrb	r3, [r7, #7]
 800d0fc:	9300      	str	r3, [sp, #0]
 800d0fe:	23ac      	movs	r3, #172	; 0xac
 800d100:	4a10      	ldr	r2, [pc, #64]	; (800d144 <btstack_uart_embedded_set_sleep+0x54>)
 800d102:	4911      	ldr	r1, [pc, #68]	; (800d148 <btstack_uart_embedded_set_sleep+0x58>)
 800d104:	2001      	movs	r0, #1
 800d106:	f00a f99b 	bl	8017440 <hci_dump_log>
	if (sleep_mode == BTSTACK_UART_SLEEP_RTS_HIGH_WAKE_ON_CTS_PULSE){
 800d10a:	79fb      	ldrb	r3, [r7, #7]
 800d10c:	2b01      	cmp	r3, #1
 800d10e:	d103      	bne.n	800d118 <btstack_uart_embedded_set_sleep+0x28>
		hal_uart_dma_set_csr_irq_handler(&btstack_uart_cts_pulse);
 800d110:	480e      	ldr	r0, [pc, #56]	; (800d14c <btstack_uart_embedded_set_sleep+0x5c>)
 800d112:	f7f4 feed 	bl	8001ef0 <hal_uart_dma_set_csr_irq_handler>
 800d116:	e002      	b.n	800d11e <btstack_uart_embedded_set_sleep+0x2e>
	} else {
		hal_uart_dma_set_csr_irq_handler(NULL);
 800d118:	2000      	movs	r0, #0
 800d11a:	f7f4 fee9 	bl	8001ef0 <hal_uart_dma_set_csr_irq_handler>
	}

#ifdef HAVE_HAL_UART_DMA_SLEEP_MODES
	hal_uart_dma_set_sleep_mode(sleep_mode);
#else
	hal_uart_dma_set_sleep(sleep_mode != BTSTACK_UART_SLEEP_OFF);
 800d11e:	79fb      	ldrb	r3, [r7, #7]
 800d120:	2b00      	cmp	r3, #0
 800d122:	bf14      	ite	ne
 800d124:	2301      	movne	r3, #1
 800d126:	2300      	moveq	r3, #0
 800d128:	b2db      	uxtb	r3, r3
 800d12a:	4618      	mov	r0, r3
 800d12c:	f7f4 fe6c 	bl	8001e08 <hal_uart_dma_set_sleep>
#endif
	log_info("done");
 800d130:	23b8      	movs	r3, #184	; 0xb8
 800d132:	4a04      	ldr	r2, [pc, #16]	; (800d144 <btstack_uart_embedded_set_sleep+0x54>)
 800d134:	4906      	ldr	r1, [pc, #24]	; (800d150 <btstack_uart_embedded_set_sleep+0x60>)
 800d136:	2001      	movs	r0, #1
 800d138:	f00a f982 	bl	8017440 <hci_dump_log>
}
 800d13c:	bf00      	nop
 800d13e:	3708      	adds	r7, #8
 800d140:	46bd      	mov	sp, r7
 800d142:	bd80      	pop	{r7, pc}
 800d144:	08028f6c 	.word	0x08028f6c
 800d148:	08028f8c 	.word	0x08028f8c
 800d14c:	0800cf01 	.word	0x0800cf01
 800d150:	08028fa0 	.word	0x08028fa0

0800d154 <btstack_uart_block_embedded_instance>:
	/* int (*get_supported_sleep_modes); */                           &btstack_uart_embedded_get_supported_sleep_modes,
    /* void (*set_sleep)(btstack_uart_sleep_mode_t sleep_mode); */    &btstack_uart_embedded_set_sleep,
    /* void (*set_wakeup_handler)(void (*handler)(void)); */          &btstack_uart_embedded_set_wakeup_handler,
};

const btstack_uart_block_t * btstack_uart_block_embedded_instance(void){
 800d154:	b480      	push	{r7}
 800d156:	af00      	add	r7, sp, #0
	return &btstack_uart_embedded;
 800d158:	4b02      	ldr	r3, [pc, #8]	; (800d164 <btstack_uart_block_embedded_instance+0x10>)
}
 800d15a:	4618      	mov	r0, r3
 800d15c:	46bd      	mov	sp, r7
 800d15e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d162:	4770      	bx	lr
 800d164:	08030980 	.word	0x08030980

0800d168 <ad_iterator_init>:
#include "hci.h"
#include "hci_cmd.h"

#include "ad_parser.h"

void ad_iterator_init(ad_context_t *context, uint8_t ad_len, const uint8_t * ad_data){
 800d168:	b480      	push	{r7}
 800d16a:	b085      	sub	sp, #20
 800d16c:	af00      	add	r7, sp, #0
 800d16e:	60f8      	str	r0, [r7, #12]
 800d170:	460b      	mov	r3, r1
 800d172:	607a      	str	r2, [r7, #4]
 800d174:	72fb      	strb	r3, [r7, #11]
    context->data = ad_data;
 800d176:	68fb      	ldr	r3, [r7, #12]
 800d178:	687a      	ldr	r2, [r7, #4]
 800d17a:	601a      	str	r2, [r3, #0]
    context->length = ad_len;
 800d17c:	68fb      	ldr	r3, [r7, #12]
 800d17e:	7afa      	ldrb	r2, [r7, #11]
 800d180:	715a      	strb	r2, [r3, #5]
    context->offset = 0;
 800d182:	68fb      	ldr	r3, [r7, #12]
 800d184:	2200      	movs	r2, #0
 800d186:	711a      	strb	r2, [r3, #4]
}
 800d188:	bf00      	nop
 800d18a:	3714      	adds	r7, #20
 800d18c:	46bd      	mov	sp, r7
 800d18e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d192:	4770      	bx	lr

0800d194 <ad_iterator_has_more>:

bool ad_iterator_has_more(const ad_context_t * context){
 800d194:	b480      	push	{r7}
 800d196:	b085      	sub	sp, #20
 800d198:	af00      	add	r7, sp, #0
 800d19a:	6078      	str	r0, [r7, #4]
    // assert chunk_len and chunk_type are withing buffer
    if ((context->offset + 1u) >= context->length) {
 800d19c:	687b      	ldr	r3, [r7, #4]
 800d19e:	791b      	ldrb	r3, [r3, #4]
 800d1a0:	3301      	adds	r3, #1
 800d1a2:	687a      	ldr	r2, [r7, #4]
 800d1a4:	7952      	ldrb	r2, [r2, #5]
 800d1a6:	4293      	cmp	r3, r2
 800d1a8:	d301      	bcc.n	800d1ae <ad_iterator_has_more+0x1a>
        return false;
 800d1aa:	2300      	movs	r3, #0
 800d1ac:	e018      	b.n	800d1e0 <ad_iterator_has_more+0x4c>
    }

    // assert chunk_len > 0
    uint8_t chunk_len = context->data[context->offset];
 800d1ae:	687b      	ldr	r3, [r7, #4]
 800d1b0:	681b      	ldr	r3, [r3, #0]
 800d1b2:	687a      	ldr	r2, [r7, #4]
 800d1b4:	7912      	ldrb	r2, [r2, #4]
 800d1b6:	4413      	add	r3, r2
 800d1b8:	781b      	ldrb	r3, [r3, #0]
 800d1ba:	73fb      	strb	r3, [r7, #15]
    if (chunk_len == 0u){
 800d1bc:	7bfb      	ldrb	r3, [r7, #15]
 800d1be:	2b00      	cmp	r3, #0
 800d1c0:	d101      	bne.n	800d1c6 <ad_iterator_has_more+0x32>
        return false;
 800d1c2:	2300      	movs	r3, #0
 800d1c4:	e00c      	b.n	800d1e0 <ad_iterator_has_more+0x4c>
    }
    
    // assert complete chunk fits into buffer
    if ((context->offset + 1u + chunk_len) > context->length) {
 800d1c6:	687b      	ldr	r3, [r7, #4]
 800d1c8:	791b      	ldrb	r3, [r3, #4]
 800d1ca:	461a      	mov	r2, r3
 800d1cc:	7bfb      	ldrb	r3, [r7, #15]
 800d1ce:	4413      	add	r3, r2
 800d1d0:	3301      	adds	r3, #1
 800d1d2:	687a      	ldr	r2, [r7, #4]
 800d1d4:	7952      	ldrb	r2, [r2, #5]
 800d1d6:	4293      	cmp	r3, r2
 800d1d8:	d901      	bls.n	800d1de <ad_iterator_has_more+0x4a>
        return false;
 800d1da:	2300      	movs	r3, #0
 800d1dc:	e000      	b.n	800d1e0 <ad_iterator_has_more+0x4c>
    }
    return true;
 800d1de:	2301      	movs	r3, #1
}
 800d1e0:	4618      	mov	r0, r3
 800d1e2:	3714      	adds	r7, #20
 800d1e4:	46bd      	mov	sp, r7
 800d1e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1ea:	4770      	bx	lr

0800d1ec <ad_iterator_next>:

// pre: ad_iterator_has_more() == 1
void ad_iterator_next(ad_context_t * context){
 800d1ec:	b480      	push	{r7}
 800d1ee:	b085      	sub	sp, #20
 800d1f0:	af00      	add	r7, sp, #0
 800d1f2:	6078      	str	r0, [r7, #4]
    uint8_t chunk_len = context->data[context->offset];
 800d1f4:	687b      	ldr	r3, [r7, #4]
 800d1f6:	681b      	ldr	r3, [r3, #0]
 800d1f8:	687a      	ldr	r2, [r7, #4]
 800d1fa:	7912      	ldrb	r2, [r2, #4]
 800d1fc:	4413      	add	r3, r2
 800d1fe:	781b      	ldrb	r3, [r3, #0]
 800d200:	73fb      	strb	r3, [r7, #15]
    context->offset += 1u + chunk_len;
 800d202:	687b      	ldr	r3, [r7, #4]
 800d204:	791a      	ldrb	r2, [r3, #4]
 800d206:	7bfb      	ldrb	r3, [r7, #15]
 800d208:	4413      	add	r3, r2
 800d20a:	b2db      	uxtb	r3, r3
 800d20c:	3301      	adds	r3, #1
 800d20e:	b2da      	uxtb	r2, r3
 800d210:	687b      	ldr	r3, [r7, #4]
 800d212:	711a      	strb	r2, [r3, #4]
}
 800d214:	bf00      	nop
 800d216:	3714      	adds	r7, #20
 800d218:	46bd      	mov	sp, r7
 800d21a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d21e:	4770      	bx	lr

0800d220 <ad_iterator_get_data_len>:

uint8_t   ad_iterator_get_data_len(const ad_context_t * context){
 800d220:	b480      	push	{r7}
 800d222:	b083      	sub	sp, #12
 800d224:	af00      	add	r7, sp, #0
 800d226:	6078      	str	r0, [r7, #4]
    return context->data[context->offset] - 1u;
 800d228:	687b      	ldr	r3, [r7, #4]
 800d22a:	681b      	ldr	r3, [r3, #0]
 800d22c:	687a      	ldr	r2, [r7, #4]
 800d22e:	7912      	ldrb	r2, [r2, #4]
 800d230:	4413      	add	r3, r2
 800d232:	781b      	ldrb	r3, [r3, #0]
 800d234:	3b01      	subs	r3, #1
 800d236:	b2db      	uxtb	r3, r3
}
 800d238:	4618      	mov	r0, r3
 800d23a:	370c      	adds	r7, #12
 800d23c:	46bd      	mov	sp, r7
 800d23e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d242:	4770      	bx	lr

0800d244 <ad_iterator_get_data_type>:

uint8_t   ad_iterator_get_data_type(const ad_context_t * context){
 800d244:	b480      	push	{r7}
 800d246:	b083      	sub	sp, #12
 800d248:	af00      	add	r7, sp, #0
 800d24a:	6078      	str	r0, [r7, #4]
    return context->data[context->offset + 1u];
 800d24c:	687b      	ldr	r3, [r7, #4]
 800d24e:	681a      	ldr	r2, [r3, #0]
 800d250:	687b      	ldr	r3, [r7, #4]
 800d252:	791b      	ldrb	r3, [r3, #4]
 800d254:	3301      	adds	r3, #1
 800d256:	4413      	add	r3, r2
 800d258:	781b      	ldrb	r3, [r3, #0]
}
 800d25a:	4618      	mov	r0, r3
 800d25c:	370c      	adds	r7, #12
 800d25e:	46bd      	mov	sp, r7
 800d260:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d264:	4770      	bx	lr

0800d266 <ad_iterator_get_data>:

const uint8_t * ad_iterator_get_data(const ad_context_t * context){
 800d266:	b480      	push	{r7}
 800d268:	b083      	sub	sp, #12
 800d26a:	af00      	add	r7, sp, #0
 800d26c:	6078      	str	r0, [r7, #4]
    return &context->data[context->offset + 2u];
 800d26e:	687b      	ldr	r3, [r7, #4]
 800d270:	681a      	ldr	r2, [r3, #0]
 800d272:	687b      	ldr	r3, [r7, #4]
 800d274:	791b      	ldrb	r3, [r3, #4]
 800d276:	3302      	adds	r3, #2
 800d278:	4413      	add	r3, r2
}
 800d27a:	4618      	mov	r0, r3
 800d27c:	370c      	adds	r7, #12
 800d27e:	46bd      	mov	sp, r7
 800d280:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d284:	4770      	bx	lr

0800d286 <hci_event_packet_get_type>:
static inline uint8_t hci_event_packet_get_type(const uint8_t * event){
 800d286:	b480      	push	{r7}
 800d288:	b083      	sub	sp, #12
 800d28a:	af00      	add	r7, sp, #0
 800d28c:	6078      	str	r0, [r7, #4]
    return event[0];
 800d28e:	687b      	ldr	r3, [r7, #4]
 800d290:	781b      	ldrb	r3, [r3, #0]
}
 800d292:	4618      	mov	r0, r3
 800d294:	370c      	adds	r7, #12
 800d296:	46bd      	mov	sp, r7
 800d298:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d29c:	4770      	bx	lr

0800d29e <btstack_event_state_get_state>:
static inline uint8_t btstack_event_state_get_state(const uint8_t * event){
 800d29e:	b480      	push	{r7}
 800d2a0:	b083      	sub	sp, #12
 800d2a2:	af00      	add	r7, sp, #0
 800d2a4:	6078      	str	r0, [r7, #4]
    return event[2];
 800d2a6:	687b      	ldr	r3, [r7, #4]
 800d2a8:	3302      	adds	r3, #2
 800d2aa:	781b      	ldrb	r3, [r3, #0]
}
 800d2ac:	4618      	mov	r0, r3
 800d2ae:	370c      	adds	r7, #12
 800d2b0:	46bd      	mov	sp, r7
 800d2b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d2b6:	4770      	bx	lr

0800d2b8 <btstack_crypto_done>:
    int nrounds = rijndaelSetupEncrypt(rk, &key[0], KEYBITS);
    rijndaelEncrypt(rk, nrounds, plaintext, ciphertext);
}
#endif

static void btstack_crypto_done(btstack_crypto_t * btstack_crypto){
 800d2b8:	b580      	push	{r7, lr}
 800d2ba:	b082      	sub	sp, #8
 800d2bc:	af00      	add	r7, sp, #0
 800d2be:	6078      	str	r0, [r7, #4]
    btstack_linked_list_pop(&btstack_crypto_operations);
 800d2c0:	4806      	ldr	r0, [pc, #24]	; (800d2dc <btstack_crypto_done+0x24>)
 800d2c2:	f001 fa2d 	bl	800e720 <btstack_linked_list_pop>
    (*btstack_crypto->context_callback.callback)(btstack_crypto->context_callback.context);
 800d2c6:	687b      	ldr	r3, [r7, #4]
 800d2c8:	685b      	ldr	r3, [r3, #4]
 800d2ca:	687a      	ldr	r2, [r7, #4]
 800d2cc:	6892      	ldr	r2, [r2, #8]
 800d2ce:	4610      	mov	r0, r2
 800d2d0:	4798      	blx	r3
}
 800d2d2:	bf00      	nop
 800d2d4:	3708      	adds	r7, #8
 800d2d6:	46bd      	mov	sp, r7
 800d2d8:	bd80      	pop	{r7, pc}
 800d2da:	bf00      	nop
 800d2dc:	20006178 	.word	0x20006178

0800d2e0 <btstack_crypto_cmac_shift_left_by_one_bit_inplace>:

static void btstack_crypto_cmac_shift_left_by_one_bit_inplace(int len, uint8_t * data){
 800d2e0:	b480      	push	{r7}
 800d2e2:	b087      	sub	sp, #28
 800d2e4:	af00      	add	r7, sp, #0
 800d2e6:	6078      	str	r0, [r7, #4]
 800d2e8:	6039      	str	r1, [r7, #0]
    int i;
    int carry = 0;
 800d2ea:	2300      	movs	r3, #0
 800d2ec:	613b      	str	r3, [r7, #16]
    for (i=len-1; i >= 0 ; i--){
 800d2ee:	687b      	ldr	r3, [r7, #4]
 800d2f0:	3b01      	subs	r3, #1
 800d2f2:	617b      	str	r3, [r7, #20]
 800d2f4:	e01a      	b.n	800d32c <btstack_crypto_cmac_shift_left_by_one_bit_inplace+0x4c>
        int new_carry = data[i] >> 7;
 800d2f6:	697b      	ldr	r3, [r7, #20]
 800d2f8:	683a      	ldr	r2, [r7, #0]
 800d2fa:	4413      	add	r3, r2
 800d2fc:	781b      	ldrb	r3, [r3, #0]
 800d2fe:	09db      	lsrs	r3, r3, #7
 800d300:	b2db      	uxtb	r3, r3
 800d302:	60fb      	str	r3, [r7, #12]
        data[i] = (data[i] << 1) | carry;
 800d304:	697b      	ldr	r3, [r7, #20]
 800d306:	683a      	ldr	r2, [r7, #0]
 800d308:	4413      	add	r3, r2
 800d30a:	781b      	ldrb	r3, [r3, #0]
 800d30c:	005b      	lsls	r3, r3, #1
 800d30e:	b25a      	sxtb	r2, r3
 800d310:	693b      	ldr	r3, [r7, #16]
 800d312:	b25b      	sxtb	r3, r3
 800d314:	4313      	orrs	r3, r2
 800d316:	b259      	sxtb	r1, r3
 800d318:	697b      	ldr	r3, [r7, #20]
 800d31a:	683a      	ldr	r2, [r7, #0]
 800d31c:	4413      	add	r3, r2
 800d31e:	b2ca      	uxtb	r2, r1
 800d320:	701a      	strb	r2, [r3, #0]
        carry = new_carry;
 800d322:	68fb      	ldr	r3, [r7, #12]
 800d324:	613b      	str	r3, [r7, #16]
    for (i=len-1; i >= 0 ; i--){
 800d326:	697b      	ldr	r3, [r7, #20]
 800d328:	3b01      	subs	r3, #1
 800d32a:	617b      	str	r3, [r7, #20]
 800d32c:	697b      	ldr	r3, [r7, #20]
 800d32e:	2b00      	cmp	r3, #0
 800d330:	dae1      	bge.n	800d2f6 <btstack_crypto_cmac_shift_left_by_one_bit_inplace+0x16>
    }
}
 800d332:	bf00      	nop
 800d334:	371c      	adds	r7, #28
 800d336:	46bd      	mov	sp, r7
 800d338:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d33c:	4770      	bx	lr

0800d33e <btstack_crypto_cmac_get_byte>:

static uint8_t btstack_crypto_cmac_get_byte(btstack_crypto_aes128_cmac_t * btstack_crypto_cmac, uint16_t pos){
 800d33e:	b580      	push	{r7, lr}
 800d340:	b082      	sub	sp, #8
 800d342:	af00      	add	r7, sp, #0
 800d344:	6078      	str	r0, [r7, #4]
 800d346:	460b      	mov	r3, r1
 800d348:	807b      	strh	r3, [r7, #2]
    if (btstack_crypto_cmac->btstack_crypto.operation == BTSTACK_CRYPTO_CMAC_GENERATOR){
 800d34a:	687b      	ldr	r3, [r7, #4]
 800d34c:	7b1b      	ldrb	r3, [r3, #12]
 800d34e:	2b02      	cmp	r3, #2
 800d350:	d106      	bne.n	800d360 <btstack_crypto_cmac_get_byte+0x22>
        return (*btstack_crypto_cmac->data.get_byte_callback)(pos);
 800d352:	687b      	ldr	r3, [r7, #4]
 800d354:	699b      	ldr	r3, [r3, #24]
 800d356:	887a      	ldrh	r2, [r7, #2]
 800d358:	4610      	mov	r0, r2
 800d35a:	4798      	blx	r3
 800d35c:	4603      	mov	r3, r0
 800d35e:	e004      	b.n	800d36a <btstack_crypto_cmac_get_byte+0x2c>
    } else {
        return btstack_crypto_cmac->data.message[pos]; 
 800d360:	687b      	ldr	r3, [r7, #4]
 800d362:	699a      	ldr	r2, [r3, #24]
 800d364:	887b      	ldrh	r3, [r7, #2]
 800d366:	4413      	add	r3, r2
 800d368:	781b      	ldrb	r3, [r3, #0]
    }
}
 800d36a:	4618      	mov	r0, r3
 800d36c:	3708      	adds	r7, #8
 800d36e:	46bd      	mov	sp, r7
 800d370:	bd80      	pop	{r7, pc}
	...

0800d374 <btstack_crypto_aes128_start>:
    // Step 7
    btstack_aes128_calc(btstack_crypto_cmac->key, cmac_y, btstack_crypto_cmac->hash);
}
#else

static void btstack_crypto_aes128_start(const sm_key_t key, const sm_key_t plaintext){
 800d374:	b580      	push	{r7, lr}
 800d376:	b08a      	sub	sp, #40	; 0x28
 800d378:	af00      	add	r7, sp, #0
 800d37a:	6078      	str	r0, [r7, #4]
 800d37c:	6039      	str	r1, [r7, #0]
    uint8_t key_flipped[16];
    uint8_t plaintext_flipped[16];
    reverse_128(key, key_flipped);
 800d37e:	f107 0318 	add.w	r3, r7, #24
 800d382:	4619      	mov	r1, r3
 800d384:	6878      	ldr	r0, [r7, #4]
 800d386:	f001 fe98 	bl	800f0ba <reverse_128>
    reverse_128(plaintext, plaintext_flipped);
 800d38a:	f107 0308 	add.w	r3, r7, #8
 800d38e:	4619      	mov	r1, r3
 800d390:	6838      	ldr	r0, [r7, #0]
 800d392:	f001 fe92 	bl	800f0ba <reverse_128>
    btstack_crypto_wait_for_hci_result = 1;
 800d396:	4b07      	ldr	r3, [pc, #28]	; (800d3b4 <btstack_crypto_aes128_start+0x40>)
 800d398:	2201      	movs	r2, #1
 800d39a:	701a      	strb	r2, [r3, #0]
    hci_send_cmd(&hci_le_encrypt, key_flipped, plaintext_flipped);
 800d39c:	f107 0208 	add.w	r2, r7, #8
 800d3a0:	f107 0318 	add.w	r3, r7, #24
 800d3a4:	4619      	mov	r1, r3
 800d3a6:	4804      	ldr	r0, [pc, #16]	; (800d3b8 <btstack_crypto_aes128_start+0x44>)
 800d3a8:	f008 fe1a 	bl	8015fe0 <hci_send_cmd>
}
 800d3ac:	bf00      	nop
 800d3ae:	3728      	adds	r7, #40	; 0x28
 800d3b0:	46bd      	mov	sp, r7
 800d3b2:	bd80      	pop	{r7, pc}
 800d3b4:	20006175 	.word	0x20006175
 800d3b8:	08030bf0 	.word	0x08030bf0

0800d3bc <btstack_crypto_cmac_next_state>:

static inline void btstack_crypto_cmac_next_state(void){
 800d3bc:	b480      	push	{r7}
 800d3be:	af00      	add	r7, sp, #0
    btstack_crypto_cmac_state = (btstack_crypto_cmac_state_t) (((int)btstack_crypto_cmac_state) + 1);
 800d3c0:	4b05      	ldr	r3, [pc, #20]	; (800d3d8 <btstack_crypto_cmac_next_state+0x1c>)
 800d3c2:	781b      	ldrb	r3, [r3, #0]
 800d3c4:	3301      	adds	r3, #1
 800d3c6:	b2da      	uxtb	r2, r3
 800d3c8:	4b03      	ldr	r3, [pc, #12]	; (800d3d8 <btstack_crypto_cmac_next_state+0x1c>)
 800d3ca:	701a      	strb	r2, [r3, #0]
}
 800d3cc:	bf00      	nop
 800d3ce:	46bd      	mov	sp, r7
 800d3d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d3d4:	4770      	bx	lr
 800d3d6:	bf00      	nop
 800d3d8:	20006184 	.word	0x20006184

0800d3dc <btstack_crypto_cmac_last_block_complete>:

static int btstack_crypto_cmac_last_block_complete(btstack_crypto_aes128_cmac_t * btstack_crypto_cmac){
 800d3dc:	b480      	push	{r7}
 800d3de:	b085      	sub	sp, #20
 800d3e0:	af00      	add	r7, sp, #0
 800d3e2:	6078      	str	r0, [r7, #4]
	uint16_t len = btstack_crypto_cmac->size;
 800d3e4:	687b      	ldr	r3, [r7, #4]
 800d3e6:	8a9b      	ldrh	r3, [r3, #20]
 800d3e8:	81fb      	strh	r3, [r7, #14]
    if (len == 0u) return 0u;
 800d3ea:	89fb      	ldrh	r3, [r7, #14]
 800d3ec:	2b00      	cmp	r3, #0
 800d3ee:	d101      	bne.n	800d3f4 <btstack_crypto_cmac_last_block_complete+0x18>
 800d3f0:	2300      	movs	r3, #0
 800d3f2:	e007      	b.n	800d404 <btstack_crypto_cmac_last_block_complete+0x28>
    return (len & 0x0fu) == 0u;
 800d3f4:	89fb      	ldrh	r3, [r7, #14]
 800d3f6:	f003 030f 	and.w	r3, r3, #15
 800d3fa:	2b00      	cmp	r3, #0
 800d3fc:	bf0c      	ite	eq
 800d3fe:	2301      	moveq	r3, #1
 800d400:	2300      	movne	r3, #0
 800d402:	b2db      	uxtb	r3, r3
}
 800d404:	4618      	mov	r0, r3
 800d406:	3714      	adds	r7, #20
 800d408:	46bd      	mov	sp, r7
 800d40a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d40e:	4770      	bx	lr

0800d410 <btstack_crypto_cmac_handle_aes_engine_ready>:

static void btstack_crypto_cmac_handle_aes_engine_ready(btstack_crypto_aes128_cmac_t * btstack_crypto_cmac){
 800d410:	b590      	push	{r4, r7, lr}
 800d412:	b09d      	sub	sp, #116	; 0x74
 800d414:	af02      	add	r7, sp, #8
 800d416:	6078      	str	r0, [r7, #4]
    switch (btstack_crypto_cmac_state){
 800d418:	4b9b      	ldr	r3, [pc, #620]	; (800d688 <btstack_crypto_cmac_handle_aes_engine_ready+0x278>)
 800d41a:	781b      	ldrb	r3, [r3, #0]
 800d41c:	2b03      	cmp	r3, #3
 800d41e:	d00b      	beq.n	800d438 <btstack_crypto_cmac_handle_aes_engine_ready+0x28>
 800d420:	2b05      	cmp	r3, #5
 800d422:	d03c      	beq.n	800d49e <btstack_crypto_cmac_handle_aes_engine_ready+0x8e>
 800d424:	2b01      	cmp	r3, #1
 800d426:	f040 8120 	bne.w	800d66a <btstack_crypto_cmac_handle_aes_engine_ready+0x25a>
        case CMAC_CALC_SUBKEYS: {
            btstack_crypto_cmac_next_state();
 800d42a:	f7ff ffc7 	bl	800d3bc <btstack_crypto_cmac_next_state>
            btstack_crypto_aes128_start(btstack_crypto_cmac_k, zero);
 800d42e:	4997      	ldr	r1, [pc, #604]	; (800d68c <btstack_crypto_cmac_handle_aes_engine_ready+0x27c>)
 800d430:	4897      	ldr	r0, [pc, #604]	; (800d690 <btstack_crypto_cmac_handle_aes_engine_ready+0x280>)
 800d432:	f7ff ff9f 	bl	800d374 <btstack_crypto_aes128_start>
            break;
 800d436:	e123      	b.n	800d680 <btstack_crypto_cmac_handle_aes_engine_ready+0x270>
        }
        case CMAC_CALC_MI: {
            int j;
            sm_key_t y;
            for (j=0;j<16;j++){
 800d438:	2300      	movs	r3, #0
 800d43a:	667b      	str	r3, [r7, #100]	; 0x64
 800d43c:	e01c      	b.n	800d478 <btstack_crypto_cmac_handle_aes_engine_ready+0x68>
                y[j] = btstack_crypto_cmac_x[j] ^ btstack_crypto_cmac_get_byte(btstack_crypto_cmac, (btstack_crypto_cmac_block_current*16u) + j);
 800d43e:	4a95      	ldr	r2, [pc, #596]	; (800d694 <btstack_crypto_cmac_handle_aes_engine_ready+0x284>)
 800d440:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d442:	4413      	add	r3, r2
 800d444:	781c      	ldrb	r4, [r3, #0]
 800d446:	4b94      	ldr	r3, [pc, #592]	; (800d698 <btstack_crypto_cmac_handle_aes_engine_ready+0x288>)
 800d448:	781b      	ldrb	r3, [r3, #0]
 800d44a:	b29b      	uxth	r3, r3
 800d44c:	011b      	lsls	r3, r3, #4
 800d44e:	b29a      	uxth	r2, r3
 800d450:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d452:	b29b      	uxth	r3, r3
 800d454:	4413      	add	r3, r2
 800d456:	b29b      	uxth	r3, r3
 800d458:	4619      	mov	r1, r3
 800d45a:	6878      	ldr	r0, [r7, #4]
 800d45c:	f7ff ff6f 	bl	800d33e <btstack_crypto_cmac_get_byte>
 800d460:	4603      	mov	r3, r0
 800d462:	4063      	eors	r3, r4
 800d464:	b2d9      	uxtb	r1, r3
 800d466:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 800d46a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d46c:	4413      	add	r3, r2
 800d46e:	460a      	mov	r2, r1
 800d470:	701a      	strb	r2, [r3, #0]
            for (j=0;j<16;j++){
 800d472:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d474:	3301      	adds	r3, #1
 800d476:	667b      	str	r3, [r7, #100]	; 0x64
 800d478:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d47a:	2b0f      	cmp	r3, #15
 800d47c:	dddf      	ble.n	800d43e <btstack_crypto_cmac_handle_aes_engine_ready+0x2e>
            }
            btstack_crypto_cmac_block_current++;
 800d47e:	4b86      	ldr	r3, [pc, #536]	; (800d698 <btstack_crypto_cmac_handle_aes_engine_ready+0x288>)
 800d480:	781b      	ldrb	r3, [r3, #0]
 800d482:	3301      	adds	r3, #1
 800d484:	b2da      	uxtb	r2, r3
 800d486:	4b84      	ldr	r3, [pc, #528]	; (800d698 <btstack_crypto_cmac_handle_aes_engine_ready+0x288>)
 800d488:	701a      	strb	r2, [r3, #0]
            btstack_crypto_cmac_next_state();
 800d48a:	f7ff ff97 	bl	800d3bc <btstack_crypto_cmac_next_state>
            btstack_crypto_aes128_start(btstack_crypto_cmac_k, y);
 800d48e:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800d492:	4619      	mov	r1, r3
 800d494:	487e      	ldr	r0, [pc, #504]	; (800d690 <btstack_crypto_cmac_handle_aes_engine_ready+0x280>)
 800d496:	f7ff ff6d 	bl	800d374 <btstack_crypto_aes128_start>
            break;
 800d49a:	bf00      	nop
 800d49c:	e0f0      	b.n	800d680 <btstack_crypto_cmac_handle_aes_engine_ready+0x270>
        }
        case CMAC_CALC_MLAST: {
            sm_key_t k1;
            (void)memcpy(k1, btstack_crypto_cmac_subkey, 16);
 800d49e:	4b7f      	ldr	r3, [pc, #508]	; (800d69c <btstack_crypto_cmac_handle_aes_engine_ready+0x28c>)
 800d4a0:	f107 043c 	add.w	r4, r7, #60	; 0x3c
 800d4a4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800d4a6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
            btstack_crypto_cmac_shift_left_by_one_bit_inplace(16, k1);
 800d4aa:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800d4ae:	4619      	mov	r1, r3
 800d4b0:	2010      	movs	r0, #16
 800d4b2:	f7ff ff15 	bl	800d2e0 <btstack_crypto_cmac_shift_left_by_one_bit_inplace>
            if (btstack_crypto_cmac_subkey[0u] & 0x80u){
 800d4b6:	4b79      	ldr	r3, [pc, #484]	; (800d69c <btstack_crypto_cmac_handle_aes_engine_ready+0x28c>)
 800d4b8:	781b      	ldrb	r3, [r3, #0]
 800d4ba:	b25b      	sxtb	r3, r3
 800d4bc:	2b00      	cmp	r3, #0
 800d4be:	da07      	bge.n	800d4d0 <btstack_crypto_cmac_handle_aes_engine_ready+0xc0>
                k1[15u] ^= 0x87u;
 800d4c0:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 800d4c4:	f083 0378 	eor.w	r3, r3, #120	; 0x78
 800d4c8:	43db      	mvns	r3, r3
 800d4ca:	b2db      	uxtb	r3, r3
 800d4cc:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
            }
            sm_key_t k2;
            (void)memcpy(k2, k1, 16);
 800d4d0:	f107 042c 	add.w	r4, r7, #44	; 0x2c
 800d4d4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800d4d8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800d4da:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
            btstack_crypto_cmac_shift_left_by_one_bit_inplace(16, k2);
 800d4de:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800d4e2:	4619      	mov	r1, r3
 800d4e4:	2010      	movs	r0, #16
 800d4e6:	f7ff fefb 	bl	800d2e0 <btstack_crypto_cmac_shift_left_by_one_bit_inplace>
            if (k1[0u] & 0x80u){
 800d4ea:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 800d4ee:	b25b      	sxtb	r3, r3
 800d4f0:	2b00      	cmp	r3, #0
 800d4f2:	da07      	bge.n	800d504 <btstack_crypto_cmac_handle_aes_engine_ready+0xf4>
                k2[15u] ^= 0x87u;
 800d4f4:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 800d4f8:	f083 0378 	eor.w	r3, r3, #120	; 0x78
 800d4fc:	43db      	mvns	r3, r3
 800d4fe:	b2db      	uxtb	r3, r3
 800d500:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
            }

            log_info_key("k", btstack_crypto_cmac_k);
 800d504:	4962      	ldr	r1, [pc, #392]	; (800d690 <btstack_crypto_cmac_handle_aes_engine_ready+0x280>)
 800d506:	4866      	ldr	r0, [pc, #408]	; (800d6a0 <btstack_crypto_cmac_handle_aes_engine_ready+0x290>)
 800d508:	f001 ff34 	bl	800f374 <log_info_key>
            log_info_key("k1", k1);
 800d50c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800d510:	4619      	mov	r1, r3
 800d512:	4864      	ldr	r0, [pc, #400]	; (800d6a4 <btstack_crypto_cmac_handle_aes_engine_ready+0x294>)
 800d514:	f001 ff2e 	bl	800f374 <log_info_key>
            log_info_key("k2", k2);
 800d518:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800d51c:	4619      	mov	r1, r3
 800d51e:	4862      	ldr	r0, [pc, #392]	; (800d6a8 <btstack_crypto_cmac_handle_aes_engine_ready+0x298>)
 800d520:	f001 ff28 	bl	800f374 <log_info_key>

            // step 4: set m_last
            int i;
            sm_key_t btstack_crypto_cmac_m_last;
            if (btstack_crypto_cmac_last_block_complete(btstack_crypto_cmac)){
 800d524:	6878      	ldr	r0, [r7, #4]
 800d526:	f7ff ff59 	bl	800d3dc <btstack_crypto_cmac_last_block_complete>
 800d52a:	4603      	mov	r3, r0
 800d52c:	2b00      	cmp	r3, #0
 800d52e:	d024      	beq.n	800d57a <btstack_crypto_cmac_handle_aes_engine_ready+0x16a>
                for (i=0;i<16;i++){
 800d530:	2300      	movs	r3, #0
 800d532:	663b      	str	r3, [r7, #96]	; 0x60
 800d534:	e01d      	b.n	800d572 <btstack_crypto_cmac_handle_aes_engine_ready+0x162>
                    btstack_crypto_cmac_m_last[i] = btstack_crypto_cmac_get_byte(btstack_crypto_cmac, btstack_crypto_cmac->size - 16u + i) ^ k1[i];
 800d536:	687b      	ldr	r3, [r7, #4]
 800d538:	8a9a      	ldrh	r2, [r3, #20]
 800d53a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d53c:	b29b      	uxth	r3, r3
 800d53e:	4413      	add	r3, r2
 800d540:	b29b      	uxth	r3, r3
 800d542:	3b10      	subs	r3, #16
 800d544:	b29b      	uxth	r3, r3
 800d546:	4619      	mov	r1, r3
 800d548:	6878      	ldr	r0, [r7, #4]
 800d54a:	f7ff fef8 	bl	800d33e <btstack_crypto_cmac_get_byte>
 800d54e:	4603      	mov	r3, r0
 800d550:	4619      	mov	r1, r3
 800d552:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 800d556:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d558:	4413      	add	r3, r2
 800d55a:	781b      	ldrb	r3, [r3, #0]
 800d55c:	404b      	eors	r3, r1
 800d55e:	b2d9      	uxtb	r1, r3
 800d560:	f107 021c 	add.w	r2, r7, #28
 800d564:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d566:	4413      	add	r3, r2
 800d568:	460a      	mov	r2, r1
 800d56a:	701a      	strb	r2, [r3, #0]
                for (i=0;i<16;i++){
 800d56c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d56e:	3301      	adds	r3, #1
 800d570:	663b      	str	r3, [r7, #96]	; 0x60
 800d572:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d574:	2b0f      	cmp	r3, #15
 800d576:	ddde      	ble.n	800d536 <btstack_crypto_cmac_handle_aes_engine_ready+0x126>
 800d578:	e04d      	b.n	800d616 <btstack_crypto_cmac_handle_aes_engine_ready+0x206>
                }
            } else {
                int valid_octets_in_last_block = btstack_crypto_cmac->size & 0x0fu;
 800d57a:	687b      	ldr	r3, [r7, #4]
 800d57c:	8a9b      	ldrh	r3, [r3, #20]
 800d57e:	f003 030f 	and.w	r3, r3, #15
 800d582:	65fb      	str	r3, [r7, #92]	; 0x5c
                for (i=0;i<16;i++){
 800d584:	2300      	movs	r3, #0
 800d586:	663b      	str	r3, [r7, #96]	; 0x60
 800d588:	e042      	b.n	800d610 <btstack_crypto_cmac_handle_aes_engine_ready+0x200>
                    if (i < valid_octets_in_last_block){
 800d58a:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800d58c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d58e:	429a      	cmp	r2, r3
 800d590:	da1c      	bge.n	800d5cc <btstack_crypto_cmac_handle_aes_engine_ready+0x1bc>
                        btstack_crypto_cmac_m_last[i] = btstack_crypto_cmac_get_byte(btstack_crypto_cmac, (btstack_crypto_cmac->size & 0xfff0u) + i) ^ k2[i];
 800d592:	687b      	ldr	r3, [r7, #4]
 800d594:	8a9b      	ldrh	r3, [r3, #20]
 800d596:	f023 030f 	bic.w	r3, r3, #15
 800d59a:	b29a      	uxth	r2, r3
 800d59c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d59e:	b29b      	uxth	r3, r3
 800d5a0:	4413      	add	r3, r2
 800d5a2:	b29b      	uxth	r3, r3
 800d5a4:	4619      	mov	r1, r3
 800d5a6:	6878      	ldr	r0, [r7, #4]
 800d5a8:	f7ff fec9 	bl	800d33e <btstack_crypto_cmac_get_byte>
 800d5ac:	4603      	mov	r3, r0
 800d5ae:	4619      	mov	r1, r3
 800d5b0:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800d5b4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d5b6:	4413      	add	r3, r2
 800d5b8:	781b      	ldrb	r3, [r3, #0]
 800d5ba:	404b      	eors	r3, r1
 800d5bc:	b2d9      	uxtb	r1, r3
 800d5be:	f107 021c 	add.w	r2, r7, #28
 800d5c2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d5c4:	4413      	add	r3, r2
 800d5c6:	460a      	mov	r2, r1
 800d5c8:	701a      	strb	r2, [r3, #0]
                        continue;
 800d5ca:	e01e      	b.n	800d60a <btstack_crypto_cmac_handle_aes_engine_ready+0x1fa>
                    }
                    if (i == valid_octets_in_last_block){
 800d5cc:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800d5ce:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d5d0:	429a      	cmp	r2, r3
 800d5d2:	d10f      	bne.n	800d5f4 <btstack_crypto_cmac_handle_aes_engine_ready+0x1e4>
                        btstack_crypto_cmac_m_last[i] = 0x80u ^ k2[i];
 800d5d4:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800d5d8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d5da:	4413      	add	r3, r2
 800d5dc:	781b      	ldrb	r3, [r3, #0]
 800d5de:	f083 037f 	eor.w	r3, r3, #127	; 0x7f
 800d5e2:	43db      	mvns	r3, r3
 800d5e4:	b2d9      	uxtb	r1, r3
 800d5e6:	f107 021c 	add.w	r2, r7, #28
 800d5ea:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d5ec:	4413      	add	r3, r2
 800d5ee:	460a      	mov	r2, r1
 800d5f0:	701a      	strb	r2, [r3, #0]
                        continue;
 800d5f2:	e00a      	b.n	800d60a <btstack_crypto_cmac_handle_aes_engine_ready+0x1fa>
                    }
                    btstack_crypto_cmac_m_last[i] = k2[i];
 800d5f4:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800d5f8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d5fa:	4413      	add	r3, r2
 800d5fc:	7819      	ldrb	r1, [r3, #0]
 800d5fe:	f107 021c 	add.w	r2, r7, #28
 800d602:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d604:	4413      	add	r3, r2
 800d606:	460a      	mov	r2, r1
 800d608:	701a      	strb	r2, [r3, #0]
                for (i=0;i<16;i++){
 800d60a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d60c:	3301      	adds	r3, #1
 800d60e:	663b      	str	r3, [r7, #96]	; 0x60
 800d610:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d612:	2b0f      	cmp	r3, #15
 800d614:	ddb9      	ble.n	800d58a <btstack_crypto_cmac_handle_aes_engine_ready+0x17a>
                }
            }
            sm_key_t y;
            for (i=0;i<16;i++){
 800d616:	2300      	movs	r3, #0
 800d618:	663b      	str	r3, [r7, #96]	; 0x60
 800d61a:	e013      	b.n	800d644 <btstack_crypto_cmac_handle_aes_engine_ready+0x234>
                y[i] = btstack_crypto_cmac_x[i] ^ btstack_crypto_cmac_m_last[i];
 800d61c:	4a1d      	ldr	r2, [pc, #116]	; (800d694 <btstack_crypto_cmac_handle_aes_engine_ready+0x284>)
 800d61e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d620:	4413      	add	r3, r2
 800d622:	781a      	ldrb	r2, [r3, #0]
 800d624:	f107 011c 	add.w	r1, r7, #28
 800d628:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d62a:	440b      	add	r3, r1
 800d62c:	781b      	ldrb	r3, [r3, #0]
 800d62e:	4053      	eors	r3, r2
 800d630:	b2d9      	uxtb	r1, r3
 800d632:	f107 020c 	add.w	r2, r7, #12
 800d636:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d638:	4413      	add	r3, r2
 800d63a:	460a      	mov	r2, r1
 800d63c:	701a      	strb	r2, [r3, #0]
            for (i=0;i<16;i++){
 800d63e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d640:	3301      	adds	r3, #1
 800d642:	663b      	str	r3, [r7, #96]	; 0x60
 800d644:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d646:	2b0f      	cmp	r3, #15
 800d648:	dde8      	ble.n	800d61c <btstack_crypto_cmac_handle_aes_engine_ready+0x20c>
            }
            btstack_crypto_cmac_block_current++;
 800d64a:	4b13      	ldr	r3, [pc, #76]	; (800d698 <btstack_crypto_cmac_handle_aes_engine_ready+0x288>)
 800d64c:	781b      	ldrb	r3, [r3, #0]
 800d64e:	3301      	adds	r3, #1
 800d650:	b2da      	uxtb	r2, r3
 800d652:	4b11      	ldr	r3, [pc, #68]	; (800d698 <btstack_crypto_cmac_handle_aes_engine_ready+0x288>)
 800d654:	701a      	strb	r2, [r3, #0]
            btstack_crypto_cmac_next_state();
 800d656:	f7ff feb1 	bl	800d3bc <btstack_crypto_cmac_next_state>
            btstack_crypto_aes128_start(btstack_crypto_cmac_k, y);
 800d65a:	f107 030c 	add.w	r3, r7, #12
 800d65e:	4619      	mov	r1, r3
 800d660:	480b      	ldr	r0, [pc, #44]	; (800d690 <btstack_crypto_cmac_handle_aes_engine_ready+0x280>)
 800d662:	f7ff fe87 	bl	800d374 <btstack_crypto_aes128_start>
            break;
 800d666:	bf00      	nop
 800d668:	e00a      	b.n	800d680 <btstack_crypto_cmac_handle_aes_engine_ready+0x270>
        }
        default:
            log_info("btstack_crypto_cmac_handle_aes_engine_ready called in state %u", btstack_crypto_cmac_state);
 800d66a:	4b07      	ldr	r3, [pc, #28]	; (800d688 <btstack_crypto_cmac_handle_aes_engine_ready+0x278>)
 800d66c:	781b      	ldrb	r3, [r3, #0]
 800d66e:	9300      	str	r3, [sp, #0]
 800d670:	f44f 73b4 	mov.w	r3, #360	; 0x168
 800d674:	4a0d      	ldr	r2, [pc, #52]	; (800d6ac <btstack_crypto_cmac_handle_aes_engine_ready+0x29c>)
 800d676:	490e      	ldr	r1, [pc, #56]	; (800d6b0 <btstack_crypto_cmac_handle_aes_engine_ready+0x2a0>)
 800d678:	2001      	movs	r0, #1
 800d67a:	f009 fee1 	bl	8017440 <hci_dump_log>
            break;
 800d67e:	bf00      	nop
    }
}
 800d680:	bf00      	nop
 800d682:	376c      	adds	r7, #108	; 0x6c
 800d684:	46bd      	mov	sp, r7
 800d686:	bd90      	pop	{r4, r7, pc}
 800d688:	20006184 	.word	0x20006184
 800d68c:	080309b4 	.word	0x080309b4
 800d690:	20006188 	.word	0x20006188
 800d694:	20006198 	.word	0x20006198
 800d698:	200061b8 	.word	0x200061b8
 800d69c:	200061a8 	.word	0x200061a8
 800d6a0:	08028fac 	.word	0x08028fac
 800d6a4:	08028fb0 	.word	0x08028fb0
 800d6a8:	08028fb4 	.word	0x08028fb4
 800d6ac:	08028fb8 	.word	0x08028fb8
 800d6b0:	08028fcc 	.word	0x08028fcc

0800d6b4 <btstack_crypto_cmac_handle_encryption_result>:

static void btstack_crypto_cmac_handle_encryption_result(btstack_crypto_aes128_cmac_t * btstack_crypto_cmac, sm_key_t data){
 800d6b4:	b590      	push	{r4, r7, lr}
 800d6b6:	b085      	sub	sp, #20
 800d6b8:	af02      	add	r7, sp, #8
 800d6ba:	6078      	str	r0, [r7, #4]
 800d6bc:	6039      	str	r1, [r7, #0]
    switch (btstack_crypto_cmac_state){
 800d6be:	4b31      	ldr	r3, [pc, #196]	; (800d784 <btstack_crypto_cmac_handle_encryption_result+0xd0>)
 800d6c0:	781b      	ldrb	r3, [r3, #0]
 800d6c2:	2b04      	cmp	r3, #4
 800d6c4:	d019      	beq.n	800d6fa <btstack_crypto_cmac_handle_encryption_result+0x46>
 800d6c6:	2b06      	cmp	r3, #6
 800d6c8:	d02d      	beq.n	800d726 <btstack_crypto_cmac_handle_encryption_result+0x72>
 800d6ca:	2b02      	cmp	r3, #2
 800d6cc:	d14a      	bne.n	800d764 <btstack_crypto_cmac_handle_encryption_result+0xb0>
        case CMAC_W4_SUBKEYS:
            (void)memcpy(btstack_crypto_cmac_subkey, data, 16);
 800d6ce:	4a2e      	ldr	r2, [pc, #184]	; (800d788 <btstack_crypto_cmac_handle_encryption_result+0xd4>)
 800d6d0:	683b      	ldr	r3, [r7, #0]
 800d6d2:	4614      	mov	r4, r2
 800d6d4:	6818      	ldr	r0, [r3, #0]
 800d6d6:	6859      	ldr	r1, [r3, #4]
 800d6d8:	689a      	ldr	r2, [r3, #8]
 800d6da:	68db      	ldr	r3, [r3, #12]
 800d6dc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
            // next
            btstack_crypto_cmac_state = (btstack_crypto_cmac_block_current < (btstack_crypto_cmac_block_count - 1u)) ? CMAC_CALC_MI : CMAC_CALC_MLAST;
 800d6de:	4b2b      	ldr	r3, [pc, #172]	; (800d78c <btstack_crypto_cmac_handle_encryption_result+0xd8>)
 800d6e0:	781b      	ldrb	r3, [r3, #0]
 800d6e2:	461a      	mov	r2, r3
 800d6e4:	4b2a      	ldr	r3, [pc, #168]	; (800d790 <btstack_crypto_cmac_handle_encryption_result+0xdc>)
 800d6e6:	781b      	ldrb	r3, [r3, #0]
 800d6e8:	3b01      	subs	r3, #1
 800d6ea:	429a      	cmp	r2, r3
 800d6ec:	d201      	bcs.n	800d6f2 <btstack_crypto_cmac_handle_encryption_result+0x3e>
 800d6ee:	2203      	movs	r2, #3
 800d6f0:	e000      	b.n	800d6f4 <btstack_crypto_cmac_handle_encryption_result+0x40>
 800d6f2:	2205      	movs	r2, #5
 800d6f4:	4b23      	ldr	r3, [pc, #140]	; (800d784 <btstack_crypto_cmac_handle_encryption_result+0xd0>)
 800d6f6:	701a      	strb	r2, [r3, #0]
            break;
 800d6f8:	e03f      	b.n	800d77a <btstack_crypto_cmac_handle_encryption_result+0xc6>
        case CMAC_W4_MI:
            (void)memcpy(btstack_crypto_cmac_x, data, 16);
 800d6fa:	4a26      	ldr	r2, [pc, #152]	; (800d794 <btstack_crypto_cmac_handle_encryption_result+0xe0>)
 800d6fc:	683b      	ldr	r3, [r7, #0]
 800d6fe:	4614      	mov	r4, r2
 800d700:	6818      	ldr	r0, [r3, #0]
 800d702:	6859      	ldr	r1, [r3, #4]
 800d704:	689a      	ldr	r2, [r3, #8]
 800d706:	68db      	ldr	r3, [r3, #12]
 800d708:	c40f      	stmia	r4!, {r0, r1, r2, r3}
            btstack_crypto_cmac_state = (btstack_crypto_cmac_block_current < (btstack_crypto_cmac_block_count - 1u)) ? CMAC_CALC_MI : CMAC_CALC_MLAST;
 800d70a:	4b20      	ldr	r3, [pc, #128]	; (800d78c <btstack_crypto_cmac_handle_encryption_result+0xd8>)
 800d70c:	781b      	ldrb	r3, [r3, #0]
 800d70e:	461a      	mov	r2, r3
 800d710:	4b1f      	ldr	r3, [pc, #124]	; (800d790 <btstack_crypto_cmac_handle_encryption_result+0xdc>)
 800d712:	781b      	ldrb	r3, [r3, #0]
 800d714:	3b01      	subs	r3, #1
 800d716:	429a      	cmp	r2, r3
 800d718:	d201      	bcs.n	800d71e <btstack_crypto_cmac_handle_encryption_result+0x6a>
 800d71a:	2203      	movs	r2, #3
 800d71c:	e000      	b.n	800d720 <btstack_crypto_cmac_handle_encryption_result+0x6c>
 800d71e:	2205      	movs	r2, #5
 800d720:	4b18      	ldr	r3, [pc, #96]	; (800d784 <btstack_crypto_cmac_handle_encryption_result+0xd0>)
 800d722:	701a      	strb	r2, [r3, #0]
            break;
 800d724:	e029      	b.n	800d77a <btstack_crypto_cmac_handle_encryption_result+0xc6>
        case CMAC_W4_MLAST:
            // done
            log_info("Setting CMAC Engine to IDLE");
 800d726:	f44f 73bd 	mov.w	r3, #378	; 0x17a
 800d72a:	4a1b      	ldr	r2, [pc, #108]	; (800d798 <btstack_crypto_cmac_handle_encryption_result+0xe4>)
 800d72c:	491b      	ldr	r1, [pc, #108]	; (800d79c <btstack_crypto_cmac_handle_encryption_result+0xe8>)
 800d72e:	2001      	movs	r0, #1
 800d730:	f009 fe86 	bl	8017440 <hci_dump_log>
            btstack_crypto_cmac_state = CMAC_IDLE;
 800d734:	4b13      	ldr	r3, [pc, #76]	; (800d784 <btstack_crypto_cmac_handle_encryption_result+0xd0>)
 800d736:	2200      	movs	r2, #0
 800d738:	701a      	strb	r2, [r3, #0]
            log_info_key("CMAC", data);
 800d73a:	6839      	ldr	r1, [r7, #0]
 800d73c:	4818      	ldr	r0, [pc, #96]	; (800d7a0 <btstack_crypto_cmac_handle_encryption_result+0xec>)
 800d73e:	f001 fe19 	bl	800f374 <log_info_key>
            (void)memcpy(btstack_crypto_cmac->hash, data, 16);
 800d742:	687b      	ldr	r3, [r7, #4]
 800d744:	69db      	ldr	r3, [r3, #28]
 800d746:	2210      	movs	r2, #16
 800d748:	6839      	ldr	r1, [r7, #0]
 800d74a:	4618      	mov	r0, r3
 800d74c:	f01a f995 	bl	8027a7a <memcpy>
			btstack_linked_list_pop(&btstack_crypto_operations);
 800d750:	4814      	ldr	r0, [pc, #80]	; (800d7a4 <btstack_crypto_cmac_handle_encryption_result+0xf0>)
 800d752:	f000 ffe5 	bl	800e720 <btstack_linked_list_pop>
			(*btstack_crypto_cmac->btstack_crypto.context_callback.callback)(btstack_crypto_cmac->btstack_crypto.context_callback.context);
 800d756:	687b      	ldr	r3, [r7, #4]
 800d758:	685b      	ldr	r3, [r3, #4]
 800d75a:	687a      	ldr	r2, [r7, #4]
 800d75c:	6892      	ldr	r2, [r2, #8]
 800d75e:	4610      	mov	r0, r2
 800d760:	4798      	blx	r3
            break;
 800d762:	e00a      	b.n	800d77a <btstack_crypto_cmac_handle_encryption_result+0xc6>
        default:
            log_info("btstack_crypto_cmac_handle_encryption_result called in state %u", btstack_crypto_cmac_state);
 800d764:	4b07      	ldr	r3, [pc, #28]	; (800d784 <btstack_crypto_cmac_handle_encryption_result+0xd0>)
 800d766:	781b      	ldrb	r3, [r3, #0]
 800d768:	9300      	str	r3, [sp, #0]
 800d76a:	f44f 73c1 	mov.w	r3, #386	; 0x182
 800d76e:	4a0a      	ldr	r2, [pc, #40]	; (800d798 <btstack_crypto_cmac_handle_encryption_result+0xe4>)
 800d770:	490d      	ldr	r1, [pc, #52]	; (800d7a8 <btstack_crypto_cmac_handle_encryption_result+0xf4>)
 800d772:	2001      	movs	r0, #1
 800d774:	f009 fe64 	bl	8017440 <hci_dump_log>
            break;
 800d778:	bf00      	nop
    }
}
 800d77a:	bf00      	nop
 800d77c:	370c      	adds	r7, #12
 800d77e:	46bd      	mov	sp, r7
 800d780:	bd90      	pop	{r4, r7, pc}
 800d782:	bf00      	nop
 800d784:	20006184 	.word	0x20006184
 800d788:	200061a8 	.word	0x200061a8
 800d78c:	200061b8 	.word	0x200061b8
 800d790:	200061b9 	.word	0x200061b9
 800d794:	20006198 	.word	0x20006198
 800d798:	08028fb8 	.word	0x08028fb8
 800d79c:	08029014 	.word	0x08029014
 800d7a0:	08029038 	.word	0x08029038
 800d7a4:	20006178 	.word	0x20006178
 800d7a8:	08029040 	.word	0x08029040

0800d7ac <btstack_crypto_cmac_start>:

static void btstack_crypto_cmac_start(btstack_crypto_aes128_cmac_t * btstack_crypto_cmac){
 800d7ac:	b590      	push	{r4, r7, lr}
 800d7ae:	b085      	sub	sp, #20
 800d7b0:	af02      	add	r7, sp, #8
 800d7b2:	6078      	str	r0, [r7, #4]

    (void)memcpy(btstack_crypto_cmac_k, btstack_crypto_cmac->key, 16);
 800d7b4:	687b      	ldr	r3, [r7, #4]
 800d7b6:	691b      	ldr	r3, [r3, #16]
 800d7b8:	4a1a      	ldr	r2, [pc, #104]	; (800d824 <btstack_crypto_cmac_start+0x78>)
 800d7ba:	4614      	mov	r4, r2
 800d7bc:	6818      	ldr	r0, [r3, #0]
 800d7be:	6859      	ldr	r1, [r3, #4]
 800d7c0:	689a      	ldr	r2, [r3, #8]
 800d7c2:	68db      	ldr	r3, [r3, #12]
 800d7c4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    memset(btstack_crypto_cmac_x, 0, 16);
 800d7c6:	2210      	movs	r2, #16
 800d7c8:	2100      	movs	r1, #0
 800d7ca:	4817      	ldr	r0, [pc, #92]	; (800d828 <btstack_crypto_cmac_start+0x7c>)
 800d7cc:	f01a f979 	bl	8027ac2 <memset>
    btstack_crypto_cmac_block_current = 0;
 800d7d0:	4b16      	ldr	r3, [pc, #88]	; (800d82c <btstack_crypto_cmac_start+0x80>)
 800d7d2:	2200      	movs	r2, #0
 800d7d4:	701a      	strb	r2, [r3, #0]

    // step 2: n := ceil(len/const_Bsize);
    btstack_crypto_cmac_block_count = (btstack_crypto_cmac->size + 15u) / 16u;
 800d7d6:	687b      	ldr	r3, [r7, #4]
 800d7d8:	8a9b      	ldrh	r3, [r3, #20]
 800d7da:	330f      	adds	r3, #15
 800d7dc:	091b      	lsrs	r3, r3, #4
 800d7de:	b2da      	uxtb	r2, r3
 800d7e0:	4b13      	ldr	r3, [pc, #76]	; (800d830 <btstack_crypto_cmac_start+0x84>)
 800d7e2:	701a      	strb	r2, [r3, #0]

    // step 3: ..
    if (btstack_crypto_cmac_block_count==0u){
 800d7e4:	4b12      	ldr	r3, [pc, #72]	; (800d830 <btstack_crypto_cmac_start+0x84>)
 800d7e6:	781b      	ldrb	r3, [r3, #0]
 800d7e8:	2b00      	cmp	r3, #0
 800d7ea:	d102      	bne.n	800d7f2 <btstack_crypto_cmac_start+0x46>
        btstack_crypto_cmac_block_count = 1;
 800d7ec:	4b10      	ldr	r3, [pc, #64]	; (800d830 <btstack_crypto_cmac_start+0x84>)
 800d7ee:	2201      	movs	r2, #1
 800d7f0:	701a      	strb	r2, [r3, #0]
    }
    log_info("btstack_crypto_cmac_start: len %u, block count %u", btstack_crypto_cmac->size, btstack_crypto_cmac_block_count);
 800d7f2:	687b      	ldr	r3, [r7, #4]
 800d7f4:	8a9b      	ldrh	r3, [r3, #20]
 800d7f6:	461a      	mov	r2, r3
 800d7f8:	4b0d      	ldr	r3, [pc, #52]	; (800d830 <btstack_crypto_cmac_start+0x84>)
 800d7fa:	781b      	ldrb	r3, [r3, #0]
 800d7fc:	9301      	str	r3, [sp, #4]
 800d7fe:	9200      	str	r2, [sp, #0]
 800d800:	f44f 73ca 	mov.w	r3, #404	; 0x194
 800d804:	4a0b      	ldr	r2, [pc, #44]	; (800d834 <btstack_crypto_cmac_start+0x88>)
 800d806:	490c      	ldr	r1, [pc, #48]	; (800d838 <btstack_crypto_cmac_start+0x8c>)
 800d808:	2001      	movs	r0, #1
 800d80a:	f009 fe19 	bl	8017440 <hci_dump_log>

    // first, we need to compute l for k1, k2, and m_last
    btstack_crypto_cmac_state = CMAC_CALC_SUBKEYS;
 800d80e:	4b0b      	ldr	r3, [pc, #44]	; (800d83c <btstack_crypto_cmac_start+0x90>)
 800d810:	2201      	movs	r2, #1
 800d812:	701a      	strb	r2, [r3, #0]

    // let's go
    btstack_crypto_cmac_handle_aes_engine_ready(btstack_crypto_cmac);
 800d814:	6878      	ldr	r0, [r7, #4]
 800d816:	f7ff fdfb 	bl	800d410 <btstack_crypto_cmac_handle_aes_engine_ready>
}
 800d81a:	bf00      	nop
 800d81c:	370c      	adds	r7, #12
 800d81e:	46bd      	mov	sp, r7
 800d820:	bd90      	pop	{r4, r7, pc}
 800d822:	bf00      	nop
 800d824:	20006188 	.word	0x20006188
 800d828:	20006198 	.word	0x20006198
 800d82c:	200061b8 	.word	0x200061b8
 800d830:	200061b9 	.word	0x200061b9
 800d834:	08028fb8 	.word	0x08028fb8
 800d838:	08029088 	.word	0x08029088
 800d83c:	20006184 	.word	0x20006184

0800d840 <btstack_crypto_ccm_setup_a_i>:
  6            Reserved (always zero)
  5 ... 3      Zero
  2 ... 0      L'
*/

static void btstack_crypto_ccm_setup_a_i(btstack_crypto_ccm_t * btstack_crypto_ccm, uint16_t counter){
 800d840:	b580      	push	{r7, lr}
 800d842:	b082      	sub	sp, #8
 800d844:	af00      	add	r7, sp, #0
 800d846:	6078      	str	r0, [r7, #4]
 800d848:	460b      	mov	r3, r1
 800d84a:	807b      	strh	r3, [r7, #2]
    btstack_crypto_ccm_s[0] = 1;  // L' = L - 1
 800d84c:	4b09      	ldr	r3, [pc, #36]	; (800d874 <btstack_crypto_ccm_setup_a_i+0x34>)
 800d84e:	2201      	movs	r2, #1
 800d850:	701a      	strb	r2, [r3, #0]
    (void)memcpy(&btstack_crypto_ccm_s[1], btstack_crypto_ccm->nonce, 13);
 800d852:	687b      	ldr	r3, [r7, #4]
 800d854:	699b      	ldr	r3, [r3, #24]
 800d856:	220d      	movs	r2, #13
 800d858:	4619      	mov	r1, r3
 800d85a:	4807      	ldr	r0, [pc, #28]	; (800d878 <btstack_crypto_ccm_setup_a_i+0x38>)
 800d85c:	f01a f90d 	bl	8027a7a <memcpy>
    big_endian_store_16(btstack_crypto_ccm_s, 14, counter);
 800d860:	887b      	ldrh	r3, [r7, #2]
 800d862:	461a      	mov	r2, r3
 800d864:	210e      	movs	r1, #14
 800d866:	4803      	ldr	r0, [pc, #12]	; (800d874 <btstack_crypto_ccm_setup_a_i+0x34>)
 800d868:	f001 fb93 	bl	800ef92 <big_endian_store_16>
#ifdef DEBUG_CCM
    printf("btstack_crypto_ccm_setup_a_%u\n", counter);
    printf("%16s: ", "ai");
    printf_hexdump(btstack_crypto_ccm_s, 16);
#endif
}
 800d86c:	bf00      	nop
 800d86e:	3708      	adds	r7, #8
 800d870:	46bd      	mov	sp, r7
 800d872:	bd80      	pop	{r7, pc}
 800d874:	200061bc 	.word	0x200061bc
 800d878:	200061bd 	.word	0x200061bd

0800d87c <btstack_crypto_ccm_setup_b_0>:
      6            Adata
      5 ... 3      M'
      2 ... 0      L'
 */

static void btstack_crypto_ccm_setup_b_0(btstack_crypto_ccm_t * btstack_crypto_ccm, uint8_t * b0){
 800d87c:	b580      	push	{r7, lr}
 800d87e:	b084      	sub	sp, #16
 800d880:	af00      	add	r7, sp, #0
 800d882:	6078      	str	r0, [r7, #4]
 800d884:	6039      	str	r1, [r7, #0]
    uint8_t m_prime = (btstack_crypto_ccm->auth_len - 2u) / 2u;
 800d886:	687b      	ldr	r3, [r7, #4]
 800d888:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 800d88c:	3b02      	subs	r3, #2
 800d88e:	085b      	lsrs	r3, r3, #1
 800d890:	73fb      	strb	r3, [r7, #15]
    uint8_t Adata   = btstack_crypto_ccm->aad_len ? 1 : 0;
 800d892:	687b      	ldr	r3, [r7, #4]
 800d894:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d896:	2b00      	cmp	r3, #0
 800d898:	bf14      	ite	ne
 800d89a:	2301      	movne	r3, #1
 800d89c:	2300      	moveq	r3, #0
 800d89e:	b2db      	uxtb	r3, r3
 800d8a0:	73bb      	strb	r3, [r7, #14]
    b0[0u] = (Adata << 6u) | (m_prime << 3u) | 1u ;  // Adata, M', L' = L - 1
 800d8a2:	7bbb      	ldrb	r3, [r7, #14]
 800d8a4:	019b      	lsls	r3, r3, #6
 800d8a6:	b25a      	sxtb	r2, r3
 800d8a8:	7bfb      	ldrb	r3, [r7, #15]
 800d8aa:	00db      	lsls	r3, r3, #3
 800d8ac:	b25b      	sxtb	r3, r3
 800d8ae:	4313      	orrs	r3, r2
 800d8b0:	b25b      	sxtb	r3, r3
 800d8b2:	b2db      	uxtb	r3, r3
 800d8b4:	f043 0301 	orr.w	r3, r3, #1
 800d8b8:	b2da      	uxtb	r2, r3
 800d8ba:	683b      	ldr	r3, [r7, #0]
 800d8bc:	701a      	strb	r2, [r3, #0]
    (void)memcpy(&b0[1], btstack_crypto_ccm->nonce, 13);
 800d8be:	683b      	ldr	r3, [r7, #0]
 800d8c0:	1c58      	adds	r0, r3, #1
 800d8c2:	687b      	ldr	r3, [r7, #4]
 800d8c4:	699b      	ldr	r3, [r3, #24]
 800d8c6:	220d      	movs	r2, #13
 800d8c8:	4619      	mov	r1, r3
 800d8ca:	f01a f8d6 	bl	8027a7a <memcpy>
    big_endian_store_16(b0, 14, btstack_crypto_ccm->message_len);
 800d8ce:	687b      	ldr	r3, [r7, #4]
 800d8d0:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800d8d2:	461a      	mov	r2, r3
 800d8d4:	210e      	movs	r1, #14
 800d8d6:	6838      	ldr	r0, [r7, #0]
 800d8d8:	f001 fb5b 	bl	800ef92 <big_endian_store_16>
#ifdef DEBUG_CCM
    printf("%16s: ", "B0");
    printf_hexdump(b0, 16);
#endif
}
 800d8dc:	bf00      	nop
 800d8de:	3710      	adds	r7, #16
 800d8e0:	46bd      	mov	sp, r7
 800d8e2:	bd80      	pop	{r7, pc}

0800d8e4 <btstack_crypto_log_ec_publickey>:

#ifdef ENABLE_ECC_P256

static void btstack_crypto_log_ec_publickey(const uint8_t * ec_q){
 800d8e4:	b580      	push	{r7, lr}
 800d8e6:	b082      	sub	sp, #8
 800d8e8:	af00      	add	r7, sp, #0
 800d8ea:	6078      	str	r0, [r7, #4]
    log_info("Elliptic curve: X");
 800d8ec:	f240 13e7 	movw	r3, #487	; 0x1e7
 800d8f0:	4a0c      	ldr	r2, [pc, #48]	; (800d924 <btstack_crypto_log_ec_publickey+0x40>)
 800d8f2:	490d      	ldr	r1, [pc, #52]	; (800d928 <btstack_crypto_log_ec_publickey+0x44>)
 800d8f4:	2001      	movs	r0, #1
 800d8f6:	f009 fda3 	bl	8017440 <hci_dump_log>
    log_info_hexdump(&ec_q[0],32);
 800d8fa:	2120      	movs	r1, #32
 800d8fc:	6878      	ldr	r0, [r7, #4]
 800d8fe:	f001 fd2b 	bl	800f358 <log_info_hexdump>
    log_info("Elliptic curve: Y");
 800d902:	f240 13e9 	movw	r3, #489	; 0x1e9
 800d906:	4a07      	ldr	r2, [pc, #28]	; (800d924 <btstack_crypto_log_ec_publickey+0x40>)
 800d908:	4908      	ldr	r1, [pc, #32]	; (800d92c <btstack_crypto_log_ec_publickey+0x48>)
 800d90a:	2001      	movs	r0, #1
 800d90c:	f009 fd98 	bl	8017440 <hci_dump_log>
    log_info_hexdump(&ec_q[32],32);
 800d910:	687b      	ldr	r3, [r7, #4]
 800d912:	3320      	adds	r3, #32
 800d914:	2120      	movs	r1, #32
 800d916:	4618      	mov	r0, r3
 800d918:	f001 fd1e 	bl	800f358 <log_info_hexdump>
}
 800d91c:	bf00      	nop
 800d91e:	3708      	adds	r7, #8
 800d920:	46bd      	mov	sp, r7
 800d922:	bd80      	pop	{r7, pc}
 800d924:	08028fb8 	.word	0x08028fb8
 800d928:	080290c4 	.word	0x080290c4
 800d92c:	080290e0 	.word	0x080290e0

0800d930 <sm_generate_f_rng>:

#if (defined(USE_MICRO_ECC_P256) && !defined(WICED_VERSION)) || defined(USE_MBEDTLS_ECC_P256)
// @return OK
static int sm_generate_f_rng(unsigned char * buffer, unsigned size){
 800d930:	b580      	push	{r7, lr}
 800d932:	b084      	sub	sp, #16
 800d934:	af02      	add	r7, sp, #8
 800d936:	6078      	str	r0, [r7, #4]
 800d938:	6039      	str	r1, [r7, #0]
    if (btstack_crypto_ecc_p256_key_generation_state != ECC_P256_KEY_GENERATION_ACTIVE) return 0;
 800d93a:	4b15      	ldr	r3, [pc, #84]	; (800d990 <sm_generate_f_rng+0x60>)
 800d93c:	781b      	ldrb	r3, [r3, #0]
 800d93e:	2b02      	cmp	r3, #2
 800d940:	d001      	beq.n	800d946 <sm_generate_f_rng+0x16>
 800d942:	2300      	movs	r3, #0
 800d944:	e020      	b.n	800d988 <sm_generate_f_rng+0x58>
    log_info("sm_generate_f_rng: size %u - offset %u", (int) size, btstack_crypto_ecc_p256_random_offset);
 800d946:	683b      	ldr	r3, [r7, #0]
 800d948:	4a12      	ldr	r2, [pc, #72]	; (800d994 <sm_generate_f_rng+0x64>)
 800d94a:	7812      	ldrb	r2, [r2, #0]
 800d94c:	9201      	str	r2, [sp, #4]
 800d94e:	9300      	str	r3, [sp, #0]
 800d950:	f240 13f1 	movw	r3, #497	; 0x1f1
 800d954:	4a10      	ldr	r2, [pc, #64]	; (800d998 <sm_generate_f_rng+0x68>)
 800d956:	4911      	ldr	r1, [pc, #68]	; (800d99c <sm_generate_f_rng+0x6c>)
 800d958:	2001      	movs	r0, #1
 800d95a:	f009 fd71 	bl	8017440 <hci_dump_log>
    while (size) {
 800d95e:	e00f      	b.n	800d980 <sm_generate_f_rng+0x50>
        *buffer++ = btstack_crypto_ecc_p256_random[btstack_crypto_ecc_p256_random_offset++];
 800d960:	4b0c      	ldr	r3, [pc, #48]	; (800d994 <sm_generate_f_rng+0x64>)
 800d962:	781b      	ldrb	r3, [r3, #0]
 800d964:	1c5a      	adds	r2, r3, #1
 800d966:	b2d1      	uxtb	r1, r2
 800d968:	4a0a      	ldr	r2, [pc, #40]	; (800d994 <sm_generate_f_rng+0x64>)
 800d96a:	7011      	strb	r1, [r2, #0]
 800d96c:	4619      	mov	r1, r3
 800d96e:	687b      	ldr	r3, [r7, #4]
 800d970:	1c5a      	adds	r2, r3, #1
 800d972:	607a      	str	r2, [r7, #4]
 800d974:	4a0a      	ldr	r2, [pc, #40]	; (800d9a0 <sm_generate_f_rng+0x70>)
 800d976:	5c52      	ldrb	r2, [r2, r1]
 800d978:	701a      	strb	r2, [r3, #0]
        size--;
 800d97a:	683b      	ldr	r3, [r7, #0]
 800d97c:	3b01      	subs	r3, #1
 800d97e:	603b      	str	r3, [r7, #0]
    while (size) {
 800d980:	683b      	ldr	r3, [r7, #0]
 800d982:	2b00      	cmp	r3, #0
 800d984:	d1ec      	bne.n	800d960 <sm_generate_f_rng+0x30>
    }
    return 1;
 800d986:	2301      	movs	r3, #1
}
 800d988:	4618      	mov	r0, r3
 800d98a:	3708      	adds	r7, #8
 800d98c:	46bd      	mov	sp, r7
 800d98e:	bd80      	pop	{r7, pc}
 800d990:	2000624e 	.word	0x2000624e
 800d994:	2000624d 	.word	0x2000624d
 800d998:	08028fb8 	.word	0x08028fb8
 800d99c:	080290fc 	.word	0x080290fc
 800d9a0:	2000620c 	.word	0x2000620c

0800d9a4 <btstack_crypto_ecc_p256_generate_key_software>:
    UNUSED(context);
    return sm_generate_f_rng(buffer, size) == 0;
}
#endif /* USE_MBEDTLS_ECC_P256 */

static void btstack_crypto_ecc_p256_generate_key_software(void){
 800d9a4:	b580      	push	{r7, lr}
 800d9a6:	af00      	add	r7, sp, #0

    btstack_crypto_ecc_p256_random_offset = 0;
 800d9a8:	4b09      	ldr	r3, [pc, #36]	; (800d9d0 <btstack_crypto_ecc_p256_generate_key_software+0x2c>)
 800d9aa:	2200      	movs	r2, #0
 800d9ac:	701a      	strb	r2, [r3, #0]
    
    // generate EC key
#ifdef USE_MICRO_ECC_P256

#ifndef WICED_VERSION
    log_info("set uECC RNG for initial key generation with 64 random bytes");
 800d9ae:	f240 2309 	movw	r3, #521	; 0x209
 800d9b2:	4a08      	ldr	r2, [pc, #32]	; (800d9d4 <btstack_crypto_ecc_p256_generate_key_software+0x30>)
 800d9b4:	4908      	ldr	r1, [pc, #32]	; (800d9d8 <btstack_crypto_ecc_p256_generate_key_software+0x34>)
 800d9b6:	2001      	movs	r0, #1
 800d9b8:	f009 fd42 	bl	8017440 <hci_dump_log>
    // micro-ecc from WICED SDK uses its wiced_crypto_get_random by default - no need to set it
    uECC_set_rng(&sm_generate_f_rng);
 800d9bc:	4807      	ldr	r0, [pc, #28]	; (800d9dc <btstack_crypto_ecc_p256_generate_key_software+0x38>)
 800d9be:	f7fc ffc1 	bl	800a944 <uECC_set_rng>
    // disable RNG again, as returning no randmon data lets shared key generation fail
    log_info("disable uECC RNG in standard version after key generation");
    uECC_set_rng(NULL);
#else
    // static version
    uECC_make_key(btstack_crypto_ecc_p256_public_key, btstack_crypto_ecc_p256_d);
 800d9c2:	4907      	ldr	r1, [pc, #28]	; (800d9e0 <btstack_crypto_ecc_p256_generate_key_software+0x3c>)
 800d9c4:	4807      	ldr	r0, [pc, #28]	; (800d9e4 <btstack_crypto_ecc_p256_generate_key_software+0x40>)
 800d9c6:	f7fe f8d5 	bl	800bb74 <uECC_make_key>
    mbedtls_mpi_write_binary(&P.Y, &btstack_crypto_ecc_p256_public_key[32], 32);
    mbedtls_mpi_write_binary(&d, btstack_crypto_ecc_p256_d, 32);
    mbedtls_ecp_point_free(&P);
    mbedtls_mpi_free(&d);
#endif  /* USE_MBEDTLS_ECC_P256 */
}
 800d9ca:	bf00      	nop
 800d9cc:	bd80      	pop	{r7, pc}
 800d9ce:	bf00      	nop
 800d9d0:	2000624d 	.word	0x2000624d
 800d9d4:	08028fb8 	.word	0x08028fb8
 800d9d8:	0802912c 	.word	0x0802912c
 800d9dc:	0800d931 	.word	0x0800d931
 800d9e0:	20006250 	.word	0x20006250
 800d9e4:	200061cc 	.word	0x200061cc

0800d9e8 <btstack_crypto_ecc_p256_calculate_dhkey_software>:

#ifdef USE_SOFTWARE_ECC_P256_IMPLEMENTATION
static void btstack_crypto_ecc_p256_calculate_dhkey_software(btstack_crypto_ecc_p256_t * btstack_crypto_ec_p192){
 800d9e8:	b580      	push	{r7, lr}
 800d9ea:	b082      	sub	sp, #8
 800d9ec:	af00      	add	r7, sp, #0
 800d9ee:	6078      	str	r0, [r7, #4]
    memset(btstack_crypto_ec_p192->dhkey, 0, 32);
 800d9f0:	687b      	ldr	r3, [r7, #4]
 800d9f2:	695b      	ldr	r3, [r3, #20]
 800d9f4:	2220      	movs	r2, #32
 800d9f6:	2100      	movs	r1, #0
 800d9f8:	4618      	mov	r0, r3
 800d9fa:	f01a f862 	bl	8027ac2 <memset>
#if uECC_SUPPORTS_secp256r1
    // standard version
    uECC_shared_secret(btstack_crypto_ec_p192->public_key, btstack_crypto_ecc_p256_d, btstack_crypto_ec_p192->dhkey, uECC_secp256r1());
#else
    // static version
    uECC_shared_secret(btstack_crypto_ec_p192->public_key, btstack_crypto_ecc_p256_d, btstack_crypto_ec_p192->dhkey);
 800d9fe:	687b      	ldr	r3, [r7, #4]
 800da00:	6918      	ldr	r0, [r3, #16]
 800da02:	687b      	ldr	r3, [r7, #4]
 800da04:	695b      	ldr	r3, [r3, #20]
 800da06:	461a      	mov	r2, r3
 800da08:	4909      	ldr	r1, [pc, #36]	; (800da30 <btstack_crypto_ecc_p256_calculate_dhkey_software+0x48>)
 800da0a:	f7fe f8f5 	bl	800bbf8 <uECC_shared_secret>
    mbedtls_ecp_point_free(&DH);
    mbedtls_mpi_free(&d);
    mbedtls_ecp_point_free(&Q);
#endif

    log_info("dhkey");
 800da0e:	f240 234b 	movw	r3, #587	; 0x24b
 800da12:	4a08      	ldr	r2, [pc, #32]	; (800da34 <btstack_crypto_ecc_p256_calculate_dhkey_software+0x4c>)
 800da14:	4908      	ldr	r1, [pc, #32]	; (800da38 <btstack_crypto_ecc_p256_calculate_dhkey_software+0x50>)
 800da16:	2001      	movs	r0, #1
 800da18:	f009 fd12 	bl	8017440 <hci_dump_log>
    log_info_hexdump(btstack_crypto_ec_p192->dhkey, 32);
 800da1c:	687b      	ldr	r3, [r7, #4]
 800da1e:	695b      	ldr	r3, [r3, #20]
 800da20:	2120      	movs	r1, #32
 800da22:	4618      	mov	r0, r3
 800da24:	f001 fc98 	bl	800f358 <log_info_hexdump>
}
 800da28:	bf00      	nop
 800da2a:	3708      	adds	r7, #8
 800da2c:	46bd      	mov	sp, r7
 800da2e:	bd80      	pop	{r7, pc}
 800da30:	20006250 	.word	0x20006250
 800da34:	08028fb8 	.word	0x08028fb8
 800da38:	08029170 	.word	0x08029170

0800da3c <btstack_crypto_ccm_next_block>:
#endif

#endif

static void btstack_crypto_ccm_next_block(btstack_crypto_ccm_t * btstack_crypto_ccm, btstack_crypto_ccm_state_t state_when_done){
 800da3c:	b580      	push	{r7, lr}
 800da3e:	b084      	sub	sp, #16
 800da40:	af00      	add	r7, sp, #0
 800da42:	6078      	str	r0, [r7, #4]
 800da44:	460b      	mov	r3, r1
 800da46:	70fb      	strb	r3, [r7, #3]
    uint16_t bytes_to_process = btstack_min(btstack_crypto_ccm->block_len, 16);
 800da48:	687b      	ldr	r3, [r7, #4]
 800da4a:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800da4c:	2110      	movs	r1, #16
 800da4e:	4618      	mov	r0, r3
 800da50:	f001 fb5d 	bl	800f10e <btstack_min>
 800da54:	4603      	mov	r3, r0
 800da56:	81fb      	strh	r3, [r7, #14]
    // next block
    btstack_crypto_ccm->counter++;
 800da58:	687b      	ldr	r3, [r7, #4]
 800da5a:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 800da5c:	3301      	adds	r3, #1
 800da5e:	b29a      	uxth	r2, r3
 800da60:	687b      	ldr	r3, [r7, #4]
 800da62:	875a      	strh	r2, [r3, #58]	; 0x3a
    btstack_crypto_ccm->input       += bytes_to_process;
 800da64:	687b      	ldr	r3, [r7, #4]
 800da66:	69da      	ldr	r2, [r3, #28]
 800da68:	89fb      	ldrh	r3, [r7, #14]
 800da6a:	441a      	add	r2, r3
 800da6c:	687b      	ldr	r3, [r7, #4]
 800da6e:	61da      	str	r2, [r3, #28]
    btstack_crypto_ccm->output      += bytes_to_process;
 800da70:	687b      	ldr	r3, [r7, #4]
 800da72:	6a1a      	ldr	r2, [r3, #32]
 800da74:	89fb      	ldrh	r3, [r7, #14]
 800da76:	441a      	add	r2, r3
 800da78:	687b      	ldr	r3, [r7, #4]
 800da7a:	621a      	str	r2, [r3, #32]
    btstack_crypto_ccm->block_len   -= bytes_to_process;
 800da7c:	687b      	ldr	r3, [r7, #4]
 800da7e:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
 800da80:	89fb      	ldrh	r3, [r7, #14]
 800da82:	1ad3      	subs	r3, r2, r3
 800da84:	b29a      	uxth	r2, r3
 800da86:	687b      	ldr	r3, [r7, #4]
 800da88:	879a      	strh	r2, [r3, #60]	; 0x3c
    btstack_crypto_ccm->message_len -= bytes_to_process;
 800da8a:	687b      	ldr	r3, [r7, #4]
 800da8c:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 800da8e:	89fb      	ldrh	r3, [r7, #14]
 800da90:	1ad3      	subs	r3, r2, r3
 800da92:	b29a      	uxth	r2, r3
 800da94:	687b      	ldr	r3, [r7, #4]
 800da96:	871a      	strh	r2, [r3, #56]	; 0x38
#ifdef DEBUG_CCM
    printf("btstack_crypto_ccm_next_block (message len %u, block_len %u)\n", btstack_crypto_ccm->message_len, btstack_crypto_ccm->block_len);
#endif
    if (btstack_crypto_ccm->message_len == 0u){
 800da98:	687b      	ldr	r3, [r7, #4]
 800da9a:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800da9c:	2b00      	cmp	r3, #0
 800da9e:	d103      	bne.n	800daa8 <btstack_crypto_ccm_next_block+0x6c>
        btstack_crypto_ccm->state = CCM_CALCULATE_S0;
 800daa0:	687b      	ldr	r3, [r7, #4]
 800daa2:	2206      	movs	r2, #6
 800daa4:	741a      	strb	r2, [r3, #16]
        btstack_crypto_ccm->state = state_when_done;
        if (btstack_crypto_ccm->block_len == 0u){
            btstack_crypto_done(&btstack_crypto_ccm->btstack_crypto);
        }
    }
}
 800daa6:	e00a      	b.n	800dabe <btstack_crypto_ccm_next_block+0x82>
        btstack_crypto_ccm->state = state_when_done;
 800daa8:	687b      	ldr	r3, [r7, #4]
 800daaa:	78fa      	ldrb	r2, [r7, #3]
 800daac:	741a      	strb	r2, [r3, #16]
        if (btstack_crypto_ccm->block_len == 0u){
 800daae:	687b      	ldr	r3, [r7, #4]
 800dab0:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800dab2:	2b00      	cmp	r3, #0
 800dab4:	d103      	bne.n	800dabe <btstack_crypto_ccm_next_block+0x82>
            btstack_crypto_done(&btstack_crypto_ccm->btstack_crypto);
 800dab6:	687b      	ldr	r3, [r7, #4]
 800dab8:	4618      	mov	r0, r3
 800daba:	f7ff fbfd 	bl	800d2b8 <btstack_crypto_done>
}
 800dabe:	bf00      	nop
 800dac0:	3710      	adds	r7, #16
 800dac2:	46bd      	mov	sp, r7
 800dac4:	bd80      	pop	{r7, pc}

0800dac6 <btstack_crypto_ccm_handle_s0>:

// If Controller is used for AES128, data is little endian
static void btstack_crypto_ccm_handle_s0(btstack_crypto_ccm_t * btstack_crypto_ccm, const uint8_t * data){
 800dac6:	b580      	push	{r7, lr}
 800dac8:	b084      	sub	sp, #16
 800daca:	af00      	add	r7, sp, #0
 800dacc:	6078      	str	r0, [r7, #4]
 800dace:	6039      	str	r1, [r7, #0]
    int i;
    for (i=0;i<16;i++){
 800dad0:	2300      	movs	r3, #0
 800dad2:	60fb      	str	r3, [r7, #12]
 800dad4:	e016      	b.n	800db04 <btstack_crypto_ccm_handle_s0+0x3e>
#ifdef USE_BTSTACK_AES128
        btstack_crypto_ccm->x_i[i] = btstack_crypto_ccm->x_i[i] ^ data[i];
#else
        btstack_crypto_ccm->x_i[i] = btstack_crypto_ccm->x_i[i] ^ data[15-i];
 800dad6:	687a      	ldr	r2, [r7, #4]
 800dad8:	68fb      	ldr	r3, [r7, #12]
 800dada:	4413      	add	r3, r2
 800dadc:	3324      	adds	r3, #36	; 0x24
 800dade:	781a      	ldrb	r2, [r3, #0]
 800dae0:	68fb      	ldr	r3, [r7, #12]
 800dae2:	f1c3 030f 	rsb	r3, r3, #15
 800dae6:	4619      	mov	r1, r3
 800dae8:	683b      	ldr	r3, [r7, #0]
 800daea:	440b      	add	r3, r1
 800daec:	781b      	ldrb	r3, [r3, #0]
 800daee:	4053      	eors	r3, r2
 800daf0:	b2d9      	uxtb	r1, r3
 800daf2:	687a      	ldr	r2, [r7, #4]
 800daf4:	68fb      	ldr	r3, [r7, #12]
 800daf6:	4413      	add	r3, r2
 800daf8:	3324      	adds	r3, #36	; 0x24
 800dafa:	460a      	mov	r2, r1
 800dafc:	701a      	strb	r2, [r3, #0]
    for (i=0;i<16;i++){
 800dafe:	68fb      	ldr	r3, [r7, #12]
 800db00:	3301      	adds	r3, #1
 800db02:	60fb      	str	r3, [r7, #12]
 800db04:	68fb      	ldr	r3, [r7, #12]
 800db06:	2b0f      	cmp	r3, #15
 800db08:	dde5      	ble.n	800dad6 <btstack_crypto_ccm_handle_s0+0x10>
#endif
    }
    btstack_crypto_done(&btstack_crypto_ccm->btstack_crypto);
 800db0a:	687b      	ldr	r3, [r7, #4]
 800db0c:	4618      	mov	r0, r3
 800db0e:	f7ff fbd3 	bl	800d2b8 <btstack_crypto_done>
}
 800db12:	bf00      	nop
 800db14:	3710      	adds	r7, #16
 800db16:	46bd      	mov	sp, r7
 800db18:	bd80      	pop	{r7, pc}

0800db1a <btstack_crypto_ccm_handle_sn>:

// If Controller is used for AES128, data is little endian
static void btstack_crypto_ccm_handle_sn(btstack_crypto_ccm_t * btstack_crypto_ccm, const uint8_t * data){
 800db1a:	b580      	push	{r7, lr}
 800db1c:	b084      	sub	sp, #16
 800db1e:	af00      	add	r7, sp, #0
 800db20:	6078      	str	r0, [r7, #4]
 800db22:	6039      	str	r1, [r7, #0]
    int i;
    uint16_t bytes_to_process = btstack_min(btstack_crypto_ccm->block_len, 16);
 800db24:	687b      	ldr	r3, [r7, #4]
 800db26:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800db28:	2110      	movs	r1, #16
 800db2a:	4618      	mov	r0, r3
 800db2c:	f001 faef 	bl	800f10e <btstack_min>
 800db30:	4603      	mov	r3, r0
 800db32:	817b      	strh	r3, [r7, #10]
    for (i=0;i<bytes_to_process;i++){
 800db34:	2300      	movs	r3, #0
 800db36:	60fb      	str	r3, [r7, #12]
 800db38:	e015      	b.n	800db66 <btstack_crypto_ccm_handle_sn+0x4c>
#ifdef USE_BTSTACK_AES128
        btstack_crypto_ccm->output[i] = btstack_crypto_ccm->input[i] ^ data[i];
#else
        btstack_crypto_ccm->output[i] = btstack_crypto_ccm->input[i] ^ data[15-i];
 800db3a:	687b      	ldr	r3, [r7, #4]
 800db3c:	69da      	ldr	r2, [r3, #28]
 800db3e:	68fb      	ldr	r3, [r7, #12]
 800db40:	4413      	add	r3, r2
 800db42:	7819      	ldrb	r1, [r3, #0]
 800db44:	68fb      	ldr	r3, [r7, #12]
 800db46:	f1c3 030f 	rsb	r3, r3, #15
 800db4a:	461a      	mov	r2, r3
 800db4c:	683b      	ldr	r3, [r7, #0]
 800db4e:	4413      	add	r3, r2
 800db50:	781a      	ldrb	r2, [r3, #0]
 800db52:	687b      	ldr	r3, [r7, #4]
 800db54:	6a18      	ldr	r0, [r3, #32]
 800db56:	68fb      	ldr	r3, [r7, #12]
 800db58:	4403      	add	r3, r0
 800db5a:	404a      	eors	r2, r1
 800db5c:	b2d2      	uxtb	r2, r2
 800db5e:	701a      	strb	r2, [r3, #0]
    for (i=0;i<bytes_to_process;i++){
 800db60:	68fb      	ldr	r3, [r7, #12]
 800db62:	3301      	adds	r3, #1
 800db64:	60fb      	str	r3, [r7, #12]
 800db66:	897b      	ldrh	r3, [r7, #10]
 800db68:	68fa      	ldr	r2, [r7, #12]
 800db6a:	429a      	cmp	r2, r3
 800db6c:	dbe5      	blt.n	800db3a <btstack_crypto_ccm_handle_sn+0x20>
#endif
    }
    switch (btstack_crypto_ccm->btstack_crypto.operation){
 800db6e:	687b      	ldr	r3, [r7, #4]
 800db70:	7b1b      	ldrb	r3, [r3, #12]
 800db72:	2b07      	cmp	r3, #7
 800db74:	d006      	beq.n	800db84 <btstack_crypto_ccm_handle_sn+0x6a>
 800db76:	2b08      	cmp	r3, #8
 800db78:	d000      	beq.n	800db7c <btstack_crypto_ccm_handle_sn+0x62>
        case BTSTACK_CRYPTO_CCM_ENCRYPT_BLOCK:
            btstack_crypto_ccm_next_block(btstack_crypto_ccm, CCM_CALCULATE_XN);
            break;
        default:
            btstack_assert(false);
            break;
 800db7a:	e008      	b.n	800db8e <btstack_crypto_ccm_handle_sn+0x74>
            btstack_crypto_ccm->state = CCM_CALCULATE_XN;
 800db7c:	687b      	ldr	r3, [r7, #4]
 800db7e:	2204      	movs	r2, #4
 800db80:	741a      	strb	r2, [r3, #16]
            break;
 800db82:	e004      	b.n	800db8e <btstack_crypto_ccm_handle_sn+0x74>
            btstack_crypto_ccm_next_block(btstack_crypto_ccm, CCM_CALCULATE_XN);
 800db84:	2104      	movs	r1, #4
 800db86:	6878      	ldr	r0, [r7, #4]
 800db88:	f7ff ff58 	bl	800da3c <btstack_crypto_ccm_next_block>
            break;
 800db8c:	bf00      	nop
    }
}
 800db8e:	bf00      	nop
 800db90:	3710      	adds	r7, #16
 800db92:	46bd      	mov	sp, r7
 800db94:	bd80      	pop	{r7, pc}

0800db96 <btstack_crypto_ccm_handle_aad_xn>:

static void btstack_crypto_ccm_handle_aad_xn(btstack_crypto_ccm_t * btstack_crypto_ccm) {
 800db96:	b580      	push	{r7, lr}
 800db98:	b082      	sub	sp, #8
 800db9a:	af00      	add	r7, sp, #0
 800db9c:	6078      	str	r0, [r7, #4]
#ifdef DEBUG_CCM
    printf("%16s: ", "Xn+1 AAD");
    printf_hexdump(btstack_crypto_ccm->x_i, 16);
#endif
    // more aad?
    if (btstack_crypto_ccm->aad_offset < (btstack_crypto_ccm->aad_len + 2u)){
 800db9e:	687b      	ldr	r3, [r7, #4]
 800dba0:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 800dba2:	461a      	mov	r2, r3
 800dba4:	687b      	ldr	r3, [r7, #4]
 800dba6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800dba8:	3302      	adds	r3, #2
 800dbaa:	429a      	cmp	r2, r3
 800dbac:	d203      	bcs.n	800dbb6 <btstack_crypto_ccm_handle_aad_xn+0x20>
        btstack_crypto_ccm->state = CCM_CALCULATE_AAD_XN;
 800dbae:	687b      	ldr	r3, [r7, #4]
 800dbb0:	2202      	movs	r2, #2
 800dbb2:	741a      	strb	r2, [r3, #16]
    } else {
        // done
        btstack_crypto_done((btstack_crypto_t *) btstack_crypto_ccm);
    }
}
 800dbb4:	e002      	b.n	800dbbc <btstack_crypto_ccm_handle_aad_xn+0x26>
        btstack_crypto_done((btstack_crypto_t *) btstack_crypto_ccm);
 800dbb6:	6878      	ldr	r0, [r7, #4]
 800dbb8:	f7ff fb7e 	bl	800d2b8 <btstack_crypto_done>
}
 800dbbc:	bf00      	nop
 800dbbe:	3708      	adds	r7, #8
 800dbc0:	46bd      	mov	sp, r7
 800dbc2:	bd80      	pop	{r7, pc}

0800dbc4 <btstack_crypto_ccm_handle_x1>:

static void btstack_crypto_ccm_handle_x1(btstack_crypto_ccm_t * btstack_crypto_ccm) {
 800dbc4:	b480      	push	{r7}
 800dbc6:	b083      	sub	sp, #12
 800dbc8:	af00      	add	r7, sp, #0
 800dbca:	6078      	str	r0, [r7, #4]
#ifdef DEBUG_CCM
    printf("%16s: ", "Xi");
    printf_hexdump(btstack_crypto_ccm->x_i, 16);
#endif
    switch (btstack_crypto_ccm->btstack_crypto.operation){
 800dbcc:	687b      	ldr	r3, [r7, #4]
 800dbce:	7b1b      	ldrb	r3, [r3, #12]
 800dbd0:	2b07      	cmp	r3, #7
 800dbd2:	d010      	beq.n	800dbf6 <btstack_crypto_ccm_handle_x1+0x32>
 800dbd4:	2b08      	cmp	r3, #8
 800dbd6:	d00a      	beq.n	800dbee <btstack_crypto_ccm_handle_x1+0x2a>
 800dbd8:	2b06      	cmp	r3, #6
 800dbda:	d000      	beq.n	800dbde <btstack_crypto_ccm_handle_x1+0x1a>
        case BTSTACK_CRYPTO_CCM_ENCRYPT_BLOCK:
            btstack_crypto_ccm->state = CCM_CALCULATE_XN;
            break;
        default:
        btstack_assert(false);
            break;
 800dbdc:	e00f      	b.n	800dbfe <btstack_crypto_ccm_handle_x1+0x3a>
            btstack_crypto_ccm->aad_remainder_len = 0;
 800dbde:	687b      	ldr	r3, [r7, #4]
 800dbe0:	2200      	movs	r2, #0
 800dbe2:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
            btstack_crypto_ccm->state = CCM_CALCULATE_AAD_XN;
 800dbe6:	687b      	ldr	r3, [r7, #4]
 800dbe8:	2202      	movs	r2, #2
 800dbea:	741a      	strb	r2, [r3, #16]
            break;
 800dbec:	e007      	b.n	800dbfe <btstack_crypto_ccm_handle_x1+0x3a>
            btstack_crypto_ccm->state = CCM_CALCULATE_SN;
 800dbee:	687b      	ldr	r3, [r7, #4]
 800dbf0:	2208      	movs	r2, #8
 800dbf2:	741a      	strb	r2, [r3, #16]
            break;
 800dbf4:	e003      	b.n	800dbfe <btstack_crypto_ccm_handle_x1+0x3a>
            btstack_crypto_ccm->state = CCM_CALCULATE_XN;
 800dbf6:	687b      	ldr	r3, [r7, #4]
 800dbf8:	2204      	movs	r2, #4
 800dbfa:	741a      	strb	r2, [r3, #16]
            break;
 800dbfc:	bf00      	nop
    }
}
 800dbfe:	bf00      	nop
 800dc00:	370c      	adds	r7, #12
 800dc02:	46bd      	mov	sp, r7
 800dc04:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc08:	4770      	bx	lr

0800dc0a <btstack_crypto_ccm_handle_xn>:

static void btstack_crypto_ccm_handle_xn(btstack_crypto_ccm_t * btstack_crypto_ccm) {
 800dc0a:	b580      	push	{r7, lr}
 800dc0c:	b082      	sub	sp, #8
 800dc0e:	af00      	add	r7, sp, #0
 800dc10:	6078      	str	r0, [r7, #4]
#ifdef DEBUG_CCM
    printf("%16s: ", "Xn+1");
    printf_hexdump(btstack_crypto_ccm->x_i, 16);
#endif
    switch (btstack_crypto_ccm->btstack_crypto.operation){
 800dc12:	687b      	ldr	r3, [r7, #4]
 800dc14:	7b1b      	ldrb	r3, [r3, #12]
 800dc16:	2b07      	cmp	r3, #7
 800dc18:	d007      	beq.n	800dc2a <btstack_crypto_ccm_handle_xn+0x20>
 800dc1a:	2b08      	cmp	r3, #8
 800dc1c:	d000      	beq.n	800dc20 <btstack_crypto_ccm_handle_xn+0x16>
        case BTSTACK_CRYPTO_CCM_ENCRYPT_BLOCK:
            btstack_crypto_ccm->state = CCM_CALCULATE_SN;
            break;
        default:
        btstack_assert(false);
            break;
 800dc1e:	e008      	b.n	800dc32 <btstack_crypto_ccm_handle_xn+0x28>
            btstack_crypto_ccm_next_block(btstack_crypto_ccm, CCM_CALCULATE_SN);
 800dc20:	2108      	movs	r1, #8
 800dc22:	6878      	ldr	r0, [r7, #4]
 800dc24:	f7ff ff0a 	bl	800da3c <btstack_crypto_ccm_next_block>
            break;
 800dc28:	e003      	b.n	800dc32 <btstack_crypto_ccm_handle_xn+0x28>
            btstack_crypto_ccm->state = CCM_CALCULATE_SN;
 800dc2a:	687b      	ldr	r3, [r7, #4]
 800dc2c:	2208      	movs	r2, #8
 800dc2e:	741a      	strb	r2, [r3, #16]
            break;
 800dc30:	bf00      	nop
    }
}
 800dc32:	bf00      	nop
 800dc34:	3708      	adds	r7, #8
 800dc36:	46bd      	mov	sp, r7
 800dc38:	bd80      	pop	{r7, pc}
	...

0800dc3c <btstack_crypto_ccm_calc_s0>:

static void btstack_crypto_ccm_calc_s0(btstack_crypto_ccm_t * btstack_crypto_ccm){
 800dc3c:	b580      	push	{r7, lr}
 800dc3e:	b082      	sub	sp, #8
 800dc40:	af00      	add	r7, sp, #0
 800dc42:	6078      	str	r0, [r7, #4]
#ifdef DEBUG_CCM
    printf("btstack_crypto_ccm_calc_s0\n");
#endif
    btstack_crypto_ccm->state = CCM_W4_S0;
 800dc44:	687b      	ldr	r3, [r7, #4]
 800dc46:	2207      	movs	r2, #7
 800dc48:	741a      	strb	r2, [r3, #16]
    btstack_crypto_ccm_setup_a_i(btstack_crypto_ccm, 0);
 800dc4a:	2100      	movs	r1, #0
 800dc4c:	6878      	ldr	r0, [r7, #4]
 800dc4e:	f7ff fdf7 	bl	800d840 <btstack_crypto_ccm_setup_a_i>
#ifdef USE_BTSTACK_AES128
    uint8_t data[16];
    btstack_aes128_calc(btstack_crypto_ccm->key, btstack_crypto_ccm_s, data);
    btstack_crypto_ccm_handle_s0(btstack_crypto_ccm, data);
#else
    btstack_crypto_aes128_start(btstack_crypto_ccm->key, btstack_crypto_ccm_s);
 800dc52:	687b      	ldr	r3, [r7, #4]
 800dc54:	695b      	ldr	r3, [r3, #20]
 800dc56:	4904      	ldr	r1, [pc, #16]	; (800dc68 <btstack_crypto_ccm_calc_s0+0x2c>)
 800dc58:	4618      	mov	r0, r3
 800dc5a:	f7ff fb8b 	bl	800d374 <btstack_crypto_aes128_start>
#endif
}
 800dc5e:	bf00      	nop
 800dc60:	3708      	adds	r7, #8
 800dc62:	46bd      	mov	sp, r7
 800dc64:	bd80      	pop	{r7, pc}
 800dc66:	bf00      	nop
 800dc68:	200061bc 	.word	0x200061bc

0800dc6c <btstack_crypto_ccm_calc_sn>:

static void btstack_crypto_ccm_calc_sn(btstack_crypto_ccm_t * btstack_crypto_ccm){
 800dc6c:	b580      	push	{r7, lr}
 800dc6e:	b082      	sub	sp, #8
 800dc70:	af00      	add	r7, sp, #0
 800dc72:	6078      	str	r0, [r7, #4]
#ifdef DEBUG_CCM
    printf("btstack_crypto_ccm_calc_s%u\n", btstack_crypto_ccm->counter);
#endif
    btstack_crypto_ccm->state = CCM_W4_SN;
 800dc74:	687b      	ldr	r3, [r7, #4]
 800dc76:	2209      	movs	r2, #9
 800dc78:	741a      	strb	r2, [r3, #16]
    btstack_crypto_ccm_setup_a_i(btstack_crypto_ccm, btstack_crypto_ccm->counter);
 800dc7a:	687b      	ldr	r3, [r7, #4]
 800dc7c:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 800dc7e:	4619      	mov	r1, r3
 800dc80:	6878      	ldr	r0, [r7, #4]
 800dc82:	f7ff fddd 	bl	800d840 <btstack_crypto_ccm_setup_a_i>
#ifdef USE_BTSTACK_AES128
    uint8_t data[16];
    btstack_aes128_calc(btstack_crypto_ccm->key, btstack_crypto_ccm_s, data);
    btstack_crypto_ccm_handle_sn(btstack_crypto_ccm, data);
#else
    btstack_crypto_aes128_start(btstack_crypto_ccm->key, btstack_crypto_ccm_s);
 800dc86:	687b      	ldr	r3, [r7, #4]
 800dc88:	695b      	ldr	r3, [r3, #20]
 800dc8a:	4904      	ldr	r1, [pc, #16]	; (800dc9c <btstack_crypto_ccm_calc_sn+0x30>)
 800dc8c:	4618      	mov	r0, r3
 800dc8e:	f7ff fb71 	bl	800d374 <btstack_crypto_aes128_start>
#endif
}
 800dc92:	bf00      	nop
 800dc94:	3708      	adds	r7, #8
 800dc96:	46bd      	mov	sp, r7
 800dc98:	bd80      	pop	{r7, pc}
 800dc9a:	bf00      	nop
 800dc9c:	200061bc 	.word	0x200061bc

0800dca0 <btstack_crypto_ccm_calc_x1>:

static void btstack_crypto_ccm_calc_x1(btstack_crypto_ccm_t * btstack_crypto_ccm){
 800dca0:	b580      	push	{r7, lr}
 800dca2:	b086      	sub	sp, #24
 800dca4:	af00      	add	r7, sp, #0
 800dca6:	6078      	str	r0, [r7, #4]
    uint8_t btstack_crypto_ccm_buffer[16];
    btstack_crypto_ccm->state = CCM_W4_X1;
 800dca8:	687b      	ldr	r3, [r7, #4]
 800dcaa:	2201      	movs	r2, #1
 800dcac:	741a      	strb	r2, [r3, #16]
    btstack_crypto_ccm_setup_b_0(btstack_crypto_ccm, btstack_crypto_ccm_buffer);
 800dcae:	f107 0308 	add.w	r3, r7, #8
 800dcb2:	4619      	mov	r1, r3
 800dcb4:	6878      	ldr	r0, [r7, #4]
 800dcb6:	f7ff fde1 	bl	800d87c <btstack_crypto_ccm_setup_b_0>
#ifdef USE_BTSTACK_AES128
    btstack_aes128_calc(btstack_crypto_ccm->key, btstack_crypto_ccm_buffer, btstack_crypto_ccm->x_i);
    btstack_crypto_ccm_handle_x1(btstack_crypto_ccm);
#else
    btstack_crypto_aes128_start(btstack_crypto_ccm->key, btstack_crypto_ccm_buffer);
 800dcba:	687b      	ldr	r3, [r7, #4]
 800dcbc:	695b      	ldr	r3, [r3, #20]
 800dcbe:	f107 0208 	add.w	r2, r7, #8
 800dcc2:	4611      	mov	r1, r2
 800dcc4:	4618      	mov	r0, r3
 800dcc6:	f7ff fb55 	bl	800d374 <btstack_crypto_aes128_start>
#endif
}
 800dcca:	bf00      	nop
 800dccc:	3718      	adds	r7, #24
 800dcce:	46bd      	mov	sp, r7
 800dcd0:	bd80      	pop	{r7, pc}

0800dcd2 <btstack_crypto_ccm_calc_xn>:

static void btstack_crypto_ccm_calc_xn(btstack_crypto_ccm_t * btstack_crypto_ccm, const uint8_t * plaintext){
 800dcd2:	b580      	push	{r7, lr}
 800dcd4:	b088      	sub	sp, #32
 800dcd6:	af00      	add	r7, sp, #0
 800dcd8:	6078      	str	r0, [r7, #4]
 800dcda:	6039      	str	r1, [r7, #0]
    uint8_t btstack_crypto_ccm_buffer[16];
    btstack_crypto_ccm->state = CCM_W4_XN;
 800dcdc:	687b      	ldr	r3, [r7, #4]
 800dcde:	2205      	movs	r2, #5
 800dce0:	741a      	strb	r2, [r3, #16]
#ifdef DEBUG_CCM
    printf("%16s: ", "bn");
    printf_hexdump(plaintext, 16);
#endif
    uint8_t i;
    uint8_t bytes_to_decrypt = btstack_crypto_ccm->block_len;
 800dce2:	687b      	ldr	r3, [r7, #4]
 800dce4:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800dce6:	77bb      	strb	r3, [r7, #30]
    // use explicit min implementation as c-stat worried about out-of-bounds-reads
    if (bytes_to_decrypt > 16u) {
 800dce8:	7fbb      	ldrb	r3, [r7, #30]
 800dcea:	2b10      	cmp	r3, #16
 800dcec:	d901      	bls.n	800dcf2 <btstack_crypto_ccm_calc_xn+0x20>
        bytes_to_decrypt = 16;
 800dcee:	2310      	movs	r3, #16
 800dcf0:	77bb      	strb	r3, [r7, #30]
    }
    for (i = 0; i < bytes_to_decrypt ; i++){
 800dcf2:	2300      	movs	r3, #0
 800dcf4:	77fb      	strb	r3, [r7, #31]
 800dcf6:	e013      	b.n	800dd20 <btstack_crypto_ccm_calc_xn+0x4e>
        btstack_crypto_ccm_buffer[i] =  btstack_crypto_ccm->x_i[i] ^ plaintext[i];
 800dcf8:	7ffb      	ldrb	r3, [r7, #31]
 800dcfa:	687a      	ldr	r2, [r7, #4]
 800dcfc:	4413      	add	r3, r2
 800dcfe:	f893 1024 	ldrb.w	r1, [r3, #36]	; 0x24
 800dd02:	7ffb      	ldrb	r3, [r7, #31]
 800dd04:	683a      	ldr	r2, [r7, #0]
 800dd06:	4413      	add	r3, r2
 800dd08:	781a      	ldrb	r2, [r3, #0]
 800dd0a:	7ffb      	ldrb	r3, [r7, #31]
 800dd0c:	404a      	eors	r2, r1
 800dd0e:	b2d2      	uxtb	r2, r2
 800dd10:	f107 0120 	add.w	r1, r7, #32
 800dd14:	440b      	add	r3, r1
 800dd16:	f803 2c14 	strb.w	r2, [r3, #-20]
    for (i = 0; i < bytes_to_decrypt ; i++){
 800dd1a:	7ffb      	ldrb	r3, [r7, #31]
 800dd1c:	3301      	adds	r3, #1
 800dd1e:	77fb      	strb	r3, [r7, #31]
 800dd20:	7ffa      	ldrb	r2, [r7, #31]
 800dd22:	7fbb      	ldrb	r3, [r7, #30]
 800dd24:	429a      	cmp	r2, r3
 800dd26:	d3e7      	bcc.n	800dcf8 <btstack_crypto_ccm_calc_xn+0x26>
    }
    (void)memcpy(&btstack_crypto_ccm_buffer[i], &btstack_crypto_ccm->x_i[i],
 800dd28:	7ffb      	ldrb	r3, [r7, #31]
 800dd2a:	f107 020c 	add.w	r2, r7, #12
 800dd2e:	18d0      	adds	r0, r2, r3
 800dd30:	7ffb      	ldrb	r3, [r7, #31]
 800dd32:	3320      	adds	r3, #32
 800dd34:	687a      	ldr	r2, [r7, #4]
 800dd36:	4413      	add	r3, r2
 800dd38:	1d19      	adds	r1, r3, #4
 800dd3a:	7fbb      	ldrb	r3, [r7, #30]
 800dd3c:	f1c3 0310 	rsb	r3, r3, #16
 800dd40:	461a      	mov	r2, r3
 800dd42:	f019 fe9a 	bl	8027a7a <memcpy>

#ifdef USE_BTSTACK_AES128
    btstack_aes128_calc(btstack_crypto_ccm->key, btstack_crypto_ccm_buffer, btstack_crypto_ccm->x_i);
    btstack_crypto_ccm_handle_xn(btstack_crypto_ccm);
#else
    btstack_crypto_aes128_start(btstack_crypto_ccm->key, btstack_crypto_ccm_buffer);
 800dd46:	687b      	ldr	r3, [r7, #4]
 800dd48:	695b      	ldr	r3, [r3, #20]
 800dd4a:	f107 020c 	add.w	r2, r7, #12
 800dd4e:	4611      	mov	r1, r2
 800dd50:	4618      	mov	r0, r3
 800dd52:	f7ff fb0f 	bl	800d374 <btstack_crypto_aes128_start>
#endif
}
 800dd56:	bf00      	nop
 800dd58:	3720      	adds	r7, #32
 800dd5a:	46bd      	mov	sp, r7
 800dd5c:	bd80      	pop	{r7, pc}

0800dd5e <btstack_crypto_ccm_calc_aad_xn>:

static void btstack_crypto_ccm_calc_aad_xn(btstack_crypto_ccm_t * btstack_crypto_ccm){
 800dd5e:	b580      	push	{r7, lr}
 800dd60:	b084      	sub	sp, #16
 800dd62:	af00      	add	r7, sp, #0
 800dd64:	6078      	str	r0, [r7, #4]
    // store length
    if (btstack_crypto_ccm->aad_offset == 0u){
 800dd66:	687b      	ldr	r3, [r7, #4]
 800dd68:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 800dd6a:	2b00      	cmp	r3, #0
 800dd6c:	d127      	bne.n	800ddbe <btstack_crypto_ccm_calc_aad_xn+0x60>
        uint8_t len_buffer[2];
        big_endian_store_16(len_buffer, 0, btstack_crypto_ccm->aad_len);
 800dd6e:	687b      	ldr	r3, [r7, #4]
 800dd70:	8eda      	ldrh	r2, [r3, #54]	; 0x36
 800dd72:	f107 0308 	add.w	r3, r7, #8
 800dd76:	2100      	movs	r1, #0
 800dd78:	4618      	mov	r0, r3
 800dd7a:	f001 f90a 	bl	800ef92 <big_endian_store_16>
        btstack_crypto_ccm->x_i[0] ^= len_buffer[0];
 800dd7e:	687b      	ldr	r3, [r7, #4]
 800dd80:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 800dd84:	7a3b      	ldrb	r3, [r7, #8]
 800dd86:	4053      	eors	r3, r2
 800dd88:	b2da      	uxtb	r2, r3
 800dd8a:	687b      	ldr	r3, [r7, #4]
 800dd8c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
        btstack_crypto_ccm->x_i[1] ^= len_buffer[1];
 800dd90:	687b      	ldr	r3, [r7, #4]
 800dd92:	f893 2025 	ldrb.w	r2, [r3, #37]	; 0x25
 800dd96:	7a7b      	ldrb	r3, [r7, #9]
 800dd98:	4053      	eors	r3, r2
 800dd9a:	b2da      	uxtb	r2, r3
 800dd9c:	687b      	ldr	r3, [r7, #4]
 800dd9e:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
        btstack_crypto_ccm->aad_remainder_len += 2u;
 800dda2:	687b      	ldr	r3, [r7, #4]
 800dda4:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
 800dda8:	3302      	adds	r3, #2
 800ddaa:	b2da      	uxtb	r2, r3
 800ddac:	687b      	ldr	r3, [r7, #4]
 800ddae:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
        btstack_crypto_ccm->aad_offset        += 2u;
 800ddb2:	687b      	ldr	r3, [r7, #4]
 800ddb4:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 800ddb6:	3302      	adds	r3, #2
 800ddb8:	b29a      	uxth	r2, r3
 800ddba:	687b      	ldr	r3, [r7, #4]
 800ddbc:	869a      	strh	r2, [r3, #52]	; 0x34
    }

    // fill from input
    uint16_t bytes_free = 16u - btstack_crypto_ccm->aad_remainder_len;
 800ddbe:	687b      	ldr	r3, [r7, #4]
 800ddc0:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
 800ddc4:	b29b      	uxth	r3, r3
 800ddc6:	f1c3 0310 	rsb	r3, r3, #16
 800ddca:	81fb      	strh	r3, [r7, #14]
    uint16_t bytes_to_copy = btstack_min(bytes_free, btstack_crypto_ccm->block_len);
 800ddcc:	89fa      	ldrh	r2, [r7, #14]
 800ddce:	687b      	ldr	r3, [r7, #4]
 800ddd0:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800ddd2:	4619      	mov	r1, r3
 800ddd4:	4610      	mov	r0, r2
 800ddd6:	f001 f99a 	bl	800f10e <btstack_min>
 800ddda:	4603      	mov	r3, r0
 800dddc:	81bb      	strh	r3, [r7, #12]
    while (bytes_to_copy){
 800ddde:	e02c      	b.n	800de3a <btstack_crypto_ccm_calc_aad_xn+0xdc>
        btstack_crypto_ccm->x_i[btstack_crypto_ccm->aad_remainder_len++] ^= *btstack_crypto_ccm->input++;
 800dde0:	687b      	ldr	r3, [r7, #4]
 800dde2:	69db      	ldr	r3, [r3, #28]
 800dde4:	1c59      	adds	r1, r3, #1
 800dde6:	687a      	ldr	r2, [r7, #4]
 800dde8:	61d1      	str	r1, [r2, #28]
 800ddea:	7819      	ldrb	r1, [r3, #0]
 800ddec:	687b      	ldr	r3, [r7, #4]
 800ddee:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
 800ddf2:	1c5a      	adds	r2, r3, #1
 800ddf4:	b2d0      	uxtb	r0, r2
 800ddf6:	687a      	ldr	r2, [r7, #4]
 800ddf8:	f882 003f 	strb.w	r0, [r2, #63]	; 0x3f
 800ddfc:	4618      	mov	r0, r3
 800ddfe:	687a      	ldr	r2, [r7, #4]
 800de00:	4402      	add	r2, r0
 800de02:	f892 2024 	ldrb.w	r2, [r2, #36]	; 0x24
 800de06:	4618      	mov	r0, r3
 800de08:	ea81 0302 	eor.w	r3, r1, r2
 800de0c:	b2da      	uxtb	r2, r3
 800de0e:	687b      	ldr	r3, [r7, #4]
 800de10:	4403      	add	r3, r0
 800de12:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
        btstack_crypto_ccm->aad_offset++;
 800de16:	687b      	ldr	r3, [r7, #4]
 800de18:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 800de1a:	3301      	adds	r3, #1
 800de1c:	b29a      	uxth	r2, r3
 800de1e:	687b      	ldr	r3, [r7, #4]
 800de20:	869a      	strh	r2, [r3, #52]	; 0x34
        btstack_crypto_ccm->block_len--;
 800de22:	687b      	ldr	r3, [r7, #4]
 800de24:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800de26:	3b01      	subs	r3, #1
 800de28:	b29a      	uxth	r2, r3
 800de2a:	687b      	ldr	r3, [r7, #4]
 800de2c:	879a      	strh	r2, [r3, #60]	; 0x3c
        bytes_to_copy--;
 800de2e:	89bb      	ldrh	r3, [r7, #12]
 800de30:	3b01      	subs	r3, #1
 800de32:	81bb      	strh	r3, [r7, #12]
        bytes_free--;
 800de34:	89fb      	ldrh	r3, [r7, #14]
 800de36:	3b01      	subs	r3, #1
 800de38:	81fb      	strh	r3, [r7, #14]
    while (bytes_to_copy){
 800de3a:	89bb      	ldrh	r3, [r7, #12]
 800de3c:	2b00      	cmp	r3, #0
 800de3e:	d1cf      	bne.n	800dde0 <btstack_crypto_ccm_calc_aad_xn+0x82>
    }

    // if last block, fill with zeros
    if (btstack_crypto_ccm->aad_offset == (btstack_crypto_ccm->aad_len + 2u)){
 800de40:	687b      	ldr	r3, [r7, #4]
 800de42:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 800de44:	461a      	mov	r2, r3
 800de46:	687b      	ldr	r3, [r7, #4]
 800de48:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800de4a:	3302      	adds	r3, #2
 800de4c:	429a      	cmp	r2, r3
 800de4e:	d103      	bne.n	800de58 <btstack_crypto_ccm_calc_aad_xn+0xfa>
        btstack_crypto_ccm->aad_remainder_len = 16;
 800de50:	687b      	ldr	r3, [r7, #4]
 800de52:	2210      	movs	r2, #16
 800de54:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
    }
    // if not full, notify done
    if (btstack_crypto_ccm->aad_remainder_len < 16u){
 800de58:	687b      	ldr	r3, [r7, #4]
 800de5a:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
 800de5e:	2b0f      	cmp	r3, #15
 800de60:	d804      	bhi.n	800de6c <btstack_crypto_ccm_calc_aad_xn+0x10e>
        btstack_crypto_done(&btstack_crypto_ccm->btstack_crypto);
 800de62:	687b      	ldr	r3, [r7, #4]
 800de64:	4618      	mov	r0, r3
 800de66:	f7ff fa27 	bl	800d2b8 <btstack_crypto_done>
        return;
 800de6a:	e00e      	b.n	800de8a <btstack_crypto_ccm_calc_aad_xn+0x12c>
#ifdef DEBUG_CCM
    printf("%16s: ", "Xn XOR Bn (aad)");
    printf_hexdump(btstack_crypto_ccm->x_i, 16);
#endif

    btstack_crypto_ccm->aad_remainder_len = 0;
 800de6c:	687b      	ldr	r3, [r7, #4]
 800de6e:	2200      	movs	r2, #0
 800de70:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
    btstack_crypto_ccm->state = CCM_W4_AAD_XN;
 800de74:	687b      	ldr	r3, [r7, #4]
 800de76:	2203      	movs	r2, #3
 800de78:	741a      	strb	r2, [r3, #16]
#ifdef USE_BTSTACK_AES128
    btstack_aes128_calc(btstack_crypto_ccm->key, btstack_crypto_ccm->x_i, btstack_crypto_ccm->x_i);
    btstack_crypto_ccm_handle_aad_xn(btstack_crypto_ccm);
#else
    btstack_crypto_aes128_start(btstack_crypto_ccm->key, btstack_crypto_ccm->x_i);
 800de7a:	687b      	ldr	r3, [r7, #4]
 800de7c:	695a      	ldr	r2, [r3, #20]
 800de7e:	687b      	ldr	r3, [r7, #4]
 800de80:	3324      	adds	r3, #36	; 0x24
 800de82:	4619      	mov	r1, r3
 800de84:	4610      	mov	r0, r2
 800de86:	f7ff fa75 	bl	800d374 <btstack_crypto_aes128_start>
#endif
}
 800de8a:	3710      	adds	r7, #16
 800de8c:	46bd      	mov	sp, r7
 800de8e:	bd80      	pop	{r7, pc}

0800de90 <btstack_crypto_run>:

static void btstack_crypto_run(void){
 800de90:	b5f0      	push	{r4, r5, r6, r7, lr}
 800de92:	b087      	sub	sp, #28
 800de94:	af00      	add	r7, sp, #0
#ifdef ENABLE_ECC_P256
    btstack_crypto_ecc_p256_t      * btstack_crypto_ec_p192;
#endif

    // stack up and running?
    if (hci_get_state() != HCI_STATE_WORKING) return;
 800de96:	f008 fe5d 	bl	8016b54 <hci_get_state>
 800de9a:	4603      	mov	r3, r0
 800de9c:	2b02      	cmp	r3, #2
 800de9e:	f040 80ee 	bne.w	800e07e <btstack_crypto_run+0x1ee>

    // try to do as much as possible
    while (true){

        // anything to do?
        if (btstack_linked_list_empty(&btstack_crypto_operations)) return;
 800dea2:	487c      	ldr	r0, [pc, #496]	; (800e094 <btstack_crypto_run+0x204>)
 800dea4:	f000 fbb4 	bl	800e610 <btstack_linked_list_empty>
 800dea8:	4603      	mov	r3, r0
 800deaa:	2b00      	cmp	r3, #0
 800deac:	f040 80e9 	bne.w	800e082 <btstack_crypto_run+0x1f2>

        // already active?
        if (btstack_crypto_wait_for_hci_result) return;
 800deb0:	4b79      	ldr	r3, [pc, #484]	; (800e098 <btstack_crypto_run+0x208>)
 800deb2:	781b      	ldrb	r3, [r3, #0]
 800deb4:	2b00      	cmp	r3, #0
 800deb6:	f040 80e6 	bne.w	800e086 <btstack_crypto_run+0x1f6>

        // can send a command?
        if (!hci_can_send_command_packet_now()) return;
 800deba:	f002 f815 	bl	800fee8 <hci_can_send_command_packet_now>
 800debe:	4603      	mov	r3, r0
 800dec0:	2b00      	cmp	r3, #0
 800dec2:	f000 80e2 	beq.w	800e08a <btstack_crypto_run+0x1fa>

        // ok, find next task
    	btstack_crypto_t * btstack_crypto = (btstack_crypto_t*) btstack_linked_list_get_first_item(&btstack_crypto_operations);
 800dec6:	4873      	ldr	r0, [pc, #460]	; (800e094 <btstack_crypto_run+0x204>)
 800dec8:	f000 fc1e 	bl	800e708 <btstack_linked_list_get_first_item>
 800decc:	6178      	str	r0, [r7, #20]
    	switch (btstack_crypto->operation){
 800dece:	697b      	ldr	r3, [r7, #20]
 800ded0:	7b1b      	ldrb	r3, [r3, #12]
 800ded2:	2b08      	cmp	r3, #8
 800ded4:	f200 80d1 	bhi.w	800e07a <btstack_crypto_run+0x1ea>
 800ded8:	a201      	add	r2, pc, #4	; (adr r2, 800dee0 <btstack_crypto_run+0x50>)
 800deda:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800dede:	bf00      	nop
 800dee0:	0800df05 	.word	0x0800df05
 800dee4:	0800df13 	.word	0x0800df13
 800dee8:	0800df29 	.word	0x0800df29
 800deec:	0800df29 	.word	0x0800df29
 800def0:	0800dfc1 	.word	0x0800dfc1
 800def4:	0800e05d 	.word	0x0800e05d
 800def8:	0800df4b 	.word	0x0800df4b
 800defc:	0800df4b 	.word	0x0800df4b
 800df00:	0800df4b 	.word	0x0800df4b
    		case BTSTACK_CRYPTO_RANDOM:
    			btstack_crypto_wait_for_hci_result = true;
 800df04:	4b64      	ldr	r3, [pc, #400]	; (800e098 <btstack_crypto_run+0x208>)
 800df06:	2201      	movs	r2, #1
 800df08:	701a      	strb	r2, [r3, #0]
    		    hci_send_cmd(&hci_le_rand);
 800df0a:	4864      	ldr	r0, [pc, #400]	; (800e09c <btstack_crypto_run+0x20c>)
 800df0c:	f008 f868 	bl	8015fe0 <hci_send_cmd>
    		    break;
 800df10:	e0b4      	b.n	800e07c <btstack_crypto_run+0x1ec>
    		case BTSTACK_CRYPTO_AES128:
                btstack_crypto_aes128 = (btstack_crypto_aes128_t *) btstack_crypto;
 800df12:	697b      	ldr	r3, [r7, #20]
 800df14:	607b      	str	r3, [r7, #4]
#ifdef USE_BTSTACK_AES128
                btstack_aes128_calc(btstack_crypto_aes128->key, btstack_crypto_aes128->plaintext, btstack_crypto_aes128->ciphertext);
                btstack_crypto_done(btstack_crypto);
#else
                btstack_crypto_aes128_start(btstack_crypto_aes128->key, btstack_crypto_aes128->plaintext);
 800df16:	687b      	ldr	r3, [r7, #4]
 800df18:	691a      	ldr	r2, [r3, #16]
 800df1a:	687b      	ldr	r3, [r7, #4]
 800df1c:	695b      	ldr	r3, [r3, #20]
 800df1e:	4619      	mov	r1, r3
 800df20:	4610      	mov	r0, r2
 800df22:	f7ff fa27 	bl	800d374 <btstack_crypto_aes128_start>
#endif
    		    break;
 800df26:	e0a9      	b.n	800e07c <btstack_crypto_run+0x1ec>

    		case BTSTACK_CRYPTO_CMAC_MESSAGE:
    		case BTSTACK_CRYPTO_CMAC_GENERATOR:
                btstack_crypto_cmac = (btstack_crypto_aes128_cmac_t *) btstack_crypto;
 800df28:	697b      	ldr	r3, [r7, #20]
 800df2a:	60bb      	str	r3, [r7, #8]
#ifdef USE_BTSTACK_AES128
                btstack_crypto_cmac_calc( btstack_crypto_cmac );
                btstack_crypto_done(btstack_crypto);
#else
    			btstack_crypto_wait_for_hci_result = 1;
 800df2c:	4b5a      	ldr	r3, [pc, #360]	; (800e098 <btstack_crypto_run+0x208>)
 800df2e:	2201      	movs	r2, #1
 800df30:	701a      	strb	r2, [r3, #0]
    			if (btstack_crypto_cmac_state == CMAC_IDLE){
 800df32:	4b5b      	ldr	r3, [pc, #364]	; (800e0a0 <btstack_crypto_run+0x210>)
 800df34:	781b      	ldrb	r3, [r3, #0]
 800df36:	2b00      	cmp	r3, #0
 800df38:	d103      	bne.n	800df42 <btstack_crypto_run+0xb2>
    				btstack_crypto_cmac_start(btstack_crypto_cmac);
 800df3a:	68b8      	ldr	r0, [r7, #8]
 800df3c:	f7ff fc36 	bl	800d7ac <btstack_crypto_cmac_start>
    			} else {
    				btstack_crypto_cmac_handle_aes_engine_ready(btstack_crypto_cmac);
    			}
#endif
    			break;
 800df40:	e09c      	b.n	800e07c <btstack_crypto_run+0x1ec>
    				btstack_crypto_cmac_handle_aes_engine_ready(btstack_crypto_cmac);
 800df42:	68b8      	ldr	r0, [r7, #8]
 800df44:	f7ff fa64 	bl	800d410 <btstack_crypto_cmac_handle_aes_engine_ready>
    			break;
 800df48:	e098      	b.n	800e07c <btstack_crypto_run+0x1ec>

            case BTSTACK_CRYPTO_CCM_DIGEST_BLOCK:
            case BTSTACK_CRYPTO_CCM_ENCRYPT_BLOCK:
            case BTSTACK_CRYPTO_CCM_DECRYPT_BLOCK:
                btstack_crypto_ccm = (btstack_crypto_ccm_t *) btstack_crypto;
 800df4a:	697b      	ldr	r3, [r7, #20]
 800df4c:	613b      	str	r3, [r7, #16]
                switch (btstack_crypto_ccm->state){
 800df4e:	693b      	ldr	r3, [r7, #16]
 800df50:	7c1b      	ldrb	r3, [r3, #16]
 800df52:	2b08      	cmp	r3, #8
 800df54:	d832      	bhi.n	800dfbc <btstack_crypto_run+0x12c>
 800df56:	a201      	add	r2, pc, #4	; (adr r2, 800df5c <btstack_crypto_run+0xcc>)
 800df58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800df5c:	0800df89 	.word	0x0800df89
 800df60:	0800dfbd 	.word	0x0800dfbd
 800df64:	0800df81 	.word	0x0800df81
 800df68:	0800dfbd 	.word	0x0800dfbd
 800df6c:	0800dfa1 	.word	0x0800dfa1
 800df70:	0800dfbd 	.word	0x0800dfbd
 800df74:	0800df91 	.word	0x0800df91
 800df78:	0800dfbd 	.word	0x0800dfbd
 800df7c:	0800df99 	.word	0x0800df99
                    case CCM_CALCULATE_AAD_XN:
#ifdef DEBUG_CCM
                        printf("CCM_CALCULATE_AAD_XN\n");
#endif
                        btstack_crypto_ccm_calc_aad_xn(btstack_crypto_ccm);
 800df80:	6938      	ldr	r0, [r7, #16]
 800df82:	f7ff feec 	bl	800dd5e <btstack_crypto_ccm_calc_aad_xn>
                        break;
 800df86:	e01a      	b.n	800dfbe <btstack_crypto_run+0x12e>
                    case CCM_CALCULATE_X1:
#ifdef DEBUG_CCM
                        printf("CCM_CALCULATE_X1\n");
#endif
                        btstack_crypto_ccm_calc_x1(btstack_crypto_ccm);
 800df88:	6938      	ldr	r0, [r7, #16]
 800df8a:	f7ff fe89 	bl	800dca0 <btstack_crypto_ccm_calc_x1>
                        break;
 800df8e:	e016      	b.n	800dfbe <btstack_crypto_run+0x12e>
                    case CCM_CALCULATE_S0:
#ifdef DEBUG_CCM
                        printf("CCM_CALCULATE_S0\n");
#endif
                        btstack_crypto_ccm_calc_s0(btstack_crypto_ccm);
 800df90:	6938      	ldr	r0, [r7, #16]
 800df92:	f7ff fe53 	bl	800dc3c <btstack_crypto_ccm_calc_s0>
                        break;
 800df96:	e012      	b.n	800dfbe <btstack_crypto_run+0x12e>
                    case CCM_CALCULATE_SN:
#ifdef DEBUG_CCM
                        printf("CCM_CALCULATE_SN\n");
#endif
                        btstack_crypto_ccm_calc_sn(btstack_crypto_ccm);
 800df98:	6938      	ldr	r0, [r7, #16]
 800df9a:	f7ff fe67 	bl	800dc6c <btstack_crypto_ccm_calc_sn>
                        break;
 800df9e:	e00e      	b.n	800dfbe <btstack_crypto_run+0x12e>
                    case CCM_CALCULATE_XN:
#ifdef DEBUG_CCM
                        printf("CCM_CALCULATE_XN\n");
#endif
                        btstack_crypto_ccm_calc_xn(btstack_crypto_ccm, (btstack_crypto->operation == BTSTACK_CRYPTO_CCM_ENCRYPT_BLOCK) ? btstack_crypto_ccm->input : btstack_crypto_ccm->output);
 800dfa0:	697b      	ldr	r3, [r7, #20]
 800dfa2:	7b1b      	ldrb	r3, [r3, #12]
 800dfa4:	2b07      	cmp	r3, #7
 800dfa6:	d102      	bne.n	800dfae <btstack_crypto_run+0x11e>
 800dfa8:	693b      	ldr	r3, [r7, #16]
 800dfaa:	69db      	ldr	r3, [r3, #28]
 800dfac:	e001      	b.n	800dfb2 <btstack_crypto_run+0x122>
 800dfae:	693b      	ldr	r3, [r7, #16]
 800dfb0:	6a1b      	ldr	r3, [r3, #32]
 800dfb2:	4619      	mov	r1, r3
 800dfb4:	6938      	ldr	r0, [r7, #16]
 800dfb6:	f7ff fe8c 	bl	800dcd2 <btstack_crypto_ccm_calc_xn>
                        break;
 800dfba:	e000      	b.n	800dfbe <btstack_crypto_run+0x12e>
                    default:
                        break;
 800dfbc:	bf00      	nop
                }
                break;
 800dfbe:	e05d      	b.n	800e07c <btstack_crypto_run+0x1ec>

#ifdef ENABLE_ECC_P256
            case BTSTACK_CRYPTO_ECC_P256_GENERATE_KEY:
                btstack_crypto_ec_p192 = (btstack_crypto_ecc_p256_t *) btstack_crypto;
 800dfc0:	697b      	ldr	r3, [r7, #20]
 800dfc2:	60fb      	str	r3, [r7, #12]
                switch (btstack_crypto_ecc_p256_key_generation_state){
 800dfc4:	4b37      	ldr	r3, [pc, #220]	; (800e0a4 <btstack_crypto_run+0x214>)
 800dfc6:	781b      	ldrb	r3, [r3, #0]
 800dfc8:	2b01      	cmp	r3, #1
 800dfca:	d038      	beq.n	800e03e <btstack_crypto_run+0x1ae>
 800dfcc:	2b04      	cmp	r3, #4
 800dfce:	d002      	beq.n	800dfd6 <btstack_crypto_run+0x146>
 800dfd0:	2b00      	cmp	r3, #0
 800dfd2:	d020      	beq.n	800e016 <btstack_crypto_run+0x186>
                        btstack_crypto_wait_for_hci_result = true;
                        hci_send_cmd(&hci_le_rand);
                        break;
#endif
                    default:
                        break;
 800dfd4:	e041      	b.n	800e05a <btstack_crypto_run+0x1ca>
                        btstack_crypto_log_ec_publickey(btstack_crypto_ecc_p256_public_key);
 800dfd6:	4834      	ldr	r0, [pc, #208]	; (800e0a8 <btstack_crypto_run+0x218>)
 800dfd8:	f7ff fc84 	bl	800d8e4 <btstack_crypto_log_ec_publickey>
                        (void)memcpy(btstack_crypto_ec_p192->public_key,
 800dfdc:	68fb      	ldr	r3, [r7, #12]
 800dfde:	691b      	ldr	r3, [r3, #16]
 800dfe0:	4a31      	ldr	r2, [pc, #196]	; (800e0a8 <btstack_crypto_run+0x218>)
 800dfe2:	4614      	mov	r4, r2
 800dfe4:	469c      	mov	ip, r3
 800dfe6:	f104 0e40 	add.w	lr, r4, #64	; 0x40
 800dfea:	4665      	mov	r5, ip
 800dfec:	4626      	mov	r6, r4
 800dfee:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800dff0:	6028      	str	r0, [r5, #0]
 800dff2:	6069      	str	r1, [r5, #4]
 800dff4:	60aa      	str	r2, [r5, #8]
 800dff6:	60eb      	str	r3, [r5, #12]
 800dff8:	3410      	adds	r4, #16
 800dffa:	f10c 0c10 	add.w	ip, ip, #16
 800dffe:	4574      	cmp	r4, lr
 800e000:	d1f3      	bne.n	800dfea <btstack_crypto_run+0x15a>
                        btstack_linked_list_pop(&btstack_crypto_operations);
 800e002:	4824      	ldr	r0, [pc, #144]	; (800e094 <btstack_crypto_run+0x204>)
 800e004:	f000 fb8c 	bl	800e720 <btstack_linked_list_pop>
                        (*btstack_crypto_ec_p192->btstack_crypto.context_callback.callback)(btstack_crypto_ec_p192->btstack_crypto.context_callback.context);
 800e008:	68fb      	ldr	r3, [r7, #12]
 800e00a:	685b      	ldr	r3, [r3, #4]
 800e00c:	68fa      	ldr	r2, [r7, #12]
 800e00e:	6892      	ldr	r2, [r2, #8]
 800e010:	4610      	mov	r0, r2
 800e012:	4798      	blx	r3
                        break;
 800e014:	e021      	b.n	800e05a <btstack_crypto_run+0x1ca>
                        log_info("start ecc random");
 800e016:	f240 33ab 	movw	r3, #939	; 0x3ab
 800e01a:	4a24      	ldr	r2, [pc, #144]	; (800e0ac <btstack_crypto_run+0x21c>)
 800e01c:	4924      	ldr	r1, [pc, #144]	; (800e0b0 <btstack_crypto_run+0x220>)
 800e01e:	2001      	movs	r0, #1
 800e020:	f009 fa0e 	bl	8017440 <hci_dump_log>
                        btstack_crypto_ecc_p256_key_generation_state = ECC_P256_KEY_GENERATION_GENERATING_RANDOM;
 800e024:	4b1f      	ldr	r3, [pc, #124]	; (800e0a4 <btstack_crypto_run+0x214>)
 800e026:	2201      	movs	r2, #1
 800e028:	701a      	strb	r2, [r3, #0]
                        btstack_crypto_ecc_p256_random_offset = 0;
 800e02a:	4b22      	ldr	r3, [pc, #136]	; (800e0b4 <btstack_crypto_run+0x224>)
 800e02c:	2200      	movs	r2, #0
 800e02e:	701a      	strb	r2, [r3, #0]
                        btstack_crypto_wait_for_hci_result = true;
 800e030:	4b19      	ldr	r3, [pc, #100]	; (800e098 <btstack_crypto_run+0x208>)
 800e032:	2201      	movs	r2, #1
 800e034:	701a      	strb	r2, [r3, #0]
                        hci_send_cmd(&hci_le_rand);
 800e036:	4819      	ldr	r0, [pc, #100]	; (800e09c <btstack_crypto_run+0x20c>)
 800e038:	f007 ffd2 	bl	8015fe0 <hci_send_cmd>
                        break;
 800e03c:	e00d      	b.n	800e05a <btstack_crypto_run+0x1ca>
                        log_info("more ecc random");
 800e03e:	f44f 736e 	mov.w	r3, #952	; 0x3b8
 800e042:	4a1a      	ldr	r2, [pc, #104]	; (800e0ac <btstack_crypto_run+0x21c>)
 800e044:	491c      	ldr	r1, [pc, #112]	; (800e0b8 <btstack_crypto_run+0x228>)
 800e046:	2001      	movs	r0, #1
 800e048:	f009 f9fa 	bl	8017440 <hci_dump_log>
                        btstack_crypto_wait_for_hci_result = true;
 800e04c:	4b12      	ldr	r3, [pc, #72]	; (800e098 <btstack_crypto_run+0x208>)
 800e04e:	2201      	movs	r2, #1
 800e050:	701a      	strb	r2, [r3, #0]
                        hci_send_cmd(&hci_le_rand);
 800e052:	4812      	ldr	r0, [pc, #72]	; (800e09c <btstack_crypto_run+0x20c>)
 800e054:	f007 ffc4 	bl	8015fe0 <hci_send_cmd>
                        break;
 800e058:	bf00      	nop
                }
                break;
 800e05a:	e00f      	b.n	800e07c <btstack_crypto_run+0x1ec>
            case BTSTACK_CRYPTO_ECC_P256_CALCULATE_DHKEY:
                btstack_crypto_ec_p192 = (btstack_crypto_ecc_p256_t *) btstack_crypto;
 800e05c:	697b      	ldr	r3, [r7, #20]
 800e05e:	60fb      	str	r3, [r7, #12]
#ifdef USE_SOFTWARE_ECC_P256_IMPLEMENTATION
                btstack_crypto_ecc_p256_calculate_dhkey_software(btstack_crypto_ec_p192);
 800e060:	68f8      	ldr	r0, [r7, #12]
 800e062:	f7ff fcc1 	bl	800d9e8 <btstack_crypto_ecc_p256_calculate_dhkey_software>
                // done
                btstack_linked_list_pop(&btstack_crypto_operations);
 800e066:	480b      	ldr	r0, [pc, #44]	; (800e094 <btstack_crypto_run+0x204>)
 800e068:	f000 fb5a 	bl	800e720 <btstack_linked_list_pop>
                (*btstack_crypto_ec_p192->btstack_crypto.context_callback.callback)(btstack_crypto_ec_p192->btstack_crypto.context_callback.context);
 800e06c:	68fb      	ldr	r3, [r7, #12]
 800e06e:	685b      	ldr	r3, [r3, #4]
 800e070:	68fa      	ldr	r2, [r7, #12]
 800e072:	6892      	ldr	r2, [r2, #8]
 800e074:	4610      	mov	r0, r2
 800e076:	4798      	blx	r3
#else
                btstack_crypto_wait_for_hci_result = 1;
                hci_send_cmd(&hci_le_generate_dhkey, &btstack_crypto_ec_p192->public_key[0], &btstack_crypto_ec_p192->public_key[32]);
#endif
                break;
 800e078:	e000      	b.n	800e07c <btstack_crypto_run+0x1ec>

#endif /* ENABLE_ECC_P256 */

            default:
                break;
 800e07a:	bf00      	nop
    while (true){
 800e07c:	e711      	b.n	800dea2 <btstack_crypto_run+0x12>
    if (hci_get_state() != HCI_STATE_WORKING) return;
 800e07e:	bf00      	nop
 800e080:	e004      	b.n	800e08c <btstack_crypto_run+0x1fc>
        if (btstack_linked_list_empty(&btstack_crypto_operations)) return;
 800e082:	bf00      	nop
 800e084:	e002      	b.n	800e08c <btstack_crypto_run+0x1fc>
        if (btstack_crypto_wait_for_hci_result) return;
 800e086:	bf00      	nop
 800e088:	e000      	b.n	800e08c <btstack_crypto_run+0x1fc>
        if (!hci_can_send_command_packet_now()) return;
 800e08a:	bf00      	nop
        }
    }
}
 800e08c:	371c      	adds	r7, #28
 800e08e:	46bd      	mov	sp, r7
 800e090:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e092:	bf00      	nop
 800e094:	20006178 	.word	0x20006178
 800e098:	20006175 	.word	0x20006175
 800e09c:	08030bf8 	.word	0x08030bf8
 800e0a0:	20006184 	.word	0x20006184
 800e0a4:	2000624e 	.word	0x2000624e
 800e0a8:	200061cc 	.word	0x200061cc
 800e0ac:	08028fb8 	.word	0x08028fb8
 800e0b0:	08029180 	.word	0x08029180
 800e0b4:	2000624d 	.word	0x2000624d
 800e0b8:	08029198 	.word	0x08029198

0800e0bc <btstack_crypto_handle_random_data>:

static void btstack_crypto_handle_random_data(const uint8_t * data, uint16_t len){
 800e0bc:	b580      	push	{r7, lr}
 800e0be:	b086      	sub	sp, #24
 800e0c0:	af00      	add	r7, sp, #0
 800e0c2:	6078      	str	r0, [r7, #4]
 800e0c4:	460b      	mov	r3, r1
 800e0c6:	807b      	strh	r3, [r7, #2]
    btstack_crypto_random_t * btstack_crypto_random;
    btstack_crypto_t * btstack_crypto = (btstack_crypto_t*) btstack_linked_list_get_first_item(&btstack_crypto_operations);
 800e0c8:	4831      	ldr	r0, [pc, #196]	; (800e190 <btstack_crypto_handle_random_data+0xd4>)
 800e0ca:	f000 fb1d 	bl	800e708 <btstack_linked_list_get_first_item>
 800e0ce:	6178      	str	r0, [r7, #20]
    uint16_t bytes_to_copy;
	if (!btstack_crypto) return;
 800e0d0:	697b      	ldr	r3, [r7, #20]
 800e0d2:	2b00      	cmp	r3, #0
 800e0d4:	d057      	beq.n	800e186 <btstack_crypto_handle_random_data+0xca>
    switch (btstack_crypto->operation){
 800e0d6:	697b      	ldr	r3, [r7, #20]
 800e0d8:	7b1b      	ldrb	r3, [r3, #12]
 800e0da:	2b00      	cmp	r3, #0
 800e0dc:	d002      	beq.n	800e0e4 <btstack_crypto_handle_random_data+0x28>
 800e0de:	2b04      	cmp	r3, #4
 800e0e0:	d02e      	beq.n	800e140 <btstack_crypto_handle_random_data+0x84>
                btstack_crypto_ecc_p256_key_generation_state = ECC_P256_KEY_GENERATION_DONE;
            }
            break;
#endif
        default:
            break;
 800e0e2:	e04d      	b.n	800e180 <btstack_crypto_handle_random_data+0xc4>
            btstack_crypto_random = (btstack_crypto_random_t*) btstack_crypto;
 800e0e4:	697b      	ldr	r3, [r7, #20]
 800e0e6:	613b      	str	r3, [r7, #16]
            bytes_to_copy = btstack_min(btstack_crypto_random->size, len);
 800e0e8:	693b      	ldr	r3, [r7, #16]
 800e0ea:	8a9b      	ldrh	r3, [r3, #20]
 800e0ec:	461a      	mov	r2, r3
 800e0ee:	887b      	ldrh	r3, [r7, #2]
 800e0f0:	4619      	mov	r1, r3
 800e0f2:	4610      	mov	r0, r2
 800e0f4:	f001 f80b 	bl	800f10e <btstack_min>
 800e0f8:	4603      	mov	r3, r0
 800e0fa:	81fb      	strh	r3, [r7, #14]
            (void)memcpy(btstack_crypto_random->buffer, data, bytes_to_copy);
 800e0fc:	693b      	ldr	r3, [r7, #16]
 800e0fe:	691b      	ldr	r3, [r3, #16]
 800e100:	89fa      	ldrh	r2, [r7, #14]
 800e102:	6879      	ldr	r1, [r7, #4]
 800e104:	4618      	mov	r0, r3
 800e106:	f019 fcb8 	bl	8027a7a <memcpy>
            btstack_crypto_random->buffer += bytes_to_copy;
 800e10a:	693b      	ldr	r3, [r7, #16]
 800e10c:	691a      	ldr	r2, [r3, #16]
 800e10e:	89fb      	ldrh	r3, [r7, #14]
 800e110:	441a      	add	r2, r3
 800e112:	693b      	ldr	r3, [r7, #16]
 800e114:	611a      	str	r2, [r3, #16]
            btstack_crypto_random->size   -= bytes_to_copy;
 800e116:	693b      	ldr	r3, [r7, #16]
 800e118:	8a9a      	ldrh	r2, [r3, #20]
 800e11a:	89fb      	ldrh	r3, [r7, #14]
 800e11c:	1ad3      	subs	r3, r2, r3
 800e11e:	b29a      	uxth	r2, r3
 800e120:	693b      	ldr	r3, [r7, #16]
 800e122:	829a      	strh	r2, [r3, #20]
            if (!btstack_crypto_random->size) {
 800e124:	693b      	ldr	r3, [r7, #16]
 800e126:	8a9b      	ldrh	r3, [r3, #20]
 800e128:	2b00      	cmp	r3, #0
 800e12a:	d126      	bne.n	800e17a <btstack_crypto_handle_random_data+0xbe>
                btstack_linked_list_pop(&btstack_crypto_operations);
 800e12c:	4818      	ldr	r0, [pc, #96]	; (800e190 <btstack_crypto_handle_random_data+0xd4>)
 800e12e:	f000 faf7 	bl	800e720 <btstack_linked_list_pop>
                (*btstack_crypto_random->btstack_crypto.context_callback.callback)(btstack_crypto_random->btstack_crypto.context_callback.context);
 800e132:	693b      	ldr	r3, [r7, #16]
 800e134:	685b      	ldr	r3, [r3, #4]
 800e136:	693a      	ldr	r2, [r7, #16]
 800e138:	6892      	ldr	r2, [r2, #8]
 800e13a:	4610      	mov	r0, r2
 800e13c:	4798      	blx	r3
            break;
 800e13e:	e01c      	b.n	800e17a <btstack_crypto_handle_random_data+0xbe>
            (void)memcpy(&btstack_crypto_ecc_p256_random[btstack_crypto_ecc_p256_random_len],
 800e140:	4b14      	ldr	r3, [pc, #80]	; (800e194 <btstack_crypto_handle_random_data+0xd8>)
 800e142:	781b      	ldrb	r3, [r3, #0]
 800e144:	461a      	mov	r2, r3
 800e146:	4b14      	ldr	r3, [pc, #80]	; (800e198 <btstack_crypto_handle_random_data+0xdc>)
 800e148:	4413      	add	r3, r2
 800e14a:	2208      	movs	r2, #8
 800e14c:	6879      	ldr	r1, [r7, #4]
 800e14e:	4618      	mov	r0, r3
 800e150:	f019 fc93 	bl	8027a7a <memcpy>
            btstack_crypto_ecc_p256_random_len += 8u;
 800e154:	4b0f      	ldr	r3, [pc, #60]	; (800e194 <btstack_crypto_handle_random_data+0xd8>)
 800e156:	781b      	ldrb	r3, [r3, #0]
 800e158:	3308      	adds	r3, #8
 800e15a:	b2da      	uxtb	r2, r3
 800e15c:	4b0d      	ldr	r3, [pc, #52]	; (800e194 <btstack_crypto_handle_random_data+0xd8>)
 800e15e:	701a      	strb	r2, [r3, #0]
            if (btstack_crypto_ecc_p256_random_len >= 64u) {
 800e160:	4b0c      	ldr	r3, [pc, #48]	; (800e194 <btstack_crypto_handle_random_data+0xd8>)
 800e162:	781b      	ldrb	r3, [r3, #0]
 800e164:	2b3f      	cmp	r3, #63	; 0x3f
 800e166:	d90a      	bls.n	800e17e <btstack_crypto_handle_random_data+0xc2>
                btstack_crypto_ecc_p256_key_generation_state = ECC_P256_KEY_GENERATION_ACTIVE;
 800e168:	4b0c      	ldr	r3, [pc, #48]	; (800e19c <btstack_crypto_handle_random_data+0xe0>)
 800e16a:	2202      	movs	r2, #2
 800e16c:	701a      	strb	r2, [r3, #0]
                btstack_crypto_ecc_p256_generate_key_software();
 800e16e:	f7ff fc19 	bl	800d9a4 <btstack_crypto_ecc_p256_generate_key_software>
                btstack_crypto_ecc_p256_key_generation_state = ECC_P256_KEY_GENERATION_DONE;
 800e172:	4b0a      	ldr	r3, [pc, #40]	; (800e19c <btstack_crypto_handle_random_data+0xe0>)
 800e174:	2204      	movs	r2, #4
 800e176:	701a      	strb	r2, [r3, #0]
            break;
 800e178:	e001      	b.n	800e17e <btstack_crypto_handle_random_data+0xc2>
            break;
 800e17a:	bf00      	nop
 800e17c:	e000      	b.n	800e180 <btstack_crypto_handle_random_data+0xc4>
            break;
 800e17e:	bf00      	nop
    }
	// more work?
	btstack_crypto_run();
 800e180:	f7ff fe86 	bl	800de90 <btstack_crypto_run>
 800e184:	e000      	b.n	800e188 <btstack_crypto_handle_random_data+0xcc>
	if (!btstack_crypto) return;
 800e186:	bf00      	nop
}
 800e188:	3718      	adds	r7, #24
 800e18a:	46bd      	mov	sp, r7
 800e18c:	bd80      	pop	{r7, pc}
 800e18e:	bf00      	nop
 800e190:	20006178 	.word	0x20006178
 800e194:	2000624c 	.word	0x2000624c
 800e198:	2000620c 	.word	0x2000620c
 800e19c:	2000624e 	.word	0x2000624e

0800e1a0 <btstack_crypto_handle_encryption_result>:

#ifndef USE_BTSTACK_AES128
static void btstack_crypto_handle_encryption_result(const uint8_t * data){
 800e1a0:	b580      	push	{r7, lr}
 800e1a2:	b08a      	sub	sp, #40	; 0x28
 800e1a4:	af00      	add	r7, sp, #0
 800e1a6:	6078      	str	r0, [r7, #4]
	btstack_crypto_aes128_t      * btstack_crypto_aes128;
	btstack_crypto_aes128_cmac_t * btstack_crypto_cmac;
    btstack_crypto_ccm_t         * btstack_crypto_ccm;
	uint8_t result[16];

    btstack_crypto_t * btstack_crypto = (btstack_crypto_t*) btstack_linked_list_get_first_item(&btstack_crypto_operations);
 800e1a8:	4846      	ldr	r0, [pc, #280]	; (800e2c4 <btstack_crypto_handle_encryption_result+0x124>)
 800e1aa:	f000 faad 	bl	800e708 <btstack_linked_list_get_first_item>
 800e1ae:	6278      	str	r0, [r7, #36]	; 0x24
	if (!btstack_crypto) return;
 800e1b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e1b2:	2b00      	cmp	r3, #0
 800e1b4:	f000 8080 	beq.w	800e2b8 <btstack_crypto_handle_encryption_result+0x118>
	switch (btstack_crypto->operation){
 800e1b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e1ba:	7b1b      	ldrb	r3, [r3, #12]
 800e1bc:	3b01      	subs	r3, #1
 800e1be:	2b07      	cmp	r3, #7
 800e1c0:	d87c      	bhi.n	800e2bc <btstack_crypto_handle_encryption_result+0x11c>
 800e1c2:	a201      	add	r2, pc, #4	; (adr r2, 800e1c8 <btstack_crypto_handle_encryption_result+0x28>)
 800e1c4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e1c8:	0800e1e9 	.word	0x0800e1e9
 800e1cc:	0800e205 	.word	0x0800e205
 800e1d0:	0800e205 	.word	0x0800e205
 800e1d4:	0800e2bd 	.word	0x0800e2bd
 800e1d8:	0800e2bd 	.word	0x0800e2bd
 800e1dc:	0800e227 	.word	0x0800e227
 800e1e0:	0800e227 	.word	0x0800e227
 800e1e4:	0800e227 	.word	0x0800e227
		case BTSTACK_CRYPTO_AES128:
			btstack_crypto_aes128 = (btstack_crypto_aes128_t*) btstack_linked_list_get_first_item(&btstack_crypto_operations);
 800e1e8:	4836      	ldr	r0, [pc, #216]	; (800e2c4 <btstack_crypto_handle_encryption_result+0x124>)
 800e1ea:	f000 fa8d 	bl	800e708 <btstack_linked_list_get_first_item>
 800e1ee:	61b8      	str	r0, [r7, #24]
		    reverse_128(data, btstack_crypto_aes128->ciphertext);
 800e1f0:	69bb      	ldr	r3, [r7, #24]
 800e1f2:	699b      	ldr	r3, [r3, #24]
 800e1f4:	4619      	mov	r1, r3
 800e1f6:	6878      	ldr	r0, [r7, #4]
 800e1f8:	f000 ff5f 	bl	800f0ba <reverse_128>
            btstack_crypto_done(btstack_crypto);
 800e1fc:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e1fe:	f7ff f85b 	bl	800d2b8 <btstack_crypto_done>
			break;
 800e202:	e05c      	b.n	800e2be <btstack_crypto_handle_encryption_result+0x11e>
		case BTSTACK_CRYPTO_CMAC_GENERATOR:
		case BTSTACK_CRYPTO_CMAC_MESSAGE:
			btstack_crypto_cmac = (btstack_crypto_aes128_cmac_t*) btstack_linked_list_get_first_item(&btstack_crypto_operations);
 800e204:	482f      	ldr	r0, [pc, #188]	; (800e2c4 <btstack_crypto_handle_encryption_result+0x124>)
 800e206:	f000 fa7f 	bl	800e708 <btstack_linked_list_get_first_item>
 800e20a:	61f8      	str	r0, [r7, #28]
		    reverse_128(data, result);
 800e20c:	f107 0308 	add.w	r3, r7, #8
 800e210:	4619      	mov	r1, r3
 800e212:	6878      	ldr	r0, [r7, #4]
 800e214:	f000 ff51 	bl	800f0ba <reverse_128>
		    btstack_crypto_cmac_handle_encryption_result(btstack_crypto_cmac, result);
 800e218:	f107 0308 	add.w	r3, r7, #8
 800e21c:	4619      	mov	r1, r3
 800e21e:	69f8      	ldr	r0, [r7, #28]
 800e220:	f7ff fa48 	bl	800d6b4 <btstack_crypto_cmac_handle_encryption_result>
			break;
 800e224:	e04b      	b.n	800e2be <btstack_crypto_handle_encryption_result+0x11e>
        case BTSTACK_CRYPTO_CCM_DIGEST_BLOCK:
        case BTSTACK_CRYPTO_CCM_ENCRYPT_BLOCK:
        case BTSTACK_CRYPTO_CCM_DECRYPT_BLOCK:
            btstack_crypto_ccm = (btstack_crypto_ccm_t*) btstack_linked_list_get_first_item(&btstack_crypto_operations);
 800e226:	4827      	ldr	r0, [pc, #156]	; (800e2c4 <btstack_crypto_handle_encryption_result+0x124>)
 800e228:	f000 fa6e 	bl	800e708 <btstack_linked_list_get_first_item>
 800e22c:	6238      	str	r0, [r7, #32]
            switch (btstack_crypto_ccm->state){
 800e22e:	6a3b      	ldr	r3, [r7, #32]
 800e230:	7c1b      	ldrb	r3, [r3, #16]
 800e232:	3b01      	subs	r3, #1
 800e234:	2b08      	cmp	r3, #8
 800e236:	d83d      	bhi.n	800e2b4 <btstack_crypto_handle_encryption_result+0x114>
 800e238:	a201      	add	r2, pc, #4	; (adr r2, 800e240 <btstack_crypto_handle_encryption_result+0xa0>)
 800e23a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e23e:	bf00      	nop
 800e240:	0800e265 	.word	0x0800e265
 800e244:	0800e2b5 	.word	0x0800e2b5
 800e248:	0800e28d 	.word	0x0800e28d
 800e24c:	0800e2b5 	.word	0x0800e2b5
 800e250:	0800e279 	.word	0x0800e279
 800e254:	0800e2b5 	.word	0x0800e2b5
 800e258:	0800e2a1 	.word	0x0800e2a1
 800e25c:	0800e2b5 	.word	0x0800e2b5
 800e260:	0800e2ab 	.word	0x0800e2ab
                case CCM_W4_X1:
                    reverse_128(data, btstack_crypto_ccm->x_i);
 800e264:	6a3b      	ldr	r3, [r7, #32]
 800e266:	3324      	adds	r3, #36	; 0x24
 800e268:	4619      	mov	r1, r3
 800e26a:	6878      	ldr	r0, [r7, #4]
 800e26c:	f000 ff25 	bl	800f0ba <reverse_128>
                    btstack_crypto_ccm_handle_x1(btstack_crypto_ccm);
 800e270:	6a38      	ldr	r0, [r7, #32]
 800e272:	f7ff fca7 	bl	800dbc4 <btstack_crypto_ccm_handle_x1>
                    break;
 800e276:	e01e      	b.n	800e2b6 <btstack_crypto_handle_encryption_result+0x116>
                case CCM_W4_XN:
                    reverse_128(data, btstack_crypto_ccm->x_i);
 800e278:	6a3b      	ldr	r3, [r7, #32]
 800e27a:	3324      	adds	r3, #36	; 0x24
 800e27c:	4619      	mov	r1, r3
 800e27e:	6878      	ldr	r0, [r7, #4]
 800e280:	f000 ff1b 	bl	800f0ba <reverse_128>
                    btstack_crypto_ccm_handle_xn(btstack_crypto_ccm);
 800e284:	6a38      	ldr	r0, [r7, #32]
 800e286:	f7ff fcc0 	bl	800dc0a <btstack_crypto_ccm_handle_xn>
                    break;
 800e28a:	e014      	b.n	800e2b6 <btstack_crypto_handle_encryption_result+0x116>
                case CCM_W4_AAD_XN:
                    reverse_128(data, btstack_crypto_ccm->x_i);
 800e28c:	6a3b      	ldr	r3, [r7, #32]
 800e28e:	3324      	adds	r3, #36	; 0x24
 800e290:	4619      	mov	r1, r3
 800e292:	6878      	ldr	r0, [r7, #4]
 800e294:	f000 ff11 	bl	800f0ba <reverse_128>
                    btstack_crypto_ccm_handle_aad_xn(btstack_crypto_ccm);
 800e298:	6a38      	ldr	r0, [r7, #32]
 800e29a:	f7ff fc7c 	bl	800db96 <btstack_crypto_ccm_handle_aad_xn>
                    break;
 800e29e:	e00a      	b.n	800e2b6 <btstack_crypto_handle_encryption_result+0x116>
                case CCM_W4_S0:
                    btstack_crypto_ccm_handle_s0(btstack_crypto_ccm, data);
 800e2a0:	6879      	ldr	r1, [r7, #4]
 800e2a2:	6a38      	ldr	r0, [r7, #32]
 800e2a4:	f7ff fc0f 	bl	800dac6 <btstack_crypto_ccm_handle_s0>
                    break;
 800e2a8:	e005      	b.n	800e2b6 <btstack_crypto_handle_encryption_result+0x116>
                case CCM_W4_SN:
                    btstack_crypto_ccm_handle_sn(btstack_crypto_ccm, data);
 800e2aa:	6879      	ldr	r1, [r7, #4]
 800e2ac:	6a38      	ldr	r0, [r7, #32]
 800e2ae:	f7ff fc34 	bl	800db1a <btstack_crypto_ccm_handle_sn>
                    break;
 800e2b2:	e000      	b.n	800e2b6 <btstack_crypto_handle_encryption_result+0x116>
                default:
                    break;
 800e2b4:	bf00      	nop
            }
            break;
 800e2b6:	e002      	b.n	800e2be <btstack_crypto_handle_encryption_result+0x11e>
	if (!btstack_crypto) return;
 800e2b8:	bf00      	nop
 800e2ba:	e000      	b.n	800e2be <btstack_crypto_handle_encryption_result+0x11e>
		default:
			break;
 800e2bc:	bf00      	nop
	}
}
 800e2be:	3728      	adds	r7, #40	; 0x28
 800e2c0:	46bd      	mov	sp, r7
 800e2c2:	bd80      	pop	{r7, pc}
 800e2c4:	20006178 	.word	0x20006178

0800e2c8 <btstack_crypto_event_handler>:
#endif

static void btstack_crypto_event_handler(uint8_t packet_type, uint16_t cid, uint8_t *packet, uint16_t size){
 800e2c8:	b580      	push	{r7, lr}
 800e2ca:	b088      	sub	sp, #32
 800e2cc:	af02      	add	r7, sp, #8
 800e2ce:	60ba      	str	r2, [r7, #8]
 800e2d0:	461a      	mov	r2, r3
 800e2d2:	4603      	mov	r3, r0
 800e2d4:	73fb      	strb	r3, [r7, #15]
 800e2d6:	460b      	mov	r3, r1
 800e2d8:	81bb      	strh	r3, [r7, #12]
 800e2da:	4613      	mov	r3, r2
 800e2dc:	80fb      	strh	r3, [r7, #6]
#ifndef USE_SOFTWARE_ECC_P256_IMPLEMENTATION
    btstack_crypto_ecc_p256_t * btstack_crypto_ec_p192;
#endif
#endif
    
    if (packet_type != HCI_EVENT_PACKET)  return;
 800e2de:	7bfb      	ldrb	r3, [r7, #15]
 800e2e0:	2b04      	cmp	r3, #4
 800e2e2:	d17e      	bne.n	800e3e2 <btstack_crypto_event_handler+0x11a>

    switch (hci_event_packet_get_type(packet)){
 800e2e4:	68b8      	ldr	r0, [r7, #8]
 800e2e6:	f7fe ffce 	bl	800d286 <hci_event_packet_get_type>
 800e2ea:	4603      	mov	r3, r0
 800e2ec:	2b0e      	cmp	r3, #14
 800e2ee:	d012      	beq.n	800e316 <btstack_crypto_event_handler+0x4e>
 800e2f0:	2b60      	cmp	r3, #96	; 0x60
 800e2f2:	d000      	beq.n	800e2f6 <btstack_crypto_event_handler+0x2e>
            }
            break;
#endif
#endif
        default:
            break;
 800e2f4:	e072      	b.n	800e3dc <btstack_crypto_event_handler+0x114>
            if (btstack_event_state_get_state(packet) != HCI_STATE_HALTING) break;
 800e2f6:	68b8      	ldr	r0, [r7, #8]
 800e2f8:	f7fe ffd1 	bl	800d29e <btstack_event_state_get_state>
 800e2fc:	4603      	mov	r3, r0
 800e2fe:	2b03      	cmp	r3, #3
 800e300:	d167      	bne.n	800e3d2 <btstack_crypto_event_handler+0x10a>
            if (!btstack_crypto_wait_for_hci_result) break;
 800e302:	4b3c      	ldr	r3, [pc, #240]	; (800e3f4 <btstack_crypto_event_handler+0x12c>)
 800e304:	781b      	ldrb	r3, [r3, #0]
 800e306:	f083 0301 	eor.w	r3, r3, #1
 800e30a:	b2db      	uxtb	r3, r3
 800e30c:	2b00      	cmp	r3, #0
 800e30e:	d162      	bne.n	800e3d6 <btstack_crypto_event_handler+0x10e>
            hci_halting_defer();
 800e310:	f008 fcf4 	bl	8016cfc <hci_halting_defer>
            break;
 800e314:	e062      	b.n	800e3dc <btstack_crypto_event_handler+0x114>
    	    if (HCI_EVENT_IS_COMMAND_COMPLETE(packet, hci_le_encrypt)){
 800e316:	68bb      	ldr	r3, [r7, #8]
 800e318:	781b      	ldrb	r3, [r3, #0]
 800e31a:	2b0e      	cmp	r3, #14
 800e31c:	d118      	bne.n	800e350 <btstack_crypto_event_handler+0x88>
 800e31e:	2103      	movs	r1, #3
 800e320:	68b8      	ldr	r0, [r7, #8]
 800e322:	f000 fd60 	bl	800ede6 <little_endian_read_16>
 800e326:	4603      	mov	r3, r0
 800e328:	461a      	mov	r2, r3
 800e32a:	4b33      	ldr	r3, [pc, #204]	; (800e3f8 <btstack_crypto_event_handler+0x130>)
 800e32c:	881b      	ldrh	r3, [r3, #0]
 800e32e:	429a      	cmp	r2, r3
 800e330:	d10e      	bne.n	800e350 <btstack_crypto_event_handler+0x88>
                if (!btstack_crypto_wait_for_hci_result) return;
 800e332:	4b30      	ldr	r3, [pc, #192]	; (800e3f4 <btstack_crypto_event_handler+0x12c>)
 800e334:	781b      	ldrb	r3, [r3, #0]
 800e336:	f083 0301 	eor.w	r3, r3, #1
 800e33a:	b2db      	uxtb	r3, r3
 800e33c:	2b00      	cmp	r3, #0
 800e33e:	d152      	bne.n	800e3e6 <btstack_crypto_event_handler+0x11e>
                btstack_crypto_wait_for_hci_result = 0;
 800e340:	4b2c      	ldr	r3, [pc, #176]	; (800e3f4 <btstack_crypto_event_handler+0x12c>)
 800e342:	2200      	movs	r2, #0
 800e344:	701a      	strb	r2, [r3, #0]
    	        btstack_crypto_handle_encryption_result(&packet[6]);
 800e346:	68bb      	ldr	r3, [r7, #8]
 800e348:	3306      	adds	r3, #6
 800e34a:	4618      	mov	r0, r3
 800e34c:	f7ff ff28 	bl	800e1a0 <btstack_crypto_handle_encryption_result>
    	    if (HCI_EVENT_IS_COMMAND_COMPLETE(packet, hci_le_rand)){
 800e350:	68bb      	ldr	r3, [r7, #8]
 800e352:	781b      	ldrb	r3, [r3, #0]
 800e354:	2b0e      	cmp	r3, #14
 800e356:	d119      	bne.n	800e38c <btstack_crypto_event_handler+0xc4>
 800e358:	2103      	movs	r1, #3
 800e35a:	68b8      	ldr	r0, [r7, #8]
 800e35c:	f000 fd43 	bl	800ede6 <little_endian_read_16>
 800e360:	4603      	mov	r3, r0
 800e362:	461a      	mov	r2, r3
 800e364:	4b25      	ldr	r3, [pc, #148]	; (800e3fc <btstack_crypto_event_handler+0x134>)
 800e366:	881b      	ldrh	r3, [r3, #0]
 800e368:	429a      	cmp	r2, r3
 800e36a:	d10f      	bne.n	800e38c <btstack_crypto_event_handler+0xc4>
                if (!btstack_crypto_wait_for_hci_result) return;
 800e36c:	4b21      	ldr	r3, [pc, #132]	; (800e3f4 <btstack_crypto_event_handler+0x12c>)
 800e36e:	781b      	ldrb	r3, [r3, #0]
 800e370:	f083 0301 	eor.w	r3, r3, #1
 800e374:	b2db      	uxtb	r3, r3
 800e376:	2b00      	cmp	r3, #0
 800e378:	d137      	bne.n	800e3ea <btstack_crypto_event_handler+0x122>
                btstack_crypto_wait_for_hci_result = false;
 800e37a:	4b1e      	ldr	r3, [pc, #120]	; (800e3f4 <btstack_crypto_event_handler+0x12c>)
 800e37c:	2200      	movs	r2, #0
 800e37e:	701a      	strb	r2, [r3, #0]
                btstack_crypto_handle_random_data(&packet[6], 8);
 800e380:	68bb      	ldr	r3, [r7, #8]
 800e382:	3306      	adds	r3, #6
 800e384:	2108      	movs	r1, #8
 800e386:	4618      	mov	r0, r3
 800e388:	f7ff fe98 	bl	800e0bc <btstack_crypto_handle_random_data>
            if (HCI_EVENT_IS_COMMAND_COMPLETE(packet, hci_read_local_supported_commands)){
 800e38c:	68bb      	ldr	r3, [r7, #8]
 800e38e:	781b      	ldrb	r3, [r3, #0]
 800e390:	2b0e      	cmp	r3, #14
 800e392:	d122      	bne.n	800e3da <btstack_crypto_event_handler+0x112>
 800e394:	2103      	movs	r1, #3
 800e396:	68b8      	ldr	r0, [r7, #8]
 800e398:	f000 fd25 	bl	800ede6 <little_endian_read_16>
 800e39c:	4603      	mov	r3, r0
 800e39e:	461a      	mov	r2, r3
 800e3a0:	4b17      	ldr	r3, [pc, #92]	; (800e400 <btstack_crypto_event_handler+0x138>)
 800e3a2:	881b      	ldrh	r3, [r3, #0]
 800e3a4:	429a      	cmp	r2, r3
 800e3a6:	d118      	bne.n	800e3da <btstack_crypto_event_handler+0x112>
                int ecdh_operations_supported = (packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+34u] & 0x06u) == 0x06u;
 800e3a8:	68bb      	ldr	r3, [r7, #8]
 800e3aa:	3328      	adds	r3, #40	; 0x28
 800e3ac:	781b      	ldrb	r3, [r3, #0]
 800e3ae:	f003 0306 	and.w	r3, r3, #6
 800e3b2:	2b06      	cmp	r3, #6
 800e3b4:	bf0c      	ite	eq
 800e3b6:	2301      	moveq	r3, #1
 800e3b8:	2300      	movne	r3, #0
 800e3ba:	b2db      	uxtb	r3, r3
 800e3bc:	617b      	str	r3, [r7, #20]
                log_info("controller supports ECDH operation: %u", ecdh_operations_supported);
 800e3be:	697b      	ldr	r3, [r7, #20]
 800e3c0:	9300      	str	r3, [sp, #0]
 800e3c2:	f240 4356 	movw	r3, #1110	; 0x456
 800e3c6:	4a0f      	ldr	r2, [pc, #60]	; (800e404 <btstack_crypto_event_handler+0x13c>)
 800e3c8:	490f      	ldr	r1, [pc, #60]	; (800e408 <btstack_crypto_event_handler+0x140>)
 800e3ca:	2001      	movs	r0, #1
 800e3cc:	f009 f838 	bl	8017440 <hci_dump_log>
            break;
 800e3d0:	e003      	b.n	800e3da <btstack_crypto_event_handler+0x112>
            if (btstack_event_state_get_state(packet) != HCI_STATE_HALTING) break;
 800e3d2:	bf00      	nop
 800e3d4:	e002      	b.n	800e3dc <btstack_crypto_event_handler+0x114>
            if (!btstack_crypto_wait_for_hci_result) break;
 800e3d6:	bf00      	nop
 800e3d8:	e000      	b.n	800e3dc <btstack_crypto_event_handler+0x114>
            break;
 800e3da:	bf00      	nop
    }

    // try processing
	btstack_crypto_run();    
 800e3dc:	f7ff fd58 	bl	800de90 <btstack_crypto_run>
 800e3e0:	e004      	b.n	800e3ec <btstack_crypto_event_handler+0x124>
    if (packet_type != HCI_EVENT_PACKET)  return;
 800e3e2:	bf00      	nop
 800e3e4:	e002      	b.n	800e3ec <btstack_crypto_event_handler+0x124>
                if (!btstack_crypto_wait_for_hci_result) return;
 800e3e6:	bf00      	nop
 800e3e8:	e000      	b.n	800e3ec <btstack_crypto_event_handler+0x124>
                if (!btstack_crypto_wait_for_hci_result) return;
 800e3ea:	bf00      	nop
}
 800e3ec:	3718      	adds	r7, #24
 800e3ee:	46bd      	mov	sp, r7
 800e3f0:	bd80      	pop	{r7, pc}
 800e3f2:	bf00      	nop
 800e3f4:	20006175 	.word	0x20006175
 800e3f8:	08030bf0 	.word	0x08030bf0
 800e3fc:	08030bf8 	.word	0x08030bf8
 800e400:	08030b48 	.word	0x08030b48
 800e404:	08028fb8 	.word	0x08028fb8
 800e408:	080291b0 	.word	0x080291b0

0800e40c <btstack_crypto_init>:

void btstack_crypto_init(void){
 800e40c:	b580      	push	{r7, lr}
 800e40e:	af00      	add	r7, sp, #0
	if (btstack_crypto_initialized) return;
 800e410:	4b07      	ldr	r3, [pc, #28]	; (800e430 <btstack_crypto_init+0x24>)
 800e412:	781b      	ldrb	r3, [r3, #0]
 800e414:	2b00      	cmp	r3, #0
 800e416:	d109      	bne.n	800e42c <btstack_crypto_init+0x20>
	btstack_crypto_initialized = true;
 800e418:	4b05      	ldr	r3, [pc, #20]	; (800e430 <btstack_crypto_init+0x24>)
 800e41a:	2201      	movs	r2, #1
 800e41c:	701a      	strb	r2, [r3, #0]

	// register with HCI
    hci_event_callback_registration.callback = &btstack_crypto_event_handler;
 800e41e:	4b05      	ldr	r3, [pc, #20]	; (800e434 <btstack_crypto_init+0x28>)
 800e420:	4a05      	ldr	r2, [pc, #20]	; (800e438 <btstack_crypto_init+0x2c>)
 800e422:	605a      	str	r2, [r3, #4]
    hci_add_event_handler(&hci_event_callback_registration);
 800e424:	4803      	ldr	r0, [pc, #12]	; (800e434 <btstack_crypto_init+0x28>)
 800e426:	f005 fd65 	bl	8013ef4 <hci_add_event_handler>
 800e42a:	e000      	b.n	800e42e <btstack_crypto_init+0x22>
	if (btstack_crypto_initialized) return;
 800e42c:	bf00      	nop

#ifdef USE_MBEDTLS_ECC_P256
	mbedtls_ecp_group_init(&mbedtls_ec_group);
	mbedtls_ecp_group_load(&mbedtls_ec_group, MBEDTLS_ECP_DP_SECP256R1);
#endif
}
 800e42e:	bd80      	pop	{r7, pc}
 800e430:	20006174 	.word	0x20006174
 800e434:	2000617c 	.word	0x2000617c
 800e438:	0800e2c9 	.word	0x0800e2c9

0800e43c <btstack_crypto_random_generate>:

void btstack_crypto_random_generate(btstack_crypto_random_t * request, uint8_t * buffer, uint16_t size, void (* callback)(void * arg), void * callback_arg){
 800e43c:	b580      	push	{r7, lr}
 800e43e:	b084      	sub	sp, #16
 800e440:	af00      	add	r7, sp, #0
 800e442:	60f8      	str	r0, [r7, #12]
 800e444:	60b9      	str	r1, [r7, #8]
 800e446:	603b      	str	r3, [r7, #0]
 800e448:	4613      	mov	r3, r2
 800e44a:	80fb      	strh	r3, [r7, #6]
	request->btstack_crypto.context_callback.callback  = callback;
 800e44c:	68fb      	ldr	r3, [r7, #12]
 800e44e:	683a      	ldr	r2, [r7, #0]
 800e450:	605a      	str	r2, [r3, #4]
	request->btstack_crypto.context_callback.context   = callback_arg;
 800e452:	68fb      	ldr	r3, [r7, #12]
 800e454:	69ba      	ldr	r2, [r7, #24]
 800e456:	609a      	str	r2, [r3, #8]
	request->btstack_crypto.operation         		   = BTSTACK_CRYPTO_RANDOM;
 800e458:	68fb      	ldr	r3, [r7, #12]
 800e45a:	2200      	movs	r2, #0
 800e45c:	731a      	strb	r2, [r3, #12]
	request->buffer = buffer;
 800e45e:	68fb      	ldr	r3, [r7, #12]
 800e460:	68ba      	ldr	r2, [r7, #8]
 800e462:	611a      	str	r2, [r3, #16]
	request->size   = size;
 800e464:	68fb      	ldr	r3, [r7, #12]
 800e466:	88fa      	ldrh	r2, [r7, #6]
 800e468:	829a      	strh	r2, [r3, #20]
	btstack_linked_list_add_tail(&btstack_crypto_operations, (btstack_linked_item_t*) request);
 800e46a:	68f9      	ldr	r1, [r7, #12]
 800e46c:	4804      	ldr	r0, [pc, #16]	; (800e480 <btstack_crypto_random_generate+0x44>)
 800e46e:	f000 f903 	bl	800e678 <btstack_linked_list_add_tail>
	btstack_crypto_run();
 800e472:	f7ff fd0d 	bl	800de90 <btstack_crypto_run>
}
 800e476:	bf00      	nop
 800e478:	3710      	adds	r7, #16
 800e47a:	46bd      	mov	sp, r7
 800e47c:	bd80      	pop	{r7, pc}
 800e47e:	bf00      	nop
 800e480:	20006178 	.word	0x20006178

0800e484 <btstack_crypto_aes128_encrypt>:

void btstack_crypto_aes128_encrypt(btstack_crypto_aes128_t * request, const uint8_t * key, const uint8_t * plaintext, uint8_t * ciphertext, void (* callback)(void * arg), void * callback_arg){
 800e484:	b580      	push	{r7, lr}
 800e486:	b084      	sub	sp, #16
 800e488:	af00      	add	r7, sp, #0
 800e48a:	60f8      	str	r0, [r7, #12]
 800e48c:	60b9      	str	r1, [r7, #8]
 800e48e:	607a      	str	r2, [r7, #4]
 800e490:	603b      	str	r3, [r7, #0]
	request->btstack_crypto.context_callback.callback  = callback;
 800e492:	68fb      	ldr	r3, [r7, #12]
 800e494:	69ba      	ldr	r2, [r7, #24]
 800e496:	605a      	str	r2, [r3, #4]
	request->btstack_crypto.context_callback.context   = callback_arg;
 800e498:	68fb      	ldr	r3, [r7, #12]
 800e49a:	69fa      	ldr	r2, [r7, #28]
 800e49c:	609a      	str	r2, [r3, #8]
	request->btstack_crypto.operation         		   = BTSTACK_CRYPTO_AES128;
 800e49e:	68fb      	ldr	r3, [r7, #12]
 800e4a0:	2201      	movs	r2, #1
 800e4a2:	731a      	strb	r2, [r3, #12]
	request->key 									   = key;
 800e4a4:	68fb      	ldr	r3, [r7, #12]
 800e4a6:	68ba      	ldr	r2, [r7, #8]
 800e4a8:	611a      	str	r2, [r3, #16]
	request->plaintext      					       = plaintext;
 800e4aa:	68fb      	ldr	r3, [r7, #12]
 800e4ac:	687a      	ldr	r2, [r7, #4]
 800e4ae:	615a      	str	r2, [r3, #20]
	request->ciphertext 							   = ciphertext;
 800e4b0:	68fb      	ldr	r3, [r7, #12]
 800e4b2:	683a      	ldr	r2, [r7, #0]
 800e4b4:	619a      	str	r2, [r3, #24]
	btstack_linked_list_add_tail(&btstack_crypto_operations, (btstack_linked_item_t*) request);
 800e4b6:	68f9      	ldr	r1, [r7, #12]
 800e4b8:	4804      	ldr	r0, [pc, #16]	; (800e4cc <btstack_crypto_aes128_encrypt+0x48>)
 800e4ba:	f000 f8dd 	bl	800e678 <btstack_linked_list_add_tail>
	btstack_crypto_run();
 800e4be:	f7ff fce7 	bl	800de90 <btstack_crypto_run>
}
 800e4c2:	bf00      	nop
 800e4c4:	3710      	adds	r7, #16
 800e4c6:	46bd      	mov	sp, r7
 800e4c8:	bd80      	pop	{r7, pc}
 800e4ca:	bf00      	nop
 800e4cc:	20006178 	.word	0x20006178

0800e4d0 <btstack_crypto_aes128_cmac_message>:
	request->hash 									   = hash;
	btstack_linked_list_add_tail(&btstack_crypto_operations, (btstack_linked_item_t*) request);
	btstack_crypto_run();
}

void btstack_crypto_aes128_cmac_message(btstack_crypto_aes128_cmac_t * request, const uint8_t * key, uint16_t size, const uint8_t * message, uint8_t * hash, void (* callback)(void * arg), void * callback_arg){
 800e4d0:	b580      	push	{r7, lr}
 800e4d2:	b084      	sub	sp, #16
 800e4d4:	af00      	add	r7, sp, #0
 800e4d6:	60f8      	str	r0, [r7, #12]
 800e4d8:	60b9      	str	r1, [r7, #8]
 800e4da:	603b      	str	r3, [r7, #0]
 800e4dc:	4613      	mov	r3, r2
 800e4de:	80fb      	strh	r3, [r7, #6]
	request->btstack_crypto.context_callback.callback  = callback;
 800e4e0:	68fb      	ldr	r3, [r7, #12]
 800e4e2:	69fa      	ldr	r2, [r7, #28]
 800e4e4:	605a      	str	r2, [r3, #4]
	request->btstack_crypto.context_callback.context   = callback_arg;
 800e4e6:	68fb      	ldr	r3, [r7, #12]
 800e4e8:	6a3a      	ldr	r2, [r7, #32]
 800e4ea:	609a      	str	r2, [r3, #8]
	request->btstack_crypto.operation         		   = BTSTACK_CRYPTO_CMAC_MESSAGE;
 800e4ec:	68fb      	ldr	r3, [r7, #12]
 800e4ee:	2203      	movs	r2, #3
 800e4f0:	731a      	strb	r2, [r3, #12]
	request->key 									   = key;
 800e4f2:	68fb      	ldr	r3, [r7, #12]
 800e4f4:	68ba      	ldr	r2, [r7, #8]
 800e4f6:	611a      	str	r2, [r3, #16]
	request->size 									   = size;
 800e4f8:	68fb      	ldr	r3, [r7, #12]
 800e4fa:	88fa      	ldrh	r2, [r7, #6]
 800e4fc:	829a      	strh	r2, [r3, #20]
	request->data.message      						   = message;
 800e4fe:	68fb      	ldr	r3, [r7, #12]
 800e500:	683a      	ldr	r2, [r7, #0]
 800e502:	619a      	str	r2, [r3, #24]
	request->hash 									   = hash;
 800e504:	68fb      	ldr	r3, [r7, #12]
 800e506:	69ba      	ldr	r2, [r7, #24]
 800e508:	61da      	str	r2, [r3, #28]
	btstack_linked_list_add_tail(&btstack_crypto_operations, (btstack_linked_item_t*) request);
 800e50a:	68f9      	ldr	r1, [r7, #12]
 800e50c:	4804      	ldr	r0, [pc, #16]	; (800e520 <btstack_crypto_aes128_cmac_message+0x50>)
 800e50e:	f000 f8b3 	bl	800e678 <btstack_linked_list_add_tail>
	btstack_crypto_run();
 800e512:	f7ff fcbd 	bl	800de90 <btstack_crypto_run>
}
 800e516:	bf00      	nop
 800e518:	3710      	adds	r7, #16
 800e51a:	46bd      	mov	sp, r7
 800e51c:	bd80      	pop	{r7, pc}
 800e51e:	bf00      	nop
 800e520:	20006178 	.word	0x20006178

0800e524 <btstack_crypto_ecc_p256_generate_key>:
    btstack_linked_list_add_tail(&btstack_crypto_operations, (btstack_linked_item_t*) request);
    btstack_crypto_run();
}

#ifdef ENABLE_ECC_P256
void btstack_crypto_ecc_p256_generate_key(btstack_crypto_ecc_p256_t * request, uint8_t * public_key, void (* callback)(void * arg), void * callback_arg){
 800e524:	b580      	push	{r7, lr}
 800e526:	b084      	sub	sp, #16
 800e528:	af00      	add	r7, sp, #0
 800e52a:	60f8      	str	r0, [r7, #12]
 800e52c:	60b9      	str	r1, [r7, #8]
 800e52e:	607a      	str	r2, [r7, #4]
 800e530:	603b      	str	r3, [r7, #0]
    // reset key generation
    if (btstack_crypto_ecc_p256_key_generation_state == ECC_P256_KEY_GENERATION_DONE){
 800e532:	4b10      	ldr	r3, [pc, #64]	; (800e574 <btstack_crypto_ecc_p256_generate_key+0x50>)
 800e534:	781b      	ldrb	r3, [r3, #0]
 800e536:	2b04      	cmp	r3, #4
 800e538:	d105      	bne.n	800e546 <btstack_crypto_ecc_p256_generate_key+0x22>
        btstack_crypto_ecc_p256_random_len = 0;
 800e53a:	4b0f      	ldr	r3, [pc, #60]	; (800e578 <btstack_crypto_ecc_p256_generate_key+0x54>)
 800e53c:	2200      	movs	r2, #0
 800e53e:	701a      	strb	r2, [r3, #0]
        btstack_crypto_ecc_p256_key_generation_state = ECC_P256_KEY_GENERATION_IDLE;
 800e540:	4b0c      	ldr	r3, [pc, #48]	; (800e574 <btstack_crypto_ecc_p256_generate_key+0x50>)
 800e542:	2200      	movs	r2, #0
 800e544:	701a      	strb	r2, [r3, #0]
    }
    request->btstack_crypto.context_callback.callback  = callback;
 800e546:	68fb      	ldr	r3, [r7, #12]
 800e548:	687a      	ldr	r2, [r7, #4]
 800e54a:	605a      	str	r2, [r3, #4]
    request->btstack_crypto.context_callback.context   = callback_arg;
 800e54c:	68fb      	ldr	r3, [r7, #12]
 800e54e:	683a      	ldr	r2, [r7, #0]
 800e550:	609a      	str	r2, [r3, #8]
    request->btstack_crypto.operation                  = BTSTACK_CRYPTO_ECC_P256_GENERATE_KEY;
 800e552:	68fb      	ldr	r3, [r7, #12]
 800e554:	2204      	movs	r2, #4
 800e556:	731a      	strb	r2, [r3, #12]
    request->public_key                                = public_key;
 800e558:	68fb      	ldr	r3, [r7, #12]
 800e55a:	68ba      	ldr	r2, [r7, #8]
 800e55c:	611a      	str	r2, [r3, #16]
    btstack_linked_list_add_tail(&btstack_crypto_operations, (btstack_linked_item_t*) request);
 800e55e:	68f9      	ldr	r1, [r7, #12]
 800e560:	4806      	ldr	r0, [pc, #24]	; (800e57c <btstack_crypto_ecc_p256_generate_key+0x58>)
 800e562:	f000 f889 	bl	800e678 <btstack_linked_list_add_tail>
    btstack_crypto_run();
 800e566:	f7ff fc93 	bl	800de90 <btstack_crypto_run>
}
 800e56a:	bf00      	nop
 800e56c:	3710      	adds	r7, #16
 800e56e:	46bd      	mov	sp, r7
 800e570:	bd80      	pop	{r7, pc}
 800e572:	bf00      	nop
 800e574:	2000624e 	.word	0x2000624e
 800e578:	2000624c 	.word	0x2000624c
 800e57c:	20006178 	.word	0x20006178

0800e580 <btstack_crypto_ecc_p256_calculate_dhkey>:

void btstack_crypto_ecc_p256_calculate_dhkey(btstack_crypto_ecc_p256_t * request, const uint8_t * public_key, uint8_t * dhkey, void (* callback)(void * arg), void * callback_arg){
 800e580:	b580      	push	{r7, lr}
 800e582:	b084      	sub	sp, #16
 800e584:	af00      	add	r7, sp, #0
 800e586:	60f8      	str	r0, [r7, #12]
 800e588:	60b9      	str	r1, [r7, #8]
 800e58a:	607a      	str	r2, [r7, #4]
 800e58c:	603b      	str	r3, [r7, #0]
    request->btstack_crypto.context_callback.callback  = callback;
 800e58e:	68fb      	ldr	r3, [r7, #12]
 800e590:	683a      	ldr	r2, [r7, #0]
 800e592:	605a      	str	r2, [r3, #4]
    request->btstack_crypto.context_callback.context   = callback_arg;
 800e594:	68fb      	ldr	r3, [r7, #12]
 800e596:	69ba      	ldr	r2, [r7, #24]
 800e598:	609a      	str	r2, [r3, #8]
    request->btstack_crypto.operation                  = BTSTACK_CRYPTO_ECC_P256_CALCULATE_DHKEY;
 800e59a:	68fb      	ldr	r3, [r7, #12]
 800e59c:	2205      	movs	r2, #5
 800e59e:	731a      	strb	r2, [r3, #12]
    request->public_key                                = (uint8_t *) public_key;
 800e5a0:	68fb      	ldr	r3, [r7, #12]
 800e5a2:	68ba      	ldr	r2, [r7, #8]
 800e5a4:	611a      	str	r2, [r3, #16]
    request->dhkey                                     = dhkey;
 800e5a6:	68fb      	ldr	r3, [r7, #12]
 800e5a8:	687a      	ldr	r2, [r7, #4]
 800e5aa:	615a      	str	r2, [r3, #20]
    btstack_linked_list_add_tail(&btstack_crypto_operations, (btstack_linked_item_t*) request);
 800e5ac:	68f9      	ldr	r1, [r7, #12]
 800e5ae:	4804      	ldr	r0, [pc, #16]	; (800e5c0 <btstack_crypto_ecc_p256_calculate_dhkey+0x40>)
 800e5b0:	f000 f862 	bl	800e678 <btstack_linked_list_add_tail>
    btstack_crypto_run();
 800e5b4:	f7ff fc6c 	bl	800de90 <btstack_crypto_run>
}
 800e5b8:	bf00      	nop
 800e5ba:	3710      	adds	r7, #16
 800e5bc:	46bd      	mov	sp, r7
 800e5be:	bd80      	pop	{r7, pc}
 800e5c0:	20006178 	.word	0x20006178

0800e5c4 <btstack_crypto_ecc_p256_validate_public_key>:

int btstack_crypto_ecc_p256_validate_public_key(const uint8_t * public_key){
 800e5c4:	b580      	push	{r7, lr}
 800e5c6:	b086      	sub	sp, #24
 800e5c8:	af02      	add	r7, sp, #8
 800e5ca:	6078      	str	r0, [r7, #4]

    // validate public key using micro-ecc
    int err = 0;
 800e5cc:	2300      	movs	r3, #0
 800e5ce:	60fb      	str	r3, [r7, #12]
#if uECC_SUPPORTS_secp256r1
    // standard version
    err = uECC_valid_public_key(public_key, uECC_secp256r1()) == 0;
#else
    // static version
    err = uECC_valid_public_key(public_key) == 0;
 800e5d0:	6878      	ldr	r0, [r7, #4]
 800e5d2:	f7fd fbd3 	bl	800bd7c <uECC_valid_public_key>
 800e5d6:	4603      	mov	r3, r0
 800e5d8:	2b00      	cmp	r3, #0
 800e5da:	bf0c      	ite	eq
 800e5dc:	2301      	moveq	r3, #1
 800e5de:	2300      	movne	r3, #0
 800e5e0:	b2db      	uxtb	r3, r3
 800e5e2:	60fb      	str	r3, [r7, #12]
    mbedtls_mpi_lset(&Q.Z, 1);
    err = mbedtls_ecp_check_pubkey(&mbedtls_ec_group, &Q);
    mbedtls_ecp_point_free( & Q);
#endif

    if (err != 0){
 800e5e4:	68fb      	ldr	r3, [r7, #12]
 800e5e6:	2b00      	cmp	r3, #0
 800e5e8:	d008      	beq.n	800e5fc <btstack_crypto_ecc_p256_validate_public_key+0x38>
        log_error("public key invalid %x", err);
 800e5ea:	68fb      	ldr	r3, [r7, #12]
 800e5ec:	9300      	str	r3, [sp, #0]
 800e5ee:	f240 5306 	movw	r3, #1286	; 0x506
 800e5f2:	4a05      	ldr	r2, [pc, #20]	; (800e608 <btstack_crypto_ecc_p256_validate_public_key+0x44>)
 800e5f4:	4905      	ldr	r1, [pc, #20]	; (800e60c <btstack_crypto_ecc_p256_validate_public_key+0x48>)
 800e5f6:	2002      	movs	r0, #2
 800e5f8:	f008 ff22 	bl	8017440 <hci_dump_log>
    }
    return  err;
 800e5fc:	68fb      	ldr	r3, [r7, #12]
}
 800e5fe:	4618      	mov	r0, r3
 800e600:	3710      	adds	r7, #16
 800e602:	46bd      	mov	sp, r7
 800e604:	bd80      	pop	{r7, pc}
 800e606:	bf00      	nop
 800e608:	08028fb8 	.word	0x08028fb8
 800e60c:	080291e0 	.word	0x080291e0

0800e610 <btstack_linked_list_empty>:
#include "btstack_debug.h"

/**
 * tests if list is empty
 */
bool  btstack_linked_list_empty(btstack_linked_list_t * list){
 800e610:	b480      	push	{r7}
 800e612:	b083      	sub	sp, #12
 800e614:	af00      	add	r7, sp, #0
 800e616:	6078      	str	r0, [r7, #4]
    return *list == (void *) 0;
 800e618:	687b      	ldr	r3, [r7, #4]
 800e61a:	681b      	ldr	r3, [r3, #0]
 800e61c:	2b00      	cmp	r3, #0
 800e61e:	bf0c      	ite	eq
 800e620:	2301      	moveq	r3, #1
 800e622:	2300      	movne	r3, #0
 800e624:	b2db      	uxtb	r3, r3
}
 800e626:	4618      	mov	r0, r3
 800e628:	370c      	adds	r7, #12
 800e62a:	46bd      	mov	sp, r7
 800e62c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e630:	4770      	bx	lr

0800e632 <btstack_linked_list_add>:


/**
 * btstack_linked_list_add
 */
bool btstack_linked_list_add(btstack_linked_list_t * list, btstack_linked_item_t *item){        // <-- add item to list
 800e632:	b480      	push	{r7}
 800e634:	b085      	sub	sp, #20
 800e636:	af00      	add	r7, sp, #0
 800e638:	6078      	str	r0, [r7, #4]
 800e63a:	6039      	str	r1, [r7, #0]
    // check if already in list
    btstack_linked_item_t *it;
    for (it = *list; it != NULL; it = it->next){
 800e63c:	687b      	ldr	r3, [r7, #4]
 800e63e:	681b      	ldr	r3, [r3, #0]
 800e640:	60fb      	str	r3, [r7, #12]
 800e642:	e008      	b.n	800e656 <btstack_linked_list_add+0x24>
        if (it == item) {
 800e644:	68fa      	ldr	r2, [r7, #12]
 800e646:	683b      	ldr	r3, [r7, #0]
 800e648:	429a      	cmp	r2, r3
 800e64a:	d101      	bne.n	800e650 <btstack_linked_list_add+0x1e>
            return false;
 800e64c:	2300      	movs	r3, #0
 800e64e:	e00d      	b.n	800e66c <btstack_linked_list_add+0x3a>
    for (it = *list; it != NULL; it = it->next){
 800e650:	68fb      	ldr	r3, [r7, #12]
 800e652:	681b      	ldr	r3, [r3, #0]
 800e654:	60fb      	str	r3, [r7, #12]
 800e656:	68fb      	ldr	r3, [r7, #12]
 800e658:	2b00      	cmp	r3, #0
 800e65a:	d1f3      	bne.n	800e644 <btstack_linked_list_add+0x12>
        }
    }
    // add first
    item->next = *list;
 800e65c:	687b      	ldr	r3, [r7, #4]
 800e65e:	681a      	ldr	r2, [r3, #0]
 800e660:	683b      	ldr	r3, [r7, #0]
 800e662:	601a      	str	r2, [r3, #0]
    *list = item;
 800e664:	687b      	ldr	r3, [r7, #4]
 800e666:	683a      	ldr	r2, [r7, #0]
 800e668:	601a      	str	r2, [r3, #0]
    return true;
 800e66a:	2301      	movs	r3, #1
}
 800e66c:	4618      	mov	r0, r3
 800e66e:	3714      	adds	r7, #20
 800e670:	46bd      	mov	sp, r7
 800e672:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e676:	4770      	bx	lr

0800e678 <btstack_linked_list_add_tail>:

bool btstack_linked_list_add_tail(btstack_linked_list_t * list, btstack_linked_item_t *item){   // <-- add item to list as last element
 800e678:	b480      	push	{r7}
 800e67a:	b085      	sub	sp, #20
 800e67c:	af00      	add	r7, sp, #0
 800e67e:	6078      	str	r0, [r7, #4]
 800e680:	6039      	str	r1, [r7, #0]
    // check if already in list
    btstack_linked_item_t *it;
    for (it = (btstack_linked_item_t *) list; it->next != NULL ; it = it->next){
 800e682:	687b      	ldr	r3, [r7, #4]
 800e684:	60fb      	str	r3, [r7, #12]
 800e686:	e009      	b.n	800e69c <btstack_linked_list_add_tail+0x24>
        if (it->next == item) {
 800e688:	68fb      	ldr	r3, [r7, #12]
 800e68a:	681b      	ldr	r3, [r3, #0]
 800e68c:	683a      	ldr	r2, [r7, #0]
 800e68e:	429a      	cmp	r2, r3
 800e690:	d101      	bne.n	800e696 <btstack_linked_list_add_tail+0x1e>
            return false;
 800e692:	2300      	movs	r3, #0
 800e694:	e00d      	b.n	800e6b2 <btstack_linked_list_add_tail+0x3a>
    for (it = (btstack_linked_item_t *) list; it->next != NULL ; it = it->next){
 800e696:	68fb      	ldr	r3, [r7, #12]
 800e698:	681b      	ldr	r3, [r3, #0]
 800e69a:	60fb      	str	r3, [r7, #12]
 800e69c:	68fb      	ldr	r3, [r7, #12]
 800e69e:	681b      	ldr	r3, [r3, #0]
 800e6a0:	2b00      	cmp	r3, #0
 800e6a2:	d1f1      	bne.n	800e688 <btstack_linked_list_add_tail+0x10>
        }
    }
    item->next = (btstack_linked_item_t*) 0;
 800e6a4:	683b      	ldr	r3, [r7, #0]
 800e6a6:	2200      	movs	r2, #0
 800e6a8:	601a      	str	r2, [r3, #0]
    it->next = item;
 800e6aa:	68fb      	ldr	r3, [r7, #12]
 800e6ac:	683a      	ldr	r2, [r7, #0]
 800e6ae:	601a      	str	r2, [r3, #0]
    return true;
 800e6b0:	2301      	movs	r3, #1
}
 800e6b2:	4618      	mov	r0, r3
 800e6b4:	3714      	adds	r7, #20
 800e6b6:	46bd      	mov	sp, r7
 800e6b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e6bc:	4770      	bx	lr

0800e6be <btstack_linked_list_remove>:

bool  btstack_linked_list_remove(btstack_linked_list_t * list, btstack_linked_item_t *item){    // <-- remove item from list
 800e6be:	b480      	push	{r7}
 800e6c0:	b085      	sub	sp, #20
 800e6c2:	af00      	add	r7, sp, #0
 800e6c4:	6078      	str	r0, [r7, #4]
 800e6c6:	6039      	str	r1, [r7, #0]
    if (!item) return false;
 800e6c8:	683b      	ldr	r3, [r7, #0]
 800e6ca:	2b00      	cmp	r3, #0
 800e6cc:	d101      	bne.n	800e6d2 <btstack_linked_list_remove+0x14>
 800e6ce:	2300      	movs	r3, #0
 800e6d0:	e014      	b.n	800e6fc <btstack_linked_list_remove+0x3e>
    btstack_linked_item_t *it;
    for (it = (btstack_linked_item_t *) list; it != NULL; it = it->next){
 800e6d2:	687b      	ldr	r3, [r7, #4]
 800e6d4:	60fb      	str	r3, [r7, #12]
 800e6d6:	e00d      	b.n	800e6f4 <btstack_linked_list_remove+0x36>
        if (it->next == item){
 800e6d8:	68fb      	ldr	r3, [r7, #12]
 800e6da:	681b      	ldr	r3, [r3, #0]
 800e6dc:	683a      	ldr	r2, [r7, #0]
 800e6de:	429a      	cmp	r2, r3
 800e6e0:	d105      	bne.n	800e6ee <btstack_linked_list_remove+0x30>
            it->next =  item->next;
 800e6e2:	683b      	ldr	r3, [r7, #0]
 800e6e4:	681a      	ldr	r2, [r3, #0]
 800e6e6:	68fb      	ldr	r3, [r7, #12]
 800e6e8:	601a      	str	r2, [r3, #0]
            return true;
 800e6ea:	2301      	movs	r3, #1
 800e6ec:	e006      	b.n	800e6fc <btstack_linked_list_remove+0x3e>
    for (it = (btstack_linked_item_t *) list; it != NULL; it = it->next){
 800e6ee:	68fb      	ldr	r3, [r7, #12]
 800e6f0:	681b      	ldr	r3, [r3, #0]
 800e6f2:	60fb      	str	r3, [r7, #12]
 800e6f4:	68fb      	ldr	r3, [r7, #12]
 800e6f6:	2b00      	cmp	r3, #0
 800e6f8:	d1ee      	bne.n	800e6d8 <btstack_linked_list_remove+0x1a>
        }
    }
    return false;
 800e6fa:	2300      	movs	r3, #0
}
 800e6fc:	4618      	mov	r0, r3
 800e6fe:	3714      	adds	r7, #20
 800e700:	46bd      	mov	sp, r7
 800e702:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e706:	4770      	bx	lr

0800e708 <btstack_linked_list_get_first_item>:
    }
    return counter; 
}

// get first element
btstack_linked_item_t * btstack_linked_list_get_first_item(btstack_linked_list_t * list){
 800e708:	b480      	push	{r7}
 800e70a:	b083      	sub	sp, #12
 800e70c:	af00      	add	r7, sp, #0
 800e70e:	6078      	str	r0, [r7, #4]
    return * list;
 800e710:	687b      	ldr	r3, [r7, #4]
 800e712:	681b      	ldr	r3, [r3, #0]
}
 800e714:	4618      	mov	r0, r3
 800e716:	370c      	adds	r7, #12
 800e718:	46bd      	mov	sp, r7
 800e71a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e71e:	4770      	bx	lr

0800e720 <btstack_linked_list_pop>:

// pop (get + remove) first element
btstack_linked_item_t * btstack_linked_list_pop(btstack_linked_list_t * list){
 800e720:	b480      	push	{r7}
 800e722:	b085      	sub	sp, #20
 800e724:	af00      	add	r7, sp, #0
 800e726:	6078      	str	r0, [r7, #4]
    btstack_linked_item_t * item = *list;
 800e728:	687b      	ldr	r3, [r7, #4]
 800e72a:	681b      	ldr	r3, [r3, #0]
 800e72c:	60fb      	str	r3, [r7, #12]
    if (!item) return NULL;
 800e72e:	68fb      	ldr	r3, [r7, #12]
 800e730:	2b00      	cmp	r3, #0
 800e732:	d101      	bne.n	800e738 <btstack_linked_list_pop+0x18>
 800e734:	2300      	movs	r3, #0
 800e736:	e004      	b.n	800e742 <btstack_linked_list_pop+0x22>
    *list = item->next;
 800e738:	68fb      	ldr	r3, [r7, #12]
 800e73a:	681a      	ldr	r2, [r3, #0]
 800e73c:	687b      	ldr	r3, [r7, #4]
 800e73e:	601a      	str	r2, [r3, #0]
    return item;
 800e740:	68fb      	ldr	r3, [r7, #12]
}
 800e742:	4618      	mov	r0, r3
 800e744:	3714      	adds	r7, #20
 800e746:	46bd      	mov	sp, r7
 800e748:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e74c:	4770      	bx	lr

0800e74e <btstack_linked_list_iterator_init>:

//
// Linked List Iterator implementation
//

void btstack_linked_list_iterator_init(btstack_linked_list_iterator_t * it, btstack_linked_list_t * head){
 800e74e:	b480      	push	{r7}
 800e750:	b083      	sub	sp, #12
 800e752:	af00      	add	r7, sp, #0
 800e754:	6078      	str	r0, [r7, #4]
 800e756:	6039      	str	r1, [r7, #0]
    it->advance_on_next = 0;
 800e758:	687b      	ldr	r3, [r7, #4]
 800e75a:	2200      	movs	r2, #0
 800e75c:	601a      	str	r2, [r3, #0]
    it->prev = (btstack_linked_item_t*) head;
 800e75e:	687b      	ldr	r3, [r7, #4]
 800e760:	683a      	ldr	r2, [r7, #0]
 800e762:	605a      	str	r2, [r3, #4]
    it->curr = * head;
 800e764:	683b      	ldr	r3, [r7, #0]
 800e766:	681a      	ldr	r2, [r3, #0]
 800e768:	687b      	ldr	r3, [r7, #4]
 800e76a:	609a      	str	r2, [r3, #8]
}
 800e76c:	bf00      	nop
 800e76e:	370c      	adds	r7, #12
 800e770:	46bd      	mov	sp, r7
 800e772:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e776:	4770      	bx	lr

0800e778 <btstack_linked_list_iterator_has_next>:

bool btstack_linked_list_iterator_has_next(btstack_linked_list_iterator_t * it){
 800e778:	b480      	push	{r7}
 800e77a:	b083      	sub	sp, #12
 800e77c:	af00      	add	r7, sp, #0
 800e77e:	6078      	str	r0, [r7, #4]
    // log_info("btstack_linked_list_iterator_has_next: advance on next %u, it->prev %p, it->curr %p", it->advance_on_next, it->prev, it->curr);
    if (!it->advance_on_next){
 800e780:	687b      	ldr	r3, [r7, #4]
 800e782:	681b      	ldr	r3, [r3, #0]
 800e784:	2b00      	cmp	r3, #0
 800e786:	d107      	bne.n	800e798 <btstack_linked_list_iterator_has_next+0x20>
        return it->curr != NULL;
 800e788:	687b      	ldr	r3, [r7, #4]
 800e78a:	689b      	ldr	r3, [r3, #8]
 800e78c:	2b00      	cmp	r3, #0
 800e78e:	bf14      	ite	ne
 800e790:	2301      	movne	r3, #1
 800e792:	2300      	moveq	r3, #0
 800e794:	b2db      	uxtb	r3, r3
 800e796:	e017      	b.n	800e7c8 <btstack_linked_list_iterator_has_next+0x50>
    }
    if (it->prev->next != it->curr){
 800e798:	687b      	ldr	r3, [r7, #4]
 800e79a:	685b      	ldr	r3, [r3, #4]
 800e79c:	681a      	ldr	r2, [r3, #0]
 800e79e:	687b      	ldr	r3, [r7, #4]
 800e7a0:	689b      	ldr	r3, [r3, #8]
 800e7a2:	429a      	cmp	r2, r3
 800e7a4:	d008      	beq.n	800e7b8 <btstack_linked_list_iterator_has_next+0x40>
        // current item has been removed
        return it->prev->next != NULL;
 800e7a6:	687b      	ldr	r3, [r7, #4]
 800e7a8:	685b      	ldr	r3, [r3, #4]
 800e7aa:	681b      	ldr	r3, [r3, #0]
 800e7ac:	2b00      	cmp	r3, #0
 800e7ae:	bf14      	ite	ne
 800e7b0:	2301      	movne	r3, #1
 800e7b2:	2300      	moveq	r3, #0
 800e7b4:	b2db      	uxtb	r3, r3
 800e7b6:	e007      	b.n	800e7c8 <btstack_linked_list_iterator_has_next+0x50>
    }
    // current items has not been removed
    return it->curr->next != NULL;
 800e7b8:	687b      	ldr	r3, [r7, #4]
 800e7ba:	689b      	ldr	r3, [r3, #8]
 800e7bc:	681b      	ldr	r3, [r3, #0]
 800e7be:	2b00      	cmp	r3, #0
 800e7c0:	bf14      	ite	ne
 800e7c2:	2301      	movne	r3, #1
 800e7c4:	2300      	moveq	r3, #0
 800e7c6:	b2db      	uxtb	r3, r3
}
 800e7c8:	4618      	mov	r0, r3
 800e7ca:	370c      	adds	r7, #12
 800e7cc:	46bd      	mov	sp, r7
 800e7ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e7d2:	4770      	bx	lr

0800e7d4 <btstack_linked_list_iterator_next>:

btstack_linked_item_t * btstack_linked_list_iterator_next(btstack_linked_list_iterator_t * it){
 800e7d4:	b480      	push	{r7}
 800e7d6:	b083      	sub	sp, #12
 800e7d8:	af00      	add	r7, sp, #0
 800e7da:	6078      	str	r0, [r7, #4]
    if (it->advance_on_next){
 800e7dc:	687b      	ldr	r3, [r7, #4]
 800e7de:	681b      	ldr	r3, [r3, #0]
 800e7e0:	2b00      	cmp	r3, #0
 800e7e2:	d016      	beq.n	800e812 <btstack_linked_list_iterator_next+0x3e>
        if (it->prev->next == it->curr){
 800e7e4:	687b      	ldr	r3, [r7, #4]
 800e7e6:	685b      	ldr	r3, [r3, #4]
 800e7e8:	681a      	ldr	r2, [r3, #0]
 800e7ea:	687b      	ldr	r3, [r7, #4]
 800e7ec:	689b      	ldr	r3, [r3, #8]
 800e7ee:	429a      	cmp	r2, r3
 800e7f0:	d109      	bne.n	800e806 <btstack_linked_list_iterator_next+0x32>
            it->prev = it->curr;
 800e7f2:	687b      	ldr	r3, [r7, #4]
 800e7f4:	689a      	ldr	r2, [r3, #8]
 800e7f6:	687b      	ldr	r3, [r7, #4]
 800e7f8:	605a      	str	r2, [r3, #4]
            it->curr = it->curr->next;
 800e7fa:	687b      	ldr	r3, [r7, #4]
 800e7fc:	689b      	ldr	r3, [r3, #8]
 800e7fe:	681a      	ldr	r2, [r3, #0]
 800e800:	687b      	ldr	r3, [r7, #4]
 800e802:	609a      	str	r2, [r3, #8]
 800e804:	e008      	b.n	800e818 <btstack_linked_list_iterator_next+0x44>
        } else {
            // curr was removed from the list, set it again but don't advance prev
            it->curr = it->prev->next;
 800e806:	687b      	ldr	r3, [r7, #4]
 800e808:	685b      	ldr	r3, [r3, #4]
 800e80a:	681a      	ldr	r2, [r3, #0]
 800e80c:	687b      	ldr	r3, [r7, #4]
 800e80e:	609a      	str	r2, [r3, #8]
 800e810:	e002      	b.n	800e818 <btstack_linked_list_iterator_next+0x44>
        }
    } else {
        it->advance_on_next = 1;
 800e812:	687b      	ldr	r3, [r7, #4]
 800e814:	2201      	movs	r2, #1
 800e816:	601a      	str	r2, [r3, #0]
    }
    return it->curr;
 800e818:	687b      	ldr	r3, [r7, #4]
 800e81a:	689b      	ldr	r3, [r3, #8]
}
 800e81c:	4618      	mov	r0, r3
 800e81e:	370c      	adds	r7, #12
 800e820:	46bd      	mov	sp, r7
 800e822:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e826:	4770      	bx	lr

0800e828 <btstack_linked_list_iterator_remove>:

void btstack_linked_list_iterator_remove(btstack_linked_list_iterator_t * it){
 800e828:	b480      	push	{r7}
 800e82a:	b083      	sub	sp, #12
 800e82c:	af00      	add	r7, sp, #0
 800e82e:	6078      	str	r0, [r7, #4]
    btstack_assert(it->prev->next == it->curr);
    it->curr = it->curr->next;
 800e830:	687b      	ldr	r3, [r7, #4]
 800e832:	689b      	ldr	r3, [r3, #8]
 800e834:	681a      	ldr	r2, [r3, #0]
 800e836:	687b      	ldr	r3, [r7, #4]
 800e838:	609a      	str	r2, [r3, #8]
    it->prev->next = it->curr;
 800e83a:	687b      	ldr	r3, [r7, #4]
 800e83c:	685b      	ldr	r3, [r3, #4]
 800e83e:	687a      	ldr	r2, [r7, #4]
 800e840:	6892      	ldr	r2, [r2, #8]
 800e842:	601a      	str	r2, [r3, #0]
    it->advance_on_next = 0;
 800e844:	687b      	ldr	r3, [r7, #4]
 800e846:	2200      	movs	r2, #0
 800e848:	601a      	str	r2, [r3, #0]
}
 800e84a:	bf00      	nop
 800e84c:	370c      	adds	r7, #12
 800e84e:	46bd      	mov	sp, r7
 800e850:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e854:	4770      	bx	lr
	...

0800e858 <btstack_memory_hci_connection_get>:

#ifdef MAX_NR_HCI_CONNECTIONS
#if MAX_NR_HCI_CONNECTIONS > 0
static hci_connection_t hci_connection_storage[MAX_NR_HCI_CONNECTIONS];
static btstack_memory_pool_t hci_connection_pool;
hci_connection_t * btstack_memory_hci_connection_get(void){
 800e858:	b580      	push	{r7, lr}
 800e85a:	b082      	sub	sp, #8
 800e85c:	af00      	add	r7, sp, #0
    void * buffer = btstack_memory_pool_get(&hci_connection_pool);
 800e85e:	4809      	ldr	r0, [pc, #36]	; (800e884 <btstack_memory_hci_connection_get+0x2c>)
 800e860:	f000 f95a 	bl	800eb18 <btstack_memory_pool_get>
 800e864:	6078      	str	r0, [r7, #4]
    if (buffer){
 800e866:	687b      	ldr	r3, [r7, #4]
 800e868:	2b00      	cmp	r3, #0
 800e86a:	d005      	beq.n	800e878 <btstack_memory_hci_connection_get+0x20>
        memset(buffer, 0, sizeof(hci_connection_t));
 800e86c:	f640 6228 	movw	r2, #3624	; 0xe28
 800e870:	2100      	movs	r1, #0
 800e872:	6878      	ldr	r0, [r7, #4]
 800e874:	f019 f925 	bl	8027ac2 <memset>
    }
    return (hci_connection_t *) buffer;
 800e878:	687b      	ldr	r3, [r7, #4]
}
 800e87a:	4618      	mov	r0, r3
 800e87c:	3708      	adds	r7, #8
 800e87e:	46bd      	mov	sp, r7
 800e880:	bd80      	pop	{r7, pc}
 800e882:	bf00      	nop
 800e884:	20007ec0 	.word	0x20007ec0

0800e888 <btstack_memory_hci_connection_free>:
void btstack_memory_hci_connection_free(hci_connection_t *hci_connection){
 800e888:	b580      	push	{r7, lr}
 800e88a:	b082      	sub	sp, #8
 800e88c:	af00      	add	r7, sp, #0
 800e88e:	6078      	str	r0, [r7, #4]
    btstack_memory_pool_free(&hci_connection_pool, hci_connection);
 800e890:	6879      	ldr	r1, [r7, #4]
 800e892:	4803      	ldr	r0, [pc, #12]	; (800e8a0 <btstack_memory_hci_connection_free+0x18>)
 800e894:	f000 f95a 	bl	800eb4c <btstack_memory_pool_free>
}
 800e898:	bf00      	nop
 800e89a:	3708      	adds	r7, #8
 800e89c:	46bd      	mov	sp, r7
 800e89e:	bd80      	pop	{r7, pc}
 800e8a0:	20007ec0 	.word	0x20007ec0

0800e8a4 <btstack_memory_l2cap_channel_get>:

#ifdef MAX_NR_L2CAP_CHANNELS
#if MAX_NR_L2CAP_CHANNELS > 0
static l2cap_channel_t l2cap_channel_storage[MAX_NR_L2CAP_CHANNELS];
static btstack_memory_pool_t l2cap_channel_pool;
l2cap_channel_t * btstack_memory_l2cap_channel_get(void){
 800e8a4:	b580      	push	{r7, lr}
 800e8a6:	b082      	sub	sp, #8
 800e8a8:	af00      	add	r7, sp, #0
    void * buffer = btstack_memory_pool_get(&l2cap_channel_pool);
 800e8aa:	4808      	ldr	r0, [pc, #32]	; (800e8cc <btstack_memory_l2cap_channel_get+0x28>)
 800e8ac:	f000 f934 	bl	800eb18 <btstack_memory_pool_get>
 800e8b0:	6078      	str	r0, [r7, #4]
    if (buffer){
 800e8b2:	687b      	ldr	r3, [r7, #4]
 800e8b4:	2b00      	cmp	r3, #0
 800e8b6:	d004      	beq.n	800e8c2 <btstack_memory_l2cap_channel_get+0x1e>
        memset(buffer, 0, sizeof(l2cap_channel_t));
 800e8b8:	22b4      	movs	r2, #180	; 0xb4
 800e8ba:	2100      	movs	r1, #0
 800e8bc:	6878      	ldr	r0, [r7, #4]
 800e8be:	f019 f900 	bl	8027ac2 <memset>
    }
    return (l2cap_channel_t *) buffer;
 800e8c2:	687b      	ldr	r3, [r7, #4]
}
 800e8c4:	4618      	mov	r0, r3
 800e8c6:	3708      	adds	r7, #8
 800e8c8:	46bd      	mov	sp, r7
 800e8ca:	bd80      	pop	{r7, pc}
 800e8cc:	200081c8 	.word	0x200081c8

0800e8d0 <btstack_memory_l2cap_channel_free>:
void btstack_memory_l2cap_channel_free(l2cap_channel_t *l2cap_channel){
 800e8d0:	b580      	push	{r7, lr}
 800e8d2:	b082      	sub	sp, #8
 800e8d4:	af00      	add	r7, sp, #0
 800e8d6:	6078      	str	r0, [r7, #4]
    btstack_memory_pool_free(&l2cap_channel_pool, l2cap_channel);
 800e8d8:	6879      	ldr	r1, [r7, #4]
 800e8da:	4803      	ldr	r0, [pc, #12]	; (800e8e8 <btstack_memory_l2cap_channel_free+0x18>)
 800e8dc:	f000 f936 	bl	800eb4c <btstack_memory_pool_free>
}
 800e8e0:	bf00      	nop
 800e8e2:	3708      	adds	r7, #8
 800e8e4:	46bd      	mov	sp, r7
 800e8e6:	bd80      	pop	{r7, pc}
 800e8e8:	200081c8 	.word	0x200081c8

0800e8ec <btstack_memory_whitelist_entry_free>:
    if (buffer){
        memset(buffer, 0, sizeof(whitelist_entry_t));
    }
    return (whitelist_entry_t *) buffer;
}
void btstack_memory_whitelist_entry_free(whitelist_entry_t *whitelist_entry){
 800e8ec:	b580      	push	{r7, lr}
 800e8ee:	b082      	sub	sp, #8
 800e8f0:	af00      	add	r7, sp, #0
 800e8f2:	6078      	str	r0, [r7, #4]
    btstack_memory_pool_free(&whitelist_entry_pool, whitelist_entry);
 800e8f4:	6879      	ldr	r1, [r7, #4]
 800e8f6:	4803      	ldr	r0, [pc, #12]	; (800e904 <btstack_memory_whitelist_entry_free+0x18>)
 800e8f8:	f000 f928 	bl	800eb4c <btstack_memory_pool_free>
}
 800e8fc:	bf00      	nop
 800e8fe:	3708      	adds	r7, #8
 800e900:	46bd      	mov	sp, r7
 800e902:	bd80      	pop	{r7, pc}
 800e904:	20008b60 	.word	0x20008b60

0800e908 <btstack_memory_sm_lookup_entry_free>:
    if (buffer){
        memset(buffer, 0, sizeof(sm_lookup_entry_t));
    }
    return (sm_lookup_entry_t *) buffer;
}
void btstack_memory_sm_lookup_entry_free(sm_lookup_entry_t *sm_lookup_entry){
 800e908:	b580      	push	{r7, lr}
 800e90a:	b082      	sub	sp, #8
 800e90c:	af00      	add	r7, sp, #0
 800e90e:	6078      	str	r0, [r7, #4]
    btstack_memory_pool_free(&sm_lookup_entry_pool, sm_lookup_entry);
 800e910:	6879      	ldr	r1, [r7, #4]
 800e912:	4803      	ldr	r0, [pc, #12]	; (800e920 <btstack_memory_sm_lookup_entry_free+0x18>)
 800e914:	f000 f91a 	bl	800eb4c <btstack_memory_pool_free>
}
 800e918:	bf00      	nop
 800e91a:	3708      	adds	r7, #8
 800e91c:	46bd      	mov	sp, r7
 800e91e:	bd80      	pop	{r7, pc}
 800e920:	20008b88 	.word	0x20008b88

0800e924 <btstack_memory_init>:


#endif

// init
void btstack_memory_init(void){
 800e924:	b580      	push	{r7, lr}
 800e926:	af00      	add	r7, sp, #0


	HAL_Delay( 1000 );
 800e928:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800e92c:	f7f3 fbb2 	bl	8002094 <HAL_Delay>
    // assert that there is no unexpected padding for combined buffer
    btstack_assert(sizeof(test_buffer_t) == sizeof(btstack_memory_buffer_t) + sizeof(void *));
#endif
  
#if MAX_NR_HCI_CONNECTIONS > 0
    btstack_memory_pool_create(&hci_connection_pool, hci_connection_storage, MAX_NR_HCI_CONNECTIONS, sizeof(hci_connection_t));
 800e930:	f640 6328 	movw	r3, #3624	; 0xe28
 800e934:	2202      	movs	r2, #2
 800e936:	493e      	ldr	r1, [pc, #248]	; (800ea30 <btstack_memory_init+0x10c>)
 800e938:	483e      	ldr	r0, [pc, #248]	; (800ea34 <btstack_memory_init+0x110>)
 800e93a:	f000 f8c9 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_L2CAP_SERVICES > 0
    btstack_memory_pool_create(&l2cap_service_pool, l2cap_service_storage, MAX_NR_L2CAP_SERVICES, sizeof(l2cap_service_t));
 800e93e:	2310      	movs	r3, #16
 800e940:	2203      	movs	r2, #3
 800e942:	493d      	ldr	r1, [pc, #244]	; (800ea38 <btstack_memory_init+0x114>)
 800e944:	483d      	ldr	r0, [pc, #244]	; (800ea3c <btstack_memory_init+0x118>)
 800e946:	f000 f8c3 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_L2CAP_CHANNELS > 0
    btstack_memory_pool_create(&l2cap_channel_pool, l2cap_channel_storage, MAX_NR_L2CAP_CHANNELS, sizeof(l2cap_channel_t));
 800e94a:	23b4      	movs	r3, #180	; 0xb4
 800e94c:	2204      	movs	r2, #4
 800e94e:	493c      	ldr	r1, [pc, #240]	; (800ea40 <btstack_memory_init+0x11c>)
 800e950:	483c      	ldr	r0, [pc, #240]	; (800ea44 <btstack_memory_init+0x120>)
 800e952:	f000 f8bd 	bl	800ead0 <btstack_memory_pool_create>
#endif
#ifdef ENABLE_CLASSIC
#if MAX_NR_RFCOMM_MULTIPLEXERS > 0
    btstack_memory_pool_create(&rfcomm_multiplexer_pool, rfcomm_multiplexer_storage, MAX_NR_RFCOMM_MULTIPLEXERS, sizeof(rfcomm_multiplexer_t));
 800e956:	2334      	movs	r3, #52	; 0x34
 800e958:	2201      	movs	r2, #1
 800e95a:	493b      	ldr	r1, [pc, #236]	; (800ea48 <btstack_memory_init+0x124>)
 800e95c:	483b      	ldr	r0, [pc, #236]	; (800ea4c <btstack_memory_init+0x128>)
 800e95e:	f000 f8b7 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_RFCOMM_SERVICES > 0
    btstack_memory_pool_create(&rfcomm_service_pool, rfcomm_service_storage, MAX_NR_RFCOMM_SERVICES, sizeof(rfcomm_service_t));
 800e962:	2310      	movs	r3, #16
 800e964:	2201      	movs	r2, #1
 800e966:	493a      	ldr	r1, [pc, #232]	; (800ea50 <btstack_memory_init+0x12c>)
 800e968:	483a      	ldr	r0, [pc, #232]	; (800ea54 <btstack_memory_init+0x130>)
 800e96a:	f000 f8b1 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_RFCOMM_CHANNELS > 0
    btstack_memory_pool_create(&rfcomm_channel_pool, rfcomm_channel_storage, MAX_NR_RFCOMM_CHANNELS, sizeof(rfcomm_channel_t));
 800e96e:	2328      	movs	r3, #40	; 0x28
 800e970:	2201      	movs	r2, #1
 800e972:	4939      	ldr	r1, [pc, #228]	; (800ea58 <btstack_memory_init+0x134>)
 800e974:	4839      	ldr	r0, [pc, #228]	; (800ea5c <btstack_memory_init+0x138>)
 800e976:	f000 f8ab 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_BTSTACK_LINK_KEY_DB_MEMORY_ENTRIES > 0
    btstack_memory_pool_create(&btstack_link_key_db_memory_entry_pool, btstack_link_key_db_memory_entry_storage, MAX_NR_BTSTACK_LINK_KEY_DB_MEMORY_ENTRIES, sizeof(btstack_link_key_db_memory_entry_t));
 800e97a:	231c      	movs	r3, #28
 800e97c:	2202      	movs	r2, #2
 800e97e:	4938      	ldr	r1, [pc, #224]	; (800ea60 <btstack_memory_init+0x13c>)
 800e980:	4838      	ldr	r0, [pc, #224]	; (800ea64 <btstack_memory_init+0x140>)
 800e982:	f000 f8a5 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_BNEP_SERVICES > 0
    btstack_memory_pool_create(&bnep_service_pool, bnep_service_storage, MAX_NR_BNEP_SERVICES, sizeof(bnep_service_t));
 800e986:	230c      	movs	r3, #12
 800e988:	2201      	movs	r2, #1
 800e98a:	4937      	ldr	r1, [pc, #220]	; (800ea68 <btstack_memory_init+0x144>)
 800e98c:	4837      	ldr	r0, [pc, #220]	; (800ea6c <btstack_memory_init+0x148>)
 800e98e:	f000 f89f 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_BNEP_CHANNELS > 0
    btstack_memory_pool_create(&bnep_channel_pool, bnep_channel_storage, MAX_NR_BNEP_CHANNELS, sizeof(bnep_channel_t));
 800e992:	23d8      	movs	r3, #216	; 0xd8
 800e994:	2201      	movs	r2, #1
 800e996:	4936      	ldr	r1, [pc, #216]	; (800ea70 <btstack_memory_init+0x14c>)
 800e998:	4836      	ldr	r0, [pc, #216]	; (800ea74 <btstack_memory_init+0x150>)
 800e99a:	f000 f899 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_HFP_CONNECTIONS > 0
    btstack_memory_pool_create(&hfp_connection_pool, hfp_connection_storage, MAX_NR_HFP_CONNECTIONS, sizeof(hfp_connection_t));
 800e99e:	f44f 731c 	mov.w	r3, #624	; 0x270
 800e9a2:	2201      	movs	r2, #1
 800e9a4:	4934      	ldr	r1, [pc, #208]	; (800ea78 <btstack_memory_init+0x154>)
 800e9a6:	4835      	ldr	r0, [pc, #212]	; (800ea7c <btstack_memory_init+0x158>)
 800e9a8:	f000 f892 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_HID_HOST_CONNECTIONS > 0
    btstack_memory_pool_create(&hid_host_connection_pool, hid_host_connection_storage, MAX_NR_HID_HOST_CONNECTIONS, sizeof(hid_host_connection_t));
#endif
#if MAX_NR_SERVICE_RECORD_ITEMS > 0
    btstack_memory_pool_create(&service_record_item_pool, service_record_item_storage, MAX_NR_SERVICE_RECORD_ITEMS, sizeof(service_record_item_t));
 800e9ac:	230c      	movs	r3, #12
 800e9ae:	2204      	movs	r2, #4
 800e9b0:	4933      	ldr	r1, [pc, #204]	; (800ea80 <btstack_memory_init+0x15c>)
 800e9b2:	4834      	ldr	r0, [pc, #208]	; (800ea84 <btstack_memory_init+0x160>)
 800e9b4:	f000 f88c 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_AVDTP_STREAM_ENDPOINTS > 0
    btstack_memory_pool_create(&avdtp_stream_endpoint_pool, avdtp_stream_endpoint_storage, MAX_NR_AVDTP_STREAM_ENDPOINTS, sizeof(avdtp_stream_endpoint_t));
 800e9b8:	f44f 73a2 	mov.w	r3, #324	; 0x144
 800e9bc:	2201      	movs	r2, #1
 800e9be:	4932      	ldr	r1, [pc, #200]	; (800ea88 <btstack_memory_init+0x164>)
 800e9c0:	4832      	ldr	r0, [pc, #200]	; (800ea8c <btstack_memory_init+0x168>)
 800e9c2:	f000 f885 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_AVDTP_CONNECTIONS > 0
    btstack_memory_pool_create(&avdtp_connection_pool, avdtp_connection_storage, MAX_NR_AVDTP_CONNECTIONS, sizeof(avdtp_connection_t));
 800e9c6:	f44f 73fe 	mov.w	r3, #508	; 0x1fc
 800e9ca:	2201      	movs	r2, #1
 800e9cc:	4930      	ldr	r1, [pc, #192]	; (800ea90 <btstack_memory_init+0x16c>)
 800e9ce:	4831      	ldr	r0, [pc, #196]	; (800ea94 <btstack_memory_init+0x170>)
 800e9d0:	f000 f87e 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_AVRCP_CONNECTIONS > 0
    btstack_memory_pool_create(&avrcp_connection_pool, avrcp_connection_storage, MAX_NR_AVRCP_CONNECTIONS, sizeof(avrcp_connection_t));
 800e9d4:	f44f 73be 	mov.w	r3, #380	; 0x17c
 800e9d8:	2201      	movs	r2, #1
 800e9da:	492f      	ldr	r1, [pc, #188]	; (800ea98 <btstack_memory_init+0x174>)
 800e9dc:	482f      	ldr	r0, [pc, #188]	; (800ea9c <btstack_memory_init+0x178>)
 800e9de:	f000 f877 	bl	800ead0 <btstack_memory_pool_create>
    btstack_memory_pool_create(&avrcp_browsing_connection_pool, avrcp_browsing_connection_storage, MAX_NR_AVRCP_BROWSING_CONNECTIONS, sizeof(avrcp_browsing_connection_t));
#endif
#endif
#ifdef ENABLE_BLE
#if MAX_NR_GATT_CLIENTS > 0
    btstack_memory_pool_create(&gatt_client_pool, gatt_client_storage, MAX_NR_GATT_CLIENTS, sizeof(gatt_client_t));
 800e9e2:	2374      	movs	r3, #116	; 0x74
 800e9e4:	2201      	movs	r2, #1
 800e9e6:	492e      	ldr	r1, [pc, #184]	; (800eaa0 <btstack_memory_init+0x17c>)
 800e9e8:	482e      	ldr	r0, [pc, #184]	; (800eaa4 <btstack_memory_init+0x180>)
 800e9ea:	f000 f871 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_WHITELIST_ENTRIES > 0
    btstack_memory_pool_create(&whitelist_entry_pool, whitelist_entry_storage, MAX_NR_WHITELIST_ENTRIES, sizeof(whitelist_entry_t));
 800e9ee:	230c      	movs	r3, #12
 800e9f0:	2201      	movs	r2, #1
 800e9f2:	492d      	ldr	r1, [pc, #180]	; (800eaa8 <btstack_memory_init+0x184>)
 800e9f4:	482d      	ldr	r0, [pc, #180]	; (800eaac <btstack_memory_init+0x188>)
 800e9f6:	f000 f86b 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_SM_LOOKUP_ENTRIES > 0
    btstack_memory_pool_create(&sm_lookup_entry_pool, sm_lookup_entry_storage, MAX_NR_SM_LOOKUP_ENTRIES, sizeof(sm_lookup_entry_t));
 800e9fa:	230c      	movs	r3, #12
 800e9fc:	2203      	movs	r2, #3
 800e9fe:	492c      	ldr	r1, [pc, #176]	; (800eab0 <btstack_memory_init+0x18c>)
 800ea00:	482c      	ldr	r0, [pc, #176]	; (800eab4 <btstack_memory_init+0x190>)
 800ea02:	f000 f865 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_MESH_UPPER_TRANSPORT_PDUS > 0
    btstack_memory_pool_create(&mesh_upper_transport_pdu_pool, mesh_upper_transport_pdu_storage, MAX_NR_MESH_UPPER_TRANSPORT_PDUS, sizeof(mesh_upper_transport_pdu_t));
#endif
#if MAX_NR_MESH_NETWORK_KEYS > 0
    btstack_memory_pool_create(&mesh_network_key_pool, mesh_network_key_storage, MAX_NR_MESH_NETWORK_KEYS, sizeof(mesh_network_key_t));
 800ea06:	2364      	movs	r3, #100	; 0x64
 800ea08:	2203      	movs	r2, #3
 800ea0a:	492b      	ldr	r1, [pc, #172]	; (800eab8 <btstack_memory_init+0x194>)
 800ea0c:	482b      	ldr	r0, [pc, #172]	; (800eabc <btstack_memory_init+0x198>)
 800ea0e:	f000 f85f 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_MESH_TRANSPORT_KEYS > 0
    btstack_memory_pool_create(&mesh_transport_key_pool, mesh_transport_key_storage, MAX_NR_MESH_TRANSPORT_KEYS, sizeof(mesh_transport_key_t));
 800ea12:	2320      	movs	r3, #32
 800ea14:	2210      	movs	r2, #16
 800ea16:	492a      	ldr	r1, [pc, #168]	; (800eac0 <btstack_memory_init+0x19c>)
 800ea18:	482a      	ldr	r0, [pc, #168]	; (800eac4 <btstack_memory_init+0x1a0>)
 800ea1a:	f000 f859 	bl	800ead0 <btstack_memory_pool_create>
#endif
#if MAX_NR_MESH_VIRTUAL_ADDRESSS > 0
    btstack_memory_pool_create(&mesh_virtual_address_pool, mesh_virtual_address_storage, MAX_NR_MESH_VIRTUAL_ADDRESSS, sizeof(mesh_virtual_address_t));
#endif
#if MAX_NR_MESH_SUBNETS > 0
    btstack_memory_pool_create(&mesh_subnet_pool, mesh_subnet_storage, MAX_NR_MESH_SUBNETS, sizeof(mesh_subnet_t));
 800ea1e:	236c      	movs	r3, #108	; 0x6c
 800ea20:	2202      	movs	r2, #2
 800ea22:	4929      	ldr	r1, [pc, #164]	; (800eac8 <btstack_memory_init+0x1a4>)
 800ea24:	4829      	ldr	r0, [pc, #164]	; (800eacc <btstack_memory_init+0x1a8>)
 800ea26:	f000 f853 	bl	800ead0 <btstack_memory_pool_create>
#endif
#endif
}
 800ea2a:	bf00      	nop
 800ea2c:	bd80      	pop	{r7, pc}
 800ea2e:	bf00      	nop
 800ea30:	20006270 	.word	0x20006270
 800ea34:	20007ec0 	.word	0x20007ec0
 800ea38:	20007ec4 	.word	0x20007ec4
 800ea3c:	20007ef4 	.word	0x20007ef4
 800ea40:	20007ef8 	.word	0x20007ef8
 800ea44:	200081c8 	.word	0x200081c8
 800ea48:	200081cc 	.word	0x200081cc
 800ea4c:	20008200 	.word	0x20008200
 800ea50:	20008204 	.word	0x20008204
 800ea54:	20008214 	.word	0x20008214
 800ea58:	20008218 	.word	0x20008218
 800ea5c:	20008240 	.word	0x20008240
 800ea60:	20008244 	.word	0x20008244
 800ea64:	2000827c 	.word	0x2000827c
 800ea68:	20008280 	.word	0x20008280
 800ea6c:	2000828c 	.word	0x2000828c
 800ea70:	20008290 	.word	0x20008290
 800ea74:	20008368 	.word	0x20008368
 800ea78:	2000836c 	.word	0x2000836c
 800ea7c:	200085dc 	.word	0x200085dc
 800ea80:	200085e0 	.word	0x200085e0
 800ea84:	20008610 	.word	0x20008610
 800ea88:	20008614 	.word	0x20008614
 800ea8c:	20008758 	.word	0x20008758
 800ea90:	2000875c 	.word	0x2000875c
 800ea94:	20008958 	.word	0x20008958
 800ea98:	2000895c 	.word	0x2000895c
 800ea9c:	20008ad8 	.word	0x20008ad8
 800eaa0:	20008adc 	.word	0x20008adc
 800eaa4:	20008b50 	.word	0x20008b50
 800eaa8:	20008b54 	.word	0x20008b54
 800eaac:	20008b60 	.word	0x20008b60
 800eab0:	20008b64 	.word	0x20008b64
 800eab4:	20008b88 	.word	0x20008b88
 800eab8:	20008b8c 	.word	0x20008b8c
 800eabc:	20008cb8 	.word	0x20008cb8
 800eac0:	20008cbc 	.word	0x20008cbc
 800eac4:	20008ebc 	.word	0x20008ebc
 800eac8:	20008ec0 	.word	0x20008ec0
 800eacc:	20008f98 	.word	0x20008f98

0800ead0 <btstack_memory_pool_create>:

typedef struct node {
    struct node * next;
} node_t;

void btstack_memory_pool_create(btstack_memory_pool_t *pool, void * storage, int count, int block_size){
 800ead0:	b580      	push	{r7, lr}
 800ead2:	b088      	sub	sp, #32
 800ead4:	af00      	add	r7, sp, #0
 800ead6:	60f8      	str	r0, [r7, #12]
 800ead8:	60b9      	str	r1, [r7, #8]
 800eada:	607a      	str	r2, [r7, #4]
 800eadc:	603b      	str	r3, [r7, #0]
    node_t *free_blocks = (node_t*) pool;
 800eade:	68fb      	ldr	r3, [r7, #12]
 800eae0:	617b      	str	r3, [r7, #20]
    char   *mem_ptr = (char *) storage;
 800eae2:	68bb      	ldr	r3, [r7, #8]
 800eae4:	61fb      	str	r3, [r7, #28]
    int i;
    
    // create singly linked list of all available blocks
    free_blocks->next = NULL;
 800eae6:	697b      	ldr	r3, [r7, #20]
 800eae8:	2200      	movs	r2, #0
 800eaea:	601a      	str	r2, [r3, #0]
    for (i = 0 ; i < count ; i++){
 800eaec:	2300      	movs	r3, #0
 800eaee:	61bb      	str	r3, [r7, #24]
 800eaf0:	e00a      	b.n	800eb08 <btstack_memory_pool_create+0x38>
        btstack_memory_pool_free(pool, mem_ptr);
 800eaf2:	69f9      	ldr	r1, [r7, #28]
 800eaf4:	68f8      	ldr	r0, [r7, #12]
 800eaf6:	f000 f829 	bl	800eb4c <btstack_memory_pool_free>
        mem_ptr += block_size;
 800eafa:	683b      	ldr	r3, [r7, #0]
 800eafc:	69fa      	ldr	r2, [r7, #28]
 800eafe:	4413      	add	r3, r2
 800eb00:	61fb      	str	r3, [r7, #28]
    for (i = 0 ; i < count ; i++){
 800eb02:	69bb      	ldr	r3, [r7, #24]
 800eb04:	3301      	adds	r3, #1
 800eb06:	61bb      	str	r3, [r7, #24]
 800eb08:	69ba      	ldr	r2, [r7, #24]
 800eb0a:	687b      	ldr	r3, [r7, #4]
 800eb0c:	429a      	cmp	r2, r3
 800eb0e:	dbf0      	blt.n	800eaf2 <btstack_memory_pool_create+0x22>
    }
}
 800eb10:	bf00      	nop
 800eb12:	3720      	adds	r7, #32
 800eb14:	46bd      	mov	sp, r7
 800eb16:	bd80      	pop	{r7, pc}

0800eb18 <btstack_memory_pool_get>:

void * btstack_memory_pool_get(btstack_memory_pool_t *pool){
 800eb18:	b480      	push	{r7}
 800eb1a:	b085      	sub	sp, #20
 800eb1c:	af00      	add	r7, sp, #0
 800eb1e:	6078      	str	r0, [r7, #4]
    node_t *free_blocks = (node_t*) pool;
 800eb20:	687b      	ldr	r3, [r7, #4]
 800eb22:	60fb      	str	r3, [r7, #12]
    
    if (!free_blocks->next) return NULL;
 800eb24:	68fb      	ldr	r3, [r7, #12]
 800eb26:	681b      	ldr	r3, [r3, #0]
 800eb28:	2b00      	cmp	r3, #0
 800eb2a:	d101      	bne.n	800eb30 <btstack_memory_pool_get+0x18>
 800eb2c:	2300      	movs	r3, #0
 800eb2e:	e007      	b.n	800eb40 <btstack_memory_pool_get+0x28>
    
    // remove first
    node_t *node      = free_blocks->next;
 800eb30:	68fb      	ldr	r3, [r7, #12]
 800eb32:	681b      	ldr	r3, [r3, #0]
 800eb34:	60bb      	str	r3, [r7, #8]
    free_blocks->next = node->next;
 800eb36:	68bb      	ldr	r3, [r7, #8]
 800eb38:	681a      	ldr	r2, [r3, #0]
 800eb3a:	68fb      	ldr	r3, [r7, #12]
 800eb3c:	601a      	str	r2, [r3, #0]
    
    return (void*) node;
 800eb3e:	68bb      	ldr	r3, [r7, #8]
}
 800eb40:	4618      	mov	r0, r3
 800eb42:	3714      	adds	r7, #20
 800eb44:	46bd      	mov	sp, r7
 800eb46:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb4a:	4770      	bx	lr

0800eb4c <btstack_memory_pool_free>:

void btstack_memory_pool_free(btstack_memory_pool_t *pool, void * block){
 800eb4c:	b480      	push	{r7}
 800eb4e:	b087      	sub	sp, #28
 800eb50:	af00      	add	r7, sp, #0
 800eb52:	6078      	str	r0, [r7, #4]
 800eb54:	6039      	str	r1, [r7, #0]
    node_t *free_blocks = (node_t*) pool;
 800eb56:	687b      	ldr	r3, [r7, #4]
 800eb58:	613b      	str	r3, [r7, #16]
    node_t *node        = (node_t*) block;
 800eb5a:	683b      	ldr	r3, [r7, #0]
 800eb5c:	60fb      	str	r3, [r7, #12]

    // assert that node is not already in list
    node_t * it;
    for (it = free_blocks->next; it != NULL; it = it->next){
 800eb5e:	693b      	ldr	r3, [r7, #16]
 800eb60:	681b      	ldr	r3, [r3, #0]
 800eb62:	617b      	str	r3, [r7, #20]
 800eb64:	e002      	b.n	800eb6c <btstack_memory_pool_free+0x20>
 800eb66:	697b      	ldr	r3, [r7, #20]
 800eb68:	681b      	ldr	r3, [r3, #0]
 800eb6a:	617b      	str	r3, [r7, #20]
 800eb6c:	697b      	ldr	r3, [r7, #20]
 800eb6e:	2b00      	cmp	r3, #0
 800eb70:	d1f9      	bne.n	800eb66 <btstack_memory_pool_free+0x1a>
        btstack_assert(it != node);
    }

    // add block as node to list
    node->next          = free_blocks->next;
 800eb72:	693b      	ldr	r3, [r7, #16]
 800eb74:	681a      	ldr	r2, [r3, #0]
 800eb76:	68fb      	ldr	r3, [r7, #12]
 800eb78:	601a      	str	r2, [r3, #0]
    free_blocks->next   = node;
 800eb7a:	693b      	ldr	r3, [r7, #16]
 800eb7c:	68fa      	ldr	r2, [r7, #12]
 800eb7e:	601a      	str	r2, [r3, #0]
}
 800eb80:	bf00      	nop
 800eb82:	371c      	adds	r7, #28
 800eb84:	46bd      	mov	sp, r7
 800eb86:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb8a:	4770      	bx	lr

0800eb8c <btstack_run_loop_set_timer_handler>:

static const btstack_run_loop_t * the_run_loop = NULL;

extern const btstack_run_loop_t btstack_run_loop_embedded;

void btstack_run_loop_set_timer_handler(btstack_timer_source_t *ts, void (*process)(btstack_timer_source_t *_ts)){
 800eb8c:	b480      	push	{r7}
 800eb8e:	b083      	sub	sp, #12
 800eb90:	af00      	add	r7, sp, #0
 800eb92:	6078      	str	r0, [r7, #4]
 800eb94:	6039      	str	r1, [r7, #0]
    ts->process = process;
 800eb96:	687b      	ldr	r3, [r7, #4]
 800eb98:	683a      	ldr	r2, [r7, #0]
 800eb9a:	609a      	str	r2, [r3, #8]
};
 800eb9c:	bf00      	nop
 800eb9e:	370c      	adds	r7, #12
 800eba0:	46bd      	mov	sp, r7
 800eba2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eba6:	4770      	bx	lr

0800eba8 <btstack_run_loop_set_data_source_handler>:

void btstack_run_loop_set_data_source_handler(btstack_data_source_t *ds, void (*process)(btstack_data_source_t *_ds,  btstack_data_source_callback_type_t callback_type)){
 800eba8:	b480      	push	{r7}
 800ebaa:	b083      	sub	sp, #12
 800ebac:	af00      	add	r7, sp, #0
 800ebae:	6078      	str	r0, [r7, #4]
 800ebb0:	6039      	str	r1, [r7, #0]
    ds->process = process;
 800ebb2:	687b      	ldr	r3, [r7, #4]
 800ebb4:	683a      	ldr	r2, [r7, #0]
 800ebb6:	609a      	str	r2, [r3, #8]
};
 800ebb8:	bf00      	nop
 800ebba:	370c      	adds	r7, #12
 800ebbc:	46bd      	mov	sp, r7
 800ebbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ebc2:	4770      	bx	lr

0800ebc4 <btstack_run_loop_enable_data_source_callbacks>:

void * btstack_run_loop_get_data_source_handle(btstack_data_source_t *ds){
    return ds->source.handle;
}

void btstack_run_loop_enable_data_source_callbacks(btstack_data_source_t *ds, uint16_t callbacks){
 800ebc4:	b580      	push	{r7, lr}
 800ebc6:	b082      	sub	sp, #8
 800ebc8:	af00      	add	r7, sp, #0
 800ebca:	6078      	str	r0, [r7, #4]
 800ebcc:	460b      	mov	r3, r1
 800ebce:	807b      	strh	r3, [r7, #2]
    btstack_assert(the_run_loop != NULL);
    btstack_assert(the_run_loop->enable_data_source_callbacks != NULL);
    the_run_loop->enable_data_source_callbacks(ds, callbacks);
 800ebd0:	4b05      	ldr	r3, [pc, #20]	; (800ebe8 <btstack_run_loop_enable_data_source_callbacks+0x24>)
 800ebd2:	681b      	ldr	r3, [r3, #0]
 800ebd4:	68db      	ldr	r3, [r3, #12]
 800ebd6:	887a      	ldrh	r2, [r7, #2]
 800ebd8:	4611      	mov	r1, r2
 800ebda:	6878      	ldr	r0, [r7, #4]
 800ebdc:	4798      	blx	r3
}
 800ebde:	bf00      	nop
 800ebe0:	3708      	adds	r7, #8
 800ebe2:	46bd      	mov	sp, r7
 800ebe4:	bd80      	pop	{r7, pc}
 800ebe6:	bf00      	nop
 800ebe8:	20008f9c 	.word	0x20008f9c

0800ebec <btstack_run_loop_disable_data_source_callbacks>:

void btstack_run_loop_disable_data_source_callbacks(btstack_data_source_t *ds, uint16_t callbacks){
 800ebec:	b580      	push	{r7, lr}
 800ebee:	b082      	sub	sp, #8
 800ebf0:	af00      	add	r7, sp, #0
 800ebf2:	6078      	str	r0, [r7, #4]
 800ebf4:	460b      	mov	r3, r1
 800ebf6:	807b      	strh	r3, [r7, #2]
    btstack_assert(the_run_loop != NULL);
    btstack_assert(the_run_loop->enable_data_source_callbacks != NULL);
    the_run_loop->disable_data_source_callbacks(ds, callbacks);
 800ebf8:	4b05      	ldr	r3, [pc, #20]	; (800ec10 <btstack_run_loop_disable_data_source_callbacks+0x24>)
 800ebfa:	681b      	ldr	r3, [r3, #0]
 800ebfc:	691b      	ldr	r3, [r3, #16]
 800ebfe:	887a      	ldrh	r2, [r7, #2]
 800ec00:	4611      	mov	r1, r2
 800ec02:	6878      	ldr	r0, [r7, #4]
 800ec04:	4798      	blx	r3
}
 800ec06:	bf00      	nop
 800ec08:	3708      	adds	r7, #8
 800ec0a:	46bd      	mov	sp, r7
 800ec0c:	bd80      	pop	{r7, pc}
 800ec0e:	bf00      	nop
 800ec10:	20008f9c 	.word	0x20008f9c

0800ec14 <btstack_run_loop_add_data_source>:

/**
 * Add data_source to run_loop
 */
void btstack_run_loop_add_data_source(btstack_data_source_t *ds){
 800ec14:	b580      	push	{r7, lr}
 800ec16:	b082      	sub	sp, #8
 800ec18:	af00      	add	r7, sp, #0
 800ec1a:	6078      	str	r0, [r7, #4]
    btstack_assert(the_run_loop != NULL);
    btstack_assert(the_run_loop->enable_data_source_callbacks != NULL);
    btstack_assert(ds->process != NULL);
    the_run_loop->add_data_source(ds);
 800ec1c:	4b04      	ldr	r3, [pc, #16]	; (800ec30 <btstack_run_loop_add_data_source+0x1c>)
 800ec1e:	681b      	ldr	r3, [r3, #0]
 800ec20:	685b      	ldr	r3, [r3, #4]
 800ec22:	6878      	ldr	r0, [r7, #4]
 800ec24:	4798      	blx	r3
}
 800ec26:	bf00      	nop
 800ec28:	3708      	adds	r7, #8
 800ec2a:	46bd      	mov	sp, r7
 800ec2c:	bd80      	pop	{r7, pc}
 800ec2e:	bf00      	nop
 800ec30:	20008f9c 	.word	0x20008f9c

0800ec34 <btstack_run_loop_remove_data_source>:

/**
 * Remove data_source from run loop
 */
int btstack_run_loop_remove_data_source(btstack_data_source_t *ds){
 800ec34:	b580      	push	{r7, lr}
 800ec36:	b082      	sub	sp, #8
 800ec38:	af00      	add	r7, sp, #0
 800ec3a:	6078      	str	r0, [r7, #4]
    btstack_assert(the_run_loop != NULL);
    btstack_assert(the_run_loop->disable_data_source_callbacks != NULL);
    btstack_assert(ds->process != NULL);
    return the_run_loop->remove_data_source(ds);
 800ec3c:	4b04      	ldr	r3, [pc, #16]	; (800ec50 <btstack_run_loop_remove_data_source+0x1c>)
 800ec3e:	681b      	ldr	r3, [r3, #0]
 800ec40:	689b      	ldr	r3, [r3, #8]
 800ec42:	6878      	ldr	r0, [r7, #4]
 800ec44:	4798      	blx	r3
 800ec46:	4603      	mov	r3, r0
}
 800ec48:	4618      	mov	r0, r3
 800ec4a:	3708      	adds	r7, #8
 800ec4c:	46bd      	mov	sp, r7
 800ec4e:	bd80      	pop	{r7, pc}
 800ec50:	20008f9c 	.word	0x20008f9c

0800ec54 <btstack_run_loop_set_timer>:

void btstack_run_loop_set_timer(btstack_timer_source_t *a, uint32_t timeout_in_ms){
 800ec54:	b580      	push	{r7, lr}
 800ec56:	b082      	sub	sp, #8
 800ec58:	af00      	add	r7, sp, #0
 800ec5a:	6078      	str	r0, [r7, #4]
 800ec5c:	6039      	str	r1, [r7, #0]
    btstack_assert(the_run_loop != NULL);
    the_run_loop->set_timer(a, timeout_in_ms);
 800ec5e:	4b05      	ldr	r3, [pc, #20]	; (800ec74 <btstack_run_loop_set_timer+0x20>)
 800ec60:	681b      	ldr	r3, [r3, #0]
 800ec62:	695b      	ldr	r3, [r3, #20]
 800ec64:	6839      	ldr	r1, [r7, #0]
 800ec66:	6878      	ldr	r0, [r7, #4]
 800ec68:	4798      	blx	r3
}
 800ec6a:	bf00      	nop
 800ec6c:	3708      	adds	r7, #8
 800ec6e:	46bd      	mov	sp, r7
 800ec70:	bd80      	pop	{r7, pc}
 800ec72:	bf00      	nop
 800ec74:	20008f9c 	.word	0x20008f9c

0800ec78 <btstack_run_loop_set_timer_context>:

/**
 * @brief Set context for this timer
 */
void btstack_run_loop_set_timer_context(btstack_timer_source_t *ts, void * context){
 800ec78:	b480      	push	{r7}
 800ec7a:	b083      	sub	sp, #12
 800ec7c:	af00      	add	r7, sp, #0
 800ec7e:	6078      	str	r0, [r7, #4]
 800ec80:	6039      	str	r1, [r7, #0]
    ts->context = context;
 800ec82:	687b      	ldr	r3, [r7, #4]
 800ec84:	683a      	ldr	r2, [r7, #0]
 800ec86:	60da      	str	r2, [r3, #12]
}
 800ec88:	bf00      	nop
 800ec8a:	370c      	adds	r7, #12
 800ec8c:	46bd      	mov	sp, r7
 800ec8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec92:	4770      	bx	lr

0800ec94 <btstack_run_loop_get_timer_context>:

/**
 * @brief Get context for this timer
 */
void * btstack_run_loop_get_timer_context(btstack_timer_source_t *ts){
 800ec94:	b480      	push	{r7}
 800ec96:	b083      	sub	sp, #12
 800ec98:	af00      	add	r7, sp, #0
 800ec9a:	6078      	str	r0, [r7, #4]
    return ts->context;
 800ec9c:	687b      	ldr	r3, [r7, #4]
 800ec9e:	68db      	ldr	r3, [r3, #12]
}
 800eca0:	4618      	mov	r0, r3
 800eca2:	370c      	adds	r7, #12
 800eca4:	46bd      	mov	sp, r7
 800eca6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecaa:	4770      	bx	lr

0800ecac <btstack_run_loop_add_timer>:

/**
 * Add timer to run_loop (keep list sorted)
 */
void btstack_run_loop_add_timer(btstack_timer_source_t *ts){
 800ecac:	b580      	push	{r7, lr}
 800ecae:	b082      	sub	sp, #8
 800ecb0:	af00      	add	r7, sp, #0
 800ecb2:	6078      	str	r0, [r7, #4]
    btstack_assert(the_run_loop != NULL);
    btstack_assert(ts->process != NULL);
    the_run_loop->add_timer(ts);
 800ecb4:	4b04      	ldr	r3, [pc, #16]	; (800ecc8 <btstack_run_loop_add_timer+0x1c>)
 800ecb6:	681b      	ldr	r3, [r3, #0]
 800ecb8:	699b      	ldr	r3, [r3, #24]
 800ecba:	6878      	ldr	r0, [r7, #4]
 800ecbc:	4798      	blx	r3
}
 800ecbe:	bf00      	nop
 800ecc0:	3708      	adds	r7, #8
 800ecc2:	46bd      	mov	sp, r7
 800ecc4:	bd80      	pop	{r7, pc}
 800ecc6:	bf00      	nop
 800ecc8:	20008f9c 	.word	0x20008f9c

0800eccc <btstack_run_loop_remove_timer>:

/**
 * Remove timer from run loop
 */
int btstack_run_loop_remove_timer(btstack_timer_source_t *ts){
 800eccc:	b580      	push	{r7, lr}
 800ecce:	b082      	sub	sp, #8
 800ecd0:	af00      	add	r7, sp, #0
 800ecd2:	6078      	str	r0, [r7, #4]
    btstack_assert(the_run_loop != NULL);
    return the_run_loop->remove_timer(ts);
 800ecd4:	4b04      	ldr	r3, [pc, #16]	; (800ece8 <btstack_run_loop_remove_timer+0x1c>)
 800ecd6:	681b      	ldr	r3, [r3, #0]
 800ecd8:	69db      	ldr	r3, [r3, #28]
 800ecda:	6878      	ldr	r0, [r7, #4]
 800ecdc:	4798      	blx	r3
 800ecde:	4603      	mov	r3, r0
}
 800ece0:	4618      	mov	r0, r3
 800ece2:	3708      	adds	r7, #8
 800ece4:	46bd      	mov	sp, r7
 800ece6:	bd80      	pop	{r7, pc}
 800ece8:	20008f9c 	.word	0x20008f9c

0800ecec <btstack_run_loop_get_time_ms>:

/**
 * @brief Get current time in ms
 */
uint32_t btstack_run_loop_get_time_ms(void){
 800ecec:	b580      	push	{r7, lr}
 800ecee:	af00      	add	r7, sp, #0
    btstack_assert(the_run_loop != NULL);
    return the_run_loop->get_time_ms();
 800ecf0:	4b03      	ldr	r3, [pc, #12]	; (800ed00 <btstack_run_loop_get_time_ms+0x14>)
 800ecf2:	681b      	ldr	r3, [r3, #0]
 800ecf4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ecf6:	4798      	blx	r3
 800ecf8:	4603      	mov	r3, r0
}
 800ecfa:	4618      	mov	r0, r3
 800ecfc:	bd80      	pop	{r7, pc}
 800ecfe:	bf00      	nop
 800ed00:	20008f9c 	.word	0x20008f9c

0800ed04 <btstack_run_loop_execute>:
}

/**
 * Execute run_loop
 */
void btstack_run_loop_execute(void){
 800ed04:	b580      	push	{r7, lr}
 800ed06:	af00      	add	r7, sp, #0
    btstack_assert(the_run_loop != NULL);
    the_run_loop->execute();
 800ed08:	4b02      	ldr	r3, [pc, #8]	; (800ed14 <btstack_run_loop_execute+0x10>)
 800ed0a:	681b      	ldr	r3, [r3, #0]
 800ed0c:	6a1b      	ldr	r3, [r3, #32]
 800ed0e:	4798      	blx	r3
}
 800ed10:	bf00      	nop
 800ed12:	bd80      	pop	{r7, pc}
 800ed14:	20008f9c 	.word	0x20008f9c

0800ed18 <btstack_run_loop_init>:

// init must be called before any other run_loop call
void btstack_run_loop_init(const btstack_run_loop_t * run_loop){
 800ed18:	b580      	push	{r7, lr}
 800ed1a:	b082      	sub	sp, #8
 800ed1c:	af00      	add	r7, sp, #0
 800ed1e:	6078      	str	r0, [r7, #4]
    btstack_assert(the_run_loop == NULL);
    the_run_loop = run_loop;
 800ed20:	4a05      	ldr	r2, [pc, #20]	; (800ed38 <btstack_run_loop_init+0x20>)
 800ed22:	687b      	ldr	r3, [r7, #4]
 800ed24:	6013      	str	r3, [r2, #0]
    the_run_loop->init();
 800ed26:	4b04      	ldr	r3, [pc, #16]	; (800ed38 <btstack_run_loop_init+0x20>)
 800ed28:	681b      	ldr	r3, [r3, #0]
 800ed2a:	681b      	ldr	r3, [r3, #0]
 800ed2c:	4798      	blx	r3
}
 800ed2e:	bf00      	nop
 800ed30:	3708      	adds	r7, #8
 800ed32:	46bd      	mov	sp, r7
 800ed34:	bd80      	pop	{r7, pc}
 800ed36:	bf00      	nop
 800ed38:	20008f9c 	.word	0x20008f9c

0800ed3c <btstack_tlv_set_instance>:


static const btstack_tlv_t * btstack_tlv_singleton_impl;
static void * 		         btstack_tlv_singleton_context;

void btstack_tlv_set_instance(const btstack_tlv_t * tlv_impl, void * tlv_context){
 800ed3c:	b580      	push	{r7, lr}
 800ed3e:	b084      	sub	sp, #16
 800ed40:	af02      	add	r7, sp, #8
 800ed42:	6078      	str	r0, [r7, #4]
 800ed44:	6039      	str	r1, [r7, #0]
	log_info("TLV Instance %p", tlv_impl);
 800ed46:	687b      	ldr	r3, [r7, #4]
 800ed48:	9300      	str	r3, [sp, #0]
 800ed4a:	2330      	movs	r3, #48	; 0x30
 800ed4c:	4a07      	ldr	r2, [pc, #28]	; (800ed6c <btstack_tlv_set_instance+0x30>)
 800ed4e:	4908      	ldr	r1, [pc, #32]	; (800ed70 <btstack_tlv_set_instance+0x34>)
 800ed50:	2001      	movs	r0, #1
 800ed52:	f008 fb75 	bl	8017440 <hci_dump_log>
	btstack_tlv_singleton_impl 	  = tlv_impl;
 800ed56:	4a07      	ldr	r2, [pc, #28]	; (800ed74 <btstack_tlv_set_instance+0x38>)
 800ed58:	687b      	ldr	r3, [r7, #4]
 800ed5a:	6013      	str	r3, [r2, #0]
	btstack_tlv_singleton_context = tlv_context;
 800ed5c:	4a06      	ldr	r2, [pc, #24]	; (800ed78 <btstack_tlv_set_instance+0x3c>)
 800ed5e:	683b      	ldr	r3, [r7, #0]
 800ed60:	6013      	str	r3, [r2, #0]
}
 800ed62:	bf00      	nop
 800ed64:	3708      	adds	r7, #8
 800ed66:	46bd      	mov	sp, r7
 800ed68:	bd80      	pop	{r7, pc}
 800ed6a:	bf00      	nop
 800ed6c:	08029200 	.word	0x08029200
 800ed70:	08029210 	.word	0x08029210
 800ed74:	20008fa0 	.word	0x20008fa0
 800ed78:	20008fa4 	.word	0x20008fa4

0800ed7c <btstack_tlv_get_instance>:

void btstack_tlv_get_instance(const btstack_tlv_t ** tlv_impl, void ** tlv_context){
 800ed7c:	b480      	push	{r7}
 800ed7e:	b083      	sub	sp, #12
 800ed80:	af00      	add	r7, sp, #0
 800ed82:	6078      	str	r0, [r7, #4]
 800ed84:	6039      	str	r1, [r7, #0]
	*tlv_impl    = btstack_tlv_singleton_impl;
 800ed86:	4b07      	ldr	r3, [pc, #28]	; (800eda4 <btstack_tlv_get_instance+0x28>)
 800ed88:	681a      	ldr	r2, [r3, #0]
 800ed8a:	687b      	ldr	r3, [r7, #4]
 800ed8c:	601a      	str	r2, [r3, #0]
	*tlv_context = btstack_tlv_singleton_context;
 800ed8e:	4b06      	ldr	r3, [pc, #24]	; (800eda8 <btstack_tlv_get_instance+0x2c>)
 800ed90:	681a      	ldr	r2, [r3, #0]
 800ed92:	683b      	ldr	r3, [r7, #0]
 800ed94:	601a      	str	r2, [r3, #0]
}
 800ed96:	bf00      	nop
 800ed98:	370c      	adds	r7, #12
 800ed9a:	46bd      	mov	sp, r7
 800ed9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eda0:	4770      	bx	lr
 800eda2:	bf00      	nop
 800eda4:	20008fa0 	.word	0x20008fa0
 800eda8:	20008fa4 	.word	0x20008fa4

0800edac <bd_addr_cmp>:
 * @brief Compare two Bluetooth addresses
 * @param a
 * @param b
 * @return 0 if equal
 */
int bd_addr_cmp(const bd_addr_t a, const bd_addr_t b){
 800edac:	b580      	push	{r7, lr}
 800edae:	b082      	sub	sp, #8
 800edb0:	af00      	add	r7, sp, #0
 800edb2:	6078      	str	r0, [r7, #4]
 800edb4:	6039      	str	r1, [r7, #0]
    return memcmp(a,b, BD_ADDR_LEN);
 800edb6:	2206      	movs	r2, #6
 800edb8:	6839      	ldr	r1, [r7, #0]
 800edba:	6878      	ldr	r0, [r7, #4]
 800edbc:	f018 fe4e 	bl	8027a5c <memcmp>
 800edc0:	4603      	mov	r3, r0
}
 800edc2:	4618      	mov	r0, r3
 800edc4:	3708      	adds	r7, #8
 800edc6:	46bd      	mov	sp, r7
 800edc8:	bd80      	pop	{r7, pc}

0800edca <bd_addr_copy>:
/**
 * @brief Copy Bluetooth address
 * @param dest
 * @param src
 */
void bd_addr_copy(bd_addr_t dest, const bd_addr_t src){
 800edca:	b580      	push	{r7, lr}
 800edcc:	b082      	sub	sp, #8
 800edce:	af00      	add	r7, sp, #0
 800edd0:	6078      	str	r0, [r7, #4]
 800edd2:	6039      	str	r1, [r7, #0]
    (void)memcpy(dest, src, BD_ADDR_LEN);
 800edd4:	2206      	movs	r2, #6
 800edd6:	6839      	ldr	r1, [r7, #0]
 800edd8:	6878      	ldr	r0, [r7, #4]
 800edda:	f018 fe4e 	bl	8027a7a <memcpy>
}
 800edde:	bf00      	nop
 800ede0:	3708      	adds	r7, #8
 800ede2:	46bd      	mov	sp, r7
 800ede4:	bd80      	pop	{r7, pc}

0800ede6 <little_endian_read_16>:

uint16_t little_endian_read_16(const uint8_t * buffer, int pos){
 800ede6:	b480      	push	{r7}
 800ede8:	b083      	sub	sp, #12
 800edea:	af00      	add	r7, sp, #0
 800edec:	6078      	str	r0, [r7, #4]
 800edee:	6039      	str	r1, [r7, #0]
    return (uint16_t)(((uint16_t) buffer[pos]) | (((uint16_t)buffer[(pos)+1]) << 8));
 800edf0:	683b      	ldr	r3, [r7, #0]
 800edf2:	687a      	ldr	r2, [r7, #4]
 800edf4:	4413      	add	r3, r2
 800edf6:	781b      	ldrb	r3, [r3, #0]
 800edf8:	b21a      	sxth	r2, r3
 800edfa:	683b      	ldr	r3, [r7, #0]
 800edfc:	3301      	adds	r3, #1
 800edfe:	6879      	ldr	r1, [r7, #4]
 800ee00:	440b      	add	r3, r1
 800ee02:	781b      	ldrb	r3, [r3, #0]
 800ee04:	021b      	lsls	r3, r3, #8
 800ee06:	b21b      	sxth	r3, r3
 800ee08:	4313      	orrs	r3, r2
 800ee0a:	b21b      	sxth	r3, r3
 800ee0c:	b29b      	uxth	r3, r3
}
 800ee0e:	4618      	mov	r0, r3
 800ee10:	370c      	adds	r7, #12
 800ee12:	46bd      	mov	sp, r7
 800ee14:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee18:	4770      	bx	lr

0800ee1a <little_endian_read_32>:
uint32_t little_endian_read_24(const uint8_t * buffer, int pos){
    return ((uint32_t) buffer[pos]) | (((uint32_t)buffer[(pos)+1]) << 8) | (((uint32_t)buffer[(pos)+2]) << 16);
}
uint32_t little_endian_read_32(const uint8_t * buffer, int pos){
 800ee1a:	b480      	push	{r7}
 800ee1c:	b083      	sub	sp, #12
 800ee1e:	af00      	add	r7, sp, #0
 800ee20:	6078      	str	r0, [r7, #4]
 800ee22:	6039      	str	r1, [r7, #0]
    return ((uint32_t) buffer[pos]) | (((uint32_t)buffer[(pos)+1]) << 8) | (((uint32_t)buffer[(pos)+2]) << 16) | (((uint32_t) buffer[(pos)+3]) << 24);
 800ee24:	683b      	ldr	r3, [r7, #0]
 800ee26:	687a      	ldr	r2, [r7, #4]
 800ee28:	4413      	add	r3, r2
 800ee2a:	781b      	ldrb	r3, [r3, #0]
 800ee2c:	4619      	mov	r1, r3
 800ee2e:	683b      	ldr	r3, [r7, #0]
 800ee30:	3301      	adds	r3, #1
 800ee32:	687a      	ldr	r2, [r7, #4]
 800ee34:	4413      	add	r3, r2
 800ee36:	781b      	ldrb	r3, [r3, #0]
 800ee38:	021b      	lsls	r3, r3, #8
 800ee3a:	ea41 0203 	orr.w	r2, r1, r3
 800ee3e:	683b      	ldr	r3, [r7, #0]
 800ee40:	3302      	adds	r3, #2
 800ee42:	6879      	ldr	r1, [r7, #4]
 800ee44:	440b      	add	r3, r1
 800ee46:	781b      	ldrb	r3, [r3, #0]
 800ee48:	041b      	lsls	r3, r3, #16
 800ee4a:	431a      	orrs	r2, r3
 800ee4c:	683b      	ldr	r3, [r7, #0]
 800ee4e:	3303      	adds	r3, #3
 800ee50:	6879      	ldr	r1, [r7, #4]
 800ee52:	440b      	add	r3, r1
 800ee54:	781b      	ldrb	r3, [r3, #0]
 800ee56:	061b      	lsls	r3, r3, #24
 800ee58:	4313      	orrs	r3, r2
}
 800ee5a:	4618      	mov	r0, r3
 800ee5c:	370c      	adds	r7, #12
 800ee5e:	46bd      	mov	sp, r7
 800ee60:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee64:	4770      	bx	lr

0800ee66 <little_endian_store_16>:

void little_endian_store_16(uint8_t *buffer, uint16_t pos, uint16_t value){
 800ee66:	b480      	push	{r7}
 800ee68:	b083      	sub	sp, #12
 800ee6a:	af00      	add	r7, sp, #0
 800ee6c:	6078      	str	r0, [r7, #4]
 800ee6e:	460b      	mov	r3, r1
 800ee70:	807b      	strh	r3, [r7, #2]
 800ee72:	4613      	mov	r3, r2
 800ee74:	803b      	strh	r3, [r7, #0]
    buffer[pos++] = (uint8_t)value;
 800ee76:	887b      	ldrh	r3, [r7, #2]
 800ee78:	1c5a      	adds	r2, r3, #1
 800ee7a:	807a      	strh	r2, [r7, #2]
 800ee7c:	461a      	mov	r2, r3
 800ee7e:	687b      	ldr	r3, [r7, #4]
 800ee80:	4413      	add	r3, r2
 800ee82:	883a      	ldrh	r2, [r7, #0]
 800ee84:	b2d2      	uxtb	r2, r2
 800ee86:	701a      	strb	r2, [r3, #0]
    buffer[pos++] = (uint8_t)(value >> 8);
 800ee88:	883b      	ldrh	r3, [r7, #0]
 800ee8a:	0a1b      	lsrs	r3, r3, #8
 800ee8c:	b29a      	uxth	r2, r3
 800ee8e:	887b      	ldrh	r3, [r7, #2]
 800ee90:	1c59      	adds	r1, r3, #1
 800ee92:	8079      	strh	r1, [r7, #2]
 800ee94:	4619      	mov	r1, r3
 800ee96:	687b      	ldr	r3, [r7, #4]
 800ee98:	440b      	add	r3, r1
 800ee9a:	b2d2      	uxtb	r2, r2
 800ee9c:	701a      	strb	r2, [r3, #0]
}
 800ee9e:	bf00      	nop
 800eea0:	370c      	adds	r7, #12
 800eea2:	46bd      	mov	sp, r7
 800eea4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eea8:	4770      	bx	lr

0800eeaa <little_endian_store_32>:
    buffer[pos++] = (uint8_t)(value);
    buffer[pos++] = (uint8_t)(value >> 8);
    buffer[pos++] = (uint8_t)(value >> 16);
}

void little_endian_store_32(uint8_t *buffer, uint16_t pos, uint32_t value){
 800eeaa:	b480      	push	{r7}
 800eeac:	b085      	sub	sp, #20
 800eeae:	af00      	add	r7, sp, #0
 800eeb0:	60f8      	str	r0, [r7, #12]
 800eeb2:	460b      	mov	r3, r1
 800eeb4:	607a      	str	r2, [r7, #4]
 800eeb6:	817b      	strh	r3, [r7, #10]
    buffer[pos++] = (uint8_t)(value);
 800eeb8:	897b      	ldrh	r3, [r7, #10]
 800eeba:	1c5a      	adds	r2, r3, #1
 800eebc:	817a      	strh	r2, [r7, #10]
 800eebe:	461a      	mov	r2, r3
 800eec0:	68fb      	ldr	r3, [r7, #12]
 800eec2:	4413      	add	r3, r2
 800eec4:	687a      	ldr	r2, [r7, #4]
 800eec6:	b2d2      	uxtb	r2, r2
 800eec8:	701a      	strb	r2, [r3, #0]
    buffer[pos++] = (uint8_t)(value >> 8);
 800eeca:	687b      	ldr	r3, [r7, #4]
 800eecc:	0a1a      	lsrs	r2, r3, #8
 800eece:	897b      	ldrh	r3, [r7, #10]
 800eed0:	1c59      	adds	r1, r3, #1
 800eed2:	8179      	strh	r1, [r7, #10]
 800eed4:	4619      	mov	r1, r3
 800eed6:	68fb      	ldr	r3, [r7, #12]
 800eed8:	440b      	add	r3, r1
 800eeda:	b2d2      	uxtb	r2, r2
 800eedc:	701a      	strb	r2, [r3, #0]
    buffer[pos++] = (uint8_t)(value >> 16);
 800eede:	687b      	ldr	r3, [r7, #4]
 800eee0:	0c1a      	lsrs	r2, r3, #16
 800eee2:	897b      	ldrh	r3, [r7, #10]
 800eee4:	1c59      	adds	r1, r3, #1
 800eee6:	8179      	strh	r1, [r7, #10]
 800eee8:	4619      	mov	r1, r3
 800eeea:	68fb      	ldr	r3, [r7, #12]
 800eeec:	440b      	add	r3, r1
 800eeee:	b2d2      	uxtb	r2, r2
 800eef0:	701a      	strb	r2, [r3, #0]
    buffer[pos++] = (uint8_t)(value >> 24);
 800eef2:	687b      	ldr	r3, [r7, #4]
 800eef4:	0e1a      	lsrs	r2, r3, #24
 800eef6:	897b      	ldrh	r3, [r7, #10]
 800eef8:	1c59      	adds	r1, r3, #1
 800eefa:	8179      	strh	r1, [r7, #10]
 800eefc:	4619      	mov	r1, r3
 800eefe:	68fb      	ldr	r3, [r7, #12]
 800ef00:	440b      	add	r3, r1
 800ef02:	b2d2      	uxtb	r2, r2
 800ef04:	701a      	strb	r2, [r3, #0]
}
 800ef06:	bf00      	nop
 800ef08:	3714      	adds	r7, #20
 800ef0a:	46bd      	mov	sp, r7
 800ef0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef10:	4770      	bx	lr

0800ef12 <big_endian_read_16>:

uint32_t big_endian_read_16( const uint8_t * buffer, int pos) {
 800ef12:	b480      	push	{r7}
 800ef14:	b083      	sub	sp, #12
 800ef16:	af00      	add	r7, sp, #0
 800ef18:	6078      	str	r0, [r7, #4]
 800ef1a:	6039      	str	r1, [r7, #0]
    return (uint16_t)(((uint16_t) buffer[(pos)+1]) | (((uint16_t)buffer[ pos   ]) << 8));
 800ef1c:	683b      	ldr	r3, [r7, #0]
 800ef1e:	3301      	adds	r3, #1
 800ef20:	687a      	ldr	r2, [r7, #4]
 800ef22:	4413      	add	r3, r2
 800ef24:	781b      	ldrb	r3, [r3, #0]
 800ef26:	b21a      	sxth	r2, r3
 800ef28:	683b      	ldr	r3, [r7, #0]
 800ef2a:	6879      	ldr	r1, [r7, #4]
 800ef2c:	440b      	add	r3, r1
 800ef2e:	781b      	ldrb	r3, [r3, #0]
 800ef30:	021b      	lsls	r3, r3, #8
 800ef32:	b21b      	sxth	r3, r3
 800ef34:	4313      	orrs	r3, r2
 800ef36:	b21b      	sxth	r3, r3
 800ef38:	b29b      	uxth	r3, r3
}
 800ef3a:	4618      	mov	r0, r3
 800ef3c:	370c      	adds	r7, #12
 800ef3e:	46bd      	mov	sp, r7
 800ef40:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef44:	4770      	bx	lr

0800ef46 <big_endian_read_32>:

uint32_t big_endian_read_24( const uint8_t * buffer, int pos) {
    return ( ((uint32_t)buffer[(pos)+2]) | (((uint32_t)buffer[(pos)+1]) << 8) | (((uint32_t) buffer[pos]) << 16));
}

uint32_t big_endian_read_32( const uint8_t * buffer, int pos) {
 800ef46:	b480      	push	{r7}
 800ef48:	b083      	sub	sp, #12
 800ef4a:	af00      	add	r7, sp, #0
 800ef4c:	6078      	str	r0, [r7, #4]
 800ef4e:	6039      	str	r1, [r7, #0]
    return ((uint32_t) buffer[(pos)+3]) | (((uint32_t)buffer[(pos)+2]) << 8) | (((uint32_t)buffer[(pos)+1]) << 16) | (((uint32_t) buffer[pos]) << 24);
 800ef50:	683b      	ldr	r3, [r7, #0]
 800ef52:	3303      	adds	r3, #3
 800ef54:	687a      	ldr	r2, [r7, #4]
 800ef56:	4413      	add	r3, r2
 800ef58:	781b      	ldrb	r3, [r3, #0]
 800ef5a:	4619      	mov	r1, r3
 800ef5c:	683b      	ldr	r3, [r7, #0]
 800ef5e:	3302      	adds	r3, #2
 800ef60:	687a      	ldr	r2, [r7, #4]
 800ef62:	4413      	add	r3, r2
 800ef64:	781b      	ldrb	r3, [r3, #0]
 800ef66:	021b      	lsls	r3, r3, #8
 800ef68:	ea41 0203 	orr.w	r2, r1, r3
 800ef6c:	683b      	ldr	r3, [r7, #0]
 800ef6e:	3301      	adds	r3, #1
 800ef70:	6879      	ldr	r1, [r7, #4]
 800ef72:	440b      	add	r3, r1
 800ef74:	781b      	ldrb	r3, [r3, #0]
 800ef76:	041b      	lsls	r3, r3, #16
 800ef78:	431a      	orrs	r2, r3
 800ef7a:	683b      	ldr	r3, [r7, #0]
 800ef7c:	6879      	ldr	r1, [r7, #4]
 800ef7e:	440b      	add	r3, r1
 800ef80:	781b      	ldrb	r3, [r3, #0]
 800ef82:	061b      	lsls	r3, r3, #24
 800ef84:	4313      	orrs	r3, r2
}
 800ef86:	4618      	mov	r0, r3
 800ef88:	370c      	adds	r7, #12
 800ef8a:	46bd      	mov	sp, r7
 800ef8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef90:	4770      	bx	lr

0800ef92 <big_endian_store_16>:

void big_endian_store_16(uint8_t *buffer, uint16_t pos, uint16_t value){
 800ef92:	b480      	push	{r7}
 800ef94:	b083      	sub	sp, #12
 800ef96:	af00      	add	r7, sp, #0
 800ef98:	6078      	str	r0, [r7, #4]
 800ef9a:	460b      	mov	r3, r1
 800ef9c:	807b      	strh	r3, [r7, #2]
 800ef9e:	4613      	mov	r3, r2
 800efa0:	803b      	strh	r3, [r7, #0]
    buffer[pos++] = (uint8_t)(value >> 8);
 800efa2:	883b      	ldrh	r3, [r7, #0]
 800efa4:	0a1b      	lsrs	r3, r3, #8
 800efa6:	b29a      	uxth	r2, r3
 800efa8:	887b      	ldrh	r3, [r7, #2]
 800efaa:	1c59      	adds	r1, r3, #1
 800efac:	8079      	strh	r1, [r7, #2]
 800efae:	4619      	mov	r1, r3
 800efb0:	687b      	ldr	r3, [r7, #4]
 800efb2:	440b      	add	r3, r1
 800efb4:	b2d2      	uxtb	r2, r2
 800efb6:	701a      	strb	r2, [r3, #0]
    buffer[pos++] = (uint8_t)(value);
 800efb8:	887b      	ldrh	r3, [r7, #2]
 800efba:	1c5a      	adds	r2, r3, #1
 800efbc:	807a      	strh	r2, [r7, #2]
 800efbe:	461a      	mov	r2, r3
 800efc0:	687b      	ldr	r3, [r7, #4]
 800efc2:	4413      	add	r3, r2
 800efc4:	883a      	ldrh	r2, [r7, #0]
 800efc6:	b2d2      	uxtb	r2, r2
 800efc8:	701a      	strb	r2, [r3, #0]
}
 800efca:	bf00      	nop
 800efcc:	370c      	adds	r7, #12
 800efce:	46bd      	mov	sp, r7
 800efd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800efd4:	4770      	bx	lr

0800efd6 <big_endian_store_32>:
    buffer[pos++] = (uint8_t)(value >> 16);
    buffer[pos++] = (uint8_t)(value >> 8);
    buffer[pos++] = (uint8_t)(value);
}

void big_endian_store_32(uint8_t *buffer, uint16_t pos, uint32_t value){
 800efd6:	b480      	push	{r7}
 800efd8:	b085      	sub	sp, #20
 800efda:	af00      	add	r7, sp, #0
 800efdc:	60f8      	str	r0, [r7, #12]
 800efde:	460b      	mov	r3, r1
 800efe0:	607a      	str	r2, [r7, #4]
 800efe2:	817b      	strh	r3, [r7, #10]
    buffer[pos++] = (uint8_t)(value >> 24);
 800efe4:	687b      	ldr	r3, [r7, #4]
 800efe6:	0e1a      	lsrs	r2, r3, #24
 800efe8:	897b      	ldrh	r3, [r7, #10]
 800efea:	1c59      	adds	r1, r3, #1
 800efec:	8179      	strh	r1, [r7, #10]
 800efee:	4619      	mov	r1, r3
 800eff0:	68fb      	ldr	r3, [r7, #12]
 800eff2:	440b      	add	r3, r1
 800eff4:	b2d2      	uxtb	r2, r2
 800eff6:	701a      	strb	r2, [r3, #0]
    buffer[pos++] = (uint8_t)(value >> 16);
 800eff8:	687b      	ldr	r3, [r7, #4]
 800effa:	0c1a      	lsrs	r2, r3, #16
 800effc:	897b      	ldrh	r3, [r7, #10]
 800effe:	1c59      	adds	r1, r3, #1
 800f000:	8179      	strh	r1, [r7, #10]
 800f002:	4619      	mov	r1, r3
 800f004:	68fb      	ldr	r3, [r7, #12]
 800f006:	440b      	add	r3, r1
 800f008:	b2d2      	uxtb	r2, r2
 800f00a:	701a      	strb	r2, [r3, #0]
    buffer[pos++] = (uint8_t)(value >> 8);
 800f00c:	687b      	ldr	r3, [r7, #4]
 800f00e:	0a1a      	lsrs	r2, r3, #8
 800f010:	897b      	ldrh	r3, [r7, #10]
 800f012:	1c59      	adds	r1, r3, #1
 800f014:	8179      	strh	r1, [r7, #10]
 800f016:	4619      	mov	r1, r3
 800f018:	68fb      	ldr	r3, [r7, #12]
 800f01a:	440b      	add	r3, r1
 800f01c:	b2d2      	uxtb	r2, r2
 800f01e:	701a      	strb	r2, [r3, #0]
    buffer[pos++] = (uint8_t)(value);
 800f020:	897b      	ldrh	r3, [r7, #10]
 800f022:	1c5a      	adds	r2, r3, #1
 800f024:	817a      	strh	r2, [r7, #10]
 800f026:	461a      	mov	r2, r3
 800f028:	68fb      	ldr	r3, [r7, #12]
 800f02a:	4413      	add	r3, r2
 800f02c:	687a      	ldr	r2, [r7, #4]
 800f02e:	b2d2      	uxtb	r2, r2
 800f030:	701a      	strb	r2, [r3, #0]
}
 800f032:	bf00      	nop
 800f034:	3714      	adds	r7, #20
 800f036:	46bd      	mov	sp, r7
 800f038:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f03c:	4770      	bx	lr

0800f03e <reverse_bytes>:

// general swap/endianess utils
void reverse_bytes(const uint8_t *src, uint8_t *dst, int len){
 800f03e:	b480      	push	{r7}
 800f040:	b087      	sub	sp, #28
 800f042:	af00      	add	r7, sp, #0
 800f044:	60f8      	str	r0, [r7, #12]
 800f046:	60b9      	str	r1, [r7, #8]
 800f048:	607a      	str	r2, [r7, #4]
    int i;
    for (i = 0; i < len; i++)
 800f04a:	2300      	movs	r3, #0
 800f04c:	617b      	str	r3, [r7, #20]
 800f04e:	e00e      	b.n	800f06e <reverse_bytes+0x30>
        dst[len - 1 - i] = src[i];
 800f050:	697b      	ldr	r3, [r7, #20]
 800f052:	68fa      	ldr	r2, [r7, #12]
 800f054:	441a      	add	r2, r3
 800f056:	687b      	ldr	r3, [r7, #4]
 800f058:	1e59      	subs	r1, r3, #1
 800f05a:	697b      	ldr	r3, [r7, #20]
 800f05c:	1acb      	subs	r3, r1, r3
 800f05e:	4619      	mov	r1, r3
 800f060:	68bb      	ldr	r3, [r7, #8]
 800f062:	440b      	add	r3, r1
 800f064:	7812      	ldrb	r2, [r2, #0]
 800f066:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < len; i++)
 800f068:	697b      	ldr	r3, [r7, #20]
 800f06a:	3301      	adds	r3, #1
 800f06c:	617b      	str	r3, [r7, #20]
 800f06e:	697a      	ldr	r2, [r7, #20]
 800f070:	687b      	ldr	r3, [r7, #4]
 800f072:	429a      	cmp	r2, r3
 800f074:	dbec      	blt.n	800f050 <reverse_bytes+0x12>
}
 800f076:	bf00      	nop
 800f078:	371c      	adds	r7, #28
 800f07a:	46bd      	mov	sp, r7
 800f07c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f080:	4770      	bx	lr

0800f082 <reverse_56>:
    reverse_bytes(src, dst, 3);
}
void reverse_48(const uint8_t * src, uint8_t * dst){
    reverse_bytes(src, dst, 6);
}
void reverse_56(const uint8_t * src, uint8_t * dst){
 800f082:	b580      	push	{r7, lr}
 800f084:	b082      	sub	sp, #8
 800f086:	af00      	add	r7, sp, #0
 800f088:	6078      	str	r0, [r7, #4]
 800f08a:	6039      	str	r1, [r7, #0]
    reverse_bytes(src, dst, 7);
 800f08c:	2207      	movs	r2, #7
 800f08e:	6839      	ldr	r1, [r7, #0]
 800f090:	6878      	ldr	r0, [r7, #4]
 800f092:	f7ff ffd4 	bl	800f03e <reverse_bytes>
}
 800f096:	bf00      	nop
 800f098:	3708      	adds	r7, #8
 800f09a:	46bd      	mov	sp, r7
 800f09c:	bd80      	pop	{r7, pc}

0800f09e <reverse_64>:
void reverse_64(const uint8_t * src, uint8_t * dst){
 800f09e:	b580      	push	{r7, lr}
 800f0a0:	b082      	sub	sp, #8
 800f0a2:	af00      	add	r7, sp, #0
 800f0a4:	6078      	str	r0, [r7, #4]
 800f0a6:	6039      	str	r1, [r7, #0]
    reverse_bytes(src, dst, 8);
 800f0a8:	2208      	movs	r2, #8
 800f0aa:	6839      	ldr	r1, [r7, #0]
 800f0ac:	6878      	ldr	r0, [r7, #4]
 800f0ae:	f7ff ffc6 	bl	800f03e <reverse_bytes>
}
 800f0b2:	bf00      	nop
 800f0b4:	3708      	adds	r7, #8
 800f0b6:	46bd      	mov	sp, r7
 800f0b8:	bd80      	pop	{r7, pc}

0800f0ba <reverse_128>:
void reverse_128(const uint8_t * src, uint8_t * dst){
 800f0ba:	b580      	push	{r7, lr}
 800f0bc:	b082      	sub	sp, #8
 800f0be:	af00      	add	r7, sp, #0
 800f0c0:	6078      	str	r0, [r7, #4]
 800f0c2:	6039      	str	r1, [r7, #0]
    reverse_bytes(src, dst, 16);
 800f0c4:	2210      	movs	r2, #16
 800f0c6:	6839      	ldr	r1, [r7, #0]
 800f0c8:	6878      	ldr	r0, [r7, #4]
 800f0ca:	f7ff ffb8 	bl	800f03e <reverse_bytes>
}
 800f0ce:	bf00      	nop
 800f0d0:	3708      	adds	r7, #8
 800f0d2:	46bd      	mov	sp, r7
 800f0d4:	bd80      	pop	{r7, pc}

0800f0d6 <reverse_256>:
void reverse_256(const uint8_t * src, uint8_t * dst){
 800f0d6:	b580      	push	{r7, lr}
 800f0d8:	b082      	sub	sp, #8
 800f0da:	af00      	add	r7, sp, #0
 800f0dc:	6078      	str	r0, [r7, #4]
 800f0de:	6039      	str	r1, [r7, #0]
    reverse_bytes(src, dst, 32);
 800f0e0:	2220      	movs	r2, #32
 800f0e2:	6839      	ldr	r1, [r7, #0]
 800f0e4:	6878      	ldr	r0, [r7, #4]
 800f0e6:	f7ff ffaa 	bl	800f03e <reverse_bytes>
}
 800f0ea:	bf00      	nop
 800f0ec:	3708      	adds	r7, #8
 800f0ee:	46bd      	mov	sp, r7
 800f0f0:	bd80      	pop	{r7, pc}

0800f0f2 <reverse_bd_addr>:

void reverse_bd_addr(const bd_addr_t src, bd_addr_t dest){
 800f0f2:	b580      	push	{r7, lr}
 800f0f4:	b082      	sub	sp, #8
 800f0f6:	af00      	add	r7, sp, #0
 800f0f8:	6078      	str	r0, [r7, #4]
 800f0fa:	6039      	str	r1, [r7, #0]
    reverse_bytes(src, dest, 6);
 800f0fc:	2206      	movs	r2, #6
 800f0fe:	6839      	ldr	r1, [r7, #0]
 800f100:	6878      	ldr	r0, [r7, #4]
 800f102:	f7ff ff9c 	bl	800f03e <reverse_bytes>
}
 800f106:	bf00      	nop
 800f108:	3708      	adds	r7, #8
 800f10a:	46bd      	mov	sp, r7
 800f10c:	bd80      	pop	{r7, pc}

0800f10e <btstack_min>:

uint32_t btstack_min(uint32_t a, uint32_t b){
 800f10e:	b480      	push	{r7}
 800f110:	b083      	sub	sp, #12
 800f112:	af00      	add	r7, sp, #0
 800f114:	6078      	str	r0, [r7, #4]
 800f116:	6039      	str	r1, [r7, #0]
    return (a < b) ? a : b;
 800f118:	683a      	ldr	r2, [r7, #0]
 800f11a:	687b      	ldr	r3, [r7, #4]
 800f11c:	4293      	cmp	r3, r2
 800f11e:	bf28      	it	cs
 800f120:	4613      	movcs	r3, r2
}
 800f122:	4618      	mov	r0, r3
 800f124:	370c      	adds	r7, #12
 800f126:	46bd      	mov	sp, r7
 800f128:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f12c:	4770      	bx	lr

0800f12e <btstack_max>:

uint32_t btstack_max(uint32_t a, uint32_t b){
 800f12e:	b480      	push	{r7}
 800f130:	b083      	sub	sp, #12
 800f132:	af00      	add	r7, sp, #0
 800f134:	6078      	str	r0, [r7, #4]
 800f136:	6039      	str	r1, [r7, #0]
    return (a > b) ? a : b;
 800f138:	683a      	ldr	r2, [r7, #0]
 800f13a:	687b      	ldr	r3, [r7, #4]
 800f13c:	4293      	cmp	r3, r2
 800f13e:	bf38      	it	cc
 800f140:	4613      	movcc	r3, r2
}
 800f142:	4618      	mov	r0, r3
 800f144:	370c      	adds	r7, #12
 800f146:	46bd      	mov	sp, r7
 800f148:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f14c:	4770      	bx	lr

0800f14e <btstack_time_delta>:

/**
 * @brief Calculate delta between two points in time
 * @returns time_a - time_b - result > 0 if time_a is newer than time_b
 */
int32_t btstack_time_delta(uint32_t time_a, uint32_t time_b){
 800f14e:	b480      	push	{r7}
 800f150:	b083      	sub	sp, #12
 800f152:	af00      	add	r7, sp, #0
 800f154:	6078      	str	r0, [r7, #4]
 800f156:	6039      	str	r1, [r7, #0]
    return (int32_t)(time_a - time_b);
 800f158:	687a      	ldr	r2, [r7, #4]
 800f15a:	683b      	ldr	r3, [r7, #0]
 800f15c:	1ad3      	subs	r3, r2, r3
}
 800f15e:	4618      	mov	r0, r3
 800f160:	370c      	adds	r7, #12
 800f162:	46bd      	mov	sp, r7
 800f164:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f168:	4770      	bx	lr
	...

0800f16c <char_for_nibble>:


char char_for_nibble(int nibble){
 800f16c:	b480      	push	{r7}
 800f16e:	b083      	sub	sp, #12
 800f170:	af00      	add	r7, sp, #0
 800f172:	6078      	str	r0, [r7, #4]

    static const char * char_to_nibble = "0123456789ABCDEF";

    if (nibble < 16){
 800f174:	687b      	ldr	r3, [r7, #4]
 800f176:	2b0f      	cmp	r3, #15
 800f178:	dc05      	bgt.n	800f186 <char_for_nibble+0x1a>
        return char_to_nibble[nibble];
 800f17a:	4b06      	ldr	r3, [pc, #24]	; (800f194 <char_for_nibble+0x28>)
 800f17c:	681a      	ldr	r2, [r3, #0]
 800f17e:	687b      	ldr	r3, [r7, #4]
 800f180:	4413      	add	r3, r2
 800f182:	781b      	ldrb	r3, [r3, #0]
 800f184:	e000      	b.n	800f188 <char_for_nibble+0x1c>
    } else {
        return '?';
 800f186:	233f      	movs	r3, #63	; 0x3f
    }
}
 800f188:	4618      	mov	r0, r3
 800f18a:	370c      	adds	r7, #12
 800f18c:	46bd      	mov	sp, r7
 800f18e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f192:	4770      	bx	lr
 800f194:	20000024 	.word	0x20000024

0800f198 <char_for_high_nibble>:

static inline char char_for_high_nibble(int value){
 800f198:	b580      	push	{r7, lr}
 800f19a:	b082      	sub	sp, #8
 800f19c:	af00      	add	r7, sp, #0
 800f19e:	6078      	str	r0, [r7, #4]
    return char_for_nibble((value >> 4) & 0x0f);
 800f1a0:	687b      	ldr	r3, [r7, #4]
 800f1a2:	111b      	asrs	r3, r3, #4
 800f1a4:	f003 030f 	and.w	r3, r3, #15
 800f1a8:	4618      	mov	r0, r3
 800f1aa:	f7ff ffdf 	bl	800f16c <char_for_nibble>
 800f1ae:	4603      	mov	r3, r0
}
 800f1b0:	4618      	mov	r0, r3
 800f1b2:	3708      	adds	r7, #8
 800f1b4:	46bd      	mov	sp, r7
 800f1b6:	bd80      	pop	{r7, pc}

0800f1b8 <char_for_low_nibble>:

static inline char char_for_low_nibble(int value){
 800f1b8:	b580      	push	{r7, lr}
 800f1ba:	b082      	sub	sp, #8
 800f1bc:	af00      	add	r7, sp, #0
 800f1be:	6078      	str	r0, [r7, #4]
    return char_for_nibble(value & 0x0f);
 800f1c0:	687b      	ldr	r3, [r7, #4]
 800f1c2:	f003 030f 	and.w	r3, r3, #15
 800f1c6:	4618      	mov	r0, r3
 800f1c8:	f7ff ffd0 	bl	800f16c <char_for_nibble>
 800f1cc:	4603      	mov	r3, r0
}
 800f1ce:	4618      	mov	r0, r3
 800f1d0:	3708      	adds	r7, #8
 800f1d2:	46bd      	mov	sp, r7
 800f1d4:	bd80      	pop	{r7, pc}
	...

0800f1d8 <printf_hexdump>:
    if ((c >= 'A') && (c <= 'F')) return c - 'A' + 10;
    return -1;
}

#ifdef ENABLE_PRINTF_HEXDUMP
void printf_hexdump(const void *data, int size){
 800f1d8:	b580      	push	{r7, lr}
 800f1da:	b086      	sub	sp, #24
 800f1dc:	af00      	add	r7, sp, #0
 800f1de:	6078      	str	r0, [r7, #4]
 800f1e0:	6039      	str	r1, [r7, #0]
    char buffer[4];
    buffer[2] = ' ';
 800f1e2:	2320      	movs	r3, #32
 800f1e4:	73bb      	strb	r3, [r7, #14]
    buffer[3] =  0;
 800f1e6:	2300      	movs	r3, #0
 800f1e8:	73fb      	strb	r3, [r7, #15]
    const uint8_t * ptr = (const uint8_t *) data;
 800f1ea:	687b      	ldr	r3, [r7, #4]
 800f1ec:	617b      	str	r3, [r7, #20]
    while (size > 0){
 800f1ee:	e019      	b.n	800f224 <printf_hexdump+0x4c>
        uint8_t byte = *ptr++;
 800f1f0:	697b      	ldr	r3, [r7, #20]
 800f1f2:	1c5a      	adds	r2, r3, #1
 800f1f4:	617a      	str	r2, [r7, #20]
 800f1f6:	781b      	ldrb	r3, [r3, #0]
 800f1f8:	74fb      	strb	r3, [r7, #19]
        buffer[0] = char_for_high_nibble(byte);
 800f1fa:	7cfb      	ldrb	r3, [r7, #19]
 800f1fc:	4618      	mov	r0, r3
 800f1fe:	f7ff ffcb 	bl	800f198 <char_for_high_nibble>
 800f202:	4603      	mov	r3, r0
 800f204:	733b      	strb	r3, [r7, #12]
        buffer[1] = char_for_low_nibble(byte);
 800f206:	7cfb      	ldrb	r3, [r7, #19]
 800f208:	4618      	mov	r0, r3
 800f20a:	f7ff ffd5 	bl	800f1b8 <char_for_low_nibble>
 800f20e:	4603      	mov	r3, r0
 800f210:	737b      	strb	r3, [r7, #13]
        printf("%s", buffer);
 800f212:	f107 030c 	add.w	r3, r7, #12
 800f216:	4619      	mov	r1, r3
 800f218:	4807      	ldr	r0, [pc, #28]	; (800f238 <printf_hexdump+0x60>)
 800f21a:	f018 fc5b 	bl	8027ad4 <iprintf>
        size--;
 800f21e:	683b      	ldr	r3, [r7, #0]
 800f220:	3b01      	subs	r3, #1
 800f222:	603b      	str	r3, [r7, #0]
    while (size > 0){
 800f224:	683b      	ldr	r3, [r7, #0]
 800f226:	2b00      	cmp	r3, #0
 800f228:	dce2      	bgt.n	800f1f0 <printf_hexdump+0x18>
    }
    printf("\n");
 800f22a:	200a      	movs	r0, #10
 800f22c:	f018 fc6a 	bl	8027b04 <putchar>
}
 800f230:	bf00      	nop
 800f232:	3718      	adds	r7, #24
 800f234:	46bd      	mov	sp, r7
 800f236:	bd80      	pop	{r7, pc}
 800f238:	08029228 	.word	0x08029228

0800f23c <log_hexdump>:
#endif

#if defined(ENABLE_LOG_INFO) || defined(ENABLE_LOG_DEBUG)
static void log_hexdump(int level, const void * data, int size){
 800f23c:	b590      	push	{r4, r7, lr}
 800f23e:	b0a3      	sub	sp, #140	; 0x8c
 800f240:	af02      	add	r7, sp, #8
 800f242:	60f8      	str	r0, [r7, #12]
 800f244:	60b9      	str	r1, [r7, #8]
 800f246:	607a      	str	r2, [r7, #4]
#define ITEMS_PER_LINE 16
// template '0x12, '
#define BYTES_PER_BYTE  6
    char buffer[BYTES_PER_BYTE*ITEMS_PER_LINE+1];
    int i, j;
    j = 0;
 800f248:	2300      	movs	r3, #0
 800f24a:	67bb      	str	r3, [r7, #120]	; 0x78
    for (i=0; i<size;i++){
 800f24c:	2300      	movs	r3, #0
 800f24e:	67fb      	str	r3, [r7, #124]	; 0x7c
 800f250:	e063      	b.n	800f31a <log_hexdump+0xde>

        // help static analyzer proof that j stays within bounds
        if (j > (BYTES_PER_BYTE * (ITEMS_PER_LINE-1))){
 800f252:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f254:	2b5a      	cmp	r3, #90	; 0x5a
 800f256:	dd01      	ble.n	800f25c <log_hexdump+0x20>
            j = 0;
 800f258:	2300      	movs	r3, #0
 800f25a:	67bb      	str	r3, [r7, #120]	; 0x78
        }

        uint8_t byte = ((uint8_t *)data)[i];
 800f25c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800f25e:	68ba      	ldr	r2, [r7, #8]
 800f260:	4413      	add	r3, r2
 800f262:	781b      	ldrb	r3, [r3, #0]
 800f264:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
        buffer[j++] = '0';
 800f268:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f26a:	1c5a      	adds	r2, r3, #1
 800f26c:	67ba      	str	r2, [r7, #120]	; 0x78
 800f26e:	f107 0280 	add.w	r2, r7, #128	; 0x80
 800f272:	4413      	add	r3, r2
 800f274:	2230      	movs	r2, #48	; 0x30
 800f276:	f803 2c6c 	strb.w	r2, [r3, #-108]
        buffer[j++] = 'x';
 800f27a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f27c:	1c5a      	adds	r2, r3, #1
 800f27e:	67ba      	str	r2, [r7, #120]	; 0x78
 800f280:	f107 0280 	add.w	r2, r7, #128	; 0x80
 800f284:	4413      	add	r3, r2
 800f286:	2278      	movs	r2, #120	; 0x78
 800f288:	f803 2c6c 	strb.w	r2, [r3, #-108]
        buffer[j++] = char_for_high_nibble(byte);
 800f28c:	f897 2077 	ldrb.w	r2, [r7, #119]	; 0x77
 800f290:	6fbc      	ldr	r4, [r7, #120]	; 0x78
 800f292:	1c63      	adds	r3, r4, #1
 800f294:	67bb      	str	r3, [r7, #120]	; 0x78
 800f296:	4610      	mov	r0, r2
 800f298:	f7ff ff7e 	bl	800f198 <char_for_high_nibble>
 800f29c:	4603      	mov	r3, r0
 800f29e:	461a      	mov	r2, r3
 800f2a0:	f107 0380 	add.w	r3, r7, #128	; 0x80
 800f2a4:	4423      	add	r3, r4
 800f2a6:	f803 2c6c 	strb.w	r2, [r3, #-108]
        buffer[j++] = char_for_low_nibble(byte);
 800f2aa:	f897 2077 	ldrb.w	r2, [r7, #119]	; 0x77
 800f2ae:	6fbc      	ldr	r4, [r7, #120]	; 0x78
 800f2b0:	1c63      	adds	r3, r4, #1
 800f2b2:	67bb      	str	r3, [r7, #120]	; 0x78
 800f2b4:	4610      	mov	r0, r2
 800f2b6:	f7ff ff7f 	bl	800f1b8 <char_for_low_nibble>
 800f2ba:	4603      	mov	r3, r0
 800f2bc:	461a      	mov	r2, r3
 800f2be:	f107 0380 	add.w	r3, r7, #128	; 0x80
 800f2c2:	4423      	add	r3, r4
 800f2c4:	f803 2c6c 	strb.w	r2, [r3, #-108]
        buffer[j++] = ',';
 800f2c8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f2ca:	1c5a      	adds	r2, r3, #1
 800f2cc:	67ba      	str	r2, [r7, #120]	; 0x78
 800f2ce:	f107 0280 	add.w	r2, r7, #128	; 0x80
 800f2d2:	4413      	add	r3, r2
 800f2d4:	222c      	movs	r2, #44	; 0x2c
 800f2d6:	f803 2c6c 	strb.w	r2, [r3, #-108]
        buffer[j++] = ' ';     
 800f2da:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f2dc:	1c5a      	adds	r2, r3, #1
 800f2de:	67ba      	str	r2, [r7, #120]	; 0x78
 800f2e0:	f107 0280 	add.w	r2, r7, #128	; 0x80
 800f2e4:	4413      	add	r3, r2
 800f2e6:	2220      	movs	r2, #32
 800f2e8:	f803 2c6c 	strb.w	r2, [r3, #-108]

        if (j >= (BYTES_PER_BYTE * ITEMS_PER_LINE) ){
 800f2ec:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f2ee:	2b5f      	cmp	r3, #95	; 0x5f
 800f2f0:	dd10      	ble.n	800f314 <log_hexdump+0xd8>
            buffer[j] = 0;
 800f2f2:	f107 0214 	add.w	r2, r7, #20
 800f2f6:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f2f8:	4413      	add	r3, r2
 800f2fa:	2200      	movs	r2, #0
 800f2fc:	701a      	strb	r2, [r3, #0]
            HCI_DUMP_LOG(level, "%s", buffer);
 800f2fe:	f107 0314 	add.w	r3, r7, #20
 800f302:	9300      	str	r3, [sp, #0]
 800f304:	23fa      	movs	r3, #250	; 0xfa
 800f306:	4a12      	ldr	r2, [pc, #72]	; (800f350 <log_hexdump+0x114>)
 800f308:	4912      	ldr	r1, [pc, #72]	; (800f354 <log_hexdump+0x118>)
 800f30a:	68f8      	ldr	r0, [r7, #12]
 800f30c:	f008 f898 	bl	8017440 <hci_dump_log>
            j = 0;
 800f310:	2300      	movs	r3, #0
 800f312:	67bb      	str	r3, [r7, #120]	; 0x78
    for (i=0; i<size;i++){
 800f314:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800f316:	3301      	adds	r3, #1
 800f318:	67fb      	str	r3, [r7, #124]	; 0x7c
 800f31a:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800f31c:	687b      	ldr	r3, [r7, #4]
 800f31e:	429a      	cmp	r2, r3
 800f320:	db97      	blt.n	800f252 <log_hexdump+0x16>
        }
    }
    if (j != 0){
 800f322:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f324:	2b00      	cmp	r3, #0
 800f326:	d00f      	beq.n	800f348 <log_hexdump+0x10c>
        buffer[j] = 0;
 800f328:	f107 0214 	add.w	r2, r7, #20
 800f32c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f32e:	4413      	add	r3, r2
 800f330:	2200      	movs	r2, #0
 800f332:	701a      	strb	r2, [r3, #0]
        HCI_DUMP_LOG(level, "%s", buffer);
 800f334:	f107 0314 	add.w	r3, r7, #20
 800f338:	9300      	str	r3, [sp, #0]
 800f33a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800f33e:	4a04      	ldr	r2, [pc, #16]	; (800f350 <log_hexdump+0x114>)
 800f340:	4904      	ldr	r1, [pc, #16]	; (800f354 <log_hexdump+0x118>)
 800f342:	68f8      	ldr	r0, [r7, #12]
 800f344:	f008 f87c 	bl	8017440 <hci_dump_log>
    }
}
 800f348:	bf00      	nop
 800f34a:	3784      	adds	r7, #132	; 0x84
 800f34c:	46bd      	mov	sp, r7
 800f34e:	bd90      	pop	{r4, r7, pc}
 800f350:	0802922c 	.word	0x0802922c
 800f354:	0802923c 	.word	0x0802923c

0800f358 <log_info_hexdump>:
    UNUSED(data);   // ok: no code
    UNUSED(size);   // ok: no code
#endif
}

void log_info_hexdump(const void *data, int size){
 800f358:	b580      	push	{r7, lr}
 800f35a:	b082      	sub	sp, #8
 800f35c:	af00      	add	r7, sp, #0
 800f35e:	6078      	str	r0, [r7, #4]
 800f360:	6039      	str	r1, [r7, #0]
#ifdef ENABLE_LOG_INFO
    log_hexdump(HCI_DUMP_LOG_LEVEL_INFO, data, size);
 800f362:	683a      	ldr	r2, [r7, #0]
 800f364:	6879      	ldr	r1, [r7, #4]
 800f366:	2001      	movs	r0, #1
 800f368:	f7ff ff68 	bl	800f23c <log_hexdump>
#else
    UNUSED(data);   // ok: no code
    UNUSED(size);   // ok: no code
#endif
}
 800f36c:	bf00      	nop
 800f36e:	3708      	adds	r7, #8
 800f370:	46bd      	mov	sp, r7
 800f372:	bd80      	pop	{r7, pc}

0800f374 <log_info_key>:

void log_info_key(const char * name, sm_key_t key){
 800f374:	b590      	push	{r4, r7, lr}
 800f376:	b091      	sub	sp, #68	; 0x44
 800f378:	af02      	add	r7, sp, #8
 800f37a:	6078      	str	r0, [r7, #4]
 800f37c:	6039      	str	r1, [r7, #0]
#ifdef ENABLE_LOG_INFO
    char buffer[16*2+1];
    int i;
    int j = 0;
 800f37e:	2300      	movs	r3, #0
 800f380:	633b      	str	r3, [r7, #48]	; 0x30
    for (i=0; i<16;i++){
 800f382:	2300      	movs	r3, #0
 800f384:	637b      	str	r3, [r7, #52]	; 0x34
 800f386:	e026      	b.n	800f3d6 <log_info_key+0x62>
        uint8_t byte = key[i];
 800f388:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f38a:	683a      	ldr	r2, [r7, #0]
 800f38c:	4413      	add	r3, r2
 800f38e:	781b      	ldrb	r3, [r3, #0]
 800f390:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        buffer[j++] = char_for_high_nibble(byte);
 800f394:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 800f398:	6b3c      	ldr	r4, [r7, #48]	; 0x30
 800f39a:	1c63      	adds	r3, r4, #1
 800f39c:	633b      	str	r3, [r7, #48]	; 0x30
 800f39e:	4610      	mov	r0, r2
 800f3a0:	f7ff fefa 	bl	800f198 <char_for_high_nibble>
 800f3a4:	4603      	mov	r3, r0
 800f3a6:	461a      	mov	r2, r3
 800f3a8:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800f3ac:	4423      	add	r3, r4
 800f3ae:	f803 2c2c 	strb.w	r2, [r3, #-44]
        buffer[j++] = char_for_low_nibble(byte);
 800f3b2:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 800f3b6:	6b3c      	ldr	r4, [r7, #48]	; 0x30
 800f3b8:	1c63      	adds	r3, r4, #1
 800f3ba:	633b      	str	r3, [r7, #48]	; 0x30
 800f3bc:	4610      	mov	r0, r2
 800f3be:	f7ff fefb 	bl	800f1b8 <char_for_low_nibble>
 800f3c2:	4603      	mov	r3, r0
 800f3c4:	461a      	mov	r2, r3
 800f3c6:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800f3ca:	4423      	add	r3, r4
 800f3cc:	f803 2c2c 	strb.w	r2, [r3, #-44]
    for (i=0; i<16;i++){
 800f3d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f3d2:	3301      	adds	r3, #1
 800f3d4:	637b      	str	r3, [r7, #52]	; 0x34
 800f3d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f3d8:	2b0f      	cmp	r3, #15
 800f3da:	ddd5      	ble.n	800f388 <log_info_key+0x14>
    }
    buffer[j] = 0;
 800f3dc:	f107 020c 	add.w	r2, r7, #12
 800f3e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f3e2:	4413      	add	r3, r2
 800f3e4:	2200      	movs	r2, #0
 800f3e6:	701a      	strb	r2, [r3, #0]
    log_info("%-6s %s", name, buffer);
 800f3e8:	f107 030c 	add.w	r3, r7, #12
 800f3ec:	9301      	str	r3, [sp, #4]
 800f3ee:	687b      	ldr	r3, [r7, #4]
 800f3f0:	9300      	str	r3, [sp, #0]
 800f3f2:	f44f 7391 	mov.w	r3, #290	; 0x122
 800f3f6:	4a04      	ldr	r2, [pc, #16]	; (800f408 <log_info_key+0x94>)
 800f3f8:	4904      	ldr	r1, [pc, #16]	; (800f40c <log_info_key+0x98>)
 800f3fa:	2001      	movs	r0, #1
 800f3fc:	f008 f820 	bl	8017440 <hci_dump_log>
#else
    UNUSED(name);
    (void)key;
#endif
}
 800f400:	bf00      	nop
 800f402:	373c      	adds	r7, #60	; 0x3c
 800f404:	46bd      	mov	sp, r7
 800f406:	bd90      	pop	{r4, r7, pc}
 800f408:	0802922c 	.word	0x0802922c
 800f40c:	08029248 	.word	0x08029248

0800f410 <bd_addr_to_str>:
    }
    return uuid128_to_str_buffer;
}

static char bd_addr_to_str_buffer[6*3];  // 12:45:78:01:34:67\0
char * bd_addr_to_str(const bd_addr_t addr){
 800f410:	b590      	push	{r4, r7, lr}
 800f412:	b087      	sub	sp, #28
 800f414:	af00      	add	r7, sp, #0
 800f416:	6078      	str	r0, [r7, #4]
    char * p = bd_addr_to_str_buffer;
 800f418:	4b18      	ldr	r3, [pc, #96]	; (800f47c <bd_addr_to_str+0x6c>)
 800f41a:	617b      	str	r3, [r7, #20]
    int i;
    for (i = 0; i < 6 ; i++) {
 800f41c:	2300      	movs	r3, #0
 800f41e:	613b      	str	r3, [r7, #16]
 800f420:	e01e      	b.n	800f460 <bd_addr_to_str+0x50>
        uint8_t byte = addr[i];
 800f422:	693b      	ldr	r3, [r7, #16]
 800f424:	687a      	ldr	r2, [r7, #4]
 800f426:	4413      	add	r3, r2
 800f428:	781b      	ldrb	r3, [r3, #0]
 800f42a:	73fb      	strb	r3, [r7, #15]
        *p++ = char_for_high_nibble(byte);
 800f42c:	7bfa      	ldrb	r2, [r7, #15]
 800f42e:	697c      	ldr	r4, [r7, #20]
 800f430:	1c63      	adds	r3, r4, #1
 800f432:	617b      	str	r3, [r7, #20]
 800f434:	4610      	mov	r0, r2
 800f436:	f7ff feaf 	bl	800f198 <char_for_high_nibble>
 800f43a:	4603      	mov	r3, r0
 800f43c:	7023      	strb	r3, [r4, #0]
        *p++ = char_for_low_nibble(byte);
 800f43e:	7bfa      	ldrb	r2, [r7, #15]
 800f440:	697c      	ldr	r4, [r7, #20]
 800f442:	1c63      	adds	r3, r4, #1
 800f444:	617b      	str	r3, [r7, #20]
 800f446:	4610      	mov	r0, r2
 800f448:	f7ff feb6 	bl	800f1b8 <char_for_low_nibble>
 800f44c:	4603      	mov	r3, r0
 800f44e:	7023      	strb	r3, [r4, #0]
        *p++ = ':';
 800f450:	697b      	ldr	r3, [r7, #20]
 800f452:	1c5a      	adds	r2, r3, #1
 800f454:	617a      	str	r2, [r7, #20]
 800f456:	223a      	movs	r2, #58	; 0x3a
 800f458:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < 6 ; i++) {
 800f45a:	693b      	ldr	r3, [r7, #16]
 800f45c:	3301      	adds	r3, #1
 800f45e:	613b      	str	r3, [r7, #16]
 800f460:	693b      	ldr	r3, [r7, #16]
 800f462:	2b05      	cmp	r3, #5
 800f464:	dddd      	ble.n	800f422 <bd_addr_to_str+0x12>
    }
    *--p = 0;
 800f466:	697b      	ldr	r3, [r7, #20]
 800f468:	3b01      	subs	r3, #1
 800f46a:	617b      	str	r3, [r7, #20]
 800f46c:	697b      	ldr	r3, [r7, #20]
 800f46e:	2200      	movs	r2, #0
 800f470:	701a      	strb	r2, [r3, #0]
    return (char *) bd_addr_to_str_buffer;
 800f472:	4b02      	ldr	r3, [pc, #8]	; (800f47c <bd_addr_to_str+0x6c>)
}
 800f474:	4618      	mov	r0, r3
 800f476:	371c      	adds	r7, #28
 800f478:	46bd      	mov	sp, r7
 800f47a:	bd90      	pop	{r4, r7, pc}
 800f47c:	20008fa8 	.word	0x20008fa8

0800f480 <btstack_replace_bd_addr_placeholder>:

void btstack_replace_bd_addr_placeholder(uint8_t * buffer, uint16_t size, const bd_addr_t address){
 800f480:	b590      	push	{r4, r7, lr}
 800f482:	b087      	sub	sp, #28
 800f484:	af00      	add	r7, sp, #0
 800f486:	60f8      	str	r0, [r7, #12]
 800f488:	460b      	mov	r3, r1
 800f48a:	607a      	str	r2, [r7, #4]
 800f48c:	817b      	strh	r3, [r7, #10]
    const int bd_addr_string_len = 17;
 800f48e:	2311      	movs	r3, #17
 800f490:	613b      	str	r3, [r7, #16]
    uint16_t i = 0;
 800f492:	2300      	movs	r3, #0
 800f494:	82fb      	strh	r3, [r7, #22]
    while ((i + bd_addr_string_len) <= size){
 800f496:	e01f      	b.n	800f4d8 <btstack_replace_bd_addr_placeholder+0x58>
        if (memcmp(&buffer[i], "00:00:00:00:00:00", bd_addr_string_len)) {
 800f498:	8afb      	ldrh	r3, [r7, #22]
 800f49a:	68fa      	ldr	r2, [r7, #12]
 800f49c:	4413      	add	r3, r2
 800f49e:	693a      	ldr	r2, [r7, #16]
 800f4a0:	4912      	ldr	r1, [pc, #72]	; (800f4ec <btstack_replace_bd_addr_placeholder+0x6c>)
 800f4a2:	4618      	mov	r0, r3
 800f4a4:	f018 fada 	bl	8027a5c <memcmp>
 800f4a8:	4603      	mov	r3, r0
 800f4aa:	2b00      	cmp	r3, #0
 800f4ac:	d003      	beq.n	800f4b6 <btstack_replace_bd_addr_placeholder+0x36>
            i++;
 800f4ae:	8afb      	ldrh	r3, [r7, #22]
 800f4b0:	3301      	adds	r3, #1
 800f4b2:	82fb      	strh	r3, [r7, #22]
            continue;
 800f4b4:	e010      	b.n	800f4d8 <btstack_replace_bd_addr_placeholder+0x58>
        }
        // set address
        (void)memcpy(&buffer[i], bd_addr_to_str(address), bd_addr_string_len);
 800f4b6:	8afb      	ldrh	r3, [r7, #22]
 800f4b8:	68fa      	ldr	r2, [r7, #12]
 800f4ba:	18d4      	adds	r4, r2, r3
 800f4bc:	6878      	ldr	r0, [r7, #4]
 800f4be:	f7ff ffa7 	bl	800f410 <bd_addr_to_str>
 800f4c2:	4601      	mov	r1, r0
 800f4c4:	693b      	ldr	r3, [r7, #16]
 800f4c6:	461a      	mov	r2, r3
 800f4c8:	4620      	mov	r0, r4
 800f4ca:	f018 fad6 	bl	8027a7a <memcpy>
        i += bd_addr_string_len;
 800f4ce:	693b      	ldr	r3, [r7, #16]
 800f4d0:	b29a      	uxth	r2, r3
 800f4d2:	8afb      	ldrh	r3, [r7, #22]
 800f4d4:	4413      	add	r3, r2
 800f4d6:	82fb      	strh	r3, [r7, #22]
    while ((i + bd_addr_string_len) <= size){
 800f4d8:	8afa      	ldrh	r2, [r7, #22]
 800f4da:	693b      	ldr	r3, [r7, #16]
 800f4dc:	441a      	add	r2, r3
 800f4de:	897b      	ldrh	r3, [r7, #10]
 800f4e0:	429a      	cmp	r2, r3
 800f4e2:	ddd9      	ble.n	800f498 <btstack_replace_bd_addr_placeholder+0x18>
    }
}
 800f4e4:	bf00      	nop
 800f4e6:	371c      	adds	r7, #28
 800f4e8:	46bd      	mov	sp, r7
 800f4ea:	bd90      	pop	{r4, r7, pc}
 800f4ec:	08029258 	.word	0x08029258

0800f4f0 <hci_event_packet_get_type>:
static inline uint8_t hci_event_packet_get_type(const uint8_t * event){
 800f4f0:	b480      	push	{r7}
 800f4f2:	b083      	sub	sp, #12
 800f4f4:	af00      	add	r7, sp, #0
 800f4f6:	6078      	str	r0, [r7, #4]
    return event[0];
 800f4f8:	687b      	ldr	r3, [r7, #4]
 800f4fa:	781b      	ldrb	r3, [r3, #0]
}
 800f4fc:	4618      	mov	r0, r3
 800f4fe:	370c      	adds	r7, #12
 800f500:	46bd      	mov	sp, r7
 800f502:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f506:	4770      	bx	lr

0800f508 <hci_event_inquiry_result_get_num_responses>:
static inline uint8_t hci_event_inquiry_result_get_num_responses(const uint8_t * event){
 800f508:	b480      	push	{r7}
 800f50a:	b083      	sub	sp, #12
 800f50c:	af00      	add	r7, sp, #0
 800f50e:	6078      	str	r0, [r7, #4]
    return event[2];
 800f510:	687b      	ldr	r3, [r7, #4]
 800f512:	3302      	adds	r3, #2
 800f514:	781b      	ldrb	r3, [r3, #0]
}
 800f516:	4618      	mov	r0, r3
 800f518:	370c      	adds	r7, #12
 800f51a:	46bd      	mov	sp, r7
 800f51c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f520:	4770      	bx	lr

0800f522 <hci_event_authentication_complete_get_status>:
static inline uint8_t hci_event_authentication_complete_get_status(const uint8_t * event){
 800f522:	b480      	push	{r7}
 800f524:	b083      	sub	sp, #12
 800f526:	af00      	add	r7, sp, #0
 800f528:	6078      	str	r0, [r7, #4]
    return event[2];
 800f52a:	687b      	ldr	r3, [r7, #4]
 800f52c:	3302      	adds	r3, #2
 800f52e:	781b      	ldrb	r3, [r3, #0]
}
 800f530:	4618      	mov	r0, r3
 800f532:	370c      	adds	r7, #12
 800f534:	46bd      	mov	sp, r7
 800f536:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f53a:	4770      	bx	lr

0800f53c <hci_event_authentication_complete_get_connection_handle>:
static inline uint16_t hci_event_authentication_complete_get_connection_handle(const uint8_t * event){
 800f53c:	b580      	push	{r7, lr}
 800f53e:	b082      	sub	sp, #8
 800f540:	af00      	add	r7, sp, #0
 800f542:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 3);
 800f544:	2103      	movs	r1, #3
 800f546:	6878      	ldr	r0, [r7, #4]
 800f548:	f7ff fc4d 	bl	800ede6 <little_endian_read_16>
 800f54c:	4603      	mov	r3, r0
}
 800f54e:	4618      	mov	r0, r3
 800f550:	3708      	adds	r7, #8
 800f552:	46bd      	mov	sp, r7
 800f554:	bd80      	pop	{r7, pc}

0800f556 <hci_event_encryption_change_get_status>:
static inline uint8_t hci_event_encryption_change_get_status(const uint8_t * event){
 800f556:	b480      	push	{r7}
 800f558:	b083      	sub	sp, #12
 800f55a:	af00      	add	r7, sp, #0
 800f55c:	6078      	str	r0, [r7, #4]
    return event[2];
 800f55e:	687b      	ldr	r3, [r7, #4]
 800f560:	3302      	adds	r3, #2
 800f562:	781b      	ldrb	r3, [r3, #0]
}
 800f564:	4618      	mov	r0, r3
 800f566:	370c      	adds	r7, #12
 800f568:	46bd      	mov	sp, r7
 800f56a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f56e:	4770      	bx	lr

0800f570 <hci_event_encryption_change_get_connection_handle>:
static inline uint16_t hci_event_encryption_change_get_connection_handle(const uint8_t * event){
 800f570:	b580      	push	{r7, lr}
 800f572:	b082      	sub	sp, #8
 800f574:	af00      	add	r7, sp, #0
 800f576:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 3);
 800f578:	2103      	movs	r1, #3
 800f57a:	6878      	ldr	r0, [r7, #4]
 800f57c:	f7ff fc33 	bl	800ede6 <little_endian_read_16>
 800f580:	4603      	mov	r3, r0
}
 800f582:	4618      	mov	r0, r3
 800f584:	3708      	adds	r7, #8
 800f586:	46bd      	mov	sp, r7
 800f588:	bd80      	pop	{r7, pc}

0800f58a <hci_event_encryption_change_get_encryption_enabled>:
static inline uint8_t hci_event_encryption_change_get_encryption_enabled(const uint8_t * event){
 800f58a:	b480      	push	{r7}
 800f58c:	b083      	sub	sp, #12
 800f58e:	af00      	add	r7, sp, #0
 800f590:	6078      	str	r0, [r7, #4]
    return event[5];
 800f592:	687b      	ldr	r3, [r7, #4]
 800f594:	3305      	adds	r3, #5
 800f596:	781b      	ldrb	r3, [r3, #0]
}
 800f598:	4618      	mov	r0, r3
 800f59a:	370c      	adds	r7, #12
 800f59c:	46bd      	mov	sp, r7
 800f59e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f5a2:	4770      	bx	lr

0800f5a4 <hci_event_command_complete_get_command_opcode>:
static inline uint16_t hci_event_command_complete_get_command_opcode(const uint8_t * event){
 800f5a4:	b580      	push	{r7, lr}
 800f5a6:	b082      	sub	sp, #8
 800f5a8:	af00      	add	r7, sp, #0
 800f5aa:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 3);
 800f5ac:	2103      	movs	r1, #3
 800f5ae:	6878      	ldr	r0, [r7, #4]
 800f5b0:	f7ff fc19 	bl	800ede6 <little_endian_read_16>
 800f5b4:	4603      	mov	r3, r0
}
 800f5b6:	4618      	mov	r0, r3
 800f5b8:	3708      	adds	r7, #8
 800f5ba:	46bd      	mov	sp, r7
 800f5bc:	bd80      	pop	{r7, pc}

0800f5be <hci_event_command_status_get_status>:
static inline uint8_t hci_event_command_status_get_status(const uint8_t * event){
 800f5be:	b480      	push	{r7}
 800f5c0:	b083      	sub	sp, #12
 800f5c2:	af00      	add	r7, sp, #0
 800f5c4:	6078      	str	r0, [r7, #4]
    return event[2];
 800f5c6:	687b      	ldr	r3, [r7, #4]
 800f5c8:	3302      	adds	r3, #2
 800f5ca:	781b      	ldrb	r3, [r3, #0]
}
 800f5cc:	4618      	mov	r0, r3
 800f5ce:	370c      	adds	r7, #12
 800f5d0:	46bd      	mov	sp, r7
 800f5d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f5d6:	4770      	bx	lr

0800f5d8 <hci_event_mode_change_get_handle>:
static inline hci_con_handle_t hci_event_mode_change_get_handle(const uint8_t * event){
 800f5d8:	b580      	push	{r7, lr}
 800f5da:	b082      	sub	sp, #8
 800f5dc:	af00      	add	r7, sp, #0
 800f5de:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 3);
 800f5e0:	2103      	movs	r1, #3
 800f5e2:	6878      	ldr	r0, [r7, #4]
 800f5e4:	f7ff fbff 	bl	800ede6 <little_endian_read_16>
 800f5e8:	4603      	mov	r3, r0
}
 800f5ea:	4618      	mov	r0, r3
 800f5ec:	3708      	adds	r7, #8
 800f5ee:	46bd      	mov	sp, r7
 800f5f0:	bd80      	pop	{r7, pc}

0800f5f2 <hci_event_mode_change_get_mode>:
static inline uint8_t hci_event_mode_change_get_mode(const uint8_t * event){
 800f5f2:	b480      	push	{r7}
 800f5f4:	b083      	sub	sp, #12
 800f5f6:	af00      	add	r7, sp, #0
 800f5f8:	6078      	str	r0, [r7, #4]
    return event[5];
 800f5fa:	687b      	ldr	r3, [r7, #4]
 800f5fc:	3305      	adds	r3, #5
 800f5fe:	781b      	ldrb	r3, [r3, #0]
}
 800f600:	4618      	mov	r0, r3
 800f602:	370c      	adds	r7, #12
 800f604:	46bd      	mov	sp, r7
 800f606:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f60a:	4770      	bx	lr

0800f60c <hci_event_pin_code_request_get_bd_addr>:
static inline void hci_event_pin_code_request_get_bd_addr(const uint8_t * event, bd_addr_t bd_addr){
 800f60c:	b580      	push	{r7, lr}
 800f60e:	b082      	sub	sp, #8
 800f610:	af00      	add	r7, sp, #0
 800f612:	6078      	str	r0, [r7, #4]
 800f614:	6039      	str	r1, [r7, #0]
    reverse_bytes(&event[2], bd_addr, 6);
 800f616:	687b      	ldr	r3, [r7, #4]
 800f618:	3302      	adds	r3, #2
 800f61a:	2206      	movs	r2, #6
 800f61c:	6839      	ldr	r1, [r7, #0]
 800f61e:	4618      	mov	r0, r3
 800f620:	f7ff fd0d 	bl	800f03e <reverse_bytes>
}
 800f624:	bf00      	nop
 800f626:	3708      	adds	r7, #8
 800f628:	46bd      	mov	sp, r7
 800f62a:	bd80      	pop	{r7, pc}

0800f62c <hci_subevent_le_connection_complete_get_connection_handle>:
static inline hci_con_handle_t hci_subevent_le_connection_complete_get_connection_handle(const uint8_t * event){
 800f62c:	b580      	push	{r7, lr}
 800f62e:	b082      	sub	sp, #8
 800f630:	af00      	add	r7, sp, #0
 800f632:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 4);
 800f634:	2104      	movs	r1, #4
 800f636:	6878      	ldr	r0, [r7, #4]
 800f638:	f7ff fbd5 	bl	800ede6 <little_endian_read_16>
 800f63c:	4603      	mov	r3, r0
}
 800f63e:	4618      	mov	r0, r3
 800f640:	3708      	adds	r7, #8
 800f642:	46bd      	mov	sp, r7
 800f644:	bd80      	pop	{r7, pc}

0800f646 <hci_subevent_le_connection_complete_get_conn_interval>:
static inline uint16_t hci_subevent_le_connection_complete_get_conn_interval(const uint8_t * event){
 800f646:	b580      	push	{r7, lr}
 800f648:	b082      	sub	sp, #8
 800f64a:	af00      	add	r7, sp, #0
 800f64c:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 14);
 800f64e:	210e      	movs	r1, #14
 800f650:	6878      	ldr	r0, [r7, #4]
 800f652:	f7ff fbc8 	bl	800ede6 <little_endian_read_16>
 800f656:	4603      	mov	r3, r0
}
 800f658:	4618      	mov	r0, r3
 800f65a:	3708      	adds	r7, #8
 800f65c:	46bd      	mov	sp, r7
 800f65e:	bd80      	pop	{r7, pc}

0800f660 <hci_subevent_le_connection_update_complete_get_connection_handle>:
static inline hci_con_handle_t hci_subevent_le_connection_update_complete_get_connection_handle(const uint8_t * event){
 800f660:	b580      	push	{r7, lr}
 800f662:	b082      	sub	sp, #8
 800f664:	af00      	add	r7, sp, #0
 800f666:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 4);
 800f668:	2104      	movs	r1, #4
 800f66a:	6878      	ldr	r0, [r7, #4]
 800f66c:	f7ff fbbb 	bl	800ede6 <little_endian_read_16>
 800f670:	4603      	mov	r3, r0
}
 800f672:	4618      	mov	r0, r3
 800f674:	3708      	adds	r7, #8
 800f676:	46bd      	mov	sp, r7
 800f678:	bd80      	pop	{r7, pc}

0800f67a <hci_subevent_le_connection_update_complete_get_conn_interval>:
static inline uint16_t hci_subevent_le_connection_update_complete_get_conn_interval(const uint8_t * event){
 800f67a:	b580      	push	{r7, lr}
 800f67c:	b082      	sub	sp, #8
 800f67e:	af00      	add	r7, sp, #0
 800f680:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 6);
 800f682:	2106      	movs	r1, #6
 800f684:	6878      	ldr	r0, [r7, #4]
 800f686:	f7ff fbae 	bl	800ede6 <little_endian_read_16>
 800f68a:	4603      	mov	r3, r0
}
 800f68c:	4618      	mov	r0, r3
 800f68e:	3708      	adds	r7, #8
 800f690:	46bd      	mov	sp, r7
 800f692:	bd80      	pop	{r7, pc}

0800f694 <hci_subevent_le_remote_connection_parameter_request_get_connection_handle>:
 * @brief Get field connection_handle from event HCI_SUBEVENT_LE_REMOTE_CONNECTION_PARAMETER_REQUEST
 * @param event packet
 * @return connection_handle
 * @note: btstack_type H
 */
static inline hci_con_handle_t hci_subevent_le_remote_connection_parameter_request_get_connection_handle(const uint8_t * event){
 800f694:	b580      	push	{r7, lr}
 800f696:	b082      	sub	sp, #8
 800f698:	af00      	add	r7, sp, #0
 800f69a:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 3);
 800f69c:	2103      	movs	r1, #3
 800f69e:	6878      	ldr	r0, [r7, #4]
 800f6a0:	f7ff fba1 	bl	800ede6 <little_endian_read_16>
 800f6a4:	4603      	mov	r3, r0
}
 800f6a6:	4618      	mov	r0, r3
 800f6a8:	3708      	adds	r7, #8
 800f6aa:	46bd      	mov	sp, r7
 800f6ac:	bd80      	pop	{r7, pc}

0800f6ae <hci_subevent_le_remote_connection_parameter_request_get_interval_min>:
 * @brief Get field interval_min from event HCI_SUBEVENT_LE_REMOTE_CONNECTION_PARAMETER_REQUEST
 * @param event packet
 * @return interval_min
 * @note: btstack_type 2
 */
static inline uint16_t hci_subevent_le_remote_connection_parameter_request_get_interval_min(const uint8_t * event){
 800f6ae:	b580      	push	{r7, lr}
 800f6b0:	b082      	sub	sp, #8
 800f6b2:	af00      	add	r7, sp, #0
 800f6b4:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 5);
 800f6b6:	2105      	movs	r1, #5
 800f6b8:	6878      	ldr	r0, [r7, #4]
 800f6ba:	f7ff fb94 	bl	800ede6 <little_endian_read_16>
 800f6be:	4603      	mov	r3, r0
}
 800f6c0:	4618      	mov	r0, r3
 800f6c2:	3708      	adds	r7, #8
 800f6c4:	46bd      	mov	sp, r7
 800f6c6:	bd80      	pop	{r7, pc}

0800f6c8 <hci_subevent_le_remote_connection_parameter_request_get_interval_max>:
 * @brief Get field interval_max from event HCI_SUBEVENT_LE_REMOTE_CONNECTION_PARAMETER_REQUEST
 * @param event packet
 * @return interval_max
 * @note: btstack_type 2
 */
static inline uint16_t hci_subevent_le_remote_connection_parameter_request_get_interval_max(const uint8_t * event){
 800f6c8:	b580      	push	{r7, lr}
 800f6ca:	b082      	sub	sp, #8
 800f6cc:	af00      	add	r7, sp, #0
 800f6ce:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 7);
 800f6d0:	2107      	movs	r1, #7
 800f6d2:	6878      	ldr	r0, [r7, #4]
 800f6d4:	f7ff fb87 	bl	800ede6 <little_endian_read_16>
 800f6d8:	4603      	mov	r3, r0
}
 800f6da:	4618      	mov	r0, r3
 800f6dc:	3708      	adds	r7, #8
 800f6de:	46bd      	mov	sp, r7
 800f6e0:	bd80      	pop	{r7, pc}

0800f6e2 <hci_subevent_le_remote_connection_parameter_request_get_latency>:
 * @brief Get field latency from event HCI_SUBEVENT_LE_REMOTE_CONNECTION_PARAMETER_REQUEST
 * @param event packet
 * @return latency
 * @note: btstack_type 2
 */
static inline uint16_t hci_subevent_le_remote_connection_parameter_request_get_latency(const uint8_t * event){
 800f6e2:	b580      	push	{r7, lr}
 800f6e4:	b082      	sub	sp, #8
 800f6e6:	af00      	add	r7, sp, #0
 800f6e8:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 9);
 800f6ea:	2109      	movs	r1, #9
 800f6ec:	6878      	ldr	r0, [r7, #4]
 800f6ee:	f7ff fb7a 	bl	800ede6 <little_endian_read_16>
 800f6f2:	4603      	mov	r3, r0
}
 800f6f4:	4618      	mov	r0, r3
 800f6f6:	3708      	adds	r7, #8
 800f6f8:	46bd      	mov	sp, r7
 800f6fa:	bd80      	pop	{r7, pc}

0800f6fc <hci_subevent_le_remote_connection_parameter_request_get_timeout>:
 * @brief Get field timeout from event HCI_SUBEVENT_LE_REMOTE_CONNECTION_PARAMETER_REQUEST
 * @param event packet
 * @return timeout
 * @note: btstack_type 2
 */
static inline uint16_t hci_subevent_le_remote_connection_parameter_request_get_timeout(const uint8_t * event){
 800f6fc:	b580      	push	{r7, lr}
 800f6fe:	b082      	sub	sp, #8
 800f700:	af00      	add	r7, sp, #0
 800f702:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 11);
 800f704:	210b      	movs	r1, #11
 800f706:	6878      	ldr	r0, [r7, #4]
 800f708:	f7ff fb6d 	bl	800ede6 <little_endian_read_16>
 800f70c:	4603      	mov	r3, r0
}
 800f70e:	4618      	mov	r0, r3
 800f710:	3708      	adds	r7, #8
 800f712:	46bd      	mov	sp, r7
 800f714:	bd80      	pop	{r7, pc}
	...

0800f718 <create_connection_for_bd_addr_and_type>:
/**
 * create connection for given address
 *
 * @return connection OR NULL, if no memory left
 */
static hci_connection_t * create_connection_for_bd_addr_and_type(const bd_addr_t addr, bd_addr_type_t addr_type){
 800f718:	b580      	push	{r7, lr}
 800f71a:	b086      	sub	sp, #24
 800f71c:	af02      	add	r7, sp, #8
 800f71e:	6078      	str	r0, [r7, #4]
 800f720:	460b      	mov	r3, r1
 800f722:	70fb      	strb	r3, [r7, #3]
    log_info("create_connection_for_addr %s, type %x", bd_addr_to_str(addr), addr_type);
 800f724:	6878      	ldr	r0, [r7, #4]
 800f726:	f7ff fe73 	bl	800f410 <bd_addr_to_str>
 800f72a:	4602      	mov	r2, r0
 800f72c:	78fb      	ldrb	r3, [r7, #3]
 800f72e:	9301      	str	r3, [sp, #4]
 800f730:	9200      	str	r2, [sp, #0]
 800f732:	23c2      	movs	r3, #194	; 0xc2
 800f734:	4a2c      	ldr	r2, [pc, #176]	; (800f7e8 <create_connection_for_bd_addr_and_type+0xd0>)
 800f736:	492d      	ldr	r1, [pc, #180]	; (800f7ec <create_connection_for_bd_addr_and_type+0xd4>)
 800f738:	2001      	movs	r0, #1
 800f73a:	f007 fe81 	bl	8017440 <hci_dump_log>
    hci_connection_t * conn = btstack_memory_hci_connection_get();
 800f73e:	f7ff f88b 	bl	800e858 <btstack_memory_hci_connection_get>
 800f742:	60f8      	str	r0, [r7, #12]
    if (!conn) return NULL;
 800f744:	68fb      	ldr	r3, [r7, #12]
 800f746:	2b00      	cmp	r3, #0
 800f748:	d101      	bne.n	800f74e <create_connection_for_bd_addr_and_type+0x36>
 800f74a:	2300      	movs	r3, #0
 800f74c:	e047      	b.n	800f7de <create_connection_for_bd_addr_and_type+0xc6>
    bd_addr_copy(conn->address, addr);
 800f74e:	68fb      	ldr	r3, [r7, #12]
 800f750:	3304      	adds	r3, #4
 800f752:	6879      	ldr	r1, [r7, #4]
 800f754:	4618      	mov	r0, r3
 800f756:	f7ff fb38 	bl	800edca <bd_addr_copy>
    conn->role = HCI_ROLE_INVALID;
 800f75a:	68fb      	ldr	r3, [r7, #12]
 800f75c:	22ff      	movs	r2, #255	; 0xff
 800f75e:	735a      	strb	r2, [r3, #13]
    conn->address_type = addr_type;
 800f760:	68fb      	ldr	r3, [r7, #12]
 800f762:	78fa      	ldrb	r2, [r7, #3]
 800f764:	731a      	strb	r2, [r3, #12]
    conn->con_handle = 0xffff;
 800f766:	68fb      	ldr	r3, [r7, #12]
 800f768:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800f76c:	815a      	strh	r2, [r3, #10]
    conn->authentication_flags = AUTH_FLAGS_NONE;
 800f76e:	68fb      	ldr	r3, [r7, #12]
 800f770:	2200      	movs	r2, #0
 800f772:	639a      	str	r2, [r3, #56]	; 0x38
    conn->bonding_flags = 0;
 800f774:	68fb      	ldr	r3, [r7, #12]
 800f776:	2200      	movs	r2, #0
 800f778:	821a      	strh	r2, [r3, #16]
    conn->requested_security_level = LEVEL_0;
 800f77a:	68fb      	ldr	r3, [r7, #12]
 800f77c:	2200      	movs	r2, #0
 800f77e:	751a      	strb	r2, [r3, #20]
#ifdef ENABLE_CLASSIC
    conn->request_role = HCI_ROLE_INVALID;
 800f780:	68fb      	ldr	r3, [r7, #12]
 800f782:	22ff      	movs	r2, #255	; 0xff
 800f784:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
    btstack_run_loop_set_timer_handler(&conn->timeout, hci_connection_timeout_handler);
 800f788:	68fb      	ldr	r3, [r7, #12]
 800f78a:	333c      	adds	r3, #60	; 0x3c
 800f78c:	4918      	ldr	r1, [pc, #96]	; (800f7f0 <create_connection_for_bd_addr_and_type+0xd8>)
 800f78e:	4618      	mov	r0, r3
 800f790:	f7ff f9fc 	bl	800eb8c <btstack_run_loop_set_timer_handler>
    btstack_run_loop_set_timer_context(&conn->timeout, conn);
 800f794:	68fb      	ldr	r3, [r7, #12]
 800f796:	333c      	adds	r3, #60	; 0x3c
 800f798:	68f9      	ldr	r1, [r7, #12]
 800f79a:	4618      	mov	r0, r3
 800f79c:	f7ff fa6c 	bl	800ec78 <btstack_run_loop_set_timer_context>
    hci_connection_timestamp(conn);
 800f7a0:	68f8      	ldr	r0, [r7, #12]
 800f7a2:	f000 f95c 	bl	800fa5e <hci_connection_timestamp>
#endif
    conn->acl_recombination_length = 0;
 800f7a6:	68fb      	ldr	r3, [r7, #12]
 800f7a8:	2200      	movs	r2, #0
 800f7aa:	f8a3 2708 	strh.w	r2, [r3, #1800]	; 0x708
    conn->acl_recombination_pos = 0;
 800f7ae:	68fb      	ldr	r3, [r7, #12]
 800f7b0:	2200      	movs	r2, #0
 800f7b2:	f8a3 2706 	strh.w	r2, [r3, #1798]	; 0x706
    conn->num_packets_sent = 0;
 800f7b6:	68fb      	ldr	r3, [r7, #12]
 800f7b8:	2200      	movs	r2, #0
 800f7ba:	f883 270a 	strb.w	r2, [r3, #1802]	; 0x70a

    conn->le_con_parameter_update_state = CON_PARAMETER_UPDATE_NONE;
 800f7be:	68fb      	ldr	r3, [r7, #12]
 800f7c0:	2200      	movs	r2, #0
 800f7c2:	f883 270b 	strb.w	r2, [r3, #1803]	; 0x70b
#ifdef ENABLE_BLE
    conn->le_phy_update_all_phys = 0xff;
 800f7c6:	68fb      	ldr	r3, [r7, #12]
 800f7c8:	22ff      	movs	r2, #255	; 0xff
 800f7ca:	f883 2718 	strb.w	r2, [r3, #1816]	; 0x718
#endif
#ifdef ENABLE_LE_LIMIT_ACL_FRAGMENT_BY_MAX_OCTETS
    conn->le_max_tx_octets = 27;
#endif
    btstack_linked_list_add(&hci_stack->connections, (btstack_linked_item_t *) conn);
 800f7ce:	4b09      	ldr	r3, [pc, #36]	; (800f7f4 <create_connection_for_bd_addr_and_type+0xdc>)
 800f7d0:	681b      	ldr	r3, [r3, #0]
 800f7d2:	3314      	adds	r3, #20
 800f7d4:	68f9      	ldr	r1, [r7, #12]
 800f7d6:	4618      	mov	r0, r3
 800f7d8:	f7fe ff2b 	bl	800e632 <btstack_linked_list_add>
    return conn;
 800f7dc:	68fb      	ldr	r3, [r7, #12]
}
 800f7de:	4618      	mov	r0, r3
 800f7e0:	3710      	adds	r7, #16
 800f7e2:	46bd      	mov	sp, r7
 800f7e4:	bd80      	pop	{r7, pc}
 800f7e6:	bf00      	nop
 800f7e8:	0802929c 	.word	0x0802929c
 800f7ec:	080292a4 	.word	0x080292a4
 800f7f0:	0800fa2d 	.word	0x0800fa2d
 800f7f4:	20009780 	.word	0x20009780

0800f7f8 <gap_get_connection_parameter_range>:
/**
 * get le connection parameter range
*
 * @return le connection parameter range struct
 */
void gap_get_connection_parameter_range(le_connection_parameter_range_t * range){
 800f7f8:	b490      	push	{r4, r7}
 800f7fa:	b082      	sub	sp, #8
 800f7fc:	af00      	add	r7, sp, #0
 800f7fe:	6078      	str	r0, [r7, #4]
    *range = hci_stack->le_connection_parameter_range;
 800f800:	4b07      	ldr	r3, [pc, #28]	; (800f820 <gap_get_connection_parameter_range+0x28>)
 800f802:	681b      	ldr	r3, [r3, #0]
 800f804:	687a      	ldr	r2, [r7, #4]
 800f806:	4614      	mov	r4, r2
 800f808:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
 800f80c:	cb07      	ldmia	r3!, {r0, r1, r2}
 800f80e:	6020      	str	r0, [r4, #0]
 800f810:	6061      	str	r1, [r4, #4]
 800f812:	60a2      	str	r2, [r4, #8]
}
 800f814:	bf00      	nop
 800f816:	3708      	adds	r7, #8
 800f818:	46bd      	mov	sp, r7
 800f81a:	bc90      	pop	{r4, r7}
 800f81c:	4770      	bx	lr
 800f81e:	bf00      	nop
 800f820:	20009780 	.word	0x20009780

0800f824 <gap_connection_parameter_range_included>:
 * @param conn_interval_max (unit: 1.25ms)
 * @param conn_latency
 * @param supervision_timeout (unit: 10ms)
 * @returns 1 if included
 */
int gap_connection_parameter_range_included(le_connection_parameter_range_t * existing_range, uint16_t le_conn_interval_min, uint16_t le_conn_interval_max, uint16_t le_conn_latency, uint16_t le_supervision_timeout){
 800f824:	b480      	push	{r7}
 800f826:	b085      	sub	sp, #20
 800f828:	af00      	add	r7, sp, #0
 800f82a:	60f8      	str	r0, [r7, #12]
 800f82c:	4608      	mov	r0, r1
 800f82e:	4611      	mov	r1, r2
 800f830:	461a      	mov	r2, r3
 800f832:	4603      	mov	r3, r0
 800f834:	817b      	strh	r3, [r7, #10]
 800f836:	460b      	mov	r3, r1
 800f838:	813b      	strh	r3, [r7, #8]
 800f83a:	4613      	mov	r3, r2
 800f83c:	80fb      	strh	r3, [r7, #6]
    if (le_conn_interval_min < existing_range->le_conn_interval_min) return 0;
 800f83e:	68fb      	ldr	r3, [r7, #12]
 800f840:	881b      	ldrh	r3, [r3, #0]
 800f842:	897a      	ldrh	r2, [r7, #10]
 800f844:	429a      	cmp	r2, r3
 800f846:	d201      	bcs.n	800f84c <gap_connection_parameter_range_included+0x28>
 800f848:	2300      	movs	r3, #0
 800f84a:	e023      	b.n	800f894 <gap_connection_parameter_range_included+0x70>
    if (le_conn_interval_max > existing_range->le_conn_interval_max) return 0;
 800f84c:	68fb      	ldr	r3, [r7, #12]
 800f84e:	885b      	ldrh	r3, [r3, #2]
 800f850:	893a      	ldrh	r2, [r7, #8]
 800f852:	429a      	cmp	r2, r3
 800f854:	d901      	bls.n	800f85a <gap_connection_parameter_range_included+0x36>
 800f856:	2300      	movs	r3, #0
 800f858:	e01c      	b.n	800f894 <gap_connection_parameter_range_included+0x70>

    if (le_conn_latency < existing_range->le_conn_latency_min) return 0;
 800f85a:	68fb      	ldr	r3, [r7, #12]
 800f85c:	889b      	ldrh	r3, [r3, #4]
 800f85e:	88fa      	ldrh	r2, [r7, #6]
 800f860:	429a      	cmp	r2, r3
 800f862:	d201      	bcs.n	800f868 <gap_connection_parameter_range_included+0x44>
 800f864:	2300      	movs	r3, #0
 800f866:	e015      	b.n	800f894 <gap_connection_parameter_range_included+0x70>
    if (le_conn_latency > existing_range->le_conn_latency_max) return 0;
 800f868:	68fb      	ldr	r3, [r7, #12]
 800f86a:	88db      	ldrh	r3, [r3, #6]
 800f86c:	88fa      	ldrh	r2, [r7, #6]
 800f86e:	429a      	cmp	r2, r3
 800f870:	d901      	bls.n	800f876 <gap_connection_parameter_range_included+0x52>
 800f872:	2300      	movs	r3, #0
 800f874:	e00e      	b.n	800f894 <gap_connection_parameter_range_included+0x70>

    if (le_supervision_timeout < existing_range->le_supervision_timeout_min) return 0;
 800f876:	68fb      	ldr	r3, [r7, #12]
 800f878:	891b      	ldrh	r3, [r3, #8]
 800f87a:	8b3a      	ldrh	r2, [r7, #24]
 800f87c:	429a      	cmp	r2, r3
 800f87e:	d201      	bcs.n	800f884 <gap_connection_parameter_range_included+0x60>
 800f880:	2300      	movs	r3, #0
 800f882:	e007      	b.n	800f894 <gap_connection_parameter_range_included+0x70>
    if (le_supervision_timeout > existing_range->le_supervision_timeout_max) return 0;
 800f884:	68fb      	ldr	r3, [r7, #12]
 800f886:	895b      	ldrh	r3, [r3, #10]
 800f888:	8b3a      	ldrh	r2, [r7, #24]
 800f88a:	429a      	cmp	r2, r3
 800f88c:	d901      	bls.n	800f892 <gap_connection_parameter_range_included+0x6e>
 800f88e:	2300      	movs	r3, #0
 800f890:	e000      	b.n	800f894 <gap_connection_parameter_range_included+0x70>

    return 1;
 800f892:	2301      	movs	r3, #1
}
 800f894:	4618      	mov	r0, r3
 800f896:	3714      	adds	r7, #20
 800f898:	46bd      	mov	sp, r7
 800f89a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f89e:	4770      	bx	lr

0800f8a0 <hci_connections_get_iterator>:
 * get hci connections iterator
 *
 * @return hci connections iterator
 */

void hci_connections_get_iterator(btstack_linked_list_iterator_t *it){
 800f8a0:	b580      	push	{r7, lr}
 800f8a2:	b082      	sub	sp, #8
 800f8a4:	af00      	add	r7, sp, #0
 800f8a6:	6078      	str	r0, [r7, #4]
    btstack_linked_list_iterator_init(it, &hci_stack->connections);
 800f8a8:	4b05      	ldr	r3, [pc, #20]	; (800f8c0 <hci_connections_get_iterator+0x20>)
 800f8aa:	681b      	ldr	r3, [r3, #0]
 800f8ac:	3314      	adds	r3, #20
 800f8ae:	4619      	mov	r1, r3
 800f8b0:	6878      	ldr	r0, [r7, #4]
 800f8b2:	f7fe ff4c 	bl	800e74e <btstack_linked_list_iterator_init>
}
 800f8b6:	bf00      	nop
 800f8b8:	3708      	adds	r7, #8
 800f8ba:	46bd      	mov	sp, r7
 800f8bc:	bd80      	pop	{r7, pc}
 800f8be:	bf00      	nop
 800f8c0:	20009780 	.word	0x20009780

0800f8c4 <hci_connection_for_handle>:
/**
 * get connection for a given handle
 *
 * @return connection OR NULL, if not found
 */
hci_connection_t * hci_connection_for_handle(hci_con_handle_t con_handle){
 800f8c4:	b580      	push	{r7, lr}
 800f8c6:	b086      	sub	sp, #24
 800f8c8:	af00      	add	r7, sp, #0
 800f8ca:	4603      	mov	r3, r0
 800f8cc:	80fb      	strh	r3, [r7, #6]
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &hci_stack->connections);
 800f8ce:	4b12      	ldr	r3, [pc, #72]	; (800f918 <hci_connection_for_handle+0x54>)
 800f8d0:	681b      	ldr	r3, [r3, #0]
 800f8d2:	f103 0214 	add.w	r2, r3, #20
 800f8d6:	f107 0308 	add.w	r3, r7, #8
 800f8da:	4611      	mov	r1, r2
 800f8dc:	4618      	mov	r0, r3
 800f8de:	f7fe ff36 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 800f8e2:	e00c      	b.n	800f8fe <hci_connection_for_handle+0x3a>
        hci_connection_t * item = (hci_connection_t *) btstack_linked_list_iterator_next(&it);
 800f8e4:	f107 0308 	add.w	r3, r7, #8
 800f8e8:	4618      	mov	r0, r3
 800f8ea:	f7fe ff73 	bl	800e7d4 <btstack_linked_list_iterator_next>
 800f8ee:	6178      	str	r0, [r7, #20]
        if ( item->con_handle == con_handle ) {
 800f8f0:	697b      	ldr	r3, [r7, #20]
 800f8f2:	895b      	ldrh	r3, [r3, #10]
 800f8f4:	88fa      	ldrh	r2, [r7, #6]
 800f8f6:	429a      	cmp	r2, r3
 800f8f8:	d101      	bne.n	800f8fe <hci_connection_for_handle+0x3a>
            return item;
 800f8fa:	697b      	ldr	r3, [r7, #20]
 800f8fc:	e008      	b.n	800f910 <hci_connection_for_handle+0x4c>
    while (btstack_linked_list_iterator_has_next(&it)){
 800f8fe:	f107 0308 	add.w	r3, r7, #8
 800f902:	4618      	mov	r0, r3
 800f904:	f7fe ff38 	bl	800e778 <btstack_linked_list_iterator_has_next>
 800f908:	4603      	mov	r3, r0
 800f90a:	2b00      	cmp	r3, #0
 800f90c:	d1ea      	bne.n	800f8e4 <hci_connection_for_handle+0x20>
        }
    } 
    return NULL;
 800f90e:	2300      	movs	r3, #0
}
 800f910:	4618      	mov	r0, r3
 800f912:	3718      	adds	r7, #24
 800f914:	46bd      	mov	sp, r7
 800f916:	bd80      	pop	{r7, pc}
 800f918:	20009780 	.word	0x20009780

0800f91c <hci_connection_for_bd_addr_and_type>:
/**
 * get connection for given address
 *
 * @return connection OR NULL, if not found
 */
hci_connection_t * hci_connection_for_bd_addr_and_type(const bd_addr_t  addr, bd_addr_type_t addr_type){
 800f91c:	b580      	push	{r7, lr}
 800f91e:	b086      	sub	sp, #24
 800f920:	af00      	add	r7, sp, #0
 800f922:	6078      	str	r0, [r7, #4]
 800f924:	460b      	mov	r3, r1
 800f926:	70fb      	strb	r3, [r7, #3]
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &hci_stack->connections);
 800f928:	4b18      	ldr	r3, [pc, #96]	; (800f98c <hci_connection_for_bd_addr_and_type+0x70>)
 800f92a:	681b      	ldr	r3, [r3, #0]
 800f92c:	f103 0214 	add.w	r2, r3, #20
 800f930:	f107 0308 	add.w	r3, r7, #8
 800f934:	4611      	mov	r1, r2
 800f936:	4618      	mov	r0, r3
 800f938:	f7fe ff09 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 800f93c:	e018      	b.n	800f970 <hci_connection_for_bd_addr_and_type+0x54>
        hci_connection_t * connection = (hci_connection_t *) btstack_linked_list_iterator_next(&it);
 800f93e:	f107 0308 	add.w	r3, r7, #8
 800f942:	4618      	mov	r0, r3
 800f944:	f7fe ff46 	bl	800e7d4 <btstack_linked_list_iterator_next>
 800f948:	6178      	str	r0, [r7, #20]
        if (connection->address_type != addr_type)  continue;
 800f94a:	697b      	ldr	r3, [r7, #20]
 800f94c:	7b1b      	ldrb	r3, [r3, #12]
 800f94e:	78fa      	ldrb	r2, [r7, #3]
 800f950:	429a      	cmp	r2, r3
 800f952:	d000      	beq.n	800f956 <hci_connection_for_bd_addr_and_type+0x3a>
 800f954:	e00c      	b.n	800f970 <hci_connection_for_bd_addr_and_type+0x54>
        if (memcmp(addr, connection->address, 6) != 0) continue;
 800f956:	697b      	ldr	r3, [r7, #20]
 800f958:	3304      	adds	r3, #4
 800f95a:	2206      	movs	r2, #6
 800f95c:	4619      	mov	r1, r3
 800f95e:	6878      	ldr	r0, [r7, #4]
 800f960:	f018 f87c 	bl	8027a5c <memcmp>
 800f964:	4603      	mov	r3, r0
 800f966:	2b00      	cmp	r3, #0
 800f968:	d000      	beq.n	800f96c <hci_connection_for_bd_addr_and_type+0x50>
 800f96a:	e001      	b.n	800f970 <hci_connection_for_bd_addr_and_type+0x54>
        return connection;   
 800f96c:	697b      	ldr	r3, [r7, #20]
 800f96e:	e008      	b.n	800f982 <hci_connection_for_bd_addr_and_type+0x66>
    while (btstack_linked_list_iterator_has_next(&it)){
 800f970:	f107 0308 	add.w	r3, r7, #8
 800f974:	4618      	mov	r0, r3
 800f976:	f7fe feff 	bl	800e778 <btstack_linked_list_iterator_has_next>
 800f97a:	4603      	mov	r3, r0
 800f97c:	2b00      	cmp	r3, #0
 800f97e:	d1de      	bne.n	800f93e <hci_connection_for_bd_addr_and_type+0x22>
    } 
    return NULL;
 800f980:	2300      	movs	r3, #0
}
 800f982:	4618      	mov	r0, r3
 800f984:	3718      	adds	r7, #24
 800f986:	46bd      	mov	sp, r7
 800f988:	bd80      	pop	{r7, pc}
 800f98a:	bf00      	nop
 800f98c:	20009780 	.word	0x20009780

0800f990 <connectionClearAuthenticationFlags>:

inline static void connectionClearAuthenticationFlags(hci_connection_t * conn, hci_authentication_flags_t flags){
 800f990:	b480      	push	{r7}
 800f992:	b083      	sub	sp, #12
 800f994:	af00      	add	r7, sp, #0
 800f996:	6078      	str	r0, [r7, #4]
 800f998:	6039      	str	r1, [r7, #0]
    conn->authentication_flags = (hci_authentication_flags_t)(conn->authentication_flags & ~flags);
 800f99a:	687b      	ldr	r3, [r7, #4]
 800f99c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800f99e:	683b      	ldr	r3, [r7, #0]
 800f9a0:	43db      	mvns	r3, r3
 800f9a2:	401a      	ands	r2, r3
 800f9a4:	687b      	ldr	r3, [r7, #4]
 800f9a6:	639a      	str	r2, [r3, #56]	; 0x38
}
 800f9a8:	bf00      	nop
 800f9aa:	370c      	adds	r7, #12
 800f9ac:	46bd      	mov	sp, r7
 800f9ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f9b2:	4770      	bx	lr

0800f9b4 <connectionSetAuthenticationFlags>:

inline static void connectionSetAuthenticationFlags(hci_connection_t * conn, hci_authentication_flags_t flags){
 800f9b4:	b480      	push	{r7}
 800f9b6:	b083      	sub	sp, #12
 800f9b8:	af00      	add	r7, sp, #0
 800f9ba:	6078      	str	r0, [r7, #4]
 800f9bc:	6039      	str	r1, [r7, #0]
    conn->authentication_flags = (hci_authentication_flags_t)(conn->authentication_flags | flags);
 800f9be:	687b      	ldr	r3, [r7, #4]
 800f9c0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800f9c2:	683b      	ldr	r3, [r7, #0]
 800f9c4:	431a      	orrs	r2, r3
 800f9c6:	687b      	ldr	r3, [r7, #4]
 800f9c8:	639a      	str	r2, [r3, #56]	; 0x38
}
 800f9ca:	bf00      	nop
 800f9cc:	370c      	adds	r7, #12
 800f9ce:	46bd      	mov	sp, r7
 800f9d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f9d4:	4770      	bx	lr
	...

0800f9d8 <hci_number_sco_connections>:

#ifdef ENABLE_CLASSIC

#ifdef ENABLE_SCO_OVER_HCI
static int hci_number_sco_connections(void){
 800f9d8:	b580      	push	{r7, lr}
 800f9da:	b086      	sub	sp, #24
 800f9dc:	af00      	add	r7, sp, #0
    int connections = 0;
 800f9de:	2300      	movs	r3, #0
 800f9e0:	617b      	str	r3, [r7, #20]
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &hci_stack->connections);
 800f9e2:	4b11      	ldr	r3, [pc, #68]	; (800fa28 <hci_number_sco_connections+0x50>)
 800f9e4:	681b      	ldr	r3, [r3, #0]
 800f9e6:	f103 0214 	add.w	r2, r3, #20
 800f9ea:	1d3b      	adds	r3, r7, #4
 800f9ec:	4611      	mov	r1, r2
 800f9ee:	4618      	mov	r0, r3
 800f9f0:	f7fe fead 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 800f9f4:	e00c      	b.n	800fa10 <hci_number_sco_connections+0x38>
        hci_connection_t * connection = (hci_connection_t *) btstack_linked_list_iterator_next(&it);
 800f9f6:	1d3b      	adds	r3, r7, #4
 800f9f8:	4618      	mov	r0, r3
 800f9fa:	f7fe feeb 	bl	800e7d4 <btstack_linked_list_iterator_next>
 800f9fe:	6138      	str	r0, [r7, #16]
        if (connection->address_type != BD_ADDR_TYPE_SCO) continue;
 800fa00:	693b      	ldr	r3, [r7, #16]
 800fa02:	7b1b      	ldrb	r3, [r3, #12]
 800fa04:	2bfc      	cmp	r3, #252	; 0xfc
 800fa06:	d000      	beq.n	800fa0a <hci_number_sco_connections+0x32>
 800fa08:	e002      	b.n	800fa10 <hci_number_sco_connections+0x38>
        connections++;
 800fa0a:	697b      	ldr	r3, [r7, #20]
 800fa0c:	3301      	adds	r3, #1
 800fa0e:	617b      	str	r3, [r7, #20]
    while (btstack_linked_list_iterator_has_next(&it)){
 800fa10:	1d3b      	adds	r3, r7, #4
 800fa12:	4618      	mov	r0, r3
 800fa14:	f7fe feb0 	bl	800e778 <btstack_linked_list_iterator_has_next>
 800fa18:	4603      	mov	r3, r0
 800fa1a:	2b00      	cmp	r3, #0
 800fa1c:	d1eb      	bne.n	800f9f6 <hci_number_sco_connections+0x1e>
    } 
    return connections;
 800fa1e:	697b      	ldr	r3, [r7, #20]
}
 800fa20:	4618      	mov	r0, r3
 800fa22:	3718      	adds	r7, #24
 800fa24:	46bd      	mov	sp, r7
 800fa26:	bd80      	pop	{r7, pc}
 800fa28:	20009780 	.word	0x20009780

0800fa2c <hci_connection_timeout_handler>:
#endif

static void hci_connection_timeout_handler(btstack_timer_source_t *timer){
 800fa2c:	b580      	push	{r7, lr}
 800fa2e:	b084      	sub	sp, #16
 800fa30:	af00      	add	r7, sp, #0
 800fa32:	6078      	str	r0, [r7, #4]
    hci_connection_t * connection = (hci_connection_t *) btstack_run_loop_get_timer_context(timer);
 800fa34:	6878      	ldr	r0, [r7, #4]
 800fa36:	f7ff f92d 	bl	800ec94 <btstack_run_loop_get_timer_context>
 800fa3a:	60f8      	str	r0, [r7, #12]
    if (btstack_run_loop_embedded_get_ticks() > connection->timestamp + btstack_run_loop_embedded_ticks_for_ms(HCI_CONNECTION_TIMEOUT_MS)){
        // connections might be timed out
        hci_emit_l2cap_check_timeout(connection);
    }
#else 
    if (btstack_run_loop_get_time_ms() > (connection->timestamp + HCI_CONNECTION_TIMEOUT_MS)){
 800fa3c:	f7ff f956 	bl	800ecec <btstack_run_loop_get_time_ms>
 800fa40:	4602      	mov	r2, r0
 800fa42:	68fb      	ldr	r3, [r7, #12]
 800fa44:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800fa46:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 800fa4a:	3310      	adds	r3, #16
 800fa4c:	429a      	cmp	r2, r3
 800fa4e:	d902      	bls.n	800fa56 <hci_connection_timeout_handler+0x2a>
        // connections might be timed out
        hci_emit_l2cap_check_timeout(connection);
 800fa50:	68f8      	ldr	r0, [r7, #12]
 800fa52:	f006 fce3 	bl	801641c <hci_emit_l2cap_check_timeout>
    }
#endif
}
 800fa56:	bf00      	nop
 800fa58:	3710      	adds	r7, #16
 800fa5a:	46bd      	mov	sp, r7
 800fa5c:	bd80      	pop	{r7, pc}

0800fa5e <hci_connection_timestamp>:

static void hci_connection_timestamp(hci_connection_t *connection){
 800fa5e:	b580      	push	{r7, lr}
 800fa60:	b082      	sub	sp, #8
 800fa62:	af00      	add	r7, sp, #0
 800fa64:	6078      	str	r0, [r7, #4]
#ifdef HAVE_EMBEDDED_TICK
    connection->timestamp = btstack_run_loop_embedded_get_ticks();
#else
    connection->timestamp = btstack_run_loop_get_time_ms();
 800fa66:	f7ff f941 	bl	800ecec <btstack_run_loop_get_time_ms>
 800fa6a:	4602      	mov	r2, r0
 800fa6c:	687b      	ldr	r3, [r7, #4]
 800fa6e:	64da      	str	r2, [r3, #76]	; 0x4c
#endif
}
 800fa70:	bf00      	nop
 800fa72:	3708      	adds	r7, #8
 800fa74:	46bd      	mov	sp, r7
 800fa76:	bd80      	pop	{r7, pc}

0800fa78 <hci_add_connection_flags_for_flipped_bd_addr>:
/**
 * add authentication flags and reset timer
 * @note: assumes classic connection
 * @note: bd_addr is passed in as litle endian uint8_t * as it is called from parsing packets
 */
static void hci_add_connection_flags_for_flipped_bd_addr(uint8_t *bd_addr, hci_authentication_flags_t flags){
 800fa78:	b580      	push	{r7, lr}
 800fa7a:	b086      	sub	sp, #24
 800fa7c:	af00      	add	r7, sp, #0
 800fa7e:	6078      	str	r0, [r7, #4]
 800fa80:	6039      	str	r1, [r7, #0]
    bd_addr_t addr;
    reverse_bd_addr(bd_addr, addr);
 800fa82:	f107 030c 	add.w	r3, r7, #12
 800fa86:	4619      	mov	r1, r3
 800fa88:	6878      	ldr	r0, [r7, #4]
 800fa8a:	f7ff fb32 	bl	800f0f2 <reverse_bd_addr>
    hci_connection_t * conn = hci_connection_for_bd_addr_and_type(addr, BD_ADDR_TYPE_ACL);
 800fa8e:	f107 030c 	add.w	r3, r7, #12
 800fa92:	21fd      	movs	r1, #253	; 0xfd
 800fa94:	4618      	mov	r0, r3
 800fa96:	f7ff ff41 	bl	800f91c <hci_connection_for_bd_addr_and_type>
 800fa9a:	6178      	str	r0, [r7, #20]
    if (conn) {
 800fa9c:	697b      	ldr	r3, [r7, #20]
 800fa9e:	2b00      	cmp	r3, #0
 800faa0:	d006      	beq.n	800fab0 <hci_add_connection_flags_for_flipped_bd_addr+0x38>
        connectionSetAuthenticationFlags(conn, flags);
 800faa2:	6839      	ldr	r1, [r7, #0]
 800faa4:	6978      	ldr	r0, [r7, #20]
 800faa6:	f7ff ff85 	bl	800f9b4 <connectionSetAuthenticationFlags>
        hci_connection_timestamp(conn);
 800faaa:	6978      	ldr	r0, [r7, #20]
 800faac:	f7ff ffd7 	bl	800fa5e <hci_connection_timestamp>
    }
}
 800fab0:	bf00      	nop
 800fab2:	3718      	adds	r7, #24
 800fab4:	46bd      	mov	sp, r7
 800fab6:	bd80      	pop	{r7, pc}

0800fab8 <hci_authentication_active_for_handle>:

int  hci_authentication_active_for_handle(hci_con_handle_t handle){
 800fab8:	b580      	push	{r7, lr}
 800faba:	b084      	sub	sp, #16
 800fabc:	af00      	add	r7, sp, #0
 800fabe:	4603      	mov	r3, r0
 800fac0:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * conn = hci_connection_for_handle(handle);
 800fac2:	88fb      	ldrh	r3, [r7, #6]
 800fac4:	4618      	mov	r0, r3
 800fac6:	f7ff fefd 	bl	800f8c4 <hci_connection_for_handle>
 800faca:	60f8      	str	r0, [r7, #12]
    if (!conn) return 0;
 800facc:	68fb      	ldr	r3, [r7, #12]
 800face:	2b00      	cmp	r3, #0
 800fad0:	d101      	bne.n	800fad6 <hci_authentication_active_for_handle+0x1e>
 800fad2:	2300      	movs	r3, #0
 800fad4:	e010      	b.n	800faf8 <hci_authentication_active_for_handle+0x40>
    if (conn->authentication_flags & LEGACY_PAIRING_ACTIVE) return 1;
 800fad6:	68fb      	ldr	r3, [r7, #12]
 800fad8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800fada:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800fade:	2b00      	cmp	r3, #0
 800fae0:	d001      	beq.n	800fae6 <hci_authentication_active_for_handle+0x2e>
 800fae2:	2301      	movs	r3, #1
 800fae4:	e008      	b.n	800faf8 <hci_authentication_active_for_handle+0x40>
    if (conn->authentication_flags & SSP_PAIRING_ACTIVE) return 1;
 800fae6:	68fb      	ldr	r3, [r7, #12]
 800fae8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800faea:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800faee:	2b00      	cmp	r3, #0
 800faf0:	d001      	beq.n	800faf6 <hci_authentication_active_for_handle+0x3e>
 800faf2:	2301      	movs	r3, #1
 800faf4:	e000      	b.n	800faf8 <hci_authentication_active_for_handle+0x40>
    return 0;
 800faf6:	2300      	movs	r3, #0
}
 800faf8:	4618      	mov	r0, r3
 800fafa:	3710      	adds	r7, #16
 800fafc:	46bd      	mov	sp, r7
 800fafe:	bd80      	pop	{r7, pc}

0800fb00 <gap_drop_link_key_for_bd_addr>:

void gap_drop_link_key_for_bd_addr(bd_addr_t addr){
 800fb00:	b580      	push	{r7, lr}
 800fb02:	b084      	sub	sp, #16
 800fb04:	af02      	add	r7, sp, #8
 800fb06:	6078      	str	r0, [r7, #4]
    if (!hci_stack->link_key_db) return;
 800fb08:	4b0d      	ldr	r3, [pc, #52]	; (800fb40 <gap_drop_link_key_for_bd_addr+0x40>)
 800fb0a:	681b      	ldr	r3, [r3, #0]
 800fb0c:	691b      	ldr	r3, [r3, #16]
 800fb0e:	2b00      	cmp	r3, #0
 800fb10:	d012      	beq.n	800fb38 <gap_drop_link_key_for_bd_addr+0x38>
    log_info("gap_drop_link_key_for_bd_addr: %s", bd_addr_to_str(addr));
 800fb12:	6878      	ldr	r0, [r7, #4]
 800fb14:	f7ff fc7c 	bl	800f410 <bd_addr_to_str>
 800fb18:	4603      	mov	r3, r0
 800fb1a:	9300      	str	r3, [sp, #0]
 800fb1c:	f44f 73c4 	mov.w	r3, #392	; 0x188
 800fb20:	4a08      	ldr	r2, [pc, #32]	; (800fb44 <gap_drop_link_key_for_bd_addr+0x44>)
 800fb22:	4909      	ldr	r1, [pc, #36]	; (800fb48 <gap_drop_link_key_for_bd_addr+0x48>)
 800fb24:	2001      	movs	r0, #1
 800fb26:	f007 fc8b 	bl	8017440 <hci_dump_log>
    hci_stack->link_key_db->delete_link_key(addr);
 800fb2a:	4b05      	ldr	r3, [pc, #20]	; (800fb40 <gap_drop_link_key_for_bd_addr+0x40>)
 800fb2c:	681b      	ldr	r3, [r3, #0]
 800fb2e:	691b      	ldr	r3, [r3, #16]
 800fb30:	695b      	ldr	r3, [r3, #20]
 800fb32:	6878      	ldr	r0, [r7, #4]
 800fb34:	4798      	blx	r3
 800fb36:	e000      	b.n	800fb3a <gap_drop_link_key_for_bd_addr+0x3a>
    if (!hci_stack->link_key_db) return;
 800fb38:	bf00      	nop
}
 800fb3a:	3708      	adds	r7, #8
 800fb3c:	46bd      	mov	sp, r7
 800fb3e:	bd80      	pop	{r7, pc}
 800fb40:	20009780 	.word	0x20009780
 800fb44:	0802929c 	.word	0x0802929c
 800fb48:	080292d4 	.word	0x080292d4

0800fb4c <gap_store_link_key_for_bd_addr>:

void gap_store_link_key_for_bd_addr(bd_addr_t addr, link_key_t link_key, link_key_type_t type){
 800fb4c:	b580      	push	{r7, lr}
 800fb4e:	b086      	sub	sp, #24
 800fb50:	af02      	add	r7, sp, #8
 800fb52:	60f8      	str	r0, [r7, #12]
 800fb54:	60b9      	str	r1, [r7, #8]
 800fb56:	4613      	mov	r3, r2
 800fb58:	71fb      	strb	r3, [r7, #7]
    if (!hci_stack->link_key_db) return;
 800fb5a:	4b10      	ldr	r3, [pc, #64]	; (800fb9c <gap_store_link_key_for_bd_addr+0x50>)
 800fb5c:	681b      	ldr	r3, [r3, #0]
 800fb5e:	691b      	ldr	r3, [r3, #16]
 800fb60:	2b00      	cmp	r3, #0
 800fb62:	d016      	beq.n	800fb92 <gap_store_link_key_for_bd_addr+0x46>
    log_info("gap_store_link_key_for_bd_addr: %s, type %u", bd_addr_to_str(addr), type);
 800fb64:	68f8      	ldr	r0, [r7, #12]
 800fb66:	f7ff fc53 	bl	800f410 <bd_addr_to_str>
 800fb6a:	4602      	mov	r2, r0
 800fb6c:	79fb      	ldrb	r3, [r7, #7]
 800fb6e:	9301      	str	r3, [sp, #4]
 800fb70:	9200      	str	r2, [sp, #0]
 800fb72:	f44f 73c7 	mov.w	r3, #398	; 0x18e
 800fb76:	4a0a      	ldr	r2, [pc, #40]	; (800fba0 <gap_store_link_key_for_bd_addr+0x54>)
 800fb78:	490a      	ldr	r1, [pc, #40]	; (800fba4 <gap_store_link_key_for_bd_addr+0x58>)
 800fb7a:	2001      	movs	r0, #1
 800fb7c:	f007 fc60 	bl	8017440 <hci_dump_log>
    hci_stack->link_key_db->put_link_key(addr, link_key, type);
 800fb80:	4b06      	ldr	r3, [pc, #24]	; (800fb9c <gap_store_link_key_for_bd_addr+0x50>)
 800fb82:	681b      	ldr	r3, [r3, #0]
 800fb84:	691b      	ldr	r3, [r3, #16]
 800fb86:	691b      	ldr	r3, [r3, #16]
 800fb88:	79fa      	ldrb	r2, [r7, #7]
 800fb8a:	68b9      	ldr	r1, [r7, #8]
 800fb8c:	68f8      	ldr	r0, [r7, #12]
 800fb8e:	4798      	blx	r3
 800fb90:	e000      	b.n	800fb94 <gap_store_link_key_for_bd_addr+0x48>
    if (!hci_stack->link_key_db) return;
 800fb92:	bf00      	nop
}
 800fb94:	3710      	adds	r7, #16
 800fb96:	46bd      	mov	sp, r7
 800fb98:	bd80      	pop	{r7, pc}
 800fb9a:	bf00      	nop
 800fb9c:	20009780 	.word	0x20009780
 800fba0:	0802929c 	.word	0x0802929c
 800fba4:	08029300 	.word	0x08029300

0800fba8 <hci_is_le_connection_type>:
    if (!hci_stack->link_key_db) return;
    hci_stack->link_key_db->iterator_done(it);
}
#endif

static bool hci_is_le_connection_type(bd_addr_type_t address_type){
 800fba8:	b480      	push	{r7}
 800fbaa:	b083      	sub	sp, #12
 800fbac:	af00      	add	r7, sp, #0
 800fbae:	4603      	mov	r3, r0
 800fbb0:	71fb      	strb	r3, [r7, #7]
    switch (address_type){
 800fbb2:	79fb      	ldrb	r3, [r7, #7]
 800fbb4:	3300      	adds	r3, #0
 800fbb6:	2b03      	cmp	r3, #3
 800fbb8:	d801      	bhi.n	800fbbe <hci_is_le_connection_type+0x16>
        case BD_ADDR_TYPE_LE_PUBLIC:
        case BD_ADDR_TYPE_LE_RANDOM:
        case BD_ADDR_TYPE_LE_PRIVAT_FALLBACK_PUBLIC:
        case BD_ADDR_TYPE_LE_PRIVAT_FALLBACK_RANDOM:
            return true;
 800fbba:	2301      	movs	r3, #1
 800fbbc:	e000      	b.n	800fbc0 <hci_is_le_connection_type+0x18>
        default:
            return false;
 800fbbe:	2300      	movs	r3, #0
    }
}
 800fbc0:	4618      	mov	r0, r3
 800fbc2:	370c      	adds	r7, #12
 800fbc4:	46bd      	mov	sp, r7
 800fbc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbca:	4770      	bx	lr

0800fbcc <hci_is_le_connection>:

static int hci_is_le_connection(hci_connection_t * connection){
 800fbcc:	b580      	push	{r7, lr}
 800fbce:	b082      	sub	sp, #8
 800fbd0:	af00      	add	r7, sp, #0
 800fbd2:	6078      	str	r0, [r7, #4]
    return hci_is_le_connection_type(connection->address_type);
 800fbd4:	687b      	ldr	r3, [r7, #4]
 800fbd6:	7b1b      	ldrb	r3, [r3, #12]
 800fbd8:	4618      	mov	r0, r3
 800fbda:	f7ff ffe5 	bl	800fba8 <hci_is_le_connection_type>
 800fbde:	4603      	mov	r3, r0
}
 800fbe0:	4618      	mov	r0, r3
 800fbe2:	3708      	adds	r7, #8
 800fbe4:	46bd      	mov	sp, r7
 800fbe6:	bd80      	pop	{r7, pc}

0800fbe8 <nr_hci_connections>:

/**
 * count connections
 */
static int nr_hci_connections(void){
 800fbe8:	b480      	push	{r7}
 800fbea:	b083      	sub	sp, #12
 800fbec:	af00      	add	r7, sp, #0
    int count = 0;
 800fbee:	2300      	movs	r3, #0
 800fbf0:	607b      	str	r3, [r7, #4]
    btstack_linked_item_t *it;
    for (it = (btstack_linked_item_t *) hci_stack->connections; it != NULL ; it = it->next){
 800fbf2:	4b0a      	ldr	r3, [pc, #40]	; (800fc1c <nr_hci_connections+0x34>)
 800fbf4:	681b      	ldr	r3, [r3, #0]
 800fbf6:	695b      	ldr	r3, [r3, #20]
 800fbf8:	603b      	str	r3, [r7, #0]
 800fbfa:	e005      	b.n	800fc08 <nr_hci_connections+0x20>
        count++;
 800fbfc:	687b      	ldr	r3, [r7, #4]
 800fbfe:	3301      	adds	r3, #1
 800fc00:	607b      	str	r3, [r7, #4]
    for (it = (btstack_linked_item_t *) hci_stack->connections; it != NULL ; it = it->next){
 800fc02:	683b      	ldr	r3, [r7, #0]
 800fc04:	681b      	ldr	r3, [r3, #0]
 800fc06:	603b      	str	r3, [r7, #0]
 800fc08:	683b      	ldr	r3, [r7, #0]
 800fc0a:	2b00      	cmp	r3, #0
 800fc0c:	d1f6      	bne.n	800fbfc <nr_hci_connections+0x14>
    }
    return count;
 800fc0e:	687b      	ldr	r3, [r7, #4]
}
 800fc10:	4618      	mov	r0, r3
 800fc12:	370c      	adds	r7, #12
 800fc14:	46bd      	mov	sp, r7
 800fc16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc1a:	4770      	bx	lr
 800fc1c:	20009780 	.word	0x20009780

0800fc20 <hci_number_free_acl_slots_for_connection_type>:

static int hci_number_free_acl_slots_for_connection_type(bd_addr_type_t address_type){
 800fc20:	b580      	push	{r7, lr}
 800fc22:	b08c      	sub	sp, #48	; 0x30
 800fc24:	af04      	add	r7, sp, #16
 800fc26:	4603      	mov	r3, r0
 800fc28:	71fb      	strb	r3, [r7, #7]
    
    unsigned int num_packets_sent_classic = 0;
 800fc2a:	2300      	movs	r3, #0
 800fc2c:	61fb      	str	r3, [r7, #28]
    unsigned int num_packets_sent_le = 0;
 800fc2e:	2300      	movs	r3, #0
 800fc30:	61bb      	str	r3, [r7, #24]

    btstack_linked_item_t *it;
    for (it = (btstack_linked_item_t *) hci_stack->connections; it != NULL; it = it->next){
 800fc32:	4b4c      	ldr	r3, [pc, #304]	; (800fd64 <hci_number_free_acl_slots_for_connection_type+0x144>)
 800fc34:	681b      	ldr	r3, [r3, #0]
 800fc36:	695b      	ldr	r3, [r3, #20]
 800fc38:	617b      	str	r3, [r7, #20]
 800fc3a:	e01c      	b.n	800fc76 <hci_number_free_acl_slots_for_connection_type+0x56>
        hci_connection_t * connection = (hci_connection_t *) it;
 800fc3c:	697b      	ldr	r3, [r7, #20]
 800fc3e:	60bb      	str	r3, [r7, #8]
        if (hci_is_le_connection(connection)){
 800fc40:	68b8      	ldr	r0, [r7, #8]
 800fc42:	f7ff ffc3 	bl	800fbcc <hci_is_le_connection>
 800fc46:	4603      	mov	r3, r0
 800fc48:	2b00      	cmp	r3, #0
 800fc4a:	d006      	beq.n	800fc5a <hci_number_free_acl_slots_for_connection_type+0x3a>
            num_packets_sent_le += connection->num_packets_sent;
 800fc4c:	68bb      	ldr	r3, [r7, #8]
 800fc4e:	f893 370a 	ldrb.w	r3, [r3, #1802]	; 0x70a
 800fc52:	461a      	mov	r2, r3
 800fc54:	69bb      	ldr	r3, [r7, #24]
 800fc56:	4413      	add	r3, r2
 800fc58:	61bb      	str	r3, [r7, #24]
        }
        if (connection->address_type == BD_ADDR_TYPE_ACL){
 800fc5a:	68bb      	ldr	r3, [r7, #8]
 800fc5c:	7b1b      	ldrb	r3, [r3, #12]
 800fc5e:	2bfd      	cmp	r3, #253	; 0xfd
 800fc60:	d106      	bne.n	800fc70 <hci_number_free_acl_slots_for_connection_type+0x50>
            num_packets_sent_classic += connection->num_packets_sent;
 800fc62:	68bb      	ldr	r3, [r7, #8]
 800fc64:	f893 370a 	ldrb.w	r3, [r3, #1802]	; 0x70a
 800fc68:	461a      	mov	r2, r3
 800fc6a:	69fb      	ldr	r3, [r7, #28]
 800fc6c:	4413      	add	r3, r2
 800fc6e:	61fb      	str	r3, [r7, #28]
    for (it = (btstack_linked_item_t *) hci_stack->connections; it != NULL; it = it->next){
 800fc70:	697b      	ldr	r3, [r7, #20]
 800fc72:	681b      	ldr	r3, [r3, #0]
 800fc74:	617b      	str	r3, [r7, #20]
 800fc76:	697b      	ldr	r3, [r7, #20]
 800fc78:	2b00      	cmp	r3, #0
 800fc7a:	d1df      	bne.n	800fc3c <hci_number_free_acl_slots_for_connection_type+0x1c>
        }
    }
    log_debug("ACL classic buffers: %u used of %u", num_packets_sent_classic, hci_stack->acl_packets_total_num);
    int free_slots_classic = hci_stack->acl_packets_total_num - num_packets_sent_classic;
 800fc7c:	4b39      	ldr	r3, [pc, #228]	; (800fd64 <hci_number_free_acl_slots_for_connection_type+0x144>)
 800fc7e:	681b      	ldr	r3, [r3, #0]
 800fc80:	f893 36fc 	ldrb.w	r3, [r3, #1788]	; 0x6fc
 800fc84:	461a      	mov	r2, r3
 800fc86:	69fb      	ldr	r3, [r7, #28]
 800fc88:	1ad3      	subs	r3, r2, r3
 800fc8a:	613b      	str	r3, [r7, #16]
    int free_slots_le = 0;
 800fc8c:	2300      	movs	r3, #0
 800fc8e:	60fb      	str	r3, [r7, #12]

    if (free_slots_classic < 0){
 800fc90:	693b      	ldr	r3, [r7, #16]
 800fc92:	2b00      	cmp	r3, #0
 800fc94:	da0f      	bge.n	800fcb6 <hci_number_free_acl_slots_for_connection_type+0x96>
        log_error("hci_number_free_acl_slots: outgoing classic packets (%u) > total classic packets (%u)", num_packets_sent_classic, hci_stack->acl_packets_total_num);
 800fc96:	4b33      	ldr	r3, [pc, #204]	; (800fd64 <hci_number_free_acl_slots_for_connection_type+0x144>)
 800fc98:	681b      	ldr	r3, [r3, #0]
 800fc9a:	f893 36fc 	ldrb.w	r3, [r3, #1788]	; 0x6fc
 800fc9e:	9301      	str	r3, [sp, #4]
 800fca0:	69fb      	ldr	r3, [r7, #28]
 800fca2:	9300      	str	r3, [sp, #0]
 800fca4:	f44f 73f4 	mov.w	r3, #488	; 0x1e8
 800fca8:	4a2f      	ldr	r2, [pc, #188]	; (800fd68 <hci_number_free_acl_slots_for_connection_type+0x148>)
 800fcaa:	4930      	ldr	r1, [pc, #192]	; (800fd6c <hci_number_free_acl_slots_for_connection_type+0x14c>)
 800fcac:	2002      	movs	r0, #2
 800fcae:	f007 fbc7 	bl	8017440 <hci_dump_log>
        return 0;
 800fcb2:	2300      	movs	r3, #0
 800fcb4:	e052      	b.n	800fd5c <hci_number_free_acl_slots_for_connection_type+0x13c>
    }

    if (hci_stack->le_acl_packets_total_num){
 800fcb6:	4b2b      	ldr	r3, [pc, #172]	; (800fd64 <hci_number_free_acl_slots_for_connection_type+0x144>)
 800fcb8:	681b      	ldr	r3, [r3, #0]
 800fcba:	f893 3703 	ldrb.w	r3, [r3, #1795]	; 0x703
 800fcbe:	2b00      	cmp	r3, #0
 800fcc0:	d01a      	beq.n	800fcf8 <hci_number_free_acl_slots_for_connection_type+0xd8>
        // if we have LE slots, they are used
        free_slots_le = hci_stack->le_acl_packets_total_num - num_packets_sent_le;
 800fcc2:	4b28      	ldr	r3, [pc, #160]	; (800fd64 <hci_number_free_acl_slots_for_connection_type+0x144>)
 800fcc4:	681b      	ldr	r3, [r3, #0]
 800fcc6:	f893 3703 	ldrb.w	r3, [r3, #1795]	; 0x703
 800fcca:	461a      	mov	r2, r3
 800fccc:	69bb      	ldr	r3, [r7, #24]
 800fcce:	1ad3      	subs	r3, r2, r3
 800fcd0:	60fb      	str	r3, [r7, #12]
        if (free_slots_le < 0){
 800fcd2:	68fb      	ldr	r3, [r7, #12]
 800fcd4:	2b00      	cmp	r3, #0
 800fcd6:	da28      	bge.n	800fd2a <hci_number_free_acl_slots_for_connection_type+0x10a>
            log_error("hci_number_free_acl_slots: outgoing le packets (%u) > total le packets (%u)", num_packets_sent_le, hci_stack->le_acl_packets_total_num);
 800fcd8:	4b22      	ldr	r3, [pc, #136]	; (800fd64 <hci_number_free_acl_slots_for_connection_type+0x144>)
 800fcda:	681b      	ldr	r3, [r3, #0]
 800fcdc:	f893 3703 	ldrb.w	r3, [r3, #1795]	; 0x703
 800fce0:	9301      	str	r3, [sp, #4]
 800fce2:	69bb      	ldr	r3, [r7, #24]
 800fce4:	9300      	str	r3, [sp, #0]
 800fce6:	f44f 73f8 	mov.w	r3, #496	; 0x1f0
 800fcea:	4a1f      	ldr	r2, [pc, #124]	; (800fd68 <hci_number_free_acl_slots_for_connection_type+0x148>)
 800fcec:	4920      	ldr	r1, [pc, #128]	; (800fd70 <hci_number_free_acl_slots_for_connection_type+0x150>)
 800fcee:	2002      	movs	r0, #2
 800fcf0:	f007 fba6 	bl	8017440 <hci_dump_log>
            return 0;
 800fcf4:	2300      	movs	r3, #0
 800fcf6:	e031      	b.n	800fd5c <hci_number_free_acl_slots_for_connection_type+0x13c>
        }
    } else {
        // otherwise, classic slots are used for LE, too
        free_slots_classic -= num_packets_sent_le;
 800fcf8:	693a      	ldr	r2, [r7, #16]
 800fcfa:	69bb      	ldr	r3, [r7, #24]
 800fcfc:	1ad3      	subs	r3, r2, r3
 800fcfe:	613b      	str	r3, [r7, #16]
        if (free_slots_classic < 0){
 800fd00:	693b      	ldr	r3, [r7, #16]
 800fd02:	2b00      	cmp	r3, #0
 800fd04:	da11      	bge.n	800fd2a <hci_number_free_acl_slots_for_connection_type+0x10a>
            log_error("hci_number_free_acl_slots: outgoing classic + le packets (%u + %u) > total packets (%u)", num_packets_sent_classic, num_packets_sent_le, hci_stack->acl_packets_total_num);
 800fd06:	4b17      	ldr	r3, [pc, #92]	; (800fd64 <hci_number_free_acl_slots_for_connection_type+0x144>)
 800fd08:	681b      	ldr	r3, [r3, #0]
 800fd0a:	f893 36fc 	ldrb.w	r3, [r3, #1788]	; 0x6fc
 800fd0e:	9302      	str	r3, [sp, #8]
 800fd10:	69bb      	ldr	r3, [r7, #24]
 800fd12:	9301      	str	r3, [sp, #4]
 800fd14:	69fb      	ldr	r3, [r7, #28]
 800fd16:	9300      	str	r3, [sp, #0]
 800fd18:	f240 13f7 	movw	r3, #503	; 0x1f7
 800fd1c:	4a12      	ldr	r2, [pc, #72]	; (800fd68 <hci_number_free_acl_slots_for_connection_type+0x148>)
 800fd1e:	4915      	ldr	r1, [pc, #84]	; (800fd74 <hci_number_free_acl_slots_for_connection_type+0x154>)
 800fd20:	2002      	movs	r0, #2
 800fd22:	f007 fb8d 	bl	8017440 <hci_dump_log>
            return 0;
 800fd26:	2300      	movs	r3, #0
 800fd28:	e018      	b.n	800fd5c <hci_number_free_acl_slots_for_connection_type+0x13c>
        }
    }

    switch (address_type){
 800fd2a:	79fb      	ldrb	r3, [r7, #7]
 800fd2c:	2bfd      	cmp	r3, #253	; 0xfd
 800fd2e:	d00a      	beq.n	800fd46 <hci_number_free_acl_slots_for_connection_type+0x126>
 800fd30:	2bfe      	cmp	r3, #254	; 0xfe
 800fd32:	d10a      	bne.n	800fd4a <hci_number_free_acl_slots_for_connection_type+0x12a>
        case BD_ADDR_TYPE_UNKNOWN:
            log_error("hci_number_free_acl_slots: unknown address type");
 800fd34:	f44f 73ff 	mov.w	r3, #510	; 0x1fe
 800fd38:	4a0b      	ldr	r2, [pc, #44]	; (800fd68 <hci_number_free_acl_slots_for_connection_type+0x148>)
 800fd3a:	490f      	ldr	r1, [pc, #60]	; (800fd78 <hci_number_free_acl_slots_for_connection_type+0x158>)
 800fd3c:	2002      	movs	r0, #2
 800fd3e:	f007 fb7f 	bl	8017440 <hci_dump_log>
            return 0;
 800fd42:	2300      	movs	r3, #0
 800fd44:	e00a      	b.n	800fd5c <hci_number_free_acl_slots_for_connection_type+0x13c>

        case BD_ADDR_TYPE_ACL:
            return free_slots_classic;
 800fd46:	693b      	ldr	r3, [r7, #16]
 800fd48:	e008      	b.n	800fd5c <hci_number_free_acl_slots_for_connection_type+0x13c>

        default:
           if (hci_stack->le_acl_packets_total_num){
 800fd4a:	4b06      	ldr	r3, [pc, #24]	; (800fd64 <hci_number_free_acl_slots_for_connection_type+0x144>)
 800fd4c:	681b      	ldr	r3, [r3, #0]
 800fd4e:	f893 3703 	ldrb.w	r3, [r3, #1795]	; 0x703
 800fd52:	2b00      	cmp	r3, #0
 800fd54:	d001      	beq.n	800fd5a <hci_number_free_acl_slots_for_connection_type+0x13a>
               return free_slots_le;
 800fd56:	68fb      	ldr	r3, [r7, #12]
 800fd58:	e000      	b.n	800fd5c <hci_number_free_acl_slots_for_connection_type+0x13c>
           }
           return free_slots_classic; 
 800fd5a:	693b      	ldr	r3, [r7, #16]
    }
}
 800fd5c:	4618      	mov	r0, r3
 800fd5e:	3720      	adds	r7, #32
 800fd60:	46bd      	mov	sp, r7
 800fd62:	bd80      	pop	{r7, pc}
 800fd64:	20009780 	.word	0x20009780
 800fd68:	0802929c 	.word	0x0802929c
 800fd6c:	0802938c 	.word	0x0802938c
 800fd70:	080293ec 	.word	0x080293ec
 800fd74:	08029440 	.word	0x08029440
 800fd78:	080294a0 	.word	0x080294a0

0800fd7c <hci_number_free_acl_slots_for_handle>:

int hci_number_free_acl_slots_for_handle(hci_con_handle_t con_handle){
 800fd7c:	b580      	push	{r7, lr}
 800fd7e:	b086      	sub	sp, #24
 800fd80:	af02      	add	r7, sp, #8
 800fd82:	4603      	mov	r3, r0
 800fd84:	80fb      	strh	r3, [r7, #6]
    // get connection type
    hci_connection_t * connection = hci_connection_for_handle(con_handle);
 800fd86:	88fb      	ldrh	r3, [r7, #6]
 800fd88:	4618      	mov	r0, r3
 800fd8a:	f7ff fd9b 	bl	800f8c4 <hci_connection_for_handle>
 800fd8e:	60f8      	str	r0, [r7, #12]
    if (!connection){
 800fd90:	68fb      	ldr	r3, [r7, #12]
 800fd92:	2b00      	cmp	r3, #0
 800fd94:	d10a      	bne.n	800fdac <hci_number_free_acl_slots_for_handle+0x30>
        log_error("hci_number_free_acl_slots: handle 0x%04x not in connection list", con_handle);
 800fd96:	88fb      	ldrh	r3, [r7, #6]
 800fd98:	9300      	str	r3, [sp, #0]
 800fd9a:	f44f 7304 	mov.w	r3, #528	; 0x210
 800fd9e:	4a08      	ldr	r2, [pc, #32]	; (800fdc0 <hci_number_free_acl_slots_for_handle+0x44>)
 800fda0:	4908      	ldr	r1, [pc, #32]	; (800fdc4 <hci_number_free_acl_slots_for_handle+0x48>)
 800fda2:	2002      	movs	r0, #2
 800fda4:	f007 fb4c 	bl	8017440 <hci_dump_log>
        return 0;
 800fda8:	2300      	movs	r3, #0
 800fdaa:	e005      	b.n	800fdb8 <hci_number_free_acl_slots_for_handle+0x3c>
    }
    return hci_number_free_acl_slots_for_connection_type(connection->address_type);
 800fdac:	68fb      	ldr	r3, [r7, #12]
 800fdae:	7b1b      	ldrb	r3, [r3, #12]
 800fdb0:	4618      	mov	r0, r3
 800fdb2:	f7ff ff35 	bl	800fc20 <hci_number_free_acl_slots_for_connection_type>
 800fdb6:	4603      	mov	r3, r0
}
 800fdb8:	4618      	mov	r0, r3
 800fdba:	3710      	adds	r7, #16
 800fdbc:	46bd      	mov	sp, r7
 800fdbe:	bd80      	pop	{r7, pc}
 800fdc0:	0802929c 	.word	0x0802929c
 800fdc4:	080294d8 	.word	0x080294d8

0800fdc8 <hci_number_free_sco_slots>:

#ifdef ENABLE_CLASSIC
static int hci_number_free_sco_slots(void){
 800fdc8:	b580      	push	{r7, lr}
 800fdca:	b088      	sub	sp, #32
 800fdcc:	af02      	add	r7, sp, #8
    unsigned int num_sco_packets_sent  = 0;
 800fdce:	2300      	movs	r3, #0
 800fdd0:	617b      	str	r3, [r7, #20]
    btstack_linked_item_t *it;
    if (hci_stack->synchronous_flow_control_enabled){
 800fdd2:	4b32      	ldr	r3, [pc, #200]	; (800fe9c <hci_number_free_sco_slots+0xd4>)
 800fdd4:	681b      	ldr	r3, [r3, #0]
 800fdd6:	f893 3702 	ldrb.w	r3, [r3, #1794]	; 0x702
 800fdda:	2b00      	cmp	r3, #0
 800fddc:	d039      	beq.n	800fe52 <hci_number_free_sco_slots+0x8a>
        // explicit flow control
        for (it = (btstack_linked_item_t *) hci_stack->connections; it ; it = it->next){
 800fdde:	4b2f      	ldr	r3, [pc, #188]	; (800fe9c <hci_number_free_sco_slots+0xd4>)
 800fde0:	681b      	ldr	r3, [r3, #0]
 800fde2:	695b      	ldr	r3, [r3, #20]
 800fde4:	613b      	str	r3, [r7, #16]
 800fde6:	e011      	b.n	800fe0c <hci_number_free_sco_slots+0x44>
            hci_connection_t * connection = (hci_connection_t *) it;
 800fde8:	693b      	ldr	r3, [r7, #16]
 800fdea:	607b      	str	r3, [r7, #4]
            if (connection->address_type != BD_ADDR_TYPE_SCO) continue;
 800fdec:	687b      	ldr	r3, [r7, #4]
 800fdee:	7b1b      	ldrb	r3, [r3, #12]
 800fdf0:	2bfc      	cmp	r3, #252	; 0xfc
 800fdf2:	d107      	bne.n	800fe04 <hci_number_free_sco_slots+0x3c>
            num_sco_packets_sent += connection->num_packets_sent;
 800fdf4:	687b      	ldr	r3, [r7, #4]
 800fdf6:	f893 370a 	ldrb.w	r3, [r3, #1802]	; 0x70a
 800fdfa:	461a      	mov	r2, r3
 800fdfc:	697b      	ldr	r3, [r7, #20]
 800fdfe:	4413      	add	r3, r2
 800fe00:	617b      	str	r3, [r7, #20]
 800fe02:	e000      	b.n	800fe06 <hci_number_free_sco_slots+0x3e>
            if (connection->address_type != BD_ADDR_TYPE_SCO) continue;
 800fe04:	bf00      	nop
        for (it = (btstack_linked_item_t *) hci_stack->connections; it ; it = it->next){
 800fe06:	693b      	ldr	r3, [r7, #16]
 800fe08:	681b      	ldr	r3, [r3, #0]
 800fe0a:	613b      	str	r3, [r7, #16]
 800fe0c:	693b      	ldr	r3, [r7, #16]
 800fe0e:	2b00      	cmp	r3, #0
 800fe10:	d1ea      	bne.n	800fde8 <hci_number_free_sco_slots+0x20>
        }
        if (num_sco_packets_sent > hci_stack->sco_packets_total_num){
 800fe12:	4b22      	ldr	r3, [pc, #136]	; (800fe9c <hci_number_free_sco_slots+0xd4>)
 800fe14:	681b      	ldr	r3, [r3, #0]
 800fe16:	f893 3700 	ldrb.w	r3, [r3, #1792]	; 0x700
 800fe1a:	461a      	mov	r2, r3
 800fe1c:	697b      	ldr	r3, [r7, #20]
 800fe1e:	4293      	cmp	r3, r2
 800fe20:	d90f      	bls.n	800fe42 <hci_number_free_sco_slots+0x7a>
            log_info("hci_number_free_sco_slots:packets (%u) > total packets (%u)", num_sco_packets_sent, hci_stack->sco_packets_total_num);
 800fe22:	4b1e      	ldr	r3, [pc, #120]	; (800fe9c <hci_number_free_sco_slots+0xd4>)
 800fe24:	681b      	ldr	r3, [r3, #0]
 800fe26:	f893 3700 	ldrb.w	r3, [r3, #1792]	; 0x700
 800fe2a:	9301      	str	r3, [sp, #4]
 800fe2c:	697b      	ldr	r3, [r7, #20]
 800fe2e:	9300      	str	r3, [sp, #0]
 800fe30:	f240 2322 	movw	r3, #546	; 0x222
 800fe34:	4a1a      	ldr	r2, [pc, #104]	; (800fea0 <hci_number_free_sco_slots+0xd8>)
 800fe36:	491b      	ldr	r1, [pc, #108]	; (800fea4 <hci_number_free_sco_slots+0xdc>)
 800fe38:	2001      	movs	r0, #1
 800fe3a:	f007 fb01 	bl	8017440 <hci_dump_log>
            return 0;
 800fe3e:	2300      	movs	r3, #0
 800fe40:	e027      	b.n	800fe92 <hci_number_free_sco_slots+0xca>
        }
        return hci_stack->sco_packets_total_num - num_sco_packets_sent;
 800fe42:	4b16      	ldr	r3, [pc, #88]	; (800fe9c <hci_number_free_sco_slots+0xd4>)
 800fe44:	681b      	ldr	r3, [r3, #0]
 800fe46:	f893 3700 	ldrb.w	r3, [r3, #1792]	; 0x700
 800fe4a:	461a      	mov	r2, r3
 800fe4c:	697b      	ldr	r3, [r7, #20]
 800fe4e:	1ad3      	subs	r3, r2, r3
 800fe50:	e01f      	b.n	800fe92 <hci_number_free_sco_slots+0xca>
    } else {
        // implicit flow control -- TODO
        int num_ready = 0;
 800fe52:	2300      	movs	r3, #0
 800fe54:	60fb      	str	r3, [r7, #12]
        for (it = (btstack_linked_item_t *) hci_stack->connections; it ; it = it->next){
 800fe56:	4b11      	ldr	r3, [pc, #68]	; (800fe9c <hci_number_free_sco_slots+0xd4>)
 800fe58:	681b      	ldr	r3, [r3, #0]
 800fe5a:	695b      	ldr	r3, [r3, #20]
 800fe5c:	613b      	str	r3, [r7, #16]
 800fe5e:	e014      	b.n	800fe8a <hci_number_free_sco_slots+0xc2>
            hci_connection_t * connection = (hci_connection_t *) it;
 800fe60:	693b      	ldr	r3, [r7, #16]
 800fe62:	60bb      	str	r3, [r7, #8]
            if (connection->address_type != BD_ADDR_TYPE_SCO) continue;
 800fe64:	68bb      	ldr	r3, [r7, #8]
 800fe66:	7b1b      	ldrb	r3, [r3, #12]
 800fe68:	2bfc      	cmp	r3, #252	; 0xfc
 800fe6a:	d108      	bne.n	800fe7e <hci_number_free_sco_slots+0xb6>
            if (connection->sco_tx_ready == 0) continue;
 800fe6c:	68bb      	ldr	r3, [r7, #8]
 800fe6e:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 800fe72:	2b00      	cmp	r3, #0
 800fe74:	d005      	beq.n	800fe82 <hci_number_free_sco_slots+0xba>
            num_ready++;
 800fe76:	68fb      	ldr	r3, [r7, #12]
 800fe78:	3301      	adds	r3, #1
 800fe7a:	60fb      	str	r3, [r7, #12]
 800fe7c:	e002      	b.n	800fe84 <hci_number_free_sco_slots+0xbc>
            if (connection->address_type != BD_ADDR_TYPE_SCO) continue;
 800fe7e:	bf00      	nop
 800fe80:	e000      	b.n	800fe84 <hci_number_free_sco_slots+0xbc>
            if (connection->sco_tx_ready == 0) continue;
 800fe82:	bf00      	nop
        for (it = (btstack_linked_item_t *) hci_stack->connections; it ; it = it->next){
 800fe84:	693b      	ldr	r3, [r7, #16]
 800fe86:	681b      	ldr	r3, [r3, #0]
 800fe88:	613b      	str	r3, [r7, #16]
 800fe8a:	693b      	ldr	r3, [r7, #16]
 800fe8c:	2b00      	cmp	r3, #0
 800fe8e:	d1e7      	bne.n	800fe60 <hci_number_free_sco_slots+0x98>
        }
        return num_ready;
 800fe90:	68fb      	ldr	r3, [r7, #12]
    }
}
 800fe92:	4618      	mov	r0, r3
 800fe94:	3718      	adds	r7, #24
 800fe96:	46bd      	mov	sp, r7
 800fe98:	bd80      	pop	{r7, pc}
 800fe9a:	bf00      	nop
 800fe9c:	20009780 	.word	0x20009780
 800fea0:	0802929c 	.word	0x0802929c
 800fea4:	08029520 	.word	0x08029520

0800fea8 <hci_can_send_comand_packet_transport>:
#endif

// only used to send HCI Host Number Completed Packets
static int hci_can_send_comand_packet_transport(void){
 800fea8:	b580      	push	{r7, lr}
 800feaa:	af00      	add	r7, sp, #0
    if (hci_stack->hci_packet_buffer_reserved) return 0;
 800feac:	4b0d      	ldr	r3, [pc, #52]	; (800fee4 <hci_can_send_comand_packet_transport+0x3c>)
 800feae:	681b      	ldr	r3, [r3, #0]
 800feb0:	f893 36f4 	ldrb.w	r3, [r3, #1780]	; 0x6f4
 800feb4:	2b00      	cmp	r3, #0
 800feb6:	d001      	beq.n	800febc <hci_can_send_comand_packet_transport+0x14>
 800feb8:	2300      	movs	r3, #0
 800feba:	e011      	b.n	800fee0 <hci_can_send_comand_packet_transport+0x38>

    // check for async hci transport implementations
    if (hci_stack->hci_transport->can_send_packet_now){
 800febc:	4b09      	ldr	r3, [pc, #36]	; (800fee4 <hci_can_send_comand_packet_transport+0x3c>)
 800febe:	681b      	ldr	r3, [r3, #0]
 800fec0:	681b      	ldr	r3, [r3, #0]
 800fec2:	695b      	ldr	r3, [r3, #20]
 800fec4:	2b00      	cmp	r3, #0
 800fec6:	d00a      	beq.n	800fede <hci_can_send_comand_packet_transport+0x36>
        if (!hci_stack->hci_transport->can_send_packet_now(HCI_COMMAND_DATA_PACKET)){
 800fec8:	4b06      	ldr	r3, [pc, #24]	; (800fee4 <hci_can_send_comand_packet_transport+0x3c>)
 800feca:	681b      	ldr	r3, [r3, #0]
 800fecc:	681b      	ldr	r3, [r3, #0]
 800fece:	695b      	ldr	r3, [r3, #20]
 800fed0:	2001      	movs	r0, #1
 800fed2:	4798      	blx	r3
 800fed4:	4603      	mov	r3, r0
 800fed6:	2b00      	cmp	r3, #0
 800fed8:	d101      	bne.n	800fede <hci_can_send_comand_packet_transport+0x36>
            return 0;
 800feda:	2300      	movs	r3, #0
 800fedc:	e000      	b.n	800fee0 <hci_can_send_comand_packet_transport+0x38>
        }
    }
    return 1;
 800fede:	2301      	movs	r3, #1
}
 800fee0:	4618      	mov	r0, r3
 800fee2:	bd80      	pop	{r7, pc}
 800fee4:	20009780 	.word	0x20009780

0800fee8 <hci_can_send_command_packet_now>:

// new functions replacing hci_can_send_packet_now[_using_packet_buffer]
int hci_can_send_command_packet_now(void){
 800fee8:	b580      	push	{r7, lr}
 800feea:	af00      	add	r7, sp, #0
    if (hci_can_send_comand_packet_transport() == 0) return 0;
 800feec:	f7ff ffdc 	bl	800fea8 <hci_can_send_comand_packet_transport>
 800fef0:	4603      	mov	r3, r0
 800fef2:	2b00      	cmp	r3, #0
 800fef4:	d101      	bne.n	800fefa <hci_can_send_command_packet_now+0x12>
 800fef6:	2300      	movs	r3, #0
 800fef8:	e008      	b.n	800ff0c <hci_can_send_command_packet_now+0x24>
    return hci_stack->num_cmd_packets > 0u;
 800fefa:	4b05      	ldr	r3, [pc, #20]	; (800ff10 <hci_can_send_command_packet_now+0x28>)
 800fefc:	681b      	ldr	r3, [r3, #0]
 800fefe:	f893 36fb 	ldrb.w	r3, [r3, #1787]	; 0x6fb
 800ff02:	2b00      	cmp	r3, #0
 800ff04:	bf14      	ite	ne
 800ff06:	2301      	movne	r3, #1
 800ff08:	2300      	moveq	r3, #0
 800ff0a:	b2db      	uxtb	r3, r3
}
 800ff0c:	4618      	mov	r0, r3
 800ff0e:	bd80      	pop	{r7, pc}
 800ff10:	20009780 	.word	0x20009780

0800ff14 <hci_transport_can_send_prepared_packet_now>:

static int hci_transport_can_send_prepared_packet_now(uint8_t packet_type){
 800ff14:	b580      	push	{r7, lr}
 800ff16:	b082      	sub	sp, #8
 800ff18:	af00      	add	r7, sp, #0
 800ff1a:	4603      	mov	r3, r0
 800ff1c:	71fb      	strb	r3, [r7, #7]
    // check for async hci transport implementations
    if (!hci_stack->hci_transport->can_send_packet_now) return 1;
 800ff1e:	4b0a      	ldr	r3, [pc, #40]	; (800ff48 <hci_transport_can_send_prepared_packet_now+0x34>)
 800ff20:	681b      	ldr	r3, [r3, #0]
 800ff22:	681b      	ldr	r3, [r3, #0]
 800ff24:	695b      	ldr	r3, [r3, #20]
 800ff26:	2b00      	cmp	r3, #0
 800ff28:	d101      	bne.n	800ff2e <hci_transport_can_send_prepared_packet_now+0x1a>
 800ff2a:	2301      	movs	r3, #1
 800ff2c:	e007      	b.n	800ff3e <hci_transport_can_send_prepared_packet_now+0x2a>
    return hci_stack->hci_transport->can_send_packet_now(packet_type);
 800ff2e:	4b06      	ldr	r3, [pc, #24]	; (800ff48 <hci_transport_can_send_prepared_packet_now+0x34>)
 800ff30:	681b      	ldr	r3, [r3, #0]
 800ff32:	681b      	ldr	r3, [r3, #0]
 800ff34:	695b      	ldr	r3, [r3, #20]
 800ff36:	79fa      	ldrb	r2, [r7, #7]
 800ff38:	4610      	mov	r0, r2
 800ff3a:	4798      	blx	r3
 800ff3c:	4603      	mov	r3, r0
}
 800ff3e:	4618      	mov	r0, r3
 800ff40:	3708      	adds	r7, #8
 800ff42:	46bd      	mov	sp, r7
 800ff44:	bd80      	pop	{r7, pc}
 800ff46:	bf00      	nop
 800ff48:	20009780 	.word	0x20009780

0800ff4c <hci_can_send_prepared_acl_packet_for_address_type>:

static int hci_can_send_prepared_acl_packet_for_address_type(bd_addr_type_t address_type){
 800ff4c:	b580      	push	{r7, lr}
 800ff4e:	b082      	sub	sp, #8
 800ff50:	af00      	add	r7, sp, #0
 800ff52:	4603      	mov	r3, r0
 800ff54:	71fb      	strb	r3, [r7, #7]
    if (!hci_transport_can_send_prepared_packet_now(HCI_ACL_DATA_PACKET)) return 0;
 800ff56:	2002      	movs	r0, #2
 800ff58:	f7ff ffdc 	bl	800ff14 <hci_transport_can_send_prepared_packet_now>
 800ff5c:	4603      	mov	r3, r0
 800ff5e:	2b00      	cmp	r3, #0
 800ff60:	d101      	bne.n	800ff66 <hci_can_send_prepared_acl_packet_for_address_type+0x1a>
 800ff62:	2300      	movs	r3, #0
 800ff64:	e009      	b.n	800ff7a <hci_can_send_prepared_acl_packet_for_address_type+0x2e>
    return hci_number_free_acl_slots_for_connection_type(address_type) > 0;
 800ff66:	79fb      	ldrb	r3, [r7, #7]
 800ff68:	4618      	mov	r0, r3
 800ff6a:	f7ff fe59 	bl	800fc20 <hci_number_free_acl_slots_for_connection_type>
 800ff6e:	4603      	mov	r3, r0
 800ff70:	2b00      	cmp	r3, #0
 800ff72:	bfcc      	ite	gt
 800ff74:	2301      	movgt	r3, #1
 800ff76:	2300      	movle	r3, #0
 800ff78:	b2db      	uxtb	r3, r3
}
 800ff7a:	4618      	mov	r0, r3
 800ff7c:	3708      	adds	r7, #8
 800ff7e:	46bd      	mov	sp, r7
 800ff80:	bd80      	pop	{r7, pc}
	...

0800ff84 <hci_can_send_acl_le_packet_now>:

int hci_can_send_acl_le_packet_now(void){
 800ff84:	b580      	push	{r7, lr}
 800ff86:	af00      	add	r7, sp, #0
    if (hci_stack->hci_packet_buffer_reserved) return 0;
 800ff88:	4b06      	ldr	r3, [pc, #24]	; (800ffa4 <hci_can_send_acl_le_packet_now+0x20>)
 800ff8a:	681b      	ldr	r3, [r3, #0]
 800ff8c:	f893 36f4 	ldrb.w	r3, [r3, #1780]	; 0x6f4
 800ff90:	2b00      	cmp	r3, #0
 800ff92:	d001      	beq.n	800ff98 <hci_can_send_acl_le_packet_now+0x14>
 800ff94:	2300      	movs	r3, #0
 800ff96:	e003      	b.n	800ffa0 <hci_can_send_acl_le_packet_now+0x1c>
    return hci_can_send_prepared_acl_packet_for_address_type(BD_ADDR_TYPE_LE_PUBLIC);
 800ff98:	2000      	movs	r0, #0
 800ff9a:	f7ff ffd7 	bl	800ff4c <hci_can_send_prepared_acl_packet_for_address_type>
 800ff9e:	4603      	mov	r3, r0
}
 800ffa0:	4618      	mov	r0, r3
 800ffa2:	bd80      	pop	{r7, pc}
 800ffa4:	20009780 	.word	0x20009780

0800ffa8 <hci_can_send_prepared_acl_packet_now>:

int hci_can_send_prepared_acl_packet_now(hci_con_handle_t con_handle) {
 800ffa8:	b580      	push	{r7, lr}
 800ffaa:	b082      	sub	sp, #8
 800ffac:	af00      	add	r7, sp, #0
 800ffae:	4603      	mov	r3, r0
 800ffb0:	80fb      	strh	r3, [r7, #6]
    if (!hci_transport_can_send_prepared_packet_now(HCI_ACL_DATA_PACKET)) return 0;
 800ffb2:	2002      	movs	r0, #2
 800ffb4:	f7ff ffae 	bl	800ff14 <hci_transport_can_send_prepared_packet_now>
 800ffb8:	4603      	mov	r3, r0
 800ffba:	2b00      	cmp	r3, #0
 800ffbc:	d101      	bne.n	800ffc2 <hci_can_send_prepared_acl_packet_now+0x1a>
 800ffbe:	2300      	movs	r3, #0
 800ffc0:	e009      	b.n	800ffd6 <hci_can_send_prepared_acl_packet_now+0x2e>
    return hci_number_free_acl_slots_for_handle(con_handle) > 0;
 800ffc2:	88fb      	ldrh	r3, [r7, #6]
 800ffc4:	4618      	mov	r0, r3
 800ffc6:	f7ff fed9 	bl	800fd7c <hci_number_free_acl_slots_for_handle>
 800ffca:	4603      	mov	r3, r0
 800ffcc:	2b00      	cmp	r3, #0
 800ffce:	bfcc      	ite	gt
 800ffd0:	2301      	movgt	r3, #1
 800ffd2:	2300      	movle	r3, #0
 800ffd4:	b2db      	uxtb	r3, r3
}
 800ffd6:	4618      	mov	r0, r3
 800ffd8:	3708      	adds	r7, #8
 800ffda:	46bd      	mov	sp, r7
 800ffdc:	bd80      	pop	{r7, pc}
	...

0800ffe0 <hci_can_send_acl_packet_now>:

int hci_can_send_acl_packet_now(hci_con_handle_t con_handle){
 800ffe0:	b580      	push	{r7, lr}
 800ffe2:	b082      	sub	sp, #8
 800ffe4:	af00      	add	r7, sp, #0
 800ffe6:	4603      	mov	r3, r0
 800ffe8:	80fb      	strh	r3, [r7, #6]
    if (hci_stack->hci_packet_buffer_reserved) return 0;
 800ffea:	4b08      	ldr	r3, [pc, #32]	; (801000c <hci_can_send_acl_packet_now+0x2c>)
 800ffec:	681b      	ldr	r3, [r3, #0]
 800ffee:	f893 36f4 	ldrb.w	r3, [r3, #1780]	; 0x6f4
 800fff2:	2b00      	cmp	r3, #0
 800fff4:	d001      	beq.n	800fffa <hci_can_send_acl_packet_now+0x1a>
 800fff6:	2300      	movs	r3, #0
 800fff8:	e004      	b.n	8010004 <hci_can_send_acl_packet_now+0x24>
    return hci_can_send_prepared_acl_packet_now(con_handle);
 800fffa:	88fb      	ldrh	r3, [r7, #6]
 800fffc:	4618      	mov	r0, r3
 800fffe:	f7ff ffd3 	bl	800ffa8 <hci_can_send_prepared_acl_packet_now>
 8010002:	4603      	mov	r3, r0
}
 8010004:	4618      	mov	r0, r3
 8010006:	3708      	adds	r7, #8
 8010008:	46bd      	mov	sp, r7
 801000a:	bd80      	pop	{r7, pc}
 801000c:	20009780 	.word	0x20009780

08010010 <hci_can_send_acl_classic_packet_now>:

#ifdef ENABLE_CLASSIC
int hci_can_send_acl_classic_packet_now(void){
 8010010:	b580      	push	{r7, lr}
 8010012:	af00      	add	r7, sp, #0
    if (hci_stack->hci_packet_buffer_reserved) return 0;
 8010014:	4b06      	ldr	r3, [pc, #24]	; (8010030 <hci_can_send_acl_classic_packet_now+0x20>)
 8010016:	681b      	ldr	r3, [r3, #0]
 8010018:	f893 36f4 	ldrb.w	r3, [r3, #1780]	; 0x6f4
 801001c:	2b00      	cmp	r3, #0
 801001e:	d001      	beq.n	8010024 <hci_can_send_acl_classic_packet_now+0x14>
 8010020:	2300      	movs	r3, #0
 8010022:	e003      	b.n	801002c <hci_can_send_acl_classic_packet_now+0x1c>
    return hci_can_send_prepared_acl_packet_for_address_type(BD_ADDR_TYPE_ACL);
 8010024:	20fd      	movs	r0, #253	; 0xfd
 8010026:	f7ff ff91 	bl	800ff4c <hci_can_send_prepared_acl_packet_for_address_type>
 801002a:	4603      	mov	r3, r0
}
 801002c:	4618      	mov	r0, r3
 801002e:	bd80      	pop	{r7, pc}
 8010030:	20009780 	.word	0x20009780

08010034 <hci_can_send_prepared_sco_packet_now>:

int hci_can_send_prepared_sco_packet_now(void){
 8010034:	b580      	push	{r7, lr}
 8010036:	af00      	add	r7, sp, #0
    if (!hci_transport_can_send_prepared_packet_now(HCI_SCO_DATA_PACKET)) return 0;
 8010038:	2003      	movs	r0, #3
 801003a:	f7ff ff6b 	bl	800ff14 <hci_transport_can_send_prepared_packet_now>
 801003e:	4603      	mov	r3, r0
 8010040:	2b00      	cmp	r3, #0
 8010042:	d101      	bne.n	8010048 <hci_can_send_prepared_sco_packet_now+0x14>
 8010044:	2300      	movs	r3, #0
 8010046:	e011      	b.n	801006c <hci_can_send_prepared_sco_packet_now+0x38>
    if (hci_have_usb_transport()){
 8010048:	f006 fd5c 	bl	8016b04 <hci_have_usb_transport>
 801004c:	4603      	mov	r3, r0
 801004e:	2b00      	cmp	r3, #0
 8010050:	d004      	beq.n	801005c <hci_can_send_prepared_sco_packet_now+0x28>
        return hci_stack->sco_can_send_now;
 8010052:	4b07      	ldr	r3, [pc, #28]	; (8010070 <hci_can_send_prepared_sco_packet_now+0x3c>)
 8010054:	681b      	ldr	r3, [r3, #0]
 8010056:	f893 3707 	ldrb.w	r3, [r3, #1799]	; 0x707
 801005a:	e007      	b.n	801006c <hci_can_send_prepared_sco_packet_now+0x38>
    } else {
        return hci_number_free_sco_slots() > 0;    
 801005c:	f7ff feb4 	bl	800fdc8 <hci_number_free_sco_slots>
 8010060:	4603      	mov	r3, r0
 8010062:	2b00      	cmp	r3, #0
 8010064:	bfcc      	ite	gt
 8010066:	2301      	movgt	r3, #1
 8010068:	2300      	movle	r3, #0
 801006a:	b2db      	uxtb	r3, r3
    }
}
 801006c:	4618      	mov	r0, r3
 801006e:	bd80      	pop	{r7, pc}
 8010070:	20009780 	.word	0x20009780

08010074 <hci_can_send_sco_packet_now>:

int hci_can_send_sco_packet_now(void){
 8010074:	b580      	push	{r7, lr}
 8010076:	af00      	add	r7, sp, #0
    if (hci_stack->hci_packet_buffer_reserved) return 0;
 8010078:	4b06      	ldr	r3, [pc, #24]	; (8010094 <hci_can_send_sco_packet_now+0x20>)
 801007a:	681b      	ldr	r3, [r3, #0]
 801007c:	f893 36f4 	ldrb.w	r3, [r3, #1780]	; 0x6f4
 8010080:	2b00      	cmp	r3, #0
 8010082:	d001      	beq.n	8010088 <hci_can_send_sco_packet_now+0x14>
 8010084:	2300      	movs	r3, #0
 8010086:	e002      	b.n	801008e <hci_can_send_sco_packet_now+0x1a>
    return hci_can_send_prepared_sco_packet_now();
 8010088:	f7ff ffd4 	bl	8010034 <hci_can_send_prepared_sco_packet_now>
 801008c:	4603      	mov	r3, r0
}
 801008e:	4618      	mov	r0, r3
 8010090:	bd80      	pop	{r7, pc}
 8010092:	bf00      	nop
 8010094:	20009780 	.word	0x20009780

08010098 <hci_is_packet_buffer_reserved>:
    hci_notify_if_sco_can_send_now();
}
#endif

// used for internal checks in l2cap.c
int hci_is_packet_buffer_reserved(void){
 8010098:	b480      	push	{r7}
 801009a:	af00      	add	r7, sp, #0
    return hci_stack->hci_packet_buffer_reserved;
 801009c:	4b04      	ldr	r3, [pc, #16]	; (80100b0 <hci_is_packet_buffer_reserved+0x18>)
 801009e:	681b      	ldr	r3, [r3, #0]
 80100a0:	f893 36f4 	ldrb.w	r3, [r3, #1780]	; 0x6f4
}
 80100a4:	4618      	mov	r0, r3
 80100a6:	46bd      	mov	sp, r7
 80100a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80100ac:	4770      	bx	lr
 80100ae:	bf00      	nop
 80100b0:	20009780 	.word	0x20009780

080100b4 <hci_reserve_packet_buffer>:

// reserves outgoing packet buffer. @returns 1 if successful
int hci_reserve_packet_buffer(void){
 80100b4:	b580      	push	{r7, lr}
 80100b6:	af00      	add	r7, sp, #0
    if (hci_stack->hci_packet_buffer_reserved) {
 80100b8:	4b0b      	ldr	r3, [pc, #44]	; (80100e8 <hci_reserve_packet_buffer+0x34>)
 80100ba:	681b      	ldr	r3, [r3, #0]
 80100bc:	f893 36f4 	ldrb.w	r3, [r3, #1780]	; 0x6f4
 80100c0:	2b00      	cmp	r3, #0
 80100c2:	d008      	beq.n	80100d6 <hci_reserve_packet_buffer+0x22>
        log_error("hci_reserve_packet_buffer called but buffer already reserved");
 80100c4:	f240 2383 	movw	r3, #643	; 0x283
 80100c8:	4a08      	ldr	r2, [pc, #32]	; (80100ec <hci_reserve_packet_buffer+0x38>)
 80100ca:	4909      	ldr	r1, [pc, #36]	; (80100f0 <hci_reserve_packet_buffer+0x3c>)
 80100cc:	2002      	movs	r0, #2
 80100ce:	f007 f9b7 	bl	8017440 <hci_dump_log>
        return 0;
 80100d2:	2300      	movs	r3, #0
 80100d4:	e005      	b.n	80100e2 <hci_reserve_packet_buffer+0x2e>
    }
    hci_stack->hci_packet_buffer_reserved = 1;
 80100d6:	4b04      	ldr	r3, [pc, #16]	; (80100e8 <hci_reserve_packet_buffer+0x34>)
 80100d8:	681b      	ldr	r3, [r3, #0]
 80100da:	2201      	movs	r2, #1
 80100dc:	f883 26f4 	strb.w	r2, [r3, #1780]	; 0x6f4
    return 1;    
 80100e0:	2301      	movs	r3, #1
}
 80100e2:	4618      	mov	r0, r3
 80100e4:	bd80      	pop	{r7, pc}
 80100e6:	bf00      	nop
 80100e8:	20009780 	.word	0x20009780
 80100ec:	0802929c 	.word	0x0802929c
 80100f0:	08029564 	.word	0x08029564

080100f4 <hci_release_packet_buffer>:

void hci_release_packet_buffer(void){
 80100f4:	b480      	push	{r7}
 80100f6:	af00      	add	r7, sp, #0
    hci_stack->hci_packet_buffer_reserved = 0;
 80100f8:	4b04      	ldr	r3, [pc, #16]	; (801010c <hci_release_packet_buffer+0x18>)
 80100fa:	681b      	ldr	r3, [r3, #0]
 80100fc:	2200      	movs	r2, #0
 80100fe:	f883 26f4 	strb.w	r2, [r3, #1780]	; 0x6f4
}
 8010102:	bf00      	nop
 8010104:	46bd      	mov	sp, r7
 8010106:	f85d 7b04 	ldr.w	r7, [sp], #4
 801010a:	4770      	bx	lr
 801010c:	20009780 	.word	0x20009780

08010110 <hci_transport_synchronous>:

// assumption: synchronous implementations don't provide can_send_packet_now as they don't keep the buffer after the call
static int hci_transport_synchronous(void){
 8010110:	b480      	push	{r7}
 8010112:	af00      	add	r7, sp, #0
    return hci_stack->hci_transport->can_send_packet_now == NULL;
 8010114:	4b06      	ldr	r3, [pc, #24]	; (8010130 <hci_transport_synchronous+0x20>)
 8010116:	681b      	ldr	r3, [r3, #0]
 8010118:	681b      	ldr	r3, [r3, #0]
 801011a:	695b      	ldr	r3, [r3, #20]
 801011c:	2b00      	cmp	r3, #0
 801011e:	bf0c      	ite	eq
 8010120:	2301      	moveq	r3, #1
 8010122:	2300      	movne	r3, #0
 8010124:	b2db      	uxtb	r3, r3
}
 8010126:	4618      	mov	r0, r3
 8010128:	46bd      	mov	sp, r7
 801012a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801012e:	4770      	bx	lr
 8010130:	20009780 	.word	0x20009780

08010134 <hci_send_acl_packet_fragments>:

static int hci_send_acl_packet_fragments(hci_connection_t *connection){
 8010134:	b580      	push	{r7, lr}
 8010136:	b08a      	sub	sp, #40	; 0x28
 8010138:	af00      	add	r7, sp, #0
 801013a:	6078      	str	r0, [r7, #4]

    // log_info("hci_send_acl_packet_fragments  %u/%u (con 0x%04x)", hci_stack->acl_fragmentation_pos, hci_stack->acl_fragmentation_total_size, connection->con_handle);

    // max ACL data packet length depends on connection type (LE vs. Classic) and available buffers
    uint16_t max_acl_data_packet_length = hci_stack->acl_data_packet_length;
 801013c:	4b5d      	ldr	r3, [pc, #372]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 801013e:	681b      	ldr	r3, [r3, #0]
 8010140:	f8b3 36fe 	ldrh.w	r3, [r3, #1790]	; 0x6fe
 8010144:	84fb      	strh	r3, [r7, #38]	; 0x26
    if (hci_is_le_connection(connection) && (hci_stack->le_data_packets_length > 0u)){
 8010146:	6878      	ldr	r0, [r7, #4]
 8010148:	f7ff fd40 	bl	800fbcc <hci_is_le_connection>
 801014c:	4603      	mov	r3, r0
 801014e:	2b00      	cmp	r3, #0
 8010150:	d00a      	beq.n	8010168 <hci_send_acl_packet_fragments+0x34>
 8010152:	4b58      	ldr	r3, [pc, #352]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 8010154:	681b      	ldr	r3, [r3, #0]
 8010156:	f8b3 3704 	ldrh.w	r3, [r3, #1796]	; 0x704
 801015a:	2b00      	cmp	r3, #0
 801015c:	d004      	beq.n	8010168 <hci_send_acl_packet_fragments+0x34>
        max_acl_data_packet_length = hci_stack->le_data_packets_length;
 801015e:	4b55      	ldr	r3, [pc, #340]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 8010160:	681b      	ldr	r3, [r3, #0]
 8010162:	f8b3 3704 	ldrh.w	r3, [r3, #1796]	; 0x704
 8010166:	84fb      	strh	r3, [r7, #38]	; 0x26
    while (true){

        log_debug("hci_send_acl_packet_fragments loop entered");

        // get current data
        const uint16_t acl_header_pos = hci_stack->acl_fragmentation_pos - 4u;
 8010168:	4b52      	ldr	r3, [pc, #328]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 801016a:	681b      	ldr	r3, [r3, #0]
 801016c:	f8b3 36f6 	ldrh.w	r3, [r3, #1782]	; 0x6f6
 8010170:	3b04      	subs	r3, #4
 8010172:	83bb      	strh	r3, [r7, #28]
        int current_acl_data_packet_length = hci_stack->acl_fragmentation_total_size - hci_stack->acl_fragmentation_pos;
 8010174:	4b4f      	ldr	r3, [pc, #316]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 8010176:	681b      	ldr	r3, [r3, #0]
 8010178:	f8b3 36f8 	ldrh.w	r3, [r3, #1784]	; 0x6f8
 801017c:	461a      	mov	r2, r3
 801017e:	4b4d      	ldr	r3, [pc, #308]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 8010180:	681b      	ldr	r3, [r3, #0]
 8010182:	f8b3 36f6 	ldrh.w	r3, [r3, #1782]	; 0x6f6
 8010186:	1ad3      	subs	r3, r2, r3
 8010188:	623b      	str	r3, [r7, #32]
        bool more_fragments = false;
 801018a:	2300      	movs	r3, #0
 801018c:	77fb      	strb	r3, [r7, #31]

        // if ACL packet is larger than Bluetooth packet buffer, only send max_acl_data_packet_length
        if (current_acl_data_packet_length > max_acl_data_packet_length){
 801018e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8010190:	6a3a      	ldr	r2, [r7, #32]
 8010192:	429a      	cmp	r2, r3
 8010194:	dd03      	ble.n	801019e <hci_send_acl_packet_fragments+0x6a>
            more_fragments = true;
 8010196:	2301      	movs	r3, #1
 8010198:	77fb      	strb	r3, [r7, #31]
            current_acl_data_packet_length = max_acl_data_packet_length;
 801019a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801019c:	623b      	str	r3, [r7, #32]
        }

        // copy handle_and_flags if not first fragment and update packet boundary flags to be 01 (continuing fragmnent)
        if (acl_header_pos > 0u){
 801019e:	8bbb      	ldrh	r3, [r7, #28]
 80101a0:	2b00      	cmp	r3, #0
 80101a2:	d017      	beq.n	80101d4 <hci_send_acl_packet_fragments+0xa0>
            uint16_t handle_and_flags = little_endian_read_16(hci_stack->hci_packet_buffer, 0);
 80101a4:	4b43      	ldr	r3, [pc, #268]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 80101a6:	681b      	ldr	r3, [r3, #0]
 80101a8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80101aa:	2100      	movs	r1, #0
 80101ac:	4618      	mov	r0, r3
 80101ae:	f7fe fe1a 	bl	800ede6 <little_endian_read_16>
 80101b2:	4603      	mov	r3, r0
 80101b4:	837b      	strh	r3, [r7, #26]
            handle_and_flags = (handle_and_flags & 0xcfffu) | (1u << 12u);
 80101b6:	8b7b      	ldrh	r3, [r7, #26]
 80101b8:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80101bc:	b29b      	uxth	r3, r3
 80101be:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80101c2:	837b      	strh	r3, [r7, #26]
            little_endian_store_16(hci_stack->hci_packet_buffer, acl_header_pos, handle_and_flags);
 80101c4:	4b3b      	ldr	r3, [pc, #236]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 80101c6:	681b      	ldr	r3, [r3, #0]
 80101c8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80101ca:	8b7a      	ldrh	r2, [r7, #26]
 80101cc:	8bb9      	ldrh	r1, [r7, #28]
 80101ce:	4618      	mov	r0, r3
 80101d0:	f7fe fe49 	bl	800ee66 <little_endian_store_16>
        }

        // update header len
        little_endian_store_16(hci_stack->hci_packet_buffer, acl_header_pos + 2u, current_acl_data_packet_length);
 80101d4:	4b37      	ldr	r3, [pc, #220]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 80101d6:	681b      	ldr	r3, [r3, #0]
 80101d8:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
 80101da:	8bbb      	ldrh	r3, [r7, #28]
 80101dc:	3302      	adds	r3, #2
 80101de:	b29b      	uxth	r3, r3
 80101e0:	6a3a      	ldr	r2, [r7, #32]
 80101e2:	b292      	uxth	r2, r2
 80101e4:	4619      	mov	r1, r3
 80101e6:	f7fe fe3e 	bl	800ee66 <little_endian_store_16>

        // count packet
        connection->num_packets_sent++;
 80101ea:	687b      	ldr	r3, [r7, #4]
 80101ec:	f893 370a 	ldrb.w	r3, [r3, #1802]	; 0x70a
 80101f0:	3301      	adds	r3, #1
 80101f2:	b2da      	uxtb	r2, r3
 80101f4:	687b      	ldr	r3, [r7, #4]
 80101f6:	f883 270a 	strb.w	r2, [r3, #1802]	; 0x70a
        log_debug("hci_send_acl_packet_fragments loop before send (more fragments %d)", (int) more_fragments);

        // update state for next fragment (if any) as "transport done" might be sent during send_packet already
        if (more_fragments){
 80101fa:	7ffb      	ldrb	r3, [r7, #31]
 80101fc:	2b00      	cmp	r3, #0
 80101fe:	d00c      	beq.n	801021a <hci_send_acl_packet_fragments+0xe6>
            // update start of next fragment to send
            hci_stack->acl_fragmentation_pos += current_acl_data_packet_length;
 8010200:	4b2c      	ldr	r3, [pc, #176]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 8010202:	681b      	ldr	r3, [r3, #0]
 8010204:	f8b3 16f6 	ldrh.w	r1, [r3, #1782]	; 0x6f6
 8010208:	6a3b      	ldr	r3, [r7, #32]
 801020a:	b29a      	uxth	r2, r3
 801020c:	4b29      	ldr	r3, [pc, #164]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 801020e:	681b      	ldr	r3, [r3, #0]
 8010210:	440a      	add	r2, r1
 8010212:	b292      	uxth	r2, r2
 8010214:	f8a3 26f6 	strh.w	r2, [r3, #1782]	; 0x6f6
 8010218:	e009      	b.n	801022e <hci_send_acl_packet_fragments+0xfa>
        } else {
            // done
            hci_stack->acl_fragmentation_pos = 0;
 801021a:	4b26      	ldr	r3, [pc, #152]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 801021c:	681b      	ldr	r3, [r3, #0]
 801021e:	2200      	movs	r2, #0
 8010220:	f8a3 26f6 	strh.w	r2, [r3, #1782]	; 0x6f6
            hci_stack->acl_fragmentation_total_size = 0;
 8010224:	4b23      	ldr	r3, [pc, #140]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 8010226:	681b      	ldr	r3, [r3, #0]
 8010228:	2200      	movs	r2, #0
 801022a:	f8a3 26f8 	strh.w	r2, [r3, #1784]	; 0x6f8
        }

        // send packet
        uint8_t * packet = &hci_stack->hci_packet_buffer[acl_header_pos];
 801022e:	4b21      	ldr	r3, [pc, #132]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 8010230:	681b      	ldr	r3, [r3, #0]
 8010232:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8010234:	8bbb      	ldrh	r3, [r7, #28]
 8010236:	4413      	add	r3, r2
 8010238:	617b      	str	r3, [r7, #20]
        const int size = current_acl_data_packet_length + 4;
 801023a:	6a3b      	ldr	r3, [r7, #32]
 801023c:	3304      	adds	r3, #4
 801023e:	613b      	str	r3, [r7, #16]
        hci_dump_packet(HCI_ACL_DATA_PACKET, 0, packet, size);
 8010240:	693b      	ldr	r3, [r7, #16]
 8010242:	b29b      	uxth	r3, r3
 8010244:	697a      	ldr	r2, [r7, #20]
 8010246:	2100      	movs	r1, #0
 8010248:	2002      	movs	r0, #2
 801024a:	f007 f853 	bl	80172f4 <hci_dump_packet>
        hci_stack->acl_fragmentation_tx_active = 1;
 801024e:	4b19      	ldr	r3, [pc, #100]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 8010250:	681b      	ldr	r3, [r3, #0]
 8010252:	2201      	movs	r2, #1
 8010254:	f883 26fa 	strb.w	r2, [r3, #1786]	; 0x6fa
        err = hci_stack->hci_transport->send_packet(HCI_ACL_DATA_PACKET, packet, size);
 8010258:	4b16      	ldr	r3, [pc, #88]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 801025a:	681b      	ldr	r3, [r3, #0]
 801025c:	681b      	ldr	r3, [r3, #0]
 801025e:	699b      	ldr	r3, [r3, #24]
 8010260:	693a      	ldr	r2, [r7, #16]
 8010262:	6979      	ldr	r1, [r7, #20]
 8010264:	2002      	movs	r0, #2
 8010266:	4798      	blx	r3
 8010268:	60f8      	str	r0, [r7, #12]

        log_debug("hci_send_acl_packet_fragments loop after send (more fragments %d)", (int) more_fragments);

        // done yet?
        if (!more_fragments) break;
 801026a:	7ffb      	ldrb	r3, [r7, #31]
 801026c:	f083 0301 	eor.w	r3, r3, #1
 8010270:	b2db      	uxtb	r3, r3
 8010272:	2b00      	cmp	r3, #0
 8010274:	d10a      	bne.n	801028c <hci_send_acl_packet_fragments+0x158>

        // can send more?
        if (!hci_can_send_prepared_acl_packet_now(connection->con_handle)) return err;
 8010276:	687b      	ldr	r3, [r7, #4]
 8010278:	895b      	ldrh	r3, [r3, #10]
 801027a:	4618      	mov	r0, r3
 801027c:	f7ff fe94 	bl	800ffa8 <hci_can_send_prepared_acl_packet_now>
 8010280:	4603      	mov	r3, r0
 8010282:	2b00      	cmp	r3, #0
 8010284:	f47f af70 	bne.w	8010168 <hci_send_acl_packet_fragments+0x34>
 8010288:	68fb      	ldr	r3, [r7, #12]
 801028a:	e00f      	b.n	80102ac <hci_send_acl_packet_fragments+0x178>
        if (!more_fragments) break;
 801028c:	bf00      	nop
    }

    log_debug("hci_send_acl_packet_fragments loop over");

    // release buffer now for synchronous transport
    if (hci_transport_synchronous()){
 801028e:	f7ff ff3f 	bl	8010110 <hci_transport_synchronous>
 8010292:	4603      	mov	r3, r0
 8010294:	2b00      	cmp	r3, #0
 8010296:	d008      	beq.n	80102aa <hci_send_acl_packet_fragments+0x176>
        hci_stack->acl_fragmentation_tx_active = 0;
 8010298:	4b06      	ldr	r3, [pc, #24]	; (80102b4 <hci_send_acl_packet_fragments+0x180>)
 801029a:	681b      	ldr	r3, [r3, #0]
 801029c:	2200      	movs	r2, #0
 801029e:	f883 26fa 	strb.w	r2, [r3, #1786]	; 0x6fa
        hci_release_packet_buffer();
 80102a2:	f7ff ff27 	bl	80100f4 <hci_release_packet_buffer>
        hci_emit_transport_packet_sent();
 80102a6:	f006 f8e7 	bl	8016478 <hci_emit_transport_packet_sent>
    }

    return err;
 80102aa:	68fb      	ldr	r3, [r7, #12]
}
 80102ac:	4618      	mov	r0, r3
 80102ae:	3728      	adds	r7, #40	; 0x28
 80102b0:	46bd      	mov	sp, r7
 80102b2:	bd80      	pop	{r7, pc}
 80102b4:	20009780 	.word	0x20009780

080102b8 <hci_send_acl_packet_buffer>:

// pre: caller has reserved the packet buffer
int hci_send_acl_packet_buffer(int size){
 80102b8:	b580      	push	{r7, lr}
 80102ba:	b088      	sub	sp, #32
 80102bc:	af02      	add	r7, sp, #8
 80102be:	6078      	str	r0, [r7, #4]

    // log_info("hci_send_acl_packet_buffer size %u", size);

    if (!hci_stack->hci_packet_buffer_reserved) {
 80102c0:	4b2d      	ldr	r3, [pc, #180]	; (8010378 <hci_send_acl_packet_buffer+0xc0>)
 80102c2:	681b      	ldr	r3, [r3, #0]
 80102c4:	f893 36f4 	ldrb.w	r3, [r3, #1780]	; 0x6f4
 80102c8:	2b00      	cmp	r3, #0
 80102ca:	d108      	bne.n	80102de <hci_send_acl_packet_buffer+0x26>
        log_error("hci_send_acl_packet_buffer called without reserving packet buffer");
 80102cc:	f44f 733c 	mov.w	r3, #752	; 0x2f0
 80102d0:	4a2a      	ldr	r2, [pc, #168]	; (801037c <hci_send_acl_packet_buffer+0xc4>)
 80102d2:	492b      	ldr	r1, [pc, #172]	; (8010380 <hci_send_acl_packet_buffer+0xc8>)
 80102d4:	2002      	movs	r0, #2
 80102d6:	f007 f8b3 	bl	8017440 <hci_dump_log>
        return 0;
 80102da:	2300      	movs	r3, #0
 80102dc:	e048      	b.n	8010370 <hci_send_acl_packet_buffer+0xb8>
    }

    uint8_t * packet = hci_stack->hci_packet_buffer;
 80102de:	4b26      	ldr	r3, [pc, #152]	; (8010378 <hci_send_acl_packet_buffer+0xc0>)
 80102e0:	681b      	ldr	r3, [r3, #0]
 80102e2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80102e4:	617b      	str	r3, [r7, #20]
    hci_con_handle_t con_handle = READ_ACL_CONNECTION_HANDLE(packet);
 80102e6:	2100      	movs	r1, #0
 80102e8:	6978      	ldr	r0, [r7, #20]
 80102ea:	f7fe fd7c 	bl	800ede6 <little_endian_read_16>
 80102ee:	4603      	mov	r3, r0
 80102f0:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80102f4:	827b      	strh	r3, [r7, #18]

    // check for free places on Bluetooth module
    if (!hci_can_send_prepared_acl_packet_now(con_handle)) {
 80102f6:	8a7b      	ldrh	r3, [r7, #18]
 80102f8:	4618      	mov	r0, r3
 80102fa:	f7ff fe55 	bl	800ffa8 <hci_can_send_prepared_acl_packet_now>
 80102fe:	4603      	mov	r3, r0
 8010300:	2b00      	cmp	r3, #0
 8010302:	d10c      	bne.n	801031e <hci_send_acl_packet_buffer+0x66>
        log_error("hci_send_acl_packet_buffer called but no free ACL buffers on controller");
 8010304:	f240 23f9 	movw	r3, #761	; 0x2f9
 8010308:	4a1c      	ldr	r2, [pc, #112]	; (801037c <hci_send_acl_packet_buffer+0xc4>)
 801030a:	491e      	ldr	r1, [pc, #120]	; (8010384 <hci_send_acl_packet_buffer+0xcc>)
 801030c:	2002      	movs	r0, #2
 801030e:	f007 f897 	bl	8017440 <hci_dump_log>
        hci_release_packet_buffer();
 8010312:	f7ff feef 	bl	80100f4 <hci_release_packet_buffer>
        hci_emit_transport_packet_sent();
 8010316:	f006 f8af 	bl	8016478 <hci_emit_transport_packet_sent>
        return BTSTACK_ACL_BUFFERS_FULL;
 801031a:	2357      	movs	r3, #87	; 0x57
 801031c:	e028      	b.n	8010370 <hci_send_acl_packet_buffer+0xb8>
    }

    hci_connection_t *connection = hci_connection_for_handle( con_handle);
 801031e:	8a7b      	ldrh	r3, [r7, #18]
 8010320:	4618      	mov	r0, r3
 8010322:	f7ff facf 	bl	800f8c4 <hci_connection_for_handle>
 8010326:	60f8      	str	r0, [r7, #12]
    if (!connection) {
 8010328:	68fb      	ldr	r3, [r7, #12]
 801032a:	2b00      	cmp	r3, #0
 801032c:	d10e      	bne.n	801034c <hci_send_acl_packet_buffer+0x94>
        log_error("hci_send_acl_packet_buffer called but no connection for handle 0x%04x", con_handle);
 801032e:	8a7b      	ldrh	r3, [r7, #18]
 8010330:	9300      	str	r3, [sp, #0]
 8010332:	f240 3301 	movw	r3, #769	; 0x301
 8010336:	4a11      	ldr	r2, [pc, #68]	; (801037c <hci_send_acl_packet_buffer+0xc4>)
 8010338:	4913      	ldr	r1, [pc, #76]	; (8010388 <hci_send_acl_packet_buffer+0xd0>)
 801033a:	2002      	movs	r0, #2
 801033c:	f007 f880 	bl	8017440 <hci_dump_log>
        hci_release_packet_buffer();
 8010340:	f7ff fed8 	bl	80100f4 <hci_release_packet_buffer>
        hci_emit_transport_packet_sent();
 8010344:	f006 f898 	bl	8016478 <hci_emit_transport_packet_sent>
        return 0;
 8010348:	2300      	movs	r3, #0
 801034a:	e011      	b.n	8010370 <hci_send_acl_packet_buffer+0xb8>
    }

#ifdef ENABLE_CLASSIC
    hci_connection_timestamp(connection);
 801034c:	68f8      	ldr	r0, [r7, #12]
 801034e:	f7ff fb86 	bl	800fa5e <hci_connection_timestamp>
#endif

    // hci_dump_packet( HCI_ACL_DATA_PACKET, 0, packet, size);

    // setup data
    hci_stack->acl_fragmentation_total_size = size;
 8010352:	4b09      	ldr	r3, [pc, #36]	; (8010378 <hci_send_acl_packet_buffer+0xc0>)
 8010354:	681b      	ldr	r3, [r3, #0]
 8010356:	687a      	ldr	r2, [r7, #4]
 8010358:	b292      	uxth	r2, r2
 801035a:	f8a3 26f8 	strh.w	r2, [r3, #1784]	; 0x6f8
    hci_stack->acl_fragmentation_pos = 4;   // start of L2CAP packet
 801035e:	4b06      	ldr	r3, [pc, #24]	; (8010378 <hci_send_acl_packet_buffer+0xc0>)
 8010360:	681b      	ldr	r3, [r3, #0]
 8010362:	2204      	movs	r2, #4
 8010364:	f8a3 26f6 	strh.w	r2, [r3, #1782]	; 0x6f6

    return hci_send_acl_packet_fragments(connection);
 8010368:	68f8      	ldr	r0, [r7, #12]
 801036a:	f7ff fee3 	bl	8010134 <hci_send_acl_packet_fragments>
 801036e:	4603      	mov	r3, r0
}
 8010370:	4618      	mov	r0, r3
 8010372:	3718      	adds	r7, #24
 8010374:	46bd      	mov	sp, r7
 8010376:	bd80      	pop	{r7, pc}
 8010378:	20009780 	.word	0x20009780
 801037c:	0802929c 	.word	0x0802929c
 8010380:	080295a8 	.word	0x080295a8
 8010384:	080295f4 	.word	0x080295f4
 8010388:	08029644 	.word	0x08029644

0801038c <acl_handler>:

    return err;
}
#endif

static void acl_handler(uint8_t *packet, uint16_t size){
 801038c:	b580      	push	{r7, lr}
 801038e:	b08a      	sub	sp, #40	; 0x28
 8010390:	af04      	add	r7, sp, #16
 8010392:	6078      	str	r0, [r7, #4]
 8010394:	460b      	mov	r3, r1
 8010396:	807b      	strh	r3, [r7, #2]

    // get info
    hci_con_handle_t con_handle = READ_ACL_CONNECTION_HANDLE(packet);
 8010398:	2100      	movs	r1, #0
 801039a:	6878      	ldr	r0, [r7, #4]
 801039c:	f7fe fd23 	bl	800ede6 <little_endian_read_16>
 80103a0:	4603      	mov	r3, r0
 80103a2:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80103a6:	82fb      	strh	r3, [r7, #22]
    hci_connection_t *conn      = hci_connection_for_handle(con_handle);
 80103a8:	8afb      	ldrh	r3, [r7, #22]
 80103aa:	4618      	mov	r0, r3
 80103ac:	f7ff fa8a 	bl	800f8c4 <hci_connection_for_handle>
 80103b0:	6138      	str	r0, [r7, #16]
    uint8_t  acl_flags          = READ_ACL_FLAGS(packet);
 80103b2:	687b      	ldr	r3, [r7, #4]
 80103b4:	3301      	adds	r3, #1
 80103b6:	781b      	ldrb	r3, [r3, #0]
 80103b8:	091b      	lsrs	r3, r3, #4
 80103ba:	73fb      	strb	r3, [r7, #15]
    uint16_t acl_length         = READ_ACL_LENGTH(packet);
 80103bc:	2102      	movs	r1, #2
 80103be:	6878      	ldr	r0, [r7, #4]
 80103c0:	f7fe fd11 	bl	800ede6 <little_endian_read_16>
 80103c4:	4603      	mov	r3, r0
 80103c6:	81bb      	strh	r3, [r7, #12]

    // ignore non-registered handle
    if (!conn){
 80103c8:	693b      	ldr	r3, [r7, #16]
 80103ca:	2b00      	cmp	r3, #0
 80103cc:	d109      	bne.n	80103e2 <acl_handler+0x56>
        log_error("acl_handler called with non-registered handle %u!" , con_handle);
 80103ce:	8afb      	ldrh	r3, [r7, #22]
 80103d0:	9300      	str	r3, [sp, #0]
 80103d2:	f44f 7356 	mov.w	r3, #856	; 0x358
 80103d6:	4a78      	ldr	r2, [pc, #480]	; (80105b8 <acl_handler+0x22c>)
 80103d8:	4978      	ldr	r1, [pc, #480]	; (80105bc <acl_handler+0x230>)
 80103da:	2002      	movs	r0, #2
 80103dc:	f007 f830 	bl	8017440 <hci_dump_log>
        return;
 80103e0:	e0e6      	b.n	80105b0 <acl_handler+0x224>
    }

    // assert packet is complete    
    if ((acl_length + 4u) != size){
 80103e2:	89bb      	ldrh	r3, [r7, #12]
 80103e4:	1d1a      	adds	r2, r3, #4
 80103e6:	887b      	ldrh	r3, [r7, #2]
 80103e8:	429a      	cmp	r2, r3
 80103ea:	d00c      	beq.n	8010406 <acl_handler+0x7a>
        log_error("acl_handler called with ACL packet of wrong size %d, expected %u => dropping packet", size, acl_length + 4);
 80103ec:	887b      	ldrh	r3, [r7, #2]
 80103ee:	89ba      	ldrh	r2, [r7, #12]
 80103f0:	3204      	adds	r2, #4
 80103f2:	9201      	str	r2, [sp, #4]
 80103f4:	9300      	str	r3, [sp, #0]
 80103f6:	f240 335e 	movw	r3, #862	; 0x35e
 80103fa:	4a6f      	ldr	r2, [pc, #444]	; (80105b8 <acl_handler+0x22c>)
 80103fc:	4970      	ldr	r1, [pc, #448]	; (80105c0 <acl_handler+0x234>)
 80103fe:	2002      	movs	r0, #2
 8010400:	f007 f81e 	bl	8017440 <hci_dump_log>
        return;
 8010404:	e0d4      	b.n	80105b0 <acl_handler+0x224>
    }

#ifdef ENABLE_CLASSIC
    // update idle timestamp
    hci_connection_timestamp(conn);
 8010406:	6938      	ldr	r0, [r7, #16]
 8010408:	f7ff fb29 	bl	800fa5e <hci_connection_timestamp>
    hci_stack->host_completed_packets = 1;
    conn->num_packets_completed++;
#endif

    // handle different packet types
    switch (acl_flags & 0x03u) {
 801040c:	7bfb      	ldrb	r3, [r7, #15]
 801040e:	f003 0303 	and.w	r3, r3, #3
 8010412:	2b01      	cmp	r3, #1
 8010414:	d002      	beq.n	801041c <acl_handler+0x90>
 8010416:	2b02      	cmp	r3, #2
 8010418:	d063      	beq.n	80104e2 <acl_handler+0x156>
 801041a:	e0ba      	b.n	8010592 <acl_handler+0x206>
            
        case 0x01: // continuation fragment
            
            // sanity checks
            if (conn->acl_recombination_pos == 0u) {
 801041c:	693b      	ldr	r3, [r7, #16]
 801041e:	f8b3 3706 	ldrh.w	r3, [r3, #1798]	; 0x706
 8010422:	2b00      	cmp	r3, #0
 8010424:	d109      	bne.n	801043a <acl_handler+0xae>
                log_error( "ACL Cont Fragment but no first fragment for handle 0x%02x", con_handle);
 8010426:	8afb      	ldrh	r3, [r7, #22]
 8010428:	9300      	str	r3, [sp, #0]
 801042a:	f240 3373 	movw	r3, #883	; 0x373
 801042e:	4a62      	ldr	r2, [pc, #392]	; (80105b8 <acl_handler+0x22c>)
 8010430:	4964      	ldr	r1, [pc, #400]	; (80105c4 <acl_handler+0x238>)
 8010432:	2002      	movs	r0, #2
 8010434:	f007 f804 	bl	8017440 <hci_dump_log>
                return;
 8010438:	e0ba      	b.n	80105b0 <acl_handler+0x224>
            }
            if ((conn->acl_recombination_pos + acl_length) > (4u + HCI_ACL_BUFFER_SIZE)){
 801043a:	693b      	ldr	r3, [r7, #16]
 801043c:	f8b3 3706 	ldrh.w	r3, [r3, #1798]	; 0x706
 8010440:	461a      	mov	r2, r3
 8010442:	89bb      	ldrh	r3, [r7, #12]
 8010444:	4413      	add	r3, r2
 8010446:	f5b3 6fd5 	cmp.w	r3, #1704	; 0x6a8
 801044a:	d317      	bcc.n	801047c <acl_handler+0xf0>
                log_error( "ACL Cont Fragment to large: combined packet %u > buffer size %u for handle 0x%02x",
 801044c:	693b      	ldr	r3, [r7, #16]
 801044e:	f8b3 3706 	ldrh.w	r3, [r3, #1798]	; 0x706
 8010452:	461a      	mov	r2, r3
 8010454:	89bb      	ldrh	r3, [r7, #12]
 8010456:	4413      	add	r3, r2
 8010458:	8afa      	ldrh	r2, [r7, #22]
 801045a:	9202      	str	r2, [sp, #8]
 801045c:	f240 62a7 	movw	r2, #1703	; 0x6a7
 8010460:	9201      	str	r2, [sp, #4]
 8010462:	9300      	str	r3, [sp, #0]
 8010464:	f44f 735e 	mov.w	r3, #888	; 0x378
 8010468:	4a53      	ldr	r2, [pc, #332]	; (80105b8 <acl_handler+0x22c>)
 801046a:	4957      	ldr	r1, [pc, #348]	; (80105c8 <acl_handler+0x23c>)
 801046c:	2002      	movs	r0, #2
 801046e:	f006 ffe7 	bl	8017440 <hci_dump_log>
                    conn->acl_recombination_pos + acl_length, 4 + HCI_ACL_BUFFER_SIZE, con_handle);
                conn->acl_recombination_pos = 0;
 8010472:	693b      	ldr	r3, [r7, #16]
 8010474:	2200      	movs	r2, #0
 8010476:	f8a3 2706 	strh.w	r2, [r3, #1798]	; 0x706
                return;
 801047a:	e099      	b.n	80105b0 <acl_handler+0x224>
            }

            // append fragment payload (header already stored)
            (void)memcpy(&conn->acl_recombination_buffer[HCI_INCOMING_PRE_BUFFER_SIZE + conn->acl_recombination_pos],
 801047c:	693b      	ldr	r3, [r7, #16]
 801047e:	f8b3 3706 	ldrh.w	r3, [r3, #1798]	; 0x706
 8010482:	330e      	adds	r3, #14
 8010484:	3350      	adds	r3, #80	; 0x50
 8010486:	693a      	ldr	r2, [r7, #16]
 8010488:	18d0      	adds	r0, r2, r3
                         &packet[4], acl_length);
 801048a:	687b      	ldr	r3, [r7, #4]
 801048c:	3304      	adds	r3, #4
            (void)memcpy(&conn->acl_recombination_buffer[HCI_INCOMING_PRE_BUFFER_SIZE + conn->acl_recombination_pos],
 801048e:	89ba      	ldrh	r2, [r7, #12]
 8010490:	4619      	mov	r1, r3
 8010492:	f017 faf2 	bl	8027a7a <memcpy>
            conn->acl_recombination_pos += acl_length;
 8010496:	693b      	ldr	r3, [r7, #16]
 8010498:	f8b3 2706 	ldrh.w	r2, [r3, #1798]	; 0x706
 801049c:	89bb      	ldrh	r3, [r7, #12]
 801049e:	4413      	add	r3, r2
 80104a0:	b29a      	uxth	r2, r3
 80104a2:	693b      	ldr	r3, [r7, #16]
 80104a4:	f8a3 2706 	strh.w	r2, [r3, #1798]	; 0x706

            // forward complete L2CAP packet if complete. 
            if (conn->acl_recombination_pos >= (conn->acl_recombination_length + 4u + 4u)){ // pos already incl. ACL header
 80104a8:	693b      	ldr	r3, [r7, #16]
 80104aa:	f8b3 3706 	ldrh.w	r3, [r3, #1798]	; 0x706
 80104ae:	461a      	mov	r2, r3
 80104b0:	693b      	ldr	r3, [r7, #16]
 80104b2:	f8b3 3708 	ldrh.w	r3, [r3, #1800]	; 0x708
 80104b6:	3308      	adds	r3, #8
 80104b8:	429a      	cmp	r2, r3
 80104ba:	d376      	bcc.n	80105aa <acl_handler+0x21e>
                hci_emit_acl_packet(&conn->acl_recombination_buffer[HCI_INCOMING_PRE_BUFFER_SIZE], conn->acl_recombination_pos);
 80104bc:	693b      	ldr	r3, [r7, #16]
 80104be:	f103 025e 	add.w	r2, r3, #94	; 0x5e
 80104c2:	693b      	ldr	r3, [r7, #16]
 80104c4:	f8b3 3706 	ldrh.w	r3, [r3, #1798]	; 0x706
 80104c8:	4619      	mov	r1, r3
 80104ca:	4610      	mov	r0, r2
 80104cc:	f005 fdd2 	bl	8016074 <hci_emit_acl_packet>
                // reset recombination buffer
                conn->acl_recombination_length = 0;
 80104d0:	693b      	ldr	r3, [r7, #16]
 80104d2:	2200      	movs	r2, #0
 80104d4:	f8a3 2708 	strh.w	r2, [r3, #1800]	; 0x708
                conn->acl_recombination_pos = 0;
 80104d8:	693b      	ldr	r3, [r7, #16]
 80104da:	2200      	movs	r2, #0
 80104dc:	f8a3 2706 	strh.w	r2, [r3, #1798]	; 0x706
            }
            break;
 80104e0:	e063      	b.n	80105aa <acl_handler+0x21e>
            
        case 0x02: { // first fragment
            
            // sanity check
            if (conn->acl_recombination_pos) {
 80104e2:	693b      	ldr	r3, [r7, #16]
 80104e4:	f8b3 3706 	ldrh.w	r3, [r3, #1798]	; 0x706
 80104e8:	2b00      	cmp	r3, #0
 80104ea:	d00c      	beq.n	8010506 <acl_handler+0x17a>
                log_error( "ACL First Fragment but data in buffer for handle 0x%02x, dropping stale fragments", con_handle);
 80104ec:	8afb      	ldrh	r3, [r7, #22]
 80104ee:	9300      	str	r3, [sp, #0]
 80104f0:	f240 338f 	movw	r3, #911	; 0x38f
 80104f4:	4a30      	ldr	r2, [pc, #192]	; (80105b8 <acl_handler+0x22c>)
 80104f6:	4935      	ldr	r1, [pc, #212]	; (80105cc <acl_handler+0x240>)
 80104f8:	2002      	movs	r0, #2
 80104fa:	f006 ffa1 	bl	8017440 <hci_dump_log>
                conn->acl_recombination_pos = 0;
 80104fe:	693b      	ldr	r3, [r7, #16]
 8010500:	2200      	movs	r2, #0
 8010502:	f8a3 2706 	strh.w	r2, [r3, #1798]	; 0x706
            }

            // peek into L2CAP packet!
            uint16_t l2cap_length = READ_L2CAP_LENGTH( packet );
 8010506:	2104      	movs	r1, #4
 8010508:	6878      	ldr	r0, [r7, #4]
 801050a:	f7fe fc6c 	bl	800ede6 <little_endian_read_16>
 801050e:	4603      	mov	r3, r0
 8010510:	817b      	strh	r3, [r7, #10]

            // compare fragment size to L2CAP packet size
            if (acl_length >= (l2cap_length + 4u)){
 8010512:	89ba      	ldrh	r2, [r7, #12]
 8010514:	897b      	ldrh	r3, [r7, #10]
 8010516:	3304      	adds	r3, #4
 8010518:	429a      	cmp	r2, r3
 801051a:	d307      	bcc.n	801052c <acl_handler+0x1a0>
                // forward fragment as L2CAP packet
                hci_emit_acl_packet(packet, acl_length + 4u);
 801051c:	89bb      	ldrh	r3, [r7, #12]
 801051e:	3304      	adds	r3, #4
 8010520:	b29b      	uxth	r3, r3
 8010522:	4619      	mov	r1, r3
 8010524:	6878      	ldr	r0, [r7, #4]
 8010526:	f005 fda5 	bl	8016074 <hci_emit_acl_packet>
                             packet, acl_length + 4u);
                conn->acl_recombination_pos    = acl_length + 4u;
                conn->acl_recombination_length = l2cap_length;
                little_endian_store_16(conn->acl_recombination_buffer, HCI_INCOMING_PRE_BUFFER_SIZE + 2u, l2cap_length +4u);
            }
            break;
 801052a:	e03f      	b.n	80105ac <acl_handler+0x220>
                if (acl_length > HCI_ACL_BUFFER_SIZE){
 801052c:	89bb      	ldrh	r3, [r7, #12]
 801052e:	f240 62a3 	movw	r2, #1699	; 0x6a3
 8010532:	4293      	cmp	r3, r2
 8010534:	d90f      	bls.n	8010556 <acl_handler+0x1ca>
                    log_error( "ACL First Fragment to large: fragment %u > buffer size %u for handle 0x%02x",
 8010536:	89bb      	ldrh	r3, [r7, #12]
 8010538:	3304      	adds	r3, #4
 801053a:	8afa      	ldrh	r2, [r7, #22]
 801053c:	9202      	str	r2, [sp, #8]
 801053e:	f240 62a7 	movw	r2, #1703	; 0x6a7
 8010542:	9201      	str	r2, [sp, #4]
 8010544:	9300      	str	r3, [sp, #0]
 8010546:	f240 339e 	movw	r3, #926	; 0x39e
 801054a:	4a1b      	ldr	r2, [pc, #108]	; (80105b8 <acl_handler+0x22c>)
 801054c:	4920      	ldr	r1, [pc, #128]	; (80105d0 <acl_handler+0x244>)
 801054e:	2002      	movs	r0, #2
 8010550:	f006 ff76 	bl	8017440 <hci_dump_log>
                    return;
 8010554:	e02c      	b.n	80105b0 <acl_handler+0x224>
                (void)memcpy(&conn->acl_recombination_buffer[HCI_INCOMING_PRE_BUFFER_SIZE],
 8010556:	693b      	ldr	r3, [r7, #16]
 8010558:	f103 005e 	add.w	r0, r3, #94	; 0x5e
 801055c:	89bb      	ldrh	r3, [r7, #12]
 801055e:	3304      	adds	r3, #4
 8010560:	461a      	mov	r2, r3
 8010562:	6879      	ldr	r1, [r7, #4]
 8010564:	f017 fa89 	bl	8027a7a <memcpy>
                conn->acl_recombination_pos    = acl_length + 4u;
 8010568:	89bb      	ldrh	r3, [r7, #12]
 801056a:	3304      	adds	r3, #4
 801056c:	b29a      	uxth	r2, r3
 801056e:	693b      	ldr	r3, [r7, #16]
 8010570:	f8a3 2706 	strh.w	r2, [r3, #1798]	; 0x706
                conn->acl_recombination_length = l2cap_length;
 8010574:	693b      	ldr	r3, [r7, #16]
 8010576:	897a      	ldrh	r2, [r7, #10]
 8010578:	f8a3 2708 	strh.w	r2, [r3, #1800]	; 0x708
                little_endian_store_16(conn->acl_recombination_buffer, HCI_INCOMING_PRE_BUFFER_SIZE + 2u, l2cap_length +4u);
 801057c:	693b      	ldr	r3, [r7, #16]
 801057e:	f103 0050 	add.w	r0, r3, #80	; 0x50
 8010582:	897b      	ldrh	r3, [r7, #10]
 8010584:	3304      	adds	r3, #4
 8010586:	b29b      	uxth	r3, r3
 8010588:	461a      	mov	r2, r3
 801058a:	2110      	movs	r1, #16
 801058c:	f7fe fc6b 	bl	800ee66 <little_endian_store_16>
            break;
 8010590:	e00c      	b.n	80105ac <acl_handler+0x220>
            
        } 
        default:
            log_error( "acl_handler called with invalid packet boundary flags %u", acl_flags & 0x03);
 8010592:	7bfb      	ldrb	r3, [r7, #15]
 8010594:	f003 0303 	and.w	r3, r3, #3
 8010598:	9300      	str	r3, [sp, #0]
 801059a:	f240 33ad 	movw	r3, #941	; 0x3ad
 801059e:	4a06      	ldr	r2, [pc, #24]	; (80105b8 <acl_handler+0x22c>)
 80105a0:	490c      	ldr	r1, [pc, #48]	; (80105d4 <acl_handler+0x248>)
 80105a2:	2002      	movs	r0, #2
 80105a4:	f006 ff4c 	bl	8017440 <hci_dump_log>
            return;
 80105a8:	e002      	b.n	80105b0 <acl_handler+0x224>
            break;
 80105aa:	bf00      	nop
    }
    
    // execute main loop
    hci_run();
 80105ac:	f005 f978 	bl	80158a0 <hci_run>
}
 80105b0:	3718      	adds	r7, #24
 80105b2:	46bd      	mov	sp, r7
 80105b4:	bd80      	pop	{r7, pc}
 80105b6:	bf00      	nop
 80105b8:	0802929c 	.word	0x0802929c
 80105bc:	08029734 	.word	0x08029734
 80105c0:	08029770 	.word	0x08029770
 80105c4:	080297cc 	.word	0x080297cc
 80105c8:	08029810 	.word	0x08029810
 80105cc:	0802986c 	.word	0x0802986c
 80105d0:	080298c8 	.word	0x080298c8
 80105d4:	0802991c 	.word	0x0802991c

080105d8 <hci_shutdown_connection>:

static void hci_shutdown_connection(hci_connection_t *conn){
 80105d8:	b5b0      	push	{r4, r5, r7, lr}
 80105da:	b086      	sub	sp, #24
 80105dc:	af02      	add	r7, sp, #8
 80105de:	6078      	str	r0, [r7, #4]
    log_info("Connection closed: handle 0x%x, %s", conn->con_handle, bd_addr_to_str(conn->address));
 80105e0:	687b      	ldr	r3, [r7, #4]
 80105e2:	895b      	ldrh	r3, [r3, #10]
 80105e4:	461c      	mov	r4, r3
 80105e6:	687b      	ldr	r3, [r7, #4]
 80105e8:	3304      	adds	r3, #4
 80105ea:	4618      	mov	r0, r3
 80105ec:	f7fe ff10 	bl	800f410 <bd_addr_to_str>
 80105f0:	4603      	mov	r3, r0
 80105f2:	9301      	str	r3, [sp, #4]
 80105f4:	9400      	str	r4, [sp, #0]
 80105f6:	f240 33b6 	movw	r3, #950	; 0x3b6
 80105fa:	4a1c      	ldr	r2, [pc, #112]	; (801066c <hci_shutdown_connection+0x94>)
 80105fc:	491c      	ldr	r1, [pc, #112]	; (8010670 <hci_shutdown_connection+0x98>)
 80105fe:	2001      	movs	r0, #1
 8010600:	f006 ff1e 	bl	8017440 <hci_dump_log>

#ifdef ENABLE_CLASSIC
#ifdef ENABLE_SCO_OVER_HCI
    int addr_type = conn->address_type;
 8010604:	687b      	ldr	r3, [r7, #4]
 8010606:	7b1b      	ldrb	r3, [r3, #12]
 8010608:	60fb      	str	r3, [r7, #12]
#endif
#endif

    btstack_run_loop_remove_timer(&conn->timeout);
 801060a:	687b      	ldr	r3, [r7, #4]
 801060c:	333c      	adds	r3, #60	; 0x3c
 801060e:	4618      	mov	r0, r3
 8010610:	f7fe fb5c 	bl	800eccc <btstack_run_loop_remove_timer>
    
    btstack_linked_list_remove(&hci_stack->connections, (btstack_linked_item_t *) conn);
 8010614:	4b17      	ldr	r3, [pc, #92]	; (8010674 <hci_shutdown_connection+0x9c>)
 8010616:	681b      	ldr	r3, [r3, #0]
 8010618:	3314      	adds	r3, #20
 801061a:	6879      	ldr	r1, [r7, #4]
 801061c:	4618      	mov	r0, r3
 801061e:	f7fe f84e 	bl	800e6be <btstack_linked_list_remove>
    btstack_memory_hci_connection_free( conn );
 8010622:	6878      	ldr	r0, [r7, #4]
 8010624:	f7fe f930 	bl	800e888 <btstack_memory_hci_connection_free>
    
    // now it's gone
    hci_emit_nr_connections_changed();
 8010628:	f005 ff5a 	bl	80164e0 <hci_emit_nr_connections_changed>

#ifdef ENABLE_CLASSIC
#ifdef ENABLE_SCO_OVER_HCI
    // update SCO
    if (addr_type == BD_ADDR_TYPE_SCO && hci_stack->hci_transport && hci_stack->hci_transport->set_sco_config){
 801062c:	68fb      	ldr	r3, [r7, #12]
 801062e:	2bfc      	cmp	r3, #252	; 0xfc
 8010630:	d118      	bne.n	8010664 <hci_shutdown_connection+0x8c>
 8010632:	4b10      	ldr	r3, [pc, #64]	; (8010674 <hci_shutdown_connection+0x9c>)
 8010634:	681b      	ldr	r3, [r3, #0]
 8010636:	681b      	ldr	r3, [r3, #0]
 8010638:	2b00      	cmp	r3, #0
 801063a:	d013      	beq.n	8010664 <hci_shutdown_connection+0x8c>
 801063c:	4b0d      	ldr	r3, [pc, #52]	; (8010674 <hci_shutdown_connection+0x9c>)
 801063e:	681b      	ldr	r3, [r3, #0]
 8010640:	681b      	ldr	r3, [r3, #0]
 8010642:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010644:	2b00      	cmp	r3, #0
 8010646:	d00d      	beq.n	8010664 <hci_shutdown_connection+0x8c>
        hci_stack->hci_transport->set_sco_config(hci_stack->sco_voice_setting_active, hci_number_sco_connections());
 8010648:	4b0a      	ldr	r3, [pc, #40]	; (8010674 <hci_shutdown_connection+0x9c>)
 801064a:	681b      	ldr	r3, [r3, #0]
 801064c:	681b      	ldr	r3, [r3, #0]
 801064e:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8010650:	4b08      	ldr	r3, [pc, #32]	; (8010674 <hci_shutdown_connection+0x9c>)
 8010652:	681b      	ldr	r3, [r3, #0]
 8010654:	f8b3 574a 	ldrh.w	r5, [r3, #1866]	; 0x74a
 8010658:	f7ff f9be 	bl	800f9d8 <hci_number_sco_connections>
 801065c:	4603      	mov	r3, r0
 801065e:	4619      	mov	r1, r3
 8010660:	4628      	mov	r0, r5
 8010662:	47a0      	blx	r4
    }
#endif
#endif
}
 8010664:	bf00      	nop
 8010666:	3710      	adds	r7, #16
 8010668:	46bd      	mov	sp, r7
 801066a:	bdb0      	pop	{r4, r5, r7, pc}
 801066c:	0802929c 	.word	0x0802929c
 8010670:	0802995c 	.word	0x0802995c
 8010674:	20009780 	.word	0x20009780

08010678 <hci_acl_packet_types_for_buffer_size_and_local_features>:
    0x2204, // EDR 3 mbps
    0x0300, // 3 slot EDR packts
    0x3000, // 5 slot EDR packet
};

static uint16_t hci_acl_packet_types_for_buffer_size_and_local_features(uint16_t buffer_size, uint8_t * local_supported_features){
 8010678:	b580      	push	{r7, lr}
 801067a:	b088      	sub	sp, #32
 801067c:	af02      	add	r7, sp, #8
 801067e:	4603      	mov	r3, r0
 8010680:	6039      	str	r1, [r7, #0]
 8010682:	80fb      	strh	r3, [r7, #6]
    // enable packet types based on size
    uint16_t packet_types = 0;
 8010684:	2300      	movs	r3, #0
 8010686:	82fb      	strh	r3, [r7, #22]
    unsigned int i;
    for (i=0;i<16;i++){
 8010688:	2300      	movs	r3, #0
 801068a:	613b      	str	r3, [r7, #16]
 801068c:	e01b      	b.n	80106c6 <hci_acl_packet_types_for_buffer_size_and_local_features+0x4e>
        if (packet_type_sizes[i] == 0) continue;
 801068e:	4a35      	ldr	r2, [pc, #212]	; (8010764 <hci_acl_packet_types_for_buffer_size_and_local_features+0xec>)
 8010690:	693b      	ldr	r3, [r7, #16]
 8010692:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8010696:	2b00      	cmp	r3, #0
 8010698:	d011      	beq.n	80106be <hci_acl_packet_types_for_buffer_size_and_local_features+0x46>
        if (packet_type_sizes[i] <= buffer_size){
 801069a:	4a32      	ldr	r2, [pc, #200]	; (8010764 <hci_acl_packet_types_for_buffer_size_and_local_features+0xec>)
 801069c:	693b      	ldr	r3, [r7, #16]
 801069e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80106a2:	88fa      	ldrh	r2, [r7, #6]
 80106a4:	429a      	cmp	r2, r3
 80106a6:	d30b      	bcc.n	80106c0 <hci_acl_packet_types_for_buffer_size_and_local_features+0x48>
            packet_types |= 1 << i;
 80106a8:	2201      	movs	r2, #1
 80106aa:	693b      	ldr	r3, [r7, #16]
 80106ac:	fa02 f303 	lsl.w	r3, r2, r3
 80106b0:	b21a      	sxth	r2, r3
 80106b2:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80106b6:	4313      	orrs	r3, r2
 80106b8:	b21b      	sxth	r3, r3
 80106ba:	82fb      	strh	r3, [r7, #22]
 80106bc:	e000      	b.n	80106c0 <hci_acl_packet_types_for_buffer_size_and_local_features+0x48>
        if (packet_type_sizes[i] == 0) continue;
 80106be:	bf00      	nop
    for (i=0;i<16;i++){
 80106c0:	693b      	ldr	r3, [r7, #16]
 80106c2:	3301      	adds	r3, #1
 80106c4:	613b      	str	r3, [r7, #16]
 80106c6:	693b      	ldr	r3, [r7, #16]
 80106c8:	2b0f      	cmp	r3, #15
 80106ca:	d9e0      	bls.n	801068e <hci_acl_packet_types_for_buffer_size_and_local_features+0x16>
        }
    }
    // disable packet types due to missing local supported features
    for (i=0;i<sizeof(packet_type_feature_requirement_bit);i++){
 80106cc:	2300      	movs	r3, #0
 80106ce:	613b      	str	r3, [r7, #16]
 80106d0:	e039      	b.n	8010746 <hci_acl_packet_types_for_buffer_size_and_local_features+0xce>
        unsigned int bit_idx = packet_type_feature_requirement_bit[i];
 80106d2:	4a25      	ldr	r2, [pc, #148]	; (8010768 <hci_acl_packet_types_for_buffer_size_and_local_features+0xf0>)
 80106d4:	693b      	ldr	r3, [r7, #16]
 80106d6:	4413      	add	r3, r2
 80106d8:	781b      	ldrb	r3, [r3, #0]
 80106da:	60fb      	str	r3, [r7, #12]
        int feature_set = (local_supported_features[bit_idx >> 3] & (1<<(bit_idx & 7))) != 0;
 80106dc:	68fb      	ldr	r3, [r7, #12]
 80106de:	08db      	lsrs	r3, r3, #3
 80106e0:	683a      	ldr	r2, [r7, #0]
 80106e2:	4413      	add	r3, r2
 80106e4:	781b      	ldrb	r3, [r3, #0]
 80106e6:	461a      	mov	r2, r3
 80106e8:	68fb      	ldr	r3, [r7, #12]
 80106ea:	f003 0307 	and.w	r3, r3, #7
 80106ee:	fa42 f303 	asr.w	r3, r2, r3
 80106f2:	f003 0301 	and.w	r3, r3, #1
 80106f6:	2b00      	cmp	r3, #0
 80106f8:	bf14      	ite	ne
 80106fa:	2301      	movne	r3, #1
 80106fc:	2300      	moveq	r3, #0
 80106fe:	b2db      	uxtb	r3, r3
 8010700:	60bb      	str	r3, [r7, #8]
        if (feature_set) continue;
 8010702:	68bb      	ldr	r3, [r7, #8]
 8010704:	2b00      	cmp	r3, #0
 8010706:	d11a      	bne.n	801073e <hci_acl_packet_types_for_buffer_size_and_local_features+0xc6>
        log_info("Features bit %02u is not set, removing packet types 0x%04x", bit_idx, packet_type_feature_packet_mask[i]);
 8010708:	4a18      	ldr	r2, [pc, #96]	; (801076c <hci_acl_packet_types_for_buffer_size_and_local_features+0xf4>)
 801070a:	693b      	ldr	r3, [r7, #16]
 801070c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8010710:	9301      	str	r3, [sp, #4]
 8010712:	68fb      	ldr	r3, [r7, #12]
 8010714:	9300      	str	r3, [sp, #0]
 8010716:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
 801071a:	4a15      	ldr	r2, [pc, #84]	; (8010770 <hci_acl_packet_types_for_buffer_size_and_local_features+0xf8>)
 801071c:	4915      	ldr	r1, [pc, #84]	; (8010774 <hci_acl_packet_types_for_buffer_size_and_local_features+0xfc>)
 801071e:	2001      	movs	r0, #1
 8010720:	f006 fe8e 	bl	8017440 <hci_dump_log>
        packet_types &= ~packet_type_feature_packet_mask[i];
 8010724:	4a11      	ldr	r2, [pc, #68]	; (801076c <hci_acl_packet_types_for_buffer_size_and_local_features+0xf4>)
 8010726:	693b      	ldr	r3, [r7, #16]
 8010728:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 801072c:	b21b      	sxth	r3, r3
 801072e:	43db      	mvns	r3, r3
 8010730:	b21a      	sxth	r2, r3
 8010732:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8010736:	4013      	ands	r3, r2
 8010738:	b21b      	sxth	r3, r3
 801073a:	82fb      	strh	r3, [r7, #22]
 801073c:	e000      	b.n	8010740 <hci_acl_packet_types_for_buffer_size_and_local_features+0xc8>
        if (feature_set) continue;
 801073e:	bf00      	nop
    for (i=0;i<sizeof(packet_type_feature_requirement_bit);i++){
 8010740:	693b      	ldr	r3, [r7, #16]
 8010742:	3301      	adds	r3, #1
 8010744:	613b      	str	r3, [r7, #16]
 8010746:	693b      	ldr	r3, [r7, #16]
 8010748:	2b05      	cmp	r3, #5
 801074a:	d9c2      	bls.n	80106d2 <hci_acl_packet_types_for_buffer_size_and_local_features+0x5a>
    }
    // flip bits for "may not be used"
    packet_types ^= 0x3306;
 801074c:	8afb      	ldrh	r3, [r7, #22]
 801074e:	f483 534c 	eor.w	r3, r3, #13056	; 0x3300
 8010752:	f083 0306 	eor.w	r3, r3, #6
 8010756:	82fb      	strh	r3, [r7, #22]
    return packet_types;
 8010758:	8afb      	ldrh	r3, [r7, #22]
}
 801075a:	4618      	mov	r0, r3
 801075c:	3718      	adds	r7, #24
 801075e:	46bd      	mov	sp, r7
 8010760:	bd80      	pop	{r7, pc}
 8010762:	bf00      	nop
 8010764:	080309c4 	.word	0x080309c4
 8010768:	080309e4 	.word	0x080309e4
 801076c:	080309ec 	.word	0x080309ec
 8010770:	0802929c 	.word	0x0802929c
 8010774:	08029988 	.word	0x08029988

08010778 <hci_usable_acl_packet_types>:

uint16_t hci_usable_acl_packet_types(void){
 8010778:	b480      	push	{r7}
 801077a:	af00      	add	r7, sp, #0
    return hci_stack->packet_types;
 801077c:	4b04      	ldr	r3, [pc, #16]	; (8010790 <hci_usable_acl_packet_types+0x18>)
 801077e:	681b      	ldr	r3, [r3, #0]
 8010780:	f8b3 3714 	ldrh.w	r3, [r3, #1812]	; 0x714
}
 8010784:	4618      	mov	r0, r3
 8010786:	46bd      	mov	sp, r7
 8010788:	f85d 7b04 	ldr.w	r7, [sp], #4
 801078c:	4770      	bx	lr
 801078e:	bf00      	nop
 8010790:	20009780 	.word	0x20009780

08010794 <hci_get_outgoing_packet_buffer>:
#endif

uint8_t* hci_get_outgoing_packet_buffer(void){
 8010794:	b480      	push	{r7}
 8010796:	af00      	add	r7, sp, #0
    // hci packet buffer is >= acl data packet length
    return hci_stack->hci_packet_buffer;
 8010798:	4b03      	ldr	r3, [pc, #12]	; (80107a8 <hci_get_outgoing_packet_buffer+0x14>)
 801079a:	681b      	ldr	r3, [r3, #0]
 801079c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
 801079e:	4618      	mov	r0, r3
 80107a0:	46bd      	mov	sp, r7
 80107a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80107a6:	4770      	bx	lr
 80107a8:	20009780 	.word	0x20009780

080107ac <hci_max_acl_data_packet_length>:

uint16_t hci_max_acl_data_packet_length(void){
 80107ac:	b480      	push	{r7}
 80107ae:	af00      	add	r7, sp, #0
    return hci_stack->acl_data_packet_length;
 80107b0:	4b04      	ldr	r3, [pc, #16]	; (80107c4 <hci_max_acl_data_packet_length+0x18>)
 80107b2:	681b      	ldr	r3, [r3, #0]
 80107b4:	f8b3 36fe 	ldrh.w	r3, [r3, #1790]	; 0x6fe
}
 80107b8:	4618      	mov	r0, r3
 80107ba:	46bd      	mov	sp, r7
 80107bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80107c0:	4770      	bx	lr
 80107c2:	bf00      	nop
 80107c4:	20009780 	.word	0x20009780

080107c8 <hci_extended_sco_link_supported>:

#ifdef ENABLE_CLASSIC
int hci_extended_sco_link_supported(void){
 80107c8:	b480      	push	{r7}
 80107ca:	af00      	add	r7, sp, #0
    // No. 31, byte 3, bit 7
    return (hci_stack->local_supported_features[3] & (1 << 7)) != 0;
 80107cc:	4b06      	ldr	r3, [pc, #24]	; (80107e8 <hci_extended_sco_link_supported+0x20>)
 80107ce:	681b      	ldr	r3, [r3, #0]
 80107d0:	f893 370b 	ldrb.w	r3, [r3, #1803]	; 0x70b
 80107d4:	b25b      	sxtb	r3, r3
 80107d6:	b2db      	uxtb	r3, r3
 80107d8:	09db      	lsrs	r3, r3, #7
 80107da:	b2db      	uxtb	r3, r3
}
 80107dc:	4618      	mov	r0, r3
 80107de:	46bd      	mov	sp, r7
 80107e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80107e4:	4770      	bx	lr
 80107e6:	bf00      	nop
 80107e8:	20009780 	.word	0x20009780

080107ec <hci_non_flushable_packet_boundary_flag_supported>:
#endif

int hci_non_flushable_packet_boundary_flag_supported(void){
 80107ec:	b480      	push	{r7}
 80107ee:	af00      	add	r7, sp, #0
    // No. 54, byte 6, bit 6
    return (hci_stack->local_supported_features[6u] & (1u << 6u)) != 0u;
 80107f0:	4b07      	ldr	r3, [pc, #28]	; (8010810 <hci_non_flushable_packet_boundary_flag_supported+0x24>)
 80107f2:	681b      	ldr	r3, [r3, #0]
 80107f4:	f893 370e 	ldrb.w	r3, [r3, #1806]	; 0x70e
 80107f8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80107fc:	2b00      	cmp	r3, #0
 80107fe:	bf14      	ite	ne
 8010800:	2301      	movne	r3, #1
 8010802:	2300      	moveq	r3, #0
 8010804:	b2db      	uxtb	r3, r3
}
 8010806:	4618      	mov	r0, r3
 8010808:	46bd      	mov	sp, r7
 801080a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801080e:	4770      	bx	lr
 8010810:	20009780 	.word	0x20009780

08010814 <gap_ssp_supported>:

static int gap_ssp_supported(void){
 8010814:	b480      	push	{r7}
 8010816:	af00      	add	r7, sp, #0
    // No. 51, byte 6, bit 3
    return (hci_stack->local_supported_features[6u] & (1u << 3u)) != 0u;
 8010818:	4b07      	ldr	r3, [pc, #28]	; (8010838 <gap_ssp_supported+0x24>)
 801081a:	681b      	ldr	r3, [r3, #0]
 801081c:	f893 370e 	ldrb.w	r3, [r3, #1806]	; 0x70e
 8010820:	f003 0308 	and.w	r3, r3, #8
 8010824:	2b00      	cmp	r3, #0
 8010826:	bf14      	ite	ne
 8010828:	2301      	movne	r3, #1
 801082a:	2300      	moveq	r3, #0
 801082c:	b2db      	uxtb	r3, r3
}
 801082e:	4618      	mov	r0, r3
 8010830:	46bd      	mov	sp, r7
 8010832:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010836:	4770      	bx	lr
 8010838:	20009780 	.word	0x20009780

0801083c <hci_classic_supported>:

static int hci_classic_supported(void){
 801083c:	b480      	push	{r7}
 801083e:	af00      	add	r7, sp, #0
#ifdef ENABLE_CLASSIC    
    // No. 37, byte 4, bit 5, = No BR/EDR Support
    return (hci_stack->local_supported_features[4] & (1 << 5)) == 0;
 8010840:	4b07      	ldr	r3, [pc, #28]	; (8010860 <hci_classic_supported+0x24>)
 8010842:	681b      	ldr	r3, [r3, #0]
 8010844:	f893 370c 	ldrb.w	r3, [r3, #1804]	; 0x70c
 8010848:	f003 0320 	and.w	r3, r3, #32
 801084c:	2b00      	cmp	r3, #0
 801084e:	bf0c      	ite	eq
 8010850:	2301      	moveq	r3, #1
 8010852:	2300      	movne	r3, #0
 8010854:	b2db      	uxtb	r3, r3
#else
    return 0;
#endif
}
 8010856:	4618      	mov	r0, r3
 8010858:	46bd      	mov	sp, r7
 801085a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801085e:	4770      	bx	lr
 8010860:	20009780 	.word	0x20009780

08010864 <hci_le_supported>:

static int hci_le_supported(void){
 8010864:	b480      	push	{r7}
 8010866:	af00      	add	r7, sp, #0
#ifdef ENABLE_BLE
    // No. 37, byte 4, bit 6 = LE Supported (Controller)
    return (hci_stack->local_supported_features[4u] & (1u << 6u)) != 0u;
 8010868:	4b07      	ldr	r3, [pc, #28]	; (8010888 <hci_le_supported+0x24>)
 801086a:	681b      	ldr	r3, [r3, #0]
 801086c:	f893 370c 	ldrb.w	r3, [r3, #1804]	; 0x70c
 8010870:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010874:	2b00      	cmp	r3, #0
 8010876:	bf14      	ite	ne
 8010878:	2301      	movne	r3, #1
 801087a:	2300      	moveq	r3, #0
 801087c:	b2db      	uxtb	r3, r3
#else
    return 0;
#endif    
}
 801087e:	4618      	mov	r0, r3
 8010880:	46bd      	mov	sp, r7
 8010882:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010886:	4770      	bx	lr
 8010888:	20009780 	.word	0x20009780

0801088c <gap_le_get_own_address>:
#ifdef ENABLE_BLE

/**
 * @brief Get addr type and address used for LE in Advertisements, Scan Responses, 
 */
void gap_le_get_own_address(uint8_t * addr_type, bd_addr_t addr){
 801088c:	b580      	push	{r7, lr}
 801088e:	b082      	sub	sp, #8
 8010890:	af00      	add	r7, sp, #0
 8010892:	6078      	str	r0, [r7, #4]
 8010894:	6039      	str	r1, [r7, #0]
    *addr_type = hci_stack->le_own_addr_type;
 8010896:	4b11      	ldr	r3, [pc, #68]	; (80108dc <gap_le_get_own_address+0x50>)
 8010898:	681b      	ldr	r3, [r3, #0]
 801089a:	f893 2754 	ldrb.w	r2, [r3, #1876]	; 0x754
 801089e:	687b      	ldr	r3, [r7, #4]
 80108a0:	701a      	strb	r2, [r3, #0]
    if (hci_stack->le_own_addr_type){
 80108a2:	4b0e      	ldr	r3, [pc, #56]	; (80108dc <gap_le_get_own_address+0x50>)
 80108a4:	681b      	ldr	r3, [r3, #0]
 80108a6:	f893 3754 	ldrb.w	r3, [r3, #1876]	; 0x754
 80108aa:	2b00      	cmp	r3, #0
 80108ac:	d009      	beq.n	80108c2 <gap_le_get_own_address+0x36>
        (void)memcpy(addr, hci_stack->le_random_address, 6);
 80108ae:	4b0b      	ldr	r3, [pc, #44]	; (80108dc <gap_le_get_own_address+0x50>)
 80108b0:	681b      	ldr	r3, [r3, #0]
 80108b2:	f203 7355 	addw	r3, r3, #1877	; 0x755
 80108b6:	2206      	movs	r2, #6
 80108b8:	4619      	mov	r1, r3
 80108ba:	6838      	ldr	r0, [r7, #0]
 80108bc:	f017 f8dd 	bl	8027a7a <memcpy>
    } else {
        (void)memcpy(addr, hci_stack->local_bd_addr, 6);
    }
}
 80108c0:	e007      	b.n	80108d2 <gap_le_get_own_address+0x46>
        (void)memcpy(addr, hci_stack->local_bd_addr, 6);
 80108c2:	4b06      	ldr	r3, [pc, #24]	; (80108dc <gap_le_get_own_address+0x50>)
 80108c4:	681b      	ldr	r3, [r3, #0]
 80108c6:	3338      	adds	r3, #56	; 0x38
 80108c8:	2206      	movs	r2, #6
 80108ca:	4619      	mov	r1, r3
 80108cc:	6838      	ldr	r0, [r7, #0]
 80108ce:	f017 f8d4 	bl	8027a7a <memcpy>
}
 80108d2:	bf00      	nop
 80108d4:	3708      	adds	r7, #8
 80108d6:	46bd      	mov	sp, r7
 80108d8:	bd80      	pop	{r7, pc}
 80108da:	bf00      	nop
 80108dc:	20009780 	.word	0x20009780

080108e0 <le_handle_advertisement_report>:

#ifdef ENABLE_LE_CENTRAL
void le_handle_advertisement_report(uint8_t *packet, uint16_t size){
 80108e0:	b580      	push	{r7, lr}
 80108e2:	b092      	sub	sp, #72	; 0x48
 80108e4:	af00      	add	r7, sp, #0
 80108e6:	6078      	str	r0, [r7, #4]
 80108e8:	460b      	mov	r3, r1
 80108ea:	807b      	strh	r3, [r7, #2]

    int offset = 3;
 80108ec:	2303      	movs	r3, #3
 80108ee:	647b      	str	r3, [r7, #68]	; 0x44
    int num_reports = packet[offset];
 80108f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80108f2:	687a      	ldr	r2, [r7, #4]
 80108f4:	4413      	add	r3, r2
 80108f6:	781b      	ldrb	r3, [r3, #0]
 80108f8:	63fb      	str	r3, [r7, #60]	; 0x3c
    offset += 1;
 80108fa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80108fc:	3301      	adds	r3, #1
 80108fe:	647b      	str	r3, [r7, #68]	; 0x44

    int i;
    // log_info("HCI: handle adv report with num reports: %d", num_reports);
    uint8_t event[12 + LE_ADVERTISING_DATA_SIZE]; // use upper bound to avoid var size automatic var
    for (i=0; (i<num_reports) && (offset < size);i++){
 8010900:	2300      	movs	r3, #0
 8010902:	643b      	str	r3, [r7, #64]	; 0x40
 8010904:	e07e      	b.n	8010a04 <le_handle_advertisement_report+0x124>
        // sanity checks on data_length:
        uint8_t data_length = packet[offset + 8];
 8010906:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010908:	3308      	adds	r3, #8
 801090a:	687a      	ldr	r2, [r7, #4]
 801090c:	4413      	add	r3, r2
 801090e:	781b      	ldrb	r3, [r3, #0]
 8010910:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
        if (data_length > LE_ADVERTISING_DATA_SIZE) return;
 8010914:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8010918:	2b1f      	cmp	r3, #31
 801091a:	d87d      	bhi.n	8010a18 <le_handle_advertisement_report+0x138>
        if ((offset + 9u + data_length + 1u) > size)    return;
 801091c:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 8010920:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010922:	4413      	add	r3, r2
 8010924:	f103 020a 	add.w	r2, r3, #10
 8010928:	887b      	ldrh	r3, [r7, #2]
 801092a:	429a      	cmp	r2, r3
 801092c:	d876      	bhi.n	8010a1c <le_handle_advertisement_report+0x13c>
        // setup event
        uint8_t event_size = 10u + data_length;
 801092e:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8010932:	330a      	adds	r3, #10
 8010934:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a
        int pos = 0;
 8010938:	2300      	movs	r3, #0
 801093a:	637b      	str	r3, [r7, #52]	; 0x34
        event[pos++] = GAP_EVENT_ADVERTISING_REPORT;
 801093c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801093e:	1c5a      	adds	r2, r3, #1
 8010940:	637a      	str	r2, [r7, #52]	; 0x34
 8010942:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8010946:	4413      	add	r3, r2
 8010948:	22e2      	movs	r2, #226	; 0xe2
 801094a:	f803 2c40 	strb.w	r2, [r3, #-64]
        event[pos++] = event_size;
 801094e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010950:	1c5a      	adds	r2, r3, #1
 8010952:	637a      	str	r2, [r7, #52]	; 0x34
 8010954:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8010958:	4413      	add	r3, r2
 801095a:	f897 203a 	ldrb.w	r2, [r7, #58]	; 0x3a
 801095e:	f803 2c40 	strb.w	r2, [r3, #-64]
        (void)memcpy(&event[pos], &packet[offset], 1 + 1 + 6); // event type + address type + address
 8010962:	f107 0208 	add.w	r2, r7, #8
 8010966:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010968:	18d0      	adds	r0, r2, r3
 801096a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801096c:	687a      	ldr	r2, [r7, #4]
 801096e:	4413      	add	r3, r2
 8010970:	2208      	movs	r2, #8
 8010972:	4619      	mov	r1, r3
 8010974:	f017 f881 	bl	8027a7a <memcpy>
        offset += 8;
 8010978:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801097a:	3308      	adds	r3, #8
 801097c:	647b      	str	r3, [r7, #68]	; 0x44
        pos += 8;
 801097e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010980:	3308      	adds	r3, #8
 8010982:	637b      	str	r3, [r7, #52]	; 0x34
        event[pos++] = packet[offset + 1 + data_length]; // rssi
 8010984:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010986:	1c5a      	adds	r2, r3, #1
 8010988:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 801098c:	4413      	add	r3, r2
 801098e:	461a      	mov	r2, r3
 8010990:	687b      	ldr	r3, [r7, #4]
 8010992:	441a      	add	r2, r3
 8010994:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010996:	1c59      	adds	r1, r3, #1
 8010998:	6379      	str	r1, [r7, #52]	; 0x34
 801099a:	7812      	ldrb	r2, [r2, #0]
 801099c:	f107 0148 	add.w	r1, r7, #72	; 0x48
 80109a0:	440b      	add	r3, r1
 80109a2:	f803 2c40 	strb.w	r2, [r3, #-64]
        event[pos++] = data_length;
 80109a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80109a8:	1c5a      	adds	r2, r3, #1
 80109aa:	637a      	str	r2, [r7, #52]	; 0x34
 80109ac:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80109b0:	4413      	add	r3, r2
 80109b2:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 80109b6:	f803 2c40 	strb.w	r2, [r3, #-64]
        offset++;
 80109ba:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80109bc:	3301      	adds	r3, #1
 80109be:	647b      	str	r3, [r7, #68]	; 0x44
        (void)memcpy(&event[pos], &packet[offset], data_length);
 80109c0:	f107 0208 	add.w	r2, r7, #8
 80109c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80109c6:	18d0      	adds	r0, r2, r3
 80109c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80109ca:	687a      	ldr	r2, [r7, #4]
 80109cc:	4413      	add	r3, r2
 80109ce:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 80109d2:	4619      	mov	r1, r3
 80109d4:	f017 f851 	bl	8027a7a <memcpy>
        pos +=    data_length;
 80109d8:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 80109dc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80109de:	4413      	add	r3, r2
 80109e0:	637b      	str	r3, [r7, #52]	; 0x34
        offset += data_length + 1u; // rssi
 80109e2:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 80109e6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80109e8:	4413      	add	r3, r2
 80109ea:	3301      	adds	r3, #1
 80109ec:	647b      	str	r3, [r7, #68]	; 0x44
        hci_emit_event(event, pos, 1);
 80109ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80109f0:	b299      	uxth	r1, r3
 80109f2:	f107 0308 	add.w	r3, r7, #8
 80109f6:	2201      	movs	r2, #1
 80109f8:	4618      	mov	r0, r3
 80109fa:	f005 fb05 	bl	8016008 <hci_emit_event>
    for (i=0; (i<num_reports) && (offset < size);i++){
 80109fe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010a00:	3301      	adds	r3, #1
 8010a02:	643b      	str	r3, [r7, #64]	; 0x40
 8010a04:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8010a06:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010a08:	429a      	cmp	r2, r3
 8010a0a:	da08      	bge.n	8010a1e <le_handle_advertisement_report+0x13e>
 8010a0c:	887b      	ldrh	r3, [r7, #2]
 8010a0e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8010a10:	429a      	cmp	r2, r3
 8010a12:	f6ff af78 	blt.w	8010906 <le_handle_advertisement_report+0x26>
 8010a16:	e002      	b.n	8010a1e <le_handle_advertisement_report+0x13e>
        if (data_length > LE_ADVERTISING_DATA_SIZE) return;
 8010a18:	bf00      	nop
 8010a1a:	e000      	b.n	8010a1e <le_handle_advertisement_report+0x13e>
        if ((offset + 9u + data_length + 1u) > size)    return;
 8010a1c:	bf00      	nop
    }
}
 8010a1e:	3748      	adds	r7, #72	; 0x48
 8010a20:	46bd      	mov	sp, r7
 8010a22:	bd80      	pop	{r7, pc}

08010a24 <hci_update_advertisements_enabled_for_current_roles>:
#endif
#endif

#ifdef ENABLE_BLE
#ifdef ENABLE_LE_PERIPHERAL
static void hci_update_advertisements_enabled_for_current_roles(void){
 8010a24:	b5b0      	push	{r4, r5, r7, lr}
 8010a26:	b08a      	sub	sp, #40	; 0x28
 8010a28:	af04      	add	r7, sp, #16
    if (hci_stack->le_advertisements_enabled){
 8010a2a:	4b36      	ldr	r3, [pc, #216]	; (8010b04 <hci_update_advertisements_enabled_for_current_roles+0xe0>)
 8010a2c:	681b      	ldr	r3, [r3, #0]
 8010a2e:	f893 379a 	ldrb.w	r3, [r3, #1946]	; 0x79a
 8010a32:	2b00      	cmp	r3, #0
 8010a34:	d05d      	beq.n	8010af2 <hci_update_advertisements_enabled_for_current_roles+0xce>
        // get number of active le slave connections
        int num_slave_connections = 0;
 8010a36:	2300      	movs	r3, #0
 8010a38:	617b      	str	r3, [r7, #20]
        btstack_linked_list_iterator_t it;
        btstack_linked_list_iterator_init(&it, &hci_stack->connections);
 8010a3a:	4b32      	ldr	r3, [pc, #200]	; (8010b04 <hci_update_advertisements_enabled_for_current_roles+0xe0>)
 8010a3c:	681b      	ldr	r3, [r3, #0]
 8010a3e:	f103 0214 	add.w	r2, r3, #20
 8010a42:	1d3b      	adds	r3, r7, #4
 8010a44:	4611      	mov	r1, r2
 8010a46:	4618      	mov	r0, r3
 8010a48:	f7fd fe81 	bl	800e74e <btstack_linked_list_iterator_init>
        while (btstack_linked_list_iterator_has_next(&it)){
 8010a4c:	e02c      	b.n	8010aa8 <hci_update_advertisements_enabled_for_current_roles+0x84>
            hci_connection_t * con = (hci_connection_t*) btstack_linked_list_iterator_next(&it);
 8010a4e:	1d3b      	adds	r3, r7, #4
 8010a50:	4618      	mov	r0, r3
 8010a52:	f7fd febf 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8010a56:	6138      	str	r0, [r7, #16]
            log_info("state %u, role %u, le_con %u", con->state, con->role, hci_is_le_connection(con));
 8010a58:	693b      	ldr	r3, [r7, #16]
 8010a5a:	7b9b      	ldrb	r3, [r3, #14]
 8010a5c:	461c      	mov	r4, r3
 8010a5e:	693b      	ldr	r3, [r7, #16]
 8010a60:	7b5b      	ldrb	r3, [r3, #13]
 8010a62:	461d      	mov	r5, r3
 8010a64:	6938      	ldr	r0, [r7, #16]
 8010a66:	f7ff f8b1 	bl	800fbcc <hci_is_le_connection>
 8010a6a:	4603      	mov	r3, r0
 8010a6c:	9302      	str	r3, [sp, #8]
 8010a6e:	9501      	str	r5, [sp, #4]
 8010a70:	9400      	str	r4, [sp, #0]
 8010a72:	f240 436c 	movw	r3, #1132	; 0x46c
 8010a76:	4a24      	ldr	r2, [pc, #144]	; (8010b08 <hci_update_advertisements_enabled_for_current_roles+0xe4>)
 8010a78:	4924      	ldr	r1, [pc, #144]	; (8010b0c <hci_update_advertisements_enabled_for_current_roles+0xe8>)
 8010a7a:	2001      	movs	r0, #1
 8010a7c:	f006 fce0 	bl	8017440 <hci_dump_log>
            if (con->state != OPEN) continue;
 8010a80:	693b      	ldr	r3, [r7, #16]
 8010a82:	7b9b      	ldrb	r3, [r3, #14]
 8010a84:	2b07      	cmp	r3, #7
 8010a86:	d000      	beq.n	8010a8a <hci_update_advertisements_enabled_for_current_roles+0x66>
 8010a88:	e00e      	b.n	8010aa8 <hci_update_advertisements_enabled_for_current_roles+0x84>
            if (con->role  != HCI_ROLE_SLAVE) continue;
 8010a8a:	693b      	ldr	r3, [r7, #16]
 8010a8c:	7b5b      	ldrb	r3, [r3, #13]
 8010a8e:	2b01      	cmp	r3, #1
 8010a90:	d000      	beq.n	8010a94 <hci_update_advertisements_enabled_for_current_roles+0x70>
 8010a92:	e009      	b.n	8010aa8 <hci_update_advertisements_enabled_for_current_roles+0x84>
            if (!hci_is_le_connection(con)) continue;
 8010a94:	6938      	ldr	r0, [r7, #16]
 8010a96:	f7ff f899 	bl	800fbcc <hci_is_le_connection>
 8010a9a:	4603      	mov	r3, r0
 8010a9c:	2b00      	cmp	r3, #0
 8010a9e:	d100      	bne.n	8010aa2 <hci_update_advertisements_enabled_for_current_roles+0x7e>
 8010aa0:	e002      	b.n	8010aa8 <hci_update_advertisements_enabled_for_current_roles+0x84>
            num_slave_connections++;
 8010aa2:	697b      	ldr	r3, [r7, #20]
 8010aa4:	3301      	adds	r3, #1
 8010aa6:	617b      	str	r3, [r7, #20]
        while (btstack_linked_list_iterator_has_next(&it)){
 8010aa8:	1d3b      	adds	r3, r7, #4
 8010aaa:	4618      	mov	r0, r3
 8010aac:	f7fd fe64 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8010ab0:	4603      	mov	r3, r0
 8010ab2:	2b00      	cmp	r3, #0
 8010ab4:	d1cb      	bne.n	8010a4e <hci_update_advertisements_enabled_for_current_roles+0x2a>
        }
        log_info("Num LE Peripheral roles: %u of %u", num_slave_connections, hci_stack->le_max_number_peripheral_connections);
 8010ab6:	4b13      	ldr	r3, [pc, #76]	; (8010b04 <hci_update_advertisements_enabled_for_current_roles+0xe0>)
 8010ab8:	681b      	ldr	r3, [r3, #0]
 8010aba:	f893 37ac 	ldrb.w	r3, [r3, #1964]	; 0x7ac
 8010abe:	9301      	str	r3, [sp, #4]
 8010ac0:	697b      	ldr	r3, [r7, #20]
 8010ac2:	9300      	str	r3, [sp, #0]
 8010ac4:	f240 4372 	movw	r3, #1138	; 0x472
 8010ac8:	4a0f      	ldr	r2, [pc, #60]	; (8010b08 <hci_update_advertisements_enabled_for_current_roles+0xe4>)
 8010aca:	4911      	ldr	r1, [pc, #68]	; (8010b10 <hci_update_advertisements_enabled_for_current_roles+0xec>)
 8010acc:	2001      	movs	r0, #1
 8010ace:	f006 fcb7 	bl	8017440 <hci_dump_log>
        hci_stack->le_advertisements_enabled_for_current_roles = num_slave_connections < hci_stack->le_max_number_peripheral_connections;
 8010ad2:	4b0c      	ldr	r3, [pc, #48]	; (8010b04 <hci_update_advertisements_enabled_for_current_roles+0xe0>)
 8010ad4:	681b      	ldr	r3, [r3, #0]
 8010ad6:	f893 37ac 	ldrb.w	r3, [r3, #1964]	; 0x7ac
 8010ada:	4619      	mov	r1, r3
 8010adc:	4b09      	ldr	r3, [pc, #36]	; (8010b04 <hci_update_advertisements_enabled_for_current_roles+0xe0>)
 8010ade:	681b      	ldr	r3, [r3, #0]
 8010ae0:	697a      	ldr	r2, [r7, #20]
 8010ae2:	428a      	cmp	r2, r1
 8010ae4:	bfb4      	ite	lt
 8010ae6:	2201      	movlt	r2, #1
 8010ae8:	2200      	movge	r2, #0
 8010aea:	b2d2      	uxtb	r2, r2
 8010aec:	f883 279b 	strb.w	r2, [r3, #1947]	; 0x79b
    } else {
        hci_stack->le_advertisements_enabled_for_current_roles = false;
    }
}
 8010af0:	e004      	b.n	8010afc <hci_update_advertisements_enabled_for_current_roles+0xd8>
        hci_stack->le_advertisements_enabled_for_current_roles = false;
 8010af2:	4b04      	ldr	r3, [pc, #16]	; (8010b04 <hci_update_advertisements_enabled_for_current_roles+0xe0>)
 8010af4:	681b      	ldr	r3, [r3, #0]
 8010af6:	2200      	movs	r2, #0
 8010af8:	f883 279b 	strb.w	r2, [r3, #1947]	; 0x79b
}
 8010afc:	bf00      	nop
 8010afe:	3718      	adds	r7, #24
 8010b00:	46bd      	mov	sp, r7
 8010b02:	bdb0      	pop	{r4, r5, r7, pc}
 8010b04:	20009780 	.word	0x20009780
 8010b08:	0802929c 	.word	0x0802929c
 8010b0c:	080299cc 	.word	0x080299cc
 8010b10:	080299f0 	.word	0x080299f0

08010b14 <hci_transport_uart_get_main_baud_rate>:
#endif
#endif

#if !defined(HAVE_PLATFORM_IPHONE_OS) && !defined (HAVE_HOST_CONTROLLER_API)

static uint32_t hci_transport_uart_get_main_baud_rate(void){
 8010b14:	b480      	push	{r7}
 8010b16:	b083      	sub	sp, #12
 8010b18:	af00      	add	r7, sp, #0
    if (!hci_stack->config) return 0;
 8010b1a:	4b0f      	ldr	r3, [pc, #60]	; (8010b58 <hci_transport_uart_get_main_baud_rate+0x44>)
 8010b1c:	681b      	ldr	r3, [r3, #0]
 8010b1e:	685b      	ldr	r3, [r3, #4]
 8010b20:	2b00      	cmp	r3, #0
 8010b22:	d101      	bne.n	8010b28 <hci_transport_uart_get_main_baud_rate+0x14>
 8010b24:	2300      	movs	r3, #0
 8010b26:	e011      	b.n	8010b4c <hci_transport_uart_get_main_baud_rate+0x38>
    uint32_t baud_rate = ((hci_transport_config_uart_t *)hci_stack->config)->baudrate_main;
 8010b28:	4b0b      	ldr	r3, [pc, #44]	; (8010b58 <hci_transport_uart_get_main_baud_rate+0x44>)
 8010b2a:	681b      	ldr	r3, [r3, #0]
 8010b2c:	685b      	ldr	r3, [r3, #4]
 8010b2e:	689b      	ldr	r3, [r3, #8]
 8010b30:	607b      	str	r3, [r7, #4]
    // Limit baud rate for Broadcom chipsets to 3 mbps
    if ((hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_BROADCOM_CORPORATION) && (baud_rate > 3000000)){
 8010b32:	4b09      	ldr	r3, [pc, #36]	; (8010b58 <hci_transport_uart_get_main_baud_rate+0x44>)
 8010b34:	681b      	ldr	r3, [r3, #0]
 8010b36:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 8010b3a:	2b0f      	cmp	r3, #15
 8010b3c:	d105      	bne.n	8010b4a <hci_transport_uart_get_main_baud_rate+0x36>
 8010b3e:	687b      	ldr	r3, [r7, #4]
 8010b40:	4a06      	ldr	r2, [pc, #24]	; (8010b5c <hci_transport_uart_get_main_baud_rate+0x48>)
 8010b42:	4293      	cmp	r3, r2
 8010b44:	d901      	bls.n	8010b4a <hci_transport_uart_get_main_baud_rate+0x36>
        baud_rate = 3000000;
 8010b46:	4b05      	ldr	r3, [pc, #20]	; (8010b5c <hci_transport_uart_get_main_baud_rate+0x48>)
 8010b48:	607b      	str	r3, [r7, #4]
    }
    return baud_rate;
 8010b4a:	687b      	ldr	r3, [r7, #4]
}
 8010b4c:	4618      	mov	r0, r3
 8010b4e:	370c      	adds	r7, #12
 8010b50:	46bd      	mov	sp, r7
 8010b52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010b56:	4770      	bx	lr
 8010b58:	20009780 	.word	0x20009780
 8010b5c:	002dc6c0 	.word	0x002dc6c0

08010b60 <hci_initialization_timeout_handler>:

static void hci_initialization_timeout_handler(btstack_timer_source_t * ds){
 8010b60:	b580      	push	{r7, lr}
 8010b62:	b086      	sub	sp, #24
 8010b64:	af02      	add	r7, sp, #8
 8010b66:	6078      	str	r0, [r7, #4]
    UNUSED(ds);

    switch (hci_stack->substate){
 8010b68:	4b53      	ldr	r3, [pc, #332]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010b6a:	681b      	ldr	r3, [r3, #0]
 8010b6c:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 8010b70:	3b01      	subs	r3, #1
 8010b72:	2b0c      	cmp	r3, #12
 8010b74:	f200 8099 	bhi.w	8010caa <hci_initialization_timeout_handler+0x14a>
 8010b78:	a201      	add	r2, pc, #4	; (adr r2, 8010b80 <hci_initialization_timeout_handler+0x20>)
 8010b7a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010b7e:	bf00      	nop
 8010b80:	08010bb5 	.word	0x08010bb5
 8010b84:	08010cab 	.word	0x08010cab
 8010b88:	08010cab 	.word	0x08010cab
 8010b8c:	08010cab 	.word	0x08010cab
 8010b90:	08010cab 	.word	0x08010cab
 8010b94:	08010cab 	.word	0x08010cab
 8010b98:	08010c29 	.word	0x08010c29
 8010b9c:	08010cab 	.word	0x08010cab
 8010ba0:	08010cab 	.word	0x08010cab
 8010ba4:	08010cab 	.word	0x08010cab
 8010ba8:	08010c01 	.word	0x08010c01
 8010bac:	08010bdd 	.word	0x08010bdd
 8010bb0:	08010c99 	.word	0x08010c99
        case HCI_INIT_W4_SEND_RESET:
            log_info("Resend HCI Reset");
 8010bb4:	f240 438c 	movw	r3, #1164	; 0x48c
 8010bb8:	4a40      	ldr	r2, [pc, #256]	; (8010cbc <hci_initialization_timeout_handler+0x15c>)
 8010bba:	4941      	ldr	r1, [pc, #260]	; (8010cc0 <hci_initialization_timeout_handler+0x160>)
 8010bbc:	2001      	movs	r0, #1
 8010bbe:	f006 fc3f 	bl	8017440 <hci_dump_log>
            hci_stack->substate = HCI_INIT_SEND_RESET;
 8010bc2:	4b3d      	ldr	r3, [pc, #244]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010bc4:	681b      	ldr	r3, [r3, #0]
 8010bc6:	2200      	movs	r2, #0
 8010bc8:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_stack->num_cmd_packets = 1;
 8010bcc:	4b3a      	ldr	r3, [pc, #232]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010bce:	681b      	ldr	r3, [r3, #0]
 8010bd0:	2201      	movs	r2, #1
 8010bd2:	f883 26fb 	strb.w	r2, [r3, #1787]	; 0x6fb
            hci_run();
 8010bd6:	f004 fe63 	bl	80158a0 <hci_run>
            break;
 8010bda:	e069      	b.n	8010cb0 <hci_initialization_timeout_handler+0x150>
        case HCI_INIT_W4_CUSTOM_INIT_CSR_WARM_BOOT_LINK_RESET:
            log_info("Resend HCI Reset - CSR Warm Boot with Link Reset");
 8010bdc:	f240 4392 	movw	r3, #1170	; 0x492
 8010be0:	4a36      	ldr	r2, [pc, #216]	; (8010cbc <hci_initialization_timeout_handler+0x15c>)
 8010be2:	4938      	ldr	r1, [pc, #224]	; (8010cc4 <hci_initialization_timeout_handler+0x164>)
 8010be4:	2001      	movs	r0, #1
 8010be6:	f006 fc2b 	bl	8017440 <hci_dump_log>
            if (hci_stack->hci_transport->reset_link){
 8010bea:	4b33      	ldr	r3, [pc, #204]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010bec:	681b      	ldr	r3, [r3, #0]
 8010bee:	681b      	ldr	r3, [r3, #0]
 8010bf0:	6a1b      	ldr	r3, [r3, #32]
 8010bf2:	2b00      	cmp	r3, #0
 8010bf4:	d004      	beq.n	8010c00 <hci_initialization_timeout_handler+0xa0>
                hci_stack->hci_transport->reset_link();
 8010bf6:	4b30      	ldr	r3, [pc, #192]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010bf8:	681b      	ldr	r3, [r3, #0]
 8010bfa:	681b      	ldr	r3, [r3, #0]
 8010bfc:	6a1b      	ldr	r3, [r3, #32]
 8010bfe:	4798      	blx	r3
            }

            /* fall through */

        case HCI_INIT_W4_CUSTOM_INIT_CSR_WARM_BOOT:
            log_info("Resend HCI Reset - CSR Warm Boot");
 8010c00:	f240 439a 	movw	r3, #1178	; 0x49a
 8010c04:	4a2d      	ldr	r2, [pc, #180]	; (8010cbc <hci_initialization_timeout_handler+0x15c>)
 8010c06:	4930      	ldr	r1, [pc, #192]	; (8010cc8 <hci_initialization_timeout_handler+0x168>)
 8010c08:	2001      	movs	r0, #1
 8010c0a:	f006 fc19 	bl	8017440 <hci_dump_log>
            hci_stack->substate = HCI_INIT_SEND_RESET_CSR_WARM_BOOT;
 8010c0e:	4b2a      	ldr	r3, [pc, #168]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010c10:	681b      	ldr	r3, [r3, #0]
 8010c12:	220a      	movs	r2, #10
 8010c14:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_stack->num_cmd_packets = 1;
 8010c18:	4b27      	ldr	r3, [pc, #156]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010c1a:	681b      	ldr	r3, [r3, #0]
 8010c1c:	2201      	movs	r2, #1
 8010c1e:	f883 26fb 	strb.w	r2, [r3, #1787]	; 0x6fb
            hci_run();
 8010c22:	f004 fe3d 	bl	80158a0 <hci_run>
            break;
 8010c26:	e043      	b.n	8010cb0 <hci_initialization_timeout_handler+0x150>
        case HCI_INIT_W4_SEND_BAUD_CHANGE:
            if (hci_stack->hci_transport->set_baudrate){
 8010c28:	4b23      	ldr	r3, [pc, #140]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010c2a:	681b      	ldr	r3, [r3, #0]
 8010c2c:	681b      	ldr	r3, [r3, #0]
 8010c2e:	69db      	ldr	r3, [r3, #28]
 8010c30:	2b00      	cmp	r3, #0
 8010c32:	d011      	beq.n	8010c58 <hci_initialization_timeout_handler+0xf8>
                uint32_t baud_rate = hci_transport_uart_get_main_baud_rate();
 8010c34:	f7ff ff6e 	bl	8010b14 <hci_transport_uart_get_main_baud_rate>
 8010c38:	60f8      	str	r0, [r7, #12]
                log_info("Local baud rate change to %" PRIu32 "(timeout handler)", baud_rate);
 8010c3a:	68fb      	ldr	r3, [r7, #12]
 8010c3c:	9300      	str	r3, [sp, #0]
 8010c3e:	f240 43a2 	movw	r3, #1186	; 0x4a2
 8010c42:	4a1e      	ldr	r2, [pc, #120]	; (8010cbc <hci_initialization_timeout_handler+0x15c>)
 8010c44:	4921      	ldr	r1, [pc, #132]	; (8010ccc <hci_initialization_timeout_handler+0x16c>)
 8010c46:	2001      	movs	r0, #1
 8010c48:	f006 fbfa 	bl	8017440 <hci_dump_log>
                hci_stack->hci_transport->set_baudrate(baud_rate);
 8010c4c:	4b1a      	ldr	r3, [pc, #104]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010c4e:	681b      	ldr	r3, [r3, #0]
 8010c50:	681b      	ldr	r3, [r3, #0]
 8010c52:	69db      	ldr	r3, [r3, #28]
 8010c54:	68f8      	ldr	r0, [r7, #12]
 8010c56:	4798      	blx	r3
            }
            // For CSR, HCI Reset is sent on new baud rate. Don't forget to reset link for H5/BCSP
            if (hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_CAMBRIDGE_SILICON_RADIO){
 8010c58:	4b17      	ldr	r3, [pc, #92]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010c5a:	681b      	ldr	r3, [r3, #0]
 8010c5c:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 8010c60:	2b0a      	cmp	r3, #10
 8010c62:	d124      	bne.n	8010cae <hci_initialization_timeout_handler+0x14e>
                if (hci_stack->hci_transport->reset_link){
 8010c64:	4b14      	ldr	r3, [pc, #80]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010c66:	681b      	ldr	r3, [r3, #0]
 8010c68:	681b      	ldr	r3, [r3, #0]
 8010c6a:	6a1b      	ldr	r3, [r3, #32]
 8010c6c:	2b00      	cmp	r3, #0
 8010c6e:	d00b      	beq.n	8010c88 <hci_initialization_timeout_handler+0x128>
                    log_info("Link Reset");
 8010c70:	f44f 6395 	mov.w	r3, #1192	; 0x4a8
 8010c74:	4a11      	ldr	r2, [pc, #68]	; (8010cbc <hci_initialization_timeout_handler+0x15c>)
 8010c76:	4916      	ldr	r1, [pc, #88]	; (8010cd0 <hci_initialization_timeout_handler+0x170>)
 8010c78:	2001      	movs	r0, #1
 8010c7a:	f006 fbe1 	bl	8017440 <hci_dump_log>
                    hci_stack->hci_transport->reset_link();
 8010c7e:	4b0e      	ldr	r3, [pc, #56]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010c80:	681b      	ldr	r3, [r3, #0]
 8010c82:	681b      	ldr	r3, [r3, #0]
 8010c84:	6a1b      	ldr	r3, [r3, #32]
 8010c86:	4798      	blx	r3
                }
                hci_stack->substate = HCI_INIT_SEND_RESET_CSR_WARM_BOOT;
 8010c88:	4b0b      	ldr	r3, [pc, #44]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010c8a:	681b      	ldr	r3, [r3, #0]
 8010c8c:	220a      	movs	r2, #10
 8010c8e:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                hci_run();
 8010c92:	f004 fe05 	bl	80158a0 <hci_run>
            }
            break;
 8010c96:	e00a      	b.n	8010cae <hci_initialization_timeout_handler+0x14e>
        case HCI_INIT_W4_CUSTOM_INIT_BCM_DELAY:
            // otherwise continue
            hci_stack->substate = HCI_INIT_W4_READ_LOCAL_SUPPORTED_COMMANDS;
 8010c98:	4b07      	ldr	r3, [pc, #28]	; (8010cb8 <hci_initialization_timeout_handler+0x158>)
 8010c9a:	681b      	ldr	r3, [r3, #0]
 8010c9c:	220f      	movs	r2, #15
 8010c9e:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_read_local_supported_commands);
 8010ca2:	480c      	ldr	r0, [pc, #48]	; (8010cd4 <hci_initialization_timeout_handler+0x174>)
 8010ca4:	f005 f99c 	bl	8015fe0 <hci_send_cmd>
            break;
 8010ca8:	e002      	b.n	8010cb0 <hci_initialization_timeout_handler+0x150>
        default:
            break;
 8010caa:	bf00      	nop
 8010cac:	e000      	b.n	8010cb0 <hci_initialization_timeout_handler+0x150>
            break;
 8010cae:	bf00      	nop
    }
}
 8010cb0:	bf00      	nop
 8010cb2:	3710      	adds	r7, #16
 8010cb4:	46bd      	mov	sp, r7
 8010cb6:	bd80      	pop	{r7, pc}
 8010cb8:	20009780 	.word	0x20009780
 8010cbc:	0802929c 	.word	0x0802929c
 8010cc0:	08029a1c 	.word	0x08029a1c
 8010cc4:	08029a34 	.word	0x08029a34
 8010cc8:	08029a6c 	.word	0x08029a6c
 8010ccc:	08029a94 	.word	0x08029a94
 8010cd0:	08029acc 	.word	0x08029acc
 8010cd4:	08030b48 	.word	0x08030b48

08010cd8 <hci_initializing_next_state>:
#endif

static void hci_initializing_next_state(void){
 8010cd8:	b480      	push	{r7}
 8010cda:	af00      	add	r7, sp, #0
    hci_stack->substate = (hci_substate_t )( ((int) hci_stack->substate) + 1);
 8010cdc:	4b07      	ldr	r3, [pc, #28]	; (8010cfc <hci_initializing_next_state+0x24>)
 8010cde:	681b      	ldr	r3, [r3, #0]
 8010ce0:	f893 2717 	ldrb.w	r2, [r3, #1815]	; 0x717
 8010ce4:	4b05      	ldr	r3, [pc, #20]	; (8010cfc <hci_initializing_next_state+0x24>)
 8010ce6:	681b      	ldr	r3, [r3, #0]
 8010ce8:	3201      	adds	r2, #1
 8010cea:	b2d2      	uxtb	r2, r2
 8010cec:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
}
 8010cf0:	bf00      	nop
 8010cf2:	46bd      	mov	sp, r7
 8010cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010cf8:	4770      	bx	lr
 8010cfa:	bf00      	nop
 8010cfc:	20009780 	.word	0x20009780

08010d00 <hci_initializing_run>:

// assumption: hci_can_send_command_packet_now() == true
static void hci_initializing_run(void){
 8010d00:	b590      	push	{r4, r7, lr}
 8010d02:	b093      	sub	sp, #76	; 0x4c
 8010d04:	af02      	add	r7, sp, #8
    log_debug("hci_initializing_run: substate %u, can send %u", hci_stack->substate, hci_can_send_command_packet_now());
    switch (hci_stack->substate){
 8010d06:	4bc7      	ldr	r3, [pc, #796]	; (8011024 <hci_initializing_run+0x324>)
 8010d08:	681b      	ldr	r3, [r3, #0]
 8010d0a:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 8010d0e:	2b42      	cmp	r3, #66	; 0x42
 8010d10:	f200 8566 	bhi.w	80117e0 <hci_initializing_run+0xae0>
 8010d14:	a201      	add	r2, pc, #4	; (adr r2, 8010d1c <hci_initializing_run+0x1c>)
 8010d16:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010d1a:	bf00      	nop
 8010d1c:	08010e29 	.word	0x08010e29
 8010d20:	080117e1 	.word	0x080117e1
 8010d24:	08010e6f 	.word	0x08010e6f
 8010d28:	080117e1 	.word	0x080117e1
 8010d2c:	08010e83 	.word	0x08010e83
 8010d30:	080117e1 	.word	0x080117e1
 8010d34:	08010ef5 	.word	0x08010ef5
 8010d38:	080117e1 	.word	0x080117e1
 8010d3c:	08010fd5 	.word	0x08010fd5
 8010d40:	080117e1 	.word	0x080117e1
 8010d44:	08010e97 	.word	0x08010e97
 8010d48:	080117e1 	.word	0x080117e1
 8010d4c:	080117e1 	.word	0x080117e1
 8010d50:	080117e1 	.word	0x080117e1
 8010d54:	080112af 	.word	0x080112af
 8010d58:	080117e1 	.word	0x080117e1
 8010d5c:	08010f7b 	.word	0x08010f7b
 8010d60:	080117e1 	.word	0x080117e1
 8010d64:	08011237 	.word	0x08011237
 8010d68:	080117e1 	.word	0x080117e1
 8010d6c:	08010edd 	.word	0x08010edd
 8010d70:	080117e1 	.word	0x080117e1
 8010d74:	080112f9 	.word	0x080112f9
 8010d78:	080117e1 	.word	0x080117e1
 8010d7c:	0801130b 	.word	0x0801130b
 8010d80:	080117e1 	.word	0x080117e1
 8010d84:	0801131d 	.word	0x0801131d
 8010d88:	080117e1 	.word	0x080117e1
 8010d8c:	0801132f 	.word	0x0801132f
 8010d90:	080117e1 	.word	0x080117e1
 8010d94:	08011363 	.word	0x08011363
 8010d98:	080117e1 	.word	0x080117e1
 8010d9c:	0801137f 	.word	0x0801137f
 8010da0:	080117e1 	.word	0x080117e1
 8010da4:	08011395 	.word	0x08011395
 8010da8:	080117e1 	.word	0x080117e1
 8010dac:	080113b1 	.word	0x080113b1
 8010db0:	080117e1 	.word	0x080117e1
 8010db4:	080113cb 	.word	0x080113cb
 8010db8:	080117e1 	.word	0x080117e1
 8010dbc:	0801146b 	.word	0x0801146b
 8010dc0:	080117e1 	.word	0x080117e1
 8010dc4:	08011657 	.word	0x08011657
 8010dc8:	080117e1 	.word	0x080117e1
 8010dcc:	08011673 	.word	0x08011673
 8010dd0:	080117e1 	.word	0x080117e1
 8010dd4:	08011691 	.word	0x08011691
 8010dd8:	080117e1 	.word	0x080117e1
 8010ddc:	080116b9 	.word	0x080116b9
 8010de0:	080117e1 	.word	0x080117e1
 8010de4:	080116cd 	.word	0x080116cd
 8010de8:	080117e1 	.word	0x080117e1
 8010dec:	080116e1 	.word	0x080116e1
 8010df0:	080117e1 	.word	0x080117e1
 8010df4:	0801170f 	.word	0x0801170f
 8010df8:	080117e1 	.word	0x080117e1
 8010dfc:	08011737 	.word	0x08011737
 8010e00:	080117e1 	.word	0x080117e1
 8010e04:	08011721 	.word	0x08011721
 8010e08:	080117e1 	.word	0x080117e1
 8010e0c:	0801174d 	.word	0x0801174d
 8010e10:	080117e1 	.word	0x080117e1
 8010e14:	0801175f 	.word	0x0801175f
 8010e18:	080117e1 	.word	0x080117e1
 8010e1c:	08011785 	.word	0x08011785
 8010e20:	080117e1 	.word	0x080117e1
 8010e24:	08011797 	.word	0x08011797
        case HCI_INIT_SEND_RESET:
            hci_state_reset();
 8010e28:	f003 f886 	bl	8013f38 <hci_state_reset>

#if !defined(HAVE_PLATFORM_IPHONE_OS) && !defined (HAVE_HOST_CONTROLLER_API)
            // prepare reset if command complete not received in 100ms
            btstack_run_loop_set_timer(&hci_stack->timeout, HCI_RESET_RESEND_TIMEOUT_MS);
 8010e2c:	4b7d      	ldr	r3, [pc, #500]	; (8011024 <hci_initializing_run+0x324>)
 8010e2e:	681b      	ldr	r3, [r3, #0]
 8010e30:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8010e34:	21c8      	movs	r1, #200	; 0xc8
 8010e36:	4618      	mov	r0, r3
 8010e38:	f7fd ff0c 	bl	800ec54 <btstack_run_loop_set_timer>
            btstack_run_loop_set_timer_handler(&hci_stack->timeout, hci_initialization_timeout_handler);
 8010e3c:	4b79      	ldr	r3, [pc, #484]	; (8011024 <hci_initializing_run+0x324>)
 8010e3e:	681b      	ldr	r3, [r3, #0]
 8010e40:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8010e44:	4978      	ldr	r1, [pc, #480]	; (8011028 <hci_initializing_run+0x328>)
 8010e46:	4618      	mov	r0, r3
 8010e48:	f7fd fea0 	bl	800eb8c <btstack_run_loop_set_timer_handler>
            btstack_run_loop_add_timer(&hci_stack->timeout);
 8010e4c:	4b75      	ldr	r3, [pc, #468]	; (8011024 <hci_initializing_run+0x324>)
 8010e4e:	681b      	ldr	r3, [r3, #0]
 8010e50:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8010e54:	4618      	mov	r0, r3
 8010e56:	f7fd ff29 	bl	800ecac <btstack_run_loop_add_timer>
#endif
            // send command
            hci_stack->substate = HCI_INIT_W4_SEND_RESET;
 8010e5a:	4b72      	ldr	r3, [pc, #456]	; (8011024 <hci_initializing_run+0x324>)
 8010e5c:	681b      	ldr	r3, [r3, #0]
 8010e5e:	2201      	movs	r2, #1
 8010e60:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_reset);
 8010e64:	4871      	ldr	r0, [pc, #452]	; (801102c <hci_initializing_run+0x32c>)
 8010e66:	f005 f8bb 	bl	8015fe0 <hci_send_cmd>
            break;
 8010e6a:	f000 bcbc 	b.w	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_SEND_READ_LOCAL_VERSION_INFORMATION:
            hci_send_cmd(&hci_read_local_version_information);
 8010e6e:	4870      	ldr	r0, [pc, #448]	; (8011030 <hci_initializing_run+0x330>)
 8010e70:	f005 f8b6 	bl	8015fe0 <hci_send_cmd>
            hci_stack->substate = HCI_INIT_W4_SEND_READ_LOCAL_VERSION_INFORMATION;
 8010e74:	4b6b      	ldr	r3, [pc, #428]	; (8011024 <hci_initializing_run+0x324>)
 8010e76:	681b      	ldr	r3, [r3, #0]
 8010e78:	2203      	movs	r2, #3
 8010e7a:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            break;
 8010e7e:	f000 bcb2 	b.w	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_SEND_READ_LOCAL_NAME:
            hci_send_cmd(&hci_read_local_name);
 8010e82:	486c      	ldr	r0, [pc, #432]	; (8011034 <hci_initializing_run+0x334>)
 8010e84:	f005 f8ac 	bl	8015fe0 <hci_send_cmd>
            hci_stack->substate = HCI_INIT_W4_SEND_READ_LOCAL_NAME;
 8010e88:	4b66      	ldr	r3, [pc, #408]	; (8011024 <hci_initializing_run+0x324>)
 8010e8a:	681b      	ldr	r3, [r3, #0]
 8010e8c:	2205      	movs	r2, #5
 8010e8e:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            break;
 8010e92:	f000 bca8 	b.w	80117e6 <hci_initializing_run+0xae6>

#if !defined(HAVE_PLATFORM_IPHONE_OS) && !defined (HAVE_HOST_CONTROLLER_API)
        case HCI_INIT_SEND_RESET_CSR_WARM_BOOT:
            hci_state_reset();
 8010e96:	f003 f84f 	bl	8013f38 <hci_state_reset>
            // prepare reset if command complete not received in 100ms
            btstack_run_loop_set_timer(&hci_stack->timeout, HCI_RESET_RESEND_TIMEOUT_MS);
 8010e9a:	4b62      	ldr	r3, [pc, #392]	; (8011024 <hci_initializing_run+0x324>)
 8010e9c:	681b      	ldr	r3, [r3, #0]
 8010e9e:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8010ea2:	21c8      	movs	r1, #200	; 0xc8
 8010ea4:	4618      	mov	r0, r3
 8010ea6:	f7fd fed5 	bl	800ec54 <btstack_run_loop_set_timer>
            btstack_run_loop_set_timer_handler(&hci_stack->timeout, hci_initialization_timeout_handler);
 8010eaa:	4b5e      	ldr	r3, [pc, #376]	; (8011024 <hci_initializing_run+0x324>)
 8010eac:	681b      	ldr	r3, [r3, #0]
 8010eae:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8010eb2:	495d      	ldr	r1, [pc, #372]	; (8011028 <hci_initializing_run+0x328>)
 8010eb4:	4618      	mov	r0, r3
 8010eb6:	f7fd fe69 	bl	800eb8c <btstack_run_loop_set_timer_handler>
            btstack_run_loop_add_timer(&hci_stack->timeout);
 8010eba:	4b5a      	ldr	r3, [pc, #360]	; (8011024 <hci_initializing_run+0x324>)
 8010ebc:	681b      	ldr	r3, [r3, #0]
 8010ebe:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8010ec2:	4618      	mov	r0, r3
 8010ec4:	f7fd fef2 	bl	800ecac <btstack_run_loop_add_timer>
            // send command
            hci_stack->substate = HCI_INIT_W4_CUSTOM_INIT_CSR_WARM_BOOT;
 8010ec8:	4b56      	ldr	r3, [pc, #344]	; (8011024 <hci_initializing_run+0x324>)
 8010eca:	681b      	ldr	r3, [r3, #0]
 8010ecc:	220b      	movs	r2, #11
 8010ece:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_reset);
 8010ed2:	4856      	ldr	r0, [pc, #344]	; (801102c <hci_initializing_run+0x32c>)
 8010ed4:	f005 f884 	bl	8015fe0 <hci_send_cmd>
            break;
 8010ed8:	f000 bc85 	b.w	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_SEND_RESET_ST_WARM_BOOT:
            hci_state_reset();
 8010edc:	f003 f82c 	bl	8013f38 <hci_state_reset>
            hci_stack->substate = HCI_INIT_W4_SEND_RESET_ST_WARM_BOOT;
 8010ee0:	4b50      	ldr	r3, [pc, #320]	; (8011024 <hci_initializing_run+0x324>)
 8010ee2:	681b      	ldr	r3, [r3, #0]
 8010ee4:	2215      	movs	r2, #21
 8010ee6:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_reset);
 8010eea:	4850      	ldr	r0, [pc, #320]	; (801102c <hci_initializing_run+0x32c>)
 8010eec:	f005 f878 	bl	8015fe0 <hci_send_cmd>
            break;
 8010ef0:	f000 bc79 	b.w	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_SEND_BAUD_CHANGE: {
            uint32_t baud_rate = hci_transport_uart_get_main_baud_rate();
 8010ef4:	f7ff fe0e 	bl	8010b14 <hci_transport_uart_get_main_baud_rate>
 8010ef8:	60b8      	str	r0, [r7, #8]
            hci_stack->chipset->set_baudrate_command(baud_rate, hci_stack->hci_packet_buffer);
 8010efa:	4b4a      	ldr	r3, [pc, #296]	; (8011024 <hci_initializing_run+0x324>)
 8010efc:	681b      	ldr	r3, [r3, #0]
 8010efe:	689b      	ldr	r3, [r3, #8]
 8010f00:	68db      	ldr	r3, [r3, #12]
 8010f02:	4a48      	ldr	r2, [pc, #288]	; (8011024 <hci_initializing_run+0x324>)
 8010f04:	6812      	ldr	r2, [r2, #0]
 8010f06:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8010f08:	4611      	mov	r1, r2
 8010f0a:	68b8      	ldr	r0, [r7, #8]
 8010f0c:	4798      	blx	r3
            hci_stack->last_cmd_opcode = little_endian_read_16(hci_stack->hci_packet_buffer, 0);
 8010f0e:	4b45      	ldr	r3, [pc, #276]	; (8011024 <hci_initializing_run+0x324>)
 8010f10:	681b      	ldr	r3, [r3, #0]
 8010f12:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8010f14:	4b43      	ldr	r3, [pc, #268]	; (8011024 <hci_initializing_run+0x324>)
 8010f16:	681c      	ldr	r4, [r3, #0]
 8010f18:	2100      	movs	r1, #0
 8010f1a:	4610      	mov	r0, r2
 8010f1c:	f7fd ff63 	bl	800ede6 <little_endian_read_16>
 8010f20:	4603      	mov	r3, r0
 8010f22:	f8a4 372a 	strh.w	r3, [r4, #1834]	; 0x72a
            hci_stack->substate = HCI_INIT_W4_SEND_BAUD_CHANGE;
 8010f26:	4b3f      	ldr	r3, [pc, #252]	; (8011024 <hci_initializing_run+0x324>)
 8010f28:	681b      	ldr	r3, [r3, #0]
 8010f2a:	2207      	movs	r2, #7
 8010f2c:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd_packet(hci_stack->hci_packet_buffer, 3u + hci_stack->hci_packet_buffer[2u]);
 8010f30:	4b3c      	ldr	r3, [pc, #240]	; (8011024 <hci_initializing_run+0x324>)
 8010f32:	681b      	ldr	r3, [r3, #0]
 8010f34:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8010f36:	4b3b      	ldr	r3, [pc, #236]	; (8011024 <hci_initializing_run+0x324>)
 8010f38:	681b      	ldr	r3, [r3, #0]
 8010f3a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8010f3c:	3302      	adds	r3, #2
 8010f3e:	781b      	ldrb	r3, [r3, #0]
 8010f40:	3303      	adds	r3, #3
 8010f42:	4619      	mov	r1, r3
 8010f44:	4610      	mov	r0, r2
 8010f46:	f004 fe2f 	bl	8015ba8 <hci_send_cmd_packet>
            // STLC25000D: baudrate change happens within 0.5 s after command was send,
            // use timer to update baud rate after 100 ms (knowing exactly, when command was sent is non-trivial)
            if (hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_ST_MICROELECTRONICS){
 8010f4a:	4b36      	ldr	r3, [pc, #216]	; (8011024 <hci_initializing_run+0x324>)
 8010f4c:	681b      	ldr	r3, [r3, #0]
 8010f4e:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 8010f52:	2b30      	cmp	r3, #48	; 0x30
 8010f54:	f040 8446 	bne.w	80117e4 <hci_initializing_run+0xae4>
                btstack_run_loop_set_timer(&hci_stack->timeout, HCI_RESET_RESEND_TIMEOUT_MS);
 8010f58:	4b32      	ldr	r3, [pc, #200]	; (8011024 <hci_initializing_run+0x324>)
 8010f5a:	681b      	ldr	r3, [r3, #0]
 8010f5c:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8010f60:	21c8      	movs	r1, #200	; 0xc8
 8010f62:	4618      	mov	r0, r3
 8010f64:	f7fd fe76 	bl	800ec54 <btstack_run_loop_set_timer>
                btstack_run_loop_add_timer(&hci_stack->timeout);
 8010f68:	4b2e      	ldr	r3, [pc, #184]	; (8011024 <hci_initializing_run+0x324>)
 8010f6a:	681b      	ldr	r3, [r3, #0]
 8010f6c:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8010f70:	4618      	mov	r0, r3
 8010f72:	f7fd fe9b 	bl	800ecac <btstack_run_loop_add_timer>
            }
            break;
 8010f76:	f000 bc35 	b.w	80117e4 <hci_initializing_run+0xae4>
        }
        case HCI_INIT_SEND_BAUD_CHANGE_BCM: {
            uint32_t baud_rate = hci_transport_uart_get_main_baud_rate();
 8010f7a:	f7ff fdcb 	bl	8010b14 <hci_transport_uart_get_main_baud_rate>
 8010f7e:	61f8      	str	r0, [r7, #28]
            hci_stack->chipset->set_baudrate_command(baud_rate, hci_stack->hci_packet_buffer);
 8010f80:	4b28      	ldr	r3, [pc, #160]	; (8011024 <hci_initializing_run+0x324>)
 8010f82:	681b      	ldr	r3, [r3, #0]
 8010f84:	689b      	ldr	r3, [r3, #8]
 8010f86:	68db      	ldr	r3, [r3, #12]
 8010f88:	4a26      	ldr	r2, [pc, #152]	; (8011024 <hci_initializing_run+0x324>)
 8010f8a:	6812      	ldr	r2, [r2, #0]
 8010f8c:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8010f8e:	4611      	mov	r1, r2
 8010f90:	69f8      	ldr	r0, [r7, #28]
 8010f92:	4798      	blx	r3
            hci_stack->last_cmd_opcode = little_endian_read_16(hci_stack->hci_packet_buffer, 0);
 8010f94:	4b23      	ldr	r3, [pc, #140]	; (8011024 <hci_initializing_run+0x324>)
 8010f96:	681b      	ldr	r3, [r3, #0]
 8010f98:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8010f9a:	4b22      	ldr	r3, [pc, #136]	; (8011024 <hci_initializing_run+0x324>)
 8010f9c:	681c      	ldr	r4, [r3, #0]
 8010f9e:	2100      	movs	r1, #0
 8010fa0:	4610      	mov	r0, r2
 8010fa2:	f7fd ff20 	bl	800ede6 <little_endian_read_16>
 8010fa6:	4603      	mov	r3, r0
 8010fa8:	f8a4 372a 	strh.w	r3, [r4, #1834]	; 0x72a
            hci_stack->substate = HCI_INIT_W4_SEND_BAUD_CHANGE_BCM;
 8010fac:	4b1d      	ldr	r3, [pc, #116]	; (8011024 <hci_initializing_run+0x324>)
 8010fae:	681b      	ldr	r3, [r3, #0]
 8010fb0:	2211      	movs	r2, #17
 8010fb2:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd_packet(hci_stack->hci_packet_buffer, 3u + hci_stack->hci_packet_buffer[2u]);
 8010fb6:	4b1b      	ldr	r3, [pc, #108]	; (8011024 <hci_initializing_run+0x324>)
 8010fb8:	681b      	ldr	r3, [r3, #0]
 8010fba:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8010fbc:	4b19      	ldr	r3, [pc, #100]	; (8011024 <hci_initializing_run+0x324>)
 8010fbe:	681b      	ldr	r3, [r3, #0]
 8010fc0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8010fc2:	3302      	adds	r3, #2
 8010fc4:	781b      	ldrb	r3, [r3, #0]
 8010fc6:	3303      	adds	r3, #3
 8010fc8:	4619      	mov	r1, r3
 8010fca:	4610      	mov	r0, r2
 8010fcc:	f004 fdec 	bl	8015ba8 <hci_send_cmd_packet>
            break;
 8010fd0:	f000 bc09 	b.w	80117e6 <hci_initializing_run+0xae6>
        }
        case HCI_INIT_CUSTOM_INIT:
            // Custom initialization
            if (hci_stack->chipset && hci_stack->chipset->next_command){
 8010fd4:	4b13      	ldr	r3, [pc, #76]	; (8011024 <hci_initializing_run+0x324>)
 8010fd6:	681b      	ldr	r3, [r3, #0]
 8010fd8:	689b      	ldr	r3, [r3, #8]
 8010fda:	2b00      	cmp	r3, #0
 8010fdc:	f000 8122 	beq.w	8011224 <hci_initializing_run+0x524>
 8010fe0:	4b10      	ldr	r3, [pc, #64]	; (8011024 <hci_initializing_run+0x324>)
 8010fe2:	681b      	ldr	r3, [r3, #0]
 8010fe4:	689b      	ldr	r3, [r3, #8]
 8010fe6:	689b      	ldr	r3, [r3, #8]
 8010fe8:	2b00      	cmp	r3, #0
 8010fea:	f000 811b 	beq.w	8011224 <hci_initializing_run+0x524>
                hci_stack->chipset_result = (*hci_stack->chipset->next_command)(hci_stack->hci_packet_buffer);
 8010fee:	4b0d      	ldr	r3, [pc, #52]	; (8011024 <hci_initializing_run+0x324>)
 8010ff0:	681b      	ldr	r3, [r3, #0]
 8010ff2:	689b      	ldr	r3, [r3, #8]
 8010ff4:	689b      	ldr	r3, [r3, #8]
 8010ff6:	4a0b      	ldr	r2, [pc, #44]	; (8011024 <hci_initializing_run+0x324>)
 8010ff8:	6812      	ldr	r2, [r2, #0]
 8010ffa:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 8010ffc:	4a09      	ldr	r2, [pc, #36]	; (8011024 <hci_initializing_run+0x324>)
 8010ffe:	6814      	ldr	r4, [r2, #0]
 8011000:	4608      	mov	r0, r1
 8011002:	4798      	blx	r3
 8011004:	4603      	mov	r3, r0
 8011006:	f884 3728 	strb.w	r3, [r4, #1832]	; 0x728
                bool send_cmd = false;
 801100a:	2300      	movs	r3, #0
 801100c:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
                switch (hci_stack->chipset_result){
 8011010:	4b04      	ldr	r3, [pc, #16]	; (8011024 <hci_initializing_run+0x324>)
 8011012:	681b      	ldr	r3, [r3, #0]
 8011014:	f893 3728 	ldrb.w	r3, [r3, #1832]	; 0x728
 8011018:	2b01      	cmp	r3, #1
 801101a:	d00d      	beq.n	8011038 <hci_initializing_run+0x338>
 801101c:	2b02      	cmp	r3, #2
 801101e:	d014      	beq.n	801104a <hci_initializing_run+0x34a>
                        } else {
                           hci_stack->substate = HCI_INIT_W4_CUSTOM_INIT_CSR_WARM_BOOT_LINK_RESET;
                        }
                        break;
                    default:
                        break;
 8011020:	e05b      	b.n	80110da <hci_initializing_run+0x3da>
 8011022:	bf00      	nop
 8011024:	20009780 	.word	0x20009780
 8011028:	08010b61 	.word	0x08010b61
 801102c:	08030ad0 	.word	0x08030ad0
 8011030:	08030b40 	.word	0x08030b40
 8011034:	08030ae0 	.word	0x08030ae0
                        send_cmd = true;
 8011038:	2301      	movs	r3, #1
 801103a:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
                        hci_stack->substate = HCI_INIT_W4_CUSTOM_INIT;
 801103e:	4ba4      	ldr	r3, [pc, #656]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011040:	681b      	ldr	r3, [r3, #0]
 8011042:	2209      	movs	r2, #9
 8011044:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                        break;
 8011048:	e047      	b.n	80110da <hci_initializing_run+0x3da>
                        send_cmd = true;
 801104a:	2301      	movs	r3, #1
 801104c:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
                        log_info("CSR Warm Boot");
 8011050:	f240 530b 	movw	r3, #1291	; 0x50b
 8011054:	4a9f      	ldr	r2, [pc, #636]	; (80112d4 <hci_initializing_run+0x5d4>)
 8011056:	49a0      	ldr	r1, [pc, #640]	; (80112d8 <hci_initializing_run+0x5d8>)
 8011058:	2001      	movs	r0, #1
 801105a:	f006 f9f1 	bl	8017440 <hci_dump_log>
                        btstack_run_loop_set_timer(&hci_stack->timeout, HCI_RESET_RESEND_TIMEOUT_MS);
 801105e:	4b9c      	ldr	r3, [pc, #624]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011060:	681b      	ldr	r3, [r3, #0]
 8011062:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8011066:	21c8      	movs	r1, #200	; 0xc8
 8011068:	4618      	mov	r0, r3
 801106a:	f7fd fdf3 	bl	800ec54 <btstack_run_loop_set_timer>
                        btstack_run_loop_set_timer_handler(&hci_stack->timeout, hci_initialization_timeout_handler);
 801106e:	4b98      	ldr	r3, [pc, #608]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011070:	681b      	ldr	r3, [r3, #0]
 8011072:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8011076:	4999      	ldr	r1, [pc, #612]	; (80112dc <hci_initializing_run+0x5dc>)
 8011078:	4618      	mov	r0, r3
 801107a:	f7fd fd87 	bl	800eb8c <btstack_run_loop_set_timer_handler>
                        btstack_run_loop_add_timer(&hci_stack->timeout);
 801107e:	4b94      	ldr	r3, [pc, #592]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011080:	681b      	ldr	r3, [r3, #0]
 8011082:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8011086:	4618      	mov	r0, r3
 8011088:	f7fd fe10 	bl	800ecac <btstack_run_loop_add_timer>
                        if ((hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_CAMBRIDGE_SILICON_RADIO)
 801108c:	4b90      	ldr	r3, [pc, #576]	; (80112d0 <hci_initializing_run+0x5d0>)
 801108e:	681b      	ldr	r3, [r3, #0]
 8011090:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 8011094:	2b0a      	cmp	r3, #10
 8011096:	d11a      	bne.n	80110ce <hci_initializing_run+0x3ce>
                            && hci_stack->config
 8011098:	4b8d      	ldr	r3, [pc, #564]	; (80112d0 <hci_initializing_run+0x5d0>)
 801109a:	681b      	ldr	r3, [r3, #0]
 801109c:	685b      	ldr	r3, [r3, #4]
 801109e:	2b00      	cmp	r3, #0
 80110a0:	d015      	beq.n	80110ce <hci_initializing_run+0x3ce>
                            && hci_stack->chipset
 80110a2:	4b8b      	ldr	r3, [pc, #556]	; (80112d0 <hci_initializing_run+0x5d0>)
 80110a4:	681b      	ldr	r3, [r3, #0]
 80110a6:	689b      	ldr	r3, [r3, #8]
 80110a8:	2b00      	cmp	r3, #0
 80110aa:	d010      	beq.n	80110ce <hci_initializing_run+0x3ce>
                            && hci_stack->hci_transport->set_baudrate
 80110ac:	4b88      	ldr	r3, [pc, #544]	; (80112d0 <hci_initializing_run+0x5d0>)
 80110ae:	681b      	ldr	r3, [r3, #0]
 80110b0:	681b      	ldr	r3, [r3, #0]
 80110b2:	69db      	ldr	r3, [r3, #28]
 80110b4:	2b00      	cmp	r3, #0
 80110b6:	d00a      	beq.n	80110ce <hci_initializing_run+0x3ce>
                            && hci_transport_uart_get_main_baud_rate()){
 80110b8:	f7ff fd2c 	bl	8010b14 <hci_transport_uart_get_main_baud_rate>
 80110bc:	4603      	mov	r3, r0
 80110be:	2b00      	cmp	r3, #0
 80110c0:	d005      	beq.n	80110ce <hci_initializing_run+0x3ce>
                            hci_stack->substate = HCI_INIT_W4_SEND_BAUD_CHANGE;
 80110c2:	4b83      	ldr	r3, [pc, #524]	; (80112d0 <hci_initializing_run+0x5d0>)
 80110c4:	681b      	ldr	r3, [r3, #0]
 80110c6:	2207      	movs	r2, #7
 80110c8:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                        break;
 80110cc:	e004      	b.n	80110d8 <hci_initializing_run+0x3d8>
                           hci_stack->substate = HCI_INIT_W4_CUSTOM_INIT_CSR_WARM_BOOT_LINK_RESET;
 80110ce:	4b80      	ldr	r3, [pc, #512]	; (80112d0 <hci_initializing_run+0x5d0>)
 80110d0:	681b      	ldr	r3, [r3, #0]
 80110d2:	220c      	movs	r2, #12
 80110d4:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                        break;
 80110d8:	bf00      	nop
                }

                if (send_cmd){
 80110da:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80110de:	2b00      	cmp	r3, #0
 80110e0:	d026      	beq.n	8011130 <hci_initializing_run+0x430>
                    int size = 3u + hci_stack->hci_packet_buffer[2u];
 80110e2:	4b7b      	ldr	r3, [pc, #492]	; (80112d0 <hci_initializing_run+0x5d0>)
 80110e4:	681b      	ldr	r3, [r3, #0]
 80110e6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80110e8:	3302      	adds	r3, #2
 80110ea:	781b      	ldrb	r3, [r3, #0]
 80110ec:	3303      	adds	r3, #3
 80110ee:	60fb      	str	r3, [r7, #12]
                    hci_stack->last_cmd_opcode = little_endian_read_16(hci_stack->hci_packet_buffer, 0);
 80110f0:	4b77      	ldr	r3, [pc, #476]	; (80112d0 <hci_initializing_run+0x5d0>)
 80110f2:	681b      	ldr	r3, [r3, #0]
 80110f4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80110f6:	4b76      	ldr	r3, [pc, #472]	; (80112d0 <hci_initializing_run+0x5d0>)
 80110f8:	681c      	ldr	r4, [r3, #0]
 80110fa:	2100      	movs	r1, #0
 80110fc:	4610      	mov	r0, r2
 80110fe:	f7fd fe72 	bl	800ede6 <little_endian_read_16>
 8011102:	4603      	mov	r3, r0
 8011104:	f8a4 372a 	strh.w	r3, [r4, #1834]	; 0x72a
                    hci_dump_packet(HCI_COMMAND_DATA_PACKET, 0, hci_stack->hci_packet_buffer, size);
 8011108:	4b71      	ldr	r3, [pc, #452]	; (80112d0 <hci_initializing_run+0x5d0>)
 801110a:	681b      	ldr	r3, [r3, #0]
 801110c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801110e:	68fb      	ldr	r3, [r7, #12]
 8011110:	b29b      	uxth	r3, r3
 8011112:	2100      	movs	r1, #0
 8011114:	2001      	movs	r0, #1
 8011116:	f006 f8ed 	bl	80172f4 <hci_dump_packet>
                    hci_stack->hci_transport->send_packet(HCI_COMMAND_DATA_PACKET, hci_stack->hci_packet_buffer, size);
 801111a:	4b6d      	ldr	r3, [pc, #436]	; (80112d0 <hci_initializing_run+0x5d0>)
 801111c:	681b      	ldr	r3, [r3, #0]
 801111e:	681b      	ldr	r3, [r3, #0]
 8011120:	699b      	ldr	r3, [r3, #24]
 8011122:	4a6b      	ldr	r2, [pc, #428]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011124:	6812      	ldr	r2, [r2, #0]
 8011126:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 8011128:	68fa      	ldr	r2, [r7, #12]
 801112a:	2001      	movs	r0, #1
 801112c:	4798      	blx	r3
                    break;
 801112e:	e35a      	b.n	80117e6 <hci_initializing_run+0xae6>
                }
                log_info("Init script done");
 8011130:	f240 5325 	movw	r3, #1317	; 0x525
 8011134:	4a67      	ldr	r2, [pc, #412]	; (80112d4 <hci_initializing_run+0x5d4>)
 8011136:	496a      	ldr	r1, [pc, #424]	; (80112e0 <hci_initializing_run+0x5e0>)
 8011138:	2001      	movs	r0, #1
 801113a:	f006 f981 	bl	8017440 <hci_dump_log>

                // Init script download on Broadcom chipsets causes:
                if ( (hci_stack->chipset_result != BTSTACK_CHIPSET_NO_INIT_SCRIPT) &&
 801113e:	4b64      	ldr	r3, [pc, #400]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011140:	681b      	ldr	r3, [r3, #0]
 8011142:	f893 3728 	ldrb.w	r3, [r3, #1832]	; 0x728
 8011146:	2b03      	cmp	r3, #3
 8011148:	d06c      	beq.n	8011224 <hci_initializing_run+0x524>
                   (  (hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_BROADCOM_CORPORATION) 
 801114a:	4b61      	ldr	r3, [pc, #388]	; (80112d0 <hci_initializing_run+0x5d0>)
 801114c:	681b      	ldr	r3, [r3, #0]
 801114e:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
                if ( (hci_stack->chipset_result != BTSTACK_CHIPSET_NO_INIT_SCRIPT) &&
 8011152:	2b0f      	cmp	r3, #15
 8011154:	d005      	beq.n	8011162 <hci_initializing_run+0x462>
                ||    (hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_EM_MICROELECTRONIC_MARIN_SA)) ){
 8011156:	4b5e      	ldr	r3, [pc, #376]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011158:	681b      	ldr	r3, [r3, #0]
 801115a:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 801115e:	2b5a      	cmp	r3, #90	; 0x5a
 8011160:	d160      	bne.n	8011224 <hci_initializing_run+0x524>

                    // - baud rate to reset, restore UART baud rate if needed
                    int need_baud_change = hci_stack->config
 8011162:	4b5b      	ldr	r3, [pc, #364]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011164:	681b      	ldr	r3, [r3, #0]
 8011166:	685b      	ldr	r3, [r3, #4]
                        && hci_stack->chipset
                        && hci_stack->chipset->set_baudrate_command
                        && hci_stack->hci_transport->set_baudrate
                        && ((hci_transport_config_uart_t *)hci_stack->config)->baudrate_main;
 8011168:	2b00      	cmp	r3, #0
 801116a:	d018      	beq.n	801119e <hci_initializing_run+0x49e>
                        && hci_stack->chipset
 801116c:	4b58      	ldr	r3, [pc, #352]	; (80112d0 <hci_initializing_run+0x5d0>)
 801116e:	681b      	ldr	r3, [r3, #0]
 8011170:	689b      	ldr	r3, [r3, #8]
 8011172:	2b00      	cmp	r3, #0
 8011174:	d013      	beq.n	801119e <hci_initializing_run+0x49e>
                        && hci_stack->chipset->set_baudrate_command
 8011176:	4b56      	ldr	r3, [pc, #344]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011178:	681b      	ldr	r3, [r3, #0]
 801117a:	689b      	ldr	r3, [r3, #8]
 801117c:	68db      	ldr	r3, [r3, #12]
 801117e:	2b00      	cmp	r3, #0
 8011180:	d00d      	beq.n	801119e <hci_initializing_run+0x49e>
                        && hci_stack->hci_transport->set_baudrate
 8011182:	4b53      	ldr	r3, [pc, #332]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011184:	681b      	ldr	r3, [r3, #0]
 8011186:	681b      	ldr	r3, [r3, #0]
 8011188:	69db      	ldr	r3, [r3, #28]
 801118a:	2b00      	cmp	r3, #0
 801118c:	d007      	beq.n	801119e <hci_initializing_run+0x49e>
                        && ((hci_transport_config_uart_t *)hci_stack->config)->baudrate_main;
 801118e:	4b50      	ldr	r3, [pc, #320]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011190:	681b      	ldr	r3, [r3, #0]
 8011192:	685b      	ldr	r3, [r3, #4]
 8011194:	689b      	ldr	r3, [r3, #8]
 8011196:	2b00      	cmp	r3, #0
 8011198:	d001      	beq.n	801119e <hci_initializing_run+0x49e>
 801119a:	2301      	movs	r3, #1
 801119c:	e000      	b.n	80111a0 <hci_initializing_run+0x4a0>
 801119e:	2300      	movs	r3, #0
                    int need_baud_change = hci_stack->config
 80111a0:	61bb      	str	r3, [r7, #24]
                    if (need_baud_change) {
 80111a2:	69bb      	ldr	r3, [r7, #24]
 80111a4:	2b00      	cmp	r3, #0
 80111a6:	d013      	beq.n	80111d0 <hci_initializing_run+0x4d0>
                        uint32_t baud_rate = ((hci_transport_config_uart_t *)hci_stack->config)->baudrate_init;
 80111a8:	4b49      	ldr	r3, [pc, #292]	; (80112d0 <hci_initializing_run+0x5d0>)
 80111aa:	681b      	ldr	r3, [r3, #0]
 80111ac:	685b      	ldr	r3, [r3, #4]
 80111ae:	685b      	ldr	r3, [r3, #4]
 80111b0:	617b      	str	r3, [r7, #20]
                        log_info("Local baud rate change to %" PRIu32 " after init script (bcm)", baud_rate);
 80111b2:	697b      	ldr	r3, [r7, #20]
 80111b4:	9300      	str	r3, [sp, #0]
 80111b6:	f240 5334 	movw	r3, #1332	; 0x534
 80111ba:	4a46      	ldr	r2, [pc, #280]	; (80112d4 <hci_initializing_run+0x5d4>)
 80111bc:	4949      	ldr	r1, [pc, #292]	; (80112e4 <hci_initializing_run+0x5e4>)
 80111be:	2001      	movs	r0, #1
 80111c0:	f006 f93e 	bl	8017440 <hci_dump_log>
                        hci_stack->hci_transport->set_baudrate(baud_rate);
 80111c4:	4b42      	ldr	r3, [pc, #264]	; (80112d0 <hci_initializing_run+0x5d0>)
 80111c6:	681b      	ldr	r3, [r3, #0]
 80111c8:	681b      	ldr	r3, [r3, #0]
 80111ca:	69db      	ldr	r3, [r3, #28]
 80111cc:	6978      	ldr	r0, [r7, #20]
 80111ce:	4798      	blx	r3
                    }

                    uint16_t bcm_delay_ms = 300;
 80111d0:	f44f 7396 	mov.w	r3, #300	; 0x12c
 80111d4:	827b      	strh	r3, [r7, #18]
                    // - UART may or may not be disabled during update and Controller RTS may or may not be high during this time
                    //   -> Work around: wait here.
                    log_info("BCM delay (%u ms) after init script", bcm_delay_ms);
 80111d6:	8a7b      	ldrh	r3, [r7, #18]
 80111d8:	9300      	str	r3, [sp, #0]
 80111da:	f240 533b 	movw	r3, #1339	; 0x53b
 80111de:	4a3d      	ldr	r2, [pc, #244]	; (80112d4 <hci_initializing_run+0x5d4>)
 80111e0:	4941      	ldr	r1, [pc, #260]	; (80112e8 <hci_initializing_run+0x5e8>)
 80111e2:	2001      	movs	r0, #1
 80111e4:	f006 f92c 	bl	8017440 <hci_dump_log>
                    hci_stack->substate = HCI_INIT_W4_CUSTOM_INIT_BCM_DELAY;
 80111e8:	4b39      	ldr	r3, [pc, #228]	; (80112d0 <hci_initializing_run+0x5d0>)
 80111ea:	681b      	ldr	r3, [r3, #0]
 80111ec:	220d      	movs	r2, #13
 80111ee:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                    btstack_run_loop_set_timer(&hci_stack->timeout, bcm_delay_ms);
 80111f2:	4b37      	ldr	r3, [pc, #220]	; (80112d0 <hci_initializing_run+0x5d0>)
 80111f4:	681b      	ldr	r3, [r3, #0]
 80111f6:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 80111fa:	8a7a      	ldrh	r2, [r7, #18]
 80111fc:	4611      	mov	r1, r2
 80111fe:	4618      	mov	r0, r3
 8011200:	f7fd fd28 	bl	800ec54 <btstack_run_loop_set_timer>
                    btstack_run_loop_set_timer_handler(&hci_stack->timeout, hci_initialization_timeout_handler);
 8011204:	4b32      	ldr	r3, [pc, #200]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011206:	681b      	ldr	r3, [r3, #0]
 8011208:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 801120c:	4933      	ldr	r1, [pc, #204]	; (80112dc <hci_initializing_run+0x5dc>)
 801120e:	4618      	mov	r0, r3
 8011210:	f7fd fcbc 	bl	800eb8c <btstack_run_loop_set_timer_handler>
                    btstack_run_loop_add_timer(&hci_stack->timeout);
 8011214:	4b2e      	ldr	r3, [pc, #184]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011216:	681b      	ldr	r3, [r3, #0]
 8011218:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 801121c:	4618      	mov	r0, r3
 801121e:	f7fd fd45 	bl	800ecac <btstack_run_loop_add_timer>
                    break;
 8011222:	e2e0      	b.n	80117e6 <hci_initializing_run+0xae6>
                }
            }
            // otherwise continue
            hci_stack->substate = HCI_INIT_W4_READ_LOCAL_SUPPORTED_COMMANDS;
 8011224:	4b2a      	ldr	r3, [pc, #168]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011226:	681b      	ldr	r3, [r3, #0]
 8011228:	220f      	movs	r2, #15
 801122a:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_read_local_supported_commands);
 801122e:	482f      	ldr	r0, [pc, #188]	; (80112ec <hci_initializing_run+0x5ec>)
 8011230:	f004 fed6 	bl	8015fe0 <hci_send_cmd>
            break;            
 8011234:	e2d7      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_SET_BD_ADDR:
            log_info("Set Public BD ADDR to %s", bd_addr_to_str(hci_stack->custom_bd_addr));
 8011236:	4b26      	ldr	r3, [pc, #152]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011238:	681b      	ldr	r3, [r3, #0]
 801123a:	f203 73b2 	addw	r3, r3, #1970	; 0x7b2
 801123e:	4618      	mov	r0, r3
 8011240:	f7fe f8e6 	bl	800f410 <bd_addr_to_str>
 8011244:	4603      	mov	r3, r0
 8011246:	9300      	str	r3, [sp, #0]
 8011248:	f44f 63a9 	mov.w	r3, #1352	; 0x548
 801124c:	4a21      	ldr	r2, [pc, #132]	; (80112d4 <hci_initializing_run+0x5d4>)
 801124e:	4928      	ldr	r1, [pc, #160]	; (80112f0 <hci_initializing_run+0x5f0>)
 8011250:	2001      	movs	r0, #1
 8011252:	f006 f8f5 	bl	8017440 <hci_dump_log>
            hci_stack->chipset->set_bd_addr_command(hci_stack->custom_bd_addr, hci_stack->hci_packet_buffer);
 8011256:	4b1e      	ldr	r3, [pc, #120]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011258:	681b      	ldr	r3, [r3, #0]
 801125a:	689b      	ldr	r3, [r3, #8]
 801125c:	691b      	ldr	r3, [r3, #16]
 801125e:	4a1c      	ldr	r2, [pc, #112]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011260:	6812      	ldr	r2, [r2, #0]
 8011262:	f202 70b2 	addw	r0, r2, #1970	; 0x7b2
 8011266:	4a1a      	ldr	r2, [pc, #104]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011268:	6812      	ldr	r2, [r2, #0]
 801126a:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 801126c:	4611      	mov	r1, r2
 801126e:	4798      	blx	r3
            hci_stack->last_cmd_opcode = little_endian_read_16(hci_stack->hci_packet_buffer, 0);
 8011270:	4b17      	ldr	r3, [pc, #92]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011272:	681b      	ldr	r3, [r3, #0]
 8011274:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011276:	4b16      	ldr	r3, [pc, #88]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011278:	681c      	ldr	r4, [r3, #0]
 801127a:	2100      	movs	r1, #0
 801127c:	4610      	mov	r0, r2
 801127e:	f7fd fdb2 	bl	800ede6 <little_endian_read_16>
 8011282:	4603      	mov	r3, r0
 8011284:	f8a4 372a 	strh.w	r3, [r4, #1834]	; 0x72a
            hci_stack->substate = HCI_INIT_W4_SET_BD_ADDR;
 8011288:	4b11      	ldr	r3, [pc, #68]	; (80112d0 <hci_initializing_run+0x5d0>)
 801128a:	681b      	ldr	r3, [r3, #0]
 801128c:	2213      	movs	r2, #19
 801128e:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd_packet(hci_stack->hci_packet_buffer, 3u + hci_stack->hci_packet_buffer[2u]);
 8011292:	4b0f      	ldr	r3, [pc, #60]	; (80112d0 <hci_initializing_run+0x5d0>)
 8011294:	681b      	ldr	r3, [r3, #0]
 8011296:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8011298:	4b0d      	ldr	r3, [pc, #52]	; (80112d0 <hci_initializing_run+0x5d0>)
 801129a:	681b      	ldr	r3, [r3, #0]
 801129c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801129e:	3302      	adds	r3, #2
 80112a0:	781b      	ldrb	r3, [r3, #0]
 80112a2:	3303      	adds	r3, #3
 80112a4:	4619      	mov	r1, r3
 80112a6:	4610      	mov	r0, r2
 80112a8:	f004 fc7e 	bl	8015ba8 <hci_send_cmd_packet>
            break;
 80112ac:	e29b      	b.n	80117e6 <hci_initializing_run+0xae6>
#endif

        case HCI_INIT_READ_LOCAL_SUPPORTED_COMMANDS:
            log_info("Resend hci_read_local_supported_commands after CSR Warm Boot double reset");
 80112ae:	f240 5351 	movw	r3, #1361	; 0x551
 80112b2:	4a08      	ldr	r2, [pc, #32]	; (80112d4 <hci_initializing_run+0x5d4>)
 80112b4:	490f      	ldr	r1, [pc, #60]	; (80112f4 <hci_initializing_run+0x5f4>)
 80112b6:	2001      	movs	r0, #1
 80112b8:	f006 f8c2 	bl	8017440 <hci_dump_log>
            hci_stack->substate = HCI_INIT_W4_READ_LOCAL_SUPPORTED_COMMANDS;
 80112bc:	4b04      	ldr	r3, [pc, #16]	; (80112d0 <hci_initializing_run+0x5d0>)
 80112be:	681b      	ldr	r3, [r3, #0]
 80112c0:	220f      	movs	r2, #15
 80112c2:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_read_local_supported_commands);
 80112c6:	4809      	ldr	r0, [pc, #36]	; (80112ec <hci_initializing_run+0x5ec>)
 80112c8:	f004 fe8a 	bl	8015fe0 <hci_send_cmd>
            break;       
 80112cc:	e28b      	b.n	80117e6 <hci_initializing_run+0xae6>
 80112ce:	bf00      	nop
 80112d0:	20009780 	.word	0x20009780
 80112d4:	0802929c 	.word	0x0802929c
 80112d8:	08029ae0 	.word	0x08029ae0
 80112dc:	08010b61 	.word	0x08010b61
 80112e0:	08029af8 	.word	0x08029af8
 80112e4:	08029b10 	.word	0x08029b10
 80112e8:	08029b50 	.word	0x08029b50
 80112ec:	08030b48 	.word	0x08030b48
 80112f0:	08029b7c 	.word	0x08029b7c
 80112f4:	08029b9c 	.word	0x08029b9c
        case HCI_INIT_READ_BD_ADDR:
            hci_stack->substate = HCI_INIT_W4_READ_BD_ADDR;
 80112f8:	4bae      	ldr	r3, [pc, #696]	; (80115b4 <hci_initializing_run+0x8b4>)
 80112fa:	681b      	ldr	r3, [r3, #0]
 80112fc:	2217      	movs	r2, #23
 80112fe:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_read_bd_addr);
 8011302:	48ad      	ldr	r0, [pc, #692]	; (80115b8 <hci_initializing_run+0x8b8>)
 8011304:	f004 fe6c 	bl	8015fe0 <hci_send_cmd>
            break;
 8011308:	e26d      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_READ_BUFFER_SIZE:
            hci_stack->substate = HCI_INIT_W4_READ_BUFFER_SIZE;
 801130a:	4baa      	ldr	r3, [pc, #680]	; (80115b4 <hci_initializing_run+0x8b4>)
 801130c:	681b      	ldr	r3, [r3, #0]
 801130e:	2219      	movs	r2, #25
 8011310:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_read_buffer_size);
 8011314:	48a9      	ldr	r0, [pc, #676]	; (80115bc <hci_initializing_run+0x8bc>)
 8011316:	f004 fe63 	bl	8015fe0 <hci_send_cmd>
            break;
 801131a:	e264      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_READ_LOCAL_SUPPORTED_FEATURES:
            hci_stack->substate = HCI_INIT_W4_READ_LOCAL_SUPPORTED_FEATURES;
 801131c:	4ba5      	ldr	r3, [pc, #660]	; (80115b4 <hci_initializing_run+0x8b4>)
 801131e:	681b      	ldr	r3, [r3, #0]
 8011320:	221b      	movs	r2, #27
 8011322:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_read_local_supported_features);
 8011326:	48a6      	ldr	r0, [pc, #664]	; (80115c0 <hci_initializing_run+0x8c0>)
 8011328:	f004 fe5a 	bl	8015fe0 <hci_send_cmd>
            break;                
 801132c:	e25b      	b.n	80117e6 <hci_initializing_run+0xae6>
                                                HCI_HOST_ACL_PACKET_NUM, HCI_HOST_SCO_PACKET_NUM);
            break;            
#endif

        case HCI_INIT_SET_EVENT_MASK:
            hci_stack->substate = HCI_INIT_W4_SET_EVENT_MASK;
 801132e:	4ba1      	ldr	r3, [pc, #644]	; (80115b4 <hci_initializing_run+0x8b4>)
 8011330:	681b      	ldr	r3, [r3, #0]
 8011332:	221d      	movs	r2, #29
 8011334:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            if (hci_le_supported()){
 8011338:	f7ff fa94 	bl	8010864 <hci_le_supported>
 801133c:	4603      	mov	r3, r0
 801133e:	2b00      	cmp	r3, #0
 8011340:	d007      	beq.n	8011352 <hci_initializing_run+0x652>
                hci_send_cmd(&hci_set_event_mask,0xffffffff, 0x3FFFFFFF);
 8011342:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
 8011346:	f04f 31ff 	mov.w	r1, #4294967295
 801134a:	489e      	ldr	r0, [pc, #632]	; (80115c4 <hci_initializing_run+0x8c4>)
 801134c:	f004 fe48 	bl	8015fe0 <hci_send_cmd>
            } else {
                // Kensington Bluetooth 2.1 USB Dongle (CSR Chipset) returns an error for 0xffff... 
                hci_send_cmd(&hci_set_event_mask,0xffffffff, 0x1FFFFFFF);
            }
            break;
 8011350:	e249      	b.n	80117e6 <hci_initializing_run+0xae6>
                hci_send_cmd(&hci_set_event_mask,0xffffffff, 0x1FFFFFFF);
 8011352:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
 8011356:	f04f 31ff 	mov.w	r1, #4294967295
 801135a:	489a      	ldr	r0, [pc, #616]	; (80115c4 <hci_initializing_run+0x8c4>)
 801135c:	f004 fe40 	bl	8015fe0 <hci_send_cmd>
            break;
 8011360:	e241      	b.n	80117e6 <hci_initializing_run+0xae6>

#ifdef ENABLE_CLASSIC
        case HCI_INIT_WRITE_SIMPLE_PAIRING_MODE:
            hci_stack->substate = HCI_INIT_W4_WRITE_SIMPLE_PAIRING_MODE;
 8011362:	4b94      	ldr	r3, [pc, #592]	; (80115b4 <hci_initializing_run+0x8b4>)
 8011364:	681b      	ldr	r3, [r3, #0]
 8011366:	221f      	movs	r2, #31
 8011368:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_write_simple_pairing_mode, hci_stack->ssp_enable);
 801136c:	4b91      	ldr	r3, [pc, #580]	; (80115b4 <hci_initializing_run+0x8b4>)
 801136e:	681b      	ldr	r3, [r3, #0]
 8011370:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8011374:	4619      	mov	r1, r3
 8011376:	4894      	ldr	r0, [pc, #592]	; (80115c8 <hci_initializing_run+0x8c8>)
 8011378:	f004 fe32 	bl	8015fe0 <hci_send_cmd>
            break;
 801137c:	e233      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_WRITE_PAGE_TIMEOUT:
            hci_stack->substate = HCI_INIT_W4_WRITE_PAGE_TIMEOUT;
 801137e:	4b8d      	ldr	r3, [pc, #564]	; (80115b4 <hci_initializing_run+0x8b4>)
 8011380:	681b      	ldr	r3, [r3, #0]
 8011382:	2221      	movs	r2, #33	; 0x21
 8011384:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_write_page_timeout, 0x6000);  // ca. 15 sec
 8011388:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
 801138c:	488f      	ldr	r0, [pc, #572]	; (80115cc <hci_initializing_run+0x8cc>)
 801138e:	f004 fe27 	bl	8015fe0 <hci_send_cmd>
            break;
 8011392:	e228      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_WRITE_DEFAULT_LINK_POLICY_SETTING:
            hci_stack->substate = HCI_INIT_W4_WRITE_DEFAULT_LINK_POLICY_SETTING;
 8011394:	4b87      	ldr	r3, [pc, #540]	; (80115b4 <hci_initializing_run+0x8b4>)
 8011396:	681b      	ldr	r3, [r3, #0]
 8011398:	2223      	movs	r2, #35	; 0x23
 801139a:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_write_default_link_policy_setting, hci_stack->default_link_policy_settings);
 801139e:	4b85      	ldr	r3, [pc, #532]	; (80115b4 <hci_initializing_run+0x8b4>)
 80113a0:	681b      	ldr	r3, [r3, #0]
 80113a2:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 80113a6:	4619      	mov	r1, r3
 80113a8:	4889      	ldr	r0, [pc, #548]	; (80115d0 <hci_initializing_run+0x8d0>)
 80113aa:	f004 fe19 	bl	8015fe0 <hci_send_cmd>
            break;
 80113ae:	e21a      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_WRITE_CLASS_OF_DEVICE:
            hci_stack->substate = HCI_INIT_W4_WRITE_CLASS_OF_DEVICE;
 80113b0:	4b80      	ldr	r3, [pc, #512]	; (80115b4 <hci_initializing_run+0x8b4>)
 80113b2:	681b      	ldr	r3, [r3, #0]
 80113b4:	2225      	movs	r2, #37	; 0x25
 80113b6:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_write_class_of_device, hci_stack->class_of_device);
 80113ba:	4b7e      	ldr	r3, [pc, #504]	; (80115b4 <hci_initializing_run+0x8b4>)
 80113bc:	681b      	ldr	r3, [r3, #0]
 80113be:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80113c0:	4619      	mov	r1, r3
 80113c2:	4884      	ldr	r0, [pc, #528]	; (80115d4 <hci_initializing_run+0x8d4>)
 80113c4:	f004 fe0c 	bl	8015fe0 <hci_send_cmd>
            break;
 80113c8:	e20d      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_WRITE_LOCAL_NAME: {
            hci_stack->substate = HCI_INIT_W4_WRITE_LOCAL_NAME;
 80113ca:	4b7a      	ldr	r3, [pc, #488]	; (80115b4 <hci_initializing_run+0x8b4>)
 80113cc:	681b      	ldr	r3, [r3, #0]
 80113ce:	2227      	movs	r2, #39	; 0x27
 80113d0:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_reserve_packet_buffer();
 80113d4:	f7fe fe6e 	bl	80100b4 <hci_reserve_packet_buffer>
            uint8_t * packet = hci_stack->hci_packet_buffer;
 80113d8:	4b76      	ldr	r3, [pc, #472]	; (80115b4 <hci_initializing_run+0x8b4>)
 80113da:	681b      	ldr	r3, [r3, #0]
 80113dc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80113de:	62bb      	str	r3, [r7, #40]	; 0x28
            // construct HCI Command and send
            uint16_t opcode = hci_write_local_name.opcode;
 80113e0:	4b7d      	ldr	r3, [pc, #500]	; (80115d8 <hci_initializing_run+0x8d8>)
 80113e2:	881b      	ldrh	r3, [r3, #0]
 80113e4:	84fb      	strh	r3, [r7, #38]	; 0x26
            hci_stack->last_cmd_opcode = opcode;
 80113e6:	4b73      	ldr	r3, [pc, #460]	; (80115b4 <hci_initializing_run+0x8b4>)
 80113e8:	681b      	ldr	r3, [r3, #0]
 80113ea:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80113ec:	f8a3 272a 	strh.w	r2, [r3, #1834]	; 0x72a
            packet[0] = opcode & 0xff;
 80113f0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80113f2:	b2da      	uxtb	r2, r3
 80113f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80113f6:	701a      	strb	r2, [r3, #0]
            packet[1] = opcode >> 8;
 80113f8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80113fa:	0a1b      	lsrs	r3, r3, #8
 80113fc:	b29a      	uxth	r2, r3
 80113fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011400:	3301      	adds	r3, #1
 8011402:	b2d2      	uxtb	r2, r2
 8011404:	701a      	strb	r2, [r3, #0]
            packet[2] = DEVICE_NAME_LEN;
 8011406:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011408:	3302      	adds	r3, #2
 801140a:	22f8      	movs	r2, #248	; 0xf8
 801140c:	701a      	strb	r2, [r3, #0]
            memset(&packet[3], 0, DEVICE_NAME_LEN);
 801140e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011410:	3303      	adds	r3, #3
 8011412:	22f8      	movs	r2, #248	; 0xf8
 8011414:	2100      	movs	r1, #0
 8011416:	4618      	mov	r0, r3
 8011418:	f016 fb53 	bl	8027ac2 <memset>
            uint16_t name_len = (uint16_t) strlen(hci_stack->local_name);
 801141c:	4b65      	ldr	r3, [pc, #404]	; (80115b4 <hci_initializing_run+0x8b4>)
 801141e:	681b      	ldr	r3, [r3, #0]
 8011420:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011422:	4618      	mov	r0, r3
 8011424:	f7ee fedc 	bl	80001e0 <strlen>
 8011428:	4603      	mov	r3, r0
 801142a:	84bb      	strh	r3, [r7, #36]	; 0x24
            uint16_t bytes_to_copy = btstack_min(name_len, DEVICE_NAME_LEN);
 801142c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801142e:	21f8      	movs	r1, #248	; 0xf8
 8011430:	4618      	mov	r0, r3
 8011432:	f7fd fe6c 	bl	800f10e <btstack_min>
 8011436:	4603      	mov	r3, r0
 8011438:	847b      	strh	r3, [r7, #34]	; 0x22
            // if shorter than DEVICE_NAME_LEN, it's implicitly NULL-terminated by memset call
            (void)memcpy(&packet[3], hci_stack->local_name, bytes_to_copy);
 801143a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801143c:	1cd8      	adds	r0, r3, #3
 801143e:	4b5d      	ldr	r3, [pc, #372]	; (80115b4 <hci_initializing_run+0x8b4>)
 8011440:	681b      	ldr	r3, [r3, #0]
 8011442:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011444:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8011446:	4619      	mov	r1, r3
 8011448:	f016 fb17 	bl	8027a7a <memcpy>
            // expand '00:00:00:00:00:00' in name with bd_addr
            btstack_replace_bd_addr_placeholder(&packet[3], bytes_to_copy, hci_stack->local_bd_addr);
 801144c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801144e:	1cd8      	adds	r0, r3, #3
 8011450:	4b58      	ldr	r3, [pc, #352]	; (80115b4 <hci_initializing_run+0x8b4>)
 8011452:	681b      	ldr	r3, [r3, #0]
 8011454:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8011458:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801145a:	4619      	mov	r1, r3
 801145c:	f7fe f810 	bl	800f480 <btstack_replace_bd_addr_placeholder>
            hci_send_cmd_packet(packet, HCI_CMD_HEADER_SIZE + DEVICE_NAME_LEN);
 8011460:	21fb      	movs	r1, #251	; 0xfb
 8011462:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8011464:	f004 fba0 	bl	8015ba8 <hci_send_cmd_packet>
            break;
 8011468:	e1bd      	b.n	80117e6 <hci_initializing_run+0xae6>
        }
        case HCI_INIT_WRITE_EIR_DATA: {
            hci_stack->substate = HCI_INIT_W4_WRITE_EIR_DATA;
 801146a:	4b52      	ldr	r3, [pc, #328]	; (80115b4 <hci_initializing_run+0x8b4>)
 801146c:	681b      	ldr	r3, [r3, #0]
 801146e:	2229      	movs	r2, #41	; 0x29
 8011470:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_reserve_packet_buffer();
 8011474:	f7fe fe1e 	bl	80100b4 <hci_reserve_packet_buffer>
            uint8_t * packet = hci_stack->hci_packet_buffer;
 8011478:	4b4e      	ldr	r3, [pc, #312]	; (80115b4 <hci_initializing_run+0x8b4>)
 801147a:	681b      	ldr	r3, [r3, #0]
 801147c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801147e:	63bb      	str	r3, [r7, #56]	; 0x38
            // construct HCI Command in-place and send
            uint16_t opcode = hci_write_extended_inquiry_response.opcode;
 8011480:	4b56      	ldr	r3, [pc, #344]	; (80115dc <hci_initializing_run+0x8dc>)
 8011482:	881b      	ldrh	r3, [r3, #0]
 8011484:	86fb      	strh	r3, [r7, #54]	; 0x36
            hci_stack->last_cmd_opcode = opcode;
 8011486:	4b4b      	ldr	r3, [pc, #300]	; (80115b4 <hci_initializing_run+0x8b4>)
 8011488:	681b      	ldr	r3, [r3, #0]
 801148a:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801148c:	f8a3 272a 	strh.w	r2, [r3, #1834]	; 0x72a
            uint16_t offset = 0;
 8011490:	2300      	movs	r3, #0
 8011492:	87bb      	strh	r3, [r7, #60]	; 0x3c
            packet[offset++] = opcode & 0xff;
 8011494:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8011496:	1c5a      	adds	r2, r3, #1
 8011498:	87ba      	strh	r2, [r7, #60]	; 0x3c
 801149a:	461a      	mov	r2, r3
 801149c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801149e:	4413      	add	r3, r2
 80114a0:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 80114a2:	b2d2      	uxtb	r2, r2
 80114a4:	701a      	strb	r2, [r3, #0]
            packet[offset++] = opcode >> 8;
 80114a6:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 80114a8:	0a1b      	lsrs	r3, r3, #8
 80114aa:	b29a      	uxth	r2, r3
 80114ac:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 80114ae:	1c59      	adds	r1, r3, #1
 80114b0:	87b9      	strh	r1, [r7, #60]	; 0x3c
 80114b2:	4619      	mov	r1, r3
 80114b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80114b6:	440b      	add	r3, r1
 80114b8:	b2d2      	uxtb	r2, r2
 80114ba:	701a      	strb	r2, [r3, #0]
            packet[offset++] = 1 + EXTENDED_INQUIRY_RESPONSE_DATA_LEN;
 80114bc:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 80114be:	1c5a      	adds	r2, r3, #1
 80114c0:	87ba      	strh	r2, [r7, #60]	; 0x3c
 80114c2:	461a      	mov	r2, r3
 80114c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80114c6:	4413      	add	r3, r2
 80114c8:	22f1      	movs	r2, #241	; 0xf1
 80114ca:	701a      	strb	r2, [r3, #0]
            packet[offset++] = 0;  // FEC not required
 80114cc:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 80114ce:	1c5a      	adds	r2, r3, #1
 80114d0:	87ba      	strh	r2, [r7, #60]	; 0x3c
 80114d2:	461a      	mov	r2, r3
 80114d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80114d6:	4413      	add	r3, r2
 80114d8:	2200      	movs	r2, #0
 80114da:	701a      	strb	r2, [r3, #0]
            memset(&packet[offset], 0, EXTENDED_INQUIRY_RESPONSE_DATA_LEN);
 80114dc:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 80114de:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80114e0:	4413      	add	r3, r2
 80114e2:	22f0      	movs	r2, #240	; 0xf0
 80114e4:	2100      	movs	r1, #0
 80114e6:	4618      	mov	r0, r3
 80114e8:	f016 faeb 	bl	8027ac2 <memset>
            if (hci_stack->eir_data){
 80114ec:	4b31      	ldr	r3, [pc, #196]	; (80115b4 <hci_initializing_run+0x8b4>)
 80114ee:	681b      	ldr	r3, [r3, #0]
 80114f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80114f2:	2b00      	cmp	r3, #0
 80114f4:	d074      	beq.n	80115e0 <hci_initializing_run+0x8e0>
                // copy items and expand '00:00:00:00:00:00' in name with bd_addr
                ad_context_t context;
                for (ad_iterator_init(&context, EXTENDED_INQUIRY_RESPONSE_DATA_LEN, hci_stack->eir_data) ; ad_iterator_has_more(&context) ; ad_iterator_next(&context)) {
 80114f6:	4b2f      	ldr	r3, [pc, #188]	; (80115b4 <hci_initializing_run+0x8b4>)
 80114f8:	681b      	ldr	r3, [r3, #0]
 80114fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80114fc:	463b      	mov	r3, r7
 80114fe:	21f0      	movs	r1, #240	; 0xf0
 8011500:	4618      	mov	r0, r3
 8011502:	f7fb fe31 	bl	800d168 <ad_iterator_init>
 8011506:	e04d      	b.n	80115a4 <hci_initializing_run+0x8a4>
                    uint8_t data_type   = ad_iterator_get_data_type(&context);
 8011508:	463b      	mov	r3, r7
 801150a:	4618      	mov	r0, r3
 801150c:	f7fb fe9a 	bl	800d244 <ad_iterator_get_data_type>
 8011510:	4603      	mov	r3, r0
 8011512:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
                    uint8_t size        = ad_iterator_get_data_len(&context);
 8011516:	463b      	mov	r3, r7
 8011518:	4618      	mov	r0, r3
 801151a:	f7fb fe81 	bl	800d220 <ad_iterator_get_data_len>
 801151e:	4603      	mov	r3, r0
 8011520:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
                    const uint8_t *data = ad_iterator_get_data(&context);
 8011524:	463b      	mov	r3, r7
 8011526:	4618      	mov	r0, r3
 8011528:	f7fb fe9d 	bl	800d266 <ad_iterator_get_data>
 801152c:	62f8      	str	r0, [r7, #44]	; 0x2c
                    // copy item
                    packet[offset++] = size + 1;
 801152e:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8011530:	1c5a      	adds	r2, r3, #1
 8011532:	87ba      	strh	r2, [r7, #60]	; 0x3c
 8011534:	461a      	mov	r2, r3
 8011536:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011538:	4413      	add	r3, r2
 801153a:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 801153e:	3201      	adds	r2, #1
 8011540:	b2d2      	uxtb	r2, r2
 8011542:	701a      	strb	r2, [r3, #0]
                    packet[offset++] = data_type;
 8011544:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8011546:	1c5a      	adds	r2, r3, #1
 8011548:	87ba      	strh	r2, [r7, #60]	; 0x3c
 801154a:	461a      	mov	r2, r3
 801154c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801154e:	4413      	add	r3, r2
 8011550:	f897 2031 	ldrb.w	r2, [r7, #49]	; 0x31
 8011554:	701a      	strb	r2, [r3, #0]
                    memcpy(&packet[offset], data, size);
 8011556:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8011558:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801155a:	4413      	add	r3, r2
 801155c:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8011560:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8011562:	4618      	mov	r0, r3
 8011564:	f016 fa89 	bl	8027a7a <memcpy>
                    // update name item
                    if ((data_type == BLUETOOTH_DATA_TYPE_SHORTENED_LOCAL_NAME) || (data_type == BLUETOOTH_DATA_TYPE_COMPLETE_LOCAL_NAME)){
 8011568:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 801156c:	2b08      	cmp	r3, #8
 801156e:	d003      	beq.n	8011578 <hci_initializing_run+0x878>
 8011570:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 8011574:	2b09      	cmp	r3, #9
 8011576:	d10b      	bne.n	8011590 <hci_initializing_run+0x890>
                        btstack_replace_bd_addr_placeholder(&packet[offset], size, hci_stack->local_bd_addr);
 8011578:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 801157a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801157c:	18d0      	adds	r0, r2, r3
 801157e:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8011582:	b299      	uxth	r1, r3
 8011584:	4b0b      	ldr	r3, [pc, #44]	; (80115b4 <hci_initializing_run+0x8b4>)
 8011586:	681b      	ldr	r3, [r3, #0]
 8011588:	3338      	adds	r3, #56	; 0x38
 801158a:	461a      	mov	r2, r3
 801158c:	f7fd ff78 	bl	800f480 <btstack_replace_bd_addr_placeholder>
                    }
                    offset += size;
 8011590:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8011594:	b29a      	uxth	r2, r3
 8011596:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8011598:	4413      	add	r3, r2
 801159a:	87bb      	strh	r3, [r7, #60]	; 0x3c
                for (ad_iterator_init(&context, EXTENDED_INQUIRY_RESPONSE_DATA_LEN, hci_stack->eir_data) ; ad_iterator_has_more(&context) ; ad_iterator_next(&context)) {
 801159c:	463b      	mov	r3, r7
 801159e:	4618      	mov	r0, r3
 80115a0:	f7fb fe24 	bl	800d1ec <ad_iterator_next>
 80115a4:	463b      	mov	r3, r7
 80115a6:	4618      	mov	r0, r3
 80115a8:	f7fb fdf4 	bl	800d194 <ad_iterator_has_more>
 80115ac:	4603      	mov	r3, r0
 80115ae:	2b00      	cmp	r3, #0
 80115b0:	d1aa      	bne.n	8011508 <hci_initializing_run+0x808>
 80115b2:	e04b      	b.n	801164c <hci_initializing_run+0x94c>
 80115b4:	20009780 	.word	0x20009780
 80115b8:	08030b60 	.word	0x08030b60
 80115bc:	08030b58 	.word	0x08030b58
 80115c0:	08030b50 	.word	0x08030b50
 80115c4:	08030ac8 	.word	0x08030ac8
 80115c8:	08030b20 	.word	0x08030b20
 80115cc:	08030ae8 	.word	0x08030ae8
 80115d0:	08030ac0 	.word	0x08030ac0
 80115d4:	08030af8 	.word	0x08030af8
 80115d8:	08030ad8 	.word	0x08030ad8
 80115dc:	08030b18 	.word	0x08030b18
                }
            } else {
                uint16_t name_len = (uint16_t) strlen(hci_stack->local_name);
 80115e0:	4b82      	ldr	r3, [pc, #520]	; (80117ec <hci_initializing_run+0xaec>)
 80115e2:	681b      	ldr	r3, [r3, #0]
 80115e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80115e6:	4618      	mov	r0, r3
 80115e8:	f7ee fdfa 	bl	80001e0 <strlen>
 80115ec:	4603      	mov	r3, r0
 80115ee:	86bb      	strh	r3, [r7, #52]	; 0x34
                uint16_t bytes_to_copy = btstack_min(name_len, EXTENDED_INQUIRY_RESPONSE_DATA_LEN - 2);
 80115f0:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 80115f2:	21ee      	movs	r1, #238	; 0xee
 80115f4:	4618      	mov	r0, r3
 80115f6:	f7fd fd8a 	bl	800f10e <btstack_min>
 80115fa:	4603      	mov	r3, r0
 80115fc:	867b      	strh	r3, [r7, #50]	; 0x32
                packet[offset++] = bytes_to_copy + 1;
 80115fe:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8011600:	b2da      	uxtb	r2, r3
 8011602:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8011604:	1c59      	adds	r1, r3, #1
 8011606:	87b9      	strh	r1, [r7, #60]	; 0x3c
 8011608:	4619      	mov	r1, r3
 801160a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801160c:	440b      	add	r3, r1
 801160e:	3201      	adds	r2, #1
 8011610:	b2d2      	uxtb	r2, r2
 8011612:	701a      	strb	r2, [r3, #0]
                packet[offset++] = BLUETOOTH_DATA_TYPE_COMPLETE_LOCAL_NAME;
 8011614:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8011616:	1c5a      	adds	r2, r3, #1
 8011618:	87ba      	strh	r2, [r7, #60]	; 0x3c
 801161a:	461a      	mov	r2, r3
 801161c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801161e:	4413      	add	r3, r2
 8011620:	2209      	movs	r2, #9
 8011622:	701a      	strb	r2, [r3, #0]
                (void)memcpy(&packet[6], hci_stack->local_name, bytes_to_copy);
 8011624:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011626:	1d98      	adds	r0, r3, #6
 8011628:	4b70      	ldr	r3, [pc, #448]	; (80117ec <hci_initializing_run+0xaec>)
 801162a:	681b      	ldr	r3, [r3, #0]
 801162c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801162e:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
 8011630:	4619      	mov	r1, r3
 8011632:	f016 fa22 	bl	8027a7a <memcpy>
                // expand '00:00:00:00:00:00' in name with bd_addr
                btstack_replace_bd_addr_placeholder(&packet[offset], bytes_to_copy, hci_stack->local_bd_addr);
 8011636:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8011638:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801163a:	18d0      	adds	r0, r2, r3
 801163c:	4b6b      	ldr	r3, [pc, #428]	; (80117ec <hci_initializing_run+0xaec>)
 801163e:	681b      	ldr	r3, [r3, #0]
 8011640:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8011644:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8011646:	4619      	mov	r1, r3
 8011648:	f7fd ff1a 	bl	800f480 <btstack_replace_bd_addr_placeholder>
            }
            hci_send_cmd_packet(packet, HCI_CMD_HEADER_SIZE + 1 + EXTENDED_INQUIRY_RESPONSE_DATA_LEN);
 801164c:	21f4      	movs	r1, #244	; 0xf4
 801164e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8011650:	f004 faaa 	bl	8015ba8 <hci_send_cmd_packet>
            break;
 8011654:	e0c7      	b.n	80117e6 <hci_initializing_run+0xae6>
        }
        case HCI_INIT_WRITE_INQUIRY_MODE:
            hci_stack->substate = HCI_INIT_W4_WRITE_INQUIRY_MODE;
 8011656:	4b65      	ldr	r3, [pc, #404]	; (80117ec <hci_initializing_run+0xaec>)
 8011658:	681b      	ldr	r3, [r3, #0]
 801165a:	222b      	movs	r2, #43	; 0x2b
 801165c:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_write_inquiry_mode, (int) hci_stack->inquiry_mode);
 8011660:	4b62      	ldr	r3, [pc, #392]	; (80117ec <hci_initializing_run+0xaec>)
 8011662:	681b      	ldr	r3, [r3, #0]
 8011664:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8011668:	4619      	mov	r1, r3
 801166a:	4861      	ldr	r0, [pc, #388]	; (80117f0 <hci_initializing_run+0xaf0>)
 801166c:	f004 fcb8 	bl	8015fe0 <hci_send_cmd>
            break;
 8011670:	e0b9      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_WRITE_SECURE_CONNECTIONS_HOST_ENABLE:
            hci_send_cmd(&hci_write_secure_connections_host_support, 1);
 8011672:	2101      	movs	r1, #1
 8011674:	485f      	ldr	r0, [pc, #380]	; (80117f4 <hci_initializing_run+0xaf4>)
 8011676:	f004 fcb3 	bl	8015fe0 <hci_send_cmd>
			hci_stack->secure_connections_active = true;
 801167a:	4b5c      	ldr	r3, [pc, #368]	; (80117ec <hci_initializing_run+0xaec>)
 801167c:	681b      	ldr	r3, [r3, #0]
 801167e:	2201      	movs	r2, #1
 8011680:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
            hci_stack->substate = HCI_INIT_W4_WRITE_SECURE_CONNECTIONS_HOST_ENABLE;
 8011684:	4b59      	ldr	r3, [pc, #356]	; (80117ec <hci_initializing_run+0xaec>)
 8011686:	681b      	ldr	r3, [r3, #0]
 8011688:	222d      	movs	r2, #45	; 0x2d
 801168a:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            break;
 801168e:	e0aa      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_WRITE_SCAN_ENABLE:
            hci_send_cmd(&hci_write_scan_enable, (hci_stack->connectable << 1) | hci_stack->discoverable); // page scan
 8011690:	4b56      	ldr	r3, [pc, #344]	; (80117ec <hci_initializing_run+0xaec>)
 8011692:	681b      	ldr	r3, [r3, #0]
 8011694:	f893 372f 	ldrb.w	r3, [r3, #1839]	; 0x72f
 8011698:	005b      	lsls	r3, r3, #1
 801169a:	4a54      	ldr	r2, [pc, #336]	; (80117ec <hci_initializing_run+0xaec>)
 801169c:	6812      	ldr	r2, [r2, #0]
 801169e:	f892 272e 	ldrb.w	r2, [r2, #1838]	; 0x72e
 80116a2:	4313      	orrs	r3, r2
 80116a4:	4619      	mov	r1, r3
 80116a6:	4854      	ldr	r0, [pc, #336]	; (80117f8 <hci_initializing_run+0xaf8>)
 80116a8:	f004 fc9a 	bl	8015fe0 <hci_send_cmd>
            hci_stack->substate = HCI_INIT_W4_WRITE_SCAN_ENABLE;
 80116ac:	4b4f      	ldr	r3, [pc, #316]	; (80117ec <hci_initializing_run+0xaec>)
 80116ae:	681b      	ldr	r3, [r3, #0]
 80116b0:	222f      	movs	r2, #47	; 0x2f
 80116b2:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            break;
 80116b6:	e096      	b.n	80117e6 <hci_initializing_run+0xae6>
        // only sent if ENABLE_SCO_OVER_HCI is defined
        case HCI_INIT_WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE:
            hci_stack->substate = HCI_INIT_W4_WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE;
 80116b8:	4b4c      	ldr	r3, [pc, #304]	; (80117ec <hci_initializing_run+0xaec>)
 80116ba:	681b      	ldr	r3, [r3, #0]
 80116bc:	2231      	movs	r2, #49	; 0x31
 80116be:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_write_synchronous_flow_control_enable, 1); // SCO tracking enabled
 80116c2:	2101      	movs	r1, #1
 80116c4:	484d      	ldr	r0, [pc, #308]	; (80117fc <hci_initializing_run+0xafc>)
 80116c6:	f004 fc8b 	bl	8015fe0 <hci_send_cmd>
            break;
 80116ca:	e08c      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING:
            hci_stack->substate = HCI_INIT_W4_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING;
 80116cc:	4b47      	ldr	r3, [pc, #284]	; (80117ec <hci_initializing_run+0xaec>)
 80116ce:	681b      	ldr	r3, [r3, #0]
 80116d0:	2233      	movs	r2, #51	; 0x33
 80116d2:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_write_default_erroneous_data_reporting, 1);
 80116d6:	2101      	movs	r1, #1
 80116d8:	4849      	ldr	r0, [pc, #292]	; (8011800 <hci_initializing_run+0xb00>)
 80116da:	f004 fc81 	bl	8015fe0 <hci_send_cmd>
            break;
 80116de:	e082      	b.n	80117e6 <hci_initializing_run+0xae6>
        // only sent if manufacturer is Broadcom and ENABLE_SCO_OVER_HCI or ENABLE_SCO_OVER_PCM is defined
        case HCI_INIT_BCM_WRITE_SCO_PCM_INT:
            hci_stack->substate = HCI_INIT_W4_BCM_WRITE_SCO_PCM_INT;
 80116e0:	4b42      	ldr	r3, [pc, #264]	; (80117ec <hci_initializing_run+0xaec>)
 80116e2:	681b      	ldr	r3, [r3, #0]
 80116e4:	2235      	movs	r2, #53	; 0x35
 80116e6:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
#ifdef ENABLE_SCO_OVER_HCI
            log_info("BCM: Route SCO data via HCI transport");
 80116ea:	f240 53e1 	movw	r3, #1505	; 0x5e1
 80116ee:	4a45      	ldr	r2, [pc, #276]	; (8011804 <hci_initializing_run+0xb04>)
 80116f0:	4945      	ldr	r1, [pc, #276]	; (8011808 <hci_initializing_run+0xb08>)
 80116f2:	2001      	movs	r0, #1
 80116f4:	f005 fea4 	bl	8017440 <hci_dump_log>
            hci_send_cmd(&hci_bcm_write_sco_pcm_int, 1, 0, 0, 0, 0);
 80116f8:	2300      	movs	r3, #0
 80116fa:	9301      	str	r3, [sp, #4]
 80116fc:	2300      	movs	r3, #0
 80116fe:	9300      	str	r3, [sp, #0]
 8011700:	2300      	movs	r3, #0
 8011702:	2200      	movs	r2, #0
 8011704:	2101      	movs	r1, #1
 8011706:	4841      	ldr	r0, [pc, #260]	; (801180c <hci_initializing_run+0xb0c>)
 8011708:	f004 fc6a 	bl	8015fe0 <hci_send_cmd>
#endif
#ifdef ENABLE_SCO_OVER_PCM
            log_info("BCM: Route SCO data via PCM interface");
            hci_send_cmd(&hci_bcm_write_sco_pcm_int, 0, 4, 0, 1, 1);
#endif
            break;
 801170c:	e06b      	b.n	80117e6 <hci_initializing_run+0xae6>

#endif
#ifdef ENABLE_BLE
        // LE INIT
        case HCI_INIT_LE_READ_BUFFER_SIZE:
            hci_stack->substate = HCI_INIT_W4_LE_READ_BUFFER_SIZE;
 801170e:	4b37      	ldr	r3, [pc, #220]	; (80117ec <hci_initializing_run+0xaec>)
 8011710:	681b      	ldr	r3, [r3, #0]
 8011712:	2237      	movs	r2, #55	; 0x37
 8011714:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_le_read_buffer_size);
 8011718:	483d      	ldr	r0, [pc, #244]	; (8011810 <hci_initializing_run+0xb10>)
 801171a:	f004 fc61 	bl	8015fe0 <hci_send_cmd>
            break;
 801171e:	e062      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_LE_SET_EVENT_MASK:
            hci_stack->substate = HCI_INIT_W4_LE_SET_EVENT_MASK;
 8011720:	4b32      	ldr	r3, [pc, #200]	; (80117ec <hci_initializing_run+0xaec>)
 8011722:	681b      	ldr	r3, [r3, #0]
 8011724:	223b      	movs	r2, #59	; 0x3b
 8011726:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_le_set_event_mask, 0x809FF, 0x0); // bits 0-8, 11, 19 
 801172a:	2200      	movs	r2, #0
 801172c:	4939      	ldr	r1, [pc, #228]	; (8011814 <hci_initializing_run+0xb14>)
 801172e:	483a      	ldr	r0, [pc, #232]	; (8011818 <hci_initializing_run+0xb18>)
 8011730:	f004 fc56 	bl	8015fe0 <hci_send_cmd>
            break;
 8011734:	e057      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_WRITE_LE_HOST_SUPPORTED:
            // LE Supported Host = 1, Simultaneous Host = 0
            hci_stack->substate = HCI_INIT_W4_WRITE_LE_HOST_SUPPORTED;
 8011736:	4b2d      	ldr	r3, [pc, #180]	; (80117ec <hci_initializing_run+0xaec>)
 8011738:	681b      	ldr	r3, [r3, #0]
 801173a:	2239      	movs	r2, #57	; 0x39
 801173c:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_write_le_host_supported, 1, 0);
 8011740:	2200      	movs	r2, #0
 8011742:	2101      	movs	r1, #1
 8011744:	4835      	ldr	r0, [pc, #212]	; (801181c <hci_initializing_run+0xb1c>)
 8011746:	f004 fc4b 	bl	8015fe0 <hci_send_cmd>
            break;
 801174a:	e04c      	b.n	80117e6 <hci_initializing_run+0xae6>
#endif

#ifdef ENABLE_LE_DATA_LENGTH_EXTENSION
        case HCI_INIT_LE_READ_MAX_DATA_LENGTH:
            hci_stack->substate = HCI_INIT_W4_LE_READ_MAX_DATA_LENGTH;
 801174c:	4b27      	ldr	r3, [pc, #156]	; (80117ec <hci_initializing_run+0xaec>)
 801174e:	681b      	ldr	r3, [r3, #0]
 8011750:	223d      	movs	r2, #61	; 0x3d
 8011752:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_le_read_maximum_data_length);
 8011756:	4832      	ldr	r0, [pc, #200]	; (8011820 <hci_initializing_run+0xb20>)
 8011758:	f004 fc42 	bl	8015fe0 <hci_send_cmd>
            break;
 801175c:	e043      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_LE_WRITE_SUGGESTED_DATA_LENGTH:
            hci_stack->substate = HCI_INIT_W4_LE_WRITE_SUGGESTED_DATA_LENGTH;
 801175e:	4b23      	ldr	r3, [pc, #140]	; (80117ec <hci_initializing_run+0xaec>)
 8011760:	681b      	ldr	r3, [r3, #0]
 8011762:	223f      	movs	r2, #63	; 0x3f
 8011764:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_le_write_suggested_default_data_length, hci_stack->le_supported_max_tx_octets, hci_stack->le_supported_max_tx_time);
 8011768:	4b20      	ldr	r3, [pc, #128]	; (80117ec <hci_initializing_run+0xaec>)
 801176a:	681b      	ldr	r3, [r3, #0]
 801176c:	f8b3 37ae 	ldrh.w	r3, [r3, #1966]	; 0x7ae
 8011770:	4619      	mov	r1, r3
 8011772:	4b1e      	ldr	r3, [pc, #120]	; (80117ec <hci_initializing_run+0xaec>)
 8011774:	681b      	ldr	r3, [r3, #0]
 8011776:	f8b3 37b0 	ldrh.w	r3, [r3, #1968]	; 0x7b0
 801177a:	461a      	mov	r2, r3
 801177c:	4829      	ldr	r0, [pc, #164]	; (8011824 <hci_initializing_run+0xb24>)
 801177e:	f004 fc2f 	bl	8015fe0 <hci_send_cmd>
            break;
 8011782:	e030      	b.n	80117e6 <hci_initializing_run+0xae6>
#endif

#ifdef ENABLE_LE_CENTRAL
        case HCI_INIT_READ_WHITE_LIST_SIZE:
            hci_stack->substate = HCI_INIT_W4_READ_WHITE_LIST_SIZE;
 8011784:	4b19      	ldr	r3, [pc, #100]	; (80117ec <hci_initializing_run+0xaec>)
 8011786:	681b      	ldr	r3, [r3, #0]
 8011788:	2241      	movs	r2, #65	; 0x41
 801178a:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_le_read_white_list_size);
 801178e:	4826      	ldr	r0, [pc, #152]	; (8011828 <hci_initializing_run+0xb28>)
 8011790:	f004 fc26 	bl	8015fe0 <hci_send_cmd>
            break;
 8011794:	e027      	b.n	80117e6 <hci_initializing_run+0xae6>
        case HCI_INIT_LE_SET_SCAN_PARAMETERS:
            hci_stack->substate = HCI_INIT_W4_LE_SET_SCAN_PARAMETERS;
 8011796:	4b15      	ldr	r3, [pc, #84]	; (80117ec <hci_initializing_run+0xaec>)
 8011798:	681b      	ldr	r3, [r3, #0]
 801179a:	2243      	movs	r2, #67	; 0x43
 801179c:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            hci_send_cmd(&hci_le_set_scan_parameters, hci_stack->le_scan_type, hci_stack->le_scan_interval, hci_stack->le_scan_window, hci_stack->le_own_addr_type, hci_stack->le_scan_filter_policy);
 80117a0:	4b12      	ldr	r3, [pc, #72]	; (80117ec <hci_initializing_run+0xaec>)
 80117a2:	681b      	ldr	r3, [r3, #0]
 80117a4:	f893 3769 	ldrb.w	r3, [r3, #1897]	; 0x769
 80117a8:	4619      	mov	r1, r3
 80117aa:	4b10      	ldr	r3, [pc, #64]	; (80117ec <hci_initializing_run+0xaec>)
 80117ac:	681b      	ldr	r3, [r3, #0]
 80117ae:	f8b3 376c 	ldrh.w	r3, [r3, #1900]	; 0x76c
 80117b2:	4618      	mov	r0, r3
 80117b4:	4b0d      	ldr	r3, [pc, #52]	; (80117ec <hci_initializing_run+0xaec>)
 80117b6:	681b      	ldr	r3, [r3, #0]
 80117b8:	f8b3 376e 	ldrh.w	r3, [r3, #1902]	; 0x76e
 80117bc:	461c      	mov	r4, r3
 80117be:	4b0b      	ldr	r3, [pc, #44]	; (80117ec <hci_initializing_run+0xaec>)
 80117c0:	681b      	ldr	r3, [r3, #0]
 80117c2:	f893 3754 	ldrb.w	r3, [r3, #1876]	; 0x754
 80117c6:	461a      	mov	r2, r3
 80117c8:	4b08      	ldr	r3, [pc, #32]	; (80117ec <hci_initializing_run+0xaec>)
 80117ca:	681b      	ldr	r3, [r3, #0]
 80117cc:	f893 376a 	ldrb.w	r3, [r3, #1898]	; 0x76a
 80117d0:	9301      	str	r3, [sp, #4]
 80117d2:	9200      	str	r2, [sp, #0]
 80117d4:	4623      	mov	r3, r4
 80117d6:	4602      	mov	r2, r0
 80117d8:	4814      	ldr	r0, [pc, #80]	; (801182c <hci_initializing_run+0xb2c>)
 80117da:	f004 fc01 	bl	8015fe0 <hci_send_cmd>
            break;
 80117de:	e002      	b.n	80117e6 <hci_initializing_run+0xae6>
#endif
        default:
            return;
 80117e0:	bf00      	nop
 80117e2:	e000      	b.n	80117e6 <hci_initializing_run+0xae6>
            break;
 80117e4:	bf00      	nop
    }
}
 80117e6:	3744      	adds	r7, #68	; 0x44
 80117e8:	46bd      	mov	sp, r7
 80117ea:	bd90      	pop	{r4, r7, pc}
 80117ec:	20009780 	.word	0x20009780
 80117f0:	08030b10 	.word	0x08030b10
 80117f4:	08030b38 	.word	0x08030b38
 80117f8:	08030af0 	.word	0x08030af0
 80117fc:	08030b00 	.word	0x08030b00
 8011800:	08030b28 	.word	0x08030b28
 8011804:	0802929c 	.word	0x0802929c
 8011808:	08029bf0 	.word	0x08029bf0
 801180c:	08030c40 	.word	0x08030c40
 8011810:	08030b80 	.word	0x08030b80
 8011814:	000809ff 	.word	0x000809ff
 8011818:	08030b78 	.word	0x08030b78
 801181c:	08030b30 	.word	0x08030b30
 8011820:	08030c30 	.word	0x08030c30
 8011824:	08030c28 	.word	0x08030c28
 8011828:	08030bd0 	.word	0x08030bd0
 801182c:	08030bb0 	.word	0x08030bb0

08011830 <hci_init_done>:

static void hci_init_done(void){
 8011830:	b580      	push	{r7, lr}
 8011832:	af00      	add	r7, sp, #0
    // done. tell the app
    log_info("hci_init_done -> HCI_STATE_WORKING");
 8011834:	f44f 63c3 	mov.w	r3, #1560	; 0x618
 8011838:	4a07      	ldr	r2, [pc, #28]	; (8011858 <hci_init_done+0x28>)
 801183a:	4908      	ldr	r1, [pc, #32]	; (801185c <hci_init_done+0x2c>)
 801183c:	2001      	movs	r0, #1
 801183e:	f005 fdff 	bl	8017440 <hci_dump_log>
    hci_stack->state = HCI_STATE_WORKING;
 8011842:	4b07      	ldr	r3, [pc, #28]	; (8011860 <hci_init_done+0x30>)
 8011844:	681b      	ldr	r3, [r3, #0]
 8011846:	2202      	movs	r2, #2
 8011848:	f883 2716 	strb.w	r2, [r3, #1814]	; 0x716
    hci_emit_state();
 801184c:	f004 fd92 	bl	8016374 <hci_emit_state>
    hci_run();
 8011850:	f004 f826 	bl	80158a0 <hci_run>
}
 8011854:	bf00      	nop
 8011856:	bd80      	pop	{r7, pc}
 8011858:	0802929c 	.word	0x0802929c
 801185c:	08029c20 	.word	0x08029c20
 8011860:	20009780 	.word	0x20009780

08011864 <hci_initializing_event_handler_command_completed>:

static bool hci_initializing_event_handler_command_completed(const uint8_t * packet){
 8011864:	b580      	push	{r7, lr}
 8011866:	b088      	sub	sp, #32
 8011868:	af04      	add	r7, sp, #16
 801186a:	6078      	str	r0, [r7, #4]
    bool command_completed = false;
 801186c:	2300      	movs	r3, #0
 801186e:	73fb      	strb	r3, [r7, #15]
    if (hci_event_packet_get_type(packet) == HCI_EVENT_COMMAND_COMPLETE){
 8011870:	6878      	ldr	r0, [r7, #4]
 8011872:	f7fd fe3d 	bl	800f4f0 <hci_event_packet_get_type>
 8011876:	4603      	mov	r3, r0
 8011878:	2b0e      	cmp	r3, #14
 801187a:	d123      	bne.n	80118c4 <hci_initializing_event_handler_command_completed+0x60>
        uint16_t opcode = little_endian_read_16(packet,3);
 801187c:	2103      	movs	r1, #3
 801187e:	6878      	ldr	r0, [r7, #4]
 8011880:	f7fd fab1 	bl	800ede6 <little_endian_read_16>
 8011884:	4603      	mov	r3, r0
 8011886:	81bb      	strh	r3, [r7, #12]
        if (opcode == hci_stack->last_cmd_opcode){
 8011888:	4b34      	ldr	r3, [pc, #208]	; (801195c <hci_initializing_event_handler_command_completed+0xf8>)
 801188a:	681b      	ldr	r3, [r3, #0]
 801188c:	f8b3 372a 	ldrh.w	r3, [r3, #1834]	; 0x72a
 8011890:	89ba      	ldrh	r2, [r7, #12]
 8011892:	429a      	cmp	r2, r3
 8011894:	d102      	bne.n	801189c <hci_initializing_event_handler_command_completed+0x38>
            command_completed = true;
 8011896:	2301      	movs	r3, #1
 8011898:	73fb      	strb	r3, [r7, #15]
 801189a:	e013      	b.n	80118c4 <hci_initializing_event_handler_command_completed+0x60>
            log_debug("Command complete for expected opcode %04x at substate %u", opcode, hci_stack->substate);
        } else {
            log_info("Command complete for different opcode %04x, expected %04x, at substate %u", opcode, hci_stack->last_cmd_opcode, hci_stack->substate);
 801189c:	89bb      	ldrh	r3, [r7, #12]
 801189e:	4a2f      	ldr	r2, [pc, #188]	; (801195c <hci_initializing_event_handler_command_completed+0xf8>)
 80118a0:	6812      	ldr	r2, [r2, #0]
 80118a2:	f8b2 272a 	ldrh.w	r2, [r2, #1834]	; 0x72a
 80118a6:	4611      	mov	r1, r2
 80118a8:	4a2c      	ldr	r2, [pc, #176]	; (801195c <hci_initializing_event_handler_command_completed+0xf8>)
 80118aa:	6812      	ldr	r2, [r2, #0]
 80118ac:	f892 2717 	ldrb.w	r2, [r2, #1815]	; 0x717
 80118b0:	9202      	str	r2, [sp, #8]
 80118b2:	9101      	str	r1, [sp, #4]
 80118b4:	9300      	str	r3, [sp, #0]
 80118b6:	f240 6326 	movw	r3, #1574	; 0x626
 80118ba:	4a29      	ldr	r2, [pc, #164]	; (8011960 <hci_initializing_event_handler_command_completed+0xfc>)
 80118bc:	4929      	ldr	r1, [pc, #164]	; (8011964 <hci_initializing_event_handler_command_completed+0x100>)
 80118be:	2001      	movs	r0, #1
 80118c0:	f005 fdbe 	bl	8017440 <hci_dump_log>
        }
    }

    if (hci_event_packet_get_type(packet) == HCI_EVENT_COMMAND_STATUS){
 80118c4:	6878      	ldr	r0, [r7, #4]
 80118c6:	f7fd fe13 	bl	800f4f0 <hci_event_packet_get_type>
 80118ca:	4603      	mov	r3, r0
 80118cc:	2b0f      	cmp	r3, #15
 80118ce:	d11e      	bne.n	801190e <hci_initializing_event_handler_command_completed+0xaa>
        uint8_t  status = packet[2];
 80118d0:	687b      	ldr	r3, [r7, #4]
 80118d2:	789b      	ldrb	r3, [r3, #2]
 80118d4:	72fb      	strb	r3, [r7, #11]
        uint16_t opcode = little_endian_read_16(packet,4);
 80118d6:	2104      	movs	r1, #4
 80118d8:	6878      	ldr	r0, [r7, #4]
 80118da:	f7fd fa84 	bl	800ede6 <little_endian_read_16>
 80118de:	4603      	mov	r3, r0
 80118e0:	813b      	strh	r3, [r7, #8]
        if (opcode == hci_stack->last_cmd_opcode){
 80118e2:	4b1e      	ldr	r3, [pc, #120]	; (801195c <hci_initializing_event_handler_command_completed+0xf8>)
 80118e4:	681b      	ldr	r3, [r3, #0]
 80118e6:	f8b3 372a 	ldrh.w	r3, [r3, #1834]	; 0x72a
 80118ea:	893a      	ldrh	r2, [r7, #8]
 80118ec:	429a      	cmp	r2, r3
 80118ee:	d10e      	bne.n	801190e <hci_initializing_event_handler_command_completed+0xaa>
            if (status){
 80118f0:	7afb      	ldrb	r3, [r7, #11]
 80118f2:	2b00      	cmp	r3, #0
 80118f4:	d002      	beq.n	80118fc <hci_initializing_event_handler_command_completed+0x98>
                command_completed = true;
 80118f6:	2301      	movs	r3, #1
 80118f8:	73fb      	strb	r3, [r7, #15]
 80118fa:	e008      	b.n	801190e <hci_initializing_event_handler_command_completed+0xaa>
                log_debug("Command status error 0x%02x for expected opcode %04x at substate %u", status, opcode, hci_stack->substate);
            } else {
                log_info("Command status OK for expected opcode %04x, waiting for command complete", opcode);
 80118fc:	893b      	ldrh	r3, [r7, #8]
 80118fe:	9300      	str	r3, [sp, #0]
 8011900:	f240 6332 	movw	r3, #1586	; 0x632
 8011904:	4a16      	ldr	r2, [pc, #88]	; (8011960 <hci_initializing_event_handler_command_completed+0xfc>)
 8011906:	4918      	ldr	r1, [pc, #96]	; (8011968 <hci_initializing_event_handler_command_completed+0x104>)
 8011908:	2001      	movs	r0, #1
 801190a:	f005 fd99 	bl	8017440 <hci_dump_log>
            log_debug("Command status for opcode %04x, expected %04x", opcode, hci_stack->last_cmd_opcode);
        }
    }
#if !defined(HAVE_PLATFORM_IPHONE_OS) && !defined (HAVE_HOST_CONTROLLER_API)
    // Vendor == CSR
    if ((hci_stack->substate == HCI_INIT_W4_CUSTOM_INIT) && (hci_event_packet_get_type(packet) == HCI_EVENT_VENDOR_SPECIFIC)){
 801190e:	4b13      	ldr	r3, [pc, #76]	; (801195c <hci_initializing_event_handler_command_completed+0xf8>)
 8011910:	681b      	ldr	r3, [r3, #0]
 8011912:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 8011916:	2b09      	cmp	r3, #9
 8011918:	d107      	bne.n	801192a <hci_initializing_event_handler_command_completed+0xc6>
 801191a:	6878      	ldr	r0, [r7, #4]
 801191c:	f7fd fde8 	bl	800f4f0 <hci_event_packet_get_type>
 8011920:	4603      	mov	r3, r0
 8011922:	2bff      	cmp	r3, #255	; 0xff
 8011924:	d101      	bne.n	801192a <hci_initializing_event_handler_command_completed+0xc6>
        // TODO: track actual command
        command_completed = true;
 8011926:	2301      	movs	r3, #1
 8011928:	73fb      	strb	r3, [r7, #15]
    }

    // Vendor == Toshiba
    if ((hci_stack->substate == HCI_INIT_W4_SEND_BAUD_CHANGE) && (hci_event_packet_get_type(packet) == HCI_EVENT_VENDOR_SPECIFIC)){
 801192a:	4b0c      	ldr	r3, [pc, #48]	; (801195c <hci_initializing_event_handler_command_completed+0xf8>)
 801192c:	681b      	ldr	r3, [r3, #0]
 801192e:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 8011932:	2b07      	cmp	r3, #7
 8011934:	d10c      	bne.n	8011950 <hci_initializing_event_handler_command_completed+0xec>
 8011936:	6878      	ldr	r0, [r7, #4]
 8011938:	f7fd fdda 	bl	800f4f0 <hci_event_packet_get_type>
 801193c:	4603      	mov	r3, r0
 801193e:	2bff      	cmp	r3, #255	; 0xff
 8011940:	d106      	bne.n	8011950 <hci_initializing_event_handler_command_completed+0xec>
        // TODO: track actual command
        command_completed = true;
 8011942:	2301      	movs	r3, #1
 8011944:	73fb      	strb	r3, [r7, #15]
        // Fix: no HCI Command Complete received, so num_cmd_packets not reset
        hci_stack->num_cmd_packets = 1;
 8011946:	4b05      	ldr	r3, [pc, #20]	; (801195c <hci_initializing_event_handler_command_completed+0xf8>)
 8011948:	681b      	ldr	r3, [r3, #0]
 801194a:	2201      	movs	r2, #1
 801194c:	f883 26fb 	strb.w	r2, [r3, #1787]	; 0x6fb
    }
#endif

    return command_completed;
 8011950:	7bfb      	ldrb	r3, [r7, #15]
}
 8011952:	4618      	mov	r0, r3
 8011954:	3710      	adds	r7, #16
 8011956:	46bd      	mov	sp, r7
 8011958:	bd80      	pop	{r7, pc}
 801195a:	bf00      	nop
 801195c:	20009780 	.word	0x20009780
 8011960:	0802929c 	.word	0x0802929c
 8011964:	08029c4c 	.word	0x08029c4c
 8011968:	08029ca0 	.word	0x08029ca0

0801196c <hci_initializing_event_handler>:

static void hci_initializing_event_handler(const uint8_t * packet, uint16_t size){
 801196c:	b580      	push	{r7, lr}
 801196e:	b088      	sub	sp, #32
 8011970:	af02      	add	r7, sp, #8
 8011972:	6078      	str	r0, [r7, #4]
 8011974:	460b      	mov	r3, r1
 8011976:	807b      	strh	r3, [r7, #2]

    UNUSED(size);   // ok: less than 6 bytes are read from our buffer
    
    bool command_completed =  hci_initializing_event_handler_command_completed(packet);
 8011978:	6878      	ldr	r0, [r7, #4]
 801197a:	f7ff ff73 	bl	8011864 <hci_initializing_event_handler_command_completed>
 801197e:	4603      	mov	r3, r0
 8011980:	75fb      	strb	r3, [r7, #23]
    // HCI Read Local Version Information
    // Command Complete Reset - but we expected Command Complete Read Local Version Information
    // hang...
    //
    // Fix: Command Complete for HCI Reset in HCI_INIT_W4_SEND_READ_LOCAL_VERSION_INFORMATION trigger resend
    if (!command_completed
 8011982:	7dfb      	ldrb	r3, [r7, #23]
 8011984:	f083 0301 	eor.w	r3, r3, #1
 8011988:	b2db      	uxtb	r3, r3
 801198a:	2b00      	cmp	r3, #0
 801198c:	d01c      	beq.n	80119c8 <hci_initializing_event_handler+0x5c>
            && (hci_event_packet_get_type(packet) == HCI_EVENT_COMMAND_COMPLETE)
 801198e:	6878      	ldr	r0, [r7, #4]
 8011990:	f7fd fdae 	bl	800f4f0 <hci_event_packet_get_type>
 8011994:	4603      	mov	r3, r0
 8011996:	2b0e      	cmp	r3, #14
 8011998:	d116      	bne.n	80119c8 <hci_initializing_event_handler+0x5c>
            && (hci_stack->substate == HCI_INIT_W4_SEND_READ_LOCAL_VERSION_INFORMATION)){
 801199a:	4bbd      	ldr	r3, [pc, #756]	; (8011c90 <hci_initializing_event_handler+0x324>)
 801199c:	681b      	ldr	r3, [r3, #0]
 801199e:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 80119a2:	2b03      	cmp	r3, #3
 80119a4:	d110      	bne.n	80119c8 <hci_initializing_event_handler+0x5c>

        uint16_t opcode = little_endian_read_16(packet,3);
 80119a6:	2103      	movs	r1, #3
 80119a8:	6878      	ldr	r0, [r7, #4]
 80119aa:	f7fd fa1c 	bl	800ede6 <little_endian_read_16>
 80119ae:	4603      	mov	r3, r0
 80119b0:	82bb      	strh	r3, [r7, #20]
        if (opcode == hci_reset.opcode){
 80119b2:	4bb8      	ldr	r3, [pc, #736]	; (8011c94 <hci_initializing_event_handler+0x328>)
 80119b4:	881b      	ldrh	r3, [r3, #0]
 80119b6:	8aba      	ldrh	r2, [r7, #20]
 80119b8:	429a      	cmp	r2, r3
 80119ba:	d105      	bne.n	80119c8 <hci_initializing_event_handler+0x5c>
            hci_stack->substate = HCI_INIT_SEND_READ_LOCAL_VERSION_INFORMATION;
 80119bc:	4bb4      	ldr	r3, [pc, #720]	; (8011c90 <hci_initializing_event_handler+0x324>)
 80119be:	681b      	ldr	r3, [r3, #0]
 80119c0:	2202      	movs	r2, #2
 80119c2:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;
 80119c6:	e2af      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
        }
    }

    // CSR & H5
    // Fix: Command Complete for HCI Reset in HCI_INIT_W4_SEND_READ_LOCAL_VERSION_INFORMATION trigger resend
    if (!command_completed
 80119c8:	7dfb      	ldrb	r3, [r7, #23]
 80119ca:	f083 0301 	eor.w	r3, r3, #1
 80119ce:	b2db      	uxtb	r3, r3
 80119d0:	2b00      	cmp	r3, #0
 80119d2:	d01c      	beq.n	8011a0e <hci_initializing_event_handler+0xa2>
            && (hci_event_packet_get_type(packet) == HCI_EVENT_COMMAND_COMPLETE)
 80119d4:	6878      	ldr	r0, [r7, #4]
 80119d6:	f7fd fd8b 	bl	800f4f0 <hci_event_packet_get_type>
 80119da:	4603      	mov	r3, r0
 80119dc:	2b0e      	cmp	r3, #14
 80119de:	d116      	bne.n	8011a0e <hci_initializing_event_handler+0xa2>
            && (hci_stack->substate == HCI_INIT_W4_READ_LOCAL_SUPPORTED_COMMANDS)){
 80119e0:	4bab      	ldr	r3, [pc, #684]	; (8011c90 <hci_initializing_event_handler+0x324>)
 80119e2:	681b      	ldr	r3, [r3, #0]
 80119e4:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 80119e8:	2b0f      	cmp	r3, #15
 80119ea:	d110      	bne.n	8011a0e <hci_initializing_event_handler+0xa2>

        uint16_t opcode = little_endian_read_16(packet,3);
 80119ec:	2103      	movs	r1, #3
 80119ee:	6878      	ldr	r0, [r7, #4]
 80119f0:	f7fd f9f9 	bl	800ede6 <little_endian_read_16>
 80119f4:	4603      	mov	r3, r0
 80119f6:	827b      	strh	r3, [r7, #18]
        if (opcode == hci_reset.opcode){
 80119f8:	4ba6      	ldr	r3, [pc, #664]	; (8011c94 <hci_initializing_event_handler+0x328>)
 80119fa:	881b      	ldrh	r3, [r3, #0]
 80119fc:	8a7a      	ldrh	r2, [r7, #18]
 80119fe:	429a      	cmp	r2, r3
 8011a00:	d105      	bne.n	8011a0e <hci_initializing_event_handler+0xa2>
            hci_stack->substate = HCI_INIT_READ_LOCAL_SUPPORTED_COMMANDS;
 8011a02:	4ba3      	ldr	r3, [pc, #652]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011a04:	681b      	ldr	r3, [r3, #0]
 8011a06:	220e      	movs	r2, #14
 8011a08:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;
 8011a0c:	e28c      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
        }
    }

    // on CSR with BCSP/H5, the reset resend timeout leads to substate == HCI_INIT_SEND_RESET or HCI_INIT_SEND_RESET_CSR_WARM_BOOT
    // fix: Correct substate and behave as command below
    if (command_completed){
 8011a0e:	7dfb      	ldrb	r3, [r7, #23]
 8011a10:	2b00      	cmp	r3, #0
 8011a12:	d014      	beq.n	8011a3e <hci_initializing_event_handler+0xd2>
        switch (hci_stack->substate){
 8011a14:	4b9e      	ldr	r3, [pc, #632]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011a16:	681b      	ldr	r3, [r3, #0]
 8011a18:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 8011a1c:	2b00      	cmp	r3, #0
 8011a1e:	d002      	beq.n	8011a26 <hci_initializing_event_handler+0xba>
 8011a20:	2b0a      	cmp	r3, #10
 8011a22:	d006      	beq.n	8011a32 <hci_initializing_event_handler+0xc6>
                break;
            case HCI_INIT_SEND_RESET_CSR_WARM_BOOT:
                hci_stack->substate = HCI_INIT_W4_CUSTOM_INIT_CSR_WARM_BOOT;
                break;
            default:
                break;
 8011a24:	e00c      	b.n	8011a40 <hci_initializing_event_handler+0xd4>
                hci_stack->substate = HCI_INIT_W4_SEND_RESET;
 8011a26:	4b9a      	ldr	r3, [pc, #616]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011a28:	681b      	ldr	r3, [r3, #0]
 8011a2a:	2201      	movs	r2, #1
 8011a2c:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                break;
 8011a30:	e006      	b.n	8011a40 <hci_initializing_event_handler+0xd4>
                hci_stack->substate = HCI_INIT_W4_CUSTOM_INIT_CSR_WARM_BOOT;
 8011a32:	4b97      	ldr	r3, [pc, #604]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011a34:	681b      	ldr	r3, [r3, #0]
 8011a36:	220b      	movs	r2, #11
 8011a38:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                break;
 8011a3c:	e000      	b.n	8011a40 <hci_initializing_event_handler+0xd4>
        }
    }
 8011a3e:	bf00      	nop

#endif

    if (!command_completed) return;
 8011a40:	7dfb      	ldrb	r3, [r7, #23]
 8011a42:	f083 0301 	eor.w	r3, r3, #1
 8011a46:	b2db      	uxtb	r3, r3
 8011a48:	2b00      	cmp	r3, #0
 8011a4a:	f040 826c 	bne.w	8011f26 <hci_initializing_event_handler+0x5ba>

    bool need_baud_change = false;
 8011a4e:	2300      	movs	r3, #0
 8011a50:	747b      	strb	r3, [r7, #17]
    bool need_addr_change = false;
 8011a52:	2300      	movs	r3, #0
 8011a54:	743b      	strb	r3, [r7, #16]

#if !defined(HAVE_PLATFORM_IPHONE_OS) && !defined (HAVE_HOST_CONTROLLER_API)
    need_baud_change = hci_stack->config
 8011a56:	4b8e      	ldr	r3, [pc, #568]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011a58:	681b      	ldr	r3, [r3, #0]
 8011a5a:	685b      	ldr	r3, [r3, #4]
                        && hci_stack->chipset
                        && hci_stack->chipset->set_baudrate_command
                        && hci_stack->hci_transport->set_baudrate
                        && ((hci_transport_config_uart_t *)hci_stack->config)->baudrate_main;
 8011a5c:	2b00      	cmp	r3, #0
 8011a5e:	d018      	beq.n	8011a92 <hci_initializing_event_handler+0x126>
                        && hci_stack->chipset
 8011a60:	4b8b      	ldr	r3, [pc, #556]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011a62:	681b      	ldr	r3, [r3, #0]
 8011a64:	689b      	ldr	r3, [r3, #8]
 8011a66:	2b00      	cmp	r3, #0
 8011a68:	d013      	beq.n	8011a92 <hci_initializing_event_handler+0x126>
                        && hci_stack->chipset->set_baudrate_command
 8011a6a:	4b89      	ldr	r3, [pc, #548]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011a6c:	681b      	ldr	r3, [r3, #0]
 8011a6e:	689b      	ldr	r3, [r3, #8]
 8011a70:	68db      	ldr	r3, [r3, #12]
 8011a72:	2b00      	cmp	r3, #0
 8011a74:	d00d      	beq.n	8011a92 <hci_initializing_event_handler+0x126>
                        && hci_stack->hci_transport->set_baudrate
 8011a76:	4b86      	ldr	r3, [pc, #536]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011a78:	681b      	ldr	r3, [r3, #0]
 8011a7a:	681b      	ldr	r3, [r3, #0]
 8011a7c:	69db      	ldr	r3, [r3, #28]
 8011a7e:	2b00      	cmp	r3, #0
 8011a80:	d007      	beq.n	8011a92 <hci_initializing_event_handler+0x126>
                        && ((hci_transport_config_uart_t *)hci_stack->config)->baudrate_main;
 8011a82:	4b83      	ldr	r3, [pc, #524]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011a84:	681b      	ldr	r3, [r3, #0]
 8011a86:	685b      	ldr	r3, [r3, #4]
 8011a88:	689b      	ldr	r3, [r3, #8]
 8011a8a:	2b00      	cmp	r3, #0
 8011a8c:	d001      	beq.n	8011a92 <hci_initializing_event_handler+0x126>
 8011a8e:	2301      	movs	r3, #1
 8011a90:	e000      	b.n	8011a94 <hci_initializing_event_handler+0x128>
 8011a92:	2300      	movs	r3, #0
    need_baud_change = hci_stack->config
 8011a94:	747b      	strb	r3, [r7, #17]
 8011a96:	7c7b      	ldrb	r3, [r7, #17]
 8011a98:	f003 0301 	and.w	r3, r3, #1
 8011a9c:	747b      	strb	r3, [r7, #17]

    need_addr_change = hci_stack->custom_bd_addr_set
 8011a9e:	4b7c      	ldr	r3, [pc, #496]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011aa0:	681b      	ldr	r3, [r3, #0]
 8011aa2:	f893 37b8 	ldrb.w	r3, [r3, #1976]	; 0x7b8
                        && hci_stack->chipset
                        && hci_stack->chipset->set_bd_addr_command;
 8011aa6:	2b00      	cmp	r3, #0
 8011aa8:	d00c      	beq.n	8011ac4 <hci_initializing_event_handler+0x158>
                        && hci_stack->chipset
 8011aaa:	4b79      	ldr	r3, [pc, #484]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011aac:	681b      	ldr	r3, [r3, #0]
 8011aae:	689b      	ldr	r3, [r3, #8]
 8011ab0:	2b00      	cmp	r3, #0
 8011ab2:	d007      	beq.n	8011ac4 <hci_initializing_event_handler+0x158>
                        && hci_stack->chipset->set_bd_addr_command;
 8011ab4:	4b76      	ldr	r3, [pc, #472]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011ab6:	681b      	ldr	r3, [r3, #0]
 8011ab8:	689b      	ldr	r3, [r3, #8]
 8011aba:	691b      	ldr	r3, [r3, #16]
 8011abc:	2b00      	cmp	r3, #0
 8011abe:	d001      	beq.n	8011ac4 <hci_initializing_event_handler+0x158>
 8011ac0:	2301      	movs	r3, #1
 8011ac2:	e000      	b.n	8011ac6 <hci_initializing_event_handler+0x15a>
 8011ac4:	2300      	movs	r3, #0
    need_addr_change = hci_stack->custom_bd_addr_set
 8011ac6:	743b      	strb	r3, [r7, #16]
 8011ac8:	7c3b      	ldrb	r3, [r7, #16]
 8011aca:	f003 0301 	and.w	r3, r3, #1
 8011ace:	743b      	strb	r3, [r7, #16]
#endif

    switch(hci_stack->substate){
 8011ad0:	4b6f      	ldr	r3, [pc, #444]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011ad2:	681b      	ldr	r3, [r3, #0]
 8011ad4:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 8011ad8:	2b43      	cmp	r3, #67	; 0x43
 8011ada:	f200 8212 	bhi.w	8011f02 <hci_initializing_event_handler+0x596>
 8011ade:	a201      	add	r2, pc, #4	; (adr r2, 8011ae4 <hci_initializing_event_handler+0x178>)
 8011ae0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011ae4:	08011bf5 	.word	0x08011bf5
 8011ae8:	08011c0f 	.word	0x08011c0f
 8011aec:	08011f03 	.word	0x08011f03
 8011af0:	08011f03 	.word	0x08011f03
 8011af4:	08011f03 	.word	0x08011f03
 8011af8:	08011c1f 	.word	0x08011c1f
 8011afc:	08011f03 	.word	0x08011f03
 8011b00:	08011c4f 	.word	0x08011c4f
 8011b04:	08011f03 	.word	0x08011f03
 8011b08:	08011cbf 	.word	0x08011cbf
 8011b0c:	08011f03 	.word	0x08011f03
 8011b10:	08011ca5 	.word	0x08011ca5
 8011b14:	08011f03 	.word	0x08011f03
 8011b18:	08011f03 	.word	0x08011f03
 8011b1c:	08011f03 	.word	0x08011f03
 8011b20:	08011ccb 	.word	0x08011ccb
 8011b24:	08011f03 	.word	0x08011f03
 8011b28:	08011d1f 	.word	0x08011d1f
 8011b2c:	08011f03 	.word	0x08011f03
 8011b30:	08011d67 	.word	0x08011d67
 8011b34:	08011f03 	.word	0x08011f03
 8011b38:	08011d97 	.word	0x08011d97
 8011b3c:	08011f03 	.word	0x08011f03
 8011b40:	08011da3 	.word	0x08011da3
 8011b44:	08011f03 	.word	0x08011f03
 8011b48:	08011f03 	.word	0x08011f03
 8011b4c:	08011f03 	.word	0x08011f03
 8011b50:	08011f03 	.word	0x08011f03
 8011b54:	08011f03 	.word	0x08011f03
 8011b58:	08011dcb 	.word	0x08011dcb
 8011b5c:	08011f03 	.word	0x08011f03
 8011b60:	08011f03 	.word	0x08011f03
 8011b64:	08011f03 	.word	0x08011f03
 8011b68:	08011f03 	.word	0x08011f03
 8011b6c:	08011f03 	.word	0x08011f03
 8011b70:	08011f03 	.word	0x08011f03
 8011b74:	08011f03 	.word	0x08011f03
 8011b78:	08011f03 	.word	0x08011f03
 8011b7c:	08011f03 	.word	0x08011f03
 8011b80:	08011f03 	.word	0x08011f03
 8011b84:	08011f03 	.word	0x08011f03
 8011b88:	08011f03 	.word	0x08011f03
 8011b8c:	08011f03 	.word	0x08011f03
 8011b90:	08011e75 	.word	0x08011e75
 8011b94:	08011f03 	.word	0x08011f03
 8011b98:	08011f03 	.word	0x08011f03
 8011b9c:	08011f03 	.word	0x08011f03
 8011ba0:	08011ea3 	.word	0x08011ea3
 8011ba4:	08011f03 	.word	0x08011f03
 8011ba8:	08011ebd 	.word	0x08011ebd
 8011bac:	08011f03 	.word	0x08011f03
 8011bb0:	08011ed7 	.word	0x08011ed7
 8011bb4:	08011f03 	.word	0x08011f03
 8011bb8:	08011eed 	.word	0x08011eed
 8011bbc:	08011f03 	.word	0x08011f03
 8011bc0:	08011e15 	.word	0x08011e15
 8011bc4:	08011f03 	.word	0x08011f03
 8011bc8:	08011e31 	.word	0x08011e31
 8011bcc:	08011f03 	.word	0x08011f03
 8011bd0:	08011f03 	.word	0x08011f03
 8011bd4:	08011f03 	.word	0x08011f03
 8011bd8:	08011f03 	.word	0x08011f03
 8011bdc:	08011f03 	.word	0x08011f03
 8011be0:	08011f03 	.word	0x08011f03
 8011be4:	08011f03 	.word	0x08011f03
 8011be8:	08011f03 	.word	0x08011f03
 8011bec:	08011f03 	.word	0x08011f03
 8011bf0:	08011efd 	.word	0x08011efd

#if !defined(HAVE_PLATFORM_IPHONE_OS) && !defined (HAVE_HOST_CONTROLLER_API)
        case HCI_INIT_SEND_RESET:
            // on CSR with BCSP/H5, resend triggers resend of HCI Reset and leads to substate == HCI_INIT_SEND_RESET
            // fix: just correct substate and behave as command below
            hci_stack->substate = HCI_INIT_W4_SEND_RESET;
 8011bf4:	4b26      	ldr	r3, [pc, #152]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011bf6:	681b      	ldr	r3, [r3, #0]
 8011bf8:	2201      	movs	r2, #1
 8011bfa:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            btstack_run_loop_remove_timer(&hci_stack->timeout);
 8011bfe:	4b24      	ldr	r3, [pc, #144]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011c00:	681b      	ldr	r3, [r3, #0]
 8011c02:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8011c06:	4618      	mov	r0, r3
 8011c08:	f7fd f860 	bl	800eccc <btstack_run_loop_remove_timer>
            break;
 8011c0c:	e188      	b.n	8011f20 <hci_initializing_event_handler+0x5b4>
        case HCI_INIT_W4_SEND_RESET:
            btstack_run_loop_remove_timer(&hci_stack->timeout);
 8011c0e:	4b20      	ldr	r3, [pc, #128]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011c10:	681b      	ldr	r3, [r3, #0]
 8011c12:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8011c16:	4618      	mov	r0, r3
 8011c18:	f7fd f858 	bl	800eccc <btstack_run_loop_remove_timer>
            break;
 8011c1c:	e180      	b.n	8011f20 <hci_initializing_event_handler+0x5b4>
        case HCI_INIT_W4_SEND_READ_LOCAL_NAME:
            log_info("Received local name, need baud change %d", (int) need_baud_change);
 8011c1e:	7c7b      	ldrb	r3, [r7, #17]
 8011c20:	9300      	str	r3, [sp, #0]
 8011c22:	f240 63a6 	movw	r3, #1702	; 0x6a6
 8011c26:	4a1c      	ldr	r2, [pc, #112]	; (8011c98 <hci_initializing_event_handler+0x32c>)
 8011c28:	491c      	ldr	r1, [pc, #112]	; (8011c9c <hci_initializing_event_handler+0x330>)
 8011c2a:	2001      	movs	r0, #1
 8011c2c:	f005 fc08 	bl	8017440 <hci_dump_log>
            if (need_baud_change){
 8011c30:	7c7b      	ldrb	r3, [r7, #17]
 8011c32:	2b00      	cmp	r3, #0
 8011c34:	d005      	beq.n	8011c42 <hci_initializing_event_handler+0x2d6>
                hci_stack->substate = HCI_INIT_SEND_BAUD_CHANGE;
 8011c36:	4b16      	ldr	r3, [pc, #88]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011c38:	681b      	ldr	r3, [r3, #0]
 8011c3a:	2206      	movs	r2, #6
 8011c3c:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                return;
 8011c40:	e172      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
            }
            // skip baud change
            hci_stack->substate = HCI_INIT_CUSTOM_INIT;
 8011c42:	4b13      	ldr	r3, [pc, #76]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011c44:	681b      	ldr	r3, [r3, #0]
 8011c46:	2208      	movs	r2, #8
 8011c48:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;
 8011c4c:	e16c      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
        case HCI_INIT_W4_SEND_BAUD_CHANGE:
            // for STLC2500D, baud rate change already happened.
            // for others, baud rate gets changed now
            if ((hci_stack->manufacturer != BLUETOOTH_COMPANY_ID_ST_MICROELECTRONICS) && need_baud_change){
 8011c4e:	4b10      	ldr	r3, [pc, #64]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011c50:	681b      	ldr	r3, [r3, #0]
 8011c52:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 8011c56:	2b30      	cmp	r3, #48	; 0x30
 8011c58:	d014      	beq.n	8011c84 <hci_initializing_event_handler+0x318>
 8011c5a:	7c7b      	ldrb	r3, [r7, #17]
 8011c5c:	2b00      	cmp	r3, #0
 8011c5e:	d011      	beq.n	8011c84 <hci_initializing_event_handler+0x318>
                uint32_t baud_rate = hci_transport_uart_get_main_baud_rate();
 8011c60:	f7fe ff58 	bl	8010b14 <hci_transport_uart_get_main_baud_rate>
 8011c64:	60b8      	str	r0, [r7, #8]
                log_info("Local baud rate change to %" PRIu32 "(w4_send_baud_change)", baud_rate);
 8011c66:	68bb      	ldr	r3, [r7, #8]
 8011c68:	9300      	str	r3, [sp, #0]
 8011c6a:	f240 63b3 	movw	r3, #1715	; 0x6b3
 8011c6e:	4a0a      	ldr	r2, [pc, #40]	; (8011c98 <hci_initializing_event_handler+0x32c>)
 8011c70:	490b      	ldr	r1, [pc, #44]	; (8011ca0 <hci_initializing_event_handler+0x334>)
 8011c72:	2001      	movs	r0, #1
 8011c74:	f005 fbe4 	bl	8017440 <hci_dump_log>
                hci_stack->hci_transport->set_baudrate(baud_rate);
 8011c78:	4b05      	ldr	r3, [pc, #20]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011c7a:	681b      	ldr	r3, [r3, #0]
 8011c7c:	681b      	ldr	r3, [r3, #0]
 8011c7e:	69db      	ldr	r3, [r3, #28]
 8011c80:	68b8      	ldr	r0, [r7, #8]
 8011c82:	4798      	blx	r3
            }
            hci_stack->substate = HCI_INIT_CUSTOM_INIT;
 8011c84:	4b02      	ldr	r3, [pc, #8]	; (8011c90 <hci_initializing_event_handler+0x324>)
 8011c86:	681b      	ldr	r3, [r3, #0]
 8011c88:	2208      	movs	r2, #8
 8011c8a:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;
 8011c8e:	e14b      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
 8011c90:	20009780 	.word	0x20009780
 8011c94:	08030ad0 	.word	0x08030ad0
 8011c98:	0802929c 	.word	0x0802929c
 8011c9c:	08029cf0 	.word	0x08029cf0
 8011ca0:	08029d20 	.word	0x08029d20
        case HCI_INIT_W4_CUSTOM_INIT_CSR_WARM_BOOT:
            btstack_run_loop_remove_timer(&hci_stack->timeout);
 8011ca4:	4ba2      	ldr	r3, [pc, #648]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011ca6:	681b      	ldr	r3, [r3, #0]
 8011ca8:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8011cac:	4618      	mov	r0, r3
 8011cae:	f7fd f80d 	bl	800eccc <btstack_run_loop_remove_timer>
            hci_stack->substate = HCI_INIT_CUSTOM_INIT;
 8011cb2:	4b9f      	ldr	r3, [pc, #636]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011cb4:	681b      	ldr	r3, [r3, #0]
 8011cb6:	2208      	movs	r2, #8
 8011cb8:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;
 8011cbc:	e134      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
        case HCI_INIT_W4_CUSTOM_INIT:
            // repeat custom init
            hci_stack->substate = HCI_INIT_CUSTOM_INIT;
 8011cbe:	4b9c      	ldr	r3, [pc, #624]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011cc0:	681b      	ldr	r3, [r3, #0]
 8011cc2:	2208      	movs	r2, #8
 8011cc4:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;
 8011cc8:	e12e      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
            hci_stack->substate = HCI_INIT_READ_LOCAL_SUPPORTED_COMMANDS;
            return ;
#endif

        case HCI_INIT_W4_READ_LOCAL_SUPPORTED_COMMANDS:
            if (need_baud_change && (hci_stack->chipset_result != BTSTACK_CHIPSET_NO_INIT_SCRIPT) &&
 8011cca:	7c7b      	ldrb	r3, [r7, #17]
 8011ccc:	2b00      	cmp	r3, #0
 8011cce:	d017      	beq.n	8011d00 <hci_initializing_event_handler+0x394>
 8011cd0:	4b97      	ldr	r3, [pc, #604]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011cd2:	681b      	ldr	r3, [r3, #0]
 8011cd4:	f893 3728 	ldrb.w	r3, [r3, #1832]	; 0x728
 8011cd8:	2b03      	cmp	r3, #3
 8011cda:	d011      	beq.n	8011d00 <hci_initializing_event_handler+0x394>
              ((hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_BROADCOM_CORPORATION) || 
 8011cdc:	4b94      	ldr	r3, [pc, #592]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011cde:	681b      	ldr	r3, [r3, #0]
 8011ce0:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
            if (need_baud_change && (hci_stack->chipset_result != BTSTACK_CHIPSET_NO_INIT_SCRIPT) &&
 8011ce4:	2b0f      	cmp	r3, #15
 8011ce6:	d005      	beq.n	8011cf4 <hci_initializing_event_handler+0x388>
               (hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_EM_MICROELECTRONIC_MARIN_SA))) {
 8011ce8:	4b91      	ldr	r3, [pc, #580]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011cea:	681b      	ldr	r3, [r3, #0]
 8011cec:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
              ((hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_BROADCOM_CORPORATION) || 
 8011cf0:	2b5a      	cmp	r3, #90	; 0x5a
 8011cf2:	d105      	bne.n	8011d00 <hci_initializing_event_handler+0x394>
                hci_stack->substate = HCI_INIT_SEND_BAUD_CHANGE_BCM;
 8011cf4:	4b8e      	ldr	r3, [pc, #568]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011cf6:	681b      	ldr	r3, [r3, #0]
 8011cf8:	2210      	movs	r2, #16
 8011cfa:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                return;
 8011cfe:	e113      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
            }
            if (need_addr_change){
 8011d00:	7c3b      	ldrb	r3, [r7, #16]
 8011d02:	2b00      	cmp	r3, #0
 8011d04:	d005      	beq.n	8011d12 <hci_initializing_event_handler+0x3a6>
                hci_stack->substate = HCI_INIT_SET_BD_ADDR;
 8011d06:	4b8a      	ldr	r3, [pc, #552]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011d08:	681b      	ldr	r3, [r3, #0]
 8011d0a:	2212      	movs	r2, #18
 8011d0c:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                return;
 8011d10:	e10a      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
            }
            hci_stack->substate = HCI_INIT_READ_BD_ADDR;
 8011d12:	4b87      	ldr	r3, [pc, #540]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011d14:	681b      	ldr	r3, [r3, #0]
 8011d16:	2216      	movs	r2, #22
 8011d18:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;
 8011d1c:	e104      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
#if !defined(HAVE_PLATFORM_IPHONE_OS) && !defined (HAVE_HOST_CONTROLLER_API)
        case HCI_INIT_W4_SEND_BAUD_CHANGE_BCM:
            if (need_baud_change){
 8011d1e:	7c7b      	ldrb	r3, [r7, #17]
 8011d20:	2b00      	cmp	r3, #0
 8011d22:	d011      	beq.n	8011d48 <hci_initializing_event_handler+0x3dc>
                uint32_t baud_rate = hci_transport_uart_get_main_baud_rate();
 8011d24:	f7fe fef6 	bl	8010b14 <hci_transport_uart_get_main_baud_rate>
 8011d28:	60f8      	str	r0, [r7, #12]
                log_info("Local baud rate change to %" PRIu32 "(w4_send_baud_change_bcm))", baud_rate);
 8011d2a:	68fb      	ldr	r3, [r7, #12]
 8011d2c:	9300      	str	r3, [sp, #0]
 8011d2e:	f240 63d7 	movw	r3, #1751	; 0x6d7
 8011d32:	4a80      	ldr	r2, [pc, #512]	; (8011f34 <hci_initializing_event_handler+0x5c8>)
 8011d34:	4980      	ldr	r1, [pc, #512]	; (8011f38 <hci_initializing_event_handler+0x5cc>)
 8011d36:	2001      	movs	r0, #1
 8011d38:	f005 fb82 	bl	8017440 <hci_dump_log>
                hci_stack->hci_transport->set_baudrate(baud_rate);
 8011d3c:	4b7c      	ldr	r3, [pc, #496]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011d3e:	681b      	ldr	r3, [r3, #0]
 8011d40:	681b      	ldr	r3, [r3, #0]
 8011d42:	69db      	ldr	r3, [r3, #28]
 8011d44:	68f8      	ldr	r0, [r7, #12]
 8011d46:	4798      	blx	r3
            }
            if (need_addr_change){
 8011d48:	7c3b      	ldrb	r3, [r7, #16]
 8011d4a:	2b00      	cmp	r3, #0
 8011d4c:	d005      	beq.n	8011d5a <hci_initializing_event_handler+0x3ee>
                hci_stack->substate = HCI_INIT_SET_BD_ADDR;
 8011d4e:	4b78      	ldr	r3, [pc, #480]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011d50:	681b      	ldr	r3, [r3, #0]
 8011d52:	2212      	movs	r2, #18
 8011d54:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                return;
 8011d58:	e0e6      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
            }
            hci_stack->substate = HCI_INIT_READ_BD_ADDR;
 8011d5a:	4b75      	ldr	r3, [pc, #468]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011d5c:	681b      	ldr	r3, [r3, #0]
 8011d5e:	2216      	movs	r2, #22
 8011d60:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;            
 8011d64:	e0e0      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
        case HCI_INIT_W4_SET_BD_ADDR:
            // for STLC2500D + ATWILC3000, bd addr change only gets active after sending reset command
            if ((hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_ST_MICROELECTRONICS)
 8011d66:	4b72      	ldr	r3, [pc, #456]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011d68:	681b      	ldr	r3, [r3, #0]
 8011d6a:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 8011d6e:	2b30      	cmp	r3, #48	; 0x30
 8011d70:	d005      	beq.n	8011d7e <hci_initializing_event_handler+0x412>
            ||  (hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_ATMEL_CORPORATION)){
 8011d72:	4b6f      	ldr	r3, [pc, #444]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011d74:	681b      	ldr	r3, [r3, #0]
 8011d76:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 8011d7a:	2b13      	cmp	r3, #19
 8011d7c:	d105      	bne.n	8011d8a <hci_initializing_event_handler+0x41e>
                hci_stack->substate = HCI_INIT_SEND_RESET_ST_WARM_BOOT;
 8011d7e:	4b6c      	ldr	r3, [pc, #432]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011d80:	681b      	ldr	r3, [r3, #0]
 8011d82:	2214      	movs	r2, #20
 8011d84:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                return;
 8011d88:	e0ce      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
            }
            // skipping st warm boot
            hci_stack->substate = HCI_INIT_READ_BD_ADDR;
 8011d8a:	4b69      	ldr	r3, [pc, #420]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011d8c:	681b      	ldr	r3, [r3, #0]
 8011d8e:	2216      	movs	r2, #22
 8011d90:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;
 8011d94:	e0c8      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
        case HCI_INIT_W4_SEND_RESET_ST_WARM_BOOT:
            hci_stack->substate = HCI_INIT_READ_BD_ADDR;
 8011d96:	4b66      	ldr	r3, [pc, #408]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011d98:	681b      	ldr	r3, [r3, #0]
 8011d9a:	2216      	movs	r2, #22
 8011d9c:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;
 8011da0:	e0c2      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
#endif
        case HCI_INIT_W4_READ_BD_ADDR:
            // only read buffer size if supported
            if (hci_stack->local_supported_commands[0u] & 0x01u) {
 8011da2:	4b63      	ldr	r3, [pc, #396]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011da4:	681b      	ldr	r3, [r3, #0]
 8011da6:	f893 3710 	ldrb.w	r3, [r3, #1808]	; 0x710
 8011daa:	f003 0301 	and.w	r3, r3, #1
 8011dae:	2b00      	cmp	r3, #0
 8011db0:	d005      	beq.n	8011dbe <hci_initializing_event_handler+0x452>
                hci_stack->substate = HCI_INIT_READ_BUFFER_SIZE;
 8011db2:	4b5f      	ldr	r3, [pc, #380]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011db4:	681b      	ldr	r3, [r3, #0]
 8011db6:	2218      	movs	r2, #24
 8011db8:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                return;
 8011dbc:	e0b4      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
            }
            // skipping read buffer size
            hci_stack->substate = HCI_INIT_READ_LOCAL_SUPPORTED_FEATURES;
 8011dbe:	4b5c      	ldr	r3, [pc, #368]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011dc0:	681b      	ldr	r3, [r3, #0]
 8011dc2:	221a      	movs	r2, #26
 8011dc4:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;
 8011dc8:	e0ae      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
        case HCI_INIT_W4_SET_EVENT_MASK:
            // skip Classic init commands for LE only chipsets
            if (!hci_classic_supported()){
 8011dca:	f7fe fd37 	bl	801083c <hci_classic_supported>
 8011dce:	4603      	mov	r3, r0
 8011dd0:	2b00      	cmp	r3, #0
 8011dd2:	d114      	bne.n	8011dfe <hci_initializing_event_handler+0x492>
#ifdef ENABLE_BLE
                if (hci_le_supported()){
 8011dd4:	f7fe fd46 	bl	8010864 <hci_le_supported>
 8011dd8:	4603      	mov	r3, r0
 8011dda:	2b00      	cmp	r3, #0
 8011ddc:	d005      	beq.n	8011dea <hci_initializing_event_handler+0x47e>
                    hci_stack->substate = HCI_INIT_LE_READ_BUFFER_SIZE; // skip all classic command
 8011dde:	4b54      	ldr	r3, [pc, #336]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011de0:	681b      	ldr	r3, [r3, #0]
 8011de2:	2236      	movs	r2, #54	; 0x36
 8011de4:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                    return;
 8011de8:	e09e      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
                }
#endif
                log_error("Neither BR/EDR nor LE supported");
 8011dea:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 8011dee:	4a51      	ldr	r2, [pc, #324]	; (8011f34 <hci_initializing_event_handler+0x5c8>)
 8011df0:	4952      	ldr	r1, [pc, #328]	; (8011f3c <hci_initializing_event_handler+0x5d0>)
 8011df2:	2002      	movs	r0, #2
 8011df4:	f005 fb24 	bl	8017440 <hci_dump_log>
                hci_init_done();
 8011df8:	f7ff fd1a 	bl	8011830 <hci_init_done>
                return;
 8011dfc:	e094      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
            }
            if (!gap_ssp_supported()){
 8011dfe:	f7fe fd09 	bl	8010814 <gap_ssp_supported>
 8011e02:	4603      	mov	r3, r0
 8011e04:	2b00      	cmp	r3, #0
 8011e06:	d17e      	bne.n	8011f06 <hci_initializing_event_handler+0x59a>
                hci_stack->substate = HCI_INIT_WRITE_PAGE_TIMEOUT;
 8011e08:	4b49      	ldr	r3, [pc, #292]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011e0a:	681b      	ldr	r3, [r3, #0]
 8011e0c:	2220      	movs	r2, #32
 8011e0e:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                return;
 8011e12:	e089      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
            }
            break;
#ifdef ENABLE_BLE            
        case HCI_INIT_W4_LE_READ_BUFFER_SIZE:
            // skip write le host if not supported (e.g. on LE only EM9301)
            if (hci_stack->local_supported_commands[0u] & 0x02u) break;
 8011e14:	4b46      	ldr	r3, [pc, #280]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011e16:	681b      	ldr	r3, [r3, #0]
 8011e18:	f893 3710 	ldrb.w	r3, [r3, #1808]	; 0x710
 8011e1c:	f003 0302 	and.w	r3, r3, #2
 8011e20:	2b00      	cmp	r3, #0
 8011e22:	d172      	bne.n	8011f0a <hci_initializing_event_handler+0x59e>
            hci_stack->substate = HCI_INIT_LE_SET_EVENT_MASK;
 8011e24:	4b42      	ldr	r3, [pc, #264]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011e26:	681b      	ldr	r3, [r3, #0]
 8011e28:	223a      	movs	r2, #58	; 0x3a
 8011e2a:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            return;
 8011e2e:	e07b      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>

#ifdef ENABLE_LE_DATA_LENGTH_EXTENSION
        case HCI_INIT_W4_WRITE_LE_HOST_SUPPORTED:
            log_info("Supported commands %x", hci_stack->local_supported_commands[0] & 0x30);
 8011e30:	4b3f      	ldr	r3, [pc, #252]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011e32:	681b      	ldr	r3, [r3, #0]
 8011e34:	f893 3710 	ldrb.w	r3, [r3, #1808]	; 0x710
 8011e38:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8011e3c:	9300      	str	r3, [sp, #0]
 8011e3e:	f240 7312 	movw	r3, #1810	; 0x712
 8011e42:	4a3c      	ldr	r2, [pc, #240]	; (8011f34 <hci_initializing_event_handler+0x5c8>)
 8011e44:	493e      	ldr	r1, [pc, #248]	; (8011f40 <hci_initializing_event_handler+0x5d4>)
 8011e46:	2001      	movs	r0, #1
 8011e48:	f005 fafa 	bl	8017440 <hci_dump_log>
            if ((hci_stack->local_supported_commands[0u] & 0x30u) == 0x30u){
 8011e4c:	4b38      	ldr	r3, [pc, #224]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011e4e:	681b      	ldr	r3, [r3, #0]
 8011e50:	f893 3710 	ldrb.w	r3, [r3, #1808]	; 0x710
 8011e54:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8011e58:	2b30      	cmp	r3, #48	; 0x30
 8011e5a:	d105      	bne.n	8011e68 <hci_initializing_event_handler+0x4fc>
                hci_stack->substate = HCI_INIT_LE_SET_EVENT_MASK;
 8011e5c:	4b34      	ldr	r3, [pc, #208]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011e5e:	681b      	ldr	r3, [r3, #0]
 8011e60:	223a      	movs	r2, #58	; 0x3a
 8011e62:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                return;
 8011e66:	e05f      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
            }
            // explicit fall through to reduce repetitions

#ifdef ENABLE_LE_CENTRAL
            hci_stack->substate = HCI_INIT_READ_WHITE_LIST_SIZE;
 8011e68:	4b31      	ldr	r3, [pc, #196]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011e6a:	681b      	ldr	r3, [r3, #0]
 8011e6c:	2240      	movs	r2, #64	; 0x40
 8011e6e:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
#else
            hci_init_done();
#endif
            return;
 8011e72:	e059      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>

#endif  /* ENABLE_BLE */

        case HCI_INIT_W4_WRITE_INQUIRY_MODE:
            // skip write secure connections host support if not supported or disabled
            if (!hci_stack->secure_connections_enable || (hci_stack->local_supported_commands[1u] & 0x02u) == 0u) {
 8011e74:	4b2e      	ldr	r3, [pc, #184]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011e76:	681b      	ldr	r3, [r3, #0]
 8011e78:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8011e7c:	f083 0301 	eor.w	r3, r3, #1
 8011e80:	b2db      	uxtb	r3, r3
 8011e82:	2b00      	cmp	r3, #0
 8011e84:	d107      	bne.n	8011e96 <hci_initializing_event_handler+0x52a>
 8011e86:	4b2a      	ldr	r3, [pc, #168]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011e88:	681b      	ldr	r3, [r3, #0]
 8011e8a:	f893 3711 	ldrb.w	r3, [r3, #1809]	; 0x711
 8011e8e:	f003 0302 	and.w	r3, r3, #2
 8011e92:	2b00      	cmp	r3, #0
 8011e94:	d13b      	bne.n	8011f0e <hci_initializing_event_handler+0x5a2>
                hci_stack->substate = HCI_INIT_WRITE_SCAN_ENABLE;
 8011e96:	4b26      	ldr	r3, [pc, #152]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011e98:	681b      	ldr	r3, [r3, #0]
 8011e9a:	222e      	movs	r2, #46	; 0x2e
 8011e9c:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                return;
 8011ea0:	e042      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
            break;

#ifdef ENABLE_SCO_OVER_HCI
        case HCI_INIT_W4_WRITE_SCAN_ENABLE:
            // skip write synchronous flow control if not supported
            if (hci_stack->local_supported_commands[0] & 0x04) break;
 8011ea2:	4b23      	ldr	r3, [pc, #140]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011ea4:	681b      	ldr	r3, [r3, #0]
 8011ea6:	f893 3710 	ldrb.w	r3, [r3, #1808]	; 0x710
 8011eaa:	f003 0304 	and.w	r3, r3, #4
 8011eae:	2b00      	cmp	r3, #0
 8011eb0:	d12f      	bne.n	8011f12 <hci_initializing_event_handler+0x5a6>
            hci_stack->substate = HCI_INIT_W4_WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE;
 8011eb2:	4b1f      	ldr	r3, [pc, #124]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011eb4:	681b      	ldr	r3, [r3, #0]
 8011eb6:	2231      	movs	r2, #49	; 0x31
 8011eb8:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717

            /* fall through */

        case HCI_INIT_W4_WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE:
            // skip write default erroneous data reporting if not supported
            if (hci_stack->local_supported_commands[0] & 0x08) break;
 8011ebc:	4b1c      	ldr	r3, [pc, #112]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011ebe:	681b      	ldr	r3, [r3, #0]
 8011ec0:	f893 3710 	ldrb.w	r3, [r3, #1808]	; 0x710
 8011ec4:	f003 0308 	and.w	r3, r3, #8
 8011ec8:	2b00      	cmp	r3, #0
 8011eca:	d124      	bne.n	8011f16 <hci_initializing_event_handler+0x5aa>
            hci_stack->substate = HCI_INIT_W4_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING;
 8011ecc:	4b18      	ldr	r3, [pc, #96]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011ece:	681b      	ldr	r3, [r3, #0]
 8011ed0:	2233      	movs	r2, #51	; 0x33
 8011ed2:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717

            /* fall through */

        case HCI_INIT_W4_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING:
            // skip bcm set sco pcm config on non-Broadcom chipsets
            if (hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_BROADCOM_CORPORATION) break;
 8011ed6:	4b16      	ldr	r3, [pc, #88]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011ed8:	681b      	ldr	r3, [r3, #0]
 8011eda:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 8011ede:	2b0f      	cmp	r3, #15
 8011ee0:	d01b      	beq.n	8011f1a <hci_initializing_event_handler+0x5ae>
            hci_stack->substate = HCI_INIT_W4_BCM_WRITE_SCO_PCM_INT;
 8011ee2:	4b13      	ldr	r3, [pc, #76]	; (8011f30 <hci_initializing_event_handler+0x5c4>)
 8011ee4:	681b      	ldr	r3, [r3, #0]
 8011ee6:	2235      	movs	r2, #53	; 0x35
 8011ee8:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717

            /* fall through */

        case HCI_INIT_W4_BCM_WRITE_SCO_PCM_INT:
            if (!hci_le_supported()){
 8011eec:	f7fe fcba 	bl	8010864 <hci_le_supported>
 8011ef0:	4603      	mov	r3, r0
 8011ef2:	2b00      	cmp	r3, #0
 8011ef4:	d113      	bne.n	8011f1e <hci_initializing_event_handler+0x5b2>
                // SKIP LE init for Classic only configuration
                hci_init_done();
 8011ef6:	f7ff fc9b 	bl	8011830 <hci_init_done>
                return;
 8011efa:	e015      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>

// avoid compile error due to duplicate cases: HCI_INIT_W4_BCM_WRITE_SCO_PCM_INT == HCI_INIT_DONE-1
#if defined(ENABLE_BLE) || defined(ENABLE_LE_DATA_LENGTH_EXTENSION) || defined(ENABLE_LE_CENTRAL)
        // Response to command before init done state -> init done
        case (HCI_INIT_DONE-1):
            hci_init_done();
 8011efc:	f7ff fc98 	bl	8011830 <hci_init_done>
            return;
 8011f00:	e012      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
#endif
            
        default:
            break;
 8011f02:	bf00      	nop
 8011f04:	e00c      	b.n	8011f20 <hci_initializing_event_handler+0x5b4>
            break;
 8011f06:	bf00      	nop
 8011f08:	e00a      	b.n	8011f20 <hci_initializing_event_handler+0x5b4>
            if (hci_stack->local_supported_commands[0u] & 0x02u) break;
 8011f0a:	bf00      	nop
 8011f0c:	e008      	b.n	8011f20 <hci_initializing_event_handler+0x5b4>
            break;
 8011f0e:	bf00      	nop
 8011f10:	e006      	b.n	8011f20 <hci_initializing_event_handler+0x5b4>
            if (hci_stack->local_supported_commands[0] & 0x04) break;
 8011f12:	bf00      	nop
 8011f14:	e004      	b.n	8011f20 <hci_initializing_event_handler+0x5b4>
            if (hci_stack->local_supported_commands[0] & 0x08) break;
 8011f16:	bf00      	nop
 8011f18:	e002      	b.n	8011f20 <hci_initializing_event_handler+0x5b4>
            if (hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_BROADCOM_CORPORATION) break;
 8011f1a:	bf00      	nop
 8011f1c:	e000      	b.n	8011f20 <hci_initializing_event_handler+0x5b4>
            break;
 8011f1e:	bf00      	nop
    }
    hci_initializing_next_state();
 8011f20:	f7fe feda 	bl	8010cd8 <hci_initializing_next_state>
 8011f24:	e000      	b.n	8011f28 <hci_initializing_event_handler+0x5bc>
    if (!command_completed) return;
 8011f26:	bf00      	nop
}
 8011f28:	3718      	adds	r7, #24
 8011f2a:	46bd      	mov	sp, r7
 8011f2c:	bd80      	pop	{r7, pc}
 8011f2e:	bf00      	nop
 8011f30:	20009780 	.word	0x20009780
 8011f34:	0802929c 	.word	0x0802929c
 8011f38:	08029d5c 	.word	0x08029d5c
 8011f3c:	08029da0 	.word	0x08029da0
 8011f40:	08029dc8 	.word	0x08029dc8

08011f44 <hci_handle_connection_failed>:

static void hci_handle_connection_failed(hci_connection_t * conn, uint8_t status){
 8011f44:	b580      	push	{r7, lr}
 8011f46:	b088      	sub	sp, #32
 8011f48:	af02      	add	r7, sp, #8
 8011f4a:	6078      	str	r0, [r7, #4]
 8011f4c:	460b      	mov	r3, r1
 8011f4e:	70fb      	strb	r3, [r7, #3]
    log_info("Outgoing connection to %s failed", bd_addr_to_str(conn->address));
 8011f50:	687b      	ldr	r3, [r7, #4]
 8011f52:	3304      	adds	r3, #4
 8011f54:	4618      	mov	r0, r3
 8011f56:	f7fd fa5b 	bl	800f410 <bd_addr_to_str>
 8011f5a:	4603      	mov	r3, r0
 8011f5c:	9300      	str	r3, [sp, #0]
 8011f5e:	f240 736f 	movw	r3, #1903	; 0x76f
 8011f62:	4a1c      	ldr	r2, [pc, #112]	; (8011fd4 <hci_handle_connection_failed+0x90>)
 8011f64:	491c      	ldr	r1, [pc, #112]	; (8011fd8 <hci_handle_connection_failed+0x94>)
 8011f66:	2001      	movs	r0, #1
 8011f68:	f005 fa6a 	bl	8017440 <hci_dump_log>
    bd_addr_t bd_address;
    (void)memcpy(&bd_address, conn->address, 6);
 8011f6c:	687b      	ldr	r3, [r7, #4]
 8011f6e:	1d1a      	adds	r2, r3, #4
 8011f70:	f107 030c 	add.w	r3, r7, #12
 8011f74:	6810      	ldr	r0, [r2, #0]
 8011f76:	6018      	str	r0, [r3, #0]
 8011f78:	8892      	ldrh	r2, [r2, #4]
 8011f7a:	809a      	strh	r2, [r3, #4]

#ifdef ENABLE_CLASSIC
    // cache needed data
    int notify_dedicated_bonding_failed = conn->bonding_flags & BONDING_DEDICATED;
 8011f7c:	687b      	ldr	r3, [r7, #4]
 8011f7e:	8a1b      	ldrh	r3, [r3, #16]
 8011f80:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8011f84:	617b      	str	r3, [r7, #20]
#endif
    
    // connection failed, remove entry
    btstack_linked_list_remove(&hci_stack->connections, (btstack_linked_item_t *) conn);
 8011f86:	4b15      	ldr	r3, [pc, #84]	; (8011fdc <hci_handle_connection_failed+0x98>)
 8011f88:	681b      	ldr	r3, [r3, #0]
 8011f8a:	3314      	adds	r3, #20
 8011f8c:	6879      	ldr	r1, [r7, #4]
 8011f8e:	4618      	mov	r0, r3
 8011f90:	f7fc fb95 	bl	800e6be <btstack_linked_list_remove>
    btstack_memory_hci_connection_free( conn );
 8011f94:	6878      	ldr	r0, [r7, #4]
 8011f96:	f7fc fc77 	bl	800e888 <btstack_memory_hci_connection_free>

#ifdef ENABLE_CLASSIC
    // notify client if dedicated bonding
    if (notify_dedicated_bonding_failed){
 8011f9a:	697b      	ldr	r3, [r7, #20]
 8011f9c:	2b00      	cmp	r3, #0
 8011f9e:	d00d      	beq.n	8011fbc <hci_handle_connection_failed+0x78>
        log_info("hci notify_dedicated_bonding_failed");
 8011fa0:	f240 737f 	movw	r3, #1919	; 0x77f
 8011fa4:	4a0b      	ldr	r2, [pc, #44]	; (8011fd4 <hci_handle_connection_failed+0x90>)
 8011fa6:	490e      	ldr	r1, [pc, #56]	; (8011fe0 <hci_handle_connection_failed+0x9c>)
 8011fa8:	2001      	movs	r0, #1
 8011faa:	f005 fa49 	bl	8017440 <hci_dump_log>
        hci_emit_dedicated_bonding_result(bd_address, status);
 8011fae:	78fa      	ldrb	r2, [r7, #3]
 8011fb0:	f107 030c 	add.w	r3, r7, #12
 8011fb4:	4611      	mov	r1, r2
 8011fb6:	4618      	mov	r0, r3
 8011fb8:	f004 fad4 	bl	8016564 <hci_emit_dedicated_bonding_result>
    }

    // if authentication error, also delete link key
    if (status == ERROR_CODE_AUTHENTICATION_FAILURE) {
 8011fbc:	78fb      	ldrb	r3, [r7, #3]
 8011fbe:	2b05      	cmp	r3, #5
 8011fc0:	d104      	bne.n	8011fcc <hci_handle_connection_failed+0x88>
        gap_drop_link_key_for_bd_addr(bd_address);
 8011fc2:	f107 030c 	add.w	r3, r7, #12
 8011fc6:	4618      	mov	r0, r3
 8011fc8:	f7fd fd9a 	bl	800fb00 <gap_drop_link_key_for_bd_addr>
    }
#else
    UNUSED(status);
#endif
}
 8011fcc:	bf00      	nop
 8011fce:	3718      	adds	r7, #24
 8011fd0:	46bd      	mov	sp, r7
 8011fd2:	bd80      	pop	{r7, pc}
 8011fd4:	0802929c 	.word	0x0802929c
 8011fd8:	08029de8 	.word	0x08029de8
 8011fdc:	20009780 	.word	0x20009780
 8011fe0:	08029e10 	.word	0x08029e10

08011fe4 <hci_handle_remote_features_page_0>:

#ifdef ENABLE_CLASSIC
static void hci_handle_remote_features_page_0(hci_connection_t * conn, const uint8_t * features){
 8011fe4:	b480      	push	{r7}
 8011fe6:	b083      	sub	sp, #12
 8011fe8:	af00      	add	r7, sp, #0
 8011fea:	6078      	str	r0, [r7, #4]
 8011fec:	6039      	str	r1, [r7, #0]
    // SSP Controller
    if (features[6] & (1 << 3)){
 8011fee:	683b      	ldr	r3, [r7, #0]
 8011ff0:	3306      	adds	r3, #6
 8011ff2:	781b      	ldrb	r3, [r3, #0]
 8011ff4:	f003 0308 	and.w	r3, r3, #8
 8011ff8:	2b00      	cmp	r3, #0
 8011ffa:	d006      	beq.n	801200a <hci_handle_remote_features_page_0+0x26>
        conn->bonding_flags |= BONDING_REMOTE_SUPPORTS_SSP_CONTROLLER;
 8011ffc:	687b      	ldr	r3, [r7, #4]
 8011ffe:	8a1b      	ldrh	r3, [r3, #16]
 8012000:	f043 0310 	orr.w	r3, r3, #16
 8012004:	b29a      	uxth	r2, r3
 8012006:	687b      	ldr	r3, [r7, #4]
 8012008:	821a      	strh	r2, [r3, #16]
    }
    // eSCO
    if (features[3] & (1<<7)){
 801200a:	683b      	ldr	r3, [r7, #0]
 801200c:	3303      	adds	r3, #3
 801200e:	781b      	ldrb	r3, [r3, #0]
 8012010:	b25b      	sxtb	r3, r3
 8012012:	2b00      	cmp	r3, #0
 8012014:	da06      	bge.n	8012024 <hci_handle_remote_features_page_0+0x40>
        conn->remote_supported_features[0] |= 1;
 8012016:	687b      	ldr	r3, [r7, #4]
 8012018:	7d9b      	ldrb	r3, [r3, #22]
 801201a:	f043 0301 	orr.w	r3, r3, #1
 801201e:	b2da      	uxtb	r2, r3
 8012020:	687b      	ldr	r3, [r7, #4]
 8012022:	759a      	strb	r2, [r3, #22]
    }
    // Extended features
    if (features[7] & (1<<7)){
 8012024:	683b      	ldr	r3, [r7, #0]
 8012026:	3307      	adds	r3, #7
 8012028:	781b      	ldrb	r3, [r3, #0]
 801202a:	b25b      	sxtb	r3, r3
 801202c:	2b00      	cmp	r3, #0
 801202e:	da06      	bge.n	801203e <hci_handle_remote_features_page_0+0x5a>
        conn->remote_supported_features[0] |= 2;
 8012030:	687b      	ldr	r3, [r7, #4]
 8012032:	7d9b      	ldrb	r3, [r3, #22]
 8012034:	f043 0302 	orr.w	r3, r3, #2
 8012038:	b2da      	uxtb	r2, r3
 801203a:	687b      	ldr	r3, [r7, #4]
 801203c:	759a      	strb	r2, [r3, #22]
    }
}
 801203e:	bf00      	nop
 8012040:	370c      	adds	r7, #12
 8012042:	46bd      	mov	sp, r7
 8012044:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012048:	4770      	bx	lr

0801204a <hci_handle_remote_features_page_1>:

static void hci_handle_remote_features_page_1(hci_connection_t * conn, const uint8_t * features){
 801204a:	b480      	push	{r7}
 801204c:	b083      	sub	sp, #12
 801204e:	af00      	add	r7, sp, #0
 8012050:	6078      	str	r0, [r7, #4]
 8012052:	6039      	str	r1, [r7, #0]
    // SSP Host
    if (features[0] & (1 << 0)){
 8012054:	683b      	ldr	r3, [r7, #0]
 8012056:	781b      	ldrb	r3, [r3, #0]
 8012058:	f003 0301 	and.w	r3, r3, #1
 801205c:	2b00      	cmp	r3, #0
 801205e:	d006      	beq.n	801206e <hci_handle_remote_features_page_1+0x24>
        conn->bonding_flags |= BONDING_REMOTE_SUPPORTS_SSP_HOST;
 8012060:	687b      	ldr	r3, [r7, #4]
 8012062:	8a1b      	ldrh	r3, [r3, #16]
 8012064:	f043 0320 	orr.w	r3, r3, #32
 8012068:	b29a      	uxth	r2, r3
 801206a:	687b      	ldr	r3, [r7, #4]
 801206c:	821a      	strh	r2, [r3, #16]
    }
    // SC Host
    if (features[0] & (1 << 3)){
 801206e:	683b      	ldr	r3, [r7, #0]
 8012070:	781b      	ldrb	r3, [r3, #0]
 8012072:	f003 0308 	and.w	r3, r3, #8
 8012076:	2b00      	cmp	r3, #0
 8012078:	d006      	beq.n	8012088 <hci_handle_remote_features_page_1+0x3e>
        conn->bonding_flags |= BONDING_REMOTE_SUPPORTS_SC_HOST;
 801207a:	687b      	ldr	r3, [r7, #4]
 801207c:	8a1b      	ldrh	r3, [r3, #16]
 801207e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8012082:	b29a      	uxth	r2, r3
 8012084:	687b      	ldr	r3, [r7, #4]
 8012086:	821a      	strh	r2, [r3, #16]
    }
}
 8012088:	bf00      	nop
 801208a:	370c      	adds	r7, #12
 801208c:	46bd      	mov	sp, r7
 801208e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012092:	4770      	bx	lr

08012094 <hci_handle_remote_features_page_2>:

static void hci_handle_remote_features_page_2(hci_connection_t * conn, const uint8_t * features){
 8012094:	b480      	push	{r7}
 8012096:	b083      	sub	sp, #12
 8012098:	af00      	add	r7, sp, #0
 801209a:	6078      	str	r0, [r7, #4]
 801209c:	6039      	str	r1, [r7, #0]
    // SC Controller
    if (features[1] & (1 << 0)){
 801209e:	683b      	ldr	r3, [r7, #0]
 80120a0:	3301      	adds	r3, #1
 80120a2:	781b      	ldrb	r3, [r3, #0]
 80120a4:	f003 0301 	and.w	r3, r3, #1
 80120a8:	2b00      	cmp	r3, #0
 80120aa:	d006      	beq.n	80120ba <hci_handle_remote_features_page_2+0x26>
        conn->bonding_flags |= BONDING_REMOTE_SUPPORTS_SC_CONTROLLER;
 80120ac:	687b      	ldr	r3, [r7, #4]
 80120ae:	8a1b      	ldrh	r3, [r3, #16]
 80120b0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80120b4:	b29a      	uxth	r2, r3
 80120b6:	687b      	ldr	r3, [r7, #4]
 80120b8:	821a      	strh	r2, [r3, #16]
    }
}
 80120ba:	bf00      	nop
 80120bc:	370c      	adds	r7, #12
 80120be:	46bd      	mov	sp, r7
 80120c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80120c4:	4770      	bx	lr
	...

080120c8 <hci_handle_remote_features_received>:

static void hci_handle_remote_features_received(hci_connection_t * conn){
 80120c8:	b580      	push	{r7, lr}
 80120ca:	b084      	sub	sp, #16
 80120cc:	af02      	add	r7, sp, #8
 80120ce:	6078      	str	r0, [r7, #4]
    conn->bonding_flags |= BONDING_RECEIVED_REMOTE_FEATURES;
 80120d0:	687b      	ldr	r3, [r7, #4]
 80120d2:	8a1b      	ldrh	r3, [r3, #16]
 80120d4:	f043 0308 	orr.w	r3, r3, #8
 80120d8:	b29a      	uxth	r2, r3
 80120da:	687b      	ldr	r3, [r7, #4]
 80120dc:	821a      	strh	r2, [r3, #16]
    log_info("Remote features %02x, bonding flags %x", conn->remote_supported_features[0], conn->bonding_flags);
 80120de:	687b      	ldr	r3, [r7, #4]
 80120e0:	7d9b      	ldrb	r3, [r3, #22]
 80120e2:	461a      	mov	r2, r3
 80120e4:	687b      	ldr	r3, [r7, #4]
 80120e6:	8a1b      	ldrh	r3, [r3, #16]
 80120e8:	9301      	str	r3, [sp, #4]
 80120ea:	9200      	str	r2, [sp, #0]
 80120ec:	f44f 63f6 	mov.w	r3, #1968	; 0x7b0
 80120f0:	4a0a      	ldr	r2, [pc, #40]	; (801211c <hci_handle_remote_features_received+0x54>)
 80120f2:	490b      	ldr	r1, [pc, #44]	; (8012120 <hci_handle_remote_features_received+0x58>)
 80120f4:	2001      	movs	r0, #1
 80120f6:	f005 f9a3 	bl	8017440 <hci_dump_log>
    if (conn->bonding_flags & BONDING_DEDICATED){
 80120fa:	687b      	ldr	r3, [r7, #4]
 80120fc:	8a1b      	ldrh	r3, [r3, #16]
 80120fe:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8012102:	2b00      	cmp	r3, #0
 8012104:	d006      	beq.n	8012114 <hci_handle_remote_features_received+0x4c>
        conn->bonding_flags |= BONDING_SEND_AUTHENTICATE_REQUEST;
 8012106:	687b      	ldr	r3, [r7, #4]
 8012108:	8a1b      	ldrh	r3, [r3, #16]
 801210a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 801210e:	b29a      	uxth	r2, r3
 8012110:	687b      	ldr	r3, [r7, #4]
 8012112:	821a      	strh	r2, [r3, #16]
    }
}
 8012114:	bf00      	nop
 8012116:	3708      	adds	r7, #8
 8012118:	46bd      	mov	sp, r7
 801211a:	bd80      	pop	{r7, pc}
 801211c:	0802929c 	.word	0x0802929c
 8012120:	08029e3c 	.word	0x08029e3c

08012124 <handle_event_for_current_stack_state>:
#endif

static void handle_event_for_current_stack_state(const uint8_t * packet, uint16_t size) {
 8012124:	b580      	push	{r7, lr}
 8012126:	b082      	sub	sp, #8
 8012128:	af00      	add	r7, sp, #0
 801212a:	6078      	str	r0, [r7, #4]
 801212c:	460b      	mov	r3, r1
 801212e:	807b      	strh	r3, [r7, #2]
    // handle BT initialization
    if (hci_stack->state == HCI_STATE_INITIALIZING) {
 8012130:	4b15      	ldr	r3, [pc, #84]	; (8012188 <handle_event_for_current_stack_state+0x64>)
 8012132:	681b      	ldr	r3, [r3, #0]
 8012134:	f893 3716 	ldrb.w	r3, [r3, #1814]	; 0x716
 8012138:	2b01      	cmp	r3, #1
 801213a:	d104      	bne.n	8012146 <handle_event_for_current_stack_state+0x22>
        hci_initializing_event_handler(packet, size);
 801213c:	887b      	ldrh	r3, [r7, #2]
 801213e:	4619      	mov	r1, r3
 8012140:	6878      	ldr	r0, [r7, #4]
 8012142:	f7ff fc13 	bl	801196c <hci_initializing_event_handler>
    }

    // help with BT sleep
    if ((hci_stack->state == HCI_STATE_FALLING_ASLEEP)
 8012146:	4b10      	ldr	r3, [pc, #64]	; (8012188 <handle_event_for_current_stack_state+0x64>)
 8012148:	681b      	ldr	r3, [r3, #0]
 801214a:	f893 3716 	ldrb.w	r3, [r3, #1814]	; 0x716
 801214e:	2b05      	cmp	r3, #5
 8012150:	d115      	bne.n	801217e <handle_event_for_current_stack_state+0x5a>
        && (hci_stack->substate == HCI_FALLING_ASLEEP_W4_WRITE_SCAN_ENABLE)
 8012152:	4b0d      	ldr	r3, [pc, #52]	; (8012188 <handle_event_for_current_stack_state+0x64>)
 8012154:	681b      	ldr	r3, [r3, #0]
 8012156:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 801215a:	2b46      	cmp	r3, #70	; 0x46
 801215c:	d10f      	bne.n	801217e <handle_event_for_current_stack_state+0x5a>
        && HCI_EVENT_IS_COMMAND_COMPLETE(packet, hci_write_scan_enable)) {
 801215e:	687b      	ldr	r3, [r7, #4]
 8012160:	781b      	ldrb	r3, [r3, #0]
 8012162:	2b0e      	cmp	r3, #14
 8012164:	d10b      	bne.n	801217e <handle_event_for_current_stack_state+0x5a>
 8012166:	2103      	movs	r1, #3
 8012168:	6878      	ldr	r0, [r7, #4]
 801216a:	f7fc fe3c 	bl	800ede6 <little_endian_read_16>
 801216e:	4603      	mov	r3, r0
 8012170:	461a      	mov	r2, r3
 8012172:	4b06      	ldr	r3, [pc, #24]	; (801218c <handle_event_for_current_stack_state+0x68>)
 8012174:	881b      	ldrh	r3, [r3, #0]
 8012176:	429a      	cmp	r2, r3
 8012178:	d101      	bne.n	801217e <handle_event_for_current_stack_state+0x5a>
        hci_initializing_next_state();
 801217a:	f7fe fdad 	bl	8010cd8 <hci_initializing_next_state>
    }
}
 801217e:	bf00      	nop
 8012180:	3708      	adds	r7, #8
 8012182:	46bd      	mov	sp, r7
 8012184:	bd80      	pop	{r7, pc}
 8012186:	bf00      	nop
 8012188:	20009780 	.word	0x20009780
 801218c:	08030af0 	.word	0x08030af0

08012190 <hci_handle_read_encryption_key_size_complete>:

#ifdef ENABLE_CLASSIC
static void hci_handle_read_encryption_key_size_complete(hci_connection_t * conn, uint8_t encryption_key_size) {
 8012190:	b590      	push	{r4, r7, lr}
 8012192:	b083      	sub	sp, #12
 8012194:	af00      	add	r7, sp, #0
 8012196:	6078      	str	r0, [r7, #4]
 8012198:	460b      	mov	r3, r1
 801219a:	70fb      	strb	r3, [r7, #3]
    conn->authentication_flags |= CONNECTION_ENCRYPTED;
 801219c:	687b      	ldr	r3, [r7, #4]
 801219e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80121a0:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80121a4:	687b      	ldr	r3, [r7, #4]
 80121a6:	639a      	str	r2, [r3, #56]	; 0x38
    conn->encryption_key_size = encryption_key_size;
 80121a8:	687b      	ldr	r3, [r7, #4]
 80121aa:	78fa      	ldrb	r2, [r7, #3]
 80121ac:	74da      	strb	r2, [r3, #19]

    if ((conn->authentication_flags & CONNECTION_AUTHENTICATED) != 0) {
 80121ae:	687b      	ldr	r3, [r7, #4]
 80121b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80121b2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80121b6:	2b00      	cmp	r3, #0
 80121b8:	d00a      	beq.n	80121d0 <hci_handle_read_encryption_key_size_complete+0x40>
        hci_emit_security_level(conn->con_handle, gap_security_level_for_connection(conn));
 80121ba:	687b      	ldr	r3, [r7, #4]
 80121bc:	895c      	ldrh	r4, [r3, #10]
 80121be:	6878      	ldr	r0, [r7, #4]
 80121c0:	f004 fa5e 	bl	8016680 <gap_security_level_for_connection>
 80121c4:	4603      	mov	r3, r0
 80121c6:	4619      	mov	r1, r3
 80121c8:	4620      	mov	r0, r4
 80121ca:	f004 fa0f 	bl	80165ec <hci_emit_security_level>
        return;
 80121ce:	e00d      	b.n	80121ec <hci_handle_read_encryption_key_size_complete+0x5c>
    }

    // Request Authentication if not already done
    if ((conn->bonding_flags & BONDING_SENT_AUTHENTICATE_REQUEST) != 0) return;
 80121d0:	687b      	ldr	r3, [r7, #4]
 80121d2:	8a1b      	ldrh	r3, [r3, #16]
 80121d4:	b21b      	sxth	r3, r3
 80121d6:	2b00      	cmp	r3, #0
 80121d8:	db07      	blt.n	80121ea <hci_handle_read_encryption_key_size_complete+0x5a>
    conn->bonding_flags |= BONDING_SEND_AUTHENTICATE_REQUEST;
 80121da:	687b      	ldr	r3, [r7, #4]
 80121dc:	8a1b      	ldrh	r3, [r3, #16]
 80121de:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80121e2:	b29a      	uxth	r2, r3
 80121e4:	687b      	ldr	r3, [r7, #4]
 80121e6:	821a      	strh	r2, [r3, #16]
 80121e8:	e000      	b.n	80121ec <hci_handle_read_encryption_key_size_complete+0x5c>
    if ((conn->bonding_flags & BONDING_SENT_AUTHENTICATE_REQUEST) != 0) return;
 80121ea:	bf00      	nop
}
 80121ec:	370c      	adds	r7, #12
 80121ee:	46bd      	mov	sp, r7
 80121f0:	bd90      	pop	{r4, r7, pc}
	...

080121f4 <handle_command_complete_event>:
#endif

static void handle_command_complete_event(uint8_t * packet, uint16_t size){
 80121f4:	b590      	push	{r4, r7, lr}
 80121f6:	b091      	sub	sp, #68	; 0x44
 80121f8:	af06      	add	r7, sp, #24
 80121fa:	6078      	str	r0, [r7, #4]
 80121fc:	460b      	mov	r3, r1
 80121fe:	807b      	strh	r3, [r7, #2]
    hci_con_handle_t handle;
    hci_connection_t * conn;
    uint8_t status;
#endif
    // get num cmd packets - limit to 1 to reduce complexity
    hci_stack->num_cmd_packets = packet[2] ? 1 : 0;
 8012200:	687b      	ldr	r3, [r7, #4]
 8012202:	3302      	adds	r3, #2
 8012204:	781b      	ldrb	r3, [r3, #0]
 8012206:	2b00      	cmp	r3, #0
 8012208:	bf14      	ite	ne
 801220a:	2301      	movne	r3, #1
 801220c:	2300      	moveq	r3, #0
 801220e:	b2da      	uxtb	r2, r3
 8012210:	4baa      	ldr	r3, [pc, #680]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012212:	681b      	ldr	r3, [r3, #0]
 8012214:	f883 26fb 	strb.w	r2, [r3, #1787]	; 0x6fb

    uint16_t opcode = hci_event_command_complete_get_command_opcode(packet);
 8012218:	6878      	ldr	r0, [r7, #4]
 801221a:	f7fd f9c3 	bl	800f5a4 <hci_event_command_complete_get_command_opcode>
 801221e:	4603      	mov	r3, r0
 8012220:	847b      	strh	r3, [r7, #34]	; 0x22
    switch (opcode){
 8012222:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8012224:	f241 0203 	movw	r2, #4099	; 0x1003
 8012228:	4293      	cmp	r3, r2
 801222a:	f000 81a7 	beq.w	801257c <handle_command_complete_event+0x388>
 801222e:	f241 0203 	movw	r2, #4099	; 0x1003
 8012232:	4293      	cmp	r3, r2
 8012234:	dc22      	bgt.n	801227c <handle_command_complete_event+0x88>
 8012236:	f640 421a 	movw	r2, #3098	; 0xc1a
 801223a:	4293      	cmp	r3, r2
 801223c:	f000 8179 	beq.w	8012532 <handle_command_complete_event+0x33e>
 8012240:	f640 421a 	movw	r2, #3098	; 0xc1a
 8012244:	4293      	cmp	r3, r2
 8012246:	dc09      	bgt.n	801225c <handle_command_complete_event+0x68>
 8012248:	f240 4202 	movw	r2, #1026	; 0x402
 801224c:	4293      	cmp	r3, r2
 801224e:	f000 8178 	beq.w	8012542 <handle_command_complete_event+0x34e>
 8012252:	f640 4214 	movw	r2, #3092	; 0xc14
 8012256:	4293      	cmp	r3, r2
 8012258:	d038      	beq.n	80122cc <handle_command_complete_event+0xd8>
            break;
        }
#endif
#endif
        default:
            break;
 801225a:	e2ed      	b.n	8012838 <handle_command_complete_event+0x644>
    switch (opcode){
 801225c:	f241 0201 	movw	r2, #4097	; 0x1001
 8012260:	4293      	cmp	r3, r2
 8012262:	f000 81c4 	beq.w	80125ee <handle_command_complete_event+0x3fa>
 8012266:	f241 0201 	movw	r2, #4097	; 0x1001
 801226a:	4293      	cmp	r3, r2
 801226c:	f300 81eb 	bgt.w	8012646 <handle_command_complete_event+0x452>
 8012270:	f640 422f 	movw	r2, #3119	; 0xc2f
 8012274:	4293      	cmp	r3, r2
 8012276:	f000 827a 	beq.w	801276e <handle_command_complete_event+0x57a>
            break;
 801227a:	e2dd      	b.n	8012838 <handle_command_complete_event+0x644>
    switch (opcode){
 801227c:	f241 4208 	movw	r2, #5128	; 0x1408
 8012280:	4293      	cmp	r3, r2
 8012282:	f000 8291 	beq.w	80127a8 <handle_command_complete_event+0x5b4>
 8012286:	f241 4208 	movw	r2, #5128	; 0x1408
 801228a:	4293      	cmp	r3, r2
 801228c:	dc0e      	bgt.n	80122ac <handle_command_complete_event+0xb8>
 801228e:	f241 0209 	movw	r2, #4105	; 0x1009
 8012292:	4293      	cmp	r3, r2
 8012294:	f000 8120 	beq.w	80124d8 <handle_command_complete_event+0x2e4>
 8012298:	f241 4205 	movw	r2, #5125	; 0x1405
 801229c:	4293      	cmp	r3, r2
 801229e:	f000 808a 	beq.w	80123b6 <handle_command_complete_event+0x1c2>
 80122a2:	f241 0205 	movw	r2, #4101	; 0x1005
 80122a6:	4293      	cmp	r3, r2
 80122a8:	d025      	beq.n	80122f6 <handle_command_complete_event+0x102>
            break;
 80122aa:	e2c5      	b.n	8012838 <handle_command_complete_event+0x644>
    switch (opcode){
 80122ac:	f242 020f 	movw	r2, #8207	; 0x200f
 80122b0:	4293      	cmp	r3, r2
 80122b2:	f000 80ef 	beq.w	8012494 <handle_command_complete_event+0x2a0>
 80122b6:	f242 022f 	movw	r2, #8239	; 0x202f
 80122ba:	4293      	cmp	r3, r2
 80122bc:	f000 80c5 	beq.w	801244a <handle_command_complete_event+0x256>
 80122c0:	f242 0202 	movw	r2, #8194	; 0x2002
 80122c4:	4293      	cmp	r3, r2
 80122c6:	f000 8091 	beq.w	80123ec <handle_command_complete_event+0x1f8>
            break;
 80122ca:	e2b5      	b.n	8012838 <handle_command_complete_event+0x644>
            if (packet[5]) break;
 80122cc:	687b      	ldr	r3, [r7, #4]
 80122ce:	3305      	adds	r3, #5
 80122d0:	781b      	ldrb	r3, [r3, #0]
 80122d2:	2b00      	cmp	r3, #0
 80122d4:	f040 82a3 	bne.w	801281e <handle_command_complete_event+0x62a>
            packet[6+248] = 0;
 80122d8:	687b      	ldr	r3, [r7, #4]
 80122da:	33fe      	adds	r3, #254	; 0xfe
 80122dc:	2200      	movs	r2, #0
 80122de:	701a      	strb	r2, [r3, #0]
            log_info("local name: %s", &packet[6]);
 80122e0:	687b      	ldr	r3, [r7, #4]
 80122e2:	3306      	adds	r3, #6
 80122e4:	9300      	str	r3, [sp, #0]
 80122e6:	f240 73e7 	movw	r3, #2023	; 0x7e7
 80122ea:	4a75      	ldr	r2, [pc, #468]	; (80124c0 <handle_command_complete_event+0x2cc>)
 80122ec:	4975      	ldr	r1, [pc, #468]	; (80124c4 <handle_command_complete_event+0x2d0>)
 80122ee:	2001      	movs	r0, #1
 80122f0:	f005 f8a6 	bl	8017440 <hci_dump_log>
            break;
 80122f4:	e2a0      	b.n	8012838 <handle_command_complete_event+0x644>
            if (hci_stack->state == HCI_STATE_INITIALIZING) {
 80122f6:	4b71      	ldr	r3, [pc, #452]	; (80124bc <handle_command_complete_event+0x2c8>)
 80122f8:	681b      	ldr	r3, [r3, #0]
 80122fa:	f893 3716 	ldrb.w	r3, [r3, #1814]	; 0x716
 80122fe:	2b01      	cmp	r3, #1
 8012300:	f040 828f 	bne.w	8012822 <handle_command_complete_event+0x62e>
                uint16_t acl_len = little_endian_read_16(packet, 6);
 8012304:	2106      	movs	r1, #6
 8012306:	6878      	ldr	r0, [r7, #4]
 8012308:	f7fc fd6d 	bl	800ede6 <little_endian_read_16>
 801230c:	4603      	mov	r3, r0
 801230e:	82fb      	strh	r3, [r7, #22]
                uint16_t sco_len = packet[8];
 8012310:	687b      	ldr	r3, [r7, #4]
 8012312:	3308      	adds	r3, #8
 8012314:	781b      	ldrb	r3, [r3, #0]
 8012316:	82bb      	strh	r3, [r7, #20]
                hci_stack->acl_data_packet_length = btstack_min(acl_len, HCI_ACL_PAYLOAD_SIZE);
 8012318:	8afb      	ldrh	r3, [r7, #22]
 801231a:	f240 619f 	movw	r1, #1695	; 0x69f
 801231e:	4618      	mov	r0, r3
 8012320:	f7fc fef5 	bl	800f10e <btstack_min>
 8012324:	4602      	mov	r2, r0
 8012326:	4b65      	ldr	r3, [pc, #404]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012328:	681b      	ldr	r3, [r3, #0]
 801232a:	b292      	uxth	r2, r2
 801232c:	f8a3 26fe 	strh.w	r2, [r3, #1790]	; 0x6fe
                hci_stack->sco_data_packet_length = btstack_min(sco_len, HCI_ACL_PAYLOAD_SIZE);
 8012330:	8abb      	ldrh	r3, [r7, #20]
 8012332:	f240 619f 	movw	r1, #1695	; 0x69f
 8012336:	4618      	mov	r0, r3
 8012338:	f7fc fee9 	bl	800f10e <btstack_min>
 801233c:	4602      	mov	r2, r0
 801233e:	4b5f      	ldr	r3, [pc, #380]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012340:	681b      	ldr	r3, [r3, #0]
 8012342:	b2d2      	uxtb	r2, r2
 8012344:	f883 2701 	strb.w	r2, [r3, #1793]	; 0x701
                hci_stack->acl_packets_total_num = little_endian_read_16(packet, 9);
 8012348:	2109      	movs	r1, #9
 801234a:	6878      	ldr	r0, [r7, #4]
 801234c:	f7fc fd4b 	bl	800ede6 <little_endian_read_16>
 8012350:	4603      	mov	r3, r0
 8012352:	461a      	mov	r2, r3
 8012354:	4b59      	ldr	r3, [pc, #356]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012356:	681b      	ldr	r3, [r3, #0]
 8012358:	b2d2      	uxtb	r2, r2
 801235a:	f883 26fc 	strb.w	r2, [r3, #1788]	; 0x6fc
                hci_stack->sco_packets_total_num = little_endian_read_16(packet, 11);
 801235e:	210b      	movs	r1, #11
 8012360:	6878      	ldr	r0, [r7, #4]
 8012362:	f7fc fd40 	bl	800ede6 <little_endian_read_16>
 8012366:	4603      	mov	r3, r0
 8012368:	461a      	mov	r2, r3
 801236a:	4b54      	ldr	r3, [pc, #336]	; (80124bc <handle_command_complete_event+0x2c8>)
 801236c:	681b      	ldr	r3, [r3, #0]
 801236e:	b2d2      	uxtb	r2, r2
 8012370:	f883 2700 	strb.w	r2, [r3, #1792]	; 0x700
                log_info("hci_read_buffer_size: ACL size module %u -> used %u, count %u / SCO size %u, count %u",
 8012374:	8afb      	ldrh	r3, [r7, #22]
 8012376:	4a51      	ldr	r2, [pc, #324]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012378:	6812      	ldr	r2, [r2, #0]
 801237a:	f8b2 26fe 	ldrh.w	r2, [r2, #1790]	; 0x6fe
 801237e:	4611      	mov	r1, r2
 8012380:	4a4e      	ldr	r2, [pc, #312]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012382:	6812      	ldr	r2, [r2, #0]
 8012384:	f892 26fc 	ldrb.w	r2, [r2, #1788]	; 0x6fc
 8012388:	4610      	mov	r0, r2
 801238a:	4a4c      	ldr	r2, [pc, #304]	; (80124bc <handle_command_complete_event+0x2c8>)
 801238c:	6812      	ldr	r2, [r2, #0]
 801238e:	f892 2701 	ldrb.w	r2, [r2, #1793]	; 0x701
 8012392:	4614      	mov	r4, r2
 8012394:	4a49      	ldr	r2, [pc, #292]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012396:	6812      	ldr	r2, [r2, #0]
 8012398:	f892 2700 	ldrb.w	r2, [r2, #1792]	; 0x700
 801239c:	9204      	str	r2, [sp, #16]
 801239e:	9403      	str	r4, [sp, #12]
 80123a0:	9002      	str	r0, [sp, #8]
 80123a2:	9101      	str	r1, [sp, #4]
 80123a4:	9300      	str	r3, [sp, #0]
 80123a6:	f44f 63ff 	mov.w	r3, #2040	; 0x7f8
 80123aa:	4a45      	ldr	r2, [pc, #276]	; (80124c0 <handle_command_complete_event+0x2cc>)
 80123ac:	4946      	ldr	r1, [pc, #280]	; (80124c8 <handle_command_complete_event+0x2d4>)
 80123ae:	2001      	movs	r0, #1
 80123b0:	f005 f846 	bl	8017440 <hci_dump_log>
            break;
 80123b4:	e235      	b.n	8012822 <handle_command_complete_event+0x62e>
            if (packet[5] == ERROR_CODE_SUCCESS){
 80123b6:	687b      	ldr	r3, [r7, #4]
 80123b8:	3305      	adds	r3, #5
 80123ba:	781b      	ldrb	r3, [r3, #0]
 80123bc:	2b00      	cmp	r3, #0
 80123be:	f040 8232 	bne.w	8012826 <handle_command_complete_event+0x632>
                event[0] = GAP_EVENT_RSSI_MEASUREMENT;
 80123c2:	23e5      	movs	r3, #229	; 0xe5
 80123c4:	733b      	strb	r3, [r7, #12]
                event[1] = 3;
 80123c6:	2303      	movs	r3, #3
 80123c8:	737b      	strb	r3, [r7, #13]
                (void)memcpy(&event[2], &packet[6], 3);
 80123ca:	687b      	ldr	r3, [r7, #4]
 80123cc:	1d99      	adds	r1, r3, #6
 80123ce:	f107 030c 	add.w	r3, r7, #12
 80123d2:	3302      	adds	r3, #2
 80123d4:	2203      	movs	r2, #3
 80123d6:	4618      	mov	r0, r3
 80123d8:	f015 fb4f 	bl	8027a7a <memcpy>
                hci_emit_event(event, sizeof(event), 1);
 80123dc:	f107 030c 	add.w	r3, r7, #12
 80123e0:	2201      	movs	r2, #1
 80123e2:	2105      	movs	r1, #5
 80123e4:	4618      	mov	r0, r3
 80123e6:	f003 fe0f 	bl	8016008 <hci_emit_event>
            break;
 80123ea:	e21c      	b.n	8012826 <handle_command_complete_event+0x632>
            hci_stack->le_data_packets_length = little_endian_read_16(packet, 6);
 80123ec:	4b33      	ldr	r3, [pc, #204]	; (80124bc <handle_command_complete_event+0x2c8>)
 80123ee:	681c      	ldr	r4, [r3, #0]
 80123f0:	2106      	movs	r1, #6
 80123f2:	6878      	ldr	r0, [r7, #4]
 80123f4:	f7fc fcf7 	bl	800ede6 <little_endian_read_16>
 80123f8:	4603      	mov	r3, r0
 80123fa:	f8a4 3704 	strh.w	r3, [r4, #1796]	; 0x704
            hci_stack->le_acl_packets_total_num = packet[8];
 80123fe:	4b2f      	ldr	r3, [pc, #188]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012400:	681b      	ldr	r3, [r3, #0]
 8012402:	687a      	ldr	r2, [r7, #4]
 8012404:	7a12      	ldrb	r2, [r2, #8]
 8012406:	f883 2703 	strb.w	r2, [r3, #1795]	; 0x703
            if (HCI_ACL_PAYLOAD_SIZE < hci_stack->le_data_packets_length){
 801240a:	4b2c      	ldr	r3, [pc, #176]	; (80124bc <handle_command_complete_event+0x2c8>)
 801240c:	681b      	ldr	r3, [r3, #0]
 801240e:	f8b3 3704 	ldrh.w	r3, [r3, #1796]	; 0x704
 8012412:	f5b3 6fd4 	cmp.w	r3, #1696	; 0x6a0
 8012416:	d305      	bcc.n	8012424 <handle_command_complete_event+0x230>
                hci_stack->le_data_packets_length = HCI_ACL_PAYLOAD_SIZE;
 8012418:	4b28      	ldr	r3, [pc, #160]	; (80124bc <handle_command_complete_event+0x2c8>)
 801241a:	681b      	ldr	r3, [r3, #0]
 801241c:	f240 629f 	movw	r2, #1695	; 0x69f
 8012420:	f8a3 2704 	strh.w	r2, [r3, #1796]	; 0x704
            log_info("hci_le_read_buffer_size: size %u, count %u", hci_stack->le_data_packets_length, hci_stack->le_acl_packets_total_num);
 8012424:	4b25      	ldr	r3, [pc, #148]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012426:	681b      	ldr	r3, [r3, #0]
 8012428:	f8b3 3704 	ldrh.w	r3, [r3, #1796]	; 0x704
 801242c:	461a      	mov	r2, r3
 801242e:	4b23      	ldr	r3, [pc, #140]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012430:	681b      	ldr	r3, [r3, #0]
 8012432:	f893 3703 	ldrb.w	r3, [r3, #1795]	; 0x703
 8012436:	9301      	str	r3, [sp, #4]
 8012438:	9200      	str	r2, [sp, #0]
 801243a:	f640 030c 	movw	r3, #2060	; 0x80c
 801243e:	4a20      	ldr	r2, [pc, #128]	; (80124c0 <handle_command_complete_event+0x2cc>)
 8012440:	4922      	ldr	r1, [pc, #136]	; (80124cc <handle_command_complete_event+0x2d8>)
 8012442:	2001      	movs	r0, #1
 8012444:	f004 fffc 	bl	8017440 <hci_dump_log>
            break;
 8012448:	e1f6      	b.n	8012838 <handle_command_complete_event+0x644>
            hci_stack->le_supported_max_tx_octets = little_endian_read_16(packet, 6);
 801244a:	4b1c      	ldr	r3, [pc, #112]	; (80124bc <handle_command_complete_event+0x2c8>)
 801244c:	681c      	ldr	r4, [r3, #0]
 801244e:	2106      	movs	r1, #6
 8012450:	6878      	ldr	r0, [r7, #4]
 8012452:	f7fc fcc8 	bl	800ede6 <little_endian_read_16>
 8012456:	4603      	mov	r3, r0
 8012458:	f8a4 37ae 	strh.w	r3, [r4, #1966]	; 0x7ae
            hci_stack->le_supported_max_tx_time = little_endian_read_16(packet, 8);
 801245c:	4b17      	ldr	r3, [pc, #92]	; (80124bc <handle_command_complete_event+0x2c8>)
 801245e:	681c      	ldr	r4, [r3, #0]
 8012460:	2108      	movs	r1, #8
 8012462:	6878      	ldr	r0, [r7, #4]
 8012464:	f7fc fcbf 	bl	800ede6 <little_endian_read_16>
 8012468:	4603      	mov	r3, r0
 801246a:	f8a4 37b0 	strh.w	r3, [r4, #1968]	; 0x7b0
            log_info("hci_le_read_maximum_data_length: tx octets %u, tx time %u us", hci_stack->le_supported_max_tx_octets, hci_stack->le_supported_max_tx_time);
 801246e:	4b13      	ldr	r3, [pc, #76]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012470:	681b      	ldr	r3, [r3, #0]
 8012472:	f8b3 37ae 	ldrh.w	r3, [r3, #1966]	; 0x7ae
 8012476:	461a      	mov	r2, r3
 8012478:	4b10      	ldr	r3, [pc, #64]	; (80124bc <handle_command_complete_event+0x2c8>)
 801247a:	681b      	ldr	r3, [r3, #0]
 801247c:	f8b3 37b0 	ldrh.w	r3, [r3, #1968]	; 0x7b0
 8012480:	9301      	str	r3, [sp, #4]
 8012482:	9200      	str	r2, [sp, #0]
 8012484:	f640 0313 	movw	r3, #2067	; 0x813
 8012488:	4a0d      	ldr	r2, [pc, #52]	; (80124c0 <handle_command_complete_event+0x2cc>)
 801248a:	4911      	ldr	r1, [pc, #68]	; (80124d0 <handle_command_complete_event+0x2dc>)
 801248c:	2001      	movs	r0, #1
 801248e:	f004 ffd7 	bl	8017440 <hci_dump_log>
            break;
 8012492:	e1d1      	b.n	8012838 <handle_command_complete_event+0x644>
            hci_stack->le_whitelist_capacity = packet[6];
 8012494:	4b09      	ldr	r3, [pc, #36]	; (80124bc <handle_command_complete_event+0x2c8>)
 8012496:	681b      	ldr	r3, [r3, #0]
 8012498:	687a      	ldr	r2, [r7, #4]
 801249a:	7992      	ldrb	r2, [r2, #6]
 801249c:	f883 275c 	strb.w	r2, [r3, #1884]	; 0x75c
            log_info("hci_le_read_white_list_size: size %u", hci_stack->le_whitelist_capacity);
 80124a0:	4b06      	ldr	r3, [pc, #24]	; (80124bc <handle_command_complete_event+0x2c8>)
 80124a2:	681b      	ldr	r3, [r3, #0]
 80124a4:	f893 375c 	ldrb.w	r3, [r3, #1884]	; 0x75c
 80124a8:	9300      	str	r3, [sp, #0]
 80124aa:	f640 0319 	movw	r3, #2073	; 0x819
 80124ae:	4a04      	ldr	r2, [pc, #16]	; (80124c0 <handle_command_complete_event+0x2cc>)
 80124b0:	4908      	ldr	r1, [pc, #32]	; (80124d4 <handle_command_complete_event+0x2e0>)
 80124b2:	2001      	movs	r0, #1
 80124b4:	f004 ffc4 	bl	8017440 <hci_dump_log>
            break;
 80124b8:	e1be      	b.n	8012838 <handle_command_complete_event+0x644>
 80124ba:	bf00      	nop
 80124bc:	20009780 	.word	0x20009780
 80124c0:	0802929c 	.word	0x0802929c
 80124c4:	08029e6c 	.word	0x08029e6c
 80124c8:	08029e84 	.word	0x08029e84
 80124cc:	08029ee4 	.word	0x08029ee4
 80124d0:	08029f18 	.word	0x08029f18
 80124d4:	08029f5c 	.word	0x08029f5c
            reverse_bd_addr(&packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE + 1], hci_stack->local_bd_addr);
 80124d8:	687b      	ldr	r3, [r7, #4]
 80124da:	1d9a      	adds	r2, r3, #6
 80124dc:	4ba9      	ldr	r3, [pc, #676]	; (8012784 <handle_command_complete_event+0x590>)
 80124de:	681b      	ldr	r3, [r3, #0]
 80124e0:	3338      	adds	r3, #56	; 0x38
 80124e2:	4619      	mov	r1, r3
 80124e4:	4610      	mov	r0, r2
 80124e6:	f7fc fe04 	bl	800f0f2 <reverse_bd_addr>
            log_info("Local Address, Status: 0x%02x: Addr: %s", packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE], bd_addr_to_str(hci_stack->local_bd_addr));
 80124ea:	687b      	ldr	r3, [r7, #4]
 80124ec:	3305      	adds	r3, #5
 80124ee:	781b      	ldrb	r3, [r3, #0]
 80124f0:	461c      	mov	r4, r3
 80124f2:	4ba4      	ldr	r3, [pc, #656]	; (8012784 <handle_command_complete_event+0x590>)
 80124f4:	681b      	ldr	r3, [r3, #0]
 80124f6:	3338      	adds	r3, #56	; 0x38
 80124f8:	4618      	mov	r0, r3
 80124fa:	f7fc ff89 	bl	800f410 <bd_addr_to_str>
 80124fe:	4603      	mov	r3, r0
 8012500:	9301      	str	r3, [sp, #4]
 8012502:	9400      	str	r4, [sp, #0]
 8012504:	f640 031e 	movw	r3, #2078	; 0x81e
 8012508:	4a9f      	ldr	r2, [pc, #636]	; (8012788 <handle_command_complete_event+0x594>)
 801250a:	49a0      	ldr	r1, [pc, #640]	; (801278c <handle_command_complete_event+0x598>)
 801250c:	2001      	movs	r0, #1
 801250e:	f004 ff97 	bl	8017440 <hci_dump_log>
            if (hci_stack->link_key_db){
 8012512:	4b9c      	ldr	r3, [pc, #624]	; (8012784 <handle_command_complete_event+0x590>)
 8012514:	681b      	ldr	r3, [r3, #0]
 8012516:	691b      	ldr	r3, [r3, #16]
 8012518:	2b00      	cmp	r3, #0
 801251a:	f000 8186 	beq.w	801282a <handle_command_complete_event+0x636>
                hci_stack->link_key_db->set_local_bd_addr(hci_stack->local_bd_addr);
 801251e:	4b99      	ldr	r3, [pc, #612]	; (8012784 <handle_command_complete_event+0x590>)
 8012520:	681b      	ldr	r3, [r3, #0]
 8012522:	691b      	ldr	r3, [r3, #16]
 8012524:	685b      	ldr	r3, [r3, #4]
 8012526:	4a97      	ldr	r2, [pc, #604]	; (8012784 <handle_command_complete_event+0x590>)
 8012528:	6812      	ldr	r2, [r2, #0]
 801252a:	3238      	adds	r2, #56	; 0x38
 801252c:	4610      	mov	r0, r2
 801252e:	4798      	blx	r3
            break;
 8012530:	e17b      	b.n	801282a <handle_command_complete_event+0x636>
            hci_emit_discoverable_enabled(hci_stack->discoverable);
 8012532:	4b94      	ldr	r3, [pc, #592]	; (8012784 <handle_command_complete_event+0x590>)
 8012534:	681b      	ldr	r3, [r3, #0]
 8012536:	f893 372e 	ldrb.w	r3, [r3, #1838]	; 0x72e
 801253a:	4618      	mov	r0, r3
 801253c:	f004 f8da 	bl	80166f4 <hci_emit_discoverable_enabled>
            break;
 8012540:	e17a      	b.n	8012838 <handle_command_complete_event+0x644>
            if (hci_stack->inquiry_state == GAP_INQUIRY_STATE_W4_CANCELLED){
 8012542:	4b90      	ldr	r3, [pc, #576]	; (8012784 <handle_command_complete_event+0x590>)
 8012544:	681b      	ldr	r3, [r3, #0]
 8012546:	f893 3731 	ldrb.w	r3, [r3, #1841]	; 0x731
 801254a:	2b82      	cmp	r3, #130	; 0x82
 801254c:	f040 816f 	bne.w	801282e <handle_command_complete_event+0x63a>
                hci_stack->inquiry_state = GAP_INQUIRY_STATE_IDLE;
 8012550:	4b8c      	ldr	r3, [pc, #560]	; (8012784 <handle_command_complete_event+0x590>)
 8012552:	681b      	ldr	r3, [r3, #0]
 8012554:	2200      	movs	r2, #0
 8012556:	f883 2731 	strb.w	r2, [r3, #1841]	; 0x731
                uint8_t event[] = { GAP_EVENT_INQUIRY_COMPLETE, 1, 0};
 801255a:	4a8d      	ldr	r2, [pc, #564]	; (8012790 <handle_command_complete_event+0x59c>)
 801255c:	f107 0308 	add.w	r3, r7, #8
 8012560:	6812      	ldr	r2, [r2, #0]
 8012562:	4611      	mov	r1, r2
 8012564:	8019      	strh	r1, [r3, #0]
 8012566:	3302      	adds	r3, #2
 8012568:	0c12      	lsrs	r2, r2, #16
 801256a:	701a      	strb	r2, [r3, #0]
                hci_emit_event(event, sizeof(event), 1);
 801256c:	f107 0308 	add.w	r3, r7, #8
 8012570:	2201      	movs	r2, #1
 8012572:	2103      	movs	r1, #3
 8012574:	4618      	mov	r0, r3
 8012576:	f003 fd47 	bl	8016008 <hci_emit_event>
            break;
 801257a:	e158      	b.n	801282e <handle_command_complete_event+0x63a>
            (void)memcpy(hci_stack->local_supported_features, &packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE + 1], 8);
 801257c:	4b81      	ldr	r3, [pc, #516]	; (8012784 <handle_command_complete_event+0x590>)
 801257e:	681b      	ldr	r3, [r3, #0]
 8012580:	f503 60e1 	add.w	r0, r3, #1800	; 0x708
 8012584:	687b      	ldr	r3, [r7, #4]
 8012586:	3306      	adds	r3, #6
 8012588:	2208      	movs	r2, #8
 801258a:	4619      	mov	r1, r3
 801258c:	f015 fa75 	bl	8027a7a <memcpy>
            hci_stack->packet_types = hci_acl_packet_types_for_buffer_size_and_local_features(HCI_ACL_PAYLOAD_SIZE, &hci_stack->local_supported_features[0]);
 8012590:	4b7c      	ldr	r3, [pc, #496]	; (8012784 <handle_command_complete_event+0x590>)
 8012592:	681b      	ldr	r3, [r3, #0]
 8012594:	f503 62e1 	add.w	r2, r3, #1800	; 0x708
 8012598:	4b7a      	ldr	r3, [pc, #488]	; (8012784 <handle_command_complete_event+0x590>)
 801259a:	681c      	ldr	r4, [r3, #0]
 801259c:	4611      	mov	r1, r2
 801259e:	f240 609f 	movw	r0, #1695	; 0x69f
 80125a2:	f7fe f869 	bl	8010678 <hci_acl_packet_types_for_buffer_size_and_local_features>
 80125a6:	4603      	mov	r3, r0
 80125a8:	f8a4 3714 	strh.w	r3, [r4, #1812]	; 0x714
            log_info("Packet types %04x, eSCO %u", hci_stack->packet_types, hci_extended_sco_link_supported());
 80125ac:	4b75      	ldr	r3, [pc, #468]	; (8012784 <handle_command_complete_event+0x590>)
 80125ae:	681b      	ldr	r3, [r3, #0]
 80125b0:	f8b3 3714 	ldrh.w	r3, [r3, #1812]	; 0x714
 80125b4:	461c      	mov	r4, r3
 80125b6:	f7fe f907 	bl	80107c8 <hci_extended_sco_link_supported>
 80125ba:	4603      	mov	r3, r0
 80125bc:	9301      	str	r3, [sp, #4]
 80125be:	9400      	str	r4, [sp, #0]
 80125c0:	f640 0337 	movw	r3, #2103	; 0x837
 80125c4:	4a70      	ldr	r2, [pc, #448]	; (8012788 <handle_command_complete_event+0x594>)
 80125c6:	4973      	ldr	r1, [pc, #460]	; (8012794 <handle_command_complete_event+0x5a0>)
 80125c8:	2001      	movs	r0, #1
 80125ca:	f004 ff39 	bl	8017440 <hci_dump_log>
            log_info("BR/EDR support %u, LE support %u", hci_classic_supported(), hci_le_supported());
 80125ce:	f7fe f935 	bl	801083c <hci_classic_supported>
 80125d2:	4604      	mov	r4, r0
 80125d4:	f7fe f946 	bl	8010864 <hci_le_supported>
 80125d8:	4603      	mov	r3, r0
 80125da:	9301      	str	r3, [sp, #4]
 80125dc:	9400      	str	r4, [sp, #0]
 80125de:	f640 033a 	movw	r3, #2106	; 0x83a
 80125e2:	4a69      	ldr	r2, [pc, #420]	; (8012788 <handle_command_complete_event+0x594>)
 80125e4:	496c      	ldr	r1, [pc, #432]	; (8012798 <handle_command_complete_event+0x5a4>)
 80125e6:	2001      	movs	r0, #1
 80125e8:	f004 ff2a 	bl	8017440 <hci_dump_log>
            break;
 80125ec:	e124      	b.n	8012838 <handle_command_complete_event+0x644>
            manufacturer = little_endian_read_16(packet, 10);
 80125ee:	210a      	movs	r1, #10
 80125f0:	6878      	ldr	r0, [r7, #4]
 80125f2:	f7fc fbf8 	bl	800ede6 <little_endian_read_16>
 80125f6:	4603      	mov	r3, r0
 80125f8:	84fb      	strh	r3, [r7, #38]	; 0x26
            if (manufacturer  == BLUETOOTH_COMPANY_ID_CYPRESS_SEMICONDUCTOR){
 80125fa:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80125fc:	f240 1231 	movw	r2, #305	; 0x131
 8012600:	4293      	cmp	r3, r2
 8012602:	d10e      	bne.n	8012622 <handle_command_complete_event+0x42e>
                log_info("Treat Cypress as Broadcom");
 8012604:	f44f 6304 	mov.w	r3, #2112	; 0x840
 8012608:	4a5f      	ldr	r2, [pc, #380]	; (8012788 <handle_command_complete_event+0x594>)
 801260a:	4964      	ldr	r1, [pc, #400]	; (801279c <handle_command_complete_event+0x5a8>)
 801260c:	2001      	movs	r0, #1
 801260e:	f004 ff17 	bl	8017440 <hci_dump_log>
                manufacturer = BLUETOOTH_COMPANY_ID_BROADCOM_CORPORATION;
 8012612:	230f      	movs	r3, #15
 8012614:	84fb      	strh	r3, [r7, #38]	; 0x26
                little_endian_store_16(packet, 10, manufacturer);
 8012616:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8012618:	461a      	mov	r2, r3
 801261a:	210a      	movs	r1, #10
 801261c:	6878      	ldr	r0, [r7, #4]
 801261e:	f7fc fc22 	bl	800ee66 <little_endian_store_16>
            hci_stack->manufacturer = manufacturer;
 8012622:	4b58      	ldr	r3, [pc, #352]	; (8012784 <handle_command_complete_event+0x590>)
 8012624:	681b      	ldr	r3, [r3, #0]
 8012626:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8012628:	f8a3 2712 	strh.w	r2, [r3, #1810]	; 0x712
            log_info("Manufacturer: 0x%04x", hci_stack->manufacturer);
 801262c:	4b55      	ldr	r3, [pc, #340]	; (8012784 <handle_command_complete_event+0x590>)
 801262e:	681b      	ldr	r3, [r3, #0]
 8012630:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 8012634:	9300      	str	r3, [sp, #0]
 8012636:	f640 0345 	movw	r3, #2117	; 0x845
 801263a:	4a53      	ldr	r2, [pc, #332]	; (8012788 <handle_command_complete_event+0x594>)
 801263c:	4958      	ldr	r1, [pc, #352]	; (80127a0 <handle_command_complete_event+0x5ac>)
 801263e:	2001      	movs	r0, #1
 8012640:	f004 fefe 	bl	8017440 <hci_dump_log>
            break;
 8012644:	e0f8      	b.n	8012838 <handle_command_complete_event+0x644>
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+14u] & 0x80u) >> 7u) |  // bit  0 = Octet 14, bit 7 / Read Buffer Size
 8012646:	687b      	ldr	r3, [r7, #4]
 8012648:	3314      	adds	r3, #20
 801264a:	781b      	ldrb	r3, [r3, #0]
 801264c:	09db      	lsrs	r3, r3, #7
 801264e:	b2da      	uxtb	r2, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+24u] & 0x40u) >> 5u) |  // bit  1 = Octet 24, bit 6 / Write Le Host Supported
 8012650:	687b      	ldr	r3, [r7, #4]
 8012652:	331e      	adds	r3, #30
 8012654:	781b      	ldrb	r3, [r3, #0]
 8012656:	095b      	lsrs	r3, r3, #5
 8012658:	b2db      	uxtb	r3, r3
 801265a:	f003 0302 	and.w	r3, r3, #2
 801265e:	b2db      	uxtb	r3, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+14u] & 0x80u) >> 7u) |  // bit  0 = Octet 14, bit 7 / Read Buffer Size
 8012660:	4313      	orrs	r3, r2
 8012662:	b2da      	uxtb	r2, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+10u] & 0x10u) >> 2u) |  // bit  2 = Octet 10, bit 4 / Write Synchronous Flow Control Enable
 8012664:	687b      	ldr	r3, [r7, #4]
 8012666:	3310      	adds	r3, #16
 8012668:	781b      	ldrb	r3, [r3, #0]
 801266a:	089b      	lsrs	r3, r3, #2
 801266c:	b2db      	uxtb	r3, r3
 801266e:	f003 0304 	and.w	r3, r3, #4
 8012672:	b2db      	uxtb	r3, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+24u] & 0x40u) >> 5u) |  // bit  1 = Octet 24, bit 6 / Write Le Host Supported
 8012674:	4313      	orrs	r3, r2
 8012676:	b2da      	uxtb	r2, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+18u] & 0x08u)     )  |  // bit  3 = Octet 18, bit 3 / Write Default Erroneous Data Reporting
 8012678:	687b      	ldr	r3, [r7, #4]
 801267a:	3318      	adds	r3, #24
 801267c:	781b      	ldrb	r3, [r3, #0]
 801267e:	f003 0308 	and.w	r3, r3, #8
 8012682:	b2db      	uxtb	r3, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+10u] & 0x10u) >> 2u) |  // bit  2 = Octet 10, bit 4 / Write Synchronous Flow Control Enable
 8012684:	4313      	orrs	r3, r2
 8012686:	b2da      	uxtb	r2, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+34u] & 0x01u) << 4u) |  // bit  4 = Octet 34, bit 0 / LE Write Suggested Default Data Length
 8012688:	687b      	ldr	r3, [r7, #4]
 801268a:	3328      	adds	r3, #40	; 0x28
 801268c:	781b      	ldrb	r3, [r3, #0]
 801268e:	011b      	lsls	r3, r3, #4
 8012690:	b2db      	uxtb	r3, r3
 8012692:	f003 0310 	and.w	r3, r3, #16
 8012696:	b2db      	uxtb	r3, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+18u] & 0x08u)     )  |  // bit  3 = Octet 18, bit 3 / Write Default Erroneous Data Reporting
 8012698:	4313      	orrs	r3, r2
 801269a:	b2da      	uxtb	r2, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+35u] & 0x08u) << 2u) |  // bit  5 = Octet 35, bit 3 / LE Read Maximum Data Length
 801269c:	687b      	ldr	r3, [r7, #4]
 801269e:	3329      	adds	r3, #41	; 0x29
 80126a0:	781b      	ldrb	r3, [r3, #0]
 80126a2:	009b      	lsls	r3, r3, #2
 80126a4:	b2db      	uxtb	r3, r3
 80126a6:	f003 0320 	and.w	r3, r3, #32
 80126aa:	b2db      	uxtb	r3, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+34u] & 0x01u) << 4u) |  // bit  4 = Octet 34, bit 0 / LE Write Suggested Default Data Length
 80126ac:	4313      	orrs	r3, r2
 80126ae:	b2da      	uxtb	r2, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+35u] & 0x20u) << 1u) |  // bit  6 = Octet 35, bit 5 / LE Set Default PHY
 80126b0:	687b      	ldr	r3, [r7, #4]
 80126b2:	3329      	adds	r3, #41	; 0x29
 80126b4:	781b      	ldrb	r3, [r3, #0]
 80126b6:	005b      	lsls	r3, r3, #1
 80126b8:	b2db      	uxtb	r3, r3
 80126ba:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80126be:	b2db      	uxtb	r3, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+35u] & 0x08u) << 2u) |  // bit  5 = Octet 35, bit 3 / LE Read Maximum Data Length
 80126c0:	4313      	orrs	r3, r2
 80126c2:	b2d9      	uxtb	r1, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+20u] & 0x10u) << 3u);   // bit  7 = Octet 20, bit 4 / Read Encryption Key Size
 80126c4:	687b      	ldr	r3, [r7, #4]
 80126c6:	331a      	adds	r3, #26
 80126c8:	781b      	ldrb	r3, [r3, #0]
 80126ca:	00db      	lsls	r3, r3, #3
 80126cc:	b2db      	uxtb	r3, r3
 80126ce:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80126d2:	b2da      	uxtb	r2, r3
            hci_stack->local_supported_commands[0] =
 80126d4:	4b2b      	ldr	r3, [pc, #172]	; (8012784 <handle_command_complete_event+0x590>)
 80126d6:	681b      	ldr	r3, [r3, #0]
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+35u] & 0x20u) << 1u) |  // bit  6 = Octet 35, bit 5 / LE Set Default PHY
 80126d8:	430a      	orrs	r2, r1
 80126da:	b2d2      	uxtb	r2, r2
            hci_stack->local_supported_commands[0] =
 80126dc:	f883 2710 	strb.w	r2, [r3, #1808]	; 0x710
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+ 2u] & 0x40u) >> 6u) |  // bit  8 = Octet  2, bit 6 / Read Remote Extended Features
 80126e0:	687b      	ldr	r3, [r7, #4]
 80126e2:	3308      	adds	r3, #8
 80126e4:	781b      	ldrb	r3, [r3, #0]
 80126e6:	099b      	lsrs	r3, r3, #6
 80126e8:	b2db      	uxtb	r3, r3
 80126ea:	f003 0301 	and.w	r3, r3, #1
 80126ee:	b2da      	uxtb	r2, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+32u] & 0x08u) >> 2u) |  // bit  9 = Octet 32, bit 3 / Write Secure Connections Host
 80126f0:	687b      	ldr	r3, [r7, #4]
 80126f2:	3326      	adds	r3, #38	; 0x26
 80126f4:	781b      	ldrb	r3, [r3, #0]
 80126f6:	089b      	lsrs	r3, r3, #2
 80126f8:	b2db      	uxtb	r3, r3
 80126fa:	f003 0302 	and.w	r3, r3, #2
 80126fe:	b2db      	uxtb	r3, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+ 2u] & 0x40u) >> 6u) |  // bit  8 = Octet  2, bit 6 / Read Remote Extended Features
 8012700:	4313      	orrs	r3, r2
 8012702:	b2da      	uxtb	r2, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+35u] & 0x02u) << 1u) |  // bit 10 = Octet 35, bit 1 / LE Set Address Resolution Enable
 8012704:	687b      	ldr	r3, [r7, #4]
 8012706:	3329      	adds	r3, #41	; 0x29
 8012708:	781b      	ldrb	r3, [r3, #0]
 801270a:	005b      	lsls	r3, r3, #1
 801270c:	b2db      	uxtb	r3, r3
 801270e:	f003 0304 	and.w	r3, r3, #4
 8012712:	b2db      	uxtb	r3, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+32u] & 0x08u) >> 2u) |  // bit  9 = Octet 32, bit 3 / Write Secure Connections Host
 8012714:	4313      	orrs	r3, r2
 8012716:	b2da      	uxtb	r2, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+32u] & 0x02u) << 2u) |  // bit 11 = Octet 32, bit 1 / Remote OOB Extended Data Request Reply
 8012718:	687b      	ldr	r3, [r7, #4]
 801271a:	3326      	adds	r3, #38	; 0x26
 801271c:	781b      	ldrb	r3, [r3, #0]
 801271e:	009b      	lsls	r3, r3, #2
 8012720:	b2db      	uxtb	r3, r3
 8012722:	f003 0308 	and.w	r3, r3, #8
 8012726:	b2db      	uxtb	r3, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+35u] & 0x02u) << 1u) |  // bit 10 = Octet 35, bit 1 / LE Set Address Resolution Enable
 8012728:	4313      	orrs	r3, r2
 801272a:	b2d9      	uxtb	r1, r3
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+32u] & 0x40u) >> 2u);   // bit 12 = Octet 32, bit 6 / Read Local OOB Extended Data command
 801272c:	687b      	ldr	r3, [r7, #4]
 801272e:	3326      	adds	r3, #38	; 0x26
 8012730:	781b      	ldrb	r3, [r3, #0]
 8012732:	089b      	lsrs	r3, r3, #2
 8012734:	b2db      	uxtb	r3, r3
 8012736:	f003 0310 	and.w	r3, r3, #16
 801273a:	b2da      	uxtb	r2, r3
            hci_stack->local_supported_commands[1] =
 801273c:	4b11      	ldr	r3, [pc, #68]	; (8012784 <handle_command_complete_event+0x590>)
 801273e:	681b      	ldr	r3, [r3, #0]
                ((packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1u+32u] & 0x02u) << 2u) |  // bit 11 = Octet 32, bit 1 / Remote OOB Extended Data Request Reply
 8012740:	430a      	orrs	r2, r1
 8012742:	b2d2      	uxtb	r2, r2
            hci_stack->local_supported_commands[1] =
 8012744:	f883 2711 	strb.w	r2, [r3, #1809]	; 0x711
            log_info("Local supported commands summary %02x - %02x", hci_stack->local_supported_commands[0],  hci_stack->local_supported_commands[1]);
 8012748:	4b0e      	ldr	r3, [pc, #56]	; (8012784 <handle_command_complete_event+0x590>)
 801274a:	681b      	ldr	r3, [r3, #0]
 801274c:	f893 3710 	ldrb.w	r3, [r3, #1808]	; 0x710
 8012750:	461a      	mov	r2, r3
 8012752:	4b0c      	ldr	r3, [pc, #48]	; (8012784 <handle_command_complete_event+0x590>)
 8012754:	681b      	ldr	r3, [r3, #0]
 8012756:	f893 3711 	ldrb.w	r3, [r3, #1809]	; 0x711
 801275a:	9301      	str	r3, [sp, #4]
 801275c:	9200      	str	r2, [sp, #0]
 801275e:	f640 0357 	movw	r3, #2135	; 0x857
 8012762:	4a09      	ldr	r2, [pc, #36]	; (8012788 <handle_command_complete_event+0x594>)
 8012764:	490f      	ldr	r1, [pc, #60]	; (80127a4 <handle_command_complete_event+0x5b0>)
 8012766:	2001      	movs	r0, #1
 8012768:	f004 fe6a 	bl	8017440 <hci_dump_log>
            break;
 801276c:	e064      	b.n	8012838 <handle_command_complete_event+0x644>
            if (packet[5]) return;
 801276e:	687b      	ldr	r3, [r7, #4]
 8012770:	3305      	adds	r3, #5
 8012772:	781b      	ldrb	r3, [r3, #0]
 8012774:	2b00      	cmp	r3, #0
 8012776:	d15c      	bne.n	8012832 <handle_command_complete_event+0x63e>
            hci_stack->synchronous_flow_control_enabled = 1;
 8012778:	4b02      	ldr	r3, [pc, #8]	; (8012784 <handle_command_complete_event+0x590>)
 801277a:	681b      	ldr	r3, [r3, #0]
 801277c:	2201      	movs	r2, #1
 801277e:	f883 2702 	strb.w	r2, [r3, #1794]	; 0x702
            break;
 8012782:	e059      	b.n	8012838 <handle_command_complete_event+0x644>
 8012784:	20009780 	.word	0x20009780
 8012788:	0802929c 	.word	0x0802929c
 801278c:	08029f88 	.word	0x08029f88
 8012790:	0802a0f8 	.word	0x0802a0f8
 8012794:	08029fb8 	.word	0x08029fb8
 8012798:	08029fdc 	.word	0x08029fdc
 801279c:	0802a004 	.word	0x0802a004
 80127a0:	0802a028 	.word	0x0802a028
 80127a4:	0802a044 	.word	0x0802a044
            status = packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE];
 80127a8:	687b      	ldr	r3, [r7, #4]
 80127aa:	795b      	ldrb	r3, [r3, #5]
 80127ac:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
            handle = little_endian_read_16(packet, OFFSET_OF_DATA_IN_COMMAND_COMPLETE+1);
 80127b0:	2106      	movs	r1, #6
 80127b2:	6878      	ldr	r0, [r7, #4]
 80127b4:	f7fc fb17 	bl	800ede6 <little_endian_read_16>
 80127b8:	4603      	mov	r3, r0
 80127ba:	83fb      	strh	r3, [r7, #30]
            conn   = hci_connection_for_handle(handle);
 80127bc:	8bfb      	ldrh	r3, [r7, #30]
 80127be:	4618      	mov	r0, r3
 80127c0:	f7fd f880 	bl	800f8c4 <hci_connection_for_handle>
 80127c4:	61b8      	str	r0, [r7, #24]
            if (conn != NULL) {
 80127c6:	69bb      	ldr	r3, [r7, #24]
 80127c8:	2b00      	cmp	r3, #0
 80127ca:	d034      	beq.n	8012836 <handle_command_complete_event+0x642>
                uint8_t key_size = 0;
 80127cc:	2300      	movs	r3, #0
 80127ce:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
                if (status == 0){
 80127d2:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80127d6:	2b00      	cmp	r3, #0
 80127d8:	d110      	bne.n	80127fc <handle_command_complete_event+0x608>
                    key_size = packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE+3];
 80127da:	687b      	ldr	r3, [r7, #4]
 80127dc:	7a1b      	ldrb	r3, [r3, #8]
 80127de:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
                    log_info("Handle %04x key Size: %u", handle, key_size);
 80127e2:	8bfb      	ldrh	r3, [r7, #30]
 80127e4:	f897 2025 	ldrb.w	r2, [r7, #37]	; 0x25
 80127e8:	9201      	str	r2, [sp, #4]
 80127ea:	9300      	str	r3, [sp, #0]
 80127ec:	f640 0366 	movw	r3, #2150	; 0x866
 80127f0:	4a13      	ldr	r2, [pc, #76]	; (8012840 <handle_command_complete_event+0x64c>)
 80127f2:	4914      	ldr	r1, [pc, #80]	; (8012844 <handle_command_complete_event+0x650>)
 80127f4:	2001      	movs	r0, #1
 80127f6:	f004 fe23 	bl	8017440 <hci_dump_log>
 80127fa:	e009      	b.n	8012810 <handle_command_complete_event+0x61c>
                    log_info("Read Encryption Key Size failed 0x%02x-> assuming insecure connection with key size of 1", status);
 80127fc:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8012800:	9300      	str	r3, [sp, #0]
 8012802:	f640 0368 	movw	r3, #2152	; 0x868
 8012806:	4a0e      	ldr	r2, [pc, #56]	; (8012840 <handle_command_complete_event+0x64c>)
 8012808:	490f      	ldr	r1, [pc, #60]	; (8012848 <handle_command_complete_event+0x654>)
 801280a:	2001      	movs	r0, #1
 801280c:	f004 fe18 	bl	8017440 <hci_dump_log>
                hci_handle_read_encryption_key_size_complete(conn, key_size);
 8012810:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
 8012814:	4619      	mov	r1, r3
 8012816:	69b8      	ldr	r0, [r7, #24]
 8012818:	f7ff fcba 	bl	8012190 <hci_handle_read_encryption_key_size_complete>
            break;
 801281c:	e00b      	b.n	8012836 <handle_command_complete_event+0x642>
            if (packet[5]) break;
 801281e:	bf00      	nop
 8012820:	e00a      	b.n	8012838 <handle_command_complete_event+0x644>
            break;
 8012822:	bf00      	nop
 8012824:	e008      	b.n	8012838 <handle_command_complete_event+0x644>
            break;
 8012826:	bf00      	nop
 8012828:	e006      	b.n	8012838 <handle_command_complete_event+0x644>
            break;
 801282a:	bf00      	nop
 801282c:	e004      	b.n	8012838 <handle_command_complete_event+0x644>
            break;
 801282e:	bf00      	nop
 8012830:	e002      	b.n	8012838 <handle_command_complete_event+0x644>
            if (packet[5]) return;
 8012832:	bf00      	nop
 8012834:	e000      	b.n	8012838 <handle_command_complete_event+0x644>
            break;
 8012836:	bf00      	nop
    }
}
 8012838:	372c      	adds	r7, #44	; 0x2c
 801283a:	46bd      	mov	sp, r7
 801283c:	bd90      	pop	{r4, r7, pc}
 801283e:	bf00      	nop
 8012840:	0802929c 	.word	0x0802929c
 8012844:	0802a078 	.word	0x0802a078
 8012848:	0802a098 	.word	0x0802a098

0801284c <event_handle_le_connection_complete>:

#ifdef ENABLE_BLE
static void event_handle_le_connection_complete(const uint8_t * packet){
 801284c:	b5b0      	push	{r4, r5, r7, lr}
 801284e:	b08a      	sub	sp, #40	; 0x28
 8012850:	af04      	add	r7, sp, #16
 8012852:	6078      	str	r0, [r7, #4]
	bd_addr_t addr;
	bd_addr_type_t addr_type;
	hci_connection_t * conn;

	// Connection management
	reverse_bd_addr(&packet[8], addr);
 8012854:	687b      	ldr	r3, [r7, #4]
 8012856:	3308      	adds	r3, #8
 8012858:	f107 020c 	add.w	r2, r7, #12
 801285c:	4611      	mov	r1, r2
 801285e:	4618      	mov	r0, r3
 8012860:	f7fc fc47 	bl	800f0f2 <reverse_bd_addr>
	addr_type = (bd_addr_type_t)packet[7];
 8012864:	687b      	ldr	r3, [r7, #4]
 8012866:	3307      	adds	r3, #7
 8012868:	781b      	ldrb	r3, [r3, #0]
 801286a:	74fb      	strb	r3, [r7, #19]
	log_info("LE Connection_complete (status=%u) type %u, %s", packet[3], addr_type, bd_addr_to_str(addr));
 801286c:	687b      	ldr	r3, [r7, #4]
 801286e:	3303      	adds	r3, #3
 8012870:	781b      	ldrb	r3, [r3, #0]
 8012872:	461d      	mov	r5, r3
 8012874:	7cfc      	ldrb	r4, [r7, #19]
 8012876:	f107 030c 	add.w	r3, r7, #12
 801287a:	4618      	mov	r0, r3
 801287c:	f7fc fdc8 	bl	800f410 <bd_addr_to_str>
 8012880:	4603      	mov	r3, r0
 8012882:	9302      	str	r3, [sp, #8]
 8012884:	9401      	str	r4, [sp, #4]
 8012886:	9500      	str	r5, [sp, #0]
 8012888:	f44f 6309 	mov.w	r3, #2192	; 0x890
 801288c:	4a4e      	ldr	r2, [pc, #312]	; (80129c8 <event_handle_le_connection_complete+0x17c>)
 801288e:	494f      	ldr	r1, [pc, #316]	; (80129cc <event_handle_le_connection_complete+0x180>)
 8012890:	2001      	movs	r0, #1
 8012892:	f004 fdd5 	bl	8017440 <hci_dump_log>
	conn = hci_connection_for_bd_addr_and_type(addr, addr_type);
 8012896:	7cfa      	ldrb	r2, [r7, #19]
 8012898:	f107 030c 	add.w	r3, r7, #12
 801289c:	4611      	mov	r1, r2
 801289e:	4618      	mov	r0, r3
 80128a0:	f7fd f83c 	bl	800f91c <hci_connection_for_bd_addr_and_type>
 80128a4:	6178      	str	r0, [r7, #20]

#ifdef ENABLE_LE_CENTRAL
	// handle error: error is reported only to the initiator -> outgoing connection
	if (packet[3]){
 80128a6:	687b      	ldr	r3, [r7, #4]
 80128a8:	3303      	adds	r3, #3
 80128aa:	781b      	ldrb	r3, [r3, #0]
 80128ac:	2b00      	cmp	r3, #0
 80128ae:	d021      	beq.n	80128f4 <event_handle_le_connection_complete+0xa8>

		// handle cancelled outgoing connection
		// "If the cancellation was successful then, after the Command Complete event for the LE_Create_Connection_Cancel command,
		//  either an LE Connection Complete or an LE Enhanced Connection Complete event shall be generated.
		//  In either case, the event shall be sent with the error code Unknown Connection Identifier (0x02)."
		if (packet[3] == ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER){
 80128b0:	687b      	ldr	r3, [r7, #4]
 80128b2:	3303      	adds	r3, #3
 80128b4:	781b      	ldrb	r3, [r3, #0]
 80128b6:	2b02      	cmp	r3, #2
 80128b8:	d10e      	bne.n	80128d8 <event_handle_le_connection_complete+0x8c>
			// whitelist connect
			if (hci_is_le_connection_type(addr_type)){
 80128ba:	7cfb      	ldrb	r3, [r7, #19]
 80128bc:	4618      	mov	r0, r3
 80128be:	f7fd f973 	bl	800fba8 <hci_is_le_connection_type>
 80128c2:	4603      	mov	r3, r0
 80128c4:	2b00      	cmp	r3, #0
 80128c6:	d004      	beq.n	80128d2 <event_handle_le_connection_complete+0x86>
				hci_stack->le_connecting_state   = LE_CONNECTING_IDLE;
 80128c8:	4b41      	ldr	r3, [pc, #260]	; (80129d0 <event_handle_le_connection_complete+0x184>)
 80128ca:	681b      	ldr	r3, [r3, #0]
 80128cc:	2200      	movs	r2, #0
 80128ce:	f883 2766 	strb.w	r2, [r3, #1894]	; 0x766
			}
			// get outgoing connection conn struct for direct connect
			conn = gap_get_outgoing_connection();
 80128d2:	f004 f805 	bl	80168e0 <gap_get_outgoing_connection>
 80128d6:	6178      	str	r0, [r7, #20]
		}

		// outgoing le connection establishment is done
		if (conn){
 80128d8:	697b      	ldr	r3, [r7, #20]
 80128da:	2b00      	cmp	r3, #0
 80128dc:	d06e      	beq.n	80129bc <event_handle_le_connection_complete+0x170>
			// remove entry
			btstack_linked_list_remove(&hci_stack->connections, (btstack_linked_item_t *) conn);
 80128de:	4b3c      	ldr	r3, [pc, #240]	; (80129d0 <event_handle_le_connection_complete+0x184>)
 80128e0:	681b      	ldr	r3, [r3, #0]
 80128e2:	3314      	adds	r3, #20
 80128e4:	6979      	ldr	r1, [r7, #20]
 80128e6:	4618      	mov	r0, r3
 80128e8:	f7fb fee9 	bl	800e6be <btstack_linked_list_remove>
			btstack_memory_hci_connection_free( conn );
 80128ec:	6978      	ldr	r0, [r7, #20]
 80128ee:	f7fb ffcb 	bl	800e888 <btstack_memory_hci_connection_free>
		}
		return;
 80128f2:	e063      	b.n	80129bc <event_handle_le_connection_complete+0x170>
	}
#endif

	// on success, both hosts receive connection complete event
	if (packet[6] == HCI_ROLE_MASTER){
 80128f4:	687b      	ldr	r3, [r7, #4]
 80128f6:	3306      	adds	r3, #6
 80128f8:	781b      	ldrb	r3, [r3, #0]
 80128fa:	2b00      	cmp	r3, #0
 80128fc:	d111      	bne.n	8012922 <event_handle_le_connection_complete+0xd6>
#ifdef ENABLE_LE_CENTRAL
		// if we're master on an le connection, it was an outgoing connection and we're done with it
		// note: no hci_connection_t object exists yet for connect with whitelist
		if (hci_is_le_connection_type(addr_type)){
 80128fe:	7cfb      	ldrb	r3, [r7, #19]
 8012900:	4618      	mov	r0, r3
 8012902:	f7fd f951 	bl	800fba8 <hci_is_le_connection_type>
 8012906:	4603      	mov	r3, r0
 8012908:	2b00      	cmp	r3, #0
 801290a:	d00f      	beq.n	801292c <event_handle_le_connection_complete+0xe0>
			hci_stack->le_connecting_state   = LE_CONNECTING_IDLE;
 801290c:	4b30      	ldr	r3, [pc, #192]	; (80129d0 <event_handle_le_connection_complete+0x184>)
 801290e:	681b      	ldr	r3, [r3, #0]
 8012910:	2200      	movs	r2, #0
 8012912:	f883 2766 	strb.w	r2, [r3, #1894]	; 0x766
			hci_stack->le_connecting_request = LE_CONNECTING_IDLE;
 8012916:	4b2e      	ldr	r3, [pc, #184]	; (80129d0 <event_handle_le_connection_complete+0x184>)
 8012918:	681b      	ldr	r3, [r3, #0]
 801291a:	2200      	movs	r2, #0
 801291c:	f883 2767 	strb.w	r2, [r3, #1895]	; 0x767
 8012920:	e004      	b.n	801292c <event_handle_le_connection_complete+0xe0>
		}
#endif
	} else {
#ifdef ENABLE_LE_PERIPHERAL
		// if we're slave, it was an incoming connection, advertisements have stopped
		hci_stack->le_advertisements_active = false;
 8012922:	4b2b      	ldr	r3, [pc, #172]	; (80129d0 <event_handle_le_connection_complete+0x184>)
 8012924:	681b      	ldr	r3, [r3, #0]
 8012926:	2200      	movs	r2, #0
 8012928:	f883 2799 	strb.w	r2, [r3, #1945]	; 0x799
#endif
	}

	// LE connections are auto-accepted, so just create a connection if there isn't one already
	if (!conn){
 801292c:	697b      	ldr	r3, [r7, #20]
 801292e:	2b00      	cmp	r3, #0
 8012930:	d107      	bne.n	8012942 <event_handle_le_connection_complete+0xf6>
		conn = create_connection_for_bd_addr_and_type(addr, addr_type);
 8012932:	7cfa      	ldrb	r2, [r7, #19]
 8012934:	f107 030c 	add.w	r3, r7, #12
 8012938:	4611      	mov	r1, r2
 801293a:	4618      	mov	r0, r3
 801293c:	f7fc feec 	bl	800f718 <create_connection_for_bd_addr_and_type>
 8012940:	6178      	str	r0, [r7, #20]
	}

	// no memory, sorry.
	if (!conn){
 8012942:	697b      	ldr	r3, [r7, #20]
 8012944:	2b00      	cmp	r3, #0
 8012946:	d03b      	beq.n	80129c0 <event_handle_le_connection_complete+0x174>
		return;
	}

	conn->state = OPEN;
 8012948:	697b      	ldr	r3, [r7, #20]
 801294a:	2207      	movs	r2, #7
 801294c:	739a      	strb	r2, [r3, #14]
	conn->role  = packet[6];
 801294e:	687b      	ldr	r3, [r7, #4]
 8012950:	799a      	ldrb	r2, [r3, #6]
 8012952:	697b      	ldr	r3, [r7, #20]
 8012954:	735a      	strb	r2, [r3, #13]
	conn->con_handle             = hci_subevent_le_connection_complete_get_connection_handle(packet);
 8012956:	6878      	ldr	r0, [r7, #4]
 8012958:	f7fc fe68 	bl	800f62c <hci_subevent_le_connection_complete_get_connection_handle>
 801295c:	4603      	mov	r3, r0
 801295e:	461a      	mov	r2, r3
 8012960:	697b      	ldr	r3, [r7, #20]
 8012962:	815a      	strh	r2, [r3, #10]
	conn->le_connection_interval = hci_subevent_le_connection_complete_get_conn_interval(packet);
 8012964:	6878      	ldr	r0, [r7, #4]
 8012966:	f7fc fe6e 	bl	800f646 <hci_subevent_le_connection_complete_get_conn_interval>
 801296a:	4603      	mov	r3, r0
 801296c:	461a      	mov	r2, r3
 801296e:	697b      	ldr	r3, [r7, #20]
 8012970:	f8a3 2716 	strh.w	r2, [r3, #1814]	; 0x716

#ifdef ENABLE_LE_PERIPHERAL
	if (packet[6] == HCI_ROLE_SLAVE){
 8012974:	687b      	ldr	r3, [r7, #4]
 8012976:	3306      	adds	r3, #6
 8012978:	781b      	ldrb	r3, [r3, #0]
 801297a:	2b01      	cmp	r3, #1
 801297c:	d101      	bne.n	8012982 <event_handle_le_connection_complete+0x136>
		hci_update_advertisements_enabled_for_current_roles();
 801297e:	f7fe f851 	bl	8010a24 <hci_update_advertisements_enabled_for_current_roles>
	}
#endif

    // init unenhanced att bearer mtu
    conn->att_connection.mtu = ATT_DEFAULT_MTU;
 8012982:	697b      	ldr	r3, [r7, #20]
 8012984:	2217      	movs	r2, #23
 8012986:	f8a3 274a 	strh.w	r2, [r3, #1866]	; 0x74a
    conn->att_connection.mtu_exchanged = false;
 801298a:	697b      	ldr	r3, [r7, #20]
 801298c:	2200      	movs	r2, #0
 801298e:	f883 274e 	strb.w	r2, [r3, #1870]	; 0x74e

	// restart timer
	// btstack_run_loop_set_timer(&conn->timeout, HCI_CONNECTION_TIMEOUT_MS);
	// btstack_run_loop_add_timer(&conn->timeout);

	log_info("New connection: handle %u, %s", conn->con_handle, bd_addr_to_str(conn->address));
 8012992:	697b      	ldr	r3, [r7, #20]
 8012994:	895b      	ldrh	r3, [r3, #10]
 8012996:	461c      	mov	r4, r3
 8012998:	697b      	ldr	r3, [r7, #20]
 801299a:	3304      	adds	r3, #4
 801299c:	4618      	mov	r0, r3
 801299e:	f7fc fd37 	bl	800f410 <bd_addr_to_str>
 80129a2:	4603      	mov	r3, r0
 80129a4:	9301      	str	r3, [sp, #4]
 80129a6:	9400      	str	r4, [sp, #0]
 80129a8:	f640 03de 	movw	r3, #2270	; 0x8de
 80129ac:	4a06      	ldr	r2, [pc, #24]	; (80129c8 <event_handle_le_connection_complete+0x17c>)
 80129ae:	4909      	ldr	r1, [pc, #36]	; (80129d4 <event_handle_le_connection_complete+0x188>)
 80129b0:	2001      	movs	r0, #1
 80129b2:	f004 fd45 	bl	8017440 <hci_dump_log>

	hci_emit_nr_connections_changed();
 80129b6:	f003 fd93 	bl	80164e0 <hci_emit_nr_connections_changed>
 80129ba:	e002      	b.n	80129c2 <event_handle_le_connection_complete+0x176>
		return;
 80129bc:	bf00      	nop
 80129be:	e000      	b.n	80129c2 <event_handle_le_connection_complete+0x176>
		return;
 80129c0:	bf00      	nop
}
 80129c2:	3718      	adds	r7, #24
 80129c4:	46bd      	mov	sp, r7
 80129c6:	bdb0      	pop	{r4, r5, r7, pc}
 80129c8:	0802929c 	.word	0x0802929c
 80129cc:	0802a0fc 	.word	0x0802a0fc
 80129d0:	20009780 	.word	0x20009780
 80129d4:	0802a134 	.word	0x0802a134

080129d8 <event_handler>:
#endif

static void event_handler(uint8_t *packet, uint16_t size){
 80129d8:	b5b0      	push	{r4, r5, r7, lr}
 80129da:	b09e      	sub	sp, #120	; 0x78
 80129dc:	af04      	add	r7, sp, #16
 80129de:	6078      	str	r0, [r7, #4]
 80129e0:	460b      	mov	r3, r1
 80129e2:	807b      	strh	r3, [r7, #2]

    uint16_t event_length = packet[1];
 80129e4:	687b      	ldr	r3, [r7, #4]
 80129e6:	3301      	adds	r3, #1
 80129e8:	781b      	ldrb	r3, [r3, #0]
 80129ea:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56

    // assert packet is complete
    if (size != (event_length + 2u)){
 80129ee:	887a      	ldrh	r2, [r7, #2]
 80129f0:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 80129f4:	3302      	adds	r3, #2
 80129f6:	429a      	cmp	r2, r3
 80129f8:	d012      	beq.n	8012a20 <event_handler+0x48>
        log_error("event_handler called with packet of wrong size %d, expected %u => dropping packet", size, event_length + 2);
 80129fa:	887b      	ldrh	r3, [r7, #2]
 80129fc:	f8b7 2056 	ldrh.w	r2, [r7, #86]	; 0x56
 8012a00:	3202      	adds	r2, #2
 8012a02:	9201      	str	r2, [sp, #4]
 8012a04:	9300      	str	r3, [sp, #0]
 8012a06:	f640 03ea 	movw	r3, #2282	; 0x8ea
 8012a0a:	4a03      	ldr	r2, [pc, #12]	; (8012a18 <event_handler+0x40>)
 8012a0c:	4903      	ldr	r1, [pc, #12]	; (8012a1c <event_handler+0x44>)
 8012a0e:	2002      	movs	r0, #2
 8012a10:	f004 fd16 	bl	8017440 <hci_dump_log>
        return;
 8012a14:	f001 b940 	b.w	8013c98 <event_handler+0x12c0>
 8012a18:	0802929c 	.word	0x0802929c
 8012a1c:	0802a15c 	.word	0x0802a15c
    bd_addr_t addr;
#endif

    // log_info("HCI:EVENT:%02x", hci_event_packet_get_type(packet));
    
    switch (hci_event_packet_get_type(packet)) {
 8012a20:	6878      	ldr	r0, [r7, #4]
 8012a22:	f7fc fd65 	bl	800f4f0 <hci_event_packet_get_type>
 8012a26:	4603      	mov	r3, r0
 8012a28:	3b01      	subs	r3, #1
 8012a2a:	2bfe      	cmp	r3, #254	; 0xfe
 8012a2c:	f201 80ce 	bhi.w	8013bcc <event_handler+0x11f4>
 8012a30:	a201      	add	r2, pc, #4	; (adr r2, 8012a38 <event_handler+0x60>)
 8012a32:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012a36:	bf00      	nop
 8012a38:	08013039 	.word	0x08013039
 8012a3c:	08013a45 	.word	0x08013a45
 8012a40:	080131c3 	.word	0x080131c3
 8012a44:	08013091 	.word	0x08013091
 8012a48:	080138a7 	.word	0x080138a7
 8012a4c:	080137e7 	.word	0x080137e7
 8012a50:	08013075 	.word	0x08013075
 8012a54:	080136c1 	.word	0x080136c1
 8012a58:	08013bcd 	.word	0x08013bcd
 8012a5c:	08013bcd 	.word	0x08013bcd
 8012a60:	08013391 	.word	0x08013391
 8012a64:	08013bcd 	.word	0x08013bcd
 8012a68:	08013bcd 	.word	0x08013bcd
 8012a6c:	08012e35 	.word	0x08012e35
 8012a70:	08012e43 	.word	0x08012e43
 8012a74:	08013977 	.word	0x08013977
 8012a78:	08013bcd 	.word	0x08013bcd
 8012a7c:	080139b3 	.word	0x080139b3
 8012a80:	08012f5d 	.word	0x08012f5d
 8012a84:	08013677 	.word	0x08013677
 8012a88:	08013bcd 	.word	0x08013bcd
 8012a8c:	08013561 	.word	0x08013561
 8012a90:	080134d7 	.word	0x080134d7
 8012a94:	080134ff 	.word	0x080134ff
 8012a98:	08013bcd 	.word	0x08013bcd
 8012a9c:	08013bcd 	.word	0x08013bcd
 8012aa0:	08013bcd 	.word	0x08013bcd
 8012aa4:	08013bcd 	.word	0x08013bcd
 8012aa8:	08013bcd 	.word	0x08013bcd
 8012aac:	08013bcd 	.word	0x08013bcd
 8012ab0:	08013bcd 	.word	0x08013bcd
 8012ab4:	08013bcd 	.word	0x08013bcd
 8012ab8:	08013bcd 	.word	0x08013bcd
 8012abc:	08013a45 	.word	0x08013a45
 8012ac0:	08013403 	.word	0x08013403
 8012ac4:	08013bcd 	.word	0x08013bcd
 8012ac8:	08013bcd 	.word	0x08013bcd
 8012acc:	08013bcd 	.word	0x08013bcd
 8012ad0:	08013bcd 	.word	0x08013bcd
 8012ad4:	08013bcd 	.word	0x08013bcd
 8012ad8:	08013bcd 	.word	0x08013bcd
 8012adc:	08013bcd 	.word	0x08013bcd
 8012ae0:	08013bcd 	.word	0x08013bcd
 8012ae4:	080132bb 	.word	0x080132bb
 8012ae8:	08013bcd 	.word	0x08013bcd
 8012aec:	08013bcd 	.word	0x08013bcd
 8012af0:	08013a45 	.word	0x08013a45
 8012af4:	08013bcd 	.word	0x08013bcd
 8012af8:	080135b7 	.word	0x080135b7
 8012afc:	08013bcd 	.word	0x08013bcd
 8012b00:	0801361f 	.word	0x0801361f
 8012b04:	0801364b 	.word	0x0801364b
 8012b08:	08013bcd 	.word	0x08013bcd
 8012b0c:	08013bcd 	.word	0x08013bcd
 8012b10:	08013bcd 	.word	0x08013bcd
 8012b14:	08013bcd 	.word	0x08013bcd
 8012b18:	08013bcd 	.word	0x08013bcd
 8012b1c:	08013bcd 	.word	0x08013bcd
 8012b20:	08013bcd 	.word	0x08013bcd
 8012b24:	08013bcd 	.word	0x08013bcd
 8012b28:	08013bcd 	.word	0x08013bcd
 8012b2c:	08013a51 	.word	0x08013a51
 8012b30:	08013bcd 	.word	0x08013bcd
 8012b34:	08013bcd 	.word	0x08013bcd
 8012b38:	08013bcd 	.word	0x08013bcd
 8012b3c:	08013bcd 	.word	0x08013bcd
 8012b40:	08013bcd 	.word	0x08013bcd
 8012b44:	08013bcd 	.word	0x08013bcd
 8012b48:	08013bcd 	.word	0x08013bcd
 8012b4c:	08013bcd 	.word	0x08013bcd
 8012b50:	08013bcd 	.word	0x08013bcd
 8012b54:	08013bcd 	.word	0x08013bcd
 8012b58:	08013bcd 	.word	0x08013bcd
 8012b5c:	08013bcd 	.word	0x08013bcd
 8012b60:	08013bcd 	.word	0x08013bcd
 8012b64:	08013bcd 	.word	0x08013bcd
 8012b68:	08013bcd 	.word	0x08013bcd
 8012b6c:	08013bcd 	.word	0x08013bcd
 8012b70:	08013bcd 	.word	0x08013bcd
 8012b74:	08013bcd 	.word	0x08013bcd
 8012b78:	08013bcd 	.word	0x08013bcd
 8012b7c:	08013bcd 	.word	0x08013bcd
 8012b80:	08013bcd 	.word	0x08013bcd
 8012b84:	08013bcd 	.word	0x08013bcd
 8012b88:	08013bcd 	.word	0x08013bcd
 8012b8c:	08013bcd 	.word	0x08013bcd
 8012b90:	08013bcd 	.word	0x08013bcd
 8012b94:	08013bcd 	.word	0x08013bcd
 8012b98:	08013bcd 	.word	0x08013bcd
 8012b9c:	08013bcd 	.word	0x08013bcd
 8012ba0:	08013bcd 	.word	0x08013bcd
 8012ba4:	08013bcd 	.word	0x08013bcd
 8012ba8:	08013bcd 	.word	0x08013bcd
 8012bac:	08013bcd 	.word	0x08013bcd
 8012bb0:	08013bcd 	.word	0x08013bcd
 8012bb4:	08013bcd 	.word	0x08013bcd
 8012bb8:	08013bcd 	.word	0x08013bcd
 8012bbc:	08013bcd 	.word	0x08013bcd
 8012bc0:	08013bcd 	.word	0x08013bcd
 8012bc4:	08013bcd 	.word	0x08013bcd
 8012bc8:	08013bcd 	.word	0x08013bcd
 8012bcc:	08013bcd 	.word	0x08013bcd
 8012bd0:	08013bcd 	.word	0x08013bcd
 8012bd4:	08013bcd 	.word	0x08013bcd
 8012bd8:	08013bcd 	.word	0x08013bcd
 8012bdc:	08013bcd 	.word	0x08013bcd
 8012be0:	08013bcd 	.word	0x08013bcd
 8012be4:	08013bcd 	.word	0x08013bcd
 8012be8:	08013bcd 	.word	0x08013bcd
 8012bec:	080139f9 	.word	0x080139f9
 8012bf0:	08013a35 	.word	0x08013a35
 8012bf4:	08013bcd 	.word	0x08013bcd
 8012bf8:	08013bcd 	.word	0x08013bcd
 8012bfc:	08013bcd 	.word	0x08013bcd
 8012c00:	08013bcd 	.word	0x08013bcd
 8012c04:	08013bcd 	.word	0x08013bcd
 8012c08:	08013bcd 	.word	0x08013bcd
 8012c0c:	08013bcd 	.word	0x08013bcd
 8012c10:	08013bcd 	.word	0x08013bcd
 8012c14:	08013bcd 	.word	0x08013bcd
 8012c18:	08013bcd 	.word	0x08013bcd
 8012c1c:	08013bcd 	.word	0x08013bcd
 8012c20:	08013bcd 	.word	0x08013bcd
 8012c24:	08013bcd 	.word	0x08013bcd
 8012c28:	08013bcd 	.word	0x08013bcd
 8012c2c:	08013bcd 	.word	0x08013bcd
 8012c30:	08013bcd 	.word	0x08013bcd
 8012c34:	08013bcd 	.word	0x08013bcd
 8012c38:	08013bcd 	.word	0x08013bcd
 8012c3c:	08013bcd 	.word	0x08013bcd
 8012c40:	08013bcd 	.word	0x08013bcd
 8012c44:	08013bcd 	.word	0x08013bcd
 8012c48:	08013bcd 	.word	0x08013bcd
 8012c4c:	08013bcd 	.word	0x08013bcd
 8012c50:	08013bcd 	.word	0x08013bcd
 8012c54:	08013bcd 	.word	0x08013bcd
 8012c58:	08013bcd 	.word	0x08013bcd
 8012c5c:	08013bcd 	.word	0x08013bcd
 8012c60:	08013bcd 	.word	0x08013bcd
 8012c64:	08013bcd 	.word	0x08013bcd
 8012c68:	08013bcd 	.word	0x08013bcd
 8012c6c:	08013bcd 	.word	0x08013bcd
 8012c70:	08013bcd 	.word	0x08013bcd
 8012c74:	08013bcd 	.word	0x08013bcd
 8012c78:	08013bcd 	.word	0x08013bcd
 8012c7c:	08013bcd 	.word	0x08013bcd
 8012c80:	08013bcd 	.word	0x08013bcd
 8012c84:	08013bcd 	.word	0x08013bcd
 8012c88:	08013bcd 	.word	0x08013bcd
 8012c8c:	08013bcd 	.word	0x08013bcd
 8012c90:	08013bcd 	.word	0x08013bcd
 8012c94:	08013bcd 	.word	0x08013bcd
 8012c98:	08013bcd 	.word	0x08013bcd
 8012c9c:	08013bcd 	.word	0x08013bcd
 8012ca0:	08013bcd 	.word	0x08013bcd
 8012ca4:	08013bcd 	.word	0x08013bcd
 8012ca8:	08013bcd 	.word	0x08013bcd
 8012cac:	08013bcd 	.word	0x08013bcd
 8012cb0:	08013bcd 	.word	0x08013bcd
 8012cb4:	08013bcd 	.word	0x08013bcd
 8012cb8:	08013bcd 	.word	0x08013bcd
 8012cbc:	08013bcd 	.word	0x08013bcd
 8012cc0:	08013bcd 	.word	0x08013bcd
 8012cc4:	08013bcd 	.word	0x08013bcd
 8012cc8:	08013bcd 	.word	0x08013bcd
 8012ccc:	08013bcd 	.word	0x08013bcd
 8012cd0:	08013bcd 	.word	0x08013bcd
 8012cd4:	08013bcd 	.word	0x08013bcd
 8012cd8:	08013bcd 	.word	0x08013bcd
 8012cdc:	08013bcd 	.word	0x08013bcd
 8012ce0:	08013bcd 	.word	0x08013bcd
 8012ce4:	08013bcd 	.word	0x08013bcd
 8012ce8:	08013bcd 	.word	0x08013bcd
 8012cec:	08013bcd 	.word	0x08013bcd
 8012cf0:	08013bcd 	.word	0x08013bcd
 8012cf4:	08013bcd 	.word	0x08013bcd
 8012cf8:	08013bcd 	.word	0x08013bcd
 8012cfc:	08013bcd 	.word	0x08013bcd
 8012d00:	08013bcd 	.word	0x08013bcd
 8012d04:	08013bcd 	.word	0x08013bcd
 8012d08:	08013bcd 	.word	0x08013bcd
 8012d0c:	08013bcd 	.word	0x08013bcd
 8012d10:	08013bcd 	.word	0x08013bcd
 8012d14:	08013bcd 	.word	0x08013bcd
 8012d18:	08013bcd 	.word	0x08013bcd
 8012d1c:	08013bcd 	.word	0x08013bcd
 8012d20:	08013bcd 	.word	0x08013bcd
 8012d24:	08013bcd 	.word	0x08013bcd
 8012d28:	08013bcd 	.word	0x08013bcd
 8012d2c:	08013bcd 	.word	0x08013bcd
 8012d30:	08013bcd 	.word	0x08013bcd
 8012d34:	08013bcd 	.word	0x08013bcd
 8012d38:	08013bcd 	.word	0x08013bcd
 8012d3c:	08013bcd 	.word	0x08013bcd
 8012d40:	08013bcd 	.word	0x08013bcd
 8012d44:	08013bcd 	.word	0x08013bcd
 8012d48:	08013bcd 	.word	0x08013bcd
 8012d4c:	08013bcd 	.word	0x08013bcd
 8012d50:	08013bcd 	.word	0x08013bcd
 8012d54:	08013bcd 	.word	0x08013bcd
 8012d58:	08013bcd 	.word	0x08013bcd
 8012d5c:	08013bcd 	.word	0x08013bcd
 8012d60:	08013bcd 	.word	0x08013bcd
 8012d64:	08013bcd 	.word	0x08013bcd
 8012d68:	08013bcd 	.word	0x08013bcd
 8012d6c:	08013bcd 	.word	0x08013bcd
 8012d70:	08013bcd 	.word	0x08013bcd
 8012d74:	08013bcd 	.word	0x08013bcd
 8012d78:	08013bcd 	.word	0x08013bcd
 8012d7c:	08013bcd 	.word	0x08013bcd
 8012d80:	08013bcd 	.word	0x08013bcd
 8012d84:	08013bcd 	.word	0x08013bcd
 8012d88:	08013bcd 	.word	0x08013bcd
 8012d8c:	08013bcd 	.word	0x08013bcd
 8012d90:	08013bcd 	.word	0x08013bcd
 8012d94:	08013bcd 	.word	0x08013bcd
 8012d98:	08013bcd 	.word	0x08013bcd
 8012d9c:	08013bcd 	.word	0x08013bcd
 8012da0:	08013bcd 	.word	0x08013bcd
 8012da4:	08013bcd 	.word	0x08013bcd
 8012da8:	08013bcd 	.word	0x08013bcd
 8012dac:	08013bcd 	.word	0x08013bcd
 8012db0:	08013bcd 	.word	0x08013bcd
 8012db4:	08013bcd 	.word	0x08013bcd
 8012db8:	08013bcd 	.word	0x08013bcd
 8012dbc:	08013bcd 	.word	0x08013bcd
 8012dc0:	08013bcd 	.word	0x08013bcd
 8012dc4:	08013bcd 	.word	0x08013bcd
 8012dc8:	08013bcd 	.word	0x08013bcd
 8012dcc:	08013bcd 	.word	0x08013bcd
 8012dd0:	08013bcd 	.word	0x08013bcd
 8012dd4:	08013bcd 	.word	0x08013bcd
 8012dd8:	08013bcd 	.word	0x08013bcd
 8012ddc:	08013bcd 	.word	0x08013bcd
 8012de0:	08013bcd 	.word	0x08013bcd
 8012de4:	08013bcd 	.word	0x08013bcd
 8012de8:	08013bcd 	.word	0x08013bcd
 8012dec:	08013bcd 	.word	0x08013bcd
 8012df0:	08013bcd 	.word	0x08013bcd
 8012df4:	08013bcd 	.word	0x08013bcd
 8012df8:	08013bcd 	.word	0x08013bcd
 8012dfc:	08013bcd 	.word	0x08013bcd
 8012e00:	08013bcd 	.word	0x08013bcd
 8012e04:	08013bcd 	.word	0x08013bcd
 8012e08:	08013bcd 	.word	0x08013bcd
 8012e0c:	08013bcd 	.word	0x08013bcd
 8012e10:	08013bcd 	.word	0x08013bcd
 8012e14:	08013bcd 	.word	0x08013bcd
 8012e18:	08013bcd 	.word	0x08013bcd
 8012e1c:	08013bcd 	.word	0x08013bcd
 8012e20:	08013bcd 	.word	0x08013bcd
 8012e24:	08013bcd 	.word	0x08013bcd
 8012e28:	08013bcd 	.word	0x08013bcd
 8012e2c:	08013bcd 	.word	0x08013bcd
 8012e30:	08013b9b 	.word	0x08013b9b
                        
        case HCI_EVENT_COMMAND_COMPLETE:
            handle_command_complete_event(packet, size);
 8012e34:	887b      	ldrh	r3, [r7, #2]
 8012e36:	4619      	mov	r1, r3
 8012e38:	6878      	ldr	r0, [r7, #4]
 8012e3a:	f7ff f9db 	bl	80121f4 <handle_command_complete_event>
            break;
 8012e3e:	f000 bef8 	b.w	8013c32 <event_handler+0x125a>
            
        case HCI_EVENT_COMMAND_STATUS:
            // get num cmd packets - limit to 1 to reduce complexity
            hci_stack->num_cmd_packets = packet[3] ? 1 : 0;
 8012e42:	687b      	ldr	r3, [r7, #4]
 8012e44:	3303      	adds	r3, #3
 8012e46:	781b      	ldrb	r3, [r3, #0]
 8012e48:	2b00      	cmp	r3, #0
 8012e4a:	bf14      	ite	ne
 8012e4c:	2301      	movne	r3, #1
 8012e4e:	2300      	moveq	r3, #0
 8012e50:	b2da      	uxtb	r2, r3
 8012e52:	4bb2      	ldr	r3, [pc, #712]	; (801311c <event_handler+0x744>)
 8012e54:	681b      	ldr	r3, [r3, #0]
 8012e56:	f883 26fb 	strb.w	r2, [r3, #1787]	; 0x6fb

            // check command status to detected failed outgoing connections
            create_connection_cmd = 0;
 8012e5a:	2300      	movs	r3, #0
 8012e5c:	65fb      	str	r3, [r7, #92]	; 0x5c
#ifdef ENABLE_CLASSIC
            if (HCI_EVENT_IS_COMMAND_STATUS(packet, hci_create_connection)){
 8012e5e:	687b      	ldr	r3, [r7, #4]
 8012e60:	781b      	ldrb	r3, [r3, #0]
 8012e62:	2b0f      	cmp	r3, #15
 8012e64:	d10b      	bne.n	8012e7e <event_handler+0x4a6>
 8012e66:	2104      	movs	r1, #4
 8012e68:	6878      	ldr	r0, [r7, #4]
 8012e6a:	f7fb ffbc 	bl	800ede6 <little_endian_read_16>
 8012e6e:	4603      	mov	r3, r0
 8012e70:	461a      	mov	r2, r3
 8012e72:	4bab      	ldr	r3, [pc, #684]	; (8013120 <event_handler+0x748>)
 8012e74:	881b      	ldrh	r3, [r3, #0]
 8012e76:	429a      	cmp	r2, r3
 8012e78:	d101      	bne.n	8012e7e <event_handler+0x4a6>
                create_connection_cmd = 1;
 8012e7a:	2301      	movs	r3, #1
 8012e7c:	65fb      	str	r3, [r7, #92]	; 0x5c
            }
#endif
#ifdef ENABLE_LE_CENTRAL
            if (HCI_EVENT_IS_COMMAND_STATUS(packet, hci_le_create_connection)){
 8012e7e:	687b      	ldr	r3, [r7, #4]
 8012e80:	781b      	ldrb	r3, [r3, #0]
 8012e82:	2b0f      	cmp	r3, #15
 8012e84:	d10b      	bne.n	8012e9e <event_handler+0x4c6>
 8012e86:	2104      	movs	r1, #4
 8012e88:	6878      	ldr	r0, [r7, #4]
 8012e8a:	f7fb ffac 	bl	800ede6 <little_endian_read_16>
 8012e8e:	4603      	mov	r3, r0
 8012e90:	461a      	mov	r2, r3
 8012e92:	4ba4      	ldr	r3, [pc, #656]	; (8013124 <event_handler+0x74c>)
 8012e94:	881b      	ldrh	r3, [r3, #0]
 8012e96:	429a      	cmp	r2, r3
 8012e98:	d101      	bne.n	8012e9e <event_handler+0x4c6>
                create_connection_cmd = 1;
 8012e9a:	2301      	movs	r3, #1
 8012e9c:	65fb      	str	r3, [r7, #92]	; 0x5c
            }
#endif
            if (create_connection_cmd) {
 8012e9e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012ea0:	2b00      	cmp	r3, #0
 8012ea2:	f000 8695 	beq.w	8013bd0 <event_handler+0x11f8>
                uint8_t status = hci_event_command_status_get_status(packet);
 8012ea6:	6878      	ldr	r0, [r7, #4]
 8012ea8:	f7fc fb89 	bl	800f5be <hci_event_command_status_get_status>
 8012eac:	4603      	mov	r3, r0
 8012eae:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
                addr_type = hci_stack->outgoing_addr_type;
 8012eb2:	4b9a      	ldr	r3, [pc, #616]	; (801311c <event_handler+0x744>)
 8012eb4:	681b      	ldr	r3, [r3, #0]
 8012eb6:	f893 37c0 	ldrb.w	r3, [r3, #1984]	; 0x7c0
 8012eba:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
                conn = hci_connection_for_bd_addr_and_type(hci_stack->outgoing_addr, addr_type);
 8012ebe:	4b97      	ldr	r3, [pc, #604]	; (801311c <event_handler+0x744>)
 8012ec0:	681b      	ldr	r3, [r3, #0]
 8012ec2:	f203 73ba 	addw	r3, r3, #1978	; 0x7ba
 8012ec6:	f897 2039 	ldrb.w	r2, [r7, #57]	; 0x39
 8012eca:	4611      	mov	r1, r2
 8012ecc:	4618      	mov	r0, r3
 8012ece:	f7fc fd25 	bl	800f91c <hci_connection_for_bd_addr_and_type>
 8012ed2:	6678      	str	r0, [r7, #100]	; 0x64
                log_info("command status (create connection), status %x, connection %p, addr %s, type %x", status, conn, bd_addr_to_str(hci_stack->outgoing_addr), addr_type);
 8012ed4:	f897 4038 	ldrb.w	r4, [r7, #56]	; 0x38
 8012ed8:	4b90      	ldr	r3, [pc, #576]	; (801311c <event_handler+0x744>)
 8012eda:	681b      	ldr	r3, [r3, #0]
 8012edc:	f203 73ba 	addw	r3, r3, #1978	; 0x7ba
 8012ee0:	4618      	mov	r0, r3
 8012ee2:	f7fc fa95 	bl	800f410 <bd_addr_to_str>
 8012ee6:	4602      	mov	r2, r0
 8012ee8:	f897 3039 	ldrb.w	r3, [r7, #57]	; 0x39
 8012eec:	9303      	str	r3, [sp, #12]
 8012eee:	9202      	str	r2, [sp, #8]
 8012ef0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8012ef2:	9301      	str	r3, [sp, #4]
 8012ef4:	9400      	str	r4, [sp, #0]
 8012ef6:	f640 1315 	movw	r3, #2325	; 0x915
 8012efa:	4a8b      	ldr	r2, [pc, #556]	; (8013128 <event_handler+0x750>)
 8012efc:	498b      	ldr	r1, [pc, #556]	; (801312c <event_handler+0x754>)
 8012efe:	2001      	movs	r0, #1
 8012f00:	f004 fa9e 	bl	8017440 <hci_dump_log>

                // reset outgoing address info
                memset(hci_stack->outgoing_addr, 0, 6);
 8012f04:	4b85      	ldr	r3, [pc, #532]	; (801311c <event_handler+0x744>)
 8012f06:	681b      	ldr	r3, [r3, #0]
 8012f08:	f203 73ba 	addw	r3, r3, #1978	; 0x7ba
 8012f0c:	2206      	movs	r2, #6
 8012f0e:	2100      	movs	r1, #0
 8012f10:	4618      	mov	r0, r3
 8012f12:	f014 fdd6 	bl	8027ac2 <memset>
                hci_stack->outgoing_addr_type = BD_ADDR_TYPE_UNKNOWN;
 8012f16:	4b81      	ldr	r3, [pc, #516]	; (801311c <event_handler+0x744>)
 8012f18:	681b      	ldr	r3, [r3, #0]
 8012f1a:	22fe      	movs	r2, #254	; 0xfe
 8012f1c:	f883 27c0 	strb.w	r2, [r3, #1984]	; 0x7c0

                // on error
                if (status != ERROR_CODE_SUCCESS){
 8012f20:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8012f24:	2b00      	cmp	r3, #0
 8012f26:	f000 8653 	beq.w	8013bd0 <event_handler+0x11f8>
#ifdef ENABLE_LE_CENTRAL
                    if (hci_is_le_connection_type(addr_type)){
 8012f2a:	f897 3039 	ldrb.w	r3, [r7, #57]	; 0x39
 8012f2e:	4618      	mov	r0, r3
 8012f30:	f7fc fe3a 	bl	800fba8 <hci_is_le_connection_type>
 8012f34:	4603      	mov	r3, r0
 8012f36:	2b00      	cmp	r3, #0
 8012f38:	d004      	beq.n	8012f44 <event_handler+0x56c>
                        hci_stack->le_connecting_state = LE_CONNECTING_IDLE;
 8012f3a:	4b78      	ldr	r3, [pc, #480]	; (801311c <event_handler+0x744>)
 8012f3c:	681b      	ldr	r3, [r3, #0]
 8012f3e:	2200      	movs	r2, #0
 8012f40:	f883 2766 	strb.w	r2, [r3, #1894]	; 0x766
                    }
#endif
                    // error => outgoing connection failed
                    if (conn != NULL){
 8012f44:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8012f46:	2b00      	cmp	r3, #0
 8012f48:	f000 8642 	beq.w	8013bd0 <event_handler+0x11f8>
                        hci_handle_connection_failed(conn, status);
 8012f4c:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8012f50:	4619      	mov	r1, r3
 8012f52:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8012f54:	f7fe fff6 	bl	8011f44 <hci_handle_connection_failed>
                    }
                }
            }
            break;
 8012f58:	f000 be3a 	b.w	8013bd0 <event_handler+0x11f8>

        case HCI_EVENT_NUMBER_OF_COMPLETED_PACKETS:{
            if (size < 3) return;
 8012f5c:	887b      	ldrh	r3, [r7, #2]
 8012f5e:	2b02      	cmp	r3, #2
 8012f60:	f240 8697 	bls.w	8013c92 <event_handler+0x12ba>
            uint16_t num_handles = packet[2];
 8012f64:	687b      	ldr	r3, [r7, #4]
 8012f66:	3302      	adds	r3, #2
 8012f68:	781b      	ldrb	r3, [r3, #0]
 8012f6a:	87bb      	strh	r3, [r7, #60]	; 0x3c
            if (size != (3u + num_handles * 4u)) return;
 8012f6c:	887a      	ldrh	r2, [r7, #2]
 8012f6e:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8012f70:	009b      	lsls	r3, r3, #2
 8012f72:	3303      	adds	r3, #3
 8012f74:	429a      	cmp	r2, r3
 8012f76:	f040 868e 	bne.w	8013c96 <event_handler+0x12be>
            uint16_t offset = 3;
 8012f7a:	2303      	movs	r3, #3
 8012f7c:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
            for (i=0; i<num_handles;i++){
 8012f80:	2300      	movs	r3, #0
 8012f82:	663b      	str	r3, [r7, #96]	; 0x60
 8012f84:	e052      	b.n	801302c <event_handler+0x654>
                handle = little_endian_read_16(packet, offset) & 0x0fffu;
 8012f86:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 8012f8a:	4619      	mov	r1, r3
 8012f8c:	6878      	ldr	r0, [r7, #4]
 8012f8e:	f7fb ff2a 	bl	800ede6 <little_endian_read_16>
 8012f92:	4603      	mov	r3, r0
 8012f94:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8012f98:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
                offset += 2u;
 8012f9c:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 8012fa0:	3302      	adds	r3, #2
 8012fa2:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
                uint16_t num_packets = little_endian_read_16(packet, offset);
 8012fa6:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 8012faa:	4619      	mov	r1, r3
 8012fac:	6878      	ldr	r0, [r7, #4]
 8012fae:	f7fb ff1a 	bl	800ede6 <little_endian_read_16>
 8012fb2:	4603      	mov	r3, r0
 8012fb4:	877b      	strh	r3, [r7, #58]	; 0x3a
                offset += 2u;
 8012fb6:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 8012fba:	3302      	adds	r3, #2
 8012fbc:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
                
                conn = hci_connection_for_handle(handle);
 8012fc0:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8012fc4:	4618      	mov	r0, r3
 8012fc6:	f7fc fc7d 	bl	800f8c4 <hci_connection_for_handle>
 8012fca:	6678      	str	r0, [r7, #100]	; 0x64
                if (!conn){
 8012fcc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8012fce:	2b00      	cmp	r3, #0
 8012fd0:	d10a      	bne.n	8012fe8 <event_handler+0x610>
                    log_error("hci_number_completed_packet lists unused con handle %u", handle);
 8012fd2:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8012fd6:	9300      	str	r3, [sp, #0]
 8012fd8:	f640 1337 	movw	r3, #2359	; 0x937
 8012fdc:	4a52      	ldr	r2, [pc, #328]	; (8013128 <event_handler+0x750>)
 8012fde:	4954      	ldr	r1, [pc, #336]	; (8013130 <event_handler+0x758>)
 8012fe0:	2002      	movs	r0, #2
 8012fe2:	f004 fa2d 	bl	8017440 <hci_dump_log>
                    continue;
 8012fe6:	e01e      	b.n	8013026 <event_handler+0x64e>
                }
                
                if (conn->num_packets_sent >= num_packets){
 8012fe8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8012fea:	f893 370a 	ldrb.w	r3, [r3, #1802]	; 0x70a
 8012fee:	b29b      	uxth	r3, r3
 8012ff0:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 8012ff2:	429a      	cmp	r2, r3
 8012ff4:	d80a      	bhi.n	801300c <event_handler+0x634>
                    conn->num_packets_sent -= num_packets;
 8012ff6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8012ff8:	f893 270a 	ldrb.w	r2, [r3, #1802]	; 0x70a
 8012ffc:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8012ffe:	b2db      	uxtb	r3, r3
 8013000:	1ad3      	subs	r3, r2, r3
 8013002:	b2da      	uxtb	r2, r3
 8013004:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013006:	f883 270a 	strb.w	r2, [r3, #1802]	; 0x70a
 801300a:	e00a      	b.n	8013022 <event_handler+0x64a>
                } else {
                    log_error("hci_number_completed_packets, more packet slots freed then sent.");
 801300c:	f640 133e 	movw	r3, #2366	; 0x93e
 8013010:	4a45      	ldr	r2, [pc, #276]	; (8013128 <event_handler+0x750>)
 8013012:	4948      	ldr	r1, [pc, #288]	; (8013134 <event_handler+0x75c>)
 8013014:	2002      	movs	r0, #2
 8013016:	f004 fa13 	bl	8017440 <hci_dump_log>
                    conn->num_packets_sent = 0;
 801301a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801301c:	2200      	movs	r2, #0
 801301e:	f883 270a 	strb.w	r2, [r3, #1802]	; 0x70a
                }
                // log_info("hci_number_completed_packet %u processed for handle %u, outstanding %u", num_packets, handle, conn->num_packets_sent);

#ifdef ENABLE_CLASSIC
                // For SCO, we do the can_send_now_check here
                hci_notify_if_sco_can_send_now();
 8013022:	f003 f841 	bl	80160a8 <hci_notify_if_sco_can_send_now>
            for (i=0; i<num_handles;i++){
 8013026:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8013028:	3301      	adds	r3, #1
 801302a:	663b      	str	r3, [r7, #96]	; 0x60
 801302c:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 801302e:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8013030:	429a      	cmp	r2, r3
 8013032:	dba8      	blt.n	8012f86 <event_handler+0x5ae>
#endif
            }
            break;
 8013034:	f000 bdfd 	b.w	8013c32 <event_handler+0x125a>
        }

#ifdef ENABLE_CLASSIC
        case HCI_EVENT_INQUIRY_COMPLETE:
            if (hci_stack->inquiry_state == GAP_INQUIRY_STATE_ACTIVE){
 8013038:	4b38      	ldr	r3, [pc, #224]	; (801311c <event_handler+0x744>)
 801303a:	681b      	ldr	r3, [r3, #0]
 801303c:	f893 3731 	ldrb.w	r3, [r3, #1841]	; 0x731
 8013040:	2b80      	cmp	r3, #128	; 0x80
 8013042:	f040 85c7 	bne.w	8013bd4 <event_handler+0x11fc>
                hci_stack->inquiry_state = GAP_INQUIRY_STATE_IDLE;
 8013046:	4b35      	ldr	r3, [pc, #212]	; (801311c <event_handler+0x744>)
 8013048:	681b      	ldr	r3, [r3, #0]
 801304a:	2200      	movs	r2, #0
 801304c:	f883 2731 	strb.w	r2, [r3, #1841]	; 0x731
                uint8_t event[] = { GAP_EVENT_INQUIRY_COMPLETE, 1, 0};
 8013050:	4a39      	ldr	r2, [pc, #228]	; (8013138 <event_handler+0x760>)
 8013052:	f107 0318 	add.w	r3, r7, #24
 8013056:	6812      	ldr	r2, [r2, #0]
 8013058:	4611      	mov	r1, r2
 801305a:	8019      	strh	r1, [r3, #0]
 801305c:	3302      	adds	r3, #2
 801305e:	0c12      	lsrs	r2, r2, #16
 8013060:	701a      	strb	r2, [r3, #0]
                hci_emit_event(event, sizeof(event), 1);
 8013062:	f107 0318 	add.w	r3, r7, #24
 8013066:	2201      	movs	r2, #1
 8013068:	2103      	movs	r1, #3
 801306a:	4618      	mov	r0, r3
 801306c:	f002 ffcc 	bl	8016008 <hci_emit_event>
            }
            break;
 8013070:	f000 bdb0 	b.w	8013bd4 <event_handler+0x11fc>
        case HCI_EVENT_REMOTE_NAME_REQUEST_COMPLETE:
            if (hci_stack->remote_name_state == GAP_REMOTE_NAME_STATE_W4_COMPLETE){
 8013074:	4b29      	ldr	r3, [pc, #164]	; (801311c <event_handler+0x744>)
 8013076:	681b      	ldr	r3, [r3, #0]
 8013078:	f893 373b 	ldrb.w	r3, [r3, #1851]	; 0x73b
 801307c:	2b02      	cmp	r3, #2
 801307e:	f040 85ab 	bne.w	8013bd8 <event_handler+0x1200>
                hci_stack->remote_name_state = GAP_REMOTE_NAME_STATE_IDLE;
 8013082:	4b26      	ldr	r3, [pc, #152]	; (801311c <event_handler+0x744>)
 8013084:	681b      	ldr	r3, [r3, #0]
 8013086:	2200      	movs	r2, #0
 8013088:	f883 273b 	strb.w	r2, [r3, #1851]	; 0x73b
            }
            break;
 801308c:	f000 bda4 	b.w	8013bd8 <event_handler+0x1200>
        case HCI_EVENT_CONNECTION_REQUEST:
            reverse_bd_addr(&packet[2], addr);
 8013090:	687b      	ldr	r3, [r7, #4]
 8013092:	3302      	adds	r3, #2
 8013094:	f107 021c 	add.w	r2, r7, #28
 8013098:	4611      	mov	r1, r2
 801309a:	4618      	mov	r0, r3
 801309c:	f7fc f829 	bl	800f0f2 <reverse_bd_addr>
            link_type = (hci_link_type_t) packet[11];
 80130a0:	687b      	ldr	r3, [r7, #4]
 80130a2:	330b      	adds	r3, #11
 80130a4:	781b      	ldrb	r3, [r3, #0]
 80130a6:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            if (hci_stack->gap_classic_accept_callback != NULL){
 80130aa:	4b1c      	ldr	r3, [pc, #112]	; (801311c <event_handler+0x744>)
 80130ac:	681b      	ldr	r3, [r3, #0]
 80130ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80130b0:	2b00      	cmp	r3, #0
 80130b2:	d01c      	beq.n	80130ee <event_handler+0x716>
                if ((*hci_stack->gap_classic_accept_callback)(addr, link_type) == 0){
 80130b4:	4b19      	ldr	r3, [pc, #100]	; (801311c <event_handler+0x744>)
 80130b6:	681b      	ldr	r3, [r3, #0]
 80130b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80130ba:	f897 102b 	ldrb.w	r1, [r7, #43]	; 0x2b
 80130be:	f107 021c 	add.w	r2, r7, #28
 80130c2:	4610      	mov	r0, r2
 80130c4:	4798      	blx	r3
 80130c6:	4603      	mov	r3, r0
 80130c8:	2b00      	cmp	r3, #0
 80130ca:	d110      	bne.n	80130ee <event_handler+0x716>
                    hci_stack->decline_reason = ERROR_CODE_CONNECTION_REJECTED_DUE_TO_UNACCEPTABLE_BD_ADDR;
 80130cc:	4b13      	ldr	r3, [pc, #76]	; (801311c <event_handler+0x744>)
 80130ce:	681b      	ldr	r3, [r3, #0]
 80130d0:	220f      	movs	r2, #15
 80130d2:	f883 274d 	strb.w	r2, [r3, #1869]	; 0x74d
                    bd_addr_copy(hci_stack->decline_addr, addr);
 80130d6:	4b11      	ldr	r3, [pc, #68]	; (801311c <event_handler+0x744>)
 80130d8:	681b      	ldr	r3, [r3, #0]
 80130da:	f203 734e 	addw	r3, r3, #1870	; 0x74e
 80130de:	f107 021c 	add.w	r2, r7, #28
 80130e2:	4611      	mov	r1, r2
 80130e4:	4618      	mov	r0, r3
 80130e6:	f7fb fe70 	bl	800edca <bd_addr_copy>
                    break;
 80130ea:	f000 bda2 	b.w	8013c32 <event_handler+0x125a>
                }
            } 

            // TODO: eval COD 8-10
            log_info("Connection_incoming: %s, type %u", bd_addr_to_str(addr), (unsigned int) link_type);
 80130ee:	f107 031c 	add.w	r3, r7, #28
 80130f2:	4618      	mov	r0, r3
 80130f4:	f7fc f98c 	bl	800f410 <bd_addr_to_str>
 80130f8:	4602      	mov	r2, r0
 80130fa:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80130fe:	9301      	str	r3, [sp, #4]
 8013100:	9200      	str	r2, [sp, #0]
 8013102:	f640 1364 	movw	r3, #2404	; 0x964
 8013106:	4a08      	ldr	r2, [pc, #32]	; (8013128 <event_handler+0x750>)
 8013108:	490c      	ldr	r1, [pc, #48]	; (801313c <event_handler+0x764>)
 801310a:	2001      	movs	r0, #1
 801310c:	f004 f998 	bl	8017440 <hci_dump_log>
            addr_type = (link_type == HCI_LINK_TYPE_ACL) ? BD_ADDR_TYPE_ACL : BD_ADDR_TYPE_SCO;
 8013110:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8013114:	2b01      	cmp	r3, #1
 8013116:	d113      	bne.n	8013140 <event_handler+0x768>
 8013118:	23fd      	movs	r3, #253	; 0xfd
 801311a:	e012      	b.n	8013142 <event_handler+0x76a>
 801311c:	20009780 	.word	0x20009780
 8013120:	08030a08 	.word	0x08030a08
 8013124:	08030bc0 	.word	0x08030bc0
 8013128:	0802929c 	.word	0x0802929c
 801312c:	0802a1b8 	.word	0x0802a1b8
 8013130:	0802a210 	.word	0x0802a210
 8013134:	0802a250 	.word	0x0802a250
 8013138:	0802a0f8 	.word	0x0802a0f8
 801313c:	0802a298 	.word	0x0802a298
 8013140:	23fc      	movs	r3, #252	; 0xfc
 8013142:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
            conn = hci_connection_for_bd_addr_and_type(addr, addr_type);
 8013146:	f897 2039 	ldrb.w	r2, [r7, #57]	; 0x39
 801314a:	f107 031c 	add.w	r3, r7, #28
 801314e:	4611      	mov	r1, r2
 8013150:	4618      	mov	r0, r3
 8013152:	f7fc fbe3 	bl	800f91c <hci_connection_for_bd_addr_and_type>
 8013156:	6678      	str	r0, [r7, #100]	; 0x64
            if (!conn) {
 8013158:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801315a:	2b00      	cmp	r3, #0
 801315c:	d108      	bne.n	8013170 <event_handler+0x798>
                conn = create_connection_for_bd_addr_and_type(addr, addr_type);
 801315e:	f897 2039 	ldrb.w	r2, [r7, #57]	; 0x39
 8013162:	f107 031c 	add.w	r3, r7, #28
 8013166:	4611      	mov	r1, r2
 8013168:	4618      	mov	r0, r3
 801316a:	f7fc fad5 	bl	800f718 <create_connection_for_bd_addr_and_type>
 801316e:	6678      	str	r0, [r7, #100]	; 0x64
            }
            if (!conn) {
 8013170:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013172:	2b00      	cmp	r3, #0
 8013174:	d110      	bne.n	8013198 <event_handler+0x7c0>
                // CONNECTION REJECTED DUE TO LIMITED RESOURCES (0X0D)
                hci_stack->decline_reason = ERROR_CODE_CONNECTION_REJECTED_DUE_TO_LIMITED_RESOURCES;
 8013176:	4bb8      	ldr	r3, [pc, #736]	; (8013458 <event_handler+0xa80>)
 8013178:	681b      	ldr	r3, [r3, #0]
 801317a:	220d      	movs	r2, #13
 801317c:	f883 274d 	strb.w	r2, [r3, #1869]	; 0x74d
                bd_addr_copy(hci_stack->decline_addr, addr);
 8013180:	4bb5      	ldr	r3, [pc, #724]	; (8013458 <event_handler+0xa80>)
 8013182:	681b      	ldr	r3, [r3, #0]
 8013184:	f203 734e 	addw	r3, r3, #1870	; 0x74e
 8013188:	f107 021c 	add.w	r2, r7, #28
 801318c:	4611      	mov	r1, r2
 801318e:	4618      	mov	r0, r3
 8013190:	f7fb fe1b 	bl	800edca <bd_addr_copy>
                break;
 8013194:	f000 bd4d 	b.w	8013c32 <event_handler+0x125a>
            }
            conn->role  = HCI_ROLE_SLAVE;
 8013198:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801319a:	2201      	movs	r2, #1
 801319c:	735a      	strb	r2, [r3, #13]
            conn->state = RECEIVED_CONNECTION_REQUEST;
 801319e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80131a0:	2204      	movs	r2, #4
 80131a2:	739a      	strb	r2, [r3, #14]
            // store info about eSCO
            if (link_type == HCI_LINK_TYPE_ESCO){
 80131a4:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80131a8:	2b02      	cmp	r3, #2
 80131aa:	d106      	bne.n	80131ba <event_handler+0x7e2>
                conn->remote_supported_features[0] |= 1;
 80131ac:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80131ae:	7d9b      	ldrb	r3, [r3, #22]
 80131b0:	f043 0301 	orr.w	r3, r3, #1
 80131b4:	b2da      	uxtb	r2, r3
 80131b6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80131b8:	759a      	strb	r2, [r3, #22]
            }
            hci_run();
 80131ba:	f002 fb71 	bl	80158a0 <hci_run>
            break;
 80131be:	f000 bd38 	b.w	8013c32 <event_handler+0x125a>
            
        case HCI_EVENT_CONNECTION_COMPLETE:
            // Connection management
            reverse_bd_addr(&packet[5], addr);
 80131c2:	687b      	ldr	r3, [r7, #4]
 80131c4:	3305      	adds	r3, #5
 80131c6:	f107 021c 	add.w	r2, r7, #28
 80131ca:	4611      	mov	r1, r2
 80131cc:	4618      	mov	r0, r3
 80131ce:	f7fb ff90 	bl	800f0f2 <reverse_bd_addr>
            log_info("Connection_complete (status=%u) %s", packet[2], bd_addr_to_str(addr));
 80131d2:	687b      	ldr	r3, [r7, #4]
 80131d4:	3302      	adds	r3, #2
 80131d6:	781b      	ldrb	r3, [r3, #0]
 80131d8:	461c      	mov	r4, r3
 80131da:	f107 031c 	add.w	r3, r7, #28
 80131de:	4618      	mov	r0, r3
 80131e0:	f7fc f916 	bl	800f410 <bd_addr_to_str>
 80131e4:	4603      	mov	r3, r0
 80131e6:	9301      	str	r3, [sp, #4]
 80131e8:	9400      	str	r4, [sp, #0]
 80131ea:	f640 137c 	movw	r3, #2428	; 0x97c
 80131ee:	4a9b      	ldr	r2, [pc, #620]	; (801345c <event_handler+0xa84>)
 80131f0:	499b      	ldr	r1, [pc, #620]	; (8013460 <event_handler+0xa88>)
 80131f2:	2001      	movs	r0, #1
 80131f4:	f004 f924 	bl	8017440 <hci_dump_log>
            addr_type = BD_ADDR_TYPE_ACL;
 80131f8:	23fd      	movs	r3, #253	; 0xfd
 80131fa:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
            conn = hci_connection_for_bd_addr_and_type(addr, addr_type);
 80131fe:	f897 2039 	ldrb.w	r2, [r7, #57]	; 0x39
 8013202:	f107 031c 	add.w	r3, r7, #28
 8013206:	4611      	mov	r1, r2
 8013208:	4618      	mov	r0, r3
 801320a:	f7fc fb87 	bl	800f91c <hci_connection_for_bd_addr_and_type>
 801320e:	6678      	str	r0, [r7, #100]	; 0x64
            if (conn) {
 8013210:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013212:	2b00      	cmp	r3, #0
 8013214:	f000 84e2 	beq.w	8013bdc <event_handler+0x1204>
                if (!packet[2]){
 8013218:	687b      	ldr	r3, [r7, #4]
 801321a:	3302      	adds	r3, #2
 801321c:	781b      	ldrb	r3, [r3, #0]
 801321e:	2b00      	cmp	r3, #0
 8013220:	d142      	bne.n	80132a8 <event_handler+0x8d0>
                    conn->state = OPEN;
 8013222:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013224:	2207      	movs	r2, #7
 8013226:	739a      	strb	r2, [r3, #14]
                    conn->con_handle = little_endian_read_16(packet, 3);
 8013228:	2103      	movs	r1, #3
 801322a:	6878      	ldr	r0, [r7, #4]
 801322c:	f7fb fddb 	bl	800ede6 <little_endian_read_16>
 8013230:	4603      	mov	r3, r0
 8013232:	461a      	mov	r2, r3
 8013234:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013236:	815a      	strh	r2, [r3, #10]

                    // queue get remote feature
                    conn->bonding_flags |= BONDING_REQUEST_REMOTE_FEATURES_PAGE_0;
 8013238:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801323a:	8a1b      	ldrh	r3, [r3, #16]
 801323c:	f043 0301 	orr.w	r3, r3, #1
 8013240:	b29a      	uxth	r2, r3
 8013242:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013244:	821a      	strh	r2, [r3, #16]

                    // queue set supervision timeout if we're master
                    if ((hci_stack->link_supervision_timeout != 0) && (conn->role == HCI_ROLE_MASTER)){
 8013246:	4b84      	ldr	r3, [pc, #528]	; (8013458 <event_handler+0xa80>)
 8013248:	681b      	ldr	r3, [r3, #0]
 801324a:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 801324e:	2b00      	cmp	r3, #0
 8013250:	d008      	beq.n	8013264 <event_handler+0x88c>
 8013252:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013254:	7b5b      	ldrb	r3, [r3, #13]
 8013256:	2b00      	cmp	r3, #0
 8013258:	d104      	bne.n	8013264 <event_handler+0x88c>
                        connectionSetAuthenticationFlags(conn, WRITE_SUPERVISION_TIMEOUT);
 801325a:	f44f 2180 	mov.w	r1, #262144	; 0x40000
 801325e:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8013260:	f7fc fba8 	bl	800f9b4 <connectionSetAuthenticationFlags>
                    }

                    // restart timer
                    btstack_run_loop_set_timer(&conn->timeout, HCI_CONNECTION_TIMEOUT_MS);
 8013264:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013266:	333c      	adds	r3, #60	; 0x3c
 8013268:	f242 7110 	movw	r1, #10000	; 0x2710
 801326c:	4618      	mov	r0, r3
 801326e:	f7fb fcf1 	bl	800ec54 <btstack_run_loop_set_timer>
                    btstack_run_loop_add_timer(&conn->timeout);
 8013272:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013274:	333c      	adds	r3, #60	; 0x3c
 8013276:	4618      	mov	r0, r3
 8013278:	f7fb fd18 	bl	800ecac <btstack_run_loop_add_timer>
                    
                    log_info("New connection: handle %u, %s", conn->con_handle, bd_addr_to_str(conn->address));
 801327c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801327e:	895b      	ldrh	r3, [r3, #10]
 8013280:	461c      	mov	r4, r3
 8013282:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013284:	3304      	adds	r3, #4
 8013286:	4618      	mov	r0, r3
 8013288:	f7fc f8c2 	bl	800f410 <bd_addr_to_str>
 801328c:	4603      	mov	r3, r0
 801328e:	9301      	str	r3, [sp, #4]
 8013290:	9400      	str	r4, [sp, #0]
 8013292:	f44f 6319 	mov.w	r3, #2448	; 0x990
 8013296:	4a71      	ldr	r2, [pc, #452]	; (801345c <event_handler+0xa84>)
 8013298:	4972      	ldr	r1, [pc, #456]	; (8013464 <event_handler+0xa8c>)
 801329a:	2001      	movs	r0, #1
 801329c:	f004 f8d0 	bl	8017440 <hci_dump_log>
                    
                    hci_emit_nr_connections_changed();
 80132a0:	f003 f91e 	bl	80164e0 <hci_emit_nr_connections_changed>
                } else {
                    // connection failed
                    hci_handle_connection_failed(conn, packet[2]);
                }
            }
            break;
 80132a4:	f000 bc9a 	b.w	8013bdc <event_handler+0x1204>
                    hci_handle_connection_failed(conn, packet[2]);
 80132a8:	687b      	ldr	r3, [r7, #4]
 80132aa:	3302      	adds	r3, #2
 80132ac:	781b      	ldrb	r3, [r3, #0]
 80132ae:	4619      	mov	r1, r3
 80132b0:	6e78      	ldr	r0, [r7, #100]	; 0x64
 80132b2:	f7fe fe47 	bl	8011f44 <hci_handle_connection_failed>
            break;
 80132b6:	f000 bc91 	b.w	8013bdc <event_handler+0x1204>

        case HCI_EVENT_SYNCHRONOUS_CONNECTION_COMPLETE:
            reverse_bd_addr(&packet[5], addr);
 80132ba:	687b      	ldr	r3, [r7, #4]
 80132bc:	3305      	adds	r3, #5
 80132be:	f107 021c 	add.w	r2, r7, #28
 80132c2:	4611      	mov	r1, r2
 80132c4:	4618      	mov	r0, r3
 80132c6:	f7fb ff14 	bl	800f0f2 <reverse_bd_addr>
            log_info("Synchronous Connection Complete (status=%u) %s", packet[2], bd_addr_to_str(addr));
 80132ca:	687b      	ldr	r3, [r7, #4]
 80132cc:	3302      	adds	r3, #2
 80132ce:	781b      	ldrb	r3, [r3, #0]
 80132d0:	461c      	mov	r4, r3
 80132d2:	f107 031c 	add.w	r3, r7, #28
 80132d6:	4618      	mov	r0, r3
 80132d8:	f7fc f89a 	bl	800f410 <bd_addr_to_str>
 80132dc:	4603      	mov	r3, r0
 80132de:	9301      	str	r3, [sp, #4]
 80132e0:	9400      	str	r4, [sp, #0]
 80132e2:	f640 139c 	movw	r3, #2460	; 0x99c
 80132e6:	4a5d      	ldr	r2, [pc, #372]	; (801345c <event_handler+0xa84>)
 80132e8:	495f      	ldr	r1, [pc, #380]	; (8013468 <event_handler+0xa90>)
 80132ea:	2001      	movs	r0, #1
 80132ec:	f004 f8a8 	bl	8017440 <hci_dump_log>
            if (packet[2]){
 80132f0:	687b      	ldr	r3, [r7, #4]
 80132f2:	3302      	adds	r3, #2
 80132f4:	781b      	ldrb	r3, [r3, #0]
 80132f6:	2b00      	cmp	r3, #0
 80132f8:	f040 8472 	bne.w	8013be0 <event_handler+0x1208>
                // connection failed
                break;
            }
            conn = hci_connection_for_bd_addr_and_type(addr, BD_ADDR_TYPE_SCO);
 80132fc:	f107 031c 	add.w	r3, r7, #28
 8013300:	21fc      	movs	r1, #252	; 0xfc
 8013302:	4618      	mov	r0, r3
 8013304:	f7fc fb0a 	bl	800f91c <hci_connection_for_bd_addr_and_type>
 8013308:	6678      	str	r0, [r7, #100]	; 0x64
            if (!conn) {
 801330a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801330c:	2b00      	cmp	r3, #0
 801330e:	d106      	bne.n	801331e <event_handler+0x946>
                conn = create_connection_for_bd_addr_and_type(addr, BD_ADDR_TYPE_SCO);
 8013310:	f107 031c 	add.w	r3, r7, #28
 8013314:	21fc      	movs	r1, #252	; 0xfc
 8013316:	4618      	mov	r0, r3
 8013318:	f7fc f9fe 	bl	800f718 <create_connection_for_bd_addr_and_type>
 801331c:	6678      	str	r0, [r7, #100]	; 0x64
            }
            if (!conn) {
 801331e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013320:	2b00      	cmp	r3, #0
 8013322:	f000 845f 	beq.w	8013be4 <event_handler+0x120c>
                break;
            }
            conn->state = OPEN;
 8013326:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013328:	2207      	movs	r2, #7
 801332a:	739a      	strb	r2, [r3, #14]
            conn->con_handle = little_endian_read_16(packet, 3);            
 801332c:	2103      	movs	r1, #3
 801332e:	6878      	ldr	r0, [r7, #4]
 8013330:	f7fb fd59 	bl	800ede6 <little_endian_read_16>
 8013334:	4603      	mov	r3, r0
 8013336:	461a      	mov	r2, r3
 8013338:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801333a:	815a      	strh	r2, [r3, #10]

#ifdef ENABLE_SCO_OVER_HCI
            // update SCO
            if (conn->address_type == BD_ADDR_TYPE_SCO && hci_stack->hci_transport && hci_stack->hci_transport->set_sco_config){
 801333c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801333e:	7b1b      	ldrb	r3, [r3, #12]
 8013340:	2bfc      	cmp	r3, #252	; 0xfc
 8013342:	d118      	bne.n	8013376 <event_handler+0x99e>
 8013344:	4b44      	ldr	r3, [pc, #272]	; (8013458 <event_handler+0xa80>)
 8013346:	681b      	ldr	r3, [r3, #0]
 8013348:	681b      	ldr	r3, [r3, #0]
 801334a:	2b00      	cmp	r3, #0
 801334c:	d013      	beq.n	8013376 <event_handler+0x99e>
 801334e:	4b42      	ldr	r3, [pc, #264]	; (8013458 <event_handler+0xa80>)
 8013350:	681b      	ldr	r3, [r3, #0]
 8013352:	681b      	ldr	r3, [r3, #0]
 8013354:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013356:	2b00      	cmp	r3, #0
 8013358:	d00d      	beq.n	8013376 <event_handler+0x99e>
                hci_stack->hci_transport->set_sco_config(hci_stack->sco_voice_setting_active, hci_number_sco_connections());
 801335a:	4b3f      	ldr	r3, [pc, #252]	; (8013458 <event_handler+0xa80>)
 801335c:	681b      	ldr	r3, [r3, #0]
 801335e:	681b      	ldr	r3, [r3, #0]
 8013360:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8013362:	4b3d      	ldr	r3, [pc, #244]	; (8013458 <event_handler+0xa80>)
 8013364:	681b      	ldr	r3, [r3, #0]
 8013366:	f8b3 574a 	ldrh.w	r5, [r3, #1866]	; 0x74a
 801336a:	f7fc fb35 	bl	800f9d8 <hci_number_sco_connections>
 801336e:	4603      	mov	r3, r0
 8013370:	4619      	mov	r1, r3
 8013372:	4628      	mov	r0, r5
 8013374:	47a0      	blx	r4
            }
            // trigger can send now
            if (hci_have_usb_transport()){
 8013376:	f003 fbc5 	bl	8016b04 <hci_have_usb_transport>
 801337a:	4603      	mov	r3, r0
 801337c:	2b00      	cmp	r3, #0
 801337e:	f000 8433 	beq.w	8013be8 <event_handler+0x1210>
                hci_stack->sco_can_send_now = 1;
 8013382:	4b35      	ldr	r3, [pc, #212]	; (8013458 <event_handler+0xa80>)
 8013384:	681b      	ldr	r3, [r3, #0]
 8013386:	2201      	movs	r2, #1
 8013388:	f883 2707 	strb.w	r2, [r3, #1799]	; 0x707
            }
#endif
            break;
 801338c:	f000 bc2c 	b.w	8013be8 <event_handler+0x1210>

        case HCI_EVENT_READ_REMOTE_SUPPORTED_FEATURES_COMPLETE:
            handle = little_endian_read_16(packet, 3);
 8013390:	2103      	movs	r1, #3
 8013392:	6878      	ldr	r0, [r7, #4]
 8013394:	f7fb fd27 	bl	800ede6 <little_endian_read_16>
 8013398:	4603      	mov	r3, r0
 801339a:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            conn = hci_connection_for_handle(handle);
 801339e:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 80133a2:	4618      	mov	r0, r3
 80133a4:	f7fc fa8e 	bl	800f8c4 <hci_connection_for_handle>
 80133a8:	6678      	str	r0, [r7, #100]	; 0x64
            if (!conn) break;
 80133aa:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80133ac:	2b00      	cmp	r3, #0
 80133ae:	f000 841d 	beq.w	8013bec <event_handler+0x1214>
            if (!packet[2]){
 80133b2:	687b      	ldr	r3, [r7, #4]
 80133b4:	3302      	adds	r3, #2
 80133b6:	781b      	ldrb	r3, [r3, #0]
 80133b8:	2b00      	cmp	r3, #0
 80133ba:	d11d      	bne.n	80133f8 <event_handler+0xa20>
                const uint8_t * features = &packet[5];
 80133bc:	687b      	ldr	r3, [r7, #4]
 80133be:	3305      	adds	r3, #5
 80133c0:	637b      	str	r3, [r7, #52]	; 0x34
                hci_handle_remote_features_page_0(conn, features);
 80133c2:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80133c4:	6e78      	ldr	r0, [r7, #100]	; 0x64
 80133c6:	f7fe fe0d 	bl	8011fe4 <hci_handle_remote_features_page_0>

                // read extended features if possible
                if (((hci_stack->local_supported_commands[1] & 1) != 0) && ((conn->remote_supported_features[0] & 2) != 0)) {
 80133ca:	4b23      	ldr	r3, [pc, #140]	; (8013458 <event_handler+0xa80>)
 80133cc:	681b      	ldr	r3, [r3, #0]
 80133ce:	f893 3711 	ldrb.w	r3, [r3, #1809]	; 0x711
 80133d2:	f003 0301 	and.w	r3, r3, #1
 80133d6:	2b00      	cmp	r3, #0
 80133d8:	d00e      	beq.n	80133f8 <event_handler+0xa20>
 80133da:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80133dc:	7d9b      	ldrb	r3, [r3, #22]
 80133de:	f003 0302 	and.w	r3, r3, #2
 80133e2:	2b00      	cmp	r3, #0
 80133e4:	d008      	beq.n	80133f8 <event_handler+0xa20>
                    conn->bonding_flags |= BONDING_REQUEST_REMOTE_FEATURES_PAGE_1;
 80133e6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80133e8:	8a1b      	ldrh	r3, [r3, #16]
 80133ea:	f043 0302 	orr.w	r3, r3, #2
 80133ee:	b29a      	uxth	r2, r3
 80133f0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80133f2:	821a      	strh	r2, [r3, #16]
                    break;
 80133f4:	f000 bc1d 	b.w	8013c32 <event_handler+0x125a>
                }
            }
            hci_handle_remote_features_received(conn);
 80133f8:	6e78      	ldr	r0, [r7, #100]	; 0x64
 80133fa:	f7fe fe65 	bl	80120c8 <hci_handle_remote_features_received>
            break;
 80133fe:	f000 bc18 	b.w	8013c32 <event_handler+0x125a>

        case HCI_EVENT_READ_REMOTE_EXTENDED_FEATURES_COMPLETE:
            handle = little_endian_read_16(packet, 3);
 8013402:	2103      	movs	r1, #3
 8013404:	6878      	ldr	r0, [r7, #4]
 8013406:	f7fb fcee 	bl	800ede6 <little_endian_read_16>
 801340a:	4603      	mov	r3, r0
 801340c:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            conn = hci_connection_for_handle(handle);
 8013410:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8013414:	4618      	mov	r0, r3
 8013416:	f7fc fa55 	bl	800f8c4 <hci_connection_for_handle>
 801341a:	6678      	str	r0, [r7, #100]	; 0x64
            if (!conn) break;
 801341c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801341e:	2b00      	cmp	r3, #0
 8013420:	f000 83e6 	beq.w	8013bf0 <event_handler+0x1218>
            // status = ok, page = 1
            if (!packet[2]) {
 8013424:	687b      	ldr	r3, [r7, #4]
 8013426:	3302      	adds	r3, #2
 8013428:	781b      	ldrb	r3, [r3, #0]
 801342a:	2b00      	cmp	r3, #0
 801342c:	d14f      	bne.n	80134ce <event_handler+0xaf6>
                uint8_t page_number = packet[5];
 801342e:	687b      	ldr	r3, [r7, #4]
 8013430:	795b      	ldrb	r3, [r3, #5]
 8013432:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
                uint8_t maximum_page_number = packet[6];
 8013436:	687b      	ldr	r3, [r7, #4]
 8013438:	799b      	ldrb	r3, [r3, #6]
 801343a:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
                const uint8_t * features = &packet[7];
 801343e:	687b      	ldr	r3, [r7, #4]
 8013440:	3307      	adds	r3, #7
 8013442:	643b      	str	r3, [r7, #64]	; 0x40
                bool done = false;
 8013444:	2300      	movs	r3, #0
 8013446:	f887 3059 	strb.w	r3, [r7, #89]	; 0x59
                switch (page_number){
 801344a:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801344e:	2b01      	cmp	r3, #1
 8013450:	d00c      	beq.n	801346c <event_handler+0xa94>
 8013452:	2b02      	cmp	r3, #2
 8013454:	d02b      	beq.n	80134ae <event_handler+0xad6>
                    case 2:
                        hci_handle_remote_features_page_2(conn, features);
                        done = true;
                        break;
                    default:
                        break;
 8013456:	e032      	b.n	80134be <event_handler+0xae6>
 8013458:	20009780 	.word	0x20009780
 801345c:	0802929c 	.word	0x0802929c
 8013460:	0802a2c0 	.word	0x0802a2c0
 8013464:	0802a134 	.word	0x0802a134
 8013468:	0802a2ec 	.word	0x0802a2ec
                        hci_handle_remote_features_page_1(conn, features);
 801346c:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801346e:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8013470:	f7fe fdeb 	bl	801204a <hci_handle_remote_features_page_1>
                        if (maximum_page_number >= 2){
 8013474:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 8013478:	2b01      	cmp	r3, #1
 801347a:	d907      	bls.n	801348c <event_handler+0xab4>
                            conn->bonding_flags |= BONDING_REQUEST_REMOTE_FEATURES_PAGE_2;
 801347c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801347e:	8a1b      	ldrh	r3, [r3, #16]
 8013480:	f043 0304 	orr.w	r3, r3, #4
 8013484:	b29a      	uxth	r2, r3
 8013486:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013488:	821a      	strh	r2, [r3, #16]
                        break;
 801348a:	e018      	b.n	80134be <event_handler+0xae6>
                            if ((conn->bonding_flags & BONDING_REMOTE_SUPPORTS_SC_HOST) != 0){
 801348c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801348e:	8a1b      	ldrh	r3, [r3, #16]
 8013490:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8013494:	2b00      	cmp	r3, #0
 8013496:	d006      	beq.n	80134a6 <event_handler+0xace>
                                conn->bonding_flags |= BONDING_REMOTE_SUPPORTS_SC_CONTROLLER;
 8013498:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801349a:	8a1b      	ldrh	r3, [r3, #16]
 801349c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80134a0:	b29a      	uxth	r2, r3
 80134a2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80134a4:	821a      	strh	r2, [r3, #16]
                            done = true;
 80134a6:	2301      	movs	r3, #1
 80134a8:	f887 3059 	strb.w	r3, [r7, #89]	; 0x59
                        break;
 80134ac:	e007      	b.n	80134be <event_handler+0xae6>
                        hci_handle_remote_features_page_2(conn, features);
 80134ae:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80134b0:	6e78      	ldr	r0, [r7, #100]	; 0x64
 80134b2:	f7fe fdef 	bl	8012094 <hci_handle_remote_features_page_2>
                        done = true;
 80134b6:	2301      	movs	r3, #1
 80134b8:	f887 3059 	strb.w	r3, [r7, #89]	; 0x59
                        break;
 80134bc:	bf00      	nop
                }
                if (!done) break;
 80134be:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 80134c2:	f083 0301 	eor.w	r3, r3, #1
 80134c6:	b2db      	uxtb	r3, r3
 80134c8:	2b00      	cmp	r3, #0
 80134ca:	f040 8393 	bne.w	8013bf4 <event_handler+0x121c>
            }
            hci_handle_remote_features_received(conn);
 80134ce:	6e78      	ldr	r0, [r7, #100]	; 0x64
 80134d0:	f7fe fdfa 	bl	80120c8 <hci_handle_remote_features_received>
            break;
 80134d4:	e3ad      	b.n	8013c32 <event_handler+0x125a>

        case HCI_EVENT_LINK_KEY_REQUEST:
            log_info("HCI_EVENT_LINK_KEY_REQUEST");
 80134d6:	f640 13ed 	movw	r3, #2541	; 0x9ed
 80134da:	4ab9      	ldr	r2, [pc, #740]	; (80137c0 <event_handler+0xde8>)
 80134dc:	49b9      	ldr	r1, [pc, #740]	; (80137c4 <event_handler+0xdec>)
 80134de:	2001      	movs	r0, #1
 80134e0:	f003 ffae 	bl	8017440 <hci_dump_log>
            hci_add_connection_flags_for_flipped_bd_addr(&packet[2], RECV_LINK_KEY_REQUEST);
 80134e4:	687b      	ldr	r3, [r7, #4]
 80134e6:	3302      	adds	r3, #2
 80134e8:	2101      	movs	r1, #1
 80134ea:	4618      	mov	r0, r3
 80134ec:	f7fc fac4 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            // request handled by hci_run()
            hci_add_connection_flags_for_flipped_bd_addr(&packet[2], HANDLE_LINK_KEY_REQUEST);
 80134f0:	687b      	ldr	r3, [r7, #4]
 80134f2:	3302      	adds	r3, #2
 80134f4:	2102      	movs	r1, #2
 80134f6:	4618      	mov	r0, r3
 80134f8:	f7fc fabe 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            break;
 80134fc:	e399      	b.n	8013c32 <event_handler+0x125a>
            
        case HCI_EVENT_LINK_KEY_NOTIFICATION: {
            reverse_bd_addr(&packet[2], addr);
 80134fe:	687b      	ldr	r3, [r7, #4]
 8013500:	3302      	adds	r3, #2
 8013502:	f107 021c 	add.w	r2, r7, #28
 8013506:	4611      	mov	r1, r2
 8013508:	4618      	mov	r0, r3
 801350a:	f7fb fdf2 	bl	800f0f2 <reverse_bd_addr>
            conn = hci_connection_for_bd_addr_and_type(addr, BD_ADDR_TYPE_ACL);
 801350e:	f107 031c 	add.w	r3, r7, #28
 8013512:	21fd      	movs	r1, #253	; 0xfd
 8013514:	4618      	mov	r0, r3
 8013516:	f7fc fa01 	bl	800f91c <hci_connection_for_bd_addr_and_type>
 801351a:	6678      	str	r0, [r7, #100]	; 0x64
            if (!conn) break;
 801351c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801351e:	2b00      	cmp	r3, #0
 8013520:	f000 836a 	beq.w	8013bf8 <event_handler+0x1220>
            conn->authentication_flags |= RECV_LINK_KEY_NOTIFICATION;
 8013524:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013526:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8013528:	f043 0210 	orr.w	r2, r3, #16
 801352c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801352e:	639a      	str	r2, [r3, #56]	; 0x38
            link_key_type_t link_key_type = (link_key_type_t)packet[24];
 8013530:	687b      	ldr	r3, [r7, #4]
 8013532:	3318      	adds	r3, #24
 8013534:	781b      	ldrb	r3, [r3, #0]
 8013536:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
            // Change Connection Encryption keeps link key type
            if (link_key_type != CHANGED_COMBINATION_KEY){
 801353a:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801353e:	2b06      	cmp	r3, #6
 8013540:	d003      	beq.n	801354a <event_handler+0xb72>
                conn->link_key_type = link_key_type;
 8013542:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013544:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 8013548:	755a      	strb	r2, [r3, #21]
            }
            gap_store_link_key_for_bd_addr(addr, &packet[8], conn->link_key_type);
 801354a:	687b      	ldr	r3, [r7, #4]
 801354c:	f103 0108 	add.w	r1, r3, #8
 8013550:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013552:	7d5a      	ldrb	r2, [r3, #21]
 8013554:	f107 031c 	add.w	r3, r7, #28
 8013558:	4618      	mov	r0, r3
 801355a:	f7fc faf7 	bl	800fb4c <gap_store_link_key_for_bd_addr>
            // still forward event to allow dismiss of pairing dialog
            break;
 801355e:	e368      	b.n	8013c32 <event_handler+0x125a>
        }

        case HCI_EVENT_PIN_CODE_REQUEST:
            hci_add_connection_flags_for_flipped_bd_addr(&packet[2], LEGACY_PAIRING_ACTIVE);
 8013560:	687b      	ldr	r3, [r7, #4]
 8013562:	3302      	adds	r3, #2
 8013564:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8013568:	4618      	mov	r0, r3
 801356a:	f7fc fa85 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            // non-bondable mode: pin code negative reply will be sent
            if (!hci_stack->bondable){
 801356e:	4b96      	ldr	r3, [pc, #600]	; (80137c8 <event_handler+0xdf0>)
 8013570:	681b      	ldr	r3, [r3, #0]
 8013572:	f893 3730 	ldrb.w	r3, [r3, #1840]	; 0x730
 8013576:	2b00      	cmp	r3, #0
 8013578:	d108      	bne.n	801358c <event_handler+0xbb4>
                hci_add_connection_flags_for_flipped_bd_addr(&packet[2], DENY_PIN_CODE_REQUEST);
 801357a:	687b      	ldr	r3, [r7, #4]
 801357c:	3302      	adds	r3, #2
 801357e:	2140      	movs	r1, #64	; 0x40
 8013580:	4618      	mov	r0, r3
 8013582:	f7fc fa79 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
                hci_run();
 8013586:	f002 f98b 	bl	80158a0 <hci_run>
                return;
 801358a:	e385      	b.n	8013c98 <event_handler+0x12c0>
            }
            // PIN CODE REQUEST means the link key request didn't succee -> delete stored link key
            if (!hci_stack->link_key_db) break;
 801358c:	4b8e      	ldr	r3, [pc, #568]	; (80137c8 <event_handler+0xdf0>)
 801358e:	681b      	ldr	r3, [r3, #0]
 8013590:	691b      	ldr	r3, [r3, #16]
 8013592:	2b00      	cmp	r3, #0
 8013594:	f000 8332 	beq.w	8013bfc <event_handler+0x1224>
            hci_event_pin_code_request_get_bd_addr(packet, addr);
 8013598:	f107 031c 	add.w	r3, r7, #28
 801359c:	4619      	mov	r1, r3
 801359e:	6878      	ldr	r0, [r7, #4]
 80135a0:	f7fc f834 	bl	800f60c <hci_event_pin_code_request_get_bd_addr>
            hci_stack->link_key_db->delete_link_key(addr);
 80135a4:	4b88      	ldr	r3, [pc, #544]	; (80137c8 <event_handler+0xdf0>)
 80135a6:	681b      	ldr	r3, [r3, #0]
 80135a8:	691b      	ldr	r3, [r3, #16]
 80135aa:	695b      	ldr	r3, [r3, #20]
 80135ac:	f107 021c 	add.w	r2, r7, #28
 80135b0:	4610      	mov	r0, r2
 80135b2:	4798      	blx	r3
            break;
 80135b4:	e33d      	b.n	8013c32 <event_handler+0x125a>
            
        case HCI_EVENT_IO_CAPABILITY_REQUEST:
            hci_add_connection_flags_for_flipped_bd_addr(&packet[2], RECV_IO_CAPABILITIES_REQUEST);
 80135b6:	687b      	ldr	r3, [r7, #4]
 80135b8:	3302      	adds	r3, #2
 80135ba:	2180      	movs	r1, #128	; 0x80
 80135bc:	4618      	mov	r0, r3
 80135be:	f7fc fa5b 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            log_info("IO Capability Request received, stack bondable %u, io cap %u", hci_stack->bondable, hci_stack->ssp_io_capability);
 80135c2:	4b81      	ldr	r3, [pc, #516]	; (80137c8 <event_handler+0xdf0>)
 80135c4:	681b      	ldr	r3, [r3, #0]
 80135c6:	f893 3730 	ldrb.w	r3, [r3, #1840]	; 0x730
 80135ca:	461a      	mov	r2, r3
 80135cc:	4b7e      	ldr	r3, [pc, #504]	; (80137c8 <event_handler+0xdf0>)
 80135ce:	681b      	ldr	r3, [r3, #0]
 80135d0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 80135d4:	9301      	str	r3, [sp, #4]
 80135d6:	9200      	str	r2, [sp, #0]
 80135d8:	f640 2312 	movw	r3, #2578	; 0xa12
 80135dc:	4a78      	ldr	r2, [pc, #480]	; (80137c0 <event_handler+0xde8>)
 80135de:	497b      	ldr	r1, [pc, #492]	; (80137cc <event_handler+0xdf4>)
 80135e0:	2001      	movs	r0, #1
 80135e2:	f003 ff2d 	bl	8017440 <hci_dump_log>
#ifndef ENABLE_EXPLICIT_IO_CAPABILITIES_REPLY
            if (hci_stack->bondable && (hci_stack->ssp_io_capability != SSP_IO_CAPABILITY_UNKNOWN)){
 80135e6:	4b78      	ldr	r3, [pc, #480]	; (80137c8 <event_handler+0xdf0>)
 80135e8:	681b      	ldr	r3, [r3, #0]
 80135ea:	f893 3730 	ldrb.w	r3, [r3, #1840]	; 0x730
 80135ee:	2b00      	cmp	r3, #0
 80135f0:	d00d      	beq.n	801360e <event_handler+0xc36>
 80135f2:	4b75      	ldr	r3, [pc, #468]	; (80137c8 <event_handler+0xdf0>)
 80135f4:	681b      	ldr	r3, [r3, #0]
 80135f6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 80135fa:	2bff      	cmp	r3, #255	; 0xff
 80135fc:	d007      	beq.n	801360e <event_handler+0xc36>
                hci_add_connection_flags_for_flipped_bd_addr(&packet[2], SEND_IO_CAPABILITIES_REPLY);
 80135fe:	687b      	ldr	r3, [r7, #4]
 8013600:	3302      	adds	r3, #2
 8013602:	f44f 7180 	mov.w	r1, #256	; 0x100
 8013606:	4618      	mov	r0, r3
 8013608:	f7fc fa36 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            } else {
                hci_add_connection_flags_for_flipped_bd_addr(&packet[2], SEND_IO_CAPABILITIES_NEGATIVE_REPLY);
            }
#endif
            break;
 801360c:	e311      	b.n	8013c32 <event_handler+0x125a>
                hci_add_connection_flags_for_flipped_bd_addr(&packet[2], SEND_IO_CAPABILITIES_NEGATIVE_REPLY);
 801360e:	687b      	ldr	r3, [r7, #4]
 8013610:	3302      	adds	r3, #2
 8013612:	f44f 7100 	mov.w	r1, #512	; 0x200
 8013616:	4618      	mov	r0, r3
 8013618:	f7fc fa2e 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            break;
 801361c:	e309      	b.n	8013c32 <event_handler+0x125a>
            hci_add_connection_flags_for_flipped_bd_addr(&packet[2], SEND_REMOTE_OOB_DATA_REPLY);
            break;
#endif

        case HCI_EVENT_USER_CONFIRMATION_REQUEST:
            hci_add_connection_flags_for_flipped_bd_addr(&packet[2], SSP_PAIRING_ACTIVE);
 801361e:	687b      	ldr	r3, [r7, #4]
 8013620:	3302      	adds	r3, #2
 8013622:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8013626:	4618      	mov	r0, r3
 8013628:	f7fc fa26 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            if (!hci_stack->ssp_auto_accept) break;
 801362c:	4b66      	ldr	r3, [pc, #408]	; (80137c8 <event_handler+0xdf0>)
 801362e:	681b      	ldr	r3, [r3, #0]
 8013630:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 8013634:	2b00      	cmp	r3, #0
 8013636:	f000 82e3 	beq.w	8013c00 <event_handler+0x1228>
            hci_add_connection_flags_for_flipped_bd_addr(&packet[2], SEND_USER_CONFIRM_REPLY);
 801363a:	687b      	ldr	r3, [r7, #4]
 801363c:	3302      	adds	r3, #2
 801363e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8013642:	4618      	mov	r0, r3
 8013644:	f7fc fa18 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            break;
 8013648:	e2f3      	b.n	8013c32 <event_handler+0x125a>

        case HCI_EVENT_USER_PASSKEY_REQUEST:
            hci_add_connection_flags_for_flipped_bd_addr(&packet[2], SSP_PAIRING_ACTIVE);
 801364a:	687b      	ldr	r3, [r7, #4]
 801364c:	3302      	adds	r3, #2
 801364e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8013652:	4618      	mov	r0, r3
 8013654:	f7fc fa10 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            if (!hci_stack->ssp_auto_accept) break;
 8013658:	4b5b      	ldr	r3, [pc, #364]	; (80137c8 <event_handler+0xdf0>)
 801365a:	681b      	ldr	r3, [r3, #0]
 801365c:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 8013660:	2b00      	cmp	r3, #0
 8013662:	f000 82cf 	beq.w	8013c04 <event_handler+0x122c>
            hci_add_connection_flags_for_flipped_bd_addr(&packet[2], SEND_USER_PASSKEY_REPLY);
 8013666:	687b      	ldr	r3, [r7, #4]
 8013668:	3302      	adds	r3, #2
 801366a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 801366e:	4618      	mov	r0, r3
 8013670:	f7fc fa02 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            break;
 8013674:	e2dd      	b.n	8013c32 <event_handler+0x125a>

        case HCI_EVENT_MODE_CHANGE:
            handle = hci_event_mode_change_get_handle(packet);
 8013676:	6878      	ldr	r0, [r7, #4]
 8013678:	f7fb ffae 	bl	800f5d8 <hci_event_mode_change_get_handle>
 801367c:	4603      	mov	r3, r0
 801367e:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            conn = hci_connection_for_handle(handle);
 8013682:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8013686:	4618      	mov	r0, r3
 8013688:	f7fc f91c 	bl	800f8c4 <hci_connection_for_handle>
 801368c:	6678      	str	r0, [r7, #100]	; 0x64
            if (!conn) break;
 801368e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013690:	2b00      	cmp	r3, #0
 8013692:	f000 82b9 	beq.w	8013c08 <event_handler+0x1230>
            conn->connection_mode = hci_event_mode_change_get_mode(packet);
 8013696:	6878      	ldr	r0, [r7, #4]
 8013698:	f7fb ffab 	bl	800f5f2 <hci_event_mode_change_get_mode>
 801369c:	4603      	mov	r3, r0
 801369e:	461a      	mov	r2, r3
 80136a0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80136a2:	75da      	strb	r2, [r3, #23]
            log_info("HCI_EVENT_MODE_CHANGE, handle 0x%04x, mode %u", handle, conn->connection_mode);
 80136a4:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 80136a8:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80136aa:	7dd2      	ldrb	r2, [r2, #23]
 80136ac:	9201      	str	r2, [sp, #4]
 80136ae:	9300      	str	r3, [sp, #0]
 80136b0:	f640 2334 	movw	r3, #2612	; 0xa34
 80136b4:	4a42      	ldr	r2, [pc, #264]	; (80137c0 <event_handler+0xde8>)
 80136b6:	4946      	ldr	r1, [pc, #280]	; (80137d0 <event_handler+0xdf8>)
 80136b8:	2001      	movs	r0, #1
 80136ba:	f003 fec1 	bl	8017440 <hci_dump_log>
            break;
 80136be:	e2b8      	b.n	8013c32 <event_handler+0x125a>
#endif

        case HCI_EVENT_ENCRYPTION_CHANGE:
            handle = hci_event_encryption_change_get_connection_handle(packet);
 80136c0:	6878      	ldr	r0, [r7, #4]
 80136c2:	f7fb ff55 	bl	800f570 <hci_event_encryption_change_get_connection_handle>
 80136c6:	4603      	mov	r3, r0
 80136c8:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            conn = hci_connection_for_handle(handle);
 80136cc:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 80136d0:	4618      	mov	r0, r3
 80136d2:	f7fc f8f7 	bl	800f8c4 <hci_connection_for_handle>
 80136d6:	6678      	str	r0, [r7, #100]	; 0x64
            if (!conn) break;
 80136d8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80136da:	2b00      	cmp	r3, #0
 80136dc:	f000 8296 	beq.w	8013c0c <event_handler+0x1234>
            if (hci_event_encryption_change_get_status(packet) == 0u) {
 80136e0:	6878      	ldr	r0, [r7, #4]
 80136e2:	f7fb ff38 	bl	800f556 <hci_event_encryption_change_get_status>
 80136e6:	4603      	mov	r3, r0
 80136e8:	2b00      	cmp	r3, #0
 80136ea:	f040 8291 	bne.w	8013c10 <event_handler+0x1238>
                uint8_t encryption_enabled = hci_event_encryption_change_get_encryption_enabled(packet);
 80136ee:	6878      	ldr	r0, [r7, #4]
 80136f0:	f7fb ff4b 	bl	800f58a <hci_event_encryption_change_get_encryption_enabled>
 80136f4:	4603      	mov	r3, r0
 80136f6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
                if (encryption_enabled){
 80136fa:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80136fe:	2b00      	cmp	r3, #0
 8013700:	d06a      	beq.n	80137d8 <event_handler+0xe00>
                    if (hci_is_le_connection(conn)){
 8013702:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8013704:	f7fc fa62 	bl	800fbcc <hci_is_le_connection>
 8013708:	4603      	mov	r3, r0
 801370a:	2b00      	cmp	r3, #0
 801370c:	d006      	beq.n	801371c <event_handler+0xd44>
                        // For LE, we accept connection as encrypted
                        conn->authentication_flags |= CONNECTION_ENCRYPTED;
 801370e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013710:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8013712:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8013716:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013718:	639a      	str	r2, [r3, #56]	; 0x38
                } else {
                    conn->authentication_flags &= ~CONNECTION_ENCRYPTED;
                }
            }

            break;
 801371a:	e279      	b.n	8013c10 <event_handler+0x1238>
                        bool sc_used_during_pairing = gap_secure_connection_for_link_key_type(conn->link_key_type) != 0;
 801371c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801371e:	7d5b      	ldrb	r3, [r3, #21]
 8013720:	4618      	mov	r0, r3
 8013722:	f003 f823 	bl	801676c <gap_secure_connection_for_link_key_type>
 8013726:	4603      	mov	r3, r0
 8013728:	2b00      	cmp	r3, #0
 801372a:	bf14      	ite	ne
 801372c:	2301      	movne	r3, #1
 801372e:	2300      	moveq	r3, #0
 8013730:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
                        bool connected_uses_aes_ccm = encryption_enabled == 2;
 8013734:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8013738:	2b02      	cmp	r3, #2
 801373a:	bf0c      	ite	eq
 801373c:	2301      	moveq	r3, #1
 801373e:	2300      	movne	r3, #0
 8013740:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
                        if (hci_stack->secure_connections_active && sc_used_during_pairing && !connected_uses_aes_ccm){
 8013744:	4b20      	ldr	r3, [pc, #128]	; (80137c8 <event_handler+0xdf0>)
 8013746:	681b      	ldr	r3, [r3, #0]
 8013748:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 801374c:	2b00      	cmp	r3, #0
 801374e:	d019      	beq.n	8013784 <event_handler+0xdac>
 8013750:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8013754:	2b00      	cmp	r3, #0
 8013756:	d015      	beq.n	8013784 <event_handler+0xdac>
 8013758:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 801375c:	f083 0301 	eor.w	r3, r3, #1
 8013760:	b2db      	uxtb	r3, r3
 8013762:	2b00      	cmp	r3, #0
 8013764:	d00e      	beq.n	8013784 <event_handler+0xdac>
                            log_info("SC during pairing, but only E0 now -> abort");
 8013766:	f640 2349 	movw	r3, #2633	; 0xa49
 801376a:	4a15      	ldr	r2, [pc, #84]	; (80137c0 <event_handler+0xde8>)
 801376c:	4919      	ldr	r1, [pc, #100]	; (80137d4 <event_handler+0xdfc>)
 801376e:	2001      	movs	r0, #1
 8013770:	f003 fe66 	bl	8017440 <hci_dump_log>
                            conn->bonding_flags |= BONDING_DISCONNECT_SECURITY_BLOCK;
 8013774:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013776:	8a1b      	ldrh	r3, [r3, #16]
 8013778:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 801377c:	b29a      	uxth	r2, r3
 801377e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013780:	821a      	strh	r2, [r3, #16]
                            break;
 8013782:	e256      	b.n	8013c32 <event_handler+0x125a>
                        if (connected_uses_aes_ccm){
 8013784:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 8013788:	2b00      	cmp	r3, #0
 801378a:	d005      	beq.n	8013798 <event_handler+0xdc0>
                            conn->authentication_flags |= CONNECTION_AUTHENTICATED;
 801378c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801378e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8013790:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8013794:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013796:	639a      	str	r2, [r3, #56]	; 0x38
                        if ((hci_stack->local_supported_commands[0] & 0x80) != 0){
 8013798:	4b0b      	ldr	r3, [pc, #44]	; (80137c8 <event_handler+0xdf0>)
 801379a:	681b      	ldr	r3, [r3, #0]
 801379c:	f893 3710 	ldrb.w	r3, [r3, #1808]	; 0x710
 80137a0:	b25b      	sxtb	r3, r3
 80137a2:	2b00      	cmp	r3, #0
 80137a4:	da07      	bge.n	80137b6 <event_handler+0xdde>
                            conn->bonding_flags |= BONDING_SEND_READ_ENCRYPTION_KEY_SIZE;
 80137a6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80137a8:	8a1b      	ldrh	r3, [r3, #16]
 80137aa:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80137ae:	b29a      	uxth	r2, r3
 80137b0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80137b2:	821a      	strh	r2, [r3, #16]
            break;
 80137b4:	e22c      	b.n	8013c10 <event_handler+0x1238>
                            hci_handle_read_encryption_key_size_complete(conn, 16);
 80137b6:	2110      	movs	r1, #16
 80137b8:	6e78      	ldr	r0, [r7, #100]	; 0x64
 80137ba:	f7fe fce9 	bl	8012190 <hci_handle_read_encryption_key_size_complete>
            break;
 80137be:	e227      	b.n	8013c10 <event_handler+0x1238>
 80137c0:	0802929c 	.word	0x0802929c
 80137c4:	0802a324 	.word	0x0802a324
 80137c8:	20009780 	.word	0x20009780
 80137cc:	0802a348 	.word	0x0802a348
 80137d0:	0802a38c 	.word	0x0802a38c
 80137d4:	0802a3c4 	.word	0x0802a3c4
                    conn->authentication_flags &= ~CONNECTION_ENCRYPTED;
 80137d8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80137da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80137dc:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 80137e0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80137e2:	639a      	str	r2, [r3, #56]	; 0x38
            break;
 80137e4:	e214      	b.n	8013c10 <event_handler+0x1238>

#ifdef ENABLE_CLASSIC
        case HCI_EVENT_AUTHENTICATION_COMPLETE_EVENT:
            handle = hci_event_authentication_complete_get_connection_handle(packet);
 80137e6:	6878      	ldr	r0, [r7, #4]
 80137e8:	f7fb fea8 	bl	800f53c <hci_event_authentication_complete_get_connection_handle>
 80137ec:	4603      	mov	r3, r0
 80137ee:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            conn = hci_connection_for_handle(handle);
 80137f2:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 80137f6:	4618      	mov	r0, r3
 80137f8:	f7fc f864 	bl	800f8c4 <hci_connection_for_handle>
 80137fc:	6678      	str	r0, [r7, #100]	; 0x64
            if (!conn) break;
 80137fe:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013800:	2b00      	cmp	r3, #0
 8013802:	f000 8207 	beq.w	8013c14 <event_handler+0x123c>

            // ignore authentication event if we didn't request it
            if ((conn->bonding_flags & BONDING_SENT_AUTHENTICATE_REQUEST) == 0) break;
 8013806:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013808:	8a1b      	ldrh	r3, [r3, #16]
 801380a:	b21b      	sxth	r3, r3
 801380c:	2b00      	cmp	r3, #0
 801380e:	f280 8203 	bge.w	8013c18 <event_handler+0x1240>

            // dedicated bonding: send result and disconnect
            if (conn->bonding_flags & BONDING_DEDICATED){
 8013812:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013814:	8a1b      	ldrh	r3, [r3, #16]
 8013816:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801381a:	2b00      	cmp	r3, #0
 801381c:	d012      	beq.n	8013844 <event_handler+0xe6c>
                conn->bonding_flags &= ~BONDING_DEDICATED;
 801381e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013820:	8a1b      	ldrh	r3, [r3, #16]
 8013822:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8013826:	b29a      	uxth	r2, r3
 8013828:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801382a:	821a      	strh	r2, [r3, #16]
                conn->bonding_flags |= BONDING_DISCONNECT_DEDICATED_DONE;
 801382c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801382e:	8a1b      	ldrh	r3, [r3, #16]
 8013830:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8013834:	b29a      	uxth	r2, r3
 8013836:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013838:	821a      	strh	r2, [r3, #16]
                conn->bonding_status = packet[2];
 801383a:	687b      	ldr	r3, [r7, #4]
 801383c:	789a      	ldrb	r2, [r3, #2]
 801383e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013840:	749a      	strb	r2, [r3, #18]
                break;
 8013842:	e1f6      	b.n	8013c32 <event_handler+0x125a>
            }

            // authenticated only if auth status == 0
            if (hci_event_authentication_complete_get_status(packet) == 0){
 8013844:	6878      	ldr	r0, [r7, #4]
 8013846:	f7fb fe6c 	bl	800f522 <hci_event_authentication_complete_get_status>
 801384a:	4603      	mov	r3, r0
 801384c:	2b00      	cmp	r3, #0
 801384e:	d11e      	bne.n	801388e <event_handler+0xeb6>
                // authenticated
                conn->authentication_flags |= CONNECTION_AUTHENTICATED;
 8013850:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013852:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8013854:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8013858:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801385a:	639a      	str	r2, [r3, #56]	; 0x38

                // If link key sufficient for requested security and not already encrypted, start encryption
                if (((gap_security_level_for_link_key_type(conn->link_key_type) >= conn->requested_security_level)) &&
 801385c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801385e:	7d5b      	ldrb	r3, [r3, #21]
 8013860:	4618      	mov	r0, r3
 8013862:	f002 ff6b 	bl	801673c <gap_security_level_for_link_key_type>
 8013866:	4603      	mov	r3, r0
 8013868:	461a      	mov	r2, r3
 801386a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801386c:	7d1b      	ldrb	r3, [r3, #20]
 801386e:	429a      	cmp	r2, r3
 8013870:	d30d      	bcc.n	801388e <event_handler+0xeb6>
                    ((conn->authentication_flags & CONNECTION_ENCRYPTED) == 0)){
 8013872:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013874:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8013876:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
                if (((gap_security_level_for_link_key_type(conn->link_key_type) >= conn->requested_security_level)) &&
 801387a:	2b00      	cmp	r3, #0
 801387c:	d107      	bne.n	801388e <event_handler+0xeb6>
                    conn->bonding_flags |= BONDING_SEND_ENCRYPTION_REQUEST;
 801387e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013880:	8a1b      	ldrh	r3, [r3, #16]
 8013882:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8013886:	b29a      	uxth	r2, r3
 8013888:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801388a:	821a      	strh	r2, [r3, #16]
                    break;
 801388c:	e1d1      	b.n	8013c32 <event_handler+0x125a>
                }
            }

            // emit updated security level
            hci_emit_security_level(handle, gap_security_level_for_connection(conn));
 801388e:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8013890:	f002 fef6 	bl	8016680 <gap_security_level_for_connection>
 8013894:	4603      	mov	r3, r0
 8013896:	461a      	mov	r2, r3
 8013898:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 801389c:	4611      	mov	r1, r2
 801389e:	4618      	mov	r0, r3
 80138a0:	f002 fea4 	bl	80165ec <hci_emit_security_level>
            break;
 80138a4:	e1c5      	b.n	8013c32 <event_handler+0x125a>

        // HCI_EVENT_DISCONNECTION_COMPLETE
        // has been split, to first notify stack before shutting connection down
        // see end of function, too.
        case HCI_EVENT_DISCONNECTION_COMPLETE:
            if (packet[2]) break;   // status != 0
 80138a6:	687b      	ldr	r3, [r7, #4]
 80138a8:	3302      	adds	r3, #2
 80138aa:	781b      	ldrb	r3, [r3, #0]
 80138ac:	2b00      	cmp	r3, #0
 80138ae:	f040 81b5 	bne.w	8013c1c <event_handler+0x1244>
            handle = little_endian_read_16(packet, 3);
 80138b2:	2103      	movs	r1, #3
 80138b4:	6878      	ldr	r0, [r7, #4]
 80138b6:	f7fb fa96 	bl	800ede6 <little_endian_read_16>
 80138ba:	4603      	mov	r3, r0
 80138bc:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            // drop outgoing ACL fragments if it is for closed connection and release buffer if tx not active
            if (hci_stack->acl_fragmentation_total_size > 0u) {
 80138c0:	4bbd      	ldr	r3, [pc, #756]	; (8013bb8 <event_handler+0x11e0>)
 80138c2:	681b      	ldr	r3, [r3, #0]
 80138c4:	f8b3 36f8 	ldrh.w	r3, [r3, #1784]	; 0x6f8
 80138c8:	2b00      	cmp	r3, #0
 80138ca:	d02f      	beq.n	801392c <event_handler+0xf54>
                if (handle == READ_ACL_CONNECTION_HANDLE(hci_stack->hci_packet_buffer)){
 80138cc:	f8b7 4054 	ldrh.w	r4, [r7, #84]	; 0x54
 80138d0:	4bb9      	ldr	r3, [pc, #740]	; (8013bb8 <event_handler+0x11e0>)
 80138d2:	681b      	ldr	r3, [r3, #0]
 80138d4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80138d6:	2100      	movs	r1, #0
 80138d8:	4618      	mov	r0, r3
 80138da:	f7fb fa84 	bl	800ede6 <little_endian_read_16>
 80138de:	4603      	mov	r3, r0
 80138e0:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80138e4:	429c      	cmp	r4, r3
 80138e6:	d121      	bne.n	801392c <event_handler+0xf54>
                    int release_buffer = hci_stack->acl_fragmentation_tx_active == 0u;
 80138e8:	4bb3      	ldr	r3, [pc, #716]	; (8013bb8 <event_handler+0x11e0>)
 80138ea:	681b      	ldr	r3, [r3, #0]
 80138ec:	f893 36fa 	ldrb.w	r3, [r3, #1786]	; 0x6fa
 80138f0:	2b00      	cmp	r3, #0
 80138f2:	bf0c      	ite	eq
 80138f4:	2301      	moveq	r3, #1
 80138f6:	2300      	movne	r3, #0
 80138f8:	b2db      	uxtb	r3, r3
 80138fa:	62fb      	str	r3, [r7, #44]	; 0x2c
                    log_info("drop fragmented ACL data for closed connection, release buffer %u", release_buffer);
 80138fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80138fe:	9300      	str	r3, [sp, #0]
 8013900:	f44f 6329 	mov.w	r3, #2704	; 0xa90
 8013904:	4aad      	ldr	r2, [pc, #692]	; (8013bbc <event_handler+0x11e4>)
 8013906:	49ae      	ldr	r1, [pc, #696]	; (8013bc0 <event_handler+0x11e8>)
 8013908:	2001      	movs	r0, #1
 801390a:	f003 fd99 	bl	8017440 <hci_dump_log>
                    hci_stack->acl_fragmentation_total_size = 0;
 801390e:	4baa      	ldr	r3, [pc, #680]	; (8013bb8 <event_handler+0x11e0>)
 8013910:	681b      	ldr	r3, [r3, #0]
 8013912:	2200      	movs	r2, #0
 8013914:	f8a3 26f8 	strh.w	r2, [r3, #1784]	; 0x6f8
                    hci_stack->acl_fragmentation_pos = 0;
 8013918:	4ba7      	ldr	r3, [pc, #668]	; (8013bb8 <event_handler+0x11e0>)
 801391a:	681b      	ldr	r3, [r3, #0]
 801391c:	2200      	movs	r2, #0
 801391e:	f8a3 26f6 	strh.w	r2, [r3, #1782]	; 0x6f6
                    if (release_buffer){
 8013922:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013924:	2b00      	cmp	r3, #0
 8013926:	d001      	beq.n	801392c <event_handler+0xf54>
                        hci_release_packet_buffer();
 8013928:	f7fc fbe4 	bl	80100f4 <hci_release_packet_buffer>
                    }
                }
            }

            conn = hci_connection_for_handle(handle);
 801392c:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8013930:	4618      	mov	r0, r3
 8013932:	f7fb ffc7 	bl	800f8c4 <hci_connection_for_handle>
 8013936:	6678      	str	r0, [r7, #100]	; 0x64
            if (!conn) break;
 8013938:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801393a:	2b00      	cmp	r3, #0
 801393c:	f000 8170 	beq.w	8013c20 <event_handler+0x1248>
            // mark connection for shutdown
            conn->state = RECEIVED_DISCONNECTION_COMPLETE;
 8013940:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013942:	220a      	movs	r2, #10
 8013944:	739a      	strb	r2, [r3, #14]

            // emit dedicatd bonding event
            if (conn->bonding_flags & BONDING_EMIT_COMPLETE_ON_DISCONNECT){
 8013946:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013948:	8a1b      	ldrh	r3, [r3, #16]
 801394a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 801394e:	2b00      	cmp	r3, #0
 8013950:	d007      	beq.n	8013962 <event_handler+0xf8a>
                hci_emit_dedicated_bonding_result(conn->address, conn->bonding_status);
 8013952:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013954:	1d1a      	adds	r2, r3, #4
 8013956:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013958:	7c9b      	ldrb	r3, [r3, #18]
 801395a:	4619      	mov	r1, r3
 801395c:	4610      	mov	r0, r2
 801395e:	f002 fe01 	bl	8016564 <hci_emit_dedicated_bonding_result>
            }

#ifdef ENABLE_BLE
#ifdef ENABLE_LE_PERIPHERAL
            // re-enable advertisements for le connections if active
            if (hci_is_le_connection(conn)){
 8013962:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8013964:	f7fc f932 	bl	800fbcc <hci_is_le_connection>
 8013968:	4603      	mov	r3, r0
 801396a:	2b00      	cmp	r3, #0
 801396c:	f000 815a 	beq.w	8013c24 <event_handler+0x124c>
                hci_update_advertisements_enabled_for_current_roles();
 8013970:	f7fd f858 	bl	8010a24 <hci_update_advertisements_enabled_for_current_roles>
            }
#endif
#endif
            break;
 8013974:	e156      	b.n	8013c24 <event_handler+0x124c>

        case HCI_EVENT_HARDWARE_ERROR:
            log_error("Hardware Error: 0x%02x", packet[2]);
 8013976:	687b      	ldr	r3, [r7, #4]
 8013978:	3302      	adds	r3, #2
 801397a:	781b      	ldrb	r3, [r3, #0]
 801397c:	9300      	str	r3, [sp, #0]
 801397e:	f640 23ae 	movw	r3, #2734	; 0xaae
 8013982:	4a8e      	ldr	r2, [pc, #568]	; (8013bbc <event_handler+0x11e4>)
 8013984:	498f      	ldr	r1, [pc, #572]	; (8013bc4 <event_handler+0x11ec>)
 8013986:	2002      	movs	r0, #2
 8013988:	f003 fd5a 	bl	8017440 <hci_dump_log>
            if (hci_stack->hardware_error_callback){
 801398c:	4b8a      	ldr	r3, [pc, #552]	; (8013bb8 <event_handler+0x11e0>)
 801398e:	681b      	ldr	r3, [r3, #0]
 8013990:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013992:	2b00      	cmp	r3, #0
 8013994:	d008      	beq.n	80139a8 <event_handler+0xfd0>
                (*hci_stack->hardware_error_callback)(packet[2]);
 8013996:	4b88      	ldr	r3, [pc, #544]	; (8013bb8 <event_handler+0x11e0>)
 8013998:	681b      	ldr	r3, [r3, #0]
 801399a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801399c:	687a      	ldr	r2, [r7, #4]
 801399e:	3202      	adds	r2, #2
 80139a0:	7812      	ldrb	r2, [r2, #0]
 80139a2:	4610      	mov	r0, r2
 80139a4:	4798      	blx	r3
            } else {
                // if no special requests, just reboot stack
                hci_power_control_off();
                hci_power_control_on();
            }
            break;
 80139a6:	e144      	b.n	8013c32 <event_handler+0x125a>
                hci_power_control_off();
 80139a8:	f000 fca2 	bl	80142f0 <hci_power_control_off>
                hci_power_control_on();
 80139ac:	f000 fc28 	bl	8014200 <hci_power_control_on>
            break;
 80139b0:	e13f      	b.n	8013c32 <event_handler+0x125a>

#ifdef ENABLE_CLASSIC
        case HCI_EVENT_ROLE_CHANGE:
            if (packet[2]) break;   // status != 0
 80139b2:	687b      	ldr	r3, [r7, #4]
 80139b4:	3302      	adds	r3, #2
 80139b6:	781b      	ldrb	r3, [r3, #0]
 80139b8:	2b00      	cmp	r3, #0
 80139ba:	f040 8135 	bne.w	8013c28 <event_handler+0x1250>
            reverse_bd_addr(&packet[3], addr);
 80139be:	687b      	ldr	r3, [r7, #4]
 80139c0:	3303      	adds	r3, #3
 80139c2:	f107 021c 	add.w	r2, r7, #28
 80139c6:	4611      	mov	r1, r2
 80139c8:	4618      	mov	r0, r3
 80139ca:	f7fb fb92 	bl	800f0f2 <reverse_bd_addr>
            addr_type = BD_ADDR_TYPE_ACL;
 80139ce:	23fd      	movs	r3, #253	; 0xfd
 80139d0:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
            conn = hci_connection_for_bd_addr_and_type(addr, addr_type);
 80139d4:	f897 2039 	ldrb.w	r2, [r7, #57]	; 0x39
 80139d8:	f107 031c 	add.w	r3, r7, #28
 80139dc:	4611      	mov	r1, r2
 80139de:	4618      	mov	r0, r3
 80139e0:	f7fb ff9c 	bl	800f91c <hci_connection_for_bd_addr_and_type>
 80139e4:	6678      	str	r0, [r7, #100]	; 0x64
            if (!conn) break;
 80139e6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80139e8:	2b00      	cmp	r3, #0
 80139ea:	f000 811f 	beq.w	8013c2c <event_handler+0x1254>
            conn->role = packet[9];
 80139ee:	687b      	ldr	r3, [r7, #4]
 80139f0:	7a5a      	ldrb	r2, [r3, #9]
 80139f2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80139f4:	735a      	strb	r2, [r3, #13]
            break;
 80139f6:	e11c      	b.n	8013c32 <event_handler+0x125a>
#endif

        case HCI_EVENT_TRANSPORT_PACKET_SENT:
            // release packet buffer only for asynchronous transport and if there are not further fragements
            if (hci_transport_synchronous()) {
 80139f8:	f7fc fb8a 	bl	8010110 <hci_transport_synchronous>
 80139fc:	4603      	mov	r3, r0
 80139fe:	2b00      	cmp	r3, #0
 8013a00:	d007      	beq.n	8013a12 <event_handler+0x103a>
                log_error("Synchronous HCI Transport shouldn't send HCI_EVENT_TRANSPORT_PACKET_SENT");
 8013a02:	f640 23c6 	movw	r3, #2758	; 0xac6
 8013a06:	4a6d      	ldr	r2, [pc, #436]	; (8013bbc <event_handler+0x11e4>)
 8013a08:	496f      	ldr	r1, [pc, #444]	; (8013bc8 <event_handler+0x11f0>)
 8013a0a:	2002      	movs	r0, #2
 8013a0c:	f003 fd18 	bl	8017440 <hci_dump_log>
                return; // instead of break: to avoid re-entering hci_run()
 8013a10:	e142      	b.n	8013c98 <event_handler+0x12c0>
            }
            hci_stack->acl_fragmentation_tx_active = 0;
 8013a12:	4b69      	ldr	r3, [pc, #420]	; (8013bb8 <event_handler+0x11e0>)
 8013a14:	681b      	ldr	r3, [r3, #0]
 8013a16:	2200      	movs	r2, #0
 8013a18:	f883 26fa 	strb.w	r2, [r3, #1786]	; 0x6fa
            if (hci_stack->acl_fragmentation_total_size) break;
 8013a1c:	4b66      	ldr	r3, [pc, #408]	; (8013bb8 <event_handler+0x11e0>)
 8013a1e:	681b      	ldr	r3, [r3, #0]
 8013a20:	f8b3 36f8 	ldrh.w	r3, [r3, #1784]	; 0x6f8
 8013a24:	2b00      	cmp	r3, #0
 8013a26:	f040 8103 	bne.w	8013c30 <event_handler+0x1258>
            hci_release_packet_buffer();
 8013a2a:	f7fc fb63 	bl	80100f4 <hci_release_packet_buffer>
            
            // L2CAP receives this event via the hci_emit_event below

#ifdef ENABLE_CLASSIC
            // For SCO, we do the can_send_now_check here
            hci_notify_if_sco_can_send_now();
 8013a2e:	f002 fb3b 	bl	80160a8 <hci_notify_if_sco_can_send_now>
#endif
            break;
 8013a32:	e0fe      	b.n	8013c32 <event_handler+0x125a>

#ifdef ENABLE_CLASSIC
        case HCI_EVENT_SCO_CAN_SEND_NOW:
            // For SCO, we do the can_send_now_check here
            hci_stack->sco_can_send_now = 1;
 8013a34:	4b60      	ldr	r3, [pc, #384]	; (8013bb8 <event_handler+0x11e0>)
 8013a36:	681b      	ldr	r3, [r3, #0]
 8013a38:	2201      	movs	r2, #1
 8013a3a:	f883 2707 	strb.w	r2, [r3, #1799]	; 0x707
            hci_notify_if_sco_can_send_now();
 8013a3e:	f002 fb33 	bl	80160a8 <hci_notify_if_sco_can_send_now>
            return;
 8013a42:	e129      	b.n	8013c98 <event_handler+0x12c0>

        // explode inquriy results for easier consumption
        case HCI_EVENT_INQUIRY_RESULT:
        case HCI_EVENT_INQUIRY_RESULT_WITH_RSSI:
        case HCI_EVENT_EXTENDED_INQUIRY_RESPONSE:
            gap_inquiry_explode(packet, size);
 8013a44:	887b      	ldrh	r3, [r7, #2]
 8013a46:	4619      	mov	r1, r3
 8013a48:	6878      	ldr	r0, [r7, #4]
 8013a4a:	f002 fb59 	bl	8016100 <gap_inquiry_explode>
            break;
 8013a4e:	e0f0      	b.n	8013c32 <event_handler+0x125a>
#endif

#ifdef ENABLE_BLE
        case HCI_EVENT_LE_META:
            switch (packet[2]){
 8013a50:	687b      	ldr	r3, [r7, #4]
 8013a52:	3302      	adds	r3, #2
 8013a54:	781b      	ldrb	r3, [r3, #0]
 8013a56:	3b01      	subs	r3, #1
 8013a58:	2b05      	cmp	r3, #5
 8013a5a:	f200 8096 	bhi.w	8013b8a <event_handler+0x11b2>
 8013a5e:	a201      	add	r2, pc, #4	; (adr r2, 8013a64 <event_handler+0x108c>)
 8013a60:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013a64:	08013a9b 	.word	0x08013a9b
 8013a68:	08013a7d 	.word	0x08013a7d
 8013a6c:	08013aa3 	.word	0x08013aa3
 8013a70:	08013b8b 	.word	0x08013b8b
 8013a74:	08013b8b 	.word	0x08013b8b
 8013a78:	08013ad3 	.word	0x08013ad3
#ifdef ENABLE_LE_CENTRAL
                case HCI_SUBEVENT_LE_ADVERTISING_REPORT:
                    // log_info("advertising report received");
                    if (!hci_stack->le_scanning_enabled) break;
 8013a7c:	4b4e      	ldr	r3, [pc, #312]	; (8013bb8 <event_handler+0x11e0>)
 8013a7e:	681b      	ldr	r3, [r3, #0]
 8013a80:	f893 3764 	ldrb.w	r3, [r3, #1892]	; 0x764
 8013a84:	f083 0301 	eor.w	r3, r3, #1
 8013a88:	b2db      	uxtb	r3, r3
 8013a8a:	2b00      	cmp	r3, #0
 8013a8c:	d17f      	bne.n	8013b8e <event_handler+0x11b6>
                    le_handle_advertisement_report(packet, size);
 8013a8e:	887b      	ldrh	r3, [r7, #2]
 8013a90:	4619      	mov	r1, r3
 8013a92:	6878      	ldr	r0, [r7, #4]
 8013a94:	f7fc ff24 	bl	80108e0 <le_handle_advertisement_report>
                    break;
 8013a98:	e07e      	b.n	8013b98 <event_handler+0x11c0>
#endif
                case HCI_SUBEVENT_LE_CONNECTION_COMPLETE:
					event_handle_le_connection_complete(packet);
 8013a9a:	6878      	ldr	r0, [r7, #4]
 8013a9c:	f7fe fed6 	bl	801284c <event_handle_le_connection_complete>
                    break;
 8013aa0:	e07a      	b.n	8013b98 <event_handler+0x11c0>

                // log_info("LE buffer size: %u, count %u", little_endian_read_16(packet,6), packet[8]);
                case HCI_SUBEVENT_LE_CONNECTION_UPDATE_COMPLETE:
                    handle = hci_subevent_le_connection_update_complete_get_connection_handle(packet);
 8013aa2:	6878      	ldr	r0, [r7, #4]
 8013aa4:	f7fb fddc 	bl	800f660 <hci_subevent_le_connection_update_complete_get_connection_handle>
 8013aa8:	4603      	mov	r3, r0
 8013aaa:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
                    conn = hci_connection_for_handle(handle);
 8013aae:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8013ab2:	4618      	mov	r0, r3
 8013ab4:	f7fb ff06 	bl	800f8c4 <hci_connection_for_handle>
 8013ab8:	6678      	str	r0, [r7, #100]	; 0x64
                    if (!conn) break;
 8013aba:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013abc:	2b00      	cmp	r3, #0
 8013abe:	d068      	beq.n	8013b92 <event_handler+0x11ba>
                    conn->le_connection_interval = hci_subevent_le_connection_update_complete_get_conn_interval(packet);
 8013ac0:	6878      	ldr	r0, [r7, #4]
 8013ac2:	f7fb fdda 	bl	800f67a <hci_subevent_le_connection_update_complete_get_conn_interval>
 8013ac6:	4603      	mov	r3, r0
 8013ac8:	461a      	mov	r2, r3
 8013aca:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013acc:	f8a3 2716 	strh.w	r2, [r3, #1814]	; 0x716
                    break;
 8013ad0:	e062      	b.n	8013b98 <event_handler+0x11c0>

                case HCI_SUBEVENT_LE_REMOTE_CONNECTION_PARAMETER_REQUEST:
                    // connection
                    handle = hci_subevent_le_remote_connection_parameter_request_get_connection_handle(packet);
 8013ad2:	6878      	ldr	r0, [r7, #4]
 8013ad4:	f7fb fdde 	bl	800f694 <hci_subevent_le_remote_connection_parameter_request_get_connection_handle>
 8013ad8:	4603      	mov	r3, r0
 8013ada:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
                    conn = hci_connection_for_handle(handle);
 8013ade:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8013ae2:	4618      	mov	r0, r3
 8013ae4:	f7fb feee 	bl	800f8c4 <hci_connection_for_handle>
 8013ae8:	6678      	str	r0, [r7, #100]	; 0x64
                    if (conn) {
 8013aea:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013aec:	2b00      	cmp	r3, #0
 8013aee:	d052      	beq.n	8013b96 <event_handler+0x11be>
                        // read arguments
                        uint16_t le_conn_interval_min   = hci_subevent_le_remote_connection_parameter_request_get_interval_min(packet);
 8013af0:	6878      	ldr	r0, [r7, #4]
 8013af2:	f7fb fddc 	bl	800f6ae <hci_subevent_le_remote_connection_parameter_request_get_interval_min>
 8013af6:	4603      	mov	r3, r0
 8013af8:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                        uint16_t le_conn_interval_max   = hci_subevent_le_remote_connection_parameter_request_get_interval_max(packet);
 8013afc:	6878      	ldr	r0, [r7, #4]
 8013afe:	f7fb fde3 	bl	800f6c8 <hci_subevent_le_remote_connection_parameter_request_get_interval_max>
 8013b02:	4603      	mov	r3, r0
 8013b04:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                        uint16_t le_conn_latency        = hci_subevent_le_remote_connection_parameter_request_get_latency(packet);
 8013b08:	6878      	ldr	r0, [r7, #4]
 8013b0a:	f7fb fdea 	bl	800f6e2 <hci_subevent_le_remote_connection_parameter_request_get_latency>
 8013b0e:	4603      	mov	r3, r0
 8013b10:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
                        uint16_t le_supervision_timeout = hci_subevent_le_remote_connection_parameter_request_get_timeout(packet);
 8013b14:	6878      	ldr	r0, [r7, #4]
 8013b16:	f7fb fdf1 	bl	800f6fc <hci_subevent_le_remote_connection_parameter_request_get_timeout>
 8013b1a:	4603      	mov	r3, r0
 8013b1c:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

                        // validate against current connection parameter range
                        le_connection_parameter_range_t existing_range;
                        gap_get_connection_parameter_range(&existing_range);
 8013b20:	f107 030c 	add.w	r3, r7, #12
 8013b24:	4618      	mov	r0, r3
 8013b26:	f7fb fe67 	bl	800f7f8 <gap_get_connection_parameter_range>
                        int update_parameter = gap_connection_parameter_range_included(&existing_range, le_conn_interval_min, le_conn_interval_max, le_conn_latency, le_supervision_timeout);
 8013b2a:	f8b7 404e 	ldrh.w	r4, [r7, #78]	; 0x4e
 8013b2e:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 8013b32:	f8b7 1052 	ldrh.w	r1, [r7, #82]	; 0x52
 8013b36:	f107 000c 	add.w	r0, r7, #12
 8013b3a:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8013b3e:	9300      	str	r3, [sp, #0]
 8013b40:	4623      	mov	r3, r4
 8013b42:	f7fb fe6f 	bl	800f824 <gap_connection_parameter_range_included>
 8013b46:	64b8      	str	r0, [r7, #72]	; 0x48
                        if (update_parameter){
 8013b48:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8013b4a:	2b00      	cmp	r3, #0
 8013b4c:	d018      	beq.n	8013b80 <event_handler+0x11a8>
                            conn->le_con_parameter_update_state = CON_PARAMETER_UPDATE_REPLY;
 8013b4e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013b50:	2205      	movs	r2, #5
 8013b52:	f883 270b 	strb.w	r2, [r3, #1803]	; 0x70b
                            conn->le_conn_interval_min = le_conn_interval_min;
 8013b56:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013b58:	f8b7 2052 	ldrh.w	r2, [r7, #82]	; 0x52
 8013b5c:	f8a3 270e 	strh.w	r2, [r3, #1806]	; 0x70e
                            conn->le_conn_interval_max = le_conn_interval_max;
 8013b60:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013b62:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 8013b66:	f8a3 2710 	strh.w	r2, [r3, #1808]	; 0x710
                            conn->le_conn_latency = le_conn_latency;
 8013b6a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013b6c:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 8013b70:	f8a3 2712 	strh.w	r2, [r3, #1810]	; 0x712
                            conn->le_supervision_timeout = le_supervision_timeout;
 8013b74:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013b76:	f8b7 204c 	ldrh.w	r2, [r7, #76]	; 0x4c
 8013b7a:	f8a3 2714 	strh.w	r2, [r3, #1812]	; 0x714
                        } else {
                            conn->le_con_parameter_update_state = CON_PARAMETER_UPDATE_NEGATIVE_REPLY;
                        }
                    }
                    break;
 8013b7e:	e00a      	b.n	8013b96 <event_handler+0x11be>
                            conn->le_con_parameter_update_state = CON_PARAMETER_UPDATE_NEGATIVE_REPLY;
 8013b80:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8013b82:	2206      	movs	r2, #6
 8013b84:	f883 270b 	strb.w	r2, [r3, #1803]	; 0x70b
                    break;
 8013b88:	e005      	b.n	8013b96 <event_handler+0x11be>
                        conn->le_max_tx_octets = hci_subevent_le_data_length_change_get_max_tx_octets(packet);
                    }
                    break;
#endif
                default:
                    break;
 8013b8a:	bf00      	nop
 8013b8c:	e051      	b.n	8013c32 <event_handler+0x125a>
                    if (!hci_stack->le_scanning_enabled) break;
 8013b8e:	bf00      	nop
 8013b90:	e04f      	b.n	8013c32 <event_handler+0x125a>
                    if (!conn) break;
 8013b92:	bf00      	nop
 8013b94:	e04d      	b.n	8013c32 <event_handler+0x125a>
                    break;
 8013b96:	bf00      	nop
            }
            break;
 8013b98:	e04b      	b.n	8013c32 <event_handler+0x125a>
#endif
        case HCI_EVENT_VENDOR_SPECIFIC:
            // Vendor specific commands often create vendor specific event instead of num completed packets
            // To avoid getting stuck as num_cmds_packets is zero, reset it to 1 for controllers with this behaviour
            switch (hci_stack->manufacturer){
 8013b9a:	4b07      	ldr	r3, [pc, #28]	; (8013bb8 <event_handler+0x11e0>)
 8013b9c:	681b      	ldr	r3, [r3, #0]
 8013b9e:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 8013ba2:	2b0a      	cmp	r3, #10
 8013ba4:	d000      	beq.n	8013ba8 <event_handler+0x11d0>
                case BLUETOOTH_COMPANY_ID_CAMBRIDGE_SILICON_RADIO:
                    hci_stack->num_cmd_packets = 1;
                    break;
                default:
                    break;
 8013ba6:	e005      	b.n	8013bb4 <event_handler+0x11dc>
                    hci_stack->num_cmd_packets = 1;
 8013ba8:	4b03      	ldr	r3, [pc, #12]	; (8013bb8 <event_handler+0x11e0>)
 8013baa:	681b      	ldr	r3, [r3, #0]
 8013bac:	2201      	movs	r2, #1
 8013bae:	f883 26fb 	strb.w	r2, [r3, #1787]	; 0x6fb
                    break;
 8013bb2:	bf00      	nop
            }
            break;
 8013bb4:	e03d      	b.n	8013c32 <event_handler+0x125a>
 8013bb6:	bf00      	nop
 8013bb8:	20009780 	.word	0x20009780
 8013bbc:	0802929c 	.word	0x0802929c
 8013bc0:	0802a3f8 	.word	0x0802a3f8
 8013bc4:	0802a444 	.word	0x0802a444
 8013bc8:	0802a464 	.word	0x0802a464
        default:
            break;
 8013bcc:	bf00      	nop
 8013bce:	e030      	b.n	8013c32 <event_handler+0x125a>
            break;
 8013bd0:	bf00      	nop
 8013bd2:	e02e      	b.n	8013c32 <event_handler+0x125a>
            break;
 8013bd4:	bf00      	nop
 8013bd6:	e02c      	b.n	8013c32 <event_handler+0x125a>
            break;
 8013bd8:	bf00      	nop
 8013bda:	e02a      	b.n	8013c32 <event_handler+0x125a>
            break;
 8013bdc:	bf00      	nop
 8013bde:	e028      	b.n	8013c32 <event_handler+0x125a>
                break;
 8013be0:	bf00      	nop
 8013be2:	e026      	b.n	8013c32 <event_handler+0x125a>
                break;
 8013be4:	bf00      	nop
 8013be6:	e024      	b.n	8013c32 <event_handler+0x125a>
            break;
 8013be8:	bf00      	nop
 8013bea:	e022      	b.n	8013c32 <event_handler+0x125a>
            if (!conn) break;
 8013bec:	bf00      	nop
 8013bee:	e020      	b.n	8013c32 <event_handler+0x125a>
            if (!conn) break;
 8013bf0:	bf00      	nop
 8013bf2:	e01e      	b.n	8013c32 <event_handler+0x125a>
                if (!done) break;
 8013bf4:	bf00      	nop
 8013bf6:	e01c      	b.n	8013c32 <event_handler+0x125a>
            if (!conn) break;
 8013bf8:	bf00      	nop
 8013bfa:	e01a      	b.n	8013c32 <event_handler+0x125a>
            if (!hci_stack->link_key_db) break;
 8013bfc:	bf00      	nop
 8013bfe:	e018      	b.n	8013c32 <event_handler+0x125a>
            if (!hci_stack->ssp_auto_accept) break;
 8013c00:	bf00      	nop
 8013c02:	e016      	b.n	8013c32 <event_handler+0x125a>
            if (!hci_stack->ssp_auto_accept) break;
 8013c04:	bf00      	nop
 8013c06:	e014      	b.n	8013c32 <event_handler+0x125a>
            if (!conn) break;
 8013c08:	bf00      	nop
 8013c0a:	e012      	b.n	8013c32 <event_handler+0x125a>
            if (!conn) break;
 8013c0c:	bf00      	nop
 8013c0e:	e010      	b.n	8013c32 <event_handler+0x125a>
            break;
 8013c10:	bf00      	nop
 8013c12:	e00e      	b.n	8013c32 <event_handler+0x125a>
            if (!conn) break;
 8013c14:	bf00      	nop
 8013c16:	e00c      	b.n	8013c32 <event_handler+0x125a>
            if ((conn->bonding_flags & BONDING_SENT_AUTHENTICATE_REQUEST) == 0) break;
 8013c18:	bf00      	nop
 8013c1a:	e00a      	b.n	8013c32 <event_handler+0x125a>
            if (packet[2]) break;   // status != 0
 8013c1c:	bf00      	nop
 8013c1e:	e008      	b.n	8013c32 <event_handler+0x125a>
            if (!conn) break;
 8013c20:	bf00      	nop
 8013c22:	e006      	b.n	8013c32 <event_handler+0x125a>
            break;
 8013c24:	bf00      	nop
 8013c26:	e004      	b.n	8013c32 <event_handler+0x125a>
            if (packet[2]) break;   // status != 0
 8013c28:	bf00      	nop
 8013c2a:	e002      	b.n	8013c32 <event_handler+0x125a>
            if (!conn) break;
 8013c2c:	bf00      	nop
 8013c2e:	e000      	b.n	8013c32 <event_handler+0x125a>
            if (hci_stack->acl_fragmentation_total_size) break;
 8013c30:	bf00      	nop
    }

    handle_event_for_current_stack_state(packet, size);
 8013c32:	887b      	ldrh	r3, [r7, #2]
 8013c34:	4619      	mov	r1, r3
 8013c36:	6878      	ldr	r0, [r7, #4]
 8013c38:	f7fe fa74 	bl	8012124 <handle_event_for_current_stack_state>

    // notify upper stack
	hci_emit_event(packet, size, 0);   // don't dump, already happened in packet handler
 8013c3c:	887b      	ldrh	r3, [r7, #2]
 8013c3e:	2200      	movs	r2, #0
 8013c40:	4619      	mov	r1, r3
 8013c42:	6878      	ldr	r0, [r7, #4]
 8013c44:	f002 f9e0 	bl	8016008 <hci_emit_event>

    // moved here to give upper stack a chance to close down everything with hci_connection_t intact
    if ((hci_event_packet_get_type(packet) == HCI_EVENT_DISCONNECTION_COMPLETE) && (packet[2] == 0)){
 8013c48:	6878      	ldr	r0, [r7, #4]
 8013c4a:	f7fb fc51 	bl	800f4f0 <hci_event_packet_get_type>
 8013c4e:	4603      	mov	r3, r0
 8013c50:	2b05      	cmp	r3, #5
 8013c52:	d11b      	bne.n	8013c8c <event_handler+0x12b4>
 8013c54:	687b      	ldr	r3, [r7, #4]
 8013c56:	3302      	adds	r3, #2
 8013c58:	781b      	ldrb	r3, [r3, #0]
 8013c5a:	2b00      	cmp	r3, #0
 8013c5c:	d116      	bne.n	8013c8c <event_handler+0x12b4>
		handle = little_endian_read_16(packet, 3);
 8013c5e:	2103      	movs	r1, #3
 8013c60:	6878      	ldr	r0, [r7, #4]
 8013c62:	f7fb f8c0 	bl	800ede6 <little_endian_read_16>
 8013c66:	4603      	mov	r3, r0
 8013c68:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
		hci_connection_t * aConn = hci_connection_for_handle(handle);
 8013c6c:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8013c70:	4618      	mov	r0, r3
 8013c72:	f7fb fe27 	bl	800f8c4 <hci_connection_for_handle>
 8013c76:	6278      	str	r0, [r7, #36]	; 0x24
		// discard connection if app did not trigger a reconnect in the event handler
		if (aConn && aConn->state == RECEIVED_DISCONNECTION_COMPLETE){
 8013c78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013c7a:	2b00      	cmp	r3, #0
 8013c7c:	d006      	beq.n	8013c8c <event_handler+0x12b4>
 8013c7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013c80:	7b9b      	ldrb	r3, [r3, #14]
 8013c82:	2b0a      	cmp	r3, #10
 8013c84:	d102      	bne.n	8013c8c <event_handler+0x12b4>
			hci_shutdown_connection(aConn);
 8013c86:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8013c88:	f7fc fca6 	bl	80105d8 <hci_shutdown_connection>
		}
    }

	// execute main loop
	hci_run();
 8013c8c:	f001 fe08 	bl	80158a0 <hci_run>
 8013c90:	e002      	b.n	8013c98 <event_handler+0x12c0>
            if (size < 3) return;
 8013c92:	bf00      	nop
 8013c94:	e000      	b.n	8013c98 <event_handler+0x12c0>
            if (size != (3u + num_handles * 4u)) return;
 8013c96:	bf00      	nop
}
 8013c98:	3768      	adds	r7, #104	; 0x68
 8013c9a:	46bd      	mov	sp, r7
 8013c9c:	bdb0      	pop	{r4, r5, r7, pc}
 8013c9e:	bf00      	nop

08013ca0 <sco_tx_timeout_handler>:
#ifdef ENABLE_CLASSIC

static void sco_tx_timeout_handler(btstack_timer_source_t * ts);
static void sco_schedule_tx(hci_connection_t * conn);

static void sco_tx_timeout_handler(btstack_timer_source_t * ts){
 8013ca0:	b580      	push	{r7, lr}
 8013ca2:	b084      	sub	sp, #16
 8013ca4:	af00      	add	r7, sp, #0
 8013ca6:	6078      	str	r0, [r7, #4]
    log_debug("SCO TX Timeout");
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) btstack_run_loop_get_timer_context(ts);
 8013ca8:	6878      	ldr	r0, [r7, #4]
 8013caa:	f7fa fff3 	bl	800ec94 <btstack_run_loop_get_timer_context>
 8013cae:	4603      	mov	r3, r0
 8013cb0:	81fb      	strh	r3, [r7, #14]
    hci_connection_t * conn = hci_connection_for_handle(con_handle);
 8013cb2:	89fb      	ldrh	r3, [r7, #14]
 8013cb4:	4618      	mov	r0, r3
 8013cb6:	f7fb fe05 	bl	800f8c4 <hci_connection_for_handle>
 8013cba:	60b8      	str	r0, [r7, #8]
    if (!conn) return;
 8013cbc:	68bb      	ldr	r3, [r7, #8]
 8013cbe:	2b00      	cmp	r3, #0
 8013cc0:	d01c      	beq.n	8013cfc <sco_tx_timeout_handler+0x5c>

    // trigger send
    conn->sco_tx_ready = 1;
 8013cc2:	68bb      	ldr	r3, [r7, #8]
 8013cc4:	2201      	movs	r2, #1
 8013cc6:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
    // extra packet if CVSD but SCO buffer is too short
    if (((hci_stack->sco_voice_setting_active & 0x03) != 0x03) && (hci_stack->sco_data_packet_length < 123)){
 8013cca:	4b0e      	ldr	r3, [pc, #56]	; (8013d04 <sco_tx_timeout_handler+0x64>)
 8013ccc:	681b      	ldr	r3, [r3, #0]
 8013cce:	f8b3 374a 	ldrh.w	r3, [r3, #1866]	; 0x74a
 8013cd2:	f003 0303 	and.w	r3, r3, #3
 8013cd6:	2b03      	cmp	r3, #3
 8013cd8:	d00d      	beq.n	8013cf6 <sco_tx_timeout_handler+0x56>
 8013cda:	4b0a      	ldr	r3, [pc, #40]	; (8013d04 <sco_tx_timeout_handler+0x64>)
 8013cdc:	681b      	ldr	r3, [r3, #0]
 8013cde:	f893 3701 	ldrb.w	r3, [r3, #1793]	; 0x701
 8013ce2:	2b7a      	cmp	r3, #122	; 0x7a
 8013ce4:	d807      	bhi.n	8013cf6 <sco_tx_timeout_handler+0x56>
        conn->sco_tx_ready++;
 8013ce6:	68bb      	ldr	r3, [r7, #8]
 8013ce8:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8013cec:	3301      	adds	r3, #1
 8013cee:	b2da      	uxtb	r2, r3
 8013cf0:	68bb      	ldr	r3, [r7, #8]
 8013cf2:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
    }
    hci_notify_if_sco_can_send_now();
 8013cf6:	f002 f9d7 	bl	80160a8 <hci_notify_if_sco_can_send_now>
 8013cfa:	e000      	b.n	8013cfe <sco_tx_timeout_handler+0x5e>
    if (!conn) return;
 8013cfc:	bf00      	nop
}
 8013cfe:	3710      	adds	r7, #16
 8013d00:	46bd      	mov	sp, r7
 8013d02:	bd80      	pop	{r7, pc}
 8013d04:	20009780 	.word	0x20009780

08013d08 <sco_schedule_tx>:


#define SCO_TX_AFTER_RX_MS (6)

static void sco_schedule_tx(hci_connection_t * conn){
 8013d08:	b580      	push	{r7, lr}
 8013d0a:	b086      	sub	sp, #24
 8013d0c:	af00      	add	r7, sp, #0
 8013d0e:	6078      	str	r0, [r7, #4]

    uint32_t now = btstack_run_loop_get_time_ms();
 8013d10:	f7fa ffec 	bl	800ecec <btstack_run_loop_get_time_ms>
 8013d14:	6178      	str	r0, [r7, #20]
    uint32_t sco_tx_ms = conn->sco_rx_ms + SCO_TX_AFTER_RX_MS;
 8013d16:	687b      	ldr	r3, [r7, #4]
 8013d18:	6a1b      	ldr	r3, [r3, #32]
 8013d1a:	3306      	adds	r3, #6
 8013d1c:	613b      	str	r3, [r7, #16]
    int time_delta_ms = sco_tx_ms - now;
 8013d1e:	693a      	ldr	r2, [r7, #16]
 8013d20:	697b      	ldr	r3, [r7, #20]
 8013d22:	1ad3      	subs	r3, r2, r3
 8013d24:	60fb      	str	r3, [r7, #12]

    btstack_timer_source_t * timer = (conn->sco_rx_count & 1) ? &conn->timeout : &conn->timeout_sco;
 8013d26:	687b      	ldr	r3, [r7, #4]
 8013d28:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8013d2c:	f003 0301 	and.w	r3, r3, #1
 8013d30:	2b00      	cmp	r3, #0
 8013d32:	d002      	beq.n	8013d3a <sco_schedule_tx+0x32>
 8013d34:	687b      	ldr	r3, [r7, #4]
 8013d36:	333c      	adds	r3, #60	; 0x3c
 8013d38:	e001      	b.n	8013d3e <sco_schedule_tx+0x36>
 8013d3a:	687b      	ldr	r3, [r7, #4]
 8013d3c:	3328      	adds	r3, #40	; 0x28
 8013d3e:	60bb      	str	r3, [r7, #8]

    // log_error("SCO TX at %u in %u", (int) sco_tx_ms, time_delta_ms);
    btstack_run_loop_set_timer(timer, time_delta_ms);
 8013d40:	68fb      	ldr	r3, [r7, #12]
 8013d42:	4619      	mov	r1, r3
 8013d44:	68b8      	ldr	r0, [r7, #8]
 8013d46:	f7fa ff85 	bl	800ec54 <btstack_run_loop_set_timer>
    btstack_run_loop_set_timer_context(timer, (void *) (uintptr_t) conn->con_handle);
 8013d4a:	687b      	ldr	r3, [r7, #4]
 8013d4c:	895b      	ldrh	r3, [r3, #10]
 8013d4e:	4619      	mov	r1, r3
 8013d50:	68b8      	ldr	r0, [r7, #8]
 8013d52:	f7fa ff91 	bl	800ec78 <btstack_run_loop_set_timer_context>
    btstack_run_loop_set_timer_handler(timer, &sco_tx_timeout_handler);
 8013d56:	4905      	ldr	r1, [pc, #20]	; (8013d6c <sco_schedule_tx+0x64>)
 8013d58:	68b8      	ldr	r0, [r7, #8]
 8013d5a:	f7fa ff17 	bl	800eb8c <btstack_run_loop_set_timer_handler>
    btstack_run_loop_add_timer(timer);
 8013d5e:	68b8      	ldr	r0, [r7, #8]
 8013d60:	f7fa ffa4 	bl	800ecac <btstack_run_loop_add_timer>
}
 8013d64:	bf00      	nop
 8013d66:	3718      	adds	r7, #24
 8013d68:	46bd      	mov	sp, r7
 8013d6a:	bd80      	pop	{r7, pc}
 8013d6c:	08013ca1 	.word	0x08013ca1

08013d70 <sco_handler>:

static void sco_handler(uint8_t * packet, uint16_t size){
 8013d70:	b590      	push	{r4, r7, lr}
 8013d72:	b087      	sub	sp, #28
 8013d74:	af00      	add	r7, sp, #0
 8013d76:	6078      	str	r0, [r7, #4]
 8013d78:	460b      	mov	r3, r1
 8013d7a:	807b      	strh	r3, [r7, #2]
    // lookup connection struct
    hci_con_handle_t con_handle = READ_SCO_CONNECTION_HANDLE(packet);
 8013d7c:	2100      	movs	r1, #0
 8013d7e:	6878      	ldr	r0, [r7, #4]
 8013d80:	f7fb f831 	bl	800ede6 <little_endian_read_16>
 8013d84:	4603      	mov	r3, r0
 8013d86:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8013d8a:	82fb      	strh	r3, [r7, #22]
    hci_connection_t * conn     = hci_connection_for_handle(con_handle);
 8013d8c:	8afb      	ldrh	r3, [r7, #22]
 8013d8e:	4618      	mov	r0, r3
 8013d90:	f7fb fd98 	bl	800f8c4 <hci_connection_for_handle>
 8013d94:	6138      	str	r0, [r7, #16]
    if (!conn) return;
 8013d96:	693b      	ldr	r3, [r7, #16]
 8013d98:	2b00      	cmp	r3, #0
 8013d9a:	d078      	beq.n	8013e8e <sco_handler+0x11e>

    // CSR 8811 prefixes 60 byte SCO packet in transparent mode with 20 zero bytes -> skip first 20 payload bytes
    if (hci_stack->manufacturer == BLUETOOTH_COMPANY_ID_CAMBRIDGE_SILICON_RADIO){
 8013d9c:	4b3e      	ldr	r3, [pc, #248]	; (8013e98 <sco_handler+0x128>)
 8013d9e:	681b      	ldr	r3, [r3, #0]
 8013da0:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
 8013da4:	2b0a      	cmp	r3, #10
 8013da6:	d118      	bne.n	8013dda <sco_handler+0x6a>
        if ((size == 83) && ((hci_stack->sco_voice_setting_active & 0x03) == 0x03)){
 8013da8:	887b      	ldrh	r3, [r7, #2]
 8013daa:	2b53      	cmp	r3, #83	; 0x53
 8013dac:	d115      	bne.n	8013dda <sco_handler+0x6a>
 8013dae:	4b3a      	ldr	r3, [pc, #232]	; (8013e98 <sco_handler+0x128>)
 8013db0:	681b      	ldr	r3, [r3, #0]
 8013db2:	f8b3 374a 	ldrh.w	r3, [r3, #1866]	; 0x74a
 8013db6:	f003 0303 	and.w	r3, r3, #3
 8013dba:	2b03      	cmp	r3, #3
 8013dbc:	d10d      	bne.n	8013dda <sco_handler+0x6a>
            packet[2] = 0x3c;
 8013dbe:	687b      	ldr	r3, [r7, #4]
 8013dc0:	3302      	adds	r3, #2
 8013dc2:	223c      	movs	r2, #60	; 0x3c
 8013dc4:	701a      	strb	r2, [r3, #0]
            memmove(&packet[3], &packet[23], 63);
 8013dc6:	687b      	ldr	r3, [r7, #4]
 8013dc8:	1cd8      	adds	r0, r3, #3
 8013dca:	687b      	ldr	r3, [r7, #4]
 8013dcc:	3317      	adds	r3, #23
 8013dce:	223f      	movs	r2, #63	; 0x3f
 8013dd0:	4619      	mov	r1, r3
 8013dd2:	f013 fe5d 	bl	8027a90 <memmove>
            size = 63;
 8013dd6:	233f      	movs	r3, #63	; 0x3f
 8013dd8:	807b      	strh	r3, [r7, #2]
        }
    }

    if (hci_have_usb_transport()){
 8013dda:	f002 fe93 	bl	8016b04 <hci_have_usb_transport>
 8013dde:	4603      	mov	r3, r0
 8013de0:	2b00      	cmp	r3, #0
 8013de2:	d146      	bne.n	8013e72 <sco_handler+0x102>
        // Nothing to do
    } else {
        // log_debug("sco flow %u, handle 0x%04x, packets sent %u, bytes send %u", hci_stack->synchronous_flow_control_enabled, (int) con_handle, conn->num_packets_sent, conn->num_sco_bytes_sent);
        if (hci_stack->synchronous_flow_control_enabled == 0){
 8013de4:	4b2c      	ldr	r3, [pc, #176]	; (8013e98 <sco_handler+0x128>)
 8013de6:	681b      	ldr	r3, [r3, #0]
 8013de8:	f893 3702 	ldrb.w	r3, [r3, #1794]	; 0x702
 8013dec:	2b00      	cmp	r3, #0
 8013dee:	d140      	bne.n	8013e72 <sco_handler+0x102>
            uint32_t now = btstack_run_loop_get_time_ms();
 8013df0:	f7fa ff7c 	bl	800ecec <btstack_run_loop_get_time_ms>
 8013df4:	60f8      	str	r0, [r7, #12]

            if (!conn->sco_rx_valid){
 8013df6:	693b      	ldr	r3, [r7, #16]
 8013df8:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8013dfc:	2b00      	cmp	r3, #0
 8013dfe:	d11b      	bne.n	8013e38 <sco_handler+0xc8>
                // ignore first 10 packets
                conn->sco_rx_count++;
 8013e00:	693b      	ldr	r3, [r7, #16]
 8013e02:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8013e06:	3301      	adds	r3, #1
 8013e08:	b2da      	uxtb	r2, r3
 8013e0a:	693b      	ldr	r3, [r7, #16]
 8013e0c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                // log_debug("sco rx count %u", conn->sco_rx_count);
                if (conn->sco_rx_count == 10) {
 8013e10:	693b      	ldr	r3, [r7, #16]
 8013e12:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8013e16:	2b0a      	cmp	r3, #10
 8013e18:	d12b      	bne.n	8013e72 <sco_handler+0x102>
                    // use first timestamp as is and pretent it just started
                    conn->sco_rx_ms = now;
 8013e1a:	693b      	ldr	r3, [r7, #16]
 8013e1c:	68fa      	ldr	r2, [r7, #12]
 8013e1e:	621a      	str	r2, [r3, #32]
                    conn->sco_rx_valid = 1;
 8013e20:	693b      	ldr	r3, [r7, #16]
 8013e22:	2201      	movs	r2, #1
 8013e24:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
                    conn->sco_rx_count = 0;
 8013e28:	693b      	ldr	r3, [r7, #16]
 8013e2a:	2200      	movs	r2, #0
 8013e2c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                    sco_schedule_tx(conn);
 8013e30:	6938      	ldr	r0, [r7, #16]
 8013e32:	f7ff ff69 	bl	8013d08 <sco_schedule_tx>
 8013e36:	e01c      	b.n	8013e72 <sco_handler+0x102>
                }
            } else {
                // track expected arrival timme
                conn->sco_rx_count++;
 8013e38:	693b      	ldr	r3, [r7, #16]
 8013e3a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8013e3e:	3301      	adds	r3, #1
 8013e40:	b2da      	uxtb	r2, r3
 8013e42:	693b      	ldr	r3, [r7, #16]
 8013e44:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                conn->sco_rx_ms += 7;
 8013e48:	693b      	ldr	r3, [r7, #16]
 8013e4a:	6a1b      	ldr	r3, [r3, #32]
 8013e4c:	1dda      	adds	r2, r3, #7
 8013e4e:	693b      	ldr	r3, [r7, #16]
 8013e50:	621a      	str	r2, [r3, #32]
                int delta = (int32_t) (now - conn->sco_rx_ms);
 8013e52:	693b      	ldr	r3, [r7, #16]
 8013e54:	6a1b      	ldr	r3, [r3, #32]
 8013e56:	68fa      	ldr	r2, [r7, #12]
 8013e58:	1ad3      	subs	r3, r2, r3
 8013e5a:	60bb      	str	r3, [r7, #8]
                if (delta > 0){
 8013e5c:	68bb      	ldr	r3, [r7, #8]
 8013e5e:	2b00      	cmp	r3, #0
 8013e60:	dd04      	ble.n	8013e6c <sco_handler+0xfc>
                    conn->sco_rx_ms++;
 8013e62:	693b      	ldr	r3, [r7, #16]
 8013e64:	6a1b      	ldr	r3, [r3, #32]
 8013e66:	1c5a      	adds	r2, r3, #1
 8013e68:	693b      	ldr	r3, [r7, #16]
 8013e6a:	621a      	str	r2, [r3, #32]
                }
                // log_debug("sco rx %u", conn->sco_rx_ms);
                sco_schedule_tx(conn);
 8013e6c:	6938      	ldr	r0, [r7, #16]
 8013e6e:	f7ff ff4b 	bl	8013d08 <sco_schedule_tx>
            }
        }
    }
    // deliver to app
    if (hci_stack->sco_packet_handler) {
 8013e72:	4b09      	ldr	r3, [pc, #36]	; (8013e98 <sco_handler+0x128>)
 8013e74:	681b      	ldr	r3, [r3, #0]
 8013e76:	69db      	ldr	r3, [r3, #28]
 8013e78:	2b00      	cmp	r3, #0
 8013e7a:	d009      	beq.n	8013e90 <sco_handler+0x120>
        hci_stack->sco_packet_handler(HCI_SCO_DATA_PACKET, 0, packet, size);
 8013e7c:	4b06      	ldr	r3, [pc, #24]	; (8013e98 <sco_handler+0x128>)
 8013e7e:	681b      	ldr	r3, [r3, #0]
 8013e80:	69dc      	ldr	r4, [r3, #28]
 8013e82:	887b      	ldrh	r3, [r7, #2]
 8013e84:	687a      	ldr	r2, [r7, #4]
 8013e86:	2100      	movs	r1, #0
 8013e88:	2003      	movs	r0, #3
 8013e8a:	47a0      	blx	r4
 8013e8c:	e000      	b.n	8013e90 <sco_handler+0x120>
    if (!conn) return;
 8013e8e:	bf00      	nop
#ifdef ENABLE_HCI_CONTROLLER_TO_HOST_FLOW_CONTROL
    conn->num_packets_completed++;
    hci_stack->host_completed_packets = 1;
    hci_run();
#endif    
}
 8013e90:	371c      	adds	r7, #28
 8013e92:	46bd      	mov	sp, r7
 8013e94:	bd90      	pop	{r4, r7, pc}
 8013e96:	bf00      	nop
 8013e98:	20009780 	.word	0x20009780

08013e9c <packet_handler>:
#endif

static void packet_handler(uint8_t packet_type, uint8_t *packet, uint16_t size){
 8013e9c:	b580      	push	{r7, lr}
 8013e9e:	b082      	sub	sp, #8
 8013ea0:	af00      	add	r7, sp, #0
 8013ea2:	4603      	mov	r3, r0
 8013ea4:	6039      	str	r1, [r7, #0]
 8013ea6:	71fb      	strb	r3, [r7, #7]
 8013ea8:	4613      	mov	r3, r2
 8013eaa:	80bb      	strh	r3, [r7, #4]
    hci_dump_packet(packet_type, 1, packet, size);
 8013eac:	88bb      	ldrh	r3, [r7, #4]
 8013eae:	79f8      	ldrb	r0, [r7, #7]
 8013eb0:	683a      	ldr	r2, [r7, #0]
 8013eb2:	2101      	movs	r1, #1
 8013eb4:	f003 fa1e 	bl	80172f4 <hci_dump_packet>
    switch (packet_type) {
 8013eb8:	79fb      	ldrb	r3, [r7, #7]
 8013eba:	2b03      	cmp	r3, #3
 8013ebc:	d010      	beq.n	8013ee0 <packet_handler+0x44>
 8013ebe:	2b04      	cmp	r3, #4
 8013ec0:	d002      	beq.n	8013ec8 <packet_handler+0x2c>
 8013ec2:	2b02      	cmp	r3, #2
 8013ec4:	d006      	beq.n	8013ed4 <packet_handler+0x38>
        case HCI_SCO_DATA_PACKET:
            sco_handler(packet, size);
            break;
#endif
        default:
            break;
 8013ec6:	e011      	b.n	8013eec <packet_handler+0x50>
            event_handler(packet, size);
 8013ec8:	88bb      	ldrh	r3, [r7, #4]
 8013eca:	4619      	mov	r1, r3
 8013ecc:	6838      	ldr	r0, [r7, #0]
 8013ece:	f7fe fd83 	bl	80129d8 <event_handler>
            break;
 8013ed2:	e00b      	b.n	8013eec <packet_handler+0x50>
            acl_handler(packet, size);
 8013ed4:	88bb      	ldrh	r3, [r7, #4]
 8013ed6:	4619      	mov	r1, r3
 8013ed8:	6838      	ldr	r0, [r7, #0]
 8013eda:	f7fc fa57 	bl	801038c <acl_handler>
            break;
 8013ede:	e005      	b.n	8013eec <packet_handler+0x50>
            sco_handler(packet, size);
 8013ee0:	88bb      	ldrh	r3, [r7, #4]
 8013ee2:	4619      	mov	r1, r3
 8013ee4:	6838      	ldr	r0, [r7, #0]
 8013ee6:	f7ff ff43 	bl	8013d70 <sco_handler>
            break;
 8013eea:	bf00      	nop
    }
}
 8013eec:	bf00      	nop
 8013eee:	3708      	adds	r7, #8
 8013ef0:	46bd      	mov	sp, r7
 8013ef2:	bd80      	pop	{r7, pc}

08013ef4 <hci_add_event_handler>:

/**
 * @brief Add event packet handler. 
 */
void hci_add_event_handler(btstack_packet_callback_registration_t * callback_handler){
 8013ef4:	b580      	push	{r7, lr}
 8013ef6:	b082      	sub	sp, #8
 8013ef8:	af00      	add	r7, sp, #0
 8013efa:	6078      	str	r0, [r7, #4]
    btstack_linked_list_add_tail(&hci_stack->event_handlers, (btstack_linked_item_t*) callback_handler);
 8013efc:	4b05      	ldr	r3, [pc, #20]	; (8013f14 <hci_add_event_handler+0x20>)
 8013efe:	681b      	ldr	r3, [r3, #0]
 8013f00:	3320      	adds	r3, #32
 8013f02:	6879      	ldr	r1, [r7, #4]
 8013f04:	4618      	mov	r0, r3
 8013f06:	f7fa fbb7 	bl	800e678 <btstack_linked_list_add_tail>
}
 8013f0a:	bf00      	nop
 8013f0c:	3708      	adds	r7, #8
 8013f0e:	46bd      	mov	sp, r7
 8013f10:	bd80      	pop	{r7, pc}
 8013f12:	bf00      	nop
 8013f14:	20009780 	.word	0x20009780

08013f18 <hci_register_acl_packet_handler>:


/** Register HCI packet handlers */
void hci_register_acl_packet_handler(btstack_packet_handler_t handler){
 8013f18:	b480      	push	{r7}
 8013f1a:	b083      	sub	sp, #12
 8013f1c:	af00      	add	r7, sp, #0
 8013f1e:	6078      	str	r0, [r7, #4]
    hci_stack->acl_packet_handler = handler;
 8013f20:	4b04      	ldr	r3, [pc, #16]	; (8013f34 <hci_register_acl_packet_handler+0x1c>)
 8013f22:	681b      	ldr	r3, [r3, #0]
 8013f24:	687a      	ldr	r2, [r7, #4]
 8013f26:	619a      	str	r2, [r3, #24]
}
 8013f28:	bf00      	nop
 8013f2a:	370c      	adds	r7, #12
 8013f2c:	46bd      	mov	sp, r7
 8013f2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f32:	4770      	bx	lr
 8013f34:	20009780 	.word	0x20009780

08013f38 <hci_state_reset>:
void hci_register_sco_packet_handler(btstack_packet_handler_t handler){
    hci_stack->sco_packet_handler = handler;    
}
#endif

static void hci_state_reset(void){
 8013f38:	b580      	push	{r7, lr}
 8013f3a:	af00      	add	r7, sp, #0
    // no connections yet
    hci_stack->connections = NULL;
 8013f3c:	4b1d      	ldr	r3, [pc, #116]	; (8013fb4 <hci_state_reset+0x7c>)
 8013f3e:	681b      	ldr	r3, [r3, #0]
 8013f40:	2200      	movs	r2, #0
 8013f42:	615a      	str	r2, [r3, #20]
    // hci_stack->connectable = 0;
    // hci_stack->bondable = 1;
    // hci_stack->own_addr_type = 0;

    // buffer is free
    hci_stack->hci_packet_buffer_reserved = 0;
 8013f44:	4b1b      	ldr	r3, [pc, #108]	; (8013fb4 <hci_state_reset+0x7c>)
 8013f46:	681b      	ldr	r3, [r3, #0]
 8013f48:	2200      	movs	r2, #0
 8013f4a:	f883 26f4 	strb.w	r2, [r3, #1780]	; 0x6f4

    // no pending cmds
    hci_stack->decline_reason = 0;
 8013f4e:	4b19      	ldr	r3, [pc, #100]	; (8013fb4 <hci_state_reset+0x7c>)
 8013f50:	681b      	ldr	r3, [r3, #0]
 8013f52:	2200      	movs	r2, #0
 8013f54:	f883 274d 	strb.w	r2, [r3, #1869]	; 0x74d
    hci_stack->new_scan_enable_value = 0xff;
 8013f58:	4b16      	ldr	r3, [pc, #88]	; (8013fb4 <hci_state_reset+0x7c>)
 8013f5a:	681b      	ldr	r3, [r3, #0]
 8013f5c:	22ff      	movs	r2, #255	; 0xff
 8013f5e:	f883 272d 	strb.w	r2, [r3, #1837]	; 0x72d

    hci_stack->secure_connections_active = false;
 8013f62:	4b14      	ldr	r3, [pc, #80]	; (8013fb4 <hci_state_reset+0x7c>)
 8013f64:	681b      	ldr	r3, [r3, #0]
 8013f66:	2200      	movs	r2, #0
 8013f68:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    hci_stack->classic_read_local_oob_data = true;
#endif

    // LE
#ifdef ENABLE_BLE
    memset(hci_stack->le_random_address, 0, 6);
 8013f6c:	4b11      	ldr	r3, [pc, #68]	; (8013fb4 <hci_state_reset+0x7c>)
 8013f6e:	681b      	ldr	r3, [r3, #0]
 8013f70:	f203 7355 	addw	r3, r3, #1877	; 0x755
 8013f74:	2206      	movs	r2, #6
 8013f76:	2100      	movs	r1, #0
 8013f78:	4618      	mov	r0, r3
 8013f7a:	f013 fda2 	bl	8027ac2 <memset>
    hci_stack->le_random_address_set = 0;
 8013f7e:	4b0d      	ldr	r3, [pc, #52]	; (8013fb4 <hci_state_reset+0x7c>)
 8013f80:	681b      	ldr	r3, [r3, #0]
 8013f82:	2200      	movs	r2, #0
 8013f84:	f883 275b 	strb.w	r2, [r3, #1883]	; 0x75b
#endif
#ifdef ENABLE_LE_CENTRAL
    hci_stack->le_scanning_active  = 0;
 8013f88:	4b0a      	ldr	r3, [pc, #40]	; (8013fb4 <hci_state_reset+0x7c>)
 8013f8a:	681b      	ldr	r3, [r3, #0]
 8013f8c:	2200      	movs	r2, #0
 8013f8e:	f883 2765 	strb.w	r2, [r3, #1893]	; 0x765
    hci_stack->le_connecting_state = LE_CONNECTING_IDLE;
 8013f92:	4b08      	ldr	r3, [pc, #32]	; (8013fb4 <hci_state_reset+0x7c>)
 8013f94:	681b      	ldr	r3, [r3, #0]
 8013f96:	2200      	movs	r2, #0
 8013f98:	f883 2766 	strb.w	r2, [r3, #1894]	; 0x766
    hci_stack->le_connecting_request = LE_CONNECTING_IDLE;
 8013f9c:	4b05      	ldr	r3, [pc, #20]	; (8013fb4 <hci_state_reset+0x7c>)
 8013f9e:	681b      	ldr	r3, [r3, #0]
 8013fa0:	2200      	movs	r2, #0
 8013fa2:	f883 2767 	strb.w	r2, [r3, #1895]	; 0x767
    hci_stack->le_whitelist_capacity = 0;
 8013fa6:	4b03      	ldr	r3, [pc, #12]	; (8013fb4 <hci_state_reset+0x7c>)
 8013fa8:	681b      	ldr	r3, [r3, #0]
 8013faa:	2200      	movs	r2, #0
 8013fac:	f883 275c 	strb.w	r2, [r3, #1884]	; 0x75c
#endif
}
 8013fb0:	bf00      	nop
 8013fb2:	bd80      	pop	{r7, pc}
 8013fb4:	20009780 	.word	0x20009780

08013fb8 <hci_set_link_key_db>:

#ifdef ENABLE_CLASSIC
/**
 * @brief Configure Bluetooth hardware control. Has to be called before power on.
 */
void hci_set_link_key_db(btstack_link_key_db_t const * link_key_db){
 8013fb8:	b580      	push	{r7, lr}
 8013fba:	b082      	sub	sp, #8
 8013fbc:	af00      	add	r7, sp, #0
 8013fbe:	6078      	str	r0, [r7, #4]
    // store and open remote device db
    hci_stack->link_key_db = link_key_db;
 8013fc0:	4b08      	ldr	r3, [pc, #32]	; (8013fe4 <hci_set_link_key_db+0x2c>)
 8013fc2:	681b      	ldr	r3, [r3, #0]
 8013fc4:	687a      	ldr	r2, [r7, #4]
 8013fc6:	611a      	str	r2, [r3, #16]
    if (hci_stack->link_key_db) {
 8013fc8:	4b06      	ldr	r3, [pc, #24]	; (8013fe4 <hci_set_link_key_db+0x2c>)
 8013fca:	681b      	ldr	r3, [r3, #0]
 8013fcc:	691b      	ldr	r3, [r3, #16]
 8013fce:	2b00      	cmp	r3, #0
 8013fd0:	d004      	beq.n	8013fdc <hci_set_link_key_db+0x24>
        hci_stack->link_key_db->open();
 8013fd2:	4b04      	ldr	r3, [pc, #16]	; (8013fe4 <hci_set_link_key_db+0x2c>)
 8013fd4:	681b      	ldr	r3, [r3, #0]
 8013fd6:	691b      	ldr	r3, [r3, #16]
 8013fd8:	681b      	ldr	r3, [r3, #0]
 8013fda:	4798      	blx	r3
    }
}
 8013fdc:	bf00      	nop
 8013fde:	3708      	adds	r7, #8
 8013fe0:	46bd      	mov	sp, r7
 8013fe2:	bd80      	pop	{r7, pc}
 8013fe4:	20009780 	.word	0x20009780

08013fe8 <hci_init>:
#endif

void hci_init(const hci_transport_t *transport, const void *config){
 8013fe8:	b580      	push	{r7, lr}
 8013fea:	b082      	sub	sp, #8
 8013fec:	af00      	add	r7, sp, #0
 8013fee:	6078      	str	r0, [r7, #4]
 8013ff0:	6039      	str	r1, [r7, #0]
#ifdef HAVE_MALLOC
    if (!hci_stack) {
        hci_stack = (hci_stack_t*) malloc(sizeof(hci_stack_t));
    }
#else
    hci_stack = &hci_stack_static;
 8013ff2:	4b66      	ldr	r3, [pc, #408]	; (801418c <hci_init+0x1a4>)
 8013ff4:	4a66      	ldr	r2, [pc, #408]	; (8014190 <hci_init+0x1a8>)
 8013ff6:	601a      	str	r2, [r3, #0]
#endif
    memset(hci_stack, 0, sizeof(hci_stack_t));
 8013ff8:	4b64      	ldr	r3, [pc, #400]	; (801418c <hci_init+0x1a4>)
 8013ffa:	681b      	ldr	r3, [r3, #0]
 8013ffc:	f240 72c4 	movw	r2, #1988	; 0x7c4
 8014000:	2100      	movs	r1, #0
 8014002:	4618      	mov	r0, r3
 8014004:	f013 fd5d 	bl	8027ac2 <memset>

    // reference to use transport layer implementation
    hci_stack->hci_transport = transport;
 8014008:	4b60      	ldr	r3, [pc, #384]	; (801418c <hci_init+0x1a4>)
 801400a:	681b      	ldr	r3, [r3, #0]
 801400c:	687a      	ldr	r2, [r7, #4]
 801400e:	601a      	str	r2, [r3, #0]
        
    // reference to used config
    hci_stack->config = config;
 8014010:	4b5e      	ldr	r3, [pc, #376]	; (801418c <hci_init+0x1a4>)
 8014012:	681b      	ldr	r3, [r3, #0]
 8014014:	683a      	ldr	r2, [r7, #0]
 8014016:	605a      	str	r2, [r3, #4]
    
    // setup pointer for outgoing packet buffer
    hci_stack->hci_packet_buffer = &hci_stack->hci_packet_buffer_data[HCI_OUTGOING_PRE_BUFFER_SIZE];
 8014018:	4b5c      	ldr	r3, [pc, #368]	; (801418c <hci_init+0x1a4>)
 801401a:	681a      	ldr	r2, [r3, #0]
 801401c:	4b5b      	ldr	r3, [pc, #364]	; (801418c <hci_init+0x1a4>)
 801401e:	681b      	ldr	r3, [r3, #0]
 8014020:	3251      	adds	r2, #81	; 0x51
 8014022:	64da      	str	r2, [r3, #76]	; 0x4c

    // max acl payload size defined in config.h
    hci_stack->acl_data_packet_length = HCI_ACL_PAYLOAD_SIZE;
 8014024:	4b59      	ldr	r3, [pc, #356]	; (801418c <hci_init+0x1a4>)
 8014026:	681b      	ldr	r3, [r3, #0]
 8014028:	f240 629f 	movw	r2, #1695	; 0x69f
 801402c:	f8a3 26fe 	strh.w	r2, [r3, #1790]	; 0x6fe
    
    // register packet handlers with transport
    transport->register_packet_handler(&packet_handler);
 8014030:	687b      	ldr	r3, [r7, #4]
 8014032:	691b      	ldr	r3, [r3, #16]
 8014034:	4857      	ldr	r0, [pc, #348]	; (8014194 <hci_init+0x1ac>)
 8014036:	4798      	blx	r3

    hci_stack->state = HCI_STATE_OFF;
 8014038:	4b54      	ldr	r3, [pc, #336]	; (801418c <hci_init+0x1a4>)
 801403a:	681b      	ldr	r3, [r3, #0]
 801403c:	2200      	movs	r2, #0
 801403e:	f883 2716 	strb.w	r2, [r3, #1814]	; 0x716

    // class of device
    hci_stack->class_of_device = 0x007a020c; // Smartphone 
 8014042:	4b52      	ldr	r3, [pc, #328]	; (801418c <hci_init+0x1a4>)
 8014044:	681b      	ldr	r3, [r3, #0]
 8014046:	4a54      	ldr	r2, [pc, #336]	; (8014198 <hci_init+0x1b0>)
 8014048:	635a      	str	r2, [r3, #52]	; 0x34

    // bondable by default
    hci_stack->bondable = 1;
 801404a:	4b50      	ldr	r3, [pc, #320]	; (801418c <hci_init+0x1a4>)
 801404c:	681b      	ldr	r3, [r3, #0]
 801404e:	2201      	movs	r2, #1
 8014050:	f883 2730 	strb.w	r2, [r3, #1840]	; 0x730

#ifdef ENABLE_CLASSIC
    // classic name
    hci_stack->local_name = default_classic_name;
 8014054:	4b4d      	ldr	r3, [pc, #308]	; (801418c <hci_init+0x1a4>)
 8014056:	681b      	ldr	r3, [r3, #0]
 8014058:	4a50      	ldr	r2, [pc, #320]	; (801419c <hci_init+0x1b4>)
 801405a:	6812      	ldr	r2, [r2, #0]
 801405c:	62da      	str	r2, [r3, #44]	; 0x2c

    // Master slave policy
    hci_stack->master_slave_policy = 1;
 801405e:	4b4b      	ldr	r3, [pc, #300]	; (801418c <hci_init+0x1a4>)
 8014060:	681b      	ldr	r3, [r3, #0]
 8014062:	2201      	movs	r2, #1
 8014064:	f883 27b9 	strb.w	r2, [r3, #1977]	; 0x7b9

    // Allow Role Switch
    hci_stack->allow_role_switch = 1;
 8014068:	4b48      	ldr	r3, [pc, #288]	; (801418c <hci_init+0x1a4>)
 801406a:	681b      	ldr	r3, [r3, #0]
 801406c:	2201      	movs	r2, #1
 801406e:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f

    // Default / minimum security level = 2
    hci_stack->gap_security_level = LEVEL_2;
 8014072:	4b46      	ldr	r3, [pc, #280]	; (801418c <hci_init+0x1a4>)
 8014074:	681b      	ldr	r3, [r3, #0]
 8014076:	2202      	movs	r2, #2
 8014078:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a

    // Errata-11838 mandates 7 bytes for GAP Security Level 1-3
    hci_stack->gap_required_encyrption_key_size = 7;
 801407c:	4b43      	ldr	r3, [pc, #268]	; (801418c <hci_init+0x1a4>)
 801407e:	681b      	ldr	r3, [r3, #0]
 8014080:	2207      	movs	r2, #7
 8014082:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
#endif

    // Secure Simple Pairing default: enable, no I/O capabilities, general bonding, mitm not required, auto accept 
    hci_stack->ssp_enable = 1;
 8014086:	4b41      	ldr	r3, [pc, #260]	; (801418c <hci_init+0x1a4>)
 8014088:	681b      	ldr	r3, [r3, #0]
 801408a:	2201      	movs	r2, #1
 801408c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    hci_stack->ssp_io_capability = SSP_IO_CAPABILITY_NO_INPUT_NO_OUTPUT;
 8014090:	4b3e      	ldr	r3, [pc, #248]	; (801418c <hci_init+0x1a4>)
 8014092:	681b      	ldr	r3, [r3, #0]
 8014094:	2203      	movs	r2, #3
 8014096:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hci_stack->ssp_authentication_requirement = SSP_IO_AUTHREQ_MITM_PROTECTION_NOT_REQUIRED_GENERAL_BONDING;
 801409a:	4b3c      	ldr	r3, [pc, #240]	; (801418c <hci_init+0x1a4>)
 801409c:	681b      	ldr	r3, [r3, #0]
 801409e:	2204      	movs	r2, #4
 80140a0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hci_stack->ssp_auto_accept = 1;
 80140a4:	4b39      	ldr	r3, [pc, #228]	; (801418c <hci_init+0x1a4>)
 80140a6:	681b      	ldr	r3, [r3, #0]
 80140a8:	2201      	movs	r2, #1
 80140aa:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

    // Secure Connections: enable (requires support from Controller)
    hci_stack->secure_connections_enable = true;
 80140ae:	4b37      	ldr	r3, [pc, #220]	; (801418c <hci_init+0x1a4>)
 80140b0:	681b      	ldr	r3, [r3, #0]
 80140b2:	2201      	movs	r2, #1
 80140b4:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

    // voice setting - signed 16 bit pcm data with CVSD over the air
    hci_stack->sco_voice_setting = 0x60;
 80140b8:	4b34      	ldr	r3, [pc, #208]	; (801418c <hci_init+0x1a4>)
 80140ba:	681b      	ldr	r3, [r3, #0]
 80140bc:	2260      	movs	r2, #96	; 0x60
 80140be:	f8a3 2748 	strh.w	r2, [r3, #1864]	; 0x748

#ifdef ENABLE_LE_CENTRAL
    // connection parameter to use for outgoing connections
    hci_stack->le_connection_scan_interval = 0x0060;   // 60ms
 80140c2:	4b32      	ldr	r3, [pc, #200]	; (801418c <hci_init+0x1a4>)
 80140c4:	681b      	ldr	r3, [r3, #0]
 80140c6:	2260      	movs	r2, #96	; 0x60
 80140c8:	f8a3 277c 	strh.w	r2, [r3, #1916]	; 0x77c
    hci_stack->le_connection_scan_window  = 0x0030;    // 30ms
 80140cc:	4b2f      	ldr	r3, [pc, #188]	; (801418c <hci_init+0x1a4>)
 80140ce:	681b      	ldr	r3, [r3, #0]
 80140d0:	2230      	movs	r2, #48	; 0x30
 80140d2:	f8a3 277e 	strh.w	r2, [r3, #1918]	; 0x77e
    hci_stack->le_connection_interval_min = 0x0008;    // 10 ms
 80140d6:	4b2d      	ldr	r3, [pc, #180]	; (801418c <hci_init+0x1a4>)
 80140d8:	681b      	ldr	r3, [r3, #0]
 80140da:	2208      	movs	r2, #8
 80140dc:	f8a3 2770 	strh.w	r2, [r3, #1904]	; 0x770
    hci_stack->le_connection_interval_max = 0x0018;    // 30 ms
 80140e0:	4b2a      	ldr	r3, [pc, #168]	; (801418c <hci_init+0x1a4>)
 80140e2:	681b      	ldr	r3, [r3, #0]
 80140e4:	2218      	movs	r2, #24
 80140e6:	f8a3 2772 	strh.w	r2, [r3, #1906]	; 0x772
    hci_stack->le_connection_latency      = 4;         // 4
 80140ea:	4b28      	ldr	r3, [pc, #160]	; (801418c <hci_init+0x1a4>)
 80140ec:	681b      	ldr	r3, [r3, #0]
 80140ee:	2204      	movs	r2, #4
 80140f0:	f8a3 2774 	strh.w	r2, [r3, #1908]	; 0x774
    hci_stack->le_supervision_timeout     = 0x0048;    // 720 ms
 80140f4:	4b25      	ldr	r3, [pc, #148]	; (801418c <hci_init+0x1a4>)
 80140f6:	681b      	ldr	r3, [r3, #0]
 80140f8:	2248      	movs	r2, #72	; 0x48
 80140fa:	f8a3 2776 	strh.w	r2, [r3, #1910]	; 0x776
    hci_stack->le_minimum_ce_length       = 2;         // 1.25 ms
 80140fe:	4b23      	ldr	r3, [pc, #140]	; (801418c <hci_init+0x1a4>)
 8014100:	681b      	ldr	r3, [r3, #0]
 8014102:	2202      	movs	r2, #2
 8014104:	f8a3 2778 	strh.w	r2, [r3, #1912]	; 0x778
    hci_stack->le_maximum_ce_length       = 0x0030;    // 30 ms
 8014108:	4b20      	ldr	r3, [pc, #128]	; (801418c <hci_init+0x1a4>)
 801410a:	681b      	ldr	r3, [r3, #0]
 801410c:	2230      	movs	r2, #48	; 0x30
 801410e:	f8a3 277a 	strh.w	r2, [r3, #1914]	; 0x77a

    // default LE Scanning
    hci_stack->le_scan_type     =   0x1; // active
 8014112:	4b1e      	ldr	r3, [pc, #120]	; (801418c <hci_init+0x1a4>)
 8014114:	681b      	ldr	r3, [r3, #0]
 8014116:	2201      	movs	r2, #1
 8014118:	f883 2769 	strb.w	r2, [r3, #1897]	; 0x769
    hci_stack->le_scan_interval = 0x1e0; // 300 ms
 801411c:	4b1b      	ldr	r3, [pc, #108]	; (801418c <hci_init+0x1a4>)
 801411e:	681b      	ldr	r3, [r3, #0]
 8014120:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 8014124:	f8a3 276c 	strh.w	r2, [r3, #1900]	; 0x76c
    hci_stack->le_scan_window   =  0x30; //  30 ms
 8014128:	4b18      	ldr	r3, [pc, #96]	; (801418c <hci_init+0x1a4>)
 801412a:	681b      	ldr	r3, [r3, #0]
 801412c:	2230      	movs	r2, #48	; 0x30
 801412e:	f8a3 276e 	strh.w	r2, [r3, #1902]	; 0x76e
#endif

#ifdef ENABLE_LE_PERIPHERAL
    hci_stack->le_max_number_peripheral_connections = 1; // only single connection as peripheral
 8014132:	4b16      	ldr	r3, [pc, #88]	; (801418c <hci_init+0x1a4>)
 8014134:	681b      	ldr	r3, [r3, #0]
 8014136:	2201      	movs	r2, #1
 8014138:	f883 27ac 	strb.w	r2, [r3, #1964]	; 0x7ac
#endif

    // connection parameter range used to answer connection parameter update requests in l2cap
    hci_stack->le_connection_parameter_range.le_conn_interval_min =          6; 
 801413c:	4b13      	ldr	r3, [pc, #76]	; (801418c <hci_init+0x1a4>)
 801413e:	681b      	ldr	r3, [r3, #0]
 8014140:	2206      	movs	r2, #6
 8014142:	f8a3 2780 	strh.w	r2, [r3, #1920]	; 0x780
    hci_stack->le_connection_parameter_range.le_conn_interval_max =       3200;
 8014146:	4b11      	ldr	r3, [pc, #68]	; (801418c <hci_init+0x1a4>)
 8014148:	681b      	ldr	r3, [r3, #0]
 801414a:	f44f 6248 	mov.w	r2, #3200	; 0xc80
 801414e:	f8a3 2782 	strh.w	r2, [r3, #1922]	; 0x782
    hci_stack->le_connection_parameter_range.le_conn_latency_min =           0;
 8014152:	4b0e      	ldr	r3, [pc, #56]	; (801418c <hci_init+0x1a4>)
 8014154:	681b      	ldr	r3, [r3, #0]
 8014156:	2200      	movs	r2, #0
 8014158:	f8a3 2784 	strh.w	r2, [r3, #1924]	; 0x784
    hci_stack->le_connection_parameter_range.le_conn_latency_max =         500;
 801415c:	4b0b      	ldr	r3, [pc, #44]	; (801418c <hci_init+0x1a4>)
 801415e:	681b      	ldr	r3, [r3, #0]
 8014160:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8014164:	f8a3 2786 	strh.w	r2, [r3, #1926]	; 0x786
    hci_stack->le_connection_parameter_range.le_supervision_timeout_min =   10;
 8014168:	4b08      	ldr	r3, [pc, #32]	; (801418c <hci_init+0x1a4>)
 801416a:	681b      	ldr	r3, [r3, #0]
 801416c:	220a      	movs	r2, #10
 801416e:	f8a3 2788 	strh.w	r2, [r3, #1928]	; 0x788
    hci_stack->le_connection_parameter_range.le_supervision_timeout_max = 3200;
 8014172:	4b06      	ldr	r3, [pc, #24]	; (801418c <hci_init+0x1a4>)
 8014174:	681b      	ldr	r3, [r3, #0]
 8014176:	f44f 6248 	mov.w	r2, #3200	; 0xc80
 801417a:	f8a3 278a 	strh.w	r2, [r3, #1930]	; 0x78a

    hci_state_reset();
 801417e:	f7ff fedb 	bl	8013f38 <hci_state_reset>
}
 8014182:	bf00      	nop
 8014184:	3708      	adds	r7, #8
 8014186:	46bd      	mov	sp, r7
 8014188:	bd80      	pop	{r7, pc}
 801418a:	bf00      	nop
 801418c:	20009780 	.word	0x20009780
 8014190:	20008fbc 	.word	0x20008fbc
 8014194:	08013e9d 	.word	0x08013e9d
 8014198:	007a020c 	.word	0x007a020c
 801419c:	20000028 	.word	0x20000028

080141a0 <hci_set_chipset>:
}

/**
 * @brief Configure Bluetooth chipset driver. Has to be called before power on, or right after receiving the local version information
 */
void hci_set_chipset(const btstack_chipset_t *chipset_driver){
 80141a0:	b580      	push	{r7, lr}
 80141a2:	b082      	sub	sp, #8
 80141a4:	af00      	add	r7, sp, #0
 80141a6:	6078      	str	r0, [r7, #4]
    hci_stack->chipset = chipset_driver;
 80141a8:	4b0d      	ldr	r3, [pc, #52]	; (80141e0 <hci_set_chipset+0x40>)
 80141aa:	681b      	ldr	r3, [r3, #0]
 80141ac:	687a      	ldr	r2, [r7, #4]
 80141ae:	609a      	str	r2, [r3, #8]

    // reset chipset driver - init is also called on power_up
    if (hci_stack->chipset && hci_stack->chipset->init){
 80141b0:	4b0b      	ldr	r3, [pc, #44]	; (80141e0 <hci_set_chipset+0x40>)
 80141b2:	681b      	ldr	r3, [r3, #0]
 80141b4:	689b      	ldr	r3, [r3, #8]
 80141b6:	2b00      	cmp	r3, #0
 80141b8:	d00e      	beq.n	80141d8 <hci_set_chipset+0x38>
 80141ba:	4b09      	ldr	r3, [pc, #36]	; (80141e0 <hci_set_chipset+0x40>)
 80141bc:	681b      	ldr	r3, [r3, #0]
 80141be:	689b      	ldr	r3, [r3, #8]
 80141c0:	685b      	ldr	r3, [r3, #4]
 80141c2:	2b00      	cmp	r3, #0
 80141c4:	d008      	beq.n	80141d8 <hci_set_chipset+0x38>
        hci_stack->chipset->init(hci_stack->config);
 80141c6:	4b06      	ldr	r3, [pc, #24]	; (80141e0 <hci_set_chipset+0x40>)
 80141c8:	681b      	ldr	r3, [r3, #0]
 80141ca:	689b      	ldr	r3, [r3, #8]
 80141cc:	685b      	ldr	r3, [r3, #4]
 80141ce:	4a04      	ldr	r2, [pc, #16]	; (80141e0 <hci_set_chipset+0x40>)
 80141d0:	6812      	ldr	r2, [r2, #0]
 80141d2:	6852      	ldr	r2, [r2, #4]
 80141d4:	4610      	mov	r0, r2
 80141d6:	4798      	blx	r3
    }
}
 80141d8:	bf00      	nop
 80141da:	3708      	adds	r7, #8
 80141dc:	46bd      	mov	sp, r7
 80141de:	bd80      	pop	{r7, pc}
 80141e0:	20009780 	.word	0x20009780

080141e4 <hci_get_allow_role_switch>:

void gap_set_allow_role_switch(bool allow_role_switch){
    hci_stack->allow_role_switch = allow_role_switch ? 1 : 0;
}

uint8_t hci_get_allow_role_switch(void){
 80141e4:	b480      	push	{r7}
 80141e6:	af00      	add	r7, sp, #0
    return  hci_stack->allow_role_switch;
 80141e8:	4b04      	ldr	r3, [pc, #16]	; (80141fc <hci_get_allow_role_switch+0x18>)
 80141ea:	681b      	ldr	r3, [r3, #0]
 80141ec:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
}
 80141f0:	4618      	mov	r0, r3
 80141f2:	46bd      	mov	sp, r7
 80141f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80141f8:	4770      	bx	lr
 80141fa:	bf00      	nop
 80141fc:	20009780 	.word	0x20009780

08014200 <hci_power_control_on>:
// HCI_STATE_WORKING,        on       open
// HCI_STATE_HALTING,        on       open
// HCI_STATE_SLEEPING,    off/sleep   close
// HCI_STATE_FALLING_ASLEEP  on       open

static int hci_power_control_on(void){
 8014200:	b580      	push	{r7, lr}
 8014202:	b082      	sub	sp, #8
 8014204:	af00      	add	r7, sp, #0
    
    // power on
    int err = 0;
 8014206:	2300      	movs	r3, #0
 8014208:	607b      	str	r3, [r7, #4]
    if (hci_stack->control && hci_stack->control->on){
 801420a:	4b35      	ldr	r3, [pc, #212]	; (80142e0 <hci_power_control_on+0xe0>)
 801420c:	681b      	ldr	r3, [r3, #0]
 801420e:	68db      	ldr	r3, [r3, #12]
 8014210:	2b00      	cmp	r3, #0
 8014212:	d00b      	beq.n	801422c <hci_power_control_on+0x2c>
 8014214:	4b32      	ldr	r3, [pc, #200]	; (80142e0 <hci_power_control_on+0xe0>)
 8014216:	681b      	ldr	r3, [r3, #0]
 8014218:	68db      	ldr	r3, [r3, #12]
 801421a:	685b      	ldr	r3, [r3, #4]
 801421c:	2b00      	cmp	r3, #0
 801421e:	d005      	beq.n	801422c <hci_power_control_on+0x2c>
        err = (*hci_stack->control->on)();
 8014220:	4b2f      	ldr	r3, [pc, #188]	; (80142e0 <hci_power_control_on+0xe0>)
 8014222:	681b      	ldr	r3, [r3, #0]
 8014224:	68db      	ldr	r3, [r3, #12]
 8014226:	685b      	ldr	r3, [r3, #4]
 8014228:	4798      	blx	r3
 801422a:	6078      	str	r0, [r7, #4]
    }
    if (err){
 801422c:	687b      	ldr	r3, [r7, #4]
 801422e:	2b00      	cmp	r3, #0
 8014230:	d00a      	beq.n	8014248 <hci_power_control_on+0x48>
        log_error( "POWER_ON failed");
 8014232:	f640 43dc 	movw	r3, #3292	; 0xcdc
 8014236:	4a2b      	ldr	r2, [pc, #172]	; (80142e4 <hci_power_control_on+0xe4>)
 8014238:	492b      	ldr	r1, [pc, #172]	; (80142e8 <hci_power_control_on+0xe8>)
 801423a:	2002      	movs	r0, #2
 801423c:	f003 f900 	bl	8017440 <hci_dump_log>
        hci_emit_hci_open_failed();
 8014240:	f002 f974 	bl	801652c <hci_emit_hci_open_failed>
        return err;
 8014244:	687b      	ldr	r3, [r7, #4]
 8014246:	e047      	b.n	80142d8 <hci_power_control_on+0xd8>
    }
    
    // int chipset driver
    if (hci_stack->chipset && hci_stack->chipset->init){
 8014248:	4b25      	ldr	r3, [pc, #148]	; (80142e0 <hci_power_control_on+0xe0>)
 801424a:	681b      	ldr	r3, [r3, #0]
 801424c:	689b      	ldr	r3, [r3, #8]
 801424e:	2b00      	cmp	r3, #0
 8014250:	d00e      	beq.n	8014270 <hci_power_control_on+0x70>
 8014252:	4b23      	ldr	r3, [pc, #140]	; (80142e0 <hci_power_control_on+0xe0>)
 8014254:	681b      	ldr	r3, [r3, #0]
 8014256:	689b      	ldr	r3, [r3, #8]
 8014258:	685b      	ldr	r3, [r3, #4]
 801425a:	2b00      	cmp	r3, #0
 801425c:	d008      	beq.n	8014270 <hci_power_control_on+0x70>
        hci_stack->chipset->init(hci_stack->config);
 801425e:	4b20      	ldr	r3, [pc, #128]	; (80142e0 <hci_power_control_on+0xe0>)
 8014260:	681b      	ldr	r3, [r3, #0]
 8014262:	689b      	ldr	r3, [r3, #8]
 8014264:	685b      	ldr	r3, [r3, #4]
 8014266:	4a1e      	ldr	r2, [pc, #120]	; (80142e0 <hci_power_control_on+0xe0>)
 8014268:	6812      	ldr	r2, [r2, #0]
 801426a:	6852      	ldr	r2, [r2, #4]
 801426c:	4610      	mov	r0, r2
 801426e:	4798      	blx	r3
    }

    // init transport
    if (hci_stack->hci_transport->init){
 8014270:	4b1b      	ldr	r3, [pc, #108]	; (80142e0 <hci_power_control_on+0xe0>)
 8014272:	681b      	ldr	r3, [r3, #0]
 8014274:	681b      	ldr	r3, [r3, #0]
 8014276:	685b      	ldr	r3, [r3, #4]
 8014278:	2b00      	cmp	r3, #0
 801427a:	d008      	beq.n	801428e <hci_power_control_on+0x8e>
        hci_stack->hci_transport->init(hci_stack->config);
 801427c:	4b18      	ldr	r3, [pc, #96]	; (80142e0 <hci_power_control_on+0xe0>)
 801427e:	681b      	ldr	r3, [r3, #0]
 8014280:	681b      	ldr	r3, [r3, #0]
 8014282:	685b      	ldr	r3, [r3, #4]
 8014284:	4a16      	ldr	r2, [pc, #88]	; (80142e0 <hci_power_control_on+0xe0>)
 8014286:	6812      	ldr	r2, [r2, #0]
 8014288:	6852      	ldr	r2, [r2, #4]
 801428a:	4610      	mov	r0, r2
 801428c:	4798      	blx	r3
    }

    // open transport
    err = hci_stack->hci_transport->open();
 801428e:	4b14      	ldr	r3, [pc, #80]	; (80142e0 <hci_power_control_on+0xe0>)
 8014290:	681b      	ldr	r3, [r3, #0]
 8014292:	681b      	ldr	r3, [r3, #0]
 8014294:	689b      	ldr	r3, [r3, #8]
 8014296:	4798      	blx	r3
 8014298:	6078      	str	r0, [r7, #4]
    if (err){
 801429a:	687b      	ldr	r3, [r7, #4]
 801429c:	2b00      	cmp	r3, #0
 801429e:	d01a      	beq.n	80142d6 <hci_power_control_on+0xd6>
        log_error( "HCI_INIT failed, turning Bluetooth off again");
 80142a0:	f640 43ee 	movw	r3, #3310	; 0xcee
 80142a4:	4a0f      	ldr	r2, [pc, #60]	; (80142e4 <hci_power_control_on+0xe4>)
 80142a6:	4911      	ldr	r1, [pc, #68]	; (80142ec <hci_power_control_on+0xec>)
 80142a8:	2002      	movs	r0, #2
 80142aa:	f003 f8c9 	bl	8017440 <hci_dump_log>
        if (hci_stack->control && hci_stack->control->off){
 80142ae:	4b0c      	ldr	r3, [pc, #48]	; (80142e0 <hci_power_control_on+0xe0>)
 80142b0:	681b      	ldr	r3, [r3, #0]
 80142b2:	68db      	ldr	r3, [r3, #12]
 80142b4:	2b00      	cmp	r3, #0
 80142b6:	d00a      	beq.n	80142ce <hci_power_control_on+0xce>
 80142b8:	4b09      	ldr	r3, [pc, #36]	; (80142e0 <hci_power_control_on+0xe0>)
 80142ba:	681b      	ldr	r3, [r3, #0]
 80142bc:	68db      	ldr	r3, [r3, #12]
 80142be:	689b      	ldr	r3, [r3, #8]
 80142c0:	2b00      	cmp	r3, #0
 80142c2:	d004      	beq.n	80142ce <hci_power_control_on+0xce>
            (*hci_stack->control->off)();
 80142c4:	4b06      	ldr	r3, [pc, #24]	; (80142e0 <hci_power_control_on+0xe0>)
 80142c6:	681b      	ldr	r3, [r3, #0]
 80142c8:	68db      	ldr	r3, [r3, #12]
 80142ca:	689b      	ldr	r3, [r3, #8]
 80142cc:	4798      	blx	r3
        }
        hci_emit_hci_open_failed();
 80142ce:	f002 f92d 	bl	801652c <hci_emit_hci_open_failed>
        return err;
 80142d2:	687b      	ldr	r3, [r7, #4]
 80142d4:	e000      	b.n	80142d8 <hci_power_control_on+0xd8>
    }
    return 0;
 80142d6:	2300      	movs	r3, #0
}
 80142d8:	4618      	mov	r0, r3
 80142da:	3708      	adds	r7, #8
 80142dc:	46bd      	mov	sp, r7
 80142de:	bd80      	pop	{r7, pc}
 80142e0:	20009780 	.word	0x20009780
 80142e4:	0802929c 	.word	0x0802929c
 80142e8:	0802a4b4 	.word	0x0802a4b4
 80142ec:	0802a4cc 	.word	0x0802a4cc

080142f0 <hci_power_control_off>:

static void hci_power_control_off(void){
 80142f0:	b580      	push	{r7, lr}
 80142f2:	af00      	add	r7, sp, #0
    
    log_info("hci_power_control_off");
 80142f4:	f640 43fa 	movw	r3, #3322	; 0xcfa
 80142f8:	4a17      	ldr	r2, [pc, #92]	; (8014358 <hci_power_control_off+0x68>)
 80142fa:	4918      	ldr	r1, [pc, #96]	; (801435c <hci_power_control_off+0x6c>)
 80142fc:	2001      	movs	r0, #1
 80142fe:	f003 f89f 	bl	8017440 <hci_dump_log>

    // close low-level device
    hci_stack->hci_transport->close();
 8014302:	4b17      	ldr	r3, [pc, #92]	; (8014360 <hci_power_control_off+0x70>)
 8014304:	681b      	ldr	r3, [r3, #0]
 8014306:	681b      	ldr	r3, [r3, #0]
 8014308:	68db      	ldr	r3, [r3, #12]
 801430a:	4798      	blx	r3

    log_info("hci_power_control_off - hci_transport closed");
 801430c:	f640 43ff 	movw	r3, #3327	; 0xcff
 8014310:	4a11      	ldr	r2, [pc, #68]	; (8014358 <hci_power_control_off+0x68>)
 8014312:	4914      	ldr	r1, [pc, #80]	; (8014364 <hci_power_control_off+0x74>)
 8014314:	2001      	movs	r0, #1
 8014316:	f003 f893 	bl	8017440 <hci_dump_log>
    
    // power off
    if (hci_stack->control && hci_stack->control->off){
 801431a:	4b11      	ldr	r3, [pc, #68]	; (8014360 <hci_power_control_off+0x70>)
 801431c:	681b      	ldr	r3, [r3, #0]
 801431e:	68db      	ldr	r3, [r3, #12]
 8014320:	2b00      	cmp	r3, #0
 8014322:	d00a      	beq.n	801433a <hci_power_control_off+0x4a>
 8014324:	4b0e      	ldr	r3, [pc, #56]	; (8014360 <hci_power_control_off+0x70>)
 8014326:	681b      	ldr	r3, [r3, #0]
 8014328:	68db      	ldr	r3, [r3, #12]
 801432a:	689b      	ldr	r3, [r3, #8]
 801432c:	2b00      	cmp	r3, #0
 801432e:	d004      	beq.n	801433a <hci_power_control_off+0x4a>
        (*hci_stack->control->off)();
 8014330:	4b0b      	ldr	r3, [pc, #44]	; (8014360 <hci_power_control_off+0x70>)
 8014332:	681b      	ldr	r3, [r3, #0]
 8014334:	68db      	ldr	r3, [r3, #12]
 8014336:	689b      	ldr	r3, [r3, #8]
 8014338:	4798      	blx	r3
    }
    
    log_info("hci_power_control_off - control closed");
 801433a:	f640 5306 	movw	r3, #3334	; 0xd06
 801433e:	4a06      	ldr	r2, [pc, #24]	; (8014358 <hci_power_control_off+0x68>)
 8014340:	4909      	ldr	r1, [pc, #36]	; (8014368 <hci_power_control_off+0x78>)
 8014342:	2001      	movs	r0, #1
 8014344:	f003 f87c 	bl	8017440 <hci_dump_log>

    hci_stack->state = HCI_STATE_OFF;
 8014348:	4b05      	ldr	r3, [pc, #20]	; (8014360 <hci_power_control_off+0x70>)
 801434a:	681b      	ldr	r3, [r3, #0]
 801434c:	2200      	movs	r2, #0
 801434e:	f883 2716 	strb.w	r2, [r3, #1814]	; 0x716
}
 8014352:	bf00      	nop
 8014354:	bd80      	pop	{r7, pc}
 8014356:	bf00      	nop
 8014358:	0802929c 	.word	0x0802929c
 801435c:	0802a500 	.word	0x0802a500
 8014360:	20009780 	.word	0x20009780
 8014364:	0802a520 	.word	0x0802a520
 8014368:	0802a554 	.word	0x0802a554

0801436c <hci_power_control_sleep>:

static void hci_power_control_sleep(void){
 801436c:	b580      	push	{r7, lr}
 801436e:	af00      	add	r7, sp, #0
    
    log_info("hci_power_control_sleep");
 8014370:	f640 530d 	movw	r3, #3341	; 0xd0d
 8014374:	4a0d      	ldr	r2, [pc, #52]	; (80143ac <hci_power_control_sleep+0x40>)
 8014376:	490e      	ldr	r1, [pc, #56]	; (80143b0 <hci_power_control_sleep+0x44>)
 8014378:	2001      	movs	r0, #1
 801437a:	f003 f861 	bl	8017440 <hci_dump_log>
    // close low-level device
    hci_stack->hci_transport->close(hci_stack->config);
#endif
    
    // sleep mode
    if (hci_stack->control && hci_stack->control->sleep){
 801437e:	4b0d      	ldr	r3, [pc, #52]	; (80143b4 <hci_power_control_sleep+0x48>)
 8014380:	681b      	ldr	r3, [r3, #0]
 8014382:	68db      	ldr	r3, [r3, #12]
 8014384:	2b00      	cmp	r3, #0
 8014386:	d00a      	beq.n	801439e <hci_power_control_sleep+0x32>
 8014388:	4b0a      	ldr	r3, [pc, #40]	; (80143b4 <hci_power_control_sleep+0x48>)
 801438a:	681b      	ldr	r3, [r3, #0]
 801438c:	68db      	ldr	r3, [r3, #12]
 801438e:	68db      	ldr	r3, [r3, #12]
 8014390:	2b00      	cmp	r3, #0
 8014392:	d004      	beq.n	801439e <hci_power_control_sleep+0x32>
        (*hci_stack->control->sleep)();
 8014394:	4b07      	ldr	r3, [pc, #28]	; (80143b4 <hci_power_control_sleep+0x48>)
 8014396:	681b      	ldr	r3, [r3, #0]
 8014398:	68db      	ldr	r3, [r3, #12]
 801439a:	68db      	ldr	r3, [r3, #12]
 801439c:	4798      	blx	r3
    }
    
    hci_stack->state = HCI_STATE_SLEEPING;
 801439e:	4b05      	ldr	r3, [pc, #20]	; (80143b4 <hci_power_control_sleep+0x48>)
 80143a0:	681b      	ldr	r3, [r3, #0]
 80143a2:	2204      	movs	r2, #4
 80143a4:	f883 2716 	strb.w	r2, [r3, #1814]	; 0x716
}
 80143a8:	bf00      	nop
 80143aa:	bd80      	pop	{r7, pc}
 80143ac:	0802929c 	.word	0x0802929c
 80143b0:	0802a584 	.word	0x0802a584
 80143b4:	20009780 	.word	0x20009780

080143b8 <hci_power_control_wake>:

static int hci_power_control_wake(void){
 80143b8:	b580      	push	{r7, lr}
 80143ba:	af00      	add	r7, sp, #0
    
    log_info("hci_power_control_wake");
 80143bc:	f44f 6352 	mov.w	r3, #3360	; 0xd20
 80143c0:	4a0b      	ldr	r2, [pc, #44]	; (80143f0 <hci_power_control_wake+0x38>)
 80143c2:	490c      	ldr	r1, [pc, #48]	; (80143f4 <hci_power_control_wake+0x3c>)
 80143c4:	2001      	movs	r0, #1
 80143c6:	f003 f83b 	bl	8017440 <hci_dump_log>

    // wake on
    if (hci_stack->control && hci_stack->control->wake){
 80143ca:	4b0b      	ldr	r3, [pc, #44]	; (80143f8 <hci_power_control_wake+0x40>)
 80143cc:	681b      	ldr	r3, [r3, #0]
 80143ce:	68db      	ldr	r3, [r3, #12]
 80143d0:	2b00      	cmp	r3, #0
 80143d2:	d00a      	beq.n	80143ea <hci_power_control_wake+0x32>
 80143d4:	4b08      	ldr	r3, [pc, #32]	; (80143f8 <hci_power_control_wake+0x40>)
 80143d6:	681b      	ldr	r3, [r3, #0]
 80143d8:	68db      	ldr	r3, [r3, #12]
 80143da:	691b      	ldr	r3, [r3, #16]
 80143dc:	2b00      	cmp	r3, #0
 80143de:	d004      	beq.n	80143ea <hci_power_control_wake+0x32>
        (*hci_stack->control->wake)();
 80143e0:	4b05      	ldr	r3, [pc, #20]	; (80143f8 <hci_power_control_wake+0x40>)
 80143e2:	681b      	ldr	r3, [r3, #0]
 80143e4:	68db      	ldr	r3, [r3, #12]
 80143e6:	691b      	ldr	r3, [r3, #16]
 80143e8:	4798      	blx	r3
        hci_emit_hci_open_failed();
        return err;
    }
#endif
    
    return 0;
 80143ea:	2300      	movs	r3, #0
}
 80143ec:	4618      	mov	r0, r3
 80143ee:	bd80      	pop	{r7, pc}
 80143f0:	0802929c 	.word	0x0802929c
 80143f4:	0802a5a4 	.word	0x0802a5a4
 80143f8:	20009780 	.word	0x20009780

080143fc <hci_power_transition_to_initializing>:

static void hci_power_transition_to_initializing(void){
 80143fc:	b480      	push	{r7}
 80143fe:	af00      	add	r7, sp, #0
    // set up state machine
    hci_stack->num_cmd_packets = 1; // assume that one cmd can be sent
 8014400:	4b0c      	ldr	r3, [pc, #48]	; (8014434 <hci_power_transition_to_initializing+0x38>)
 8014402:	681b      	ldr	r3, [r3, #0]
 8014404:	2201      	movs	r2, #1
 8014406:	f883 26fb 	strb.w	r2, [r3, #1787]	; 0x6fb
    hci_stack->hci_packet_buffer_reserved = 0;
 801440a:	4b0a      	ldr	r3, [pc, #40]	; (8014434 <hci_power_transition_to_initializing+0x38>)
 801440c:	681b      	ldr	r3, [r3, #0]
 801440e:	2200      	movs	r2, #0
 8014410:	f883 26f4 	strb.w	r2, [r3, #1780]	; 0x6f4
    hci_stack->state = HCI_STATE_INITIALIZING;
 8014414:	4b07      	ldr	r3, [pc, #28]	; (8014434 <hci_power_transition_to_initializing+0x38>)
 8014416:	681b      	ldr	r3, [r3, #0]
 8014418:	2201      	movs	r2, #1
 801441a:	f883 2716 	strb.w	r2, [r3, #1814]	; 0x716
    hci_stack->substate = HCI_INIT_SEND_RESET;
 801441e:	4b05      	ldr	r3, [pc, #20]	; (8014434 <hci_power_transition_to_initializing+0x38>)
 8014420:	681b      	ldr	r3, [r3, #0]
 8014422:	2200      	movs	r2, #0
 8014424:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
}
 8014428:	bf00      	nop
 801442a:	46bd      	mov	sp, r7
 801442c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014430:	4770      	bx	lr
 8014432:	bf00      	nop
 8014434:	20009780 	.word	0x20009780

08014438 <hci_power_control_state_off>:

// returns error
static int hci_power_control_state_off(HCI_POWER_MODE power_mode){
 8014438:	b580      	push	{r7, lr}
 801443a:	b086      	sub	sp, #24
 801443c:	af02      	add	r7, sp, #8
 801443e:	4603      	mov	r3, r0
 8014440:	71fb      	strb	r3, [r7, #7]
    int err;
    switch (power_mode){
 8014442:	79fb      	ldrb	r3, [r7, #7]
 8014444:	2b01      	cmp	r3, #1
 8014446:	d004      	beq.n	8014452 <hci_power_control_state_off+0x1a>
 8014448:	2b02      	cmp	r3, #2
 801444a:	d016      	beq.n	801447a <hci_power_control_state_off+0x42>
 801444c:	2b00      	cmp	r3, #0
 801444e:	d016      	beq.n	801447e <hci_power_control_state_off+0x46>
        case HCI_POWER_SLEEP:
            // do nothing (with SLEEP == OFF)
            break;
        default:
            btstack_assert(false);
            break;
 8014450:	e016      	b.n	8014480 <hci_power_control_state_off+0x48>
            err = hci_power_control_on();
 8014452:	f7ff fed5 	bl	8014200 <hci_power_control_on>
 8014456:	60f8      	str	r0, [r7, #12]
            if (err != 0) {
 8014458:	68fb      	ldr	r3, [r7, #12]
 801445a:	2b00      	cmp	r3, #0
 801445c:	d00a      	beq.n	8014474 <hci_power_control_state_off+0x3c>
                log_error("hci_power_control_on() error %d", err);
 801445e:	68fb      	ldr	r3, [r7, #12]
 8014460:	9300      	str	r3, [sp, #0]
 8014462:	f640 5346 	movw	r3, #3398	; 0xd46
 8014466:	4a09      	ldr	r2, [pc, #36]	; (801448c <hci_power_control_state_off+0x54>)
 8014468:	4909      	ldr	r1, [pc, #36]	; (8014490 <hci_power_control_state_off+0x58>)
 801446a:	2002      	movs	r0, #2
 801446c:	f002 ffe8 	bl	8017440 <hci_dump_log>
                return err;
 8014470:	68fb      	ldr	r3, [r7, #12]
 8014472:	e006      	b.n	8014482 <hci_power_control_state_off+0x4a>
            hci_power_transition_to_initializing();
 8014474:	f7ff ffc2 	bl	80143fc <hci_power_transition_to_initializing>
            break;
 8014478:	e002      	b.n	8014480 <hci_power_control_state_off+0x48>
            break;
 801447a:	bf00      	nop
 801447c:	e000      	b.n	8014480 <hci_power_control_state_off+0x48>
            break;
 801447e:	bf00      	nop
    }
    return ERROR_CODE_SUCCESS;
 8014480:	2300      	movs	r3, #0
}
 8014482:	4618      	mov	r0, r3
 8014484:	3710      	adds	r7, #16
 8014486:	46bd      	mov	sp, r7
 8014488:	bd80      	pop	{r7, pc}
 801448a:	bf00      	nop
 801448c:	0802929c 	.word	0x0802929c
 8014490:	0802a5c4 	.word	0x0802a5c4

08014494 <hci_power_control_state_initializing>:

static int hci_power_control_state_initializing(HCI_POWER_MODE power_mode){
 8014494:	b580      	push	{r7, lr}
 8014496:	b082      	sub	sp, #8
 8014498:	af00      	add	r7, sp, #0
 801449a:	4603      	mov	r3, r0
 801449c:	71fb      	strb	r3, [r7, #7]
    switch (power_mode){
 801449e:	79fb      	ldrb	r3, [r7, #7]
 80144a0:	2b01      	cmp	r3, #1
 80144a2:	d00a      	beq.n	80144ba <hci_power_control_state_initializing+0x26>
 80144a4:	2b02      	cmp	r3, #2
 80144a6:	d005      	beq.n	80144b4 <hci_power_control_state_initializing+0x20>
 80144a8:	2b00      	cmp	r3, #0
 80144aa:	d000      	beq.n	80144ae <hci_power_control_state_initializing+0x1a>
            // no connections yet, just turn it off
            hci_power_control_sleep();
            break;
        default:
            btstack_assert(false);
            break;
 80144ac:	e006      	b.n	80144bc <hci_power_control_state_initializing+0x28>
            hci_power_control_off();
 80144ae:	f7ff ff1f 	bl	80142f0 <hci_power_control_off>
            break;
 80144b2:	e003      	b.n	80144bc <hci_power_control_state_initializing+0x28>
            hci_power_control_sleep();
 80144b4:	f7ff ff5a 	bl	801436c <hci_power_control_sleep>
            break;
 80144b8:	e000      	b.n	80144bc <hci_power_control_state_initializing+0x28>
            break;
 80144ba:	bf00      	nop
    }
    return ERROR_CODE_SUCCESS;
 80144bc:	2300      	movs	r3, #0
}
 80144be:	4618      	mov	r0, r3
 80144c0:	3708      	adds	r7, #8
 80144c2:	46bd      	mov	sp, r7
 80144c4:	bd80      	pop	{r7, pc}
	...

080144c8 <hci_power_control_state_working>:

static int hci_power_control_state_working(HCI_POWER_MODE power_mode) {
 80144c8:	b480      	push	{r7}
 80144ca:	b083      	sub	sp, #12
 80144cc:	af00      	add	r7, sp, #0
 80144ce:	4603      	mov	r3, r0
 80144d0:	71fb      	strb	r3, [r7, #7]
    switch (power_mode){
 80144d2:	79fb      	ldrb	r3, [r7, #7]
 80144d4:	2b01      	cmp	r3, #1
 80144d6:	d01a      	beq.n	801450e <hci_power_control_state_working+0x46>
 80144d8:	2b02      	cmp	r3, #2
 80144da:	d00d      	beq.n	80144f8 <hci_power_control_state_working+0x30>
 80144dc:	2b00      	cmp	r3, #0
 80144de:	d000      	beq.n	80144e2 <hci_power_control_state_working+0x1a>
            hci_stack->state = HCI_STATE_FALLING_ASLEEP;
            hci_stack->substate = HCI_FALLING_ASLEEP_DISCONNECT;
            break;
        default:
            btstack_assert(false);
            break;
 80144e0:	e016      	b.n	8014510 <hci_power_control_state_working+0x48>
            hci_stack->state = HCI_STATE_HALTING;
 80144e2:	4b0f      	ldr	r3, [pc, #60]	; (8014520 <hci_power_control_state_working+0x58>)
 80144e4:	681b      	ldr	r3, [r3, #0]
 80144e6:	2203      	movs	r2, #3
 80144e8:	f883 2716 	strb.w	r2, [r3, #1814]	; 0x716
            hci_stack->substate = HCI_HALTING_DISCONNECT_ALL_NO_TIMER;
 80144ec:	4b0c      	ldr	r3, [pc, #48]	; (8014520 <hci_power_control_state_working+0x58>)
 80144ee:	681b      	ldr	r3, [r3, #0]
 80144f0:	2249      	movs	r2, #73	; 0x49
 80144f2:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            break;
 80144f6:	e00b      	b.n	8014510 <hci_power_control_state_working+0x48>
            hci_stack->state = HCI_STATE_FALLING_ASLEEP;
 80144f8:	4b09      	ldr	r3, [pc, #36]	; (8014520 <hci_power_control_state_working+0x58>)
 80144fa:	681b      	ldr	r3, [r3, #0]
 80144fc:	2205      	movs	r2, #5
 80144fe:	f883 2716 	strb.w	r2, [r3, #1814]	; 0x716
            hci_stack->substate = HCI_FALLING_ASLEEP_DISCONNECT;
 8014502:	4b07      	ldr	r3, [pc, #28]	; (8014520 <hci_power_control_state_working+0x58>)
 8014504:	681b      	ldr	r3, [r3, #0]
 8014506:	2245      	movs	r2, #69	; 0x45
 8014508:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            break;
 801450c:	e000      	b.n	8014510 <hci_power_control_state_working+0x48>
            break;
 801450e:	bf00      	nop
    }
    return ERROR_CODE_SUCCESS;
 8014510:	2300      	movs	r3, #0
}
 8014512:	4618      	mov	r0, r3
 8014514:	370c      	adds	r7, #12
 8014516:	46bd      	mov	sp, r7
 8014518:	f85d 7b04 	ldr.w	r7, [sp], #4
 801451c:	4770      	bx	lr
 801451e:	bf00      	nop
 8014520:	20009780 	.word	0x20009780

08014524 <hci_power_control_state_halting>:

static int hci_power_control_state_halting(HCI_POWER_MODE power_mode) {
 8014524:	b580      	push	{r7, lr}
 8014526:	b082      	sub	sp, #8
 8014528:	af00      	add	r7, sp, #0
 801452a:	4603      	mov	r3, r0
 801452c:	71fb      	strb	r3, [r7, #7]
    switch (power_mode){
 801452e:	79fb      	ldrb	r3, [r7, #7]
 8014530:	2b01      	cmp	r3, #1
 8014532:	d004      	beq.n	801453e <hci_power_control_state_halting+0x1a>
 8014534:	2b02      	cmp	r3, #2
 8014536:	d005      	beq.n	8014544 <hci_power_control_state_halting+0x20>
 8014538:	2b00      	cmp	r3, #0
 801453a:	d00e      	beq.n	801455a <hci_power_control_state_halting+0x36>
            hci_stack->state = HCI_STATE_FALLING_ASLEEP;
            hci_stack->substate = HCI_FALLING_ASLEEP_DISCONNECT;
            break;
        default:
            btstack_assert(false);
            break;
 801453c:	e00e      	b.n	801455c <hci_power_control_state_halting+0x38>
            hci_power_transition_to_initializing();
 801453e:	f7ff ff5d 	bl	80143fc <hci_power_transition_to_initializing>
            break;
 8014542:	e00b      	b.n	801455c <hci_power_control_state_halting+0x38>
            hci_stack->state = HCI_STATE_FALLING_ASLEEP;
 8014544:	4b08      	ldr	r3, [pc, #32]	; (8014568 <hci_power_control_state_halting+0x44>)
 8014546:	681b      	ldr	r3, [r3, #0]
 8014548:	2205      	movs	r2, #5
 801454a:	f883 2716 	strb.w	r2, [r3, #1814]	; 0x716
            hci_stack->substate = HCI_FALLING_ASLEEP_DISCONNECT;
 801454e:	4b06      	ldr	r3, [pc, #24]	; (8014568 <hci_power_control_state_halting+0x44>)
 8014550:	681b      	ldr	r3, [r3, #0]
 8014552:	2245      	movs	r2, #69	; 0x45
 8014554:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            break;
 8014558:	e000      	b.n	801455c <hci_power_control_state_halting+0x38>
            break;
 801455a:	bf00      	nop
    }
    return ERROR_CODE_SUCCESS;
 801455c:	2300      	movs	r3, #0
}
 801455e:	4618      	mov	r0, r3
 8014560:	3708      	adds	r7, #8
 8014562:	46bd      	mov	sp, r7
 8014564:	bd80      	pop	{r7, pc}
 8014566:	bf00      	nop
 8014568:	20009780 	.word	0x20009780

0801456c <hci_power_control_state_falling_asleep>:

static int hci_power_control_state_falling_asleep(HCI_POWER_MODE power_mode) {
 801456c:	b580      	push	{r7, lr}
 801456e:	b082      	sub	sp, #8
 8014570:	af00      	add	r7, sp, #0
 8014572:	4603      	mov	r3, r0
 8014574:	71fb      	strb	r3, [r7, #7]
    switch (power_mode){
 8014576:	79fb      	ldrb	r3, [r7, #7]
 8014578:	2b01      	cmp	r3, #1
 801457a:	d004      	beq.n	8014586 <hci_power_control_state_falling_asleep+0x1a>
 801457c:	2b02      	cmp	r3, #2
 801457e:	d010      	beq.n	80145a2 <hci_power_control_state_falling_asleep+0x36>
 8014580:	2b00      	cmp	r3, #0
 8014582:	d003      	beq.n	801458c <hci_power_control_state_falling_asleep+0x20>
        case HCI_POWER_SLEEP:
            // do nothing
            break;
        default:
            btstack_assert(false);
            break;
 8014584:	e00e      	b.n	80145a4 <hci_power_control_state_falling_asleep+0x38>
            hci_power_transition_to_initializing();
 8014586:	f7ff ff39 	bl	80143fc <hci_power_transition_to_initializing>
            break;
 801458a:	e00b      	b.n	80145a4 <hci_power_control_state_falling_asleep+0x38>
            hci_stack->state = HCI_STATE_HALTING;
 801458c:	4b08      	ldr	r3, [pc, #32]	; (80145b0 <hci_power_control_state_falling_asleep+0x44>)
 801458e:	681b      	ldr	r3, [r3, #0]
 8014590:	2203      	movs	r2, #3
 8014592:	f883 2716 	strb.w	r2, [r3, #1814]	; 0x716
            hci_stack->substate = HCI_HALTING_DISCONNECT_ALL_NO_TIMER;
 8014596:	4b06      	ldr	r3, [pc, #24]	; (80145b0 <hci_power_control_state_falling_asleep+0x44>)
 8014598:	681b      	ldr	r3, [r3, #0]
 801459a:	2249      	movs	r2, #73	; 0x49
 801459c:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            break;
 80145a0:	e000      	b.n	80145a4 <hci_power_control_state_falling_asleep+0x38>
            break;
 80145a2:	bf00      	nop
    }
    return ERROR_CODE_SUCCESS;
 80145a4:	2300      	movs	r3, #0
}
 80145a6:	4618      	mov	r0, r3
 80145a8:	3708      	adds	r7, #8
 80145aa:	46bd      	mov	sp, r7
 80145ac:	bd80      	pop	{r7, pc}
 80145ae:	bf00      	nop
 80145b0:	20009780 	.word	0x20009780

080145b4 <hci_power_control_state_sleeping>:

static int hci_power_control_state_sleeping(HCI_POWER_MODE power_mode) {
 80145b4:	b580      	push	{r7, lr}
 80145b6:	b084      	sub	sp, #16
 80145b8:	af00      	add	r7, sp, #0
 80145ba:	4603      	mov	r3, r0
 80145bc:	71fb      	strb	r3, [r7, #7]
    int err;
    switch (power_mode){
 80145be:	79fb      	ldrb	r3, [r7, #7]
 80145c0:	2b01      	cmp	r3, #1
 80145c2:	d004      	beq.n	80145ce <hci_power_control_state_sleeping+0x1a>
 80145c4:	2b02      	cmp	r3, #2
 80145c6:	d018      	beq.n	80145fa <hci_power_control_state_sleeping+0x46>
 80145c8:	2b00      	cmp	r3, #0
 80145ca:	d00b      	beq.n	80145e4 <hci_power_control_state_sleeping+0x30>
        case HCI_POWER_SLEEP:
            // do nothing
            break;
        default:
            btstack_assert(false);
            break;
 80145cc:	e016      	b.n	80145fc <hci_power_control_state_sleeping+0x48>
            err = hci_power_control_wake();
 80145ce:	f7ff fef3 	bl	80143b8 <hci_power_control_wake>
 80145d2:	60f8      	str	r0, [r7, #12]
            if (err) return err;
 80145d4:	68fb      	ldr	r3, [r7, #12]
 80145d6:	2b00      	cmp	r3, #0
 80145d8:	d001      	beq.n	80145de <hci_power_control_state_sleeping+0x2a>
 80145da:	68fb      	ldr	r3, [r7, #12]
 80145dc:	e00f      	b.n	80145fe <hci_power_control_state_sleeping+0x4a>
            hci_power_transition_to_initializing();
 80145de:	f7ff ff0d 	bl	80143fc <hci_power_transition_to_initializing>
            break;
 80145e2:	e00b      	b.n	80145fc <hci_power_control_state_sleeping+0x48>
            hci_stack->state = HCI_STATE_HALTING;
 80145e4:	4b08      	ldr	r3, [pc, #32]	; (8014608 <hci_power_control_state_sleeping+0x54>)
 80145e6:	681b      	ldr	r3, [r3, #0]
 80145e8:	2203      	movs	r2, #3
 80145ea:	f883 2716 	strb.w	r2, [r3, #1814]	; 0x716
            hci_stack->substate = HCI_HALTING_DISCONNECT_ALL_NO_TIMER;
 80145ee:	4b06      	ldr	r3, [pc, #24]	; (8014608 <hci_power_control_state_sleeping+0x54>)
 80145f0:	681b      	ldr	r3, [r3, #0]
 80145f2:	2249      	movs	r2, #73	; 0x49
 80145f4:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            break;
 80145f8:	e000      	b.n	80145fc <hci_power_control_state_sleeping+0x48>
            break;
 80145fa:	bf00      	nop
    }
    return ERROR_CODE_SUCCESS;
 80145fc:	2300      	movs	r3, #0
}
 80145fe:	4618      	mov	r0, r3
 8014600:	3710      	adds	r7, #16
 8014602:	46bd      	mov	sp, r7
 8014604:	bd80      	pop	{r7, pc}
 8014606:	bf00      	nop
 8014608:	20009780 	.word	0x20009780

0801460c <hci_power_control>:

int hci_power_control(HCI_POWER_MODE power_mode){
 801460c:	b580      	push	{r7, lr}
 801460e:	b086      	sub	sp, #24
 8014610:	af02      	add	r7, sp, #8
 8014612:	4603      	mov	r3, r0
 8014614:	71fb      	strb	r3, [r7, #7]
    log_info("hci_power_control: %d, current mode %u", power_mode, hci_stack->state);
 8014616:	79fb      	ldrb	r3, [r7, #7]
 8014618:	4a2b      	ldr	r2, [pc, #172]	; (80146c8 <hci_power_control+0xbc>)
 801461a:	6812      	ldr	r2, [r2, #0]
 801461c:	f892 2716 	ldrb.w	r2, [r2, #1814]	; 0x716
 8014620:	9201      	str	r2, [sp, #4]
 8014622:	9300      	str	r3, [sp, #0]
 8014624:	f640 53d3 	movw	r3, #3539	; 0xdd3
 8014628:	4a28      	ldr	r2, [pc, #160]	; (80146cc <hci_power_control+0xc0>)
 801462a:	4929      	ldr	r1, [pc, #164]	; (80146d0 <hci_power_control+0xc4>)
 801462c:	2001      	movs	r0, #1
 801462e:	f002 ff07 	bl	8017440 <hci_dump_log>
    int err = 0;
 8014632:	2300      	movs	r3, #0
 8014634:	60fb      	str	r3, [r7, #12]
    switch (hci_stack->state){
 8014636:	4b24      	ldr	r3, [pc, #144]	; (80146c8 <hci_power_control+0xbc>)
 8014638:	681b      	ldr	r3, [r3, #0]
 801463a:	f893 3716 	ldrb.w	r3, [r3, #1814]	; 0x716
 801463e:	2b05      	cmp	r3, #5
 8014640:	d832      	bhi.n	80146a8 <hci_power_control+0x9c>
 8014642:	a201      	add	r2, pc, #4	; (adr r2, 8014648 <hci_power_control+0x3c>)
 8014644:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014648:	08014661 	.word	0x08014661
 801464c:	0801466d 	.word	0x0801466d
 8014650:	08014679 	.word	0x08014679
 8014654:	08014685 	.word	0x08014685
 8014658:	0801469d 	.word	0x0801469d
 801465c:	08014691 	.word	0x08014691
        case HCI_STATE_OFF:
            err = hci_power_control_state_off(power_mode);
 8014660:	79fb      	ldrb	r3, [r7, #7]
 8014662:	4618      	mov	r0, r3
 8014664:	f7ff fee8 	bl	8014438 <hci_power_control_state_off>
 8014668:	60f8      	str	r0, [r7, #12]
            break;
 801466a:	e01e      	b.n	80146aa <hci_power_control+0x9e>
        case HCI_STATE_INITIALIZING:
            err = hci_power_control_state_initializing(power_mode);
 801466c:	79fb      	ldrb	r3, [r7, #7]
 801466e:	4618      	mov	r0, r3
 8014670:	f7ff ff10 	bl	8014494 <hci_power_control_state_initializing>
 8014674:	60f8      	str	r0, [r7, #12]
            break;
 8014676:	e018      	b.n	80146aa <hci_power_control+0x9e>
        case HCI_STATE_WORKING:
            err = hci_power_control_state_working(power_mode);
 8014678:	79fb      	ldrb	r3, [r7, #7]
 801467a:	4618      	mov	r0, r3
 801467c:	f7ff ff24 	bl	80144c8 <hci_power_control_state_working>
 8014680:	60f8      	str	r0, [r7, #12]
            break;
 8014682:	e012      	b.n	80146aa <hci_power_control+0x9e>
        case HCI_STATE_HALTING:
            err = hci_power_control_state_halting(power_mode);
 8014684:	79fb      	ldrb	r3, [r7, #7]
 8014686:	4618      	mov	r0, r3
 8014688:	f7ff ff4c 	bl	8014524 <hci_power_control_state_halting>
 801468c:	60f8      	str	r0, [r7, #12]
            break;
 801468e:	e00c      	b.n	80146aa <hci_power_control+0x9e>
        case HCI_STATE_FALLING_ASLEEP:
            err = hci_power_control_state_falling_asleep(power_mode);
 8014690:	79fb      	ldrb	r3, [r7, #7]
 8014692:	4618      	mov	r0, r3
 8014694:	f7ff ff6a 	bl	801456c <hci_power_control_state_falling_asleep>
 8014698:	60f8      	str	r0, [r7, #12]
            break;
 801469a:	e006      	b.n	80146aa <hci_power_control+0x9e>
        case HCI_STATE_SLEEPING:
            err = hci_power_control_state_sleeping(power_mode);
 801469c:	79fb      	ldrb	r3, [r7, #7]
 801469e:	4618      	mov	r0, r3
 80146a0:	f7ff ff88 	bl	80145b4 <hci_power_control_state_sleeping>
 80146a4:	60f8      	str	r0, [r7, #12]
            break;
 80146a6:	e000      	b.n	80146aa <hci_power_control+0x9e>
        default:
            btstack_assert(false);
            break;
 80146a8:	bf00      	nop
    }
    if (err != 0){
 80146aa:	68fb      	ldr	r3, [r7, #12]
 80146ac:	2b00      	cmp	r3, #0
 80146ae:	d001      	beq.n	80146b4 <hci_power_control+0xa8>
        return err;
 80146b0:	68fb      	ldr	r3, [r7, #12]
 80146b2:	e004      	b.n	80146be <hci_power_control+0xb2>
    }

    // create internal event
	hci_emit_state();
 80146b4:	f001 fe5e 	bl	8016374 <hci_emit_state>
    
	// trigger next/first action
	hci_run();
 80146b8:	f001 f8f2 	bl	80158a0 <hci_run>
	
    return 0;
 80146bc:	2300      	movs	r3, #0
}
 80146be:	4618      	mov	r0, r3
 80146c0:	3710      	adds	r7, #16
 80146c2:	46bd      	mov	sp, r7
 80146c4:	bd80      	pop	{r7, pc}
 80146c6:	bf00      	nop
 80146c8:	20009780 	.word	0x20009780
 80146cc:	0802929c 	.word	0x0802929c
 80146d0:	0802a5ec 	.word	0x0802a5ec

080146d4 <hci_update_scan_enable>:


#ifdef ENABLE_CLASSIC

static void hci_update_scan_enable(void){
 80146d4:	b580      	push	{r7, lr}
 80146d6:	af00      	add	r7, sp, #0
    // 2 = page scan, 1 = inq scan
    hci_stack->new_scan_enable_value  = (hci_stack->connectable << 1) | hci_stack->discoverable;
 80146d8:	4b0a      	ldr	r3, [pc, #40]	; (8014704 <hci_update_scan_enable+0x30>)
 80146da:	681b      	ldr	r3, [r3, #0]
 80146dc:	f893 372f 	ldrb.w	r3, [r3, #1839]	; 0x72f
 80146e0:	005b      	lsls	r3, r3, #1
 80146e2:	b25a      	sxtb	r2, r3
 80146e4:	4b07      	ldr	r3, [pc, #28]	; (8014704 <hci_update_scan_enable+0x30>)
 80146e6:	681b      	ldr	r3, [r3, #0]
 80146e8:	f893 372e 	ldrb.w	r3, [r3, #1838]	; 0x72e
 80146ec:	b25b      	sxtb	r3, r3
 80146ee:	4313      	orrs	r3, r2
 80146f0:	b25a      	sxtb	r2, r3
 80146f2:	4b04      	ldr	r3, [pc, #16]	; (8014704 <hci_update_scan_enable+0x30>)
 80146f4:	681b      	ldr	r3, [r3, #0]
 80146f6:	b2d2      	uxtb	r2, r2
 80146f8:	f883 272d 	strb.w	r2, [r3, #1837]	; 0x72d
    hci_run();
 80146fc:	f001 f8d0 	bl	80158a0 <hci_run>
}
 8014700:	bf00      	nop
 8014702:	bd80      	pop	{r7, pc}
 8014704:	20009780 	.word	0x20009780

08014708 <gap_connectable_control>:

    hci_stack->discoverable = enable;
    hci_update_scan_enable();
}

void gap_connectable_control(uint8_t enable){
 8014708:	b580      	push	{r7, lr}
 801470a:	b082      	sub	sp, #8
 801470c:	af00      	add	r7, sp, #0
 801470e:	4603      	mov	r3, r0
 8014710:	71fb      	strb	r3, [r7, #7]
    if (enable) enable = 1; // normalize argument
 8014712:	79fb      	ldrb	r3, [r7, #7]
 8014714:	2b00      	cmp	r3, #0
 8014716:	d001      	beq.n	801471c <gap_connectable_control+0x14>
 8014718:	2301      	movs	r3, #1
 801471a:	71fb      	strb	r3, [r7, #7]
    
    // don't emit event
    if (hci_stack->connectable == enable) return;
 801471c:	4b09      	ldr	r3, [pc, #36]	; (8014744 <gap_connectable_control+0x3c>)
 801471e:	681b      	ldr	r3, [r3, #0]
 8014720:	f893 372f 	ldrb.w	r3, [r3, #1839]	; 0x72f
 8014724:	79fa      	ldrb	r2, [r7, #7]
 8014726:	429a      	cmp	r2, r3
 8014728:	d007      	beq.n	801473a <gap_connectable_control+0x32>

    hci_stack->connectable = enable;
 801472a:	4b06      	ldr	r3, [pc, #24]	; (8014744 <gap_connectable_control+0x3c>)
 801472c:	681b      	ldr	r3, [r3, #0]
 801472e:	79fa      	ldrb	r2, [r7, #7]
 8014730:	f883 272f 	strb.w	r2, [r3, #1839]	; 0x72f
    hci_update_scan_enable();
 8014734:	f7ff ffce 	bl	80146d4 <hci_update_scan_enable>
 8014738:	e000      	b.n	801473c <gap_connectable_control+0x34>
    if (hci_stack->connectable == enable) return;
 801473a:	bf00      	nop
}
 801473c:	3708      	adds	r7, #8
 801473e:	46bd      	mov	sp, r7
 8014740:	bd80      	pop	{r7, pc}
 8014742:	bf00      	nop
 8014744:	20009780 	.word	0x20009780

08014748 <gap_local_bd_addr>:
#endif

void gap_local_bd_addr(bd_addr_t address_buffer){
 8014748:	b580      	push	{r7, lr}
 801474a:	b082      	sub	sp, #8
 801474c:	af00      	add	r7, sp, #0
 801474e:	6078      	str	r0, [r7, #4]
    (void)memcpy(address_buffer, hci_stack->local_bd_addr, 6);
 8014750:	4b05      	ldr	r3, [pc, #20]	; (8014768 <gap_local_bd_addr+0x20>)
 8014752:	681b      	ldr	r3, [r3, #0]
 8014754:	3338      	adds	r3, #56	; 0x38
 8014756:	2206      	movs	r2, #6
 8014758:	4619      	mov	r1, r3
 801475a:	6878      	ldr	r0, [r7, #4]
 801475c:	f013 f98d 	bl	8027a7a <memcpy>
}
 8014760:	bf00      	nop
 8014762:	3708      	adds	r7, #8
 8014764:	46bd      	mov	sp, r7
 8014766:	bd80      	pop	{r7, pc}
 8014768:	20009780 	.word	0x20009780

0801476c <hci_halting_timeout_handler>:
        hci_emit_transport_packet_sent();
    }
}
#endif

static void hci_halting_timeout_handler(btstack_timer_source_t * ds){
 801476c:	b580      	push	{r7, lr}
 801476e:	b082      	sub	sp, #8
 8014770:	af00      	add	r7, sp, #0
 8014772:	6078      	str	r0, [r7, #4]
    UNUSED(ds);
    hci_stack->substate = HCI_HALTING_CLOSE;
 8014774:	4b06      	ldr	r3, [pc, #24]	; (8014790 <hci_halting_timeout_handler+0x24>)
 8014776:	681b      	ldr	r3, [r3, #0]
 8014778:	224c      	movs	r2, #76	; 0x4c
 801477a:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
    // allow packet handlers to defer final shutdown
    hci_emit_state();
 801477e:	f001 fdf9 	bl	8016374 <hci_emit_state>
    hci_run();
 8014782:	f001 f88d 	bl	80158a0 <hci_run>
}   
 8014786:	bf00      	nop
 8014788:	3708      	adds	r7, #8
 801478a:	46bd      	mov	sp, r7
 801478c:	bd80      	pop	{r7, pc}
 801478e:	bf00      	nop
 8014790:	20009780 	.word	0x20009780

08014794 <hci_run_acl_fragments>:

static bool hci_run_acl_fragments(void){
 8014794:	b580      	push	{r7, lr}
 8014796:	b082      	sub	sp, #8
 8014798:	af00      	add	r7, sp, #0
    if (hci_stack->acl_fragmentation_total_size > 0u) {
 801479a:	4b1d      	ldr	r3, [pc, #116]	; (8014810 <hci_run_acl_fragments+0x7c>)
 801479c:	681b      	ldr	r3, [r3, #0]
 801479e:	f8b3 36f8 	ldrh.w	r3, [r3, #1784]	; 0x6f8
 80147a2:	2b00      	cmp	r3, #0
 80147a4:	d02f      	beq.n	8014806 <hci_run_acl_fragments+0x72>
        hci_con_handle_t con_handle = READ_ACL_CONNECTION_HANDLE(hci_stack->hci_packet_buffer);
 80147a6:	4b1a      	ldr	r3, [pc, #104]	; (8014810 <hci_run_acl_fragments+0x7c>)
 80147a8:	681b      	ldr	r3, [r3, #0]
 80147aa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80147ac:	2100      	movs	r1, #0
 80147ae:	4618      	mov	r0, r3
 80147b0:	f7fa fb19 	bl	800ede6 <little_endian_read_16>
 80147b4:	4603      	mov	r3, r0
 80147b6:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80147ba:	80fb      	strh	r3, [r7, #6]
        hci_connection_t *connection = hci_connection_for_handle(con_handle);
 80147bc:	88fb      	ldrh	r3, [r7, #6]
 80147be:	4618      	mov	r0, r3
 80147c0:	f7fb f880 	bl	800f8c4 <hci_connection_for_handle>
 80147c4:	6038      	str	r0, [r7, #0]
        if (connection) {
 80147c6:	683b      	ldr	r3, [r7, #0]
 80147c8:	2b00      	cmp	r3, #0
 80147ca:	d00b      	beq.n	80147e4 <hci_run_acl_fragments+0x50>
            if (hci_can_send_prepared_acl_packet_now(con_handle)){
 80147cc:	88fb      	ldrh	r3, [r7, #6]
 80147ce:	4618      	mov	r0, r3
 80147d0:	f7fb fbea 	bl	800ffa8 <hci_can_send_prepared_acl_packet_now>
 80147d4:	4603      	mov	r3, r0
 80147d6:	2b00      	cmp	r3, #0
 80147d8:	d015      	beq.n	8014806 <hci_run_acl_fragments+0x72>
                hci_send_acl_packet_fragments(connection);
 80147da:	6838      	ldr	r0, [r7, #0]
 80147dc:	f7fb fcaa 	bl	8010134 <hci_send_acl_packet_fragments>
                return true;
 80147e0:	2301      	movs	r3, #1
 80147e2:	e011      	b.n	8014808 <hci_run_acl_fragments+0x74>
            }
        } else {
            // connection gone -> discard further fragments
            log_info("hci_run: fragmented ACL packet no connection -> discard fragment");
 80147e4:	f640 635d 	movw	r3, #3677	; 0xe5d
 80147e8:	4a0a      	ldr	r2, [pc, #40]	; (8014814 <hci_run_acl_fragments+0x80>)
 80147ea:	490b      	ldr	r1, [pc, #44]	; (8014818 <hci_run_acl_fragments+0x84>)
 80147ec:	2001      	movs	r0, #1
 80147ee:	f002 fe27 	bl	8017440 <hci_dump_log>
            hci_stack->acl_fragmentation_total_size = 0;
 80147f2:	4b07      	ldr	r3, [pc, #28]	; (8014810 <hci_run_acl_fragments+0x7c>)
 80147f4:	681b      	ldr	r3, [r3, #0]
 80147f6:	2200      	movs	r2, #0
 80147f8:	f8a3 26f8 	strh.w	r2, [r3, #1784]	; 0x6f8
            hci_stack->acl_fragmentation_pos = 0;
 80147fc:	4b04      	ldr	r3, [pc, #16]	; (8014810 <hci_run_acl_fragments+0x7c>)
 80147fe:	681b      	ldr	r3, [r3, #0]
 8014800:	2200      	movs	r2, #0
 8014802:	f8a3 26f6 	strh.w	r2, [r3, #1782]	; 0x6f6
        }
    }
    return false;
 8014806:	2300      	movs	r3, #0
}
 8014808:	4618      	mov	r0, r3
 801480a:	3708      	adds	r7, #8
 801480c:	46bd      	mov	sp, r7
 801480e:	bd80      	pop	{r7, pc}
 8014810:	20009780 	.word	0x20009780
 8014814:	0802929c 	.word	0x0802929c
 8014818:	0802a61c 	.word	0x0802a61c

0801481c <hci_run_general_gap_classic>:

#ifdef ENABLE_CLASSIC
static bool hci_run_general_gap_classic(void){
 801481c:	b580      	push	{r7, lr}
 801481e:	b084      	sub	sp, #16
 8014820:	af02      	add	r7, sp, #8

    // decline incoming connections
    if (hci_stack->decline_reason){
 8014822:	4b7a      	ldr	r3, [pc, #488]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 8014824:	681b      	ldr	r3, [r3, #0]
 8014826:	f893 374d 	ldrb.w	r3, [r3, #1869]	; 0x74d
 801482a:	2b00      	cmp	r3, #0
 801482c:	d014      	beq.n	8014858 <hci_run_general_gap_classic+0x3c>
        uint8_t reason = hci_stack->decline_reason;
 801482e:	4b77      	ldr	r3, [pc, #476]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 8014830:	681b      	ldr	r3, [r3, #0]
 8014832:	f893 374d 	ldrb.w	r3, [r3, #1869]	; 0x74d
 8014836:	717b      	strb	r3, [r7, #5]
        hci_stack->decline_reason = 0;
 8014838:	4b74      	ldr	r3, [pc, #464]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 801483a:	681b      	ldr	r3, [r3, #0]
 801483c:	2200      	movs	r2, #0
 801483e:	f883 274d 	strb.w	r2, [r3, #1869]	; 0x74d
        hci_send_cmd(&hci_reject_connection_request, hci_stack->decline_addr, reason);
 8014842:	4b72      	ldr	r3, [pc, #456]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 8014844:	681b      	ldr	r3, [r3, #0]
 8014846:	f203 734e 	addw	r3, r3, #1870	; 0x74e
 801484a:	797a      	ldrb	r2, [r7, #5]
 801484c:	4619      	mov	r1, r3
 801484e:	4870      	ldr	r0, [pc, #448]	; (8014a10 <hci_run_general_gap_classic+0x1f4>)
 8014850:	f001 fbc6 	bl	8015fe0 <hci_send_cmd>
        return true;
 8014854:	2301      	movs	r3, #1
 8014856:	e0d5      	b.n	8014a04 <hci_run_general_gap_classic+0x1e8>
    }
    // send scan enable
    if ((hci_stack->state == HCI_STATE_WORKING) && (hci_stack->new_scan_enable_value != 0xff) && hci_classic_supported()){
 8014858:	4b6c      	ldr	r3, [pc, #432]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 801485a:	681b      	ldr	r3, [r3, #0]
 801485c:	f893 3716 	ldrb.w	r3, [r3, #1814]	; 0x716
 8014860:	2b02      	cmp	r3, #2
 8014862:	d119      	bne.n	8014898 <hci_run_general_gap_classic+0x7c>
 8014864:	4b69      	ldr	r3, [pc, #420]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 8014866:	681b      	ldr	r3, [r3, #0]
 8014868:	f893 372d 	ldrb.w	r3, [r3, #1837]	; 0x72d
 801486c:	2bff      	cmp	r3, #255	; 0xff
 801486e:	d013      	beq.n	8014898 <hci_run_general_gap_classic+0x7c>
 8014870:	f7fb ffe4 	bl	801083c <hci_classic_supported>
 8014874:	4603      	mov	r3, r0
 8014876:	2b00      	cmp	r3, #0
 8014878:	d00e      	beq.n	8014898 <hci_run_general_gap_classic+0x7c>
        hci_send_cmd(&hci_write_scan_enable, hci_stack->new_scan_enable_value);
 801487a:	4b64      	ldr	r3, [pc, #400]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 801487c:	681b      	ldr	r3, [r3, #0]
 801487e:	f893 372d 	ldrb.w	r3, [r3, #1837]	; 0x72d
 8014882:	4619      	mov	r1, r3
 8014884:	4863      	ldr	r0, [pc, #396]	; (8014a14 <hci_run_general_gap_classic+0x1f8>)
 8014886:	f001 fbab 	bl	8015fe0 <hci_send_cmd>
        hci_stack->new_scan_enable_value = 0xff;
 801488a:	4b60      	ldr	r3, [pc, #384]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 801488c:	681b      	ldr	r3, [r3, #0]
 801488e:	22ff      	movs	r2, #255	; 0xff
 8014890:	f883 272d 	strb.w	r2, [r3, #1837]	; 0x72d
        return true;
 8014894:	2301      	movs	r3, #1
 8014896:	e0b5      	b.n	8014a04 <hci_run_general_gap_classic+0x1e8>
    }
    // start/stop inquiry
    if ((hci_stack->inquiry_state >= GAP_INQUIRY_DURATION_MIN) && (hci_stack->inquiry_state <= GAP_INQUIRY_DURATION_MAX)){
 8014898:	4b5c      	ldr	r3, [pc, #368]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 801489a:	681b      	ldr	r3, [r3, #0]
 801489c:	f893 3731 	ldrb.w	r3, [r3, #1841]	; 0x731
 80148a0:	2b00      	cmp	r3, #0
 80148a2:	d017      	beq.n	80148d4 <hci_run_general_gap_classic+0xb8>
 80148a4:	4b59      	ldr	r3, [pc, #356]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 80148a6:	681b      	ldr	r3, [r3, #0]
 80148a8:	f893 3731 	ldrb.w	r3, [r3, #1841]	; 0x731
 80148ac:	2b30      	cmp	r3, #48	; 0x30
 80148ae:	d811      	bhi.n	80148d4 <hci_run_general_gap_classic+0xb8>
        uint8_t duration = hci_stack->inquiry_state;
 80148b0:	4b56      	ldr	r3, [pc, #344]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 80148b2:	681b      	ldr	r3, [r3, #0]
 80148b4:	f893 3731 	ldrb.w	r3, [r3, #1841]	; 0x731
 80148b8:	71fb      	strb	r3, [r7, #7]
        hci_stack->inquiry_state = GAP_INQUIRY_STATE_ACTIVE;
 80148ba:	4b54      	ldr	r3, [pc, #336]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 80148bc:	681b      	ldr	r3, [r3, #0]
 80148be:	2280      	movs	r2, #128	; 0x80
 80148c0:	f883 2731 	strb.w	r2, [r3, #1841]	; 0x731
        hci_send_cmd(&hci_inquiry, GAP_IAC_GENERAL_INQUIRY, duration, 0);
 80148c4:	79fa      	ldrb	r2, [r7, #7]
 80148c6:	2300      	movs	r3, #0
 80148c8:	4953      	ldr	r1, [pc, #332]	; (8014a18 <hci_run_general_gap_classic+0x1fc>)
 80148ca:	4854      	ldr	r0, [pc, #336]	; (8014a1c <hci_run_general_gap_classic+0x200>)
 80148cc:	f001 fb88 	bl	8015fe0 <hci_send_cmd>
        return true;
 80148d0:	2301      	movs	r3, #1
 80148d2:	e097      	b.n	8014a04 <hci_run_general_gap_classic+0x1e8>
    }
    if (hci_stack->inquiry_state == GAP_INQUIRY_STATE_W2_CANCEL){
 80148d4:	4b4d      	ldr	r3, [pc, #308]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 80148d6:	681b      	ldr	r3, [r3, #0]
 80148d8:	f893 3731 	ldrb.w	r3, [r3, #1841]	; 0x731
 80148dc:	2b81      	cmp	r3, #129	; 0x81
 80148de:	d109      	bne.n	80148f4 <hci_run_general_gap_classic+0xd8>
        hci_stack->inquiry_state = GAP_INQUIRY_STATE_W4_CANCELLED;
 80148e0:	4b4a      	ldr	r3, [pc, #296]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 80148e2:	681b      	ldr	r3, [r3, #0]
 80148e4:	2282      	movs	r2, #130	; 0x82
 80148e6:	f883 2731 	strb.w	r2, [r3, #1841]	; 0x731
        hci_send_cmd(&hci_inquiry_cancel);
 80148ea:	484d      	ldr	r0, [pc, #308]	; (8014a20 <hci_run_general_gap_classic+0x204>)
 80148ec:	f001 fb78 	bl	8015fe0 <hci_send_cmd>
        return true;
 80148f0:	2301      	movs	r3, #1
 80148f2:	e087      	b.n	8014a04 <hci_run_general_gap_classic+0x1e8>
    }
    // remote name request
    if (hci_stack->remote_name_state == GAP_REMOTE_NAME_STATE_W2_SEND){
 80148f4:	4b45      	ldr	r3, [pc, #276]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 80148f6:	681b      	ldr	r3, [r3, #0]
 80148f8:	f893 373b 	ldrb.w	r3, [r3, #1851]	; 0x73b
 80148fc:	2b01      	cmp	r3, #1
 80148fe:	d118      	bne.n	8014932 <hci_run_general_gap_classic+0x116>
        hci_stack->remote_name_state = GAP_REMOTE_NAME_STATE_W4_COMPLETE;
 8014900:	4b42      	ldr	r3, [pc, #264]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 8014902:	681b      	ldr	r3, [r3, #0]
 8014904:	2202      	movs	r2, #2
 8014906:	f883 273b 	strb.w	r2, [r3, #1851]	; 0x73b
        hci_send_cmd(&hci_remote_name_request, hci_stack->remote_name_addr,
 801490a:	4b40      	ldr	r3, [pc, #256]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 801490c:	681b      	ldr	r3, [r3, #0]
 801490e:	f203 7132 	addw	r1, r3, #1842	; 0x732
                     hci_stack->remote_name_page_scan_repetition_mode, 0, hci_stack->remote_name_clock_offset);
 8014912:	4b3e      	ldr	r3, [pc, #248]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 8014914:	681b      	ldr	r3, [r3, #0]
 8014916:	f893 373a 	ldrb.w	r3, [r3, #1850]	; 0x73a
        hci_send_cmd(&hci_remote_name_request, hci_stack->remote_name_addr,
 801491a:	461a      	mov	r2, r3
                     hci_stack->remote_name_page_scan_repetition_mode, 0, hci_stack->remote_name_clock_offset);
 801491c:	4b3b      	ldr	r3, [pc, #236]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 801491e:	681b      	ldr	r3, [r3, #0]
 8014920:	f8b3 3738 	ldrh.w	r3, [r3, #1848]	; 0x738
        hci_send_cmd(&hci_remote_name_request, hci_stack->remote_name_addr,
 8014924:	9300      	str	r3, [sp, #0]
 8014926:	2300      	movs	r3, #0
 8014928:	483e      	ldr	r0, [pc, #248]	; (8014a24 <hci_run_general_gap_classic+0x208>)
 801492a:	f001 fb59 	bl	8015fe0 <hci_send_cmd>
        return true;
 801492e:	2301      	movs	r3, #1
 8014930:	e068      	b.n	8014a04 <hci_run_general_gap_classic+0x1e8>
            hci_send_cmd(&hci_read_local_oob_data);
        }
    }
#endif
    // pairing
    if (hci_stack->gap_pairing_state != GAP_PAIRING_STATE_IDLE){
 8014932:	4b36      	ldr	r3, [pc, #216]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 8014934:	681b      	ldr	r3, [r3, #0]
 8014936:	f893 3742 	ldrb.w	r3, [r3, #1858]	; 0x742
 801493a:	2b00      	cmp	r3, #0
 801493c:	d061      	beq.n	8014a02 <hci_run_general_gap_classic+0x1e6>
        uint8_t state = hci_stack->gap_pairing_state;
 801493e:	4b33      	ldr	r3, [pc, #204]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 8014940:	681b      	ldr	r3, [r3, #0]
 8014942:	f893 3742 	ldrb.w	r3, [r3, #1858]	; 0x742
 8014946:	71bb      	strb	r3, [r7, #6]
        hci_stack->gap_pairing_state = GAP_PAIRING_STATE_IDLE;
 8014948:	4b30      	ldr	r3, [pc, #192]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 801494a:	681b      	ldr	r3, [r3, #0]
 801494c:	2200      	movs	r2, #0
 801494e:	f883 2742 	strb.w	r2, [r3, #1858]	; 0x742
        switch (state){
 8014952:	79bb      	ldrb	r3, [r7, #6]
 8014954:	3b01      	subs	r3, #1
 8014956:	2b05      	cmp	r3, #5
 8014958:	d850      	bhi.n	80149fc <hci_run_general_gap_classic+0x1e0>
 801495a:	a201      	add	r2, pc, #4	; (adr r2, 8014960 <hci_run_general_gap_classic+0x144>)
 801495c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014960:	08014979 	.word	0x08014979
 8014964:	0801499b 	.word	0x0801499b
 8014968:	080149ad 	.word	0x080149ad
 801496c:	080149c7 	.word	0x080149c7
 8014970:	080149d9 	.word	0x080149d9
 8014974:	080149eb 	.word	0x080149eb
            case GAP_PAIRING_STATE_SEND_PIN:
                hci_send_cmd(&hci_pin_code_request_reply, hci_stack->gap_pairing_addr, hci_stack->gap_pairing_pin_len, hci_stack->gap_pairing_input.gap_pairing_pin);
 8014978:	4b24      	ldr	r3, [pc, #144]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 801497a:	681b      	ldr	r3, [r3, #0]
 801497c:	f203 713c 	addw	r1, r3, #1852	; 0x73c
 8014980:	4b22      	ldr	r3, [pc, #136]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 8014982:	681b      	ldr	r3, [r3, #0]
 8014984:	f893 3743 	ldrb.w	r3, [r3, #1859]	; 0x743
 8014988:	461a      	mov	r2, r3
 801498a:	4b20      	ldr	r3, [pc, #128]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 801498c:	681b      	ldr	r3, [r3, #0]
 801498e:	f8d3 3744 	ldr.w	r3, [r3, #1860]	; 0x744
 8014992:	4825      	ldr	r0, [pc, #148]	; (8014a28 <hci_run_general_gap_classic+0x20c>)
 8014994:	f001 fb24 	bl	8015fe0 <hci_send_cmd>
                break;
 8014998:	e031      	b.n	80149fe <hci_run_general_gap_classic+0x1e2>
            case GAP_PAIRING_STATE_SEND_PIN_NEGATIVE:
                hci_send_cmd(&hci_pin_code_request_negative_reply, hci_stack->gap_pairing_addr);
 801499a:	4b1c      	ldr	r3, [pc, #112]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 801499c:	681b      	ldr	r3, [r3, #0]
 801499e:	f203 733c 	addw	r3, r3, #1852	; 0x73c
 80149a2:	4619      	mov	r1, r3
 80149a4:	4821      	ldr	r0, [pc, #132]	; (8014a2c <hci_run_general_gap_classic+0x210>)
 80149a6:	f001 fb1b 	bl	8015fe0 <hci_send_cmd>
                break;
 80149aa:	e028      	b.n	80149fe <hci_run_general_gap_classic+0x1e2>
            case GAP_PAIRING_STATE_SEND_PASSKEY:
                hci_send_cmd(&hci_user_passkey_request_reply, hci_stack->gap_pairing_addr, hci_stack->gap_pairing_input.gap_pairing_passkey);
 80149ac:	4b17      	ldr	r3, [pc, #92]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 80149ae:	681b      	ldr	r3, [r3, #0]
 80149b0:	f203 713c 	addw	r1, r3, #1852	; 0x73c
 80149b4:	4b15      	ldr	r3, [pc, #84]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 80149b6:	681b      	ldr	r3, [r3, #0]
 80149b8:	f8d3 3744 	ldr.w	r3, [r3, #1860]	; 0x744
 80149bc:	461a      	mov	r2, r3
 80149be:	481c      	ldr	r0, [pc, #112]	; (8014a30 <hci_run_general_gap_classic+0x214>)
 80149c0:	f001 fb0e 	bl	8015fe0 <hci_send_cmd>
                break;
 80149c4:	e01b      	b.n	80149fe <hci_run_general_gap_classic+0x1e2>
            case GAP_PAIRING_STATE_SEND_PASSKEY_NEGATIVE:
                hci_send_cmd(&hci_user_passkey_request_negative_reply, hci_stack->gap_pairing_addr);
 80149c6:	4b11      	ldr	r3, [pc, #68]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 80149c8:	681b      	ldr	r3, [r3, #0]
 80149ca:	f203 733c 	addw	r3, r3, #1852	; 0x73c
 80149ce:	4619      	mov	r1, r3
 80149d0:	4818      	ldr	r0, [pc, #96]	; (8014a34 <hci_run_general_gap_classic+0x218>)
 80149d2:	f001 fb05 	bl	8015fe0 <hci_send_cmd>
                break;
 80149d6:	e012      	b.n	80149fe <hci_run_general_gap_classic+0x1e2>
            case GAP_PAIRING_STATE_SEND_CONFIRMATION:
                hci_send_cmd(&hci_user_confirmation_request_reply, hci_stack->gap_pairing_addr);
 80149d8:	4b0c      	ldr	r3, [pc, #48]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 80149da:	681b      	ldr	r3, [r3, #0]
 80149dc:	f203 733c 	addw	r3, r3, #1852	; 0x73c
 80149e0:	4619      	mov	r1, r3
 80149e2:	4815      	ldr	r0, [pc, #84]	; (8014a38 <hci_run_general_gap_classic+0x21c>)
 80149e4:	f001 fafc 	bl	8015fe0 <hci_send_cmd>
                break;
 80149e8:	e009      	b.n	80149fe <hci_run_general_gap_classic+0x1e2>
            case GAP_PAIRING_STATE_SEND_CONFIRMATION_NEGATIVE:
                hci_send_cmd(&hci_user_confirmation_request_negative_reply, hci_stack->gap_pairing_addr);
 80149ea:	4b08      	ldr	r3, [pc, #32]	; (8014a0c <hci_run_general_gap_classic+0x1f0>)
 80149ec:	681b      	ldr	r3, [r3, #0]
 80149ee:	f203 733c 	addw	r3, r3, #1852	; 0x73c
 80149f2:	4619      	mov	r1, r3
 80149f4:	4811      	ldr	r0, [pc, #68]	; (8014a3c <hci_run_general_gap_classic+0x220>)
 80149f6:	f001 faf3 	bl	8015fe0 <hci_send_cmd>
                break;
 80149fa:	e000      	b.n	80149fe <hci_run_general_gap_classic+0x1e2>
            default:
                break;
 80149fc:	bf00      	nop
        }
        return true;
 80149fe:	2301      	movs	r3, #1
 8014a00:	e000      	b.n	8014a04 <hci_run_general_gap_classic+0x1e8>
    }
    return false;
 8014a02:	2300      	movs	r3, #0
}
 8014a04:	4618      	mov	r0, r3
 8014a06:	3708      	adds	r7, #8
 8014a08:	46bd      	mov	sp, r7
 8014a0a:	bd80      	pop	{r7, pc}
 8014a0c:	20009780 	.word	0x20009780
 8014a10:	08030a28 	.word	0x08030a28
 8014a14:	08030af0 	.word	0x08030af0
 8014a18:	009e8b33 	.word	0x009e8b33
 8014a1c:	080309f8 	.word	0x080309f8
 8014a20:	08030a00 	.word	0x08030a00
 8014a24:	08030a60 	.word	0x08030a60
 8014a28:	08030a40 	.word	0x08030a40
 8014a2c:	08030a48 	.word	0x08030a48
 8014a30:	08030a90 	.word	0x08030a90
 8014a34:	08030a98 	.word	0x08030a98
 8014a38:	08030a80 	.word	0x08030a80
 8014a3c:	08030a88 	.word	0x08030a88

08014a40 <hci_run_general_gap_le>:
#endif

#ifdef ENABLE_BLE
static bool hci_run_general_gap_le(void){
 8014a40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014a42:	b0a5      	sub	sp, #148	; 0x94
 8014a44:	af0a      	add	r7, sp, #40	; 0x28

    // advertisements, active scanning, and creating connections requires random address to be set if using private address

    if (hci_stack->state != HCI_STATE_WORKING) return false;
 8014a46:	4bb2      	ldr	r3, [pc, #712]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014a48:	681b      	ldr	r3, [r3, #0]
 8014a4a:	f893 3716 	ldrb.w	r3, [r3, #1814]	; 0x716
 8014a4e:	2b02      	cmp	r3, #2
 8014a50:	d001      	beq.n	8014a56 <hci_run_general_gap_le+0x16>
 8014a52:	2300      	movs	r3, #0
 8014a54:	e2f1      	b.n	801503a <hci_run_general_gap_le+0x5fa>
    if ( (hci_stack->le_own_addr_type != BD_ADDR_TYPE_LE_PUBLIC) && (hci_stack->le_random_address_set == 0u) ) return false;
 8014a56:	4bae      	ldr	r3, [pc, #696]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014a58:	681b      	ldr	r3, [r3, #0]
 8014a5a:	f893 3754 	ldrb.w	r3, [r3, #1876]	; 0x754
 8014a5e:	2b00      	cmp	r3, #0
 8014a60:	d007      	beq.n	8014a72 <hci_run_general_gap_le+0x32>
 8014a62:	4bab      	ldr	r3, [pc, #684]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014a64:	681b      	ldr	r3, [r3, #0]
 8014a66:	f893 375b 	ldrb.w	r3, [r3, #1883]	; 0x75b
 8014a6a:	2b00      	cmp	r3, #0
 8014a6c:	d101      	bne.n	8014a72 <hci_run_general_gap_le+0x32>
 8014a6e:	2300      	movs	r3, #0
 8014a70:	e2e3      	b.n	801503a <hci_run_general_gap_le+0x5fa>


    // Phase 1: collect what to stop

    bool scanning_stop = false;
 8014a72:	2300      	movs	r3, #0
 8014a74:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
    bool connecting_stop = false;
 8014a78:	2300      	movs	r3, #0
 8014a7a:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
    bool advertising_stop = false;
 8014a7e:	2300      	movs	r3, #0
 8014a80:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
#ifndef ENABLE_LE_PERIPHERAL
    UNUSED(advertising_stop);
#endif

    // check if whitelist needs modification
    bool whitelist_modification_pending = false;
 8014a84:	2300      	movs	r3, #0
 8014a86:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
    btstack_linked_list_iterator_t lit;
    btstack_linked_list_iterator_init(&lit, &hci_stack->le_whitelist);
 8014a8a:	4ba1      	ldr	r3, [pc, #644]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014a8c:	681b      	ldr	r3, [r3, #0]
 8014a8e:	f503 62ec 	add.w	r2, r3, #1888	; 0x760
 8014a92:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8014a96:	4611      	mov	r1, r2
 8014a98:	4618      	mov	r0, r3
 8014a9a:	f7f9 fe58 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&lit)){
 8014a9e:	e00f      	b.n	8014ac0 <hci_run_general_gap_le+0x80>
        whitelist_entry_t * entry = (whitelist_entry_t*) btstack_linked_list_iterator_next(&lit);
 8014aa0:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8014aa4:	4618      	mov	r0, r3
 8014aa6:	f7f9 fe95 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8014aaa:	6638      	str	r0, [r7, #96]	; 0x60
        if (entry->state & (LE_WHITELIST_REMOVE_FROM_CONTROLLER | LE_WHITELIST_ADD_TO_CONTROLLER)){
 8014aac:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8014aae:	7adb      	ldrb	r3, [r3, #11]
 8014ab0:	f003 0306 	and.w	r3, r3, #6
 8014ab4:	2b00      	cmp	r3, #0
 8014ab6:	d003      	beq.n	8014ac0 <hci_run_general_gap_le+0x80>
            whitelist_modification_pending = true;
 8014ab8:	2301      	movs	r3, #1
 8014aba:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
            break;
 8014abe:	e007      	b.n	8014ad0 <hci_run_general_gap_le+0x90>
    while (btstack_linked_list_iterator_has_next(&lit)){
 8014ac0:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8014ac4:	4618      	mov	r0, r3
 8014ac6:	f7f9 fe57 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8014aca:	4603      	mov	r3, r0
 8014acc:	2b00      	cmp	r3, #0
 8014ace:	d1e7      	bne.n	8014aa0 <hci_run_general_gap_le+0x60>
        }
    }
    // check if resolving list needs modification
    bool resolving_list_modification_pending = false;
 8014ad0:	2300      	movs	r3, #0
 8014ad2:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
    }
#endif

#ifdef ENABLE_LE_CENTRAL
    // scanning control
    if (hci_stack->le_scanning_active) {
 8014ad6:	4b8e      	ldr	r3, [pc, #568]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014ad8:	681b      	ldr	r3, [r3, #0]
 8014ada:	f893 3765 	ldrb.w	r3, [r3, #1893]	; 0x765
 8014ade:	2b00      	cmp	r3, #0
 8014ae0:	d025      	beq.n	8014b2e <hci_run_general_gap_le+0xee>
        // stop if:
        // - parameter change required
        // - it's disabled
        // - whitelist change required but used for scanning
        // - resolving list modified
        bool scanning_uses_whitelist = (hci_stack->le_scan_filter_policy & 1) == 1;
 8014ae2:	4b8b      	ldr	r3, [pc, #556]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014ae4:	681b      	ldr	r3, [r3, #0]
 8014ae6:	f893 376a 	ldrb.w	r3, [r3, #1898]	; 0x76a
 8014aea:	f003 0301 	and.w	r3, r3, #1
 8014aee:	2b00      	cmp	r3, #0
 8014af0:	bf14      	ite	ne
 8014af2:	2301      	movne	r3, #1
 8014af4:	2300      	moveq	r3, #0
 8014af6:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
        if ((hci_stack->le_scanning_param_update) ||
 8014afa:	4b85      	ldr	r3, [pc, #532]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014afc:	681b      	ldr	r3, [r3, #0]
 8014afe:	f893 3768 	ldrb.w	r3, [r3, #1896]	; 0x768
 8014b02:	2b00      	cmp	r3, #0
 8014b04:	d110      	bne.n	8014b28 <hci_run_general_gap_le+0xe8>
            !hci_stack->le_scanning_enabled ||
 8014b06:	4b82      	ldr	r3, [pc, #520]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014b08:	681b      	ldr	r3, [r3, #0]
 8014b0a:	f893 3764 	ldrb.w	r3, [r3, #1892]	; 0x764
 8014b0e:	f083 0301 	eor.w	r3, r3, #1
 8014b12:	b2db      	uxtb	r3, r3
        if ((hci_stack->le_scanning_param_update) ||
 8014b14:	2b00      	cmp	r3, #0
 8014b16:	d107      	bne.n	8014b28 <hci_run_general_gap_le+0xe8>
            !hci_stack->le_scanning_enabled ||
 8014b18:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 8014b1c:	2b00      	cmp	r3, #0
 8014b1e:	d103      	bne.n	8014b28 <hci_run_general_gap_le+0xe8>
            scanning_uses_whitelist ||
 8014b20:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 8014b24:	2b00      	cmp	r3, #0
 8014b26:	d002      	beq.n	8014b2e <hci_run_general_gap_le+0xee>
            resolving_list_modification_pending){

            scanning_stop = true;
 8014b28:	2301      	movs	r3, #1
 8014b2a:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
#endif

#ifdef ENABLE_LE_CENTRAL
    // connecting control
    bool connecting_with_whitelist;
    switch (hci_stack->le_connecting_state){
 8014b2e:	4b78      	ldr	r3, [pc, #480]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014b30:	681b      	ldr	r3, [r3, #0]
 8014b32:	f893 3766 	ldrb.w	r3, [r3, #1894]	; 0x766
 8014b36:	3b02      	subs	r3, #2
 8014b38:	2b01      	cmp	r3, #1
 8014b3a:	d81f      	bhi.n	8014b7c <hci_run_general_gap_le+0x13c>
        case LE_CONNECTING_WHITELIST:
            // stop connecting if:
            // - connecting uses white and whitelist modification pending
            // - if it got disabled
            // - resolving list modified
            connecting_with_whitelist = hci_stack->le_connecting_state == LE_CONNECTING_WHITELIST;
 8014b3c:	4b74      	ldr	r3, [pc, #464]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014b3e:	681b      	ldr	r3, [r3, #0]
 8014b40:	f893 3766 	ldrb.w	r3, [r3, #1894]	; 0x766
 8014b44:	2b03      	cmp	r3, #3
 8014b46:	bf0c      	ite	eq
 8014b48:	2301      	moveq	r3, #1
 8014b4a:	2300      	movne	r3, #0
 8014b4c:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
            if ((connecting_with_whitelist && whitelist_modification_pending) ||
 8014b50:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 8014b54:	2b00      	cmp	r3, #0
 8014b56:	d003      	beq.n	8014b60 <hci_run_general_gap_le+0x120>
 8014b58:	f897 3064 	ldrb.w	r3, [r7, #100]	; 0x64
 8014b5c:	2b00      	cmp	r3, #0
 8014b5e:	d109      	bne.n	8014b74 <hci_run_general_gap_le+0x134>
                (hci_stack->le_connecting_request == LE_CONNECTING_IDLE) ||
 8014b60:	4b6b      	ldr	r3, [pc, #428]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014b62:	681b      	ldr	r3, [r3, #0]
 8014b64:	f893 3767 	ldrb.w	r3, [r3, #1895]	; 0x767
            if ((connecting_with_whitelist && whitelist_modification_pending) ||
 8014b68:	2b00      	cmp	r3, #0
 8014b6a:	d003      	beq.n	8014b74 <hci_run_general_gap_le+0x134>
                (hci_stack->le_connecting_request == LE_CONNECTING_IDLE) ||
 8014b6c:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 8014b70:	2b00      	cmp	r3, #0
 8014b72:	d005      	beq.n	8014b80 <hci_run_general_gap_le+0x140>
                resolving_list_modification_pending) {

                connecting_stop = true;
 8014b74:	2301      	movs	r3, #1
 8014b76:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
            }
            break;
 8014b7a:	e001      	b.n	8014b80 <hci_run_general_gap_le+0x140>
        default:
            break;
 8014b7c:	bf00      	nop
 8014b7e:	e000      	b.n	8014b82 <hci_run_general_gap_le+0x142>
            break;
 8014b80:	bf00      	nop
    }
#endif

#ifdef ENABLE_LE_PERIPHERAL
    // le advertisement control
    if (hci_stack->le_advertisements_active){
 8014b82:	4b63      	ldr	r3, [pc, #396]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014b84:	681b      	ldr	r3, [r3, #0]
 8014b86:	f893 3799 	ldrb.w	r3, [r3, #1945]	; 0x799
 8014b8a:	2b00      	cmp	r3, #0
 8014b8c:	d026      	beq.n	8014bdc <hci_run_general_gap_le+0x19c>
        // stop if:
        // - parameter change required
        // - it's disabled
        // - whitelist change required but used for advertisement filter policy
        // - resolving list modified
        bool advertising_uses_whitelist = hci_stack->le_advertisements_filter_policy > 0;
 8014b8e:	4b60      	ldr	r3, [pc, #384]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014b90:	681b      	ldr	r3, [r3, #0]
 8014b92:	f893 37a5 	ldrb.w	r3, [r3, #1957]	; 0x7a5
 8014b96:	2b00      	cmp	r3, #0
 8014b98:	bf14      	ite	ne
 8014b9a:	2301      	movne	r3, #1
 8014b9c:	2300      	moveq	r3, #0
 8014b9e:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
        if ((hci_stack->le_advertisements_todo != 0) ||
 8014ba2:	4b5b      	ldr	r3, [pc, #364]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014ba4:	681b      	ldr	r3, [r3, #0]
 8014ba6:	f893 379c 	ldrb.w	r3, [r3, #1948]	; 0x79c
 8014baa:	2b00      	cmp	r3, #0
 8014bac:	d113      	bne.n	8014bd6 <hci_run_general_gap_le+0x196>
            !hci_stack->le_advertisements_enabled_for_current_roles ||
 8014bae:	4b58      	ldr	r3, [pc, #352]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014bb0:	681b      	ldr	r3, [r3, #0]
 8014bb2:	f893 379b 	ldrb.w	r3, [r3, #1947]	; 0x79b
 8014bb6:	f083 0301 	eor.w	r3, r3, #1
 8014bba:	b2db      	uxtb	r3, r3
        if ((hci_stack->le_advertisements_todo != 0) ||
 8014bbc:	2b00      	cmp	r3, #0
 8014bbe:	d10a      	bne.n	8014bd6 <hci_run_general_gap_le+0x196>
            (advertising_uses_whitelist & whitelist_modification_pending) ||
 8014bc0:	f897 205c 	ldrb.w	r2, [r7, #92]	; 0x5c
 8014bc4:	f897 3064 	ldrb.w	r3, [r7, #100]	; 0x64
 8014bc8:	4013      	ands	r3, r2
            !hci_stack->le_advertisements_enabled_for_current_roles ||
 8014bca:	2b00      	cmp	r3, #0
 8014bcc:	d103      	bne.n	8014bd6 <hci_run_general_gap_le+0x196>
            (advertising_uses_whitelist & whitelist_modification_pending) ||
 8014bce:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 8014bd2:	2b00      	cmp	r3, #0
 8014bd4:	d002      	beq.n	8014bdc <hci_run_general_gap_le+0x19c>
            resolving_list_modification_pending) {

            advertising_stop = true;
 8014bd6:	2301      	movs	r3, #1
 8014bd8:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65


    // Phase 2: stop everything that should be off during modifications

#ifdef ENABLE_LE_CENTRAL
    if (scanning_stop){
 8014bdc:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8014be0:	2b00      	cmp	r3, #0
 8014be2:	d00b      	beq.n	8014bfc <hci_run_general_gap_le+0x1bc>
        hci_stack->le_scanning_active = false;
 8014be4:	4b4a      	ldr	r3, [pc, #296]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014be6:	681b      	ldr	r3, [r3, #0]
 8014be8:	2200      	movs	r2, #0
 8014bea:	f883 2765 	strb.w	r2, [r3, #1893]	; 0x765
        hci_send_cmd(&hci_le_set_scan_enable, 0, 0);
 8014bee:	2200      	movs	r2, #0
 8014bf0:	2100      	movs	r1, #0
 8014bf2:	4848      	ldr	r0, [pc, #288]	; (8014d14 <hci_run_general_gap_le+0x2d4>)
 8014bf4:	f001 f9f4 	bl	8015fe0 <hci_send_cmd>
        return true;
 8014bf8:	2301      	movs	r3, #1
 8014bfa:	e21e      	b.n	801503a <hci_run_general_gap_le+0x5fa>
    }
#endif

#ifdef ENABLE_LE_CENTRAL
    if (connecting_stop){
 8014bfc:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 8014c00:	2b00      	cmp	r3, #0
 8014c02:	d004      	beq.n	8014c0e <hci_run_general_gap_le+0x1ce>
        hci_send_cmd(&hci_le_create_connection_cancel);
 8014c04:	4844      	ldr	r0, [pc, #272]	; (8014d18 <hci_run_general_gap_le+0x2d8>)
 8014c06:	f001 f9eb 	bl	8015fe0 <hci_send_cmd>
        return true;
 8014c0a:	2301      	movs	r3, #1
 8014c0c:	e215      	b.n	801503a <hci_run_general_gap_le+0x5fa>
    }
#endif

#ifdef ENABLE_LE_PERIPHERAL
    if (advertising_stop){
 8014c0e:	f897 3065 	ldrb.w	r3, [r7, #101]	; 0x65
 8014c12:	2b00      	cmp	r3, #0
 8014c14:	d00a      	beq.n	8014c2c <hci_run_general_gap_le+0x1ec>
        hci_stack->le_advertisements_active = false;
 8014c16:	4b3e      	ldr	r3, [pc, #248]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014c18:	681b      	ldr	r3, [r3, #0]
 8014c1a:	2200      	movs	r2, #0
 8014c1c:	f883 2799 	strb.w	r2, [r3, #1945]	; 0x799
        hci_send_cmd(&hci_le_set_advertise_enable, 0);
 8014c20:	2100      	movs	r1, #0
 8014c22:	483e      	ldr	r0, [pc, #248]	; (8014d1c <hci_run_general_gap_le+0x2dc>)
 8014c24:	f001 f9dc 	bl	8015fe0 <hci_send_cmd>
        return true;
 8014c28:	2301      	movs	r3, #1
 8014c2a:	e206      	b.n	801503a <hci_run_general_gap_le+0x5fa>
#endif

    // Phase 3: modify

#ifdef ENABLE_LE_CENTRAL
    if (hci_stack->le_scanning_param_update){
 8014c2c:	4b38      	ldr	r3, [pc, #224]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014c2e:	681b      	ldr	r3, [r3, #0]
 8014c30:	f893 3768 	ldrb.w	r3, [r3, #1896]	; 0x768
 8014c34:	2b00      	cmp	r3, #0
 8014c36:	d025      	beq.n	8014c84 <hci_run_general_gap_le+0x244>
        hci_stack->le_scanning_param_update = false;
 8014c38:	4b35      	ldr	r3, [pc, #212]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014c3a:	681b      	ldr	r3, [r3, #0]
 8014c3c:	2200      	movs	r2, #0
 8014c3e:	f883 2768 	strb.w	r2, [r3, #1896]	; 0x768
        hci_send_cmd(&hci_le_set_scan_parameters, hci_stack->le_scan_type, hci_stack->le_scan_interval, hci_stack->le_scan_window,
 8014c42:	4b33      	ldr	r3, [pc, #204]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014c44:	681b      	ldr	r3, [r3, #0]
 8014c46:	f893 3769 	ldrb.w	r3, [r3, #1897]	; 0x769
 8014c4a:	4619      	mov	r1, r3
 8014c4c:	4b30      	ldr	r3, [pc, #192]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014c4e:	681b      	ldr	r3, [r3, #0]
 8014c50:	f8b3 376c 	ldrh.w	r3, [r3, #1900]	; 0x76c
 8014c54:	4618      	mov	r0, r3
 8014c56:	4b2e      	ldr	r3, [pc, #184]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014c58:	681b      	ldr	r3, [r3, #0]
 8014c5a:	f8b3 376e 	ldrh.w	r3, [r3, #1902]	; 0x76e
 8014c5e:	461c      	mov	r4, r3
                     hci_stack->le_own_addr_type, hci_stack->le_scan_filter_policy);
 8014c60:	4b2b      	ldr	r3, [pc, #172]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014c62:	681b      	ldr	r3, [r3, #0]
 8014c64:	f893 3754 	ldrb.w	r3, [r3, #1876]	; 0x754
        hci_send_cmd(&hci_le_set_scan_parameters, hci_stack->le_scan_type, hci_stack->le_scan_interval, hci_stack->le_scan_window,
 8014c68:	461a      	mov	r2, r3
                     hci_stack->le_own_addr_type, hci_stack->le_scan_filter_policy);
 8014c6a:	4b29      	ldr	r3, [pc, #164]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014c6c:	681b      	ldr	r3, [r3, #0]
 8014c6e:	f893 376a 	ldrb.w	r3, [r3, #1898]	; 0x76a
        hci_send_cmd(&hci_le_set_scan_parameters, hci_stack->le_scan_type, hci_stack->le_scan_interval, hci_stack->le_scan_window,
 8014c72:	9301      	str	r3, [sp, #4]
 8014c74:	9200      	str	r2, [sp, #0]
 8014c76:	4623      	mov	r3, r4
 8014c78:	4602      	mov	r2, r0
 8014c7a:	4829      	ldr	r0, [pc, #164]	; (8014d20 <hci_run_general_gap_le+0x2e0>)
 8014c7c:	f001 f9b0 	bl	8015fe0 <hci_send_cmd>
        return true;
 8014c80:	2301      	movs	r3, #1
 8014c82:	e1da      	b.n	801503a <hci_run_general_gap_le+0x5fa>
    }
#endif

#ifdef ENABLE_LE_PERIPHERAL
    if (hci_stack->le_advertisements_todo & LE_ADVERTISEMENT_TASKS_SET_PARAMS){
 8014c84:	4b22      	ldr	r3, [pc, #136]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014c86:	681b      	ldr	r3, [r3, #0]
 8014c88:	f893 379c 	ldrb.w	r3, [r3, #1948]	; 0x79c
 8014c8c:	f003 0304 	and.w	r3, r3, #4
 8014c90:	2b00      	cmp	r3, #0
 8014c92:	d049      	beq.n	8014d28 <hci_run_general_gap_le+0x2e8>
        hci_stack->le_advertisements_todo &= ~LE_ADVERTISEMENT_TASKS_SET_PARAMS;
 8014c94:	4b1e      	ldr	r3, [pc, #120]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014c96:	681b      	ldr	r3, [r3, #0]
 8014c98:	f893 279c 	ldrb.w	r2, [r3, #1948]	; 0x79c
 8014c9c:	4b1c      	ldr	r3, [pc, #112]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014c9e:	681b      	ldr	r3, [r3, #0]
 8014ca0:	f022 0204 	bic.w	r2, r2, #4
 8014ca4:	b2d2      	uxtb	r2, r2
 8014ca6:	f883 279c 	strb.w	r2, [r3, #1948]	; 0x79c
        hci_send_cmd(&hci_le_set_advertising_parameters,
                     hci_stack->le_advertisements_interval_min,
 8014caa:	4b19      	ldr	r3, [pc, #100]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014cac:	681b      	ldr	r3, [r3, #0]
 8014cae:	f8b3 379e 	ldrh.w	r3, [r3, #1950]	; 0x79e
        hci_send_cmd(&hci_le_set_advertising_parameters,
 8014cb2:	461d      	mov	r5, r3
                     hci_stack->le_advertisements_interval_max,
 8014cb4:	4b16      	ldr	r3, [pc, #88]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014cb6:	681b      	ldr	r3, [r3, #0]
 8014cb8:	f8b3 37a0 	ldrh.w	r3, [r3, #1952]	; 0x7a0
        hci_send_cmd(&hci_le_set_advertising_parameters,
 8014cbc:	461e      	mov	r6, r3
                     hci_stack->le_advertisements_type,
 8014cbe:	4b14      	ldr	r3, [pc, #80]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014cc0:	681b      	ldr	r3, [r3, #0]
 8014cc2:	f893 37a2 	ldrb.w	r3, [r3, #1954]	; 0x7a2
        hci_send_cmd(&hci_le_set_advertising_parameters,
 8014cc6:	469c      	mov	ip, r3
                     hci_stack->le_own_addr_type,
 8014cc8:	4b11      	ldr	r3, [pc, #68]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014cca:	681b      	ldr	r3, [r3, #0]
 8014ccc:	f893 3754 	ldrb.w	r3, [r3, #1876]	; 0x754
        hci_send_cmd(&hci_le_set_advertising_parameters,
 8014cd0:	4619      	mov	r1, r3
                     hci_stack->le_advertisements_direct_address_type,
 8014cd2:	4b0f      	ldr	r3, [pc, #60]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014cd4:	681b      	ldr	r3, [r3, #0]
 8014cd6:	f893 37a3 	ldrb.w	r3, [r3, #1955]	; 0x7a3
        hci_send_cmd(&hci_le_set_advertising_parameters,
 8014cda:	4618      	mov	r0, r3
                     hci_stack->le_advertisements_direct_address,
 8014cdc:	4b0c      	ldr	r3, [pc, #48]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014cde:	681b      	ldr	r3, [r3, #0]
 8014ce0:	f203 73a6 	addw	r3, r3, #1958	; 0x7a6
                     hci_stack->le_advertisements_channel_map,
 8014ce4:	4a0a      	ldr	r2, [pc, #40]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014ce6:	6812      	ldr	r2, [r2, #0]
 8014ce8:	f892 27a4 	ldrb.w	r2, [r2, #1956]	; 0x7a4
        hci_send_cmd(&hci_le_set_advertising_parameters,
 8014cec:	4614      	mov	r4, r2
                     hci_stack->le_advertisements_filter_policy);
 8014cee:	4a08      	ldr	r2, [pc, #32]	; (8014d10 <hci_run_general_gap_le+0x2d0>)
 8014cf0:	6812      	ldr	r2, [r2, #0]
 8014cf2:	f892 27a5 	ldrb.w	r2, [r2, #1957]	; 0x7a5
        hci_send_cmd(&hci_le_set_advertising_parameters,
 8014cf6:	9204      	str	r2, [sp, #16]
 8014cf8:	9403      	str	r4, [sp, #12]
 8014cfa:	9302      	str	r3, [sp, #8]
 8014cfc:	9001      	str	r0, [sp, #4]
 8014cfe:	9100      	str	r1, [sp, #0]
 8014d00:	4663      	mov	r3, ip
 8014d02:	4632      	mov	r2, r6
 8014d04:	4629      	mov	r1, r5
 8014d06:	4807      	ldr	r0, [pc, #28]	; (8014d24 <hci_run_general_gap_le+0x2e4>)
 8014d08:	f001 f96a 	bl	8015fe0 <hci_send_cmd>
        return true;
 8014d0c:	2301      	movs	r3, #1
 8014d0e:	e194      	b.n	801503a <hci_run_general_gap_le+0x5fa>
 8014d10:	20009780 	.word	0x20009780
 8014d14:	08030bb8 	.word	0x08030bb8
 8014d18:	08030bc8 	.word	0x08030bc8
 8014d1c:	08030ba8 	.word	0x08030ba8
 8014d20:	08030bb0 	.word	0x08030bb0
 8014d24:	08030b90 	.word	0x08030b90
    }
    if (hci_stack->le_advertisements_todo & LE_ADVERTISEMENT_TASKS_SET_ADV_DATA){
 8014d28:	4baf      	ldr	r3, [pc, #700]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014d2a:	681b      	ldr	r3, [r3, #0]
 8014d2c:	f893 379c 	ldrb.w	r3, [r3, #1948]	; 0x79c
 8014d30:	f003 0301 	and.w	r3, r3, #1
 8014d34:	2b00      	cmp	r3, #0
 8014d36:	d03a      	beq.n	8014dae <hci_run_general_gap_le+0x36e>
        hci_stack->le_advertisements_todo &= ~LE_ADVERTISEMENT_TASKS_SET_ADV_DATA;
 8014d38:	4bab      	ldr	r3, [pc, #684]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014d3a:	681b      	ldr	r3, [r3, #0]
 8014d3c:	f893 279c 	ldrb.w	r2, [r3, #1948]	; 0x79c
 8014d40:	4ba9      	ldr	r3, [pc, #676]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014d42:	681b      	ldr	r3, [r3, #0]
 8014d44:	f022 0201 	bic.w	r2, r2, #1
 8014d48:	b2d2      	uxtb	r2, r2
 8014d4a:	f883 279c 	strb.w	r2, [r3, #1948]	; 0x79c
        uint8_t adv_data_clean[31];
        memset(adv_data_clean, 0, sizeof(adv_data_clean));
 8014d4e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8014d52:	221f      	movs	r2, #31
 8014d54:	2100      	movs	r1, #0
 8014d56:	4618      	mov	r0, r3
 8014d58:	f012 feb3 	bl	8027ac2 <memset>
        (void)memcpy(adv_data_clean, hci_stack->le_advertisements_data,
 8014d5c:	4ba2      	ldr	r3, [pc, #648]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014d5e:	681b      	ldr	r3, [r3, #0]
 8014d60:	f8d3 178c 	ldr.w	r1, [r3, #1932]	; 0x78c
                     hci_stack->le_advertisements_data_len);
 8014d64:	4ba0      	ldr	r3, [pc, #640]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014d66:	681b      	ldr	r3, [r3, #0]
 8014d68:	f893 3790 	ldrb.w	r3, [r3, #1936]	; 0x790
        (void)memcpy(adv_data_clean, hci_stack->le_advertisements_data,
 8014d6c:	461a      	mov	r2, r3
 8014d6e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8014d72:	4618      	mov	r0, r3
 8014d74:	f012 fe81 	bl	8027a7a <memcpy>
        btstack_replace_bd_addr_placeholder(adv_data_clean, hci_stack->le_advertisements_data_len, hci_stack->local_bd_addr);
 8014d78:	4b9b      	ldr	r3, [pc, #620]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014d7a:	681b      	ldr	r3, [r3, #0]
 8014d7c:	f893 3790 	ldrb.w	r3, [r3, #1936]	; 0x790
 8014d80:	b299      	uxth	r1, r3
 8014d82:	4b99      	ldr	r3, [pc, #612]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014d84:	681b      	ldr	r3, [r3, #0]
 8014d86:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8014d8a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8014d8e:	4618      	mov	r0, r3
 8014d90:	f7fa fb76 	bl	800f480 <btstack_replace_bd_addr_placeholder>
        hci_send_cmd(&hci_le_set_advertising_data, hci_stack->le_advertisements_data_len, adv_data_clean);
 8014d94:	4b94      	ldr	r3, [pc, #592]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014d96:	681b      	ldr	r3, [r3, #0]
 8014d98:	f893 3790 	ldrb.w	r3, [r3, #1936]	; 0x790
 8014d9c:	4619      	mov	r1, r3
 8014d9e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8014da2:	461a      	mov	r2, r3
 8014da4:	4891      	ldr	r0, [pc, #580]	; (8014fec <hci_run_general_gap_le+0x5ac>)
 8014da6:	f001 f91b 	bl	8015fe0 <hci_send_cmd>
        return true;
 8014daa:	2301      	movs	r3, #1
 8014dac:	e145      	b.n	801503a <hci_run_general_gap_le+0x5fa>
    }
    if (hci_stack->le_advertisements_todo & LE_ADVERTISEMENT_TASKS_SET_SCAN_DATA){
 8014dae:	4b8e      	ldr	r3, [pc, #568]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014db0:	681b      	ldr	r3, [r3, #0]
 8014db2:	f893 379c 	ldrb.w	r3, [r3, #1948]	; 0x79c
 8014db6:	f003 0302 	and.w	r3, r3, #2
 8014dba:	2b00      	cmp	r3, #0
 8014dbc:	d03a      	beq.n	8014e34 <hci_run_general_gap_le+0x3f4>
        hci_stack->le_advertisements_todo &= ~LE_ADVERTISEMENT_TASKS_SET_SCAN_DATA;
 8014dbe:	4b8a      	ldr	r3, [pc, #552]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014dc0:	681b      	ldr	r3, [r3, #0]
 8014dc2:	f893 279c 	ldrb.w	r2, [r3, #1948]	; 0x79c
 8014dc6:	4b88      	ldr	r3, [pc, #544]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014dc8:	681b      	ldr	r3, [r3, #0]
 8014dca:	f022 0202 	bic.w	r2, r2, #2
 8014dce:	b2d2      	uxtb	r2, r2
 8014dd0:	f883 279c 	strb.w	r2, [r3, #1948]	; 0x79c
        uint8_t scan_data_clean[31];
        memset(scan_data_clean, 0, sizeof(scan_data_clean));
 8014dd4:	f107 030c 	add.w	r3, r7, #12
 8014dd8:	221f      	movs	r2, #31
 8014dda:	2100      	movs	r1, #0
 8014ddc:	4618      	mov	r0, r3
 8014dde:	f012 fe70 	bl	8027ac2 <memset>
        (void)memcpy(scan_data_clean, hci_stack->le_scan_response_data,
 8014de2:	4b81      	ldr	r3, [pc, #516]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014de4:	681b      	ldr	r3, [r3, #0]
 8014de6:	f8d3 1794 	ldr.w	r1, [r3, #1940]	; 0x794
                     hci_stack->le_scan_response_data_len);
 8014dea:	4b7f      	ldr	r3, [pc, #508]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014dec:	681b      	ldr	r3, [r3, #0]
 8014dee:	f893 3798 	ldrb.w	r3, [r3, #1944]	; 0x798
        (void)memcpy(scan_data_clean, hci_stack->le_scan_response_data,
 8014df2:	461a      	mov	r2, r3
 8014df4:	f107 030c 	add.w	r3, r7, #12
 8014df8:	4618      	mov	r0, r3
 8014dfa:	f012 fe3e 	bl	8027a7a <memcpy>
        btstack_replace_bd_addr_placeholder(scan_data_clean, hci_stack->le_scan_response_data_len, hci_stack->local_bd_addr);
 8014dfe:	4b7a      	ldr	r3, [pc, #488]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014e00:	681b      	ldr	r3, [r3, #0]
 8014e02:	f893 3798 	ldrb.w	r3, [r3, #1944]	; 0x798
 8014e06:	b299      	uxth	r1, r3
 8014e08:	4b77      	ldr	r3, [pc, #476]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014e0a:	681b      	ldr	r3, [r3, #0]
 8014e0c:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8014e10:	f107 030c 	add.w	r3, r7, #12
 8014e14:	4618      	mov	r0, r3
 8014e16:	f7fa fb33 	bl	800f480 <btstack_replace_bd_addr_placeholder>
        hci_send_cmd(&hci_le_set_scan_response_data, hci_stack->le_scan_response_data_len, scan_data_clean);
 8014e1a:	4b73      	ldr	r3, [pc, #460]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014e1c:	681b      	ldr	r3, [r3, #0]
 8014e1e:	f893 3798 	ldrb.w	r3, [r3, #1944]	; 0x798
 8014e22:	4619      	mov	r1, r3
 8014e24:	f107 030c 	add.w	r3, r7, #12
 8014e28:	461a      	mov	r2, r3
 8014e2a:	4871      	ldr	r0, [pc, #452]	; (8014ff0 <hci_run_general_gap_le+0x5b0>)
 8014e2c:	f001 f8d8 	bl	8015fe0 <hci_send_cmd>
        return true;
 8014e30:	2301      	movs	r3, #1
 8014e32:	e102      	b.n	801503a <hci_run_general_gap_le+0x5fa>
#endif


#ifdef ENABLE_LE_CENTRAL
    // if connect with whitelist was active and is not cancelled yet, wait until next time
    if (hci_stack->le_connecting_state == LE_CONNECTING_CANCEL) return false;
 8014e34:	4b6c      	ldr	r3, [pc, #432]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014e36:	681b      	ldr	r3, [r3, #0]
 8014e38:	f893 3766 	ldrb.w	r3, [r3, #1894]	; 0x766
 8014e3c:	2b01      	cmp	r3, #1
 8014e3e:	d101      	bne.n	8014e44 <hci_run_general_gap_le+0x404>
 8014e40:	2300      	movs	r3, #0
 8014e42:	e0fa      	b.n	801503a <hci_run_general_gap_le+0x5fa>
#endif

    // LE Whitelist Management
    if (whitelist_modification_pending){
 8014e44:	f897 3064 	ldrb.w	r3, [r7, #100]	; 0x64
 8014e48:	2b00      	cmp	r3, #0
 8014e4a:	d060      	beq.n	8014f0e <hci_run_general_gap_le+0x4ce>
        // add/remove entries
        btstack_linked_list_iterator_init(&lit, &hci_stack->le_whitelist);
 8014e4c:	4b66      	ldr	r3, [pc, #408]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014e4e:	681b      	ldr	r3, [r3, #0]
 8014e50:	f503 62ec 	add.w	r2, r3, #1888	; 0x760
 8014e54:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8014e58:	4611      	mov	r1, r2
 8014e5a:	4618      	mov	r0, r3
 8014e5c:	f7f9 fc77 	bl	800e74e <btstack_linked_list_iterator_init>
        while (btstack_linked_list_iterator_has_next(&lit)){
 8014e60:	e04d      	b.n	8014efe <hci_run_general_gap_le+0x4be>
            whitelist_entry_t * entry = (whitelist_entry_t*) btstack_linked_list_iterator_next(&lit);
 8014e62:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8014e66:	4618      	mov	r0, r3
 8014e68:	f7f9 fcb4 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8014e6c:	65b8      	str	r0, [r7, #88]	; 0x58
			if (entry->state & LE_WHITELIST_REMOVE_FROM_CONTROLLER){
 8014e6e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014e70:	7adb      	ldrb	r3, [r3, #11]
 8014e72:	f003 0304 	and.w	r3, r3, #4
 8014e76:	2b00      	cmp	r3, #0
 8014e78:	d011      	beq.n	8014e9e <hci_run_general_gap_le+0x45e>
				entry->state &= ~LE_WHITELIST_REMOVE_FROM_CONTROLLER;
 8014e7a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014e7c:	7adb      	ldrb	r3, [r3, #11]
 8014e7e:	f023 0304 	bic.w	r3, r3, #4
 8014e82:	b2da      	uxtb	r2, r3
 8014e84:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014e86:	72da      	strb	r2, [r3, #11]
				hci_send_cmd(&hci_le_remove_device_from_white_list, entry->address_type, entry->address);
 8014e88:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014e8a:	7a9b      	ldrb	r3, [r3, #10]
 8014e8c:	4619      	mov	r1, r3
 8014e8e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014e90:	3304      	adds	r3, #4
 8014e92:	461a      	mov	r2, r3
 8014e94:	4857      	ldr	r0, [pc, #348]	; (8014ff4 <hci_run_general_gap_le+0x5b4>)
 8014e96:	f001 f8a3 	bl	8015fe0 <hci_send_cmd>
				return true;
 8014e9a:	2301      	movs	r3, #1
 8014e9c:	e0cd      	b.n	801503a <hci_run_general_gap_le+0x5fa>
			}
            if (entry->state & LE_WHITELIST_ADD_TO_CONTROLLER){
 8014e9e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014ea0:	7adb      	ldrb	r3, [r3, #11]
 8014ea2:	f003 0302 	and.w	r3, r3, #2
 8014ea6:	2b00      	cmp	r3, #0
 8014ea8:	d018      	beq.n	8014edc <hci_run_general_gap_le+0x49c>
				entry->state &= ~LE_WHITELIST_ADD_TO_CONTROLLER;
 8014eaa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014eac:	7adb      	ldrb	r3, [r3, #11]
 8014eae:	f023 0302 	bic.w	r3, r3, #2
 8014eb2:	b2da      	uxtb	r2, r3
 8014eb4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014eb6:	72da      	strb	r2, [r3, #11]
                entry->state |= LE_WHITELIST_ON_CONTROLLER;
 8014eb8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014eba:	7adb      	ldrb	r3, [r3, #11]
 8014ebc:	f043 0301 	orr.w	r3, r3, #1
 8014ec0:	b2da      	uxtb	r2, r3
 8014ec2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014ec4:	72da      	strb	r2, [r3, #11]
                hci_send_cmd(&hci_le_add_device_to_white_list, entry->address_type, entry->address);
 8014ec6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014ec8:	7a9b      	ldrb	r3, [r3, #10]
 8014eca:	4619      	mov	r1, r3
 8014ecc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014ece:	3304      	adds	r3, #4
 8014ed0:	461a      	mov	r2, r3
 8014ed2:	4849      	ldr	r0, [pc, #292]	; (8014ff8 <hci_run_general_gap_le+0x5b8>)
 8014ed4:	f001 f884 	bl	8015fe0 <hci_send_cmd>
                return true;
 8014ed8:	2301      	movs	r3, #1
 8014eda:	e0ae      	b.n	801503a <hci_run_general_gap_le+0x5fa>
            }
            if ((entry->state & LE_WHITELIST_ON_CONTROLLER) == 0){
 8014edc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014ede:	7adb      	ldrb	r3, [r3, #11]
 8014ee0:	f003 0301 	and.w	r3, r3, #1
 8014ee4:	2b00      	cmp	r3, #0
 8014ee6:	d10a      	bne.n	8014efe <hci_run_general_gap_le+0x4be>
				btstack_linked_list_remove(&hci_stack->le_whitelist, (btstack_linked_item_t *) entry);
 8014ee8:	4b3f      	ldr	r3, [pc, #252]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014eea:	681b      	ldr	r3, [r3, #0]
 8014eec:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 8014ef0:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8014ef2:	4618      	mov	r0, r3
 8014ef4:	f7f9 fbe3 	bl	800e6be <btstack_linked_list_remove>
				btstack_memory_whitelist_entry_free(entry);
 8014ef8:	6db8      	ldr	r0, [r7, #88]	; 0x58
 8014efa:	f7f9 fcf7 	bl	800e8ec <btstack_memory_whitelist_entry_free>
        while (btstack_linked_list_iterator_has_next(&lit)){
 8014efe:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8014f02:	4618      	mov	r0, r3
 8014f04:	f7f9 fc38 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8014f08:	4603      	mov	r3, r0
 8014f0a:	2b00      	cmp	r3, #0
 8014f0c:	d1a9      	bne.n	8014e62 <hci_run_general_gap_le+0x422>

    // Phase 4: restore state

#ifdef ENABLE_LE_CENTRAL
    // re-start scanning
    if ((hci_stack->le_scanning_enabled && !hci_stack->le_scanning_active)){
 8014f0e:	4b36      	ldr	r3, [pc, #216]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014f10:	681b      	ldr	r3, [r3, #0]
 8014f12:	f893 3764 	ldrb.w	r3, [r3, #1892]	; 0x764
 8014f16:	2b00      	cmp	r3, #0
 8014f18:	d014      	beq.n	8014f44 <hci_run_general_gap_le+0x504>
 8014f1a:	4b33      	ldr	r3, [pc, #204]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014f1c:	681b      	ldr	r3, [r3, #0]
 8014f1e:	f893 3765 	ldrb.w	r3, [r3, #1893]	; 0x765
 8014f22:	f083 0301 	eor.w	r3, r3, #1
 8014f26:	b2db      	uxtb	r3, r3
 8014f28:	2b00      	cmp	r3, #0
 8014f2a:	d00b      	beq.n	8014f44 <hci_run_general_gap_le+0x504>
        hci_stack->le_scanning_active = true;
 8014f2c:	4b2e      	ldr	r3, [pc, #184]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014f2e:	681b      	ldr	r3, [r3, #0]
 8014f30:	2201      	movs	r2, #1
 8014f32:	f883 2765 	strb.w	r2, [r3, #1893]	; 0x765
        hci_send_cmd(&hci_le_set_scan_enable, 1, 0);
 8014f36:	2200      	movs	r2, #0
 8014f38:	2101      	movs	r1, #1
 8014f3a:	4830      	ldr	r0, [pc, #192]	; (8014ffc <hci_run_general_gap_le+0x5bc>)
 8014f3c:	f001 f850 	bl	8015fe0 <hci_send_cmd>
        return true;
 8014f40:	2301      	movs	r3, #1
 8014f42:	e07a      	b.n	801503a <hci_run_general_gap_le+0x5fa>
    }
#endif

#ifdef ENABLE_LE_CENTRAL
    // re-start connecting
    if ( (hci_stack->le_connecting_state == LE_CONNECTING_IDLE) && (hci_stack->le_connecting_request == LE_CONNECTING_WHITELIST)){
 8014f44:	4b28      	ldr	r3, [pc, #160]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014f46:	681b      	ldr	r3, [r3, #0]
 8014f48:	f893 3766 	ldrb.w	r3, [r3, #1894]	; 0x766
 8014f4c:	2b00      	cmp	r3, #0
 8014f4e:	d159      	bne.n	8015004 <hci_run_general_gap_le+0x5c4>
 8014f50:	4b25      	ldr	r3, [pc, #148]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014f52:	681b      	ldr	r3, [r3, #0]
 8014f54:	f893 3767 	ldrb.w	r3, [r3, #1895]	; 0x767
 8014f58:	2b03      	cmp	r3, #3
 8014f5a:	d153      	bne.n	8015004 <hci_run_general_gap_le+0x5c4>
        bd_addr_t null_addr;
        memset(null_addr, 0, 6);
 8014f5c:	1d3b      	adds	r3, r7, #4
 8014f5e:	2206      	movs	r2, #6
 8014f60:	2100      	movs	r1, #0
 8014f62:	4618      	mov	r0, r3
 8014f64:	f012 fdad 	bl	8027ac2 <memset>
        hci_send_cmd(&hci_le_create_connection,
                     hci_stack->le_connection_scan_interval,    // scan interval: 60 ms
 8014f68:	4b1f      	ldr	r3, [pc, #124]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014f6a:	681b      	ldr	r3, [r3, #0]
 8014f6c:	f8b3 377c 	ldrh.w	r3, [r3, #1916]	; 0x77c
        hci_send_cmd(&hci_le_create_connection,
 8014f70:	469c      	mov	ip, r3
                     hci_stack->le_connection_scan_window,    // scan interval: 30 ms
 8014f72:	4b1d      	ldr	r3, [pc, #116]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014f74:	681b      	ldr	r3, [r3, #0]
 8014f76:	f8b3 377e 	ldrh.w	r3, [r3, #1918]	; 0x77e
        hci_send_cmd(&hci_le_create_connection,
 8014f7a:	469e      	mov	lr, r3
                     1,         // use whitelist
                     0,         // peer address type
                     null_addr, // peer bd addr
                     hci_stack->le_own_addr_type, // our addr type:
 8014f7c:	4b1a      	ldr	r3, [pc, #104]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014f7e:	681b      	ldr	r3, [r3, #0]
 8014f80:	f893 3754 	ldrb.w	r3, [r3, #1876]	; 0x754
        hci_send_cmd(&hci_le_create_connection,
 8014f84:	461a      	mov	r2, r3
                     hci_stack->le_connection_interval_min,    // conn interval min
 8014f86:	4b18      	ldr	r3, [pc, #96]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014f88:	681b      	ldr	r3, [r3, #0]
 8014f8a:	f8b3 3770 	ldrh.w	r3, [r3, #1904]	; 0x770
        hci_send_cmd(&hci_le_create_connection,
 8014f8e:	4619      	mov	r1, r3
                     hci_stack->le_connection_interval_max,    // conn interval max
 8014f90:	4b15      	ldr	r3, [pc, #84]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014f92:	681b      	ldr	r3, [r3, #0]
 8014f94:	f8b3 3772 	ldrh.w	r3, [r3, #1906]	; 0x772
        hci_send_cmd(&hci_le_create_connection,
 8014f98:	4618      	mov	r0, r3
                     hci_stack->le_connection_latency,         // conn latency
 8014f9a:	4b13      	ldr	r3, [pc, #76]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014f9c:	681b      	ldr	r3, [r3, #0]
 8014f9e:	f8b3 3774 	ldrh.w	r3, [r3, #1908]	; 0x774
        hci_send_cmd(&hci_le_create_connection,
 8014fa2:	461c      	mov	r4, r3
                     hci_stack->le_supervision_timeout,        // conn latency
 8014fa4:	4b10      	ldr	r3, [pc, #64]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014fa6:	681b      	ldr	r3, [r3, #0]
 8014fa8:	f8b3 3776 	ldrh.w	r3, [r3, #1910]	; 0x776
        hci_send_cmd(&hci_le_create_connection,
 8014fac:	461d      	mov	r5, r3
                     hci_stack->le_minimum_ce_length,          // min ce length
 8014fae:	4b0e      	ldr	r3, [pc, #56]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014fb0:	681b      	ldr	r3, [r3, #0]
 8014fb2:	f8b3 3778 	ldrh.w	r3, [r3, #1912]	; 0x778
        hci_send_cmd(&hci_le_create_connection,
 8014fb6:	461e      	mov	r6, r3
                     hci_stack->le_maximum_ce_length           // max ce length
 8014fb8:	4b0b      	ldr	r3, [pc, #44]	; (8014fe8 <hci_run_general_gap_le+0x5a8>)
 8014fba:	681b      	ldr	r3, [r3, #0]
 8014fbc:	f8b3 377a 	ldrh.w	r3, [r3, #1914]	; 0x77a
        hci_send_cmd(&hci_le_create_connection,
 8014fc0:	9308      	str	r3, [sp, #32]
 8014fc2:	9607      	str	r6, [sp, #28]
 8014fc4:	9506      	str	r5, [sp, #24]
 8014fc6:	9405      	str	r4, [sp, #20]
 8014fc8:	9004      	str	r0, [sp, #16]
 8014fca:	9103      	str	r1, [sp, #12]
 8014fcc:	9202      	str	r2, [sp, #8]
 8014fce:	1d3b      	adds	r3, r7, #4
 8014fd0:	9301      	str	r3, [sp, #4]
 8014fd2:	2300      	movs	r3, #0
 8014fd4:	9300      	str	r3, [sp, #0]
 8014fd6:	2301      	movs	r3, #1
 8014fd8:	4672      	mov	r2, lr
 8014fda:	4661      	mov	r1, ip
 8014fdc:	4808      	ldr	r0, [pc, #32]	; (8015000 <hci_run_general_gap_le+0x5c0>)
 8014fde:	f000 ffff 	bl	8015fe0 <hci_send_cmd>
        );
        return true;
 8014fe2:	2301      	movs	r3, #1
 8014fe4:	e029      	b.n	801503a <hci_run_general_gap_le+0x5fa>
 8014fe6:	bf00      	nop
 8014fe8:	20009780 	.word	0x20009780
 8014fec:	08030b98 	.word	0x08030b98
 8014ff0:	08030ba0 	.word	0x08030ba0
 8014ff4:	08030be0 	.word	0x08030be0
 8014ff8:	08030bd8 	.word	0x08030bd8
 8014ffc:	08030bb8 	.word	0x08030bb8
 8015000:	08030bc0 	.word	0x08030bc0
    }
#endif

#ifdef ENABLE_LE_PERIPHERAL
    // re-start advertising
    if (hci_stack->le_advertisements_enabled_for_current_roles && !hci_stack->le_advertisements_active){
 8015004:	4b0f      	ldr	r3, [pc, #60]	; (8015044 <hci_run_general_gap_le+0x604>)
 8015006:	681b      	ldr	r3, [r3, #0]
 8015008:	f893 379b 	ldrb.w	r3, [r3, #1947]	; 0x79b
 801500c:	2b00      	cmp	r3, #0
 801500e:	d013      	beq.n	8015038 <hci_run_general_gap_le+0x5f8>
 8015010:	4b0c      	ldr	r3, [pc, #48]	; (8015044 <hci_run_general_gap_le+0x604>)
 8015012:	681b      	ldr	r3, [r3, #0]
 8015014:	f893 3799 	ldrb.w	r3, [r3, #1945]	; 0x799
 8015018:	f083 0301 	eor.w	r3, r3, #1
 801501c:	b2db      	uxtb	r3, r3
 801501e:	2b00      	cmp	r3, #0
 8015020:	d00a      	beq.n	8015038 <hci_run_general_gap_le+0x5f8>
        // check if advertisements should be enabled given
        hci_stack->le_advertisements_active = true;
 8015022:	4b08      	ldr	r3, [pc, #32]	; (8015044 <hci_run_general_gap_le+0x604>)
 8015024:	681b      	ldr	r3, [r3, #0]
 8015026:	2201      	movs	r2, #1
 8015028:	f883 2799 	strb.w	r2, [r3, #1945]	; 0x799
        hci_send_cmd(&hci_le_set_advertise_enable, 1);
 801502c:	2101      	movs	r1, #1
 801502e:	4806      	ldr	r0, [pc, #24]	; (8015048 <hci_run_general_gap_le+0x608>)
 8015030:	f000 ffd6 	bl	8015fe0 <hci_send_cmd>
        return true;
 8015034:	2301      	movs	r3, #1
 8015036:	e000      	b.n	801503a <hci_run_general_gap_le+0x5fa>
    }
#endif

    return false;
 8015038:	2300      	movs	r3, #0
}
 801503a:	4618      	mov	r0, r3
 801503c:	376c      	adds	r7, #108	; 0x6c
 801503e:	46bd      	mov	sp, r7
 8015040:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015042:	bf00      	nop
 8015044:	20009780 	.word	0x20009780
 8015048:	08030ba8 	.word	0x08030ba8

0801504c <hci_run_general_pending_commands>:
#endif

static bool hci_run_general_pending_commands(void){
 801504c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801504e:	b099      	sub	sp, #100	; 0x64
 8015050:	af0a      	add	r7, sp, #40	; 0x28
    btstack_linked_item_t * it;
    for (it = (btstack_linked_item_t *) hci_stack->connections; it != NULL; it = it->next){
 8015052:	4ba7      	ldr	r3, [pc, #668]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 8015054:	681b      	ldr	r3, [r3, #0]
 8015056:	695b      	ldr	r3, [r3, #20]
 8015058:	637b      	str	r3, [r7, #52]	; 0x34
 801505a:	f000 bc04 	b.w	8015866 <hci_run_general_pending_commands+0x81a>
        hci_connection_t * connection = (hci_connection_t *) it;
 801505e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015060:	62fb      	str	r3, [r7, #44]	; 0x2c

        switch(connection->state){
 8015062:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015064:	7b9b      	ldrb	r3, [r3, #14]
 8015066:	2b08      	cmp	r3, #8
 8015068:	f200 80b6 	bhi.w	80151d8 <hci_run_general_pending_commands+0x18c>
 801506c:	a201      	add	r2, pc, #4	; (adr r2, 8015074 <hci_run_general_pending_commands+0x28>)
 801506e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8015072:	bf00      	nop
 8015074:	08015099 	.word	0x08015099
 8015078:	080151d9 	.word	0x080151d9
 801507c:	080151b1 	.word	0x080151b1
 8015080:	080151d9 	.word	0x080151d9
 8015084:	08015177 	.word	0x08015177
 8015088:	080151d9 	.word	0x080151d9
 801508c:	080151d9 	.word	0x080151d9
 8015090:	080151d9 	.word	0x080151d9
 8015094:	080151c1 	.word	0x080151c1
            case SEND_CREATE_CONNECTION:
                switch(connection->address_type){
 8015098:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801509a:	7b1b      	ldrb	r3, [r3, #12]
 801509c:	2bfd      	cmp	r3, #253	; 0xfd
 801509e:	d11b      	bne.n	80150d8 <hci_run_general_pending_commands+0x8c>
#ifdef ENABLE_CLASSIC
                    case BD_ADDR_TYPE_ACL:
                        log_info("sending hci_create_connection");
 80150a0:	f241 0311 	movw	r3, #4113	; 0x1011
 80150a4:	4a93      	ldr	r2, [pc, #588]	; (80152f4 <hci_run_general_pending_commands+0x2a8>)
 80150a6:	4994      	ldr	r1, [pc, #592]	; (80152f8 <hci_run_general_pending_commands+0x2ac>)
 80150a8:	2001      	movs	r0, #1
 80150aa:	f002 f9c9 	bl	8017440 <hci_dump_log>
                        hci_send_cmd(&hci_create_connection, connection->address, hci_usable_acl_packet_types(), 0, 0, 0, hci_stack->allow_role_switch);
 80150ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80150b0:	1d1c      	adds	r4, r3, #4
 80150b2:	f7fb fb61 	bl	8010778 <hci_usable_acl_packet_types>
 80150b6:	4603      	mov	r3, r0
 80150b8:	461a      	mov	r2, r3
 80150ba:	4b8d      	ldr	r3, [pc, #564]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 80150bc:	681b      	ldr	r3, [r3, #0]
 80150be:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
 80150c2:	9302      	str	r3, [sp, #8]
 80150c4:	2300      	movs	r3, #0
 80150c6:	9301      	str	r3, [sp, #4]
 80150c8:	2300      	movs	r3, #0
 80150ca:	9300      	str	r3, [sp, #0]
 80150cc:	2300      	movs	r3, #0
 80150ce:	4621      	mov	r1, r4
 80150d0:	488a      	ldr	r0, [pc, #552]	; (80152fc <hci_run_general_pending_commands+0x2b0>)
 80150d2:	f000 ff85 	bl	8015fe0 <hci_send_cmd>
                        break;
 80150d6:	e04c      	b.n	8015172 <hci_run_general_pending_commands+0x126>
#endif
                    default:
#ifdef ENABLE_BLE
#ifdef ENABLE_LE_CENTRAL
                        log_info("sending hci_le_create_connection");
 80150d8:	f241 0318 	movw	r3, #4120	; 0x1018
 80150dc:	4a85      	ldr	r2, [pc, #532]	; (80152f4 <hci_run_general_pending_commands+0x2a8>)
 80150de:	4988      	ldr	r1, [pc, #544]	; (8015300 <hci_run_general_pending_commands+0x2b4>)
 80150e0:	2001      	movs	r0, #1
 80150e2:	f002 f9ad 	bl	8017440 <hci_dump_log>
                        hci_send_cmd(&hci_le_create_connection,
                                     hci_stack->le_connection_scan_interval,    // conn scan interval
 80150e6:	4b82      	ldr	r3, [pc, #520]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 80150e8:	681b      	ldr	r3, [r3, #0]
 80150ea:	f8b3 377c 	ldrh.w	r3, [r3, #1916]	; 0x77c
                        hci_send_cmd(&hci_le_create_connection,
 80150ee:	469c      	mov	ip, r3
                                     hci_stack->le_connection_scan_window,      // conn scan windows
 80150f0:	4b7f      	ldr	r3, [pc, #508]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 80150f2:	681b      	ldr	r3, [r3, #0]
 80150f4:	f8b3 377e 	ldrh.w	r3, [r3, #1918]	; 0x77e
                        hci_send_cmd(&hci_le_create_connection,
 80150f8:	469e      	mov	lr, r3
                                     0,         // don't use whitelist
                                     connection->address_type, // peer address type
 80150fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80150fc:	7b1b      	ldrb	r3, [r3, #12]
                        hci_send_cmd(&hci_le_create_connection,
 80150fe:	4619      	mov	r1, r3
                                     connection->address,      // peer bd addr
 8015100:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015102:	3304      	adds	r3, #4
                                     hci_stack->le_own_addr_type, // our addr type:
 8015104:	4a7a      	ldr	r2, [pc, #488]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 8015106:	6812      	ldr	r2, [r2, #0]
 8015108:	f892 2754 	ldrb.w	r2, [r2, #1876]	; 0x754
                        hci_send_cmd(&hci_le_create_connection,
 801510c:	4610      	mov	r0, r2
                                     hci_stack->le_connection_interval_min,    // conn interval min
 801510e:	4a78      	ldr	r2, [pc, #480]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 8015110:	6812      	ldr	r2, [r2, #0]
 8015112:	f8b2 2770 	ldrh.w	r2, [r2, #1904]	; 0x770
                        hci_send_cmd(&hci_le_create_connection,
 8015116:	4614      	mov	r4, r2
                                     hci_stack->le_connection_interval_max,    // conn interval max
 8015118:	4a75      	ldr	r2, [pc, #468]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 801511a:	6812      	ldr	r2, [r2, #0]
 801511c:	f8b2 2772 	ldrh.w	r2, [r2, #1906]	; 0x772
                        hci_send_cmd(&hci_le_create_connection,
 8015120:	4615      	mov	r5, r2
                                     hci_stack->le_connection_latency,         // conn latency
 8015122:	4a73      	ldr	r2, [pc, #460]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 8015124:	6812      	ldr	r2, [r2, #0]
 8015126:	f8b2 2774 	ldrh.w	r2, [r2, #1908]	; 0x774
                        hci_send_cmd(&hci_le_create_connection,
 801512a:	4616      	mov	r6, r2
                                     hci_stack->le_supervision_timeout,        // conn latency
 801512c:	4a70      	ldr	r2, [pc, #448]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 801512e:	6812      	ldr	r2, [r2, #0]
 8015130:	f8b2 2776 	ldrh.w	r2, [r2, #1910]	; 0x776
                        hci_send_cmd(&hci_le_create_connection,
 8015134:	607a      	str	r2, [r7, #4]
                                     hci_stack->le_minimum_ce_length,          // min ce length
 8015136:	4a6e      	ldr	r2, [pc, #440]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 8015138:	6812      	ldr	r2, [r2, #0]
 801513a:	f8b2 2778 	ldrh.w	r2, [r2, #1912]	; 0x778
                        hci_send_cmd(&hci_le_create_connection,
 801513e:	603a      	str	r2, [r7, #0]
                                     hci_stack->le_maximum_ce_length          // max ce length
 8015140:	4a6b      	ldr	r2, [pc, #428]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 8015142:	6812      	ldr	r2, [r2, #0]
 8015144:	f8b2 277a 	ldrh.w	r2, [r2, #1914]	; 0x77a
                        hci_send_cmd(&hci_le_create_connection,
 8015148:	9208      	str	r2, [sp, #32]
 801514a:	683a      	ldr	r2, [r7, #0]
 801514c:	9207      	str	r2, [sp, #28]
 801514e:	687a      	ldr	r2, [r7, #4]
 8015150:	9206      	str	r2, [sp, #24]
 8015152:	9605      	str	r6, [sp, #20]
 8015154:	9504      	str	r5, [sp, #16]
 8015156:	9403      	str	r4, [sp, #12]
 8015158:	9002      	str	r0, [sp, #8]
 801515a:	9301      	str	r3, [sp, #4]
 801515c:	9100      	str	r1, [sp, #0]
 801515e:	2300      	movs	r3, #0
 8015160:	4672      	mov	r2, lr
 8015162:	4661      	mov	r1, ip
 8015164:	4867      	ldr	r0, [pc, #412]	; (8015304 <hci_run_general_pending_commands+0x2b8>)
 8015166:	f000 ff3b 	bl	8015fe0 <hci_send_cmd>
                        );
                        connection->state = SENT_CREATE_CONNECTION;
 801516a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801516c:	2201      	movs	r2, #1
 801516e:	739a      	strb	r2, [r3, #14]
#endif
#endif
                        break;
 8015170:	bf00      	nop
                }
                return true;
 8015172:	2301      	movs	r3, #1
 8015174:	e37c      	b.n	8015870 <hci_run_general_pending_commands+0x824>

#ifdef ENABLE_CLASSIC
            case RECEIVED_CONNECTION_REQUEST:
                connection->role  = HCI_ROLE_SLAVE;
 8015176:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015178:	2201      	movs	r2, #1
 801517a:	735a      	strb	r2, [r3, #13]
                if (connection->address_type == BD_ADDR_TYPE_ACL){
 801517c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801517e:	7b1b      	ldrb	r3, [r3, #12]
 8015180:	2bfd      	cmp	r3, #253	; 0xfd
 8015182:	d113      	bne.n	80151ac <hci_run_general_pending_commands+0x160>
                    log_info("sending hci_accept_connection_request");
 8015184:	f241 0332 	movw	r3, #4146	; 0x1032
 8015188:	4a5a      	ldr	r2, [pc, #360]	; (80152f4 <hci_run_general_pending_commands+0x2a8>)
 801518a:	495f      	ldr	r1, [pc, #380]	; (8015308 <hci_run_general_pending_commands+0x2bc>)
 801518c:	2001      	movs	r0, #1
 801518e:	f002 f957 	bl	8017440 <hci_dump_log>
                    connection->state = ACCEPTED_CONNECTION_REQUEST;
 8015192:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015194:	2205      	movs	r2, #5
 8015196:	739a      	strb	r2, [r3, #14]
                    hci_send_cmd(&hci_accept_connection_request, connection->address, hci_stack->master_slave_policy);
 8015198:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801519a:	1d19      	adds	r1, r3, #4
 801519c:	4b54      	ldr	r3, [pc, #336]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 801519e:	681b      	ldr	r3, [r3, #0]
 80151a0:	f893 37b9 	ldrb.w	r3, [r3, #1977]	; 0x7b9
 80151a4:	461a      	mov	r2, r3
 80151a6:	4859      	ldr	r0, [pc, #356]	; (801530c <hci_run_general_pending_commands+0x2c0>)
 80151a8:	f000 ff1a 	bl	8015fe0 <hci_send_cmd>
                }
                return true;
 80151ac:	2301      	movs	r3, #1
 80151ae:	e35f      	b.n	8015870 <hci_run_general_pending_commands+0x824>
#endif

#ifdef ENABLE_BLE
#ifdef ENABLE_LE_CENTRAL
            case SEND_CANCEL_CONNECTION:
                connection->state = SENT_CANCEL_CONNECTION;
 80151b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80151b2:	2203      	movs	r2, #3
 80151b4:	739a      	strb	r2, [r3, #14]
                hci_send_cmd(&hci_le_create_connection_cancel);
 80151b6:	4856      	ldr	r0, [pc, #344]	; (8015310 <hci_run_general_pending_commands+0x2c4>)
 80151b8:	f000 ff12 	bl	8015fe0 <hci_send_cmd>
                return true;
 80151bc:	2301      	movs	r3, #1
 80151be:	e357      	b.n	8015870 <hci_run_general_pending_commands+0x824>
#endif
#endif
            case SEND_DISCONNECT:
                connection->state = SENT_DISCONNECT;
 80151c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80151c2:	2209      	movs	r2, #9
 80151c4:	739a      	strb	r2, [r3, #14]
                hci_send_cmd(&hci_disconnect, connection->con_handle, ERROR_CODE_REMOTE_USER_TERMINATED_CONNECTION);
 80151c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80151c8:	895b      	ldrh	r3, [r3, #10]
 80151ca:	2213      	movs	r2, #19
 80151cc:	4619      	mov	r1, r3
 80151ce:	4851      	ldr	r0, [pc, #324]	; (8015314 <hci_run_general_pending_commands+0x2c8>)
 80151d0:	f000 ff06 	bl	8015fe0 <hci_send_cmd>
                return true;
 80151d4:	2301      	movs	r3, #1
 80151d6:	e34b      	b.n	8015870 <hci_run_general_pending_commands+0x824>

            default:
                break;
 80151d8:	bf00      	nop
        }

        // no further commands if connection is about to get shut down
        if (connection->state == SENT_DISCONNECT) continue;
 80151da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80151dc:	7b9b      	ldrb	r3, [r3, #14]
 80151de:	2b09      	cmp	r3, #9
 80151e0:	f000 833d 	beq.w	801585e <hci_run_general_pending_commands+0x812>

        if (connection->authentication_flags & READ_RSSI){
 80151e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80151e6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80151e8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80151ec:	2b00      	cmp	r3, #0
 80151ee:	d00c      	beq.n	801520a <hci_run_general_pending_commands+0x1be>
            connectionClearAuthenticationFlags(connection, READ_RSSI);
 80151f0:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 80151f4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80151f6:	f7fa fbcb 	bl	800f990 <connectionClearAuthenticationFlags>
            hci_send_cmd(&hci_read_rssi, connection->con_handle);
 80151fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80151fc:	895b      	ldrh	r3, [r3, #10]
 80151fe:	4619      	mov	r1, r3
 8015200:	4845      	ldr	r0, [pc, #276]	; (8015318 <hci_run_general_pending_commands+0x2cc>)
 8015202:	f000 feed 	bl	8015fe0 <hci_send_cmd>
            return true;
 8015206:	2301      	movs	r3, #1
 8015208:	e332      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }

#ifdef ENABLE_CLASSIC

        if (connection->authentication_flags & WRITE_SUPERVISION_TIMEOUT){
 801520a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801520c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801520e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8015212:	2b00      	cmp	r3, #0
 8015214:	d011      	beq.n	801523a <hci_run_general_pending_commands+0x1ee>
            connectionClearAuthenticationFlags(connection, WRITE_SUPERVISION_TIMEOUT);
 8015216:	f44f 2180 	mov.w	r1, #262144	; 0x40000
 801521a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801521c:	f7fa fbb8 	bl	800f990 <connectionClearAuthenticationFlags>
            hci_send_cmd(&hci_write_link_supervision_timeout, connection->con_handle, hci_stack->link_supervision_timeout);
 8015220:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015222:	895b      	ldrh	r3, [r3, #10]
 8015224:	4619      	mov	r1, r3
 8015226:	4b32      	ldr	r3, [pc, #200]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 8015228:	681b      	ldr	r3, [r3, #0]
 801522a:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 801522e:	461a      	mov	r2, r3
 8015230:	483a      	ldr	r0, [pc, #232]	; (801531c <hci_run_general_pending_commands+0x2d0>)
 8015232:	f000 fed5 	bl	8015fe0 <hci_send_cmd>
            return true;
 8015236:	2301      	movs	r3, #1
 8015238:	e31a      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }

        if (connection->authentication_flags & HANDLE_LINK_KEY_REQUEST){
 801523a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801523c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801523e:	f003 0302 	and.w	r3, r3, #2
 8015242:	2b00      	cmp	r3, #0
 8015244:	f000 80c3 	beq.w	80153ce <hci_run_general_pending_commands+0x382>
            log_info("responding to link key request, have link key db: %u", hci_stack->link_key_db != NULL);
 8015248:	4b29      	ldr	r3, [pc, #164]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 801524a:	681b      	ldr	r3, [r3, #0]
 801524c:	691b      	ldr	r3, [r3, #16]
 801524e:	2b00      	cmp	r3, #0
 8015250:	bf14      	ite	ne
 8015252:	2301      	movne	r3, #1
 8015254:	2300      	moveq	r3, #0
 8015256:	b2db      	uxtb	r3, r3
 8015258:	9300      	str	r3, [sp, #0]
 801525a:	f241 035c 	movw	r3, #4188	; 0x105c
 801525e:	4a25      	ldr	r2, [pc, #148]	; (80152f4 <hci_run_general_pending_commands+0x2a8>)
 8015260:	492f      	ldr	r1, [pc, #188]	; (8015320 <hci_run_general_pending_commands+0x2d4>)
 8015262:	2001      	movs	r0, #1
 8015264:	f002 f8ec 	bl	8017440 <hci_dump_log>
            connectionClearAuthenticationFlags(connection, HANDLE_LINK_KEY_REQUEST);
 8015268:	2102      	movs	r1, #2
 801526a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801526c:	f7fa fb90 	bl	800f990 <connectionClearAuthenticationFlags>

            link_key_t link_key;
            link_key_type_t link_key_type;
            bool have_link_key = hci_stack->link_key_db && hci_stack->link_key_db->get_link_key(connection->address, link_key, &link_key_type);
 8015270:	4b1f      	ldr	r3, [pc, #124]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 8015272:	681b      	ldr	r3, [r3, #0]
 8015274:	691b      	ldr	r3, [r3, #16]
 8015276:	2b00      	cmp	r3, #0
 8015278:	d00f      	beq.n	801529a <hci_run_general_pending_commands+0x24e>
 801527a:	4b1d      	ldr	r3, [pc, #116]	; (80152f0 <hci_run_general_pending_commands+0x2a4>)
 801527c:	681b      	ldr	r3, [r3, #0]
 801527e:	691b      	ldr	r3, [r3, #16]
 8015280:	68db      	ldr	r3, [r3, #12]
 8015282:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8015284:	1d10      	adds	r0, r2, #4
 8015286:	f107 020f 	add.w	r2, r7, #15
 801528a:	f107 0110 	add.w	r1, r7, #16
 801528e:	4798      	blx	r3
 8015290:	4603      	mov	r3, r0
 8015292:	2b00      	cmp	r3, #0
 8015294:	d001      	beq.n	801529a <hci_run_general_pending_commands+0x24e>
 8015296:	2301      	movs	r3, #1
 8015298:	e000      	b.n	801529c <hci_run_general_pending_commands+0x250>
 801529a:	2300      	movs	r3, #0
 801529c:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 80152a0:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 80152a4:	f003 0301 	and.w	r3, r3, #1
 80152a8:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26

            const uint16_t sc_enabled_mask = BONDING_REMOTE_SUPPORTS_SC_HOST | BONDING_REMOTE_SUPPORTS_SC_CONTROLLER;
 80152ac:	23c0      	movs	r3, #192	; 0xc0
 80152ae:	84bb      	strh	r3, [r7, #36]	; 0x24
            bool sc_enabled_remote = (connection->bonding_flags & sc_enabled_mask) == sc_enabled_mask;
 80152b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80152b2:	8a1a      	ldrh	r2, [r3, #16]
 80152b4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80152b6:	4013      	ands	r3, r2
 80152b8:	b29b      	uxth	r3, r3
 80152ba:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 80152bc:	429a      	cmp	r2, r3
 80152be:	bf0c      	ite	eq
 80152c0:	2301      	moveq	r3, #1
 80152c2:	2300      	movne	r3, #0
 80152c4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            bool sc_downgrade = have_link_key && (gap_secure_connection_for_link_key_type(link_key_type) == 1) && !sc_enabled_remote;
 80152c8:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 80152cc:	2b00      	cmp	r3, #0
 80152ce:	d029      	beq.n	8015324 <hci_run_general_pending_commands+0x2d8>
 80152d0:	7bfb      	ldrb	r3, [r7, #15]
 80152d2:	4618      	mov	r0, r3
 80152d4:	f001 fa4a 	bl	801676c <gap_secure_connection_for_link_key_type>
 80152d8:	4603      	mov	r3, r0
 80152da:	2b01      	cmp	r3, #1
 80152dc:	d122      	bne.n	8015324 <hci_run_general_pending_commands+0x2d8>
 80152de:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80152e2:	f083 0301 	eor.w	r3, r3, #1
 80152e6:	b2db      	uxtb	r3, r3
 80152e8:	2b00      	cmp	r3, #0
 80152ea:	d01b      	beq.n	8015324 <hci_run_general_pending_commands+0x2d8>
 80152ec:	2301      	movs	r3, #1
 80152ee:	e01a      	b.n	8015326 <hci_run_general_pending_commands+0x2da>
 80152f0:	20009780 	.word	0x20009780
 80152f4:	0802929c 	.word	0x0802929c
 80152f8:	0802a664 	.word	0x0802a664
 80152fc:	08030a08 	.word	0x08030a08
 8015300:	0802a68c 	.word	0x0802a68c
 8015304:	08030bc0 	.word	0x08030bc0
 8015308:	0802a6b4 	.word	0x0802a6b4
 801530c:	08030a20 	.word	0x08030a20
 8015310:	08030bc8 	.word	0x08030bc8
 8015314:	08030a10 	.word	0x08030a10
 8015318:	08030b68 	.word	0x08030b68
 801531c:	08030b08 	.word	0x08030b08
 8015320:	0802a6e4 	.word	0x0802a6e4
 8015324:	2300      	movs	r3, #0
 8015326:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 801532a:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 801532e:	f003 0301 	and.w	r3, r3, #1
 8015332:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
            if (sc_downgrade){
 8015336:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 801533a:	2b00      	cmp	r3, #0
 801533c:	d012      	beq.n	8015364 <hci_run_general_pending_commands+0x318>
                log_info("Link key based on SC, but remote does not support SC -> disconnect");
 801533e:	f241 0367 	movw	r3, #4199	; 0x1067
 8015342:	4aab      	ldr	r2, [pc, #684]	; (80155f0 <hci_run_general_pending_commands+0x5a4>)
 8015344:	49ab      	ldr	r1, [pc, #684]	; (80155f4 <hci_run_general_pending_commands+0x5a8>)
 8015346:	2001      	movs	r0, #1
 8015348:	f002 f87a 	bl	8017440 <hci_dump_log>
                connection->state = SENT_DISCONNECT;
 801534c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801534e:	2209      	movs	r2, #9
 8015350:	739a      	strb	r2, [r3, #14]
                hci_send_cmd(&hci_disconnect, connection->con_handle, ERROR_CODE_AUTHENTICATION_FAILURE);
 8015352:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015354:	895b      	ldrh	r3, [r3, #10]
 8015356:	2205      	movs	r2, #5
 8015358:	4619      	mov	r1, r3
 801535a:	48a7      	ldr	r0, [pc, #668]	; (80155f8 <hci_run_general_pending_commands+0x5ac>)
 801535c:	f000 fe40 	bl	8015fe0 <hci_send_cmd>
                return true;
 8015360:	2301      	movs	r3, #1
 8015362:	e285      	b.n	8015870 <hci_run_general_pending_commands+0x824>
            }

            bool security_level_sufficient = have_link_key && (gap_security_level_for_link_key_type(link_key_type) >= connection->requested_security_level);
 8015364:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8015368:	2b00      	cmp	r3, #0
 801536a:	d00b      	beq.n	8015384 <hci_run_general_pending_commands+0x338>
 801536c:	7bfb      	ldrb	r3, [r7, #15]
 801536e:	4618      	mov	r0, r3
 8015370:	f001 f9e4 	bl	801673c <gap_security_level_for_link_key_type>
 8015374:	4603      	mov	r3, r0
 8015376:	461a      	mov	r2, r3
 8015378:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801537a:	7d1b      	ldrb	r3, [r3, #20]
 801537c:	429a      	cmp	r2, r3
 801537e:	d301      	bcc.n	8015384 <hci_run_general_pending_commands+0x338>
 8015380:	2301      	movs	r3, #1
 8015382:	e000      	b.n	8015386 <hci_run_general_pending_commands+0x33a>
 8015384:	2300      	movs	r3, #0
 8015386:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
 801538a:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 801538e:	f003 0301 	and.w	r3, r3, #1
 8015392:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
            if (have_link_key && security_level_sufficient){
 8015396:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 801539a:	2b00      	cmp	r3, #0
 801539c:	d00f      	beq.n	80153be <hci_run_general_pending_commands+0x372>
 801539e:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80153a2:	2b00      	cmp	r3, #0
 80153a4:	d00b      	beq.n	80153be <hci_run_general_pending_commands+0x372>
                connection->link_key_type = link_key_type;
 80153a6:	7bfa      	ldrb	r2, [r7, #15]
 80153a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80153aa:	755a      	strb	r2, [r3, #21]
                hci_send_cmd(&hci_link_key_request_reply, connection->address, &link_key);
 80153ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80153ae:	3304      	adds	r3, #4
 80153b0:	f107 0210 	add.w	r2, r7, #16
 80153b4:	4619      	mov	r1, r3
 80153b6:	4891      	ldr	r0, [pc, #580]	; (80155fc <hci_run_general_pending_commands+0x5b0>)
 80153b8:	f000 fe12 	bl	8015fe0 <hci_send_cmd>
 80153bc:	e005      	b.n	80153ca <hci_run_general_pending_commands+0x37e>
            } else {
                hci_send_cmd(&hci_link_key_request_negative_reply, connection->address);
 80153be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80153c0:	3304      	adds	r3, #4
 80153c2:	4619      	mov	r1, r3
 80153c4:	488e      	ldr	r0, [pc, #568]	; (8015600 <hci_run_general_pending_commands+0x5b4>)
 80153c6:	f000 fe0b 	bl	8015fe0 <hci_send_cmd>
            }
            return true;
 80153ca:	2301      	movs	r3, #1
 80153cc:	e250      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }

        if (connection->authentication_flags & DENY_PIN_CODE_REQUEST){
 80153ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80153d0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80153d2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80153d6:	2b00      	cmp	r3, #0
 80153d8:	d012      	beq.n	8015400 <hci_run_general_pending_commands+0x3b4>
            log_info("denying to pin request");
 80153da:	f241 0378 	movw	r3, #4216	; 0x1078
 80153de:	4a84      	ldr	r2, [pc, #528]	; (80155f0 <hci_run_general_pending_commands+0x5a4>)
 80153e0:	4988      	ldr	r1, [pc, #544]	; (8015604 <hci_run_general_pending_commands+0x5b8>)
 80153e2:	2001      	movs	r0, #1
 80153e4:	f002 f82c 	bl	8017440 <hci_dump_log>
            connectionClearAuthenticationFlags(connection, DENY_PIN_CODE_REQUEST);
 80153e8:	2140      	movs	r1, #64	; 0x40
 80153ea:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80153ec:	f7fa fad0 	bl	800f990 <connectionClearAuthenticationFlags>
            hci_send_cmd(&hci_pin_code_request_negative_reply, connection->address);
 80153f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80153f2:	3304      	adds	r3, #4
 80153f4:	4619      	mov	r1, r3
 80153f6:	4884      	ldr	r0, [pc, #528]	; (8015608 <hci_run_general_pending_commands+0x5bc>)
 80153f8:	f000 fdf2 	bl	8015fe0 <hci_send_cmd>
            return true;
 80153fc:	2301      	movs	r3, #1
 80153fe:	e237      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }

        if (connection->authentication_flags & SEND_IO_CAPABILITIES_REPLY){
 8015400:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015402:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8015404:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8015408:	2b00      	cmp	r3, #0
 801540a:	d037      	beq.n	801547c <hci_run_general_pending_commands+0x430>
            connectionClearAuthenticationFlags(connection, SEND_IO_CAPABILITIES_REPLY);
 801540c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8015410:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8015412:	f7fa fabd 	bl	800f990 <connectionClearAuthenticationFlags>
            // tweak authentication requirements
            uint8_t authreq = hci_stack->ssp_authentication_requirement;
 8015416:	4b7d      	ldr	r3, [pc, #500]	; (801560c <hci_run_general_pending_commands+0x5c0>)
 8015418:	681b      	ldr	r3, [r3, #0]
 801541a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 801541e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
            if (connection->bonding_flags & BONDING_DEDICATED){
 8015422:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015424:	8a1b      	ldrh	r3, [r3, #16]
 8015426:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801542a:	2b00      	cmp	r3, #0
 801542c:	d002      	beq.n	8015434 <hci_run_general_pending_commands+0x3e8>
                authreq = SSP_IO_AUTHREQ_MITM_PROTECTION_NOT_REQUIRED_DEDICATED_BONDING;
 801542e:	2302      	movs	r3, #2
 8015430:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
            }
            if (gap_mitm_protection_required_for_security_level(connection->requested_security_level)){
 8015434:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015436:	7d1b      	ldrb	r3, [r3, #20]
 8015438:	4618      	mov	r0, r3
 801543a:	f001 f9bd 	bl	80167b8 <gap_mitm_protection_required_for_security_level>
 801543e:	4603      	mov	r3, r0
 8015440:	2b00      	cmp	r3, #0
 8015442:	d005      	beq.n	8015450 <hci_run_general_pending_commands+0x404>
                authreq |= 1;
 8015444:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8015448:	f043 0301 	orr.w	r3, r3, #1
 801544c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
            }
            uint8_t have_oob_data = 0;
 8015450:	2300      	movs	r3, #0
 8015452:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
            }
            if (connection->classic_oob_c_256 != NULL){
                have_oob_data |= 2;
            }
#endif
            hci_send_cmd(&hci_io_capability_request_reply, &connection->address, hci_stack->ssp_io_capability, have_oob_data, authreq);
 8015456:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015458:	1d19      	adds	r1, r3, #4
 801545a:	4b6c      	ldr	r3, [pc, #432]	; (801560c <hci_run_general_pending_commands+0x5c0>)
 801545c:	681b      	ldr	r3, [r3, #0]
 801545e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8015462:	4618      	mov	r0, r3
 8015464:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8015468:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801546c:	9300      	str	r3, [sp, #0]
 801546e:	4613      	mov	r3, r2
 8015470:	4602      	mov	r2, r0
 8015472:	4867      	ldr	r0, [pc, #412]	; (8015610 <hci_run_general_pending_commands+0x5c4>)
 8015474:	f000 fdb4 	bl	8015fe0 <hci_send_cmd>
            return true;
 8015478:	2301      	movs	r3, #1
 801547a:	e1f9      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }

        if (connection->authentication_flags & SEND_IO_CAPABILITIES_NEGATIVE_REPLY) {
 801547c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801547e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8015480:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8015484:	2b00      	cmp	r3, #0
 8015486:	d00d      	beq.n	80154a4 <hci_run_general_pending_commands+0x458>
            connectionClearAuthenticationFlags(connection, SEND_IO_CAPABILITIES_NEGATIVE_REPLY);
 8015488:	f44f 7100 	mov.w	r1, #512	; 0x200
 801548c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801548e:	f7fa fa7f 	bl	800f990 <connectionClearAuthenticationFlags>
            hci_send_cmd(&hci_io_capability_request_negative_reply, &connection->address, ERROR_CODE_PAIRING_NOT_ALLOWED);
 8015492:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015494:	3304      	adds	r3, #4
 8015496:	2218      	movs	r2, #24
 8015498:	4619      	mov	r1, r3
 801549a:	485e      	ldr	r0, [pc, #376]	; (8015614 <hci_run_general_pending_commands+0x5c8>)
 801549c:	f000 fda0 	bl	8015fe0 <hci_send_cmd>
            return true;
 80154a0:	2301      	movs	r3, #1
 80154a2:	e1e5      	b.n	8015870 <hci_run_general_pending_commands+0x824>
            }
            return true;
        }
#endif

        if (connection->authentication_flags & SEND_USER_CONFIRM_REPLY){
 80154a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80154a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80154a8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80154ac:	2b00      	cmp	r3, #0
 80154ae:	d00c      	beq.n	80154ca <hci_run_general_pending_commands+0x47e>
            connectionClearAuthenticationFlags(connection, SEND_USER_CONFIRM_REPLY);
 80154b0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80154b4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80154b6:	f7fa fa6b 	bl	800f990 <connectionClearAuthenticationFlags>
            hci_send_cmd(&hci_user_confirmation_request_reply, &connection->address);
 80154ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80154bc:	3304      	adds	r3, #4
 80154be:	4619      	mov	r1, r3
 80154c0:	4855      	ldr	r0, [pc, #340]	; (8015618 <hci_run_general_pending_commands+0x5cc>)
 80154c2:	f000 fd8d 	bl	8015fe0 <hci_send_cmd>
            return true;
 80154c6:	2301      	movs	r3, #1
 80154c8:	e1d2      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }

        if (connection->authentication_flags & SEND_USER_PASSKEY_REPLY){
 80154ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80154cc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80154ce:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80154d2:	2b00      	cmp	r3, #0
 80154d4:	d00d      	beq.n	80154f2 <hci_run_general_pending_commands+0x4a6>
            connectionClearAuthenticationFlags(connection, SEND_USER_PASSKEY_REPLY);
 80154d6:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80154da:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80154dc:	f7fa fa58 	bl	800f990 <connectionClearAuthenticationFlags>
            hci_send_cmd(&hci_user_passkey_request_reply, &connection->address, 000000);
 80154e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80154e2:	3304      	adds	r3, #4
 80154e4:	2200      	movs	r2, #0
 80154e6:	4619      	mov	r1, r3
 80154e8:	484c      	ldr	r0, [pc, #304]	; (801561c <hci_run_general_pending_commands+0x5d0>)
 80154ea:	f000 fd79 	bl	8015fe0 <hci_send_cmd>
            return true;
 80154ee:	2301      	movs	r3, #1
 80154f0:	e1be      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }

        if (connection->bonding_flags & BONDING_REQUEST_REMOTE_FEATURES_PAGE_0){
 80154f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80154f4:	8a1b      	ldrh	r3, [r3, #16]
 80154f6:	f003 0301 	and.w	r3, r3, #1
 80154fa:	2b00      	cmp	r3, #0
 80154fc:	d00e      	beq.n	801551c <hci_run_general_pending_commands+0x4d0>
            connection->bonding_flags &= ~BONDING_REQUEST_REMOTE_FEATURES_PAGE_0;
 80154fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015500:	8a1b      	ldrh	r3, [r3, #16]
 8015502:	f023 0301 	bic.w	r3, r3, #1
 8015506:	b29a      	uxth	r2, r3
 8015508:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801550a:	821a      	strh	r2, [r3, #16]
            hci_send_cmd(&hci_read_remote_supported_features_command, connection->con_handle);
 801550c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801550e:	895b      	ldrh	r3, [r3, #10]
 8015510:	4619      	mov	r1, r3
 8015512:	4843      	ldr	r0, [pc, #268]	; (8015620 <hci_run_general_pending_commands+0x5d4>)
 8015514:	f000 fd64 	bl	8015fe0 <hci_send_cmd>
            return true;
 8015518:	2301      	movs	r3, #1
 801551a:	e1a9      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }

        if (connection->bonding_flags & BONDING_REQUEST_REMOTE_FEATURES_PAGE_1){
 801551c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801551e:	8a1b      	ldrh	r3, [r3, #16]
 8015520:	f003 0302 	and.w	r3, r3, #2
 8015524:	2b00      	cmp	r3, #0
 8015526:	d00f      	beq.n	8015548 <hci_run_general_pending_commands+0x4fc>
            connection->bonding_flags &= ~BONDING_REQUEST_REMOTE_FEATURES_PAGE_1;
 8015528:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801552a:	8a1b      	ldrh	r3, [r3, #16]
 801552c:	f023 0302 	bic.w	r3, r3, #2
 8015530:	b29a      	uxth	r2, r3
 8015532:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015534:	821a      	strh	r2, [r3, #16]
            hci_send_cmd(&hci_read_remote_extended_features_command, connection->con_handle, 1);
 8015536:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015538:	895b      	ldrh	r3, [r3, #10]
 801553a:	2201      	movs	r2, #1
 801553c:	4619      	mov	r1, r3
 801553e:	4839      	ldr	r0, [pc, #228]	; (8015624 <hci_run_general_pending_commands+0x5d8>)
 8015540:	f000 fd4e 	bl	8015fe0 <hci_send_cmd>
            return true;
 8015544:	2301      	movs	r3, #1
 8015546:	e193      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }

        if (connection->bonding_flags & BONDING_REQUEST_REMOTE_FEATURES_PAGE_2){
 8015548:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801554a:	8a1b      	ldrh	r3, [r3, #16]
 801554c:	f003 0304 	and.w	r3, r3, #4
 8015550:	2b00      	cmp	r3, #0
 8015552:	d00f      	beq.n	8015574 <hci_run_general_pending_commands+0x528>
            connection->bonding_flags &= ~BONDING_REQUEST_REMOTE_FEATURES_PAGE_2;
 8015554:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015556:	8a1b      	ldrh	r3, [r3, #16]
 8015558:	f023 0304 	bic.w	r3, r3, #4
 801555c:	b29a      	uxth	r2, r3
 801555e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015560:	821a      	strh	r2, [r3, #16]
            hci_send_cmd(&hci_read_remote_extended_features_command, connection->con_handle, 2);
 8015562:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015564:	895b      	ldrh	r3, [r3, #10]
 8015566:	2202      	movs	r2, #2
 8015568:	4619      	mov	r1, r3
 801556a:	482e      	ldr	r0, [pc, #184]	; (8015624 <hci_run_general_pending_commands+0x5d8>)
 801556c:	f000 fd38 	bl	8015fe0 <hci_send_cmd>
            return true;
 8015570:	2301      	movs	r3, #1
 8015572:	e17d      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }

        if (connection->bonding_flags & BONDING_DISCONNECT_DEDICATED_DONE){
 8015574:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015576:	8a1b      	ldrh	r3, [r3, #16]
 8015578:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801557c:	2b00      	cmp	r3, #0
 801557e:	d019      	beq.n	80155b4 <hci_run_general_pending_commands+0x568>
            connection->bonding_flags &= ~BONDING_DISCONNECT_DEDICATED_DONE;
 8015580:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015582:	8a1b      	ldrh	r3, [r3, #16]
 8015584:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8015588:	b29a      	uxth	r2, r3
 801558a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801558c:	821a      	strh	r2, [r3, #16]
            connection->bonding_flags |= BONDING_EMIT_COMPLETE_ON_DISCONNECT;
 801558e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015590:	8a1b      	ldrh	r3, [r3, #16]
 8015592:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8015596:	b29a      	uxth	r2, r3
 8015598:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801559a:	821a      	strh	r2, [r3, #16]
            connection->state = SENT_DISCONNECT;
 801559c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801559e:	2209      	movs	r2, #9
 80155a0:	739a      	strb	r2, [r3, #14]
            hci_send_cmd(&hci_disconnect, connection->con_handle, ERROR_CODE_REMOTE_USER_TERMINATED_CONNECTION);
 80155a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155a4:	895b      	ldrh	r3, [r3, #10]
 80155a6:	2213      	movs	r2, #19
 80155a8:	4619      	mov	r1, r3
 80155aa:	4813      	ldr	r0, [pc, #76]	; (80155f8 <hci_run_general_pending_commands+0x5ac>)
 80155ac:	f000 fd18 	bl	8015fe0 <hci_send_cmd>
            return true;
 80155b0:	2301      	movs	r3, #1
 80155b2:	e15d      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }

        if (connection->bonding_flags & BONDING_SEND_AUTHENTICATE_REQUEST){
 80155b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155b6:	8a1b      	ldrh	r3, [r3, #16]
 80155b8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80155bc:	2b00      	cmp	r3, #0
 80155be:	d035      	beq.n	801562c <hci_run_general_pending_commands+0x5e0>
            connection->bonding_flags &= ~BONDING_SEND_AUTHENTICATE_REQUEST;
 80155c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155c2:	8a1b      	ldrh	r3, [r3, #16]
 80155c4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80155c8:	b29a      	uxth	r2, r3
 80155ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155cc:	821a      	strh	r2, [r3, #16]
            connection->bonding_flags |= BONDING_SENT_AUTHENTICATE_REQUEST;
 80155ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155d0:	8a1b      	ldrh	r3, [r3, #16]
 80155d2:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80155d6:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80155da:	b29a      	uxth	r2, r3
 80155dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155de:	821a      	strh	r2, [r3, #16]
            hci_send_cmd(&hci_authentication_requested, connection->con_handle);
 80155e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155e2:	895b      	ldrh	r3, [r3, #10]
 80155e4:	4619      	mov	r1, r3
 80155e6:	4810      	ldr	r0, [pc, #64]	; (8015628 <hci_run_general_pending_commands+0x5dc>)
 80155e8:	f000 fcfa 	bl	8015fe0 <hci_send_cmd>
            return true;
 80155ec:	2301      	movs	r3, #1
 80155ee:	e13f      	b.n	8015870 <hci_run_general_pending_commands+0x824>
 80155f0:	0802929c 	.word	0x0802929c
 80155f4:	0802a720 	.word	0x0802a720
 80155f8:	08030a10 	.word	0x08030a10
 80155fc:	08030a30 	.word	0x08030a30
 8015600:	08030a38 	.word	0x08030a38
 8015604:	0802a76c 	.word	0x0802a76c
 8015608:	08030a48 	.word	0x08030a48
 801560c:	20009780 	.word	0x20009780
 8015610:	08030a78 	.word	0x08030a78
 8015614:	08030aa0 	.word	0x08030aa0
 8015618:	08030a80 	.word	0x08030a80
 801561c:	08030a90 	.word	0x08030a90
 8015620:	08030a68 	.word	0x08030a68
 8015624:	08030a70 	.word	0x08030a70
 8015628:	08030a50 	.word	0x08030a50
        }

        if (connection->bonding_flags & BONDING_SEND_ENCRYPTION_REQUEST){
 801562c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801562e:	8a1b      	ldrh	r3, [r3, #16]
 8015630:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8015634:	2b00      	cmp	r3, #0
 8015636:	d00f      	beq.n	8015658 <hci_run_general_pending_commands+0x60c>
            connection->bonding_flags &= ~BONDING_SEND_ENCRYPTION_REQUEST;
 8015638:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801563a:	8a1b      	ldrh	r3, [r3, #16]
 801563c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8015640:	b29a      	uxth	r2, r3
 8015642:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015644:	821a      	strh	r2, [r3, #16]
            hci_send_cmd(&hci_set_connection_encryption, connection->con_handle, 1);
 8015646:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015648:	895b      	ldrh	r3, [r3, #10]
 801564a:	2201      	movs	r2, #1
 801564c:	4619      	mov	r1, r3
 801564e:	488a      	ldr	r0, [pc, #552]	; (8015878 <hci_run_general_pending_commands+0x82c>)
 8015650:	f000 fcc6 	bl	8015fe0 <hci_send_cmd>
            return true;
 8015654:	2301      	movs	r3, #1
 8015656:	e10b      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }
        if (connection->bonding_flags & BONDING_SEND_READ_ENCRYPTION_KEY_SIZE){
 8015658:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801565a:	8a1b      	ldrh	r3, [r3, #16]
 801565c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8015660:	2b00      	cmp	r3, #0
 8015662:	d00f      	beq.n	8015684 <hci_run_general_pending_commands+0x638>
            connection->bonding_flags &= ~BONDING_SEND_READ_ENCRYPTION_KEY_SIZE;
 8015664:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015666:	8a1b      	ldrh	r3, [r3, #16]
 8015668:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 801566c:	b29a      	uxth	r2, r3
 801566e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015670:	821a      	strh	r2, [r3, #16]
            hci_send_cmd(&hci_read_encryption_key_size, connection->con_handle, 1);
 8015672:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015674:	895b      	ldrh	r3, [r3, #10]
 8015676:	2201      	movs	r2, #1
 8015678:	4619      	mov	r1, r3
 801567a:	4880      	ldr	r0, [pc, #512]	; (801587c <hci_run_general_pending_commands+0x830>)
 801567c:	f000 fcb0 	bl	8015fe0 <hci_send_cmd>
            return true;
 8015680:	2301      	movs	r3, #1
 8015682:	e0f5      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }
#endif

        if (connection->bonding_flags & BONDING_DISCONNECT_SECURITY_BLOCK){
 8015684:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015686:	8a1b      	ldrh	r3, [r3, #16]
 8015688:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801568c:	2b00      	cmp	r3, #0
 801568e:	d016      	beq.n	80156be <hci_run_general_pending_commands+0x672>
            connection->bonding_flags &= ~BONDING_DISCONNECT_SECURITY_BLOCK;
 8015690:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015692:	8a1b      	ldrh	r3, [r3, #16]
 8015694:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8015698:	b29a      	uxth	r2, r3
 801569a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801569c:	821a      	strh	r2, [r3, #16]
            if (connection->state != SENT_DISCONNECT){
 801569e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80156a0:	7b9b      	ldrb	r3, [r3, #14]
 80156a2:	2b09      	cmp	r3, #9
 80156a4:	d00b      	beq.n	80156be <hci_run_general_pending_commands+0x672>
                connection->state = SENT_DISCONNECT;
 80156a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80156a8:	2209      	movs	r2, #9
 80156aa:	739a      	strb	r2, [r3, #14]
                hci_send_cmd(&hci_disconnect, connection->con_handle, ERROR_CODE_AUTHENTICATION_FAILURE);
 80156ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80156ae:	895b      	ldrh	r3, [r3, #10]
 80156b0:	2205      	movs	r2, #5
 80156b2:	4619      	mov	r1, r3
 80156b4:	4872      	ldr	r0, [pc, #456]	; (8015880 <hci_run_general_pending_commands+0x834>)
 80156b6:	f000 fc93 	bl	8015fe0 <hci_send_cmd>
                return true;
 80156ba:	2301      	movs	r3, #1
 80156bc:	e0d8      	b.n	8015870 <hci_run_general_pending_commands+0x824>
            }
        }

#ifdef ENABLE_CLASSIC
        uint16_t sniff_min_interval;
        switch (connection->sniff_min_interval){
 80156be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80156c0:	8b1b      	ldrh	r3, [r3, #24]
 80156c2:	2b00      	cmp	r3, #0
 80156c4:	d02a      	beq.n	801571c <hci_run_general_pending_commands+0x6d0>
 80156c6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80156ca:	4293      	cmp	r3, r2
 80156cc:	d10a      	bne.n	80156e4 <hci_run_general_pending_commands+0x698>
            case 0:
                break;
            case 0xffff:
                connection->sniff_min_interval = 0;
 80156ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80156d0:	2200      	movs	r2, #0
 80156d2:	831a      	strh	r2, [r3, #24]
                hci_send_cmd(&hci_exit_sniff_mode, connection->con_handle);
 80156d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80156d6:	895b      	ldrh	r3, [r3, #10]
 80156d8:	4619      	mov	r1, r3
 80156da:	486a      	ldr	r0, [pc, #424]	; (8015884 <hci_run_general_pending_commands+0x838>)
 80156dc:	f000 fc80 	bl	8015fe0 <hci_send_cmd>
                return true;
 80156e0:	2301      	movs	r3, #1
 80156e2:	e0c5      	b.n	8015870 <hci_run_general_pending_commands+0x824>
            default:
                sniff_min_interval = connection->sniff_min_interval;
 80156e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80156e6:	8b1b      	ldrh	r3, [r3, #24]
 80156e8:	853b      	strh	r3, [r7, #40]	; 0x28
                connection->sniff_min_interval = 0;
 80156ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80156ec:	2200      	movs	r2, #0
 80156ee:	831a      	strh	r2, [r3, #24]
                hci_send_cmd(&hci_sniff_mode, connection->con_handle, connection->sniff_max_interval, sniff_min_interval, connection->sniff_attempt, connection->sniff_timeout);
 80156f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80156f2:	895b      	ldrh	r3, [r3, #10]
 80156f4:	4618      	mov	r0, r3
 80156f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80156f8:	8b5b      	ldrh	r3, [r3, #26]
 80156fa:	461c      	mov	r4, r3
 80156fc:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 80156fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015700:	8b9b      	ldrh	r3, [r3, #28]
 8015702:	4619      	mov	r1, r3
 8015704:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015706:	8bdb      	ldrh	r3, [r3, #30]
 8015708:	9301      	str	r3, [sp, #4]
 801570a:	9100      	str	r1, [sp, #0]
 801570c:	4613      	mov	r3, r2
 801570e:	4622      	mov	r2, r4
 8015710:	4601      	mov	r1, r0
 8015712:	485d      	ldr	r0, [pc, #372]	; (8015888 <hci_run_general_pending_commands+0x83c>)
 8015714:	f000 fc64 	bl	8015fe0 <hci_send_cmd>
                return true;
 8015718:	2301      	movs	r3, #1
 801571a:	e0a9      	b.n	8015870 <hci_run_general_pending_commands+0x824>
                break;
 801571c:	bf00      	nop
        }

        if (connection->request_role != HCI_ROLE_INVALID){
 801571e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015720:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8015724:	2bff      	cmp	r3, #255	; 0xff
 8015726:	d012      	beq.n	801574e <hci_run_general_pending_commands+0x702>
            hci_role_t  role = connection->request_role;
 8015728:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801572a:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 801572e:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
            connection->request_role = HCI_ROLE_INVALID;
 8015732:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015734:	22ff      	movs	r2, #255	; 0xff
 8015736:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
            hci_send_cmd(&hci_switch_role_command, connection->address, role);
 801573a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801573c:	3304      	adds	r3, #4
 801573e:	f897 202a 	ldrb.w	r2, [r7, #42]	; 0x2a
 8015742:	4619      	mov	r1, r3
 8015744:	4851      	ldr	r0, [pc, #324]	; (801588c <hci_run_general_pending_commands+0x840>)
 8015746:	f000 fc4b 	bl	8015fe0 <hci_send_cmd>
            return true;
 801574a:	2301      	movs	r3, #1
 801574c:	e090      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        }
#endif

#ifdef ENABLE_BLE
        switch (connection->le_con_parameter_update_state){
 801574e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015750:	f893 370b 	ldrb.w	r3, [r3, #1803]	; 0x70b
 8015754:	2b05      	cmp	r3, #5
 8015756:	d030      	beq.n	80157ba <hci_run_general_pending_commands+0x76e>
 8015758:	2b06      	cmp	r3, #6
 801575a:	d054      	beq.n	8015806 <hci_run_general_pending_commands+0x7ba>
 801575c:	2b03      	cmp	r3, #3
 801575e:	d006      	beq.n	801576e <hci_run_general_pending_commands+0x722>
            case CON_PARAMETER_UPDATE_NEGATIVE_REPLY:
                connection->le_con_parameter_update_state = CON_PARAMETER_UPDATE_NONE;
                hci_send_cmd(&hci_le_remote_connection_parameter_request_negative_reply, ERROR_CODE_UNSUPPORTED_LMP_PARAMETER_VALUE_UNSUPPORTED_LL_PARAMETER_VALUE);
                return true;
            default:
                break;
 8015760:	bf00      	nop
        }
        if (connection->le_phy_update_all_phys != 0xffu){
 8015762:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015764:	f893 3718 	ldrb.w	r3, [r3, #1816]	; 0x718
 8015768:	2bff      	cmp	r3, #255	; 0xff
 801576a:	d079      	beq.n	8015860 <hci_run_general_pending_commands+0x814>
 801576c:	e055      	b.n	801581a <hci_run_general_pending_commands+0x7ce>
                connection->le_con_parameter_update_state = CON_PARAMETER_UPDATE_NONE;
 801576e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015770:	2200      	movs	r2, #0
 8015772:	f883 270b 	strb.w	r2, [r3, #1803]	; 0x70b
                hci_send_cmd(&hci_le_connection_update, connection->con_handle, connection->le_conn_interval_min,
 8015776:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015778:	895b      	ldrh	r3, [r3, #10]
 801577a:	4618      	mov	r0, r3
 801577c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801577e:	f8b3 370e 	ldrh.w	r3, [r3, #1806]	; 0x70e
 8015782:	461c      	mov	r4, r3
                             connection->le_conn_interval_max, connection->le_conn_latency, connection->le_supervision_timeout,
 8015784:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015786:	f8b3 3710 	ldrh.w	r3, [r3, #1808]	; 0x710
                hci_send_cmd(&hci_le_connection_update, connection->con_handle, connection->le_conn_interval_min,
 801578a:	461d      	mov	r5, r3
                             connection->le_conn_interval_max, connection->le_conn_latency, connection->le_supervision_timeout,
 801578c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801578e:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
                hci_send_cmd(&hci_le_connection_update, connection->con_handle, connection->le_conn_interval_min,
 8015792:	461a      	mov	r2, r3
                             connection->le_conn_interval_max, connection->le_conn_latency, connection->le_supervision_timeout,
 8015794:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015796:	f8b3 3714 	ldrh.w	r3, [r3, #1812]	; 0x714
                hci_send_cmd(&hci_le_connection_update, connection->con_handle, connection->le_conn_interval_min,
 801579a:	4619      	mov	r1, r3
 801579c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80157a0:	9303      	str	r3, [sp, #12]
 80157a2:	2300      	movs	r3, #0
 80157a4:	9302      	str	r3, [sp, #8]
 80157a6:	9101      	str	r1, [sp, #4]
 80157a8:	9200      	str	r2, [sp, #0]
 80157aa:	462b      	mov	r3, r5
 80157ac:	4622      	mov	r2, r4
 80157ae:	4601      	mov	r1, r0
 80157b0:	4837      	ldr	r0, [pc, #220]	; (8015890 <hci_run_general_pending_commands+0x844>)
 80157b2:	f000 fc15 	bl	8015fe0 <hci_send_cmd>
                return true;
 80157b6:	2301      	movs	r3, #1
 80157b8:	e05a      	b.n	8015870 <hci_run_general_pending_commands+0x824>
                connection->le_con_parameter_update_state = CON_PARAMETER_UPDATE_NONE;
 80157ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80157bc:	2200      	movs	r2, #0
 80157be:	f883 270b 	strb.w	r2, [r3, #1803]	; 0x70b
                hci_send_cmd(&hci_le_remote_connection_parameter_request_reply, connection->con_handle, connection->le_conn_interval_min,
 80157c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80157c4:	895b      	ldrh	r3, [r3, #10]
 80157c6:	4618      	mov	r0, r3
 80157c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80157ca:	f8b3 370e 	ldrh.w	r3, [r3, #1806]	; 0x70e
 80157ce:	461c      	mov	r4, r3
                             connection->le_conn_interval_max, connection->le_conn_latency, connection->le_supervision_timeout,
 80157d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80157d2:	f8b3 3710 	ldrh.w	r3, [r3, #1808]	; 0x710
                hci_send_cmd(&hci_le_remote_connection_parameter_request_reply, connection->con_handle, connection->le_conn_interval_min,
 80157d6:	461d      	mov	r5, r3
                             connection->le_conn_interval_max, connection->le_conn_latency, connection->le_supervision_timeout,
 80157d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80157da:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
                hci_send_cmd(&hci_le_remote_connection_parameter_request_reply, connection->con_handle, connection->le_conn_interval_min,
 80157de:	461a      	mov	r2, r3
                             connection->le_conn_interval_max, connection->le_conn_latency, connection->le_supervision_timeout,
 80157e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80157e2:	f8b3 3714 	ldrh.w	r3, [r3, #1812]	; 0x714
                hci_send_cmd(&hci_le_remote_connection_parameter_request_reply, connection->con_handle, connection->le_conn_interval_min,
 80157e6:	4619      	mov	r1, r3
 80157e8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80157ec:	9303      	str	r3, [sp, #12]
 80157ee:	2300      	movs	r3, #0
 80157f0:	9302      	str	r3, [sp, #8]
 80157f2:	9101      	str	r1, [sp, #4]
 80157f4:	9200      	str	r2, [sp, #0]
 80157f6:	462b      	mov	r3, r5
 80157f8:	4622      	mov	r2, r4
 80157fa:	4601      	mov	r1, r0
 80157fc:	4825      	ldr	r0, [pc, #148]	; (8015894 <hci_run_general_pending_commands+0x848>)
 80157fe:	f000 fbef 	bl	8015fe0 <hci_send_cmd>
                return true;
 8015802:	2301      	movs	r3, #1
 8015804:	e034      	b.n	8015870 <hci_run_general_pending_commands+0x824>
                connection->le_con_parameter_update_state = CON_PARAMETER_UPDATE_NONE;
 8015806:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015808:	2200      	movs	r2, #0
 801580a:	f883 270b 	strb.w	r2, [r3, #1803]	; 0x70b
                hci_send_cmd(&hci_le_remote_connection_parameter_request_negative_reply, ERROR_CODE_UNSUPPORTED_LMP_PARAMETER_VALUE_UNSUPPORTED_LL_PARAMETER_VALUE);
 801580e:	2120      	movs	r1, #32
 8015810:	4821      	ldr	r0, [pc, #132]	; (8015898 <hci_run_general_pending_commands+0x84c>)
 8015812:	f000 fbe5 	bl	8015fe0 <hci_send_cmd>
                return true;
 8015816:	2301      	movs	r3, #1
 8015818:	e02a      	b.n	8015870 <hci_run_general_pending_commands+0x824>
            uint8_t all_phys = connection->le_phy_update_all_phys;
 801581a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801581c:	f893 3718 	ldrb.w	r3, [r3, #1816]	; 0x718
 8015820:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            connection->le_phy_update_all_phys = 0xff;
 8015824:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015826:	22ff      	movs	r2, #255	; 0xff
 8015828:	f883 2718 	strb.w	r2, [r3, #1816]	; 0x718
            hci_send_cmd(&hci_le_set_phy, connection->con_handle, all_phys, connection->le_phy_update_tx_phys, connection->le_phy_update_rx_phys, connection->le_phy_update_phy_options);
 801582c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801582e:	895b      	ldrh	r3, [r3, #10]
 8015830:	4618      	mov	r0, r3
 8015832:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
 8015836:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015838:	f893 3719 	ldrb.w	r3, [r3, #1817]	; 0x719
 801583c:	461c      	mov	r4, r3
 801583e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015840:	f893 371a 	ldrb.w	r3, [r3, #1818]	; 0x71a
 8015844:	4619      	mov	r1, r3
 8015846:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015848:	f993 371b 	ldrsb.w	r3, [r3, #1819]	; 0x71b
 801584c:	9301      	str	r3, [sp, #4]
 801584e:	9100      	str	r1, [sp, #0]
 8015850:	4623      	mov	r3, r4
 8015852:	4601      	mov	r1, r0
 8015854:	4811      	ldr	r0, [pc, #68]	; (801589c <hci_run_general_pending_commands+0x850>)
 8015856:	f000 fbc3 	bl	8015fe0 <hci_send_cmd>
            return true;
 801585a:	2301      	movs	r3, #1
 801585c:	e008      	b.n	8015870 <hci_run_general_pending_commands+0x824>
        if (connection->state == SENT_DISCONNECT) continue;
 801585e:	bf00      	nop
    for (it = (btstack_linked_item_t *) hci_stack->connections; it != NULL; it = it->next){
 8015860:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015862:	681b      	ldr	r3, [r3, #0]
 8015864:	637b      	str	r3, [r7, #52]	; 0x34
 8015866:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015868:	2b00      	cmp	r3, #0
 801586a:	f47f abf8 	bne.w	801505e <hci_run_general_pending_commands+0x12>
        }
#endif
    }
    return false;
 801586e:	2300      	movs	r3, #0
}
 8015870:	4618      	mov	r0, r3
 8015872:	373c      	adds	r7, #60	; 0x3c
 8015874:	46bd      	mov	sp, r7
 8015876:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015878:	08030a58 	.word	0x08030a58
 801587c:	08030b70 	.word	0x08030b70
 8015880:	08030a10 	.word	0x08030a10
 8015884:	08030ab0 	.word	0x08030ab0
 8015888:	08030aa8 	.word	0x08030aa8
 801588c:	08030ab8 	.word	0x08030ab8
 8015890:	08030be8 	.word	0x08030be8
 8015894:	08030c18 	.word	0x08030c18
 8015898:	08030c20 	.word	0x08030c20
 801589c:	08030c38 	.word	0x08030c38

080158a0 <hci_run>:

static void hci_run(void){
 80158a0:	b580      	push	{r7, lr}
 80158a2:	b08a      	sub	sp, #40	; 0x28
 80158a4:	af02      	add	r7, sp, #8

    bool done;

    // send continuation fragments first, as they block the prepared packet buffer
    done = hci_run_acl_fragments();
 80158a6:	f7fe ff75 	bl	8014794 <hci_run_acl_fragments>
 80158aa:	4603      	mov	r3, r0
 80158ac:	77fb      	strb	r3, [r7, #31]
    if (done) return;
 80158ae:	7ffb      	ldrb	r3, [r7, #31]
 80158b0:	2b00      	cmp	r3, #0
 80158b2:	f040 8146 	bne.w	8015b42 <hci_run+0x2a2>
        hci_host_num_completed_packets();        
        return;
    }
#endif

    if (!hci_can_send_command_packet_now()) return;
 80158b6:	f7fa fb17 	bl	800fee8 <hci_can_send_command_packet_now>
 80158ba:	4603      	mov	r3, r0
 80158bc:	2b00      	cmp	r3, #0
 80158be:	f000 8142 	beq.w	8015b46 <hci_run+0x2a6>
    // global/non-connection oriented commands


#ifdef ENABLE_CLASSIC
    // general gap classic
    done = hci_run_general_gap_classic();
 80158c2:	f7fe ffab 	bl	801481c <hci_run_general_gap_classic>
 80158c6:	4603      	mov	r3, r0
 80158c8:	77fb      	strb	r3, [r7, #31]
    if (done) return;
 80158ca:	7ffb      	ldrb	r3, [r7, #31]
 80158cc:	2b00      	cmp	r3, #0
 80158ce:	f040 813c 	bne.w	8015b4a <hci_run+0x2aa>
#endif

#ifdef ENABLE_BLE
    // general gap le
    done = hci_run_general_gap_le();
 80158d2:	f7ff f8b5 	bl	8014a40 <hci_run_general_gap_le>
 80158d6:	4603      	mov	r3, r0
 80158d8:	77fb      	strb	r3, [r7, #31]
    if (done) return;
 80158da:	7ffb      	ldrb	r3, [r7, #31]
 80158dc:	2b00      	cmp	r3, #0
 80158de:	f040 8136 	bne.w	8015b4e <hci_run+0x2ae>
#endif

    // send pending HCI commands
    done = hci_run_general_pending_commands();
 80158e2:	f7ff fbb3 	bl	801504c <hci_run_general_pending_commands>
 80158e6:	4603      	mov	r3, r0
 80158e8:	77fb      	strb	r3, [r7, #31]
    if (done) return;
 80158ea:	7ffb      	ldrb	r3, [r7, #31]
 80158ec:	2b00      	cmp	r3, #0
 80158ee:	f040 8130 	bne.w	8015b52 <hci_run+0x2b2>

    // stack state sub statemachines
    hci_connection_t * connection;
    switch (hci_stack->state){
 80158f2:	4b9e      	ldr	r3, [pc, #632]	; (8015b6c <hci_run+0x2cc>)
 80158f4:	681b      	ldr	r3, [r3, #0]
 80158f6:	f893 3716 	ldrb.w	r3, [r3, #1814]	; 0x716
 80158fa:	2b03      	cmp	r3, #3
 80158fc:	d008      	beq.n	8015910 <hci_run+0x70>
 80158fe:	2b05      	cmp	r3, #5
 8015900:	f000 80bf 	beq.w	8015a82 <hci_run+0x1e2>
 8015904:	2b01      	cmp	r3, #1
 8015906:	d000      	beq.n	801590a <hci_run+0x6a>
                    break;
            }
            break;
            
        default:
            break;
 8015908:	e12c      	b.n	8015b64 <hci_run+0x2c4>
            hci_initializing_run();
 801590a:	f7fb f9f9 	bl	8010d00 <hci_initializing_run>
            break;
 801590e:	e129      	b.n	8015b64 <hci_run+0x2c4>
            log_info("HCI_STATE_HALTING, substate %x\n", hci_stack->substate);
 8015910:	4b96      	ldr	r3, [pc, #600]	; (8015b6c <hci_run+0x2cc>)
 8015912:	681b      	ldr	r3, [r3, #0]
 8015914:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 8015918:	9300      	str	r3, [sp, #0]
 801591a:	f241 1367 	movw	r3, #4455	; 0x1167
 801591e:	4a94      	ldr	r2, [pc, #592]	; (8015b70 <hci_run+0x2d0>)
 8015920:	4994      	ldr	r1, [pc, #592]	; (8015b74 <hci_run+0x2d4>)
 8015922:	2001      	movs	r0, #1
 8015924:	f001 fd8c 	bl	8017440 <hci_dump_log>
            switch (hci_stack->substate){
 8015928:	4b90      	ldr	r3, [pc, #576]	; (8015b6c <hci_run+0x2cc>)
 801592a:	681b      	ldr	r3, [r3, #0]
 801592c:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 8015930:	3b49      	subs	r3, #73	; 0x49
 8015932:	2b03      	cmp	r3, #3
 8015934:	f200 80a3 	bhi.w	8015a7e <hci_run+0x1de>
 8015938:	a201      	add	r2, pc, #4	; (adr r2, 8015940 <hci_run+0xa0>)
 801593a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801593e:	bf00      	nop
 8015940:	08015951 	.word	0x08015951
 8015944:	08015951 	.word	0x08015951
 8015948:	08015a7f 	.word	0x08015a7f
 801594c:	08015a4b 	.word	0x08015a4b
                        btstack_linked_list_iterator_init(&lit, &hci_stack->le_whitelist);
 8015950:	4b86      	ldr	r3, [pc, #536]	; (8015b6c <hci_run+0x2cc>)
 8015952:	681b      	ldr	r3, [r3, #0]
 8015954:	f503 62ec 	add.w	r2, r3, #1888	; 0x760
 8015958:	1d3b      	adds	r3, r7, #4
 801595a:	4611      	mov	r1, r2
 801595c:	4618      	mov	r0, r3
 801595e:	f7f8 fef6 	bl	800e74e <btstack_linked_list_iterator_init>
                        while (btstack_linked_list_iterator_has_next(&lit)){
 8015962:	e00f      	b.n	8015984 <hci_run+0xe4>
                            whitelist_entry_t * entry = (whitelist_entry_t*) btstack_linked_list_iterator_next(&lit);
 8015964:	1d3b      	adds	r3, r7, #4
 8015966:	4618      	mov	r0, r3
 8015968:	f7f8 ff34 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801596c:	6138      	str	r0, [r7, #16]
                            btstack_linked_list_remove(&hci_stack->le_whitelist, (btstack_linked_item_t *) entry);
 801596e:	4b7f      	ldr	r3, [pc, #508]	; (8015b6c <hci_run+0x2cc>)
 8015970:	681b      	ldr	r3, [r3, #0]
 8015972:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 8015976:	6939      	ldr	r1, [r7, #16]
 8015978:	4618      	mov	r0, r3
 801597a:	f7f8 fea0 	bl	800e6be <btstack_linked_list_remove>
                            btstack_memory_whitelist_entry_free(entry);
 801597e:	6938      	ldr	r0, [r7, #16]
 8015980:	f7f8 ffb4 	bl	800e8ec <btstack_memory_whitelist_entry_free>
                        while (btstack_linked_list_iterator_has_next(&lit)){
 8015984:	1d3b      	adds	r3, r7, #4
 8015986:	4618      	mov	r0, r3
 8015988:	f7f8 fef6 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801598c:	4603      	mov	r3, r0
 801598e:	2b00      	cmp	r3, #0
 8015990:	d1e8      	bne.n	8015964 <hci_run+0xc4>
                    connection =  (hci_connection_t *) hci_stack->connections;
 8015992:	4b76      	ldr	r3, [pc, #472]	; (8015b6c <hci_run+0x2cc>)
 8015994:	681b      	ldr	r3, [r3, #0]
 8015996:	695b      	ldr	r3, [r3, #20]
 8015998:	61bb      	str	r3, [r7, #24]
                    if (connection){
 801599a:	69bb      	ldr	r3, [r7, #24]
 801599c:	2b00      	cmp	r3, #0
 801599e:	d02a      	beq.n	80159f6 <hci_run+0x156>
                        hci_con_handle_t con_handle = (uint16_t) connection->con_handle;
 80159a0:	69bb      	ldr	r3, [r7, #24]
 80159a2:	895b      	ldrh	r3, [r3, #10]
 80159a4:	82fb      	strh	r3, [r7, #22]
                        if (!hci_can_send_command_packet_now()) return;
 80159a6:	f7fa fa9f 	bl	800fee8 <hci_can_send_command_packet_now>
 80159aa:	4603      	mov	r3, r0
 80159ac:	2b00      	cmp	r3, #0
 80159ae:	f000 80d2 	beq.w	8015b56 <hci_run+0x2b6>
                        if (connection->state == SENT_DISCONNECT) return;
 80159b2:	69bb      	ldr	r3, [r7, #24]
 80159b4:	7b9b      	ldrb	r3, [r3, #14]
 80159b6:	2b09      	cmp	r3, #9
 80159b8:	f000 80cf 	beq.w	8015b5a <hci_run+0x2ba>
                        connection->state = SENT_DISCONNECT;
 80159bc:	69bb      	ldr	r3, [r7, #24]
 80159be:	2209      	movs	r2, #9
 80159c0:	739a      	strb	r2, [r3, #14]
                        log_info("HCI_STATE_HALTING, connection %p, handle %u", connection, con_handle);
 80159c2:	8afb      	ldrh	r3, [r7, #22]
 80159c4:	9301      	str	r3, [sp, #4]
 80159c6:	69bb      	ldr	r3, [r7, #24]
 80159c8:	9300      	str	r3, [sp, #0]
 80159ca:	f241 1384 	movw	r3, #4484	; 0x1184
 80159ce:	4a68      	ldr	r2, [pc, #416]	; (8015b70 <hci_run+0x2d0>)
 80159d0:	4969      	ldr	r1, [pc, #420]	; (8015b78 <hci_run+0x2d8>)
 80159d2:	2001      	movs	r0, #1
 80159d4:	f001 fd34 	bl	8017440 <hci_dump_log>
                        hci_emit_disconnection_complete(con_handle, 0x16); // terminated by local host
 80159d8:	8afb      	ldrh	r3, [r7, #22]
 80159da:	2116      	movs	r1, #22
 80159dc:	4618      	mov	r0, r3
 80159de:	f000 fd5c 	bl	801649a <hci_emit_disconnection_complete>
                        hci_shutdown_connection(connection);
 80159e2:	69b8      	ldr	r0, [r7, #24]
 80159e4:	f7fa fdf8 	bl	80105d8 <hci_shutdown_connection>
                        hci_send_cmd(&hci_disconnect, con_handle, ERROR_CODE_REMOTE_USER_TERMINATED_CONNECTION);
 80159e8:	8afb      	ldrh	r3, [r7, #22]
 80159ea:	2213      	movs	r2, #19
 80159ec:	4619      	mov	r1, r3
 80159ee:	4863      	ldr	r0, [pc, #396]	; (8015b7c <hci_run+0x2dc>)
 80159f0:	f000 faf6 	bl	8015fe0 <hci_send_cmd>
                        return;
 80159f4:	e0b6      	b.n	8015b64 <hci_run+0x2c4>
                    if (hci_stack->substate == HCI_HALTING_DISCONNECT_ALL_TIMER){
 80159f6:	4b5d      	ldr	r3, [pc, #372]	; (8015b6c <hci_run+0x2cc>)
 80159f8:	681b      	ldr	r3, [r3, #0]
 80159fa:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 80159fe:	2b4a      	cmp	r3, #74	; 0x4a
 8015a00:	d123      	bne.n	8015a4a <hci_run+0x1aa>
                        log_info("HCI_STATE_HALTING: wait 50 ms");
 8015a02:	f241 1393 	movw	r3, #4499	; 0x1193
 8015a06:	4a5a      	ldr	r2, [pc, #360]	; (8015b70 <hci_run+0x2d0>)
 8015a08:	495d      	ldr	r1, [pc, #372]	; (8015b80 <hci_run+0x2e0>)
 8015a0a:	2001      	movs	r0, #1
 8015a0c:	f001 fd18 	bl	8017440 <hci_dump_log>
                        hci_stack->substate = HCI_HALTING_W4_TIMER;
 8015a10:	4b56      	ldr	r3, [pc, #344]	; (8015b6c <hci_run+0x2cc>)
 8015a12:	681b      	ldr	r3, [r3, #0]
 8015a14:	224b      	movs	r2, #75	; 0x4b
 8015a16:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                        btstack_run_loop_set_timer(&hci_stack->timeout, 50);
 8015a1a:	4b54      	ldr	r3, [pc, #336]	; (8015b6c <hci_run+0x2cc>)
 8015a1c:	681b      	ldr	r3, [r3, #0]
 8015a1e:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8015a22:	2132      	movs	r1, #50	; 0x32
 8015a24:	4618      	mov	r0, r3
 8015a26:	f7f9 f915 	bl	800ec54 <btstack_run_loop_set_timer>
                        btstack_run_loop_set_timer_handler(&hci_stack->timeout, hci_halting_timeout_handler);
 8015a2a:	4b50      	ldr	r3, [pc, #320]	; (8015b6c <hci_run+0x2cc>)
 8015a2c:	681b      	ldr	r3, [r3, #0]
 8015a2e:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8015a32:	4954      	ldr	r1, [pc, #336]	; (8015b84 <hci_run+0x2e4>)
 8015a34:	4618      	mov	r0, r3
 8015a36:	f7f9 f8a9 	bl	800eb8c <btstack_run_loop_set_timer_handler>
                        btstack_run_loop_add_timer(&hci_stack->timeout);
 8015a3a:	4b4c      	ldr	r3, [pc, #304]	; (8015b6c <hci_run+0x2cc>)
 8015a3c:	681b      	ldr	r3, [r3, #0]
 8015a3e:	f503 63e3 	add.w	r3, r3, #1816	; 0x718
 8015a42:	4618      	mov	r0, r3
 8015a44:	f7f9 f932 	bl	800ecac <btstack_run_loop_add_timer>
                        break;
 8015a48:	e01a      	b.n	8015a80 <hci_run+0x1e0>
                    log_info("HCI_STATE_HALTING, calling off");
 8015a4a:	f241 139e 	movw	r3, #4510	; 0x119e
 8015a4e:	4a48      	ldr	r2, [pc, #288]	; (8015b70 <hci_run+0x2d0>)
 8015a50:	494d      	ldr	r1, [pc, #308]	; (8015b88 <hci_run+0x2e8>)
 8015a52:	2001      	movs	r0, #1
 8015a54:	f001 fcf4 	bl	8017440 <hci_dump_log>
                    hci_power_control_off();
 8015a58:	f7fe fc4a 	bl	80142f0 <hci_power_control_off>
                    log_info("HCI_STATE_HALTING, emitting state");
 8015a5c:	f241 13a3 	movw	r3, #4515	; 0x11a3
 8015a60:	4a43      	ldr	r2, [pc, #268]	; (8015b70 <hci_run+0x2d0>)
 8015a62:	494a      	ldr	r1, [pc, #296]	; (8015b8c <hci_run+0x2ec>)
 8015a64:	2001      	movs	r0, #1
 8015a66:	f001 fceb 	bl	8017440 <hci_dump_log>
                    hci_emit_state();
 8015a6a:	f000 fc83 	bl	8016374 <hci_emit_state>
                    log_info("HCI_STATE_HALTING, done");
 8015a6e:	f241 13a5 	movw	r3, #4517	; 0x11a5
 8015a72:	4a3f      	ldr	r2, [pc, #252]	; (8015b70 <hci_run+0x2d0>)
 8015a74:	4946      	ldr	r1, [pc, #280]	; (8015b90 <hci_run+0x2f0>)
 8015a76:	2001      	movs	r0, #1
 8015a78:	f001 fce2 	bl	8017440 <hci_dump_log>
                    break;
 8015a7c:	e000      	b.n	8015a80 <hci_run+0x1e0>
                    break;
 8015a7e:	bf00      	nop
            break;
 8015a80:	e070      	b.n	8015b64 <hci_run+0x2c4>
            switch(hci_stack->substate) {
 8015a82:	4b3a      	ldr	r3, [pc, #232]	; (8015b6c <hci_run+0x2cc>)
 8015a84:	681b      	ldr	r3, [r3, #0]
 8015a86:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 8015a8a:	2b45      	cmp	r3, #69	; 0x45
 8015a8c:	d002      	beq.n	8015a94 <hci_run+0x1f4>
 8015a8e:	2b47      	cmp	r3, #71	; 0x47
 8015a90:	d04a      	beq.n	8015b28 <hci_run+0x288>
                    break;
 8015a92:	e055      	b.n	8015b40 <hci_run+0x2a0>
                    log_info("HCI_STATE_FALLING_ASLEEP");
 8015a94:	f241 13b5 	movw	r3, #4533	; 0x11b5
 8015a98:	4a35      	ldr	r2, [pc, #212]	; (8015b70 <hci_run+0x2d0>)
 8015a9a:	493e      	ldr	r1, [pc, #248]	; (8015b94 <hci_run+0x2f4>)
 8015a9c:	2001      	movs	r0, #1
 8015a9e:	f001 fccf 	bl	8017440 <hci_dump_log>
                    connection =  (hci_connection_t *) hci_stack->connections;
 8015aa2:	4b32      	ldr	r3, [pc, #200]	; (8015b6c <hci_run+0x2cc>)
 8015aa4:	681b      	ldr	r3, [r3, #0]
 8015aa6:	695b      	ldr	r3, [r3, #20]
 8015aa8:	61bb      	str	r3, [r7, #24]
                    if (connection){
 8015aaa:	69bb      	ldr	r3, [r7, #24]
 8015aac:	2b00      	cmp	r3, #0
 8015aae:	d01b      	beq.n	8015ae8 <hci_run+0x248>
                        if (!hci_can_send_command_packet_now()) return;
 8015ab0:	f7fa fa1a 	bl	800fee8 <hci_can_send_command_packet_now>
 8015ab4:	4603      	mov	r3, r0
 8015ab6:	2b00      	cmp	r3, #0
 8015ab8:	d051      	beq.n	8015b5e <hci_run+0x2be>
                        log_info("HCI_STATE_FALLING_ASLEEP, connection %p, handle %u", connection, (uint16_t)connection->con_handle);
 8015aba:	69bb      	ldr	r3, [r7, #24]
 8015abc:	895b      	ldrh	r3, [r3, #10]
 8015abe:	9301      	str	r3, [sp, #4]
 8015ac0:	69bb      	ldr	r3, [r7, #24]
 8015ac2:	9300      	str	r3, [sp, #0]
 8015ac4:	f241 13c4 	movw	r3, #4548	; 0x11c4
 8015ac8:	4a29      	ldr	r2, [pc, #164]	; (8015b70 <hci_run+0x2d0>)
 8015aca:	4933      	ldr	r1, [pc, #204]	; (8015b98 <hci_run+0x2f8>)
 8015acc:	2001      	movs	r0, #1
 8015ace:	f001 fcb7 	bl	8017440 <hci_dump_log>
                        hci_send_cmd(&hci_disconnect, connection->con_handle, ERROR_CODE_REMOTE_USER_TERMINATED_CONNECTION);
 8015ad2:	69bb      	ldr	r3, [r7, #24]
 8015ad4:	895b      	ldrh	r3, [r3, #10]
 8015ad6:	2213      	movs	r2, #19
 8015ad8:	4619      	mov	r1, r3
 8015ada:	4828      	ldr	r0, [pc, #160]	; (8015b7c <hci_run+0x2dc>)
 8015adc:	f000 fa80 	bl	8015fe0 <hci_send_cmd>
                        hci_shutdown_connection(connection);
 8015ae0:	69b8      	ldr	r0, [r7, #24]
 8015ae2:	f7fa fd79 	bl	80105d8 <hci_shutdown_connection>
                        return;
 8015ae6:	e03d      	b.n	8015b64 <hci_run+0x2c4>
                    if (hci_classic_supported()){
 8015ae8:	f7fa fea8 	bl	801083c <hci_classic_supported>
 8015aec:	4603      	mov	r3, r0
 8015aee:	2b00      	cmp	r3, #0
 8015af0:	d01a      	beq.n	8015b28 <hci_run+0x288>
                        if (!hci_can_send_command_packet_now()) return;
 8015af2:	f7fa f9f9 	bl	800fee8 <hci_can_send_command_packet_now>
 8015af6:	4603      	mov	r3, r0
 8015af8:	2b00      	cmp	r3, #0
 8015afa:	d032      	beq.n	8015b62 <hci_run+0x2c2>
                        log_info("HCI_STATE_HALTING, disabling inq scans");
 8015afc:	f241 13d0 	movw	r3, #4560	; 0x11d0
 8015b00:	4a1b      	ldr	r2, [pc, #108]	; (8015b70 <hci_run+0x2d0>)
 8015b02:	4926      	ldr	r1, [pc, #152]	; (8015b9c <hci_run+0x2fc>)
 8015b04:	2001      	movs	r0, #1
 8015b06:	f001 fc9b 	bl	8017440 <hci_dump_log>
                        hci_send_cmd(&hci_write_scan_enable, hci_stack->connectable << 1); // drop inquiry scan but keep page scan
 8015b0a:	4b18      	ldr	r3, [pc, #96]	; (8015b6c <hci_run+0x2cc>)
 8015b0c:	681b      	ldr	r3, [r3, #0]
 8015b0e:	f893 372f 	ldrb.w	r3, [r3, #1839]	; 0x72f
 8015b12:	005b      	lsls	r3, r3, #1
 8015b14:	4619      	mov	r1, r3
 8015b16:	4822      	ldr	r0, [pc, #136]	; (8015ba0 <hci_run+0x300>)
 8015b18:	f000 fa62 	bl	8015fe0 <hci_send_cmd>
                        hci_stack->substate = HCI_FALLING_ASLEEP_W4_WRITE_SCAN_ENABLE;
 8015b1c:	4b13      	ldr	r3, [pc, #76]	; (8015b6c <hci_run+0x2cc>)
 8015b1e:	681b      	ldr	r3, [r3, #0]
 8015b20:	2246      	movs	r2, #70	; 0x46
 8015b22:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
                        break;
 8015b26:	e00b      	b.n	8015b40 <hci_run+0x2a0>
                    log_info("HCI_STATE_HALTING, calling sleep");
 8015b28:	f241 13db 	movw	r3, #4571	; 0x11db
 8015b2c:	4a10      	ldr	r2, [pc, #64]	; (8015b70 <hci_run+0x2d0>)
 8015b2e:	491d      	ldr	r1, [pc, #116]	; (8015ba4 <hci_run+0x304>)
 8015b30:	2001      	movs	r0, #1
 8015b32:	f001 fc85 	bl	8017440 <hci_dump_log>
                    hci_power_control_sleep();  // changes hci_stack->state to SLEEP
 8015b36:	f7fe fc19 	bl	801436c <hci_power_control_sleep>
                    hci_emit_state();
 8015b3a:	f000 fc1b 	bl	8016374 <hci_emit_state>
                    break;
 8015b3e:	bf00      	nop
            break;
 8015b40:	e010      	b.n	8015b64 <hci_run+0x2c4>
    if (done) return;
 8015b42:	bf00      	nop
 8015b44:	e00e      	b.n	8015b64 <hci_run+0x2c4>
    if (!hci_can_send_command_packet_now()) return;
 8015b46:	bf00      	nop
 8015b48:	e00c      	b.n	8015b64 <hci_run+0x2c4>
    if (done) return;
 8015b4a:	bf00      	nop
 8015b4c:	e00a      	b.n	8015b64 <hci_run+0x2c4>
    if (done) return;
 8015b4e:	bf00      	nop
 8015b50:	e008      	b.n	8015b64 <hci_run+0x2c4>
    if (done) return;
 8015b52:	bf00      	nop
 8015b54:	e006      	b.n	8015b64 <hci_run+0x2c4>
                        if (!hci_can_send_command_packet_now()) return;
 8015b56:	bf00      	nop
 8015b58:	e004      	b.n	8015b64 <hci_run+0x2c4>
                        if (connection->state == SENT_DISCONNECT) return;
 8015b5a:	bf00      	nop
 8015b5c:	e002      	b.n	8015b64 <hci_run+0x2c4>
                        if (!hci_can_send_command_packet_now()) return;
 8015b5e:	bf00      	nop
 8015b60:	e000      	b.n	8015b64 <hci_run+0x2c4>
                        if (!hci_can_send_command_packet_now()) return;
 8015b62:	bf00      	nop
    }
}
 8015b64:	3720      	adds	r7, #32
 8015b66:	46bd      	mov	sp, r7
 8015b68:	bd80      	pop	{r7, pc}
 8015b6a:	bf00      	nop
 8015b6c:	20009780 	.word	0x20009780
 8015b70:	0802929c 	.word	0x0802929c
 8015b74:	0802a78c 	.word	0x0802a78c
 8015b78:	0802a7b4 	.word	0x0802a7b4
 8015b7c:	08030a10 	.word	0x08030a10
 8015b80:	0802a7e8 	.word	0x0802a7e8
 8015b84:	0801476d 	.word	0x0801476d
 8015b88:	0802a810 	.word	0x0802a810
 8015b8c:	0802a838 	.word	0x0802a838
 8015b90:	0802a864 	.word	0x0802a864
 8015b94:	0802a884 	.word	0x0802a884
 8015b98:	0802a8a4 	.word	0x0802a8a4
 8015b9c:	0802a8e0 	.word	0x0802a8e0
 8015ba0:	08030af0 	.word	0x08030af0
 8015ba4:	0802a910 	.word	0x0802a910

08015ba8 <hci_send_cmd_packet>:

int hci_send_cmd_packet(uint8_t *packet, int size){
 8015ba8:	b590      	push	{r4, r7, lr}
 8015baa:	b089      	sub	sp, #36	; 0x24
 8015bac:	af02      	add	r7, sp, #8
 8015bae:	6078      	str	r0, [r7, #4]
 8015bb0:	6039      	str	r1, [r7, #0]
#endif
#ifdef ENABLE_LE_CENTRAL
    uint8_t initiator_filter_policy;
#endif

    uint16_t opcode = little_endian_read_16(packet, 0);
 8015bb2:	2100      	movs	r1, #0
 8015bb4:	6878      	ldr	r0, [r7, #4]
 8015bb6:	f7f9 f916 	bl	800ede6 <little_endian_read_16>
 8015bba:	4603      	mov	r3, r0
 8015bbc:	827b      	strh	r3, [r7, #18]
    switch (opcode) {
 8015bbe:	8a7b      	ldrh	r3, [r7, #18]
 8015bc0:	f5b3 6f86 	cmp.w	r3, #1072	; 0x430
 8015bc4:	da26      	bge.n	8015c14 <hci_send_cmd_packet+0x6c>
 8015bc6:	f240 422c 	movw	r2, #1068	; 0x42c
 8015bca:	4293      	cmp	r3, r2
 8015bcc:	f280 80fc 	bge.w	8015dc8 <hci_send_cmd_packet+0x220>
 8015bd0:	f240 420e 	movw	r2, #1038	; 0x40e
 8015bd4:	4293      	cmp	r3, r2
 8015bd6:	dc13      	bgt.n	8015c00 <hci_send_cmd_packet+0x58>
 8015bd8:	f240 420d 	movw	r2, #1037	; 0x40d
 8015bdc:	4293      	cmp	r3, r2
 8015bde:	f280 80da 	bge.w	8015d96 <hci_send_cmd_packet+0x1ee>
 8015be2:	f240 420b 	movw	r2, #1035	; 0x40b
 8015be6:	4293      	cmp	r3, r2
 8015be8:	f000 80b0 	beq.w	8015d4c <hci_send_cmd_packet+0x1a4>
 8015bec:	f240 420b 	movw	r2, #1035	; 0x40b
 8015bf0:	4293      	cmp	r3, r2
 8015bf2:	f300 80b2 	bgt.w	8015d5a <hci_send_cmd_packet+0x1b2>
 8015bf6:	f240 4205 	movw	r2, #1029	; 0x405
 8015bfa:	4293      	cmp	r3, r2
 8015bfc:	d034      	beq.n	8015c68 <hci_send_cmd_packet+0xc0>
            hci_stack->le_connecting_state = LE_CONNECTING_CANCEL;
            break;
#endif
#endif
        default:
            break;
 8015bfe:	e16a      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
    switch (opcode) {
 8015c00:	f5b3 6f85 	cmp.w	r3, #1064	; 0x428
 8015c04:	f000 80f8 	beq.w	8015df8 <hci_send_cmd_packet+0x250>
 8015c08:	f240 4229 	movw	r2, #1065	; 0x429
 8015c0c:	4293      	cmp	r3, r2
 8015c0e:	f000 80fd 	beq.w	8015e0c <hci_send_cmd_packet+0x264>
            break;
 8015c12:	e160      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
    switch (opcode) {
 8015c14:	f242 0205 	movw	r2, #8197	; 0x2005
 8015c18:	4293      	cmp	r3, r2
 8015c1a:	f000 8101 	beq.w	8015e20 <hci_send_cmd_packet+0x278>
 8015c1e:	f242 0205 	movw	r2, #8197	; 0x2005
 8015c22:	4293      	cmp	r3, r2
 8015c24:	dc09      	bgt.n	8015c3a <hci_send_cmd_packet+0x92>
 8015c26:	f640 4212 	movw	r2, #3090	; 0xc12
 8015c2a:	4293      	cmp	r3, r2
 8015c2c:	f000 809c 	beq.w	8015d68 <hci_send_cmd_packet+0x1c0>
 8015c30:	f641 0202 	movw	r2, #6146	; 0x1802
 8015c34:	4293      	cmp	r3, r2
 8015c36:	d010      	beq.n	8015c5a <hci_send_cmd_packet+0xb2>
            break;
 8015c38:	e14d      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
    switch (opcode) {
 8015c3a:	f242 020d 	movw	r2, #8205	; 0x200d
 8015c3e:	4293      	cmp	r3, r2
 8015c40:	f000 810b 	beq.w	8015e5a <hci_send_cmd_packet+0x2b2>
 8015c44:	f242 020e 	movw	r2, #8206	; 0x200e
 8015c48:	4293      	cmp	r3, r2
 8015c4a:	f000 8139 	beq.w	8015ec0 <hci_send_cmd_packet+0x318>
 8015c4e:	f242 020a 	movw	r2, #8202	; 0x200a
 8015c52:	4293      	cmp	r3, r2
 8015c54:	f000 80f4 	beq.w	8015e40 <hci_send_cmd_packet+0x298>
            break;
 8015c58:	e13d      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            hci_stack->loopback_mode = packet[3];
 8015c5a:	4bad      	ldr	r3, [pc, #692]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015c5c:	681b      	ldr	r3, [r3, #0]
 8015c5e:	687a      	ldr	r2, [r7, #4]
 8015c60:	78d2      	ldrb	r2, [r2, #3]
 8015c62:	f883 274c 	strb.w	r2, [r3, #1868]	; 0x74c
            break;
 8015c66:	e136      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            reverse_bd_addr(&packet[3], addr);
 8015c68:	687b      	ldr	r3, [r7, #4]
 8015c6a:	3303      	adds	r3, #3
 8015c6c:	f107 0208 	add.w	r2, r7, #8
 8015c70:	4611      	mov	r1, r2
 8015c72:	4618      	mov	r0, r3
 8015c74:	f7f9 fa3d 	bl	800f0f2 <reverse_bd_addr>
            log_info("Create_connection to %s", bd_addr_to_str(addr));
 8015c78:	f107 0308 	add.w	r3, r7, #8
 8015c7c:	4618      	mov	r0, r3
 8015c7e:	f7f9 fbc7 	bl	800f410 <bd_addr_to_str>
 8015c82:	4603      	mov	r3, r0
 8015c84:	9300      	str	r3, [sp, #0]
 8015c86:	f241 2308 	movw	r3, #4616	; 0x1208
 8015c8a:	4aa2      	ldr	r2, [pc, #648]	; (8015f14 <hci_send_cmd_packet+0x36c>)
 8015c8c:	49a2      	ldr	r1, [pc, #648]	; (8015f18 <hci_send_cmd_packet+0x370>)
 8015c8e:	2001      	movs	r0, #1
 8015c90:	f001 fbd6 	bl	8017440 <hci_dump_log>
            conn = hci_connection_for_bd_addr_and_type(addr, BD_ADDR_TYPE_ACL);
 8015c94:	f107 0308 	add.w	r3, r7, #8
 8015c98:	21fd      	movs	r1, #253	; 0xfd
 8015c9a:	4618      	mov	r0, r3
 8015c9c:	f7f9 fe3e 	bl	800f91c <hci_connection_for_bd_addr_and_type>
 8015ca0:	6178      	str	r0, [r7, #20]
            if (!conn) {
 8015ca2:	697b      	ldr	r3, [r7, #20]
 8015ca4:	2b00      	cmp	r3, #0
 8015ca6:	d119      	bne.n	8015cdc <hci_send_cmd_packet+0x134>
                conn = create_connection_for_bd_addr_and_type(addr, BD_ADDR_TYPE_ACL);
 8015ca8:	f107 0308 	add.w	r3, r7, #8
 8015cac:	21fd      	movs	r1, #253	; 0xfd
 8015cae:	4618      	mov	r0, r3
 8015cb0:	f7f9 fd32 	bl	800f718 <create_connection_for_bd_addr_and_type>
 8015cb4:	6178      	str	r0, [r7, #20]
                if (!conn) {
 8015cb6:	697b      	ldr	r3, [r7, #20]
 8015cb8:	2b00      	cmp	r3, #0
 8015cba:	d109      	bne.n	8015cd0 <hci_send_cmd_packet+0x128>
                    hci_emit_connection_complete(addr, 0, BTSTACK_MEMORY_ALLOC_FAILED);
 8015cbc:	f107 0308 	add.w	r3, r7, #8
 8015cc0:	2256      	movs	r2, #86	; 0x56
 8015cc2:	2100      	movs	r1, #0
 8015cc4:	4618      	mov	r0, r3
 8015cc6:	f000 fb7d 	bl	80163c4 <hci_emit_connection_complete>
                    return -1; // packet not sent to controller
 8015cca:	f04f 33ff 	mov.w	r3, #4294967295
 8015cce:	e11a      	b.n	8015f06 <hci_send_cmd_packet+0x35e>
                conn->state = SEND_CREATE_CONNECTION;
 8015cd0:	697b      	ldr	r3, [r7, #20]
 8015cd2:	2200      	movs	r2, #0
 8015cd4:	739a      	strb	r2, [r3, #14]
                conn->role  = HCI_ROLE_MASTER;
 8015cd6:	697b      	ldr	r3, [r7, #20]
 8015cd8:	2200      	movs	r2, #0
 8015cda:	735a      	strb	r2, [r3, #13]
            log_info("conn state %u", conn->state);
 8015cdc:	697b      	ldr	r3, [r7, #20]
 8015cde:	7b9b      	ldrb	r3, [r3, #14]
 8015ce0:	9300      	str	r3, [sp, #0]
 8015ce2:	f241 2315 	movw	r3, #4629	; 0x1215
 8015ce6:	4a8b      	ldr	r2, [pc, #556]	; (8015f14 <hci_send_cmd_packet+0x36c>)
 8015ce8:	498c      	ldr	r1, [pc, #560]	; (8015f1c <hci_send_cmd_packet+0x374>)
 8015cea:	2001      	movs	r0, #1
 8015cec:	f001 fba8 	bl	8017440 <hci_dump_log>
            switch (conn->state) {
 8015cf0:	697b      	ldr	r3, [r7, #20]
 8015cf2:	7b9b      	ldrb	r3, [r3, #14]
 8015cf4:	2b07      	cmp	r3, #7
 8015cf6:	d004      	beq.n	8015d02 <hci_send_cmd_packet+0x15a>
 8015cf8:	2b0a      	cmp	r3, #10
 8015cfa:	d010      	beq.n	8015d1e <hci_send_cmd_packet+0x176>
 8015cfc:	2b00      	cmp	r3, #0
 8015cfe:	d010      	beq.n	8015d22 <hci_send_cmd_packet+0x17a>
 8015d00:	e00a      	b.n	8015d18 <hci_send_cmd_packet+0x170>
                    hci_emit_connection_complete(addr, conn->con_handle, 0);
 8015d02:	697b      	ldr	r3, [r7, #20]
 8015d04:	8959      	ldrh	r1, [r3, #10]
 8015d06:	f107 0308 	add.w	r3, r7, #8
 8015d0a:	2200      	movs	r2, #0
 8015d0c:	4618      	mov	r0, r3
 8015d0e:	f000 fb59 	bl	80163c4 <hci_emit_connection_complete>
                    return -1; // packet not sent to controller
 8015d12:	f04f 33ff 	mov.w	r3, #4294967295
 8015d16:	e0f6      	b.n	8015f06 <hci_send_cmd_packet+0x35e>
                    return -1; // packet not sent to controller
 8015d18:	f04f 33ff 	mov.w	r3, #4294967295
 8015d1c:	e0f3      	b.n	8015f06 <hci_send_cmd_packet+0x35e>
                    break;
 8015d1e:	bf00      	nop
 8015d20:	e000      	b.n	8015d24 <hci_send_cmd_packet+0x17c>
                    break;
 8015d22:	bf00      	nop
            conn->state = SENT_CREATE_CONNECTION;
 8015d24:	697b      	ldr	r3, [r7, #20]
 8015d26:	2201      	movs	r2, #1
 8015d28:	739a      	strb	r2, [r3, #14]
            hci_stack->outgoing_addr_type = BD_ADDR_TYPE_ACL;
 8015d2a:	4b79      	ldr	r3, [pc, #484]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015d2c:	681b      	ldr	r3, [r3, #0]
 8015d2e:	22fd      	movs	r2, #253	; 0xfd
 8015d30:	f883 27c0 	strb.w	r2, [r3, #1984]	; 0x7c0
            (void) memcpy(hci_stack->outgoing_addr, addr, 6);
 8015d34:	4b76      	ldr	r3, [pc, #472]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015d36:	681b      	ldr	r3, [r3, #0]
 8015d38:	f203 73ba 	addw	r3, r3, #1978	; 0x7ba
 8015d3c:	461a      	mov	r2, r3
 8015d3e:	f107 0308 	add.w	r3, r7, #8
 8015d42:	6818      	ldr	r0, [r3, #0]
 8015d44:	6010      	str	r0, [r2, #0]
 8015d46:	889b      	ldrh	r3, [r3, #4]
 8015d48:	8093      	strh	r3, [r2, #4]
            break;
 8015d4a:	e0c4      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            hci_add_connection_flags_for_flipped_bd_addr(&packet[3], SENT_LINK_KEY_REPLY);
 8015d4c:	687b      	ldr	r3, [r7, #4]
 8015d4e:	3303      	adds	r3, #3
 8015d50:	2104      	movs	r1, #4
 8015d52:	4618      	mov	r0, r3
 8015d54:	f7f9 fe90 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            break;
 8015d58:	e0bd      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            hci_add_connection_flags_for_flipped_bd_addr(&packet[3], SENT_LINK_KEY_NEGATIVE_REQUEST);
 8015d5a:	687b      	ldr	r3, [r7, #4]
 8015d5c:	3303      	adds	r3, #3
 8015d5e:	2108      	movs	r1, #8
 8015d60:	4618      	mov	r0, r3
 8015d62:	f7f9 fe89 	bl	800fa78 <hci_add_connection_flags_for_flipped_bd_addr>
            break;
 8015d66:	e0b6      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            if (hci_stack->link_key_db) {
 8015d68:	4b69      	ldr	r3, [pc, #420]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015d6a:	681b      	ldr	r3, [r3, #0]
 8015d6c:	691b      	ldr	r3, [r3, #16]
 8015d6e:	2b00      	cmp	r3, #0
 8015d70:	f000 80ac 	beq.w	8015ecc <hci_send_cmd_packet+0x324>
                reverse_bd_addr(&packet[3], addr);
 8015d74:	687b      	ldr	r3, [r7, #4]
 8015d76:	3303      	adds	r3, #3
 8015d78:	f107 0208 	add.w	r2, r7, #8
 8015d7c:	4611      	mov	r1, r2
 8015d7e:	4618      	mov	r0, r3
 8015d80:	f7f9 f9b7 	bl	800f0f2 <reverse_bd_addr>
                hci_stack->link_key_db->delete_link_key(addr);
 8015d84:	4b62      	ldr	r3, [pc, #392]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015d86:	681b      	ldr	r3, [r3, #0]
 8015d88:	691b      	ldr	r3, [r3, #16]
 8015d8a:	695b      	ldr	r3, [r3, #20]
 8015d8c:	f107 0208 	add.w	r2, r7, #8
 8015d90:	4610      	mov	r0, r2
 8015d92:	4798      	blx	r3
            break;
 8015d94:	e09a      	b.n	8015ecc <hci_send_cmd_packet+0x324>
            reverse_bd_addr(&packet[3], addr);
 8015d96:	687b      	ldr	r3, [r7, #4]
 8015d98:	3303      	adds	r3, #3
 8015d9a:	f107 0208 	add.w	r2, r7, #8
 8015d9e:	4611      	mov	r1, r2
 8015da0:	4618      	mov	r0, r3
 8015da2:	f7f9 f9a6 	bl	800f0f2 <reverse_bd_addr>
            conn = hci_connection_for_bd_addr_and_type(addr, BD_ADDR_TYPE_ACL);
 8015da6:	f107 0308 	add.w	r3, r7, #8
 8015daa:	21fd      	movs	r1, #253	; 0xfd
 8015dac:	4618      	mov	r0, r3
 8015dae:	f7f9 fdb5 	bl	800f91c <hci_connection_for_bd_addr_and_type>
 8015db2:	6178      	str	r0, [r7, #20]
            if (conn) {
 8015db4:	697b      	ldr	r3, [r7, #20]
 8015db6:	2b00      	cmp	r3, #0
 8015db8:	f000 808a 	beq.w	8015ed0 <hci_send_cmd_packet+0x328>
                connectionClearAuthenticationFlags(conn, LEGACY_PAIRING_ACTIVE);
 8015dbc:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8015dc0:	6978      	ldr	r0, [r7, #20]
 8015dc2:	f7f9 fde5 	bl	800f990 <connectionClearAuthenticationFlags>
            break;
 8015dc6:	e083      	b.n	8015ed0 <hci_send_cmd_packet+0x328>
            reverse_bd_addr(&packet[3], addr);
 8015dc8:	687b      	ldr	r3, [r7, #4]
 8015dca:	3303      	adds	r3, #3
 8015dcc:	f107 0208 	add.w	r2, r7, #8
 8015dd0:	4611      	mov	r1, r2
 8015dd2:	4618      	mov	r0, r3
 8015dd4:	f7f9 f98d 	bl	800f0f2 <reverse_bd_addr>
            conn = hci_connection_for_bd_addr_and_type(addr, BD_ADDR_TYPE_ACL);
 8015dd8:	f107 0308 	add.w	r3, r7, #8
 8015ddc:	21fd      	movs	r1, #253	; 0xfd
 8015dde:	4618      	mov	r0, r3
 8015de0:	f7f9 fd9c 	bl	800f91c <hci_connection_for_bd_addr_and_type>
 8015de4:	6178      	str	r0, [r7, #20]
            if (conn) {
 8015de6:	697b      	ldr	r3, [r7, #20]
 8015de8:	2b00      	cmp	r3, #0
 8015dea:	d073      	beq.n	8015ed4 <hci_send_cmd_packet+0x32c>
                connectionClearAuthenticationFlags(conn, SSP_PAIRING_ACTIVE);
 8015dec:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8015df0:	6978      	ldr	r0, [r7, #20]
 8015df2:	f7f9 fdcd 	bl	800f990 <connectionClearAuthenticationFlags>
            break;
 8015df6:	e06d      	b.n	8015ed4 <hci_send_cmd_packet+0x32c>
            hci_stack->sco_voice_setting_active = little_endian_read_16(packet, 15);
 8015df8:	4b45      	ldr	r3, [pc, #276]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015dfa:	681c      	ldr	r4, [r3, #0]
 8015dfc:	210f      	movs	r1, #15
 8015dfe:	6878      	ldr	r0, [r7, #4]
 8015e00:	f7f8 fff1 	bl	800ede6 <little_endian_read_16>
 8015e04:	4603      	mov	r3, r0
 8015e06:	f8a4 374a 	strh.w	r3, [r4, #1866]	; 0x74a
            break;
 8015e0a:	e064      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            hci_stack->sco_voice_setting_active = little_endian_read_16(packet, 19);
 8015e0c:	4b40      	ldr	r3, [pc, #256]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015e0e:	681c      	ldr	r4, [r3, #0]
 8015e10:	2113      	movs	r1, #19
 8015e12:	6878      	ldr	r0, [r7, #4]
 8015e14:	f7f8 ffe7 	bl	800ede6 <little_endian_read_16>
 8015e18:	4603      	mov	r3, r0
 8015e1a:	f8a4 374a 	strh.w	r3, [r4, #1866]	; 0x74a
            break;
 8015e1e:	e05a      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            hci_stack->le_random_address_set = 1;
 8015e20:	4b3b      	ldr	r3, [pc, #236]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015e22:	681b      	ldr	r3, [r3, #0]
 8015e24:	2201      	movs	r2, #1
 8015e26:	f883 275b 	strb.w	r2, [r3, #1883]	; 0x75b
            reverse_bd_addr(&packet[3], hci_stack->le_random_address);
 8015e2a:	687b      	ldr	r3, [r7, #4]
 8015e2c:	1cda      	adds	r2, r3, #3
 8015e2e:	4b38      	ldr	r3, [pc, #224]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015e30:	681b      	ldr	r3, [r3, #0]
 8015e32:	f203 7355 	addw	r3, r3, #1877	; 0x755
 8015e36:	4619      	mov	r1, r3
 8015e38:	4610      	mov	r0, r2
 8015e3a:	f7f9 f95a 	bl	800f0f2 <reverse_bd_addr>
            break;
 8015e3e:	e04a      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            hci_stack->le_advertisements_active = packet[3] != 0;
 8015e40:	687b      	ldr	r3, [r7, #4]
 8015e42:	3303      	adds	r3, #3
 8015e44:	781a      	ldrb	r2, [r3, #0]
 8015e46:	4b32      	ldr	r3, [pc, #200]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015e48:	681b      	ldr	r3, [r3, #0]
 8015e4a:	2a00      	cmp	r2, #0
 8015e4c:	bf14      	ite	ne
 8015e4e:	2201      	movne	r2, #1
 8015e50:	2200      	moveq	r2, #0
 8015e52:	b2d2      	uxtb	r2, r2
 8015e54:	f883 2799 	strb.w	r2, [r3, #1945]	; 0x799
            break;
 8015e58:	e03d      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            initiator_filter_policy = packet[7];
 8015e5a:	687b      	ldr	r3, [r7, #4]
 8015e5c:	79db      	ldrb	r3, [r3, #7]
 8015e5e:	747b      	strb	r3, [r7, #17]
            switch (initiator_filter_policy) {
 8015e60:	7c7b      	ldrb	r3, [r7, #17]
 8015e62:	2b00      	cmp	r3, #0
 8015e64:	d002      	beq.n	8015e6c <hci_send_cmd_packet+0x2c4>
 8015e66:	2b01      	cmp	r3, #1
 8015e68:	d006      	beq.n	8015e78 <hci_send_cmd_packet+0x2d0>
 8015e6a:	e00b      	b.n	8015e84 <hci_send_cmd_packet+0x2dc>
                    hci_stack->le_connecting_state = LE_CONNECTING_DIRECT;
 8015e6c:	4b28      	ldr	r3, [pc, #160]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015e6e:	681b      	ldr	r3, [r3, #0]
 8015e70:	2202      	movs	r2, #2
 8015e72:	f883 2766 	strb.w	r2, [r3, #1894]	; 0x766
                    break;
 8015e76:	e00f      	b.n	8015e98 <hci_send_cmd_packet+0x2f0>
                    hci_stack->le_connecting_state = LE_CONNECTING_WHITELIST;
 8015e78:	4b25      	ldr	r3, [pc, #148]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015e7a:	681b      	ldr	r3, [r3, #0]
 8015e7c:	2203      	movs	r2, #3
 8015e7e:	f883 2766 	strb.w	r2, [r3, #1894]	; 0x766
                    break;
 8015e82:	e009      	b.n	8015e98 <hci_send_cmd_packet+0x2f0>
                    log_error("Invalid initiator_filter_policy in LE Create Connection %u", initiator_filter_policy);
 8015e84:	7c7b      	ldrb	r3, [r7, #17]
 8015e86:	9300      	str	r3, [sp, #0]
 8015e88:	f241 2370 	movw	r3, #4720	; 0x1270
 8015e8c:	4a21      	ldr	r2, [pc, #132]	; (8015f14 <hci_send_cmd_packet+0x36c>)
 8015e8e:	4924      	ldr	r1, [pc, #144]	; (8015f20 <hci_send_cmd_packet+0x378>)
 8015e90:	2002      	movs	r0, #2
 8015e92:	f001 fad5 	bl	8017440 <hci_dump_log>
                    break;
 8015e96:	bf00      	nop
            hci_stack->outgoing_addr_type = (bd_addr_type_t) packet[8]; // peer addres type
 8015e98:	687b      	ldr	r3, [r7, #4]
 8015e9a:	f103 0208 	add.w	r2, r3, #8
 8015e9e:	4b1c      	ldr	r3, [pc, #112]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015ea0:	681b      	ldr	r3, [r3, #0]
 8015ea2:	7812      	ldrb	r2, [r2, #0]
 8015ea4:	f883 27c0 	strb.w	r2, [r3, #1984]	; 0x7c0
            reverse_bd_addr( &packet[9], hci_stack->outgoing_addr); // peer address
 8015ea8:	687b      	ldr	r3, [r7, #4]
 8015eaa:	f103 0209 	add.w	r2, r3, #9
 8015eae:	4b18      	ldr	r3, [pc, #96]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015eb0:	681b      	ldr	r3, [r3, #0]
 8015eb2:	f203 73ba 	addw	r3, r3, #1978	; 0x7ba
 8015eb6:	4619      	mov	r1, r3
 8015eb8:	4610      	mov	r0, r2
 8015eba:	f7f9 f91a 	bl	800f0f2 <reverse_bd_addr>
            break;
 8015ebe:	e00a      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            hci_stack->le_connecting_state = LE_CONNECTING_CANCEL;
 8015ec0:	4b13      	ldr	r3, [pc, #76]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015ec2:	681b      	ldr	r3, [r3, #0]
 8015ec4:	2201      	movs	r2, #1
 8015ec6:	f883 2766 	strb.w	r2, [r3, #1894]	; 0x766
            break;
 8015eca:	e004      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            break;
 8015ecc:	bf00      	nop
 8015ece:	e002      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            break;
 8015ed0:	bf00      	nop
 8015ed2:	e000      	b.n	8015ed6 <hci_send_cmd_packet+0x32e>
            break;
 8015ed4:	bf00      	nop
    }

    hci_stack->num_cmd_packets--;
 8015ed6:	4b0e      	ldr	r3, [pc, #56]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015ed8:	681b      	ldr	r3, [r3, #0]
 8015eda:	f893 26fb 	ldrb.w	r2, [r3, #1787]	; 0x6fb
 8015ede:	3a01      	subs	r2, #1
 8015ee0:	b2d2      	uxtb	r2, r2
 8015ee2:	f883 26fb 	strb.w	r2, [r3, #1787]	; 0x6fb

    hci_dump_packet(HCI_COMMAND_DATA_PACKET, 0, packet, size);
 8015ee6:	683b      	ldr	r3, [r7, #0]
 8015ee8:	b29b      	uxth	r3, r3
 8015eea:	687a      	ldr	r2, [r7, #4]
 8015eec:	2100      	movs	r1, #0
 8015eee:	2001      	movs	r0, #1
 8015ef0:	f001 fa00 	bl	80172f4 <hci_dump_packet>
    return hci_stack->hci_transport->send_packet(HCI_COMMAND_DATA_PACKET, packet, size);
 8015ef4:	4b06      	ldr	r3, [pc, #24]	; (8015f10 <hci_send_cmd_packet+0x368>)
 8015ef6:	681b      	ldr	r3, [r3, #0]
 8015ef8:	681b      	ldr	r3, [r3, #0]
 8015efa:	699b      	ldr	r3, [r3, #24]
 8015efc:	683a      	ldr	r2, [r7, #0]
 8015efe:	6879      	ldr	r1, [r7, #4]
 8015f00:	2001      	movs	r0, #1
 8015f02:	4798      	blx	r3
 8015f04:	4603      	mov	r3, r0
}
 8015f06:	4618      	mov	r0, r3
 8015f08:	371c      	adds	r7, #28
 8015f0a:	46bd      	mov	sp, r7
 8015f0c:	bd90      	pop	{r4, r7, pc}
 8015f0e:	bf00      	nop
 8015f10:	20009780 	.word	0x20009780
 8015f14:	0802929c 	.word	0x0802929c
 8015f18:	0802a938 	.word	0x0802a938
 8015f1c:	0802a958 	.word	0x0802a958
 8015f20:	0802a970 	.word	0x0802a970

08015f24 <hci_disconnect_security_block>:

// disconnect because of security block
void hci_disconnect_security_block(hci_con_handle_t con_handle){
 8015f24:	b580      	push	{r7, lr}
 8015f26:	b084      	sub	sp, #16
 8015f28:	af00      	add	r7, sp, #0
 8015f2a:	4603      	mov	r3, r0
 8015f2c:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * connection = hci_connection_for_handle(con_handle);
 8015f2e:	88fb      	ldrh	r3, [r7, #6]
 8015f30:	4618      	mov	r0, r3
 8015f32:	f7f9 fcc7 	bl	800f8c4 <hci_connection_for_handle>
 8015f36:	60f8      	str	r0, [r7, #12]
    if (!connection) return;
 8015f38:	68fb      	ldr	r3, [r7, #12]
 8015f3a:	2b00      	cmp	r3, #0
 8015f3c:	d007      	beq.n	8015f4e <hci_disconnect_security_block+0x2a>
    connection->bonding_flags |= BONDING_DISCONNECT_SECURITY_BLOCK;
 8015f3e:	68fb      	ldr	r3, [r7, #12]
 8015f40:	8a1b      	ldrh	r3, [r3, #16]
 8015f42:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8015f46:	b29a      	uxth	r2, r3
 8015f48:	68fb      	ldr	r3, [r7, #12]
 8015f4a:	821a      	strh	r2, [r3, #16]
 8015f4c:	e000      	b.n	8015f50 <hci_disconnect_security_block+0x2c>
    if (!connection) return;
 8015f4e:	bf00      	nop
}
 8015f50:	3710      	adds	r7, #16
 8015f52:	46bd      	mov	sp, r7
 8015f54:	bd80      	pop	{r7, pc}
	...

08015f58 <hci_send_cmd_va_arg>:
}

#endif

// va_list part of hci_send_cmd
int hci_send_cmd_va_arg(const hci_cmd_t *cmd, va_list argptr){
 8015f58:	b580      	push	{r7, lr}
 8015f5a:	b086      	sub	sp, #24
 8015f5c:	af00      	add	r7, sp, #0
 8015f5e:	6078      	str	r0, [r7, #4]
 8015f60:	6039      	str	r1, [r7, #0]
    if (!hci_can_send_command_packet_now()){ 
 8015f62:	f7f9 ffc1 	bl	800fee8 <hci_can_send_command_packet_now>
 8015f66:	4603      	mov	r3, r0
 8015f68:	2b00      	cmp	r3, #0
 8015f6a:	d108      	bne.n	8015f7e <hci_send_cmd_va_arg+0x26>
        log_error("hci_send_cmd called but cannot send packet now");
 8015f6c:	f241 23b1 	movw	r3, #4785	; 0x12b1
 8015f70:	4a18      	ldr	r2, [pc, #96]	; (8015fd4 <hci_send_cmd_va_arg+0x7c>)
 8015f72:	4919      	ldr	r1, [pc, #100]	; (8015fd8 <hci_send_cmd_va_arg+0x80>)
 8015f74:	2002      	movs	r0, #2
 8015f76:	f001 fa63 	bl	8017440 <hci_dump_log>
        return 0;
 8015f7a:	2300      	movs	r3, #0
 8015f7c:	e025      	b.n	8015fca <hci_send_cmd_va_arg+0x72>
    }

    // for HCI INITIALIZATION
    // log_info("hci_send_cmd: opcode %04x", cmd->opcode);
    hci_stack->last_cmd_opcode = cmd->opcode;
 8015f7e:	4b17      	ldr	r3, [pc, #92]	; (8015fdc <hci_send_cmd_va_arg+0x84>)
 8015f80:	681b      	ldr	r3, [r3, #0]
 8015f82:	687a      	ldr	r2, [r7, #4]
 8015f84:	8812      	ldrh	r2, [r2, #0]
 8015f86:	f8a3 272a 	strh.w	r2, [r3, #1834]	; 0x72a

    hci_reserve_packet_buffer();
 8015f8a:	f7fa f893 	bl	80100b4 <hci_reserve_packet_buffer>
    uint8_t * packet = hci_stack->hci_packet_buffer;
 8015f8e:	4b13      	ldr	r3, [pc, #76]	; (8015fdc <hci_send_cmd_va_arg+0x84>)
 8015f90:	681b      	ldr	r3, [r3, #0]
 8015f92:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8015f94:	617b      	str	r3, [r7, #20]
    uint16_t size = hci_cmd_create_from_template(packet, cmd, argptr);
 8015f96:	683a      	ldr	r2, [r7, #0]
 8015f98:	6879      	ldr	r1, [r7, #4]
 8015f9a:	6978      	ldr	r0, [r7, #20]
 8015f9c:	f000 fecc 	bl	8016d38 <hci_cmd_create_from_template>
 8015fa0:	4603      	mov	r3, r0
 8015fa2:	827b      	strh	r3, [r7, #18]
    int err = hci_send_cmd_packet(packet, size);
 8015fa4:	8a7b      	ldrh	r3, [r7, #18]
 8015fa6:	4619      	mov	r1, r3
 8015fa8:	6978      	ldr	r0, [r7, #20]
 8015faa:	f7ff fdfd 	bl	8015ba8 <hci_send_cmd_packet>
 8015fae:	60f8      	str	r0, [r7, #12]

    // release packet buffer on error or for synchronous transport implementations
    if ((err < 0) || hci_transport_synchronous()){
 8015fb0:	68fb      	ldr	r3, [r7, #12]
 8015fb2:	2b00      	cmp	r3, #0
 8015fb4:	db04      	blt.n	8015fc0 <hci_send_cmd_va_arg+0x68>
 8015fb6:	f7fa f8ab 	bl	8010110 <hci_transport_synchronous>
 8015fba:	4603      	mov	r3, r0
 8015fbc:	2b00      	cmp	r3, #0
 8015fbe:	d003      	beq.n	8015fc8 <hci_send_cmd_va_arg+0x70>
        hci_release_packet_buffer();
 8015fc0:	f7fa f898 	bl	80100f4 <hci_release_packet_buffer>
        hci_emit_transport_packet_sent();
 8015fc4:	f000 fa58 	bl	8016478 <hci_emit_transport_packet_sent>
    }

    return err;
 8015fc8:	68fb      	ldr	r3, [r7, #12]
}
 8015fca:	4618      	mov	r0, r3
 8015fcc:	3718      	adds	r7, #24
 8015fce:	46bd      	mov	sp, r7
 8015fd0:	bd80      	pop	{r7, pc}
 8015fd2:	bf00      	nop
 8015fd4:	0802929c 	.word	0x0802929c
 8015fd8:	0802a9b4 	.word	0x0802a9b4
 8015fdc:	20009780 	.word	0x20009780

08015fe0 <hci_send_cmd>:

/**
 * pre: numcmds >= 0 - it's allowed to send a command to the controller
 */
int hci_send_cmd(const hci_cmd_t *cmd, ...){
 8015fe0:	b40f      	push	{r0, r1, r2, r3}
 8015fe2:	b580      	push	{r7, lr}
 8015fe4:	b082      	sub	sp, #8
 8015fe6:	af00      	add	r7, sp, #0
    va_list argptr;
    va_start(argptr, cmd);
 8015fe8:	f107 0314 	add.w	r3, r7, #20
 8015fec:	603b      	str	r3, [r7, #0]
    int res = hci_send_cmd_va_arg(cmd, argptr);
 8015fee:	6839      	ldr	r1, [r7, #0]
 8015ff0:	6938      	ldr	r0, [r7, #16]
 8015ff2:	f7ff ffb1 	bl	8015f58 <hci_send_cmd_va_arg>
 8015ff6:	6078      	str	r0, [r7, #4]
    va_end(argptr);
    return res;
 8015ff8:	687b      	ldr	r3, [r7, #4]
}
 8015ffa:	4618      	mov	r0, r3
 8015ffc:	3708      	adds	r7, #8
 8015ffe:	46bd      	mov	sp, r7
 8016000:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8016004:	b004      	add	sp, #16
 8016006:	4770      	bx	lr

08016008 <hci_emit_event>:

// Create various non-HCI events. 
// TODO: generalize, use table similar to hci_create_command

static void hci_emit_event(uint8_t * event, uint16_t size, int dump){
 8016008:	b590      	push	{r4, r7, lr}
 801600a:	b089      	sub	sp, #36	; 0x24
 801600c:	af00      	add	r7, sp, #0
 801600e:	60f8      	str	r0, [r7, #12]
 8016010:	460b      	mov	r3, r1
 8016012:	607a      	str	r2, [r7, #4]
 8016014:	817b      	strh	r3, [r7, #10]
    // dump packet
    if (dump) {
 8016016:	687b      	ldr	r3, [r7, #4]
 8016018:	2b00      	cmp	r3, #0
 801601a:	d005      	beq.n	8016028 <hci_emit_event+0x20>
        hci_dump_packet( HCI_EVENT_PACKET, 0, event, size);
 801601c:	897b      	ldrh	r3, [r7, #10]
 801601e:	68fa      	ldr	r2, [r7, #12]
 8016020:	2100      	movs	r1, #0
 8016022:	2004      	movs	r0, #4
 8016024:	f001 f966 	bl	80172f4 <hci_dump_packet>
    } 

    // dispatch to all event handlers
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &hci_stack->event_handlers);
 8016028:	4b11      	ldr	r3, [pc, #68]	; (8016070 <hci_emit_event+0x68>)
 801602a:	681b      	ldr	r3, [r3, #0]
 801602c:	f103 0220 	add.w	r2, r3, #32
 8016030:	f107 0310 	add.w	r3, r7, #16
 8016034:	4611      	mov	r1, r2
 8016036:	4618      	mov	r0, r3
 8016038:	f7f8 fb89 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 801603c:	e00c      	b.n	8016058 <hci_emit_event+0x50>
        btstack_packet_callback_registration_t * entry = (btstack_packet_callback_registration_t*) btstack_linked_list_iterator_next(&it);
 801603e:	f107 0310 	add.w	r3, r7, #16
 8016042:	4618      	mov	r0, r3
 8016044:	f7f8 fbc6 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8016048:	61f8      	str	r0, [r7, #28]
        entry->callback(HCI_EVENT_PACKET, 0, event, size);
 801604a:	69fb      	ldr	r3, [r7, #28]
 801604c:	685c      	ldr	r4, [r3, #4]
 801604e:	897b      	ldrh	r3, [r7, #10]
 8016050:	68fa      	ldr	r2, [r7, #12]
 8016052:	2100      	movs	r1, #0
 8016054:	2004      	movs	r0, #4
 8016056:	47a0      	blx	r4
    while (btstack_linked_list_iterator_has_next(&it)){
 8016058:	f107 0310 	add.w	r3, r7, #16
 801605c:	4618      	mov	r0, r3
 801605e:	f7f8 fb8b 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8016062:	4603      	mov	r3, r0
 8016064:	2b00      	cmp	r3, #0
 8016066:	d1ea      	bne.n	801603e <hci_emit_event+0x36>
    }
}
 8016068:	bf00      	nop
 801606a:	3724      	adds	r7, #36	; 0x24
 801606c:	46bd      	mov	sp, r7
 801606e:	bd90      	pop	{r4, r7, pc}
 8016070:	20009780 	.word	0x20009780

08016074 <hci_emit_acl_packet>:

static void hci_emit_acl_packet(uint8_t * packet, uint16_t size){
 8016074:	b590      	push	{r4, r7, lr}
 8016076:	b083      	sub	sp, #12
 8016078:	af00      	add	r7, sp, #0
 801607a:	6078      	str	r0, [r7, #4]
 801607c:	460b      	mov	r3, r1
 801607e:	807b      	strh	r3, [r7, #2]
    if (!hci_stack->acl_packet_handler) return;
 8016080:	4b08      	ldr	r3, [pc, #32]	; (80160a4 <hci_emit_acl_packet+0x30>)
 8016082:	681b      	ldr	r3, [r3, #0]
 8016084:	699b      	ldr	r3, [r3, #24]
 8016086:	2b00      	cmp	r3, #0
 8016088:	d008      	beq.n	801609c <hci_emit_acl_packet+0x28>
    hci_stack->acl_packet_handler(HCI_ACL_DATA_PACKET, 0, packet, size);
 801608a:	4b06      	ldr	r3, [pc, #24]	; (80160a4 <hci_emit_acl_packet+0x30>)
 801608c:	681b      	ldr	r3, [r3, #0]
 801608e:	699c      	ldr	r4, [r3, #24]
 8016090:	887b      	ldrh	r3, [r7, #2]
 8016092:	687a      	ldr	r2, [r7, #4]
 8016094:	2100      	movs	r1, #0
 8016096:	2002      	movs	r0, #2
 8016098:	47a0      	blx	r4
 801609a:	e000      	b.n	801609e <hci_emit_acl_packet+0x2a>
    if (!hci_stack->acl_packet_handler) return;
 801609c:	bf00      	nop
}
 801609e:	370c      	adds	r7, #12
 80160a0:	46bd      	mov	sp, r7
 80160a2:	bd90      	pop	{r4, r7, pc}
 80160a4:	20009780 	.word	0x20009780

080160a8 <hci_notify_if_sco_can_send_now>:

#ifdef ENABLE_CLASSIC
static void hci_notify_if_sco_can_send_now(void){
 80160a8:	b590      	push	{r4, r7, lr}
 80160aa:	b083      	sub	sp, #12
 80160ac:	af00      	add	r7, sp, #0
    // notify SCO sender if waiting
    if (!hci_stack->sco_waiting_for_can_send_now) return;
 80160ae:	4b13      	ldr	r3, [pc, #76]	; (80160fc <hci_notify_if_sco_can_send_now+0x54>)
 80160b0:	681b      	ldr	r3, [r3, #0]
 80160b2:	f893 3706 	ldrb.w	r3, [r3, #1798]	; 0x706
 80160b6:	2b00      	cmp	r3, #0
 80160b8:	d01c      	beq.n	80160f4 <hci_notify_if_sco_can_send_now+0x4c>
    if (hci_can_send_sco_packet_now()){
 80160ba:	f7f9 ffdb 	bl	8010074 <hci_can_send_sco_packet_now>
 80160be:	4603      	mov	r3, r0
 80160c0:	2b00      	cmp	r3, #0
 80160c2:	d018      	beq.n	80160f6 <hci_notify_if_sco_can_send_now+0x4e>
        hci_stack->sco_waiting_for_can_send_now = 0;
 80160c4:	4b0d      	ldr	r3, [pc, #52]	; (80160fc <hci_notify_if_sco_can_send_now+0x54>)
 80160c6:	681b      	ldr	r3, [r3, #0]
 80160c8:	2200      	movs	r2, #0
 80160ca:	f883 2706 	strb.w	r2, [r3, #1798]	; 0x706
        uint8_t event[2] = { HCI_EVENT_SCO_CAN_SEND_NOW, 0 };
 80160ce:	236f      	movs	r3, #111	; 0x6f
 80160d0:	713b      	strb	r3, [r7, #4]
 80160d2:	2300      	movs	r3, #0
 80160d4:	717b      	strb	r3, [r7, #5]
        hci_dump_packet(HCI_EVENT_PACKET, 1, event, sizeof(event));
 80160d6:	1d3a      	adds	r2, r7, #4
 80160d8:	2302      	movs	r3, #2
 80160da:	2101      	movs	r1, #1
 80160dc:	2004      	movs	r0, #4
 80160de:	f001 f909 	bl	80172f4 <hci_dump_packet>
        hci_stack->sco_packet_handler(HCI_EVENT_PACKET, 0, event, sizeof(event));
 80160e2:	4b06      	ldr	r3, [pc, #24]	; (80160fc <hci_notify_if_sco_can_send_now+0x54>)
 80160e4:	681b      	ldr	r3, [r3, #0]
 80160e6:	69dc      	ldr	r4, [r3, #28]
 80160e8:	1d3a      	adds	r2, r7, #4
 80160ea:	2302      	movs	r3, #2
 80160ec:	2100      	movs	r1, #0
 80160ee:	2004      	movs	r0, #4
 80160f0:	47a0      	blx	r4
 80160f2:	e000      	b.n	80160f6 <hci_notify_if_sco_can_send_now+0x4e>
    if (!hci_stack->sco_waiting_for_can_send_now) return;
 80160f4:	bf00      	nop
    }
}
 80160f6:	370c      	adds	r7, #12
 80160f8:	46bd      	mov	sp, r7
 80160fa:	bd90      	pop	{r4, r7, pc}
 80160fc:	20009780 	.word	0x20009780

08016100 <gap_inquiry_explode>:

// parsing end emitting has been merged to reduce code size
static void gap_inquiry_explode(uint8_t *packet, uint16_t size) {
 8016100:	b580      	push	{r7, lr}
 8016102:	b09c      	sub	sp, #112	; 0x70
 8016104:	af00      	add	r7, sp, #0
 8016106:	6078      	str	r0, [r7, #4]
 8016108:	460b      	mov	r3, r1
 801610a:	807b      	strh	r3, [r7, #2]
    uint8_t * eir_data;
    ad_context_t context;
    const uint8_t * name;
    uint8_t         name_len;

    if (size < 3) return;
 801610c:	887b      	ldrh	r3, [r7, #2]
 801610e:	2b02      	cmp	r3, #2
 8016110:	f240 8128 	bls.w	8016364 <gap_inquiry_explode+0x264>

    int event_type = hci_event_packet_get_type(packet);
 8016114:	6878      	ldr	r0, [r7, #4]
 8016116:	f7f9 f9eb 	bl	800f4f0 <hci_event_packet_get_type>
 801611a:	4603      	mov	r3, r0
 801611c:	65fb      	str	r3, [r7, #92]	; 0x5c
    int num_reserved_fields = (event_type == HCI_EVENT_INQUIRY_RESULT) ? 2 : 1;    // 2 for old event, 1 otherwise
 801611e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8016120:	2b02      	cmp	r3, #2
 8016122:	d101      	bne.n	8016128 <gap_inquiry_explode+0x28>
 8016124:	2302      	movs	r3, #2
 8016126:	e000      	b.n	801612a <gap_inquiry_explode+0x2a>
 8016128:	2301      	movs	r3, #1
 801612a:	65bb      	str	r3, [r7, #88]	; 0x58
    int num_responses       = hci_event_inquiry_result_get_num_responses(packet);
 801612c:	6878      	ldr	r0, [r7, #4]
 801612e:	f7f9 f9eb 	bl	800f508 <hci_event_inquiry_result_get_num_responses>
 8016132:	4603      	mov	r3, r0
 8016134:	657b      	str	r3, [r7, #84]	; 0x54

    switch (event_type){
 8016136:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8016138:	2b22      	cmp	r3, #34	; 0x22
 801613a:	d004      	beq.n	8016146 <gap_inquiry_explode+0x46>
 801613c:	2b2f      	cmp	r3, #47	; 0x2f
 801613e:	d00c      	beq.n	801615a <gap_inquiry_explode+0x5a>
 8016140:	2b02      	cmp	r3, #2
 8016142:	d000      	beq.n	8016146 <gap_inquiry_explode+0x46>
        case HCI_EVENT_EXTENDED_INQUIRY_RESPONSE:
            if (size != 257) return;
            if (num_responses != 1) return;
            break;
        default:
            return;
 8016144:	e113      	b.n	801636e <gap_inquiry_explode+0x26e>
            if (size != (3 + (num_responses * 14))) return;
 8016146:	8879      	ldrh	r1, [r7, #2]
 8016148:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801614a:	4613      	mov	r3, r2
 801614c:	00db      	lsls	r3, r3, #3
 801614e:	1a9b      	subs	r3, r3, r2
 8016150:	005b      	lsls	r3, r3, #1
 8016152:	3303      	adds	r3, #3
 8016154:	4299      	cmp	r1, r3
 8016156:	d00b      	beq.n	8016170 <gap_inquiry_explode+0x70>
 8016158:	e109      	b.n	801636e <gap_inquiry_explode+0x26e>
            if (size != 257) return;
 801615a:	887b      	ldrh	r3, [r7, #2]
 801615c:	f240 1201 	movw	r2, #257	; 0x101
 8016160:	4293      	cmp	r3, r2
 8016162:	f040 8101 	bne.w	8016368 <gap_inquiry_explode+0x268>
            if (num_responses != 1) return;
 8016166:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016168:	2b01      	cmp	r3, #1
 801616a:	f040 80ff 	bne.w	801636c <gap_inquiry_explode+0x26c>
            break;
 801616e:	e000      	b.n	8016172 <gap_inquiry_explode+0x72>
            break;
 8016170:	bf00      	nop
    }

    // event[1] is set at the end
    int i;
    for (i=0; i<num_responses;i++){
 8016172:	2300      	movs	r3, #0
 8016174:	667b      	str	r3, [r7, #100]	; 0x64
 8016176:	e0ef      	b.n	8016358 <gap_inquiry_explode+0x258>
        memset(event, 0, sizeof(event));
 8016178:	f107 0310 	add.w	r3, r7, #16
 801617c:	2233      	movs	r2, #51	; 0x33
 801617e:	2100      	movs	r1, #0
 8016180:	4618      	mov	r0, r3
 8016182:	f011 fc9e 	bl	8027ac2 <memset>
        event[0] = GAP_EVENT_INQUIRY_RESULT;
 8016186:	23e3      	movs	r3, #227	; 0xe3
 8016188:	743b      	strb	r3, [r7, #16]
        uint8_t event_size = 18;    // if name is not set by EIR
 801618a:	2312      	movs	r3, #18
 801618c:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63

        (void)memcpy(&event[2], &packet[3 + (i * 6)], 6); // bd_addr
 8016190:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8016192:	4613      	mov	r3, r2
 8016194:	005b      	lsls	r3, r3, #1
 8016196:	4413      	add	r3, r2
 8016198:	005b      	lsls	r3, r3, #1
 801619a:	3303      	adds	r3, #3
 801619c:	461a      	mov	r2, r3
 801619e:	687b      	ldr	r3, [r7, #4]
 80161a0:	1899      	adds	r1, r3, r2
 80161a2:	f107 0310 	add.w	r3, r7, #16
 80161a6:	3302      	adds	r3, #2
 80161a8:	2206      	movs	r2, #6
 80161aa:	4618      	mov	r0, r3
 80161ac:	f011 fc65 	bl	8027a7a <memcpy>
        event[8] =          packet[3 + (num_responses*(6))                         + (i*1)];     // page_scan_repetition_mode
 80161b0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80161b2:	4613      	mov	r3, r2
 80161b4:	005b      	lsls	r3, r3, #1
 80161b6:	4413      	add	r3, r2
 80161b8:	005b      	lsls	r3, r3, #1
 80161ba:	1cda      	adds	r2, r3, #3
 80161bc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80161be:	4413      	add	r3, r2
 80161c0:	461a      	mov	r2, r3
 80161c2:	687b      	ldr	r3, [r7, #4]
 80161c4:	4413      	add	r3, r2
 80161c6:	781b      	ldrb	r3, [r3, #0]
 80161c8:	763b      	strb	r3, [r7, #24]
        (void)memcpy(&event[9],
                     &packet[3 + (num_responses * (6 + 1 + num_reserved_fields)) + (i * 3)],
 80161ca:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161cc:	3307      	adds	r3, #7
 80161ce:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80161d0:	fb02 f303 	mul.w	r3, r2, r3
 80161d4:	1cd9      	adds	r1, r3, #3
 80161d6:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80161d8:	4613      	mov	r3, r2
 80161da:	005b      	lsls	r3, r3, #1
 80161dc:	4413      	add	r3, r2
 80161de:	440b      	add	r3, r1
 80161e0:	461a      	mov	r2, r3
 80161e2:	687b      	ldr	r3, [r7, #4]
 80161e4:	1899      	adds	r1, r3, r2
        (void)memcpy(&event[9],
 80161e6:	f107 0310 	add.w	r3, r7, #16
 80161ea:	3309      	adds	r3, #9
 80161ec:	2203      	movs	r2, #3
 80161ee:	4618      	mov	r0, r3
 80161f0:	f011 fc43 	bl	8027a7a <memcpy>
                     3); // class of device
        (void)memcpy(&event[12],
                     &packet[3 + (num_responses * (6 + 1 + num_reserved_fields + 3)) + (i * 2)],
 80161f4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161f6:	330a      	adds	r3, #10
 80161f8:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80161fa:	fb02 f303 	mul.w	r3, r2, r3
 80161fe:	1cda      	adds	r2, r3, #3
 8016200:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8016202:	005b      	lsls	r3, r3, #1
 8016204:	4413      	add	r3, r2
 8016206:	461a      	mov	r2, r3
 8016208:	687b      	ldr	r3, [r7, #4]
 801620a:	4413      	add	r3, r2
        (void)memcpy(&event[12],
 801620c:	881b      	ldrh	r3, [r3, #0]
 801620e:	b29b      	uxth	r3, r3
 8016210:	83bb      	strh	r3, [r7, #28]
                     2); // clock offset

        switch (event_type){
 8016212:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8016214:	2b22      	cmp	r3, #34	; 0x22
 8016216:	d005      	beq.n	8016224 <gap_inquiry_explode+0x124>
 8016218:	2b2f      	cmp	r3, #47	; 0x2f
 801621a:	d013      	beq.n	8016244 <gap_inquiry_explode+0x144>
 801621c:	2b02      	cmp	r3, #2
 801621e:	f000 8087 	beq.w	8016330 <gap_inquiry_explode+0x230>
                    (void)memcpy(&event[18], name, len);
                    event_size += len;
                }
                break;
            default:
                return;
 8016222:	e0a4      	b.n	801636e <gap_inquiry_explode+0x26e>
                event[14] = 1;
 8016224:	2301      	movs	r3, #1
 8016226:	77bb      	strb	r3, [r7, #30]
                event[15] = packet [3 + (num_responses*(6+1+num_reserved_fields+3+2)) + (i*1)]; // rssi
 8016228:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801622a:	330c      	adds	r3, #12
 801622c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801622e:	fb02 f303 	mul.w	r3, r2, r3
 8016232:	1cda      	adds	r2, r3, #3
 8016234:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8016236:	4413      	add	r3, r2
 8016238:	461a      	mov	r2, r3
 801623a:	687b      	ldr	r3, [r7, #4]
 801623c:	4413      	add	r3, r2
 801623e:	781b      	ldrb	r3, [r3, #0]
 8016240:	77fb      	strb	r3, [r7, #31]
                break;
 8016242:	e078      	b.n	8016336 <gap_inquiry_explode+0x236>
                event[14] = 1;
 8016244:	2301      	movs	r3, #1
 8016246:	77bb      	strb	r3, [r7, #30]
                event[15] = packet [3 + (num_responses*(6+1+num_reserved_fields+3+2)) + (i*1)]; // rssi
 8016248:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801624a:	330c      	adds	r3, #12
 801624c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801624e:	fb02 f303 	mul.w	r3, r2, r3
 8016252:	1cda      	adds	r2, r3, #3
 8016254:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8016256:	4413      	add	r3, r2
 8016258:	461a      	mov	r2, r3
 801625a:	687b      	ldr	r3, [r7, #4]
 801625c:	4413      	add	r3, r2
 801625e:	781b      	ldrb	r3, [r3, #0]
 8016260:	77fb      	strb	r3, [r7, #31]
                eir_data = &packet[3 + (6+1+num_reserved_fields+3+2+1)];
 8016262:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016264:	3310      	adds	r3, #16
 8016266:	461a      	mov	r2, r3
 8016268:	687b      	ldr	r3, [r7, #4]
 801626a:	4413      	add	r3, r2
 801626c:	653b      	str	r3, [r7, #80]	; 0x50
                name = NULL;
 801626e:	2300      	movs	r3, #0
 8016270:	66fb      	str	r3, [r7, #108]	; 0x6c
                for (ad_iterator_init(&context, EXTENDED_INQUIRY_RESPONSE_DATA_LEN, eir_data) ; ad_iterator_has_more(&context) ; ad_iterator_next(&context)){
 8016272:	f107 0308 	add.w	r3, r7, #8
 8016276:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8016278:	21f0      	movs	r1, #240	; 0xf0
 801627a:	4618      	mov	r0, r3
 801627c:	f7f6 ff74 	bl	800d168 <ad_iterator_init>
 8016280:	e02c      	b.n	80162dc <gap_inquiry_explode+0x1dc>
                    uint8_t data_type    = ad_iterator_get_data_type(&context);
 8016282:	f107 0308 	add.w	r3, r7, #8
 8016286:	4618      	mov	r0, r3
 8016288:	f7f6 ffdc 	bl	800d244 <ad_iterator_get_data_type>
 801628c:	4603      	mov	r3, r0
 801628e:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
                    uint8_t data_size    = ad_iterator_get_data_len(&context);
 8016292:	f107 0308 	add.w	r3, r7, #8
 8016296:	4618      	mov	r0, r3
 8016298:	f7f6 ffc2 	bl	800d220 <ad_iterator_get_data_len>
 801629c:	4603      	mov	r3, r0
 801629e:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
                    const uint8_t * data = ad_iterator_get_data(&context);
 80162a2:	f107 0308 	add.w	r3, r7, #8
 80162a6:	4618      	mov	r0, r3
 80162a8:	f7f6 ffdd 	bl	800d266 <ad_iterator_get_data>
 80162ac:	6478      	str	r0, [r7, #68]	; 0x44
                    switch (data_type){
 80162ae:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 80162b2:	2b08      	cmp	r3, #8
 80162b4:	d002      	beq.n	80162bc <gap_inquiry_explode+0x1bc>
 80162b6:	2b09      	cmp	r3, #9
 80162b8:	d003      	beq.n	80162c2 <gap_inquiry_explode+0x1c2>
                            break;
 80162ba:	e00a      	b.n	80162d2 <gap_inquiry_explode+0x1d2>
                            if (name) continue;
 80162bc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80162be:	2b00      	cmp	r3, #0
 80162c0:	d106      	bne.n	80162d0 <gap_inquiry_explode+0x1d0>
                            name = data;
 80162c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80162c4:	66fb      	str	r3, [r7, #108]	; 0x6c
                            name_len = data_size;
 80162c6:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
 80162ca:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
                            break;
 80162ce:	e000      	b.n	80162d2 <gap_inquiry_explode+0x1d2>
                            if (name) continue;
 80162d0:	bf00      	nop
                for (ad_iterator_init(&context, EXTENDED_INQUIRY_RESPONSE_DATA_LEN, eir_data) ; ad_iterator_has_more(&context) ; ad_iterator_next(&context)){
 80162d2:	f107 0308 	add.w	r3, r7, #8
 80162d6:	4618      	mov	r0, r3
 80162d8:	f7f6 ff88 	bl	800d1ec <ad_iterator_next>
 80162dc:	f107 0308 	add.w	r3, r7, #8
 80162e0:	4618      	mov	r0, r3
 80162e2:	f7f6 ff57 	bl	800d194 <ad_iterator_has_more>
 80162e6:	4603      	mov	r3, r0
 80162e8:	2b00      	cmp	r3, #0
 80162ea:	d1ca      	bne.n	8016282 <gap_inquiry_explode+0x182>
                if (name){
 80162ec:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80162ee:	2b00      	cmp	r3, #0
 80162f0:	d020      	beq.n	8016334 <gap_inquiry_explode+0x234>
                    event[16] = 1;
 80162f2:	2301      	movs	r3, #1
 80162f4:	f887 3020 	strb.w	r3, [r7, #32]
                    int len = btstack_min(name_len, GAP_INQUIRY_MAX_NAME_LEN);
 80162f8:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 80162fc:	2120      	movs	r1, #32
 80162fe:	4618      	mov	r0, r3
 8016300:	f7f8 ff05 	bl	800f10e <btstack_min>
 8016304:	4603      	mov	r3, r0
 8016306:	64fb      	str	r3, [r7, #76]	; 0x4c
                    event[17] = len;
 8016308:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801630a:	b2db      	uxtb	r3, r3
 801630c:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
                    (void)memcpy(&event[18], name, len);
 8016310:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8016312:	f107 0310 	add.w	r3, r7, #16
 8016316:	3312      	adds	r3, #18
 8016318:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 801631a:	4618      	mov	r0, r3
 801631c:	f011 fbad 	bl	8027a7a <memcpy>
                    event_size += len;
 8016320:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016322:	b2da      	uxtb	r2, r3
 8016324:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 8016328:	4413      	add	r3, r2
 801632a:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
                break;
 801632e:	e001      	b.n	8016334 <gap_inquiry_explode+0x234>
                break;
 8016330:	bf00      	nop
 8016332:	e000      	b.n	8016336 <gap_inquiry_explode+0x236>
                break;
 8016334:	bf00      	nop
        }
        event[1] = event_size - 2;
 8016336:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 801633a:	3b02      	subs	r3, #2
 801633c:	b2db      	uxtb	r3, r3
 801633e:	747b      	strb	r3, [r7, #17]
        hci_emit_event(event, event_size, 1);
 8016340:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 8016344:	b299      	uxth	r1, r3
 8016346:	f107 0310 	add.w	r3, r7, #16
 801634a:	2201      	movs	r2, #1
 801634c:	4618      	mov	r0, r3
 801634e:	f7ff fe5b 	bl	8016008 <hci_emit_event>
    for (i=0; i<num_responses;i++){
 8016352:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8016354:	3301      	adds	r3, #1
 8016356:	667b      	str	r3, [r7, #100]	; 0x64
 8016358:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801635a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801635c:	429a      	cmp	r2, r3
 801635e:	f6ff af0b 	blt.w	8016178 <gap_inquiry_explode+0x78>
 8016362:	e004      	b.n	801636e <gap_inquiry_explode+0x26e>
    if (size < 3) return;
 8016364:	bf00      	nop
 8016366:	e002      	b.n	801636e <gap_inquiry_explode+0x26e>
            if (size != 257) return;
 8016368:	bf00      	nop
 801636a:	e000      	b.n	801636e <gap_inquiry_explode+0x26e>
            if (num_responses != 1) return;
 801636c:	bf00      	nop
    }
}
 801636e:	3770      	adds	r7, #112	; 0x70
 8016370:	46bd      	mov	sp, r7
 8016372:	bd80      	pop	{r7, pc}

08016374 <hci_emit_state>:
#endif

void hci_emit_state(void){
 8016374:	b580      	push	{r7, lr}
 8016376:	b084      	sub	sp, #16
 8016378:	af02      	add	r7, sp, #8
    log_info("BTSTACK_EVENT_STATE %u", hci_stack->state);
 801637a:	4b0f      	ldr	r3, [pc, #60]	; (80163b8 <hci_emit_state+0x44>)
 801637c:	681b      	ldr	r3, [r3, #0]
 801637e:	f893 3716 	ldrb.w	r3, [r3, #1814]	; 0x716
 8016382:	9300      	str	r3, [sp, #0]
 8016384:	f241 3355 	movw	r3, #4949	; 0x1355
 8016388:	4a0c      	ldr	r2, [pc, #48]	; (80163bc <hci_emit_state+0x48>)
 801638a:	490d      	ldr	r1, [pc, #52]	; (80163c0 <hci_emit_state+0x4c>)
 801638c:	2001      	movs	r0, #1
 801638e:	f001 f857 	bl	8017440 <hci_dump_log>
    uint8_t event[3];
    event[0] = BTSTACK_EVENT_STATE;
 8016392:	2360      	movs	r3, #96	; 0x60
 8016394:	713b      	strb	r3, [r7, #4]
    event[1] = sizeof(event) - 2u;
 8016396:	2301      	movs	r3, #1
 8016398:	717b      	strb	r3, [r7, #5]
    event[2] = hci_stack->state;
 801639a:	4b07      	ldr	r3, [pc, #28]	; (80163b8 <hci_emit_state+0x44>)
 801639c:	681b      	ldr	r3, [r3, #0]
 801639e:	f893 3716 	ldrb.w	r3, [r3, #1814]	; 0x716
 80163a2:	71bb      	strb	r3, [r7, #6]
    hci_emit_event(event, sizeof(event), 1);
 80163a4:	1d3b      	adds	r3, r7, #4
 80163a6:	2201      	movs	r2, #1
 80163a8:	2103      	movs	r1, #3
 80163aa:	4618      	mov	r0, r3
 80163ac:	f7ff fe2c 	bl	8016008 <hci_emit_event>
}
 80163b0:	bf00      	nop
 80163b2:	3708      	adds	r7, #8
 80163b4:	46bd      	mov	sp, r7
 80163b6:	bd80      	pop	{r7, pc}
 80163b8:	20009780 	.word	0x20009780
 80163bc:	0802929c 	.word	0x0802929c
 80163c0:	0802a9ec 	.word	0x0802a9ec

080163c4 <hci_emit_connection_complete>:

#ifdef ENABLE_CLASSIC
static void hci_emit_connection_complete(bd_addr_t address, hci_con_handle_t con_handle, uint8_t status){
 80163c4:	b580      	push	{r7, lr}
 80163c6:	b086      	sub	sp, #24
 80163c8:	af00      	add	r7, sp, #0
 80163ca:	6078      	str	r0, [r7, #4]
 80163cc:	460b      	mov	r3, r1
 80163ce:	807b      	strh	r3, [r7, #2]
 80163d0:	4613      	mov	r3, r2
 80163d2:	707b      	strb	r3, [r7, #1]
    uint8_t event[13];
    event[0] = HCI_EVENT_CONNECTION_COMPLETE;
 80163d4:	2303      	movs	r3, #3
 80163d6:	723b      	strb	r3, [r7, #8]
    event[1] = sizeof(event) - 2;
 80163d8:	230b      	movs	r3, #11
 80163da:	727b      	strb	r3, [r7, #9]
    event[2] = status;
 80163dc:	787b      	ldrb	r3, [r7, #1]
 80163de:	72bb      	strb	r3, [r7, #10]
    little_endian_store_16(event, 3, con_handle);
 80163e0:	887a      	ldrh	r2, [r7, #2]
 80163e2:	f107 0308 	add.w	r3, r7, #8
 80163e6:	2103      	movs	r1, #3
 80163e8:	4618      	mov	r0, r3
 80163ea:	f7f8 fd3c 	bl	800ee66 <little_endian_store_16>
    reverse_bd_addr(address, &event[5]);
 80163ee:	f107 0308 	add.w	r3, r7, #8
 80163f2:	3305      	adds	r3, #5
 80163f4:	4619      	mov	r1, r3
 80163f6:	6878      	ldr	r0, [r7, #4]
 80163f8:	f7f8 fe7b 	bl	800f0f2 <reverse_bd_addr>
    event[11] = 1; // ACL connection
 80163fc:	2301      	movs	r3, #1
 80163fe:	74fb      	strb	r3, [r7, #19]
    event[12] = 0; // encryption disabled
 8016400:	2300      	movs	r3, #0
 8016402:	753b      	strb	r3, [r7, #20]
    hci_emit_event(event, sizeof(event), 1);
 8016404:	f107 0308 	add.w	r3, r7, #8
 8016408:	2201      	movs	r2, #1
 801640a:	210d      	movs	r1, #13
 801640c:	4618      	mov	r0, r3
 801640e:	f7ff fdfb 	bl	8016008 <hci_emit_event>
}
 8016412:	bf00      	nop
 8016414:	3718      	adds	r7, #24
 8016416:	46bd      	mov	sp, r7
 8016418:	bd80      	pop	{r7, pc}
	...

0801641c <hci_emit_l2cap_check_timeout>:
static void hci_emit_l2cap_check_timeout(hci_connection_t *conn){
 801641c:	b580      	push	{r7, lr}
 801641e:	b084      	sub	sp, #16
 8016420:	af00      	add	r7, sp, #0
 8016422:	6078      	str	r0, [r7, #4]
    if (disable_l2cap_timeouts) return;
 8016424:	4b11      	ldr	r3, [pc, #68]	; (801646c <hci_emit_l2cap_check_timeout+0x50>)
 8016426:	781b      	ldrb	r3, [r3, #0]
 8016428:	2b00      	cmp	r3, #0
 801642a:	d11a      	bne.n	8016462 <hci_emit_l2cap_check_timeout+0x46>
    log_info("L2CAP_EVENT_TIMEOUT_CHECK");
 801642c:	f241 336b 	movw	r3, #4971	; 0x136b
 8016430:	4a0f      	ldr	r2, [pc, #60]	; (8016470 <hci_emit_l2cap_check_timeout+0x54>)
 8016432:	4910      	ldr	r1, [pc, #64]	; (8016474 <hci_emit_l2cap_check_timeout+0x58>)
 8016434:	2001      	movs	r0, #1
 8016436:	f001 f803 	bl	8017440 <hci_dump_log>
    uint8_t event[4];
    event[0] = L2CAP_EVENT_TIMEOUT_CHECK;
 801643a:	2373      	movs	r3, #115	; 0x73
 801643c:	733b      	strb	r3, [r7, #12]
    event[1] = sizeof(event) - 2;
 801643e:	2302      	movs	r3, #2
 8016440:	737b      	strb	r3, [r7, #13]
    little_endian_store_16(event, 2, conn->con_handle);
 8016442:	687b      	ldr	r3, [r7, #4]
 8016444:	895a      	ldrh	r2, [r3, #10]
 8016446:	f107 030c 	add.w	r3, r7, #12
 801644a:	2102      	movs	r1, #2
 801644c:	4618      	mov	r0, r3
 801644e:	f7f8 fd0a 	bl	800ee66 <little_endian_store_16>
    hci_emit_event(event, sizeof(event), 1);
 8016452:	f107 030c 	add.w	r3, r7, #12
 8016456:	2201      	movs	r2, #1
 8016458:	2104      	movs	r1, #4
 801645a:	4618      	mov	r0, r3
 801645c:	f7ff fdd4 	bl	8016008 <hci_emit_event>
 8016460:	e000      	b.n	8016464 <hci_emit_l2cap_check_timeout+0x48>
    if (disable_l2cap_timeouts) return;
 8016462:	bf00      	nop
}
 8016464:	3710      	adds	r7, #16
 8016466:	46bd      	mov	sp, r7
 8016468:	bd80      	pop	{r7, pc}
 801646a:	bf00      	nop
 801646c:	20009784 	.word	0x20009784
 8016470:	0802929c 	.word	0x0802929c
 8016474:	0802aa0c 	.word	0x0802aa0c

08016478 <hci_emit_transport_packet_sent>:
    hci_emit_event(event, sizeof(event), 1);
}
#endif
#endif

static void hci_emit_transport_packet_sent(void){
 8016478:	b580      	push	{r7, lr}
 801647a:	b082      	sub	sp, #8
 801647c:	af00      	add	r7, sp, #0
    // notify upper stack that it might be possible to send again
    uint8_t event[] = { HCI_EVENT_TRANSPORT_PACKET_SENT, 0};
 801647e:	236e      	movs	r3, #110	; 0x6e
 8016480:	713b      	strb	r3, [r7, #4]
 8016482:	2300      	movs	r3, #0
 8016484:	717b      	strb	r3, [r7, #5]
    hci_emit_event(&event[0], sizeof(event), 0);  // don't dump
 8016486:	1d3b      	adds	r3, r7, #4
 8016488:	2200      	movs	r2, #0
 801648a:	2102      	movs	r1, #2
 801648c:	4618      	mov	r0, r3
 801648e:	f7ff fdbb 	bl	8016008 <hci_emit_event>
}
 8016492:	bf00      	nop
 8016494:	3708      	adds	r7, #8
 8016496:	46bd      	mov	sp, r7
 8016498:	bd80      	pop	{r7, pc}

0801649a <hci_emit_disconnection_complete>:

static void hci_emit_disconnection_complete(hci_con_handle_t con_handle, uint8_t reason){
 801649a:	b580      	push	{r7, lr}
 801649c:	b084      	sub	sp, #16
 801649e:	af00      	add	r7, sp, #0
 80164a0:	4603      	mov	r3, r0
 80164a2:	460a      	mov	r2, r1
 80164a4:	80fb      	strh	r3, [r7, #6]
 80164a6:	4613      	mov	r3, r2
 80164a8:	717b      	strb	r3, [r7, #5]
    uint8_t event[6];
    event[0] = HCI_EVENT_DISCONNECTION_COMPLETE;
 80164aa:	2305      	movs	r3, #5
 80164ac:	723b      	strb	r3, [r7, #8]
    event[1] = sizeof(event) - 2u;
 80164ae:	2304      	movs	r3, #4
 80164b0:	727b      	strb	r3, [r7, #9]
    event[2] = 0; // status = OK
 80164b2:	2300      	movs	r3, #0
 80164b4:	72bb      	strb	r3, [r7, #10]
    little_endian_store_16(event, 3, con_handle);
 80164b6:	88fa      	ldrh	r2, [r7, #6]
 80164b8:	f107 0308 	add.w	r3, r7, #8
 80164bc:	2103      	movs	r1, #3
 80164be:	4618      	mov	r0, r3
 80164c0:	f7f8 fcd1 	bl	800ee66 <little_endian_store_16>
    event[5] = reason;
 80164c4:	797b      	ldrb	r3, [r7, #5]
 80164c6:	737b      	strb	r3, [r7, #13]
    hci_emit_event(event, sizeof(event), 1);
 80164c8:	f107 0308 	add.w	r3, r7, #8
 80164cc:	2201      	movs	r2, #1
 80164ce:	2106      	movs	r1, #6
 80164d0:	4618      	mov	r0, r3
 80164d2:	f7ff fd99 	bl	8016008 <hci_emit_event>
}
 80164d6:	bf00      	nop
 80164d8:	3710      	adds	r7, #16
 80164da:	46bd      	mov	sp, r7
 80164dc:	bd80      	pop	{r7, pc}
	...

080164e0 <hci_emit_nr_connections_changed>:

static void hci_emit_nr_connections_changed(void){
 80164e0:	b580      	push	{r7, lr}
 80164e2:	b084      	sub	sp, #16
 80164e4:	af02      	add	r7, sp, #8
    log_info("BTSTACK_EVENT_NR_CONNECTIONS_CHANGED %u", nr_hci_connections());
 80164e6:	f7f9 fb7f 	bl	800fbe8 <nr_hci_connections>
 80164ea:	4603      	mov	r3, r0
 80164ec:	9300      	str	r3, [sp, #0]
 80164ee:	f241 339a 	movw	r3, #5018	; 0x139a
 80164f2:	4a0c      	ldr	r2, [pc, #48]	; (8016524 <hci_emit_nr_connections_changed+0x44>)
 80164f4:	490c      	ldr	r1, [pc, #48]	; (8016528 <hci_emit_nr_connections_changed+0x48>)
 80164f6:	2001      	movs	r0, #1
 80164f8:	f000 ffa2 	bl	8017440 <hci_dump_log>
    uint8_t event[3];
    event[0] = BTSTACK_EVENT_NR_CONNECTIONS_CHANGED;
 80164fc:	2361      	movs	r3, #97	; 0x61
 80164fe:	713b      	strb	r3, [r7, #4]
    event[1] = sizeof(event) - 2u;
 8016500:	2301      	movs	r3, #1
 8016502:	717b      	strb	r3, [r7, #5]
    event[2] = nr_hci_connections();
 8016504:	f7f9 fb70 	bl	800fbe8 <nr_hci_connections>
 8016508:	4603      	mov	r3, r0
 801650a:	b2db      	uxtb	r3, r3
 801650c:	71bb      	strb	r3, [r7, #6]
    hci_emit_event(event, sizeof(event), 1);
 801650e:	1d3b      	adds	r3, r7, #4
 8016510:	2201      	movs	r2, #1
 8016512:	2103      	movs	r1, #3
 8016514:	4618      	mov	r0, r3
 8016516:	f7ff fd77 	bl	8016008 <hci_emit_event>
}
 801651a:	bf00      	nop
 801651c:	3708      	adds	r7, #8
 801651e:	46bd      	mov	sp, r7
 8016520:	bd80      	pop	{r7, pc}
 8016522:	bf00      	nop
 8016524:	0802929c 	.word	0x0802929c
 8016528:	0802aa30 	.word	0x0802aa30

0801652c <hci_emit_hci_open_failed>:

static void hci_emit_hci_open_failed(void){
 801652c:	b580      	push	{r7, lr}
 801652e:	b082      	sub	sp, #8
 8016530:	af00      	add	r7, sp, #0
    log_info("BTSTACK_EVENT_POWERON_FAILED");
 8016532:	f241 33a3 	movw	r3, #5027	; 0x13a3
 8016536:	4a09      	ldr	r2, [pc, #36]	; (801655c <hci_emit_hci_open_failed+0x30>)
 8016538:	4909      	ldr	r1, [pc, #36]	; (8016560 <hci_emit_hci_open_failed+0x34>)
 801653a:	2001      	movs	r0, #1
 801653c:	f000 ff80 	bl	8017440 <hci_dump_log>
    uint8_t event[2];
    event[0] = BTSTACK_EVENT_POWERON_FAILED;
 8016540:	2362      	movs	r3, #98	; 0x62
 8016542:	713b      	strb	r3, [r7, #4]
    event[1] = sizeof(event) - 2u;
 8016544:	2300      	movs	r3, #0
 8016546:	717b      	strb	r3, [r7, #5]
    hci_emit_event(event, sizeof(event), 1);
 8016548:	1d3b      	adds	r3, r7, #4
 801654a:	2201      	movs	r2, #1
 801654c:	2102      	movs	r1, #2
 801654e:	4618      	mov	r0, r3
 8016550:	f7ff fd5a 	bl	8016008 <hci_emit_event>
}
 8016554:	bf00      	nop
 8016556:	3708      	adds	r7, #8
 8016558:	46bd      	mov	sp, r7
 801655a:	bd80      	pop	{r7, pc}
 801655c:	0802929c 	.word	0x0802929c
 8016560:	0802aa60 	.word	0x0802aa60

08016564 <hci_emit_dedicated_bonding_result>:

static void hci_emit_dedicated_bonding_result(bd_addr_t address, uint8_t status){
 8016564:	b580      	push	{r7, lr}
 8016566:	b088      	sub	sp, #32
 8016568:	af02      	add	r7, sp, #8
 801656a:	6078      	str	r0, [r7, #4]
 801656c:	460b      	mov	r3, r1
 801656e:	70fb      	strb	r3, [r7, #3]
    log_info("hci_emit_dedicated_bonding_result %u ", status);
 8016570:	78fb      	ldrb	r3, [r7, #3]
 8016572:	9300      	str	r3, [sp, #0]
 8016574:	f241 33ab 	movw	r3, #5035	; 0x13ab
 8016578:	4a1a      	ldr	r2, [pc, #104]	; (80165e4 <hci_emit_dedicated_bonding_result+0x80>)
 801657a:	491b      	ldr	r1, [pc, #108]	; (80165e8 <hci_emit_dedicated_bonding_result+0x84>)
 801657c:	2001      	movs	r0, #1
 801657e:	f000 ff5f 	bl	8017440 <hci_dump_log>
    uint8_t event[9];
    int pos = 0;
 8016582:	2300      	movs	r3, #0
 8016584:	617b      	str	r3, [r7, #20]
    event[pos++] = GAP_EVENT_DEDICATED_BONDING_COMPLETED;
 8016586:	697b      	ldr	r3, [r7, #20]
 8016588:	1c5a      	adds	r2, r3, #1
 801658a:	617a      	str	r2, [r7, #20]
 801658c:	f107 0218 	add.w	r2, r7, #24
 8016590:	4413      	add	r3, r2
 8016592:	22e1      	movs	r2, #225	; 0xe1
 8016594:	f803 2c10 	strb.w	r2, [r3, #-16]
    event[pos++] = sizeof(event) - 2u;
 8016598:	697b      	ldr	r3, [r7, #20]
 801659a:	1c5a      	adds	r2, r3, #1
 801659c:	617a      	str	r2, [r7, #20]
 801659e:	f107 0218 	add.w	r2, r7, #24
 80165a2:	4413      	add	r3, r2
 80165a4:	2207      	movs	r2, #7
 80165a6:	f803 2c10 	strb.w	r2, [r3, #-16]
    event[pos++] = status;
 80165aa:	697b      	ldr	r3, [r7, #20]
 80165ac:	1c5a      	adds	r2, r3, #1
 80165ae:	617a      	str	r2, [r7, #20]
 80165b0:	f107 0218 	add.w	r2, r7, #24
 80165b4:	4413      	add	r3, r2
 80165b6:	78fa      	ldrb	r2, [r7, #3]
 80165b8:	f803 2c10 	strb.w	r2, [r3, #-16]
    reverse_bd_addr(address, &event[pos]);
 80165bc:	f107 0208 	add.w	r2, r7, #8
 80165c0:	697b      	ldr	r3, [r7, #20]
 80165c2:	4413      	add	r3, r2
 80165c4:	4619      	mov	r1, r3
 80165c6:	6878      	ldr	r0, [r7, #4]
 80165c8:	f7f8 fd93 	bl	800f0f2 <reverse_bd_addr>
    hci_emit_event(event, sizeof(event), 1);
 80165cc:	f107 0308 	add.w	r3, r7, #8
 80165d0:	2201      	movs	r2, #1
 80165d2:	2109      	movs	r1, #9
 80165d4:	4618      	mov	r0, r3
 80165d6:	f7ff fd17 	bl	8016008 <hci_emit_event>
}
 80165da:	bf00      	nop
 80165dc:	3718      	adds	r7, #24
 80165de:	46bd      	mov	sp, r7
 80165e0:	bd80      	pop	{r7, pc}
 80165e2:	bf00      	nop
 80165e4:	0802929c 	.word	0x0802929c
 80165e8:	0802aa84 	.word	0x0802aa84

080165ec <hci_emit_security_level>:


#ifdef ENABLE_CLASSIC

static void hci_emit_security_level(hci_con_handle_t con_handle, gap_security_level_t level){
 80165ec:	b580      	push	{r7, lr}
 80165ee:	b088      	sub	sp, #32
 80165f0:	af02      	add	r7, sp, #8
 80165f2:	4603      	mov	r3, r0
 80165f4:	460a      	mov	r2, r1
 80165f6:	80fb      	strh	r3, [r7, #6]
 80165f8:	4613      	mov	r3, r2
 80165fa:	717b      	strb	r3, [r7, #5]
    log_info("hci_emit_security_level %u for handle %x", level, con_handle);
 80165fc:	797b      	ldrb	r3, [r7, #5]
 80165fe:	88fa      	ldrh	r2, [r7, #6]
 8016600:	9201      	str	r2, [sp, #4]
 8016602:	9300      	str	r3, [sp, #0]
 8016604:	f241 33b9 	movw	r3, #5049	; 0x13b9
 8016608:	4a1b      	ldr	r2, [pc, #108]	; (8016678 <hci_emit_security_level+0x8c>)
 801660a:	491c      	ldr	r1, [pc, #112]	; (801667c <hci_emit_security_level+0x90>)
 801660c:	2001      	movs	r0, #1
 801660e:	f000 ff17 	bl	8017440 <hci_dump_log>
    uint8_t event[5];
    int pos = 0;
 8016612:	2300      	movs	r3, #0
 8016614:	617b      	str	r3, [r7, #20]
    event[pos++] = GAP_EVENT_SECURITY_LEVEL;
 8016616:	697b      	ldr	r3, [r7, #20]
 8016618:	1c5a      	adds	r2, r3, #1
 801661a:	617a      	str	r2, [r7, #20]
 801661c:	f107 0218 	add.w	r2, r7, #24
 8016620:	4413      	add	r3, r2
 8016622:	22e0      	movs	r2, #224	; 0xe0
 8016624:	f803 2c0c 	strb.w	r2, [r3, #-12]
    event[pos++] = sizeof(event) - 2;
 8016628:	697b      	ldr	r3, [r7, #20]
 801662a:	1c5a      	adds	r2, r3, #1
 801662c:	617a      	str	r2, [r7, #20]
 801662e:	f107 0218 	add.w	r2, r7, #24
 8016632:	4413      	add	r3, r2
 8016634:	2203      	movs	r2, #3
 8016636:	f803 2c0c 	strb.w	r2, [r3, #-12]
    little_endian_store_16(event, 2, con_handle);
 801663a:	88fa      	ldrh	r2, [r7, #6]
 801663c:	f107 030c 	add.w	r3, r7, #12
 8016640:	2102      	movs	r1, #2
 8016642:	4618      	mov	r0, r3
 8016644:	f7f8 fc0f 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 8016648:	697b      	ldr	r3, [r7, #20]
 801664a:	3302      	adds	r3, #2
 801664c:	617b      	str	r3, [r7, #20]
    event[pos++] = level;
 801664e:	697b      	ldr	r3, [r7, #20]
 8016650:	1c5a      	adds	r2, r3, #1
 8016652:	617a      	str	r2, [r7, #20]
 8016654:	f107 0218 	add.w	r2, r7, #24
 8016658:	4413      	add	r3, r2
 801665a:	797a      	ldrb	r2, [r7, #5]
 801665c:	f803 2c0c 	strb.w	r2, [r3, #-12]
    hci_emit_event(event, sizeof(event), 1);
 8016660:	f107 030c 	add.w	r3, r7, #12
 8016664:	2201      	movs	r2, #1
 8016666:	2105      	movs	r1, #5
 8016668:	4618      	mov	r0, r3
 801666a:	f7ff fccd 	bl	8016008 <hci_emit_event>
}
 801666e:	bf00      	nop
 8016670:	3718      	adds	r7, #24
 8016672:	46bd      	mov	sp, r7
 8016674:	bd80      	pop	{r7, pc}
 8016676:	bf00      	nop
 8016678:	0802929c 	.word	0x0802929c
 801667c:	0802aab4 	.word	0x0802aab4

08016680 <gap_security_level_for_connection>:

static gap_security_level_t gap_security_level_for_connection(hci_connection_t * connection){
 8016680:	b580      	push	{r7, lr}
 8016682:	b084      	sub	sp, #16
 8016684:	af00      	add	r7, sp, #0
 8016686:	6078      	str	r0, [r7, #4]
    if (!connection) return LEVEL_0;
 8016688:	687b      	ldr	r3, [r7, #4]
 801668a:	2b00      	cmp	r3, #0
 801668c:	d101      	bne.n	8016692 <gap_security_level_for_connection+0x12>
 801668e:	2300      	movs	r3, #0
 8016690:	e02a      	b.n	80166e8 <gap_security_level_for_connection+0x68>
    if ((connection->authentication_flags & CONNECTION_ENCRYPTED) == 0) return LEVEL_0;
 8016692:	687b      	ldr	r3, [r7, #4]
 8016694:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8016696:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 801669a:	2b00      	cmp	r3, #0
 801669c:	d101      	bne.n	80166a2 <gap_security_level_for_connection+0x22>
 801669e:	2300      	movs	r3, #0
 80166a0:	e022      	b.n	80166e8 <gap_security_level_for_connection+0x68>
    if ((connection->authentication_flags & CONNECTION_AUTHENTICATED) == 0) return LEVEL_0;
 80166a2:	687b      	ldr	r3, [r7, #4]
 80166a4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80166a6:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80166aa:	2b00      	cmp	r3, #0
 80166ac:	d101      	bne.n	80166b2 <gap_security_level_for_connection+0x32>
 80166ae:	2300      	movs	r3, #0
 80166b0:	e01a      	b.n	80166e8 <gap_security_level_for_connection+0x68>
    if (connection->encryption_key_size < hci_stack->gap_required_encyrption_key_size) return LEVEL_0;
 80166b2:	687b      	ldr	r3, [r7, #4]
 80166b4:	7cda      	ldrb	r2, [r3, #19]
 80166b6:	4b0e      	ldr	r3, [pc, #56]	; (80166f0 <gap_security_level_for_connection+0x70>)
 80166b8:	681b      	ldr	r3, [r3, #0]
 80166ba:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
 80166be:	429a      	cmp	r2, r3
 80166c0:	d201      	bcs.n	80166c6 <gap_security_level_for_connection+0x46>
 80166c2:	2300      	movs	r3, #0
 80166c4:	e010      	b.n	80166e8 <gap_security_level_for_connection+0x68>
    gap_security_level_t security_level = gap_security_level_for_link_key_type(connection->link_key_type);
 80166c6:	687b      	ldr	r3, [r7, #4]
 80166c8:	7d5b      	ldrb	r3, [r3, #21]
 80166ca:	4618      	mov	r0, r3
 80166cc:	f000 f836 	bl	801673c <gap_security_level_for_link_key_type>
 80166d0:	4603      	mov	r3, r0
 80166d2:	73fb      	strb	r3, [r7, #15]
    // LEVEL 4 always requires 128 bit encrytion key size
    if ((security_level == LEVEL_4) && (connection->encryption_key_size < 16)){
 80166d4:	7bfb      	ldrb	r3, [r7, #15]
 80166d6:	2b04      	cmp	r3, #4
 80166d8:	d105      	bne.n	80166e6 <gap_security_level_for_connection+0x66>
 80166da:	687b      	ldr	r3, [r7, #4]
 80166dc:	7cdb      	ldrb	r3, [r3, #19]
 80166de:	2b0f      	cmp	r3, #15
 80166e0:	d801      	bhi.n	80166e6 <gap_security_level_for_connection+0x66>
        security_level = LEVEL_3;
 80166e2:	2303      	movs	r3, #3
 80166e4:	73fb      	strb	r3, [r7, #15]
    }
    return security_level;
 80166e6:	7bfb      	ldrb	r3, [r7, #15]
}    
 80166e8:	4618      	mov	r0, r3
 80166ea:	3710      	adds	r7, #16
 80166ec:	46bd      	mov	sp, r7
 80166ee:	bd80      	pop	{r7, pc}
 80166f0:	20009780 	.word	0x20009780

080166f4 <hci_emit_discoverable_enabled>:

static void hci_emit_discoverable_enabled(uint8_t enabled){
 80166f4:	b580      	push	{r7, lr}
 80166f6:	b086      	sub	sp, #24
 80166f8:	af02      	add	r7, sp, #8
 80166fa:	4603      	mov	r3, r0
 80166fc:	71fb      	strb	r3, [r7, #7]
    log_info("BTSTACK_EVENT_DISCOVERABLE_ENABLED %u", enabled);
 80166fe:	79fb      	ldrb	r3, [r7, #7]
 8016700:	9300      	str	r3, [sp, #0]
 8016702:	f241 33d2 	movw	r3, #5074	; 0x13d2
 8016706:	4a0b      	ldr	r2, [pc, #44]	; (8016734 <hci_emit_discoverable_enabled+0x40>)
 8016708:	490b      	ldr	r1, [pc, #44]	; (8016738 <hci_emit_discoverable_enabled+0x44>)
 801670a:	2001      	movs	r0, #1
 801670c:	f000 fe98 	bl	8017440 <hci_dump_log>
    uint8_t event[3];
    event[0] = BTSTACK_EVENT_DISCOVERABLE_ENABLED;
 8016710:	2366      	movs	r3, #102	; 0x66
 8016712:	733b      	strb	r3, [r7, #12]
    event[1] = sizeof(event) - 2;
 8016714:	2301      	movs	r3, #1
 8016716:	737b      	strb	r3, [r7, #13]
    event[2] = enabled;
 8016718:	79fb      	ldrb	r3, [r7, #7]
 801671a:	73bb      	strb	r3, [r7, #14]
    hci_emit_event(event, sizeof(event), 1);
 801671c:	f107 030c 	add.w	r3, r7, #12
 8016720:	2201      	movs	r2, #1
 8016722:	2103      	movs	r1, #3
 8016724:	4618      	mov	r0, r3
 8016726:	f7ff fc6f 	bl	8016008 <hci_emit_event>
}
 801672a:	bf00      	nop
 801672c:	3710      	adds	r7, #16
 801672e:	46bd      	mov	sp, r7
 8016730:	bd80      	pop	{r7, pc}
 8016732:	bf00      	nop
 8016734:	0802929c 	.word	0x0802929c
 8016738:	0802aae4 	.word	0x0802aae4

0801673c <gap_security_level_for_link_key_type>:
}

/**
 * @brief map link keys to security levels
 */
gap_security_level_t gap_security_level_for_link_key_type(link_key_type_t link_key_type){
 801673c:	b480      	push	{r7}
 801673e:	b083      	sub	sp, #12
 8016740:	af00      	add	r7, sp, #0
 8016742:	4603      	mov	r3, r0
 8016744:	71fb      	strb	r3, [r7, #7]
    switch (link_key_type){
 8016746:	79fb      	ldrb	r3, [r7, #7]
 8016748:	2b05      	cmp	r3, #5
 801674a:	d006      	beq.n	801675a <gap_security_level_for_link_key_type+0x1e>
 801674c:	2b08      	cmp	r3, #8
 801674e:	d002      	beq.n	8016756 <gap_security_level_for_link_key_type+0x1a>
 8016750:	2b00      	cmp	r3, #0
 8016752:	d002      	beq.n	801675a <gap_security_level_for_link_key_type+0x1e>
 8016754:	e003      	b.n	801675e <gap_security_level_for_link_key_type+0x22>
        case AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P256:
            return LEVEL_4;
 8016756:	2304      	movs	r3, #4
 8016758:	e002      	b.n	8016760 <gap_security_level_for_link_key_type+0x24>
        case COMBINATION_KEY:
        case AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P192:
            return LEVEL_3;
 801675a:	2303      	movs	r3, #3
 801675c:	e000      	b.n	8016760 <gap_security_level_for_link_key_type+0x24>
        default:
            return LEVEL_2;
 801675e:	2302      	movs	r3, #2
    }
}
 8016760:	4618      	mov	r0, r3
 8016762:	370c      	adds	r7, #12
 8016764:	46bd      	mov	sp, r7
 8016766:	f85d 7b04 	ldr.w	r7, [sp], #4
 801676a:	4770      	bx	lr

0801676c <gap_secure_connection_for_link_key_type>:

/**
 * @brief map link keys to secure connection yes/no
 */
int gap_secure_connection_for_link_key_type(link_key_type_t link_key_type){
 801676c:	b480      	push	{r7}
 801676e:	b083      	sub	sp, #12
 8016770:	af00      	add	r7, sp, #0
 8016772:	4603      	mov	r3, r0
 8016774:	71fb      	strb	r3, [r7, #7]
    switch (link_key_type){
 8016776:	79fb      	ldrb	r3, [r7, #7]
 8016778:	3b07      	subs	r3, #7
 801677a:	2b01      	cmp	r3, #1
 801677c:	d801      	bhi.n	8016782 <gap_secure_connection_for_link_key_type+0x16>
        case AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P256:
        case UNAUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P256:
            return 1;
 801677e:	2301      	movs	r3, #1
 8016780:	e000      	b.n	8016784 <gap_secure_connection_for_link_key_type+0x18>
        default:
            return 0;
 8016782:	2300      	movs	r3, #0
    }
}
 8016784:	4618      	mov	r0, r3
 8016786:	370c      	adds	r7, #12
 8016788:	46bd      	mov	sp, r7
 801678a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801678e:	4770      	bx	lr

08016790 <gap_authenticated_for_link_key_type>:

/**
 * @brief map link keys to authenticated
 */
int gap_authenticated_for_link_key_type(link_key_type_t link_key_type){
 8016790:	b480      	push	{r7}
 8016792:	b083      	sub	sp, #12
 8016794:	af00      	add	r7, sp, #0
 8016796:	4603      	mov	r3, r0
 8016798:	71fb      	strb	r3, [r7, #7]
    switch (link_key_type){
 801679a:	79fb      	ldrb	r3, [r7, #7]
 801679c:	2b05      	cmp	r3, #5
 801679e:	d001      	beq.n	80167a4 <gap_authenticated_for_link_key_type+0x14>
 80167a0:	2b08      	cmp	r3, #8
 80167a2:	d101      	bne.n	80167a8 <gap_authenticated_for_link_key_type+0x18>
        case AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P256:
        case AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P192:
            return 1;
 80167a4:	2301      	movs	r3, #1
 80167a6:	e000      	b.n	80167aa <gap_authenticated_for_link_key_type+0x1a>
        default:
            return 0;
 80167a8:	2300      	movs	r3, #0
    }
}
 80167aa:	4618      	mov	r0, r3
 80167ac:	370c      	adds	r7, #12
 80167ae:	46bd      	mov	sp, r7
 80167b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80167b4:	4770      	bx	lr
	...

080167b8 <gap_mitm_protection_required_for_security_level>:

int gap_mitm_protection_required_for_security_level(gap_security_level_t level){
 80167b8:	b580      	push	{r7, lr}
 80167ba:	b084      	sub	sp, #16
 80167bc:	af02      	add	r7, sp, #8
 80167be:	4603      	mov	r3, r0
 80167c0:	71fb      	strb	r3, [r7, #7]
    log_info("gap_mitm_protection_required_for_security_level %u", level);
 80167c2:	79fb      	ldrb	r3, [r7, #7]
 80167c4:	9300      	str	r3, [sp, #0]
 80167c6:	f241 432b 	movw	r3, #5163	; 0x142b
 80167ca:	4a07      	ldr	r2, [pc, #28]	; (80167e8 <gap_mitm_protection_required_for_security_level+0x30>)
 80167cc:	4907      	ldr	r1, [pc, #28]	; (80167ec <gap_mitm_protection_required_for_security_level+0x34>)
 80167ce:	2001      	movs	r0, #1
 80167d0:	f000 fe36 	bl	8017440 <hci_dump_log>
    return level > LEVEL_2;
 80167d4:	79fb      	ldrb	r3, [r7, #7]
 80167d6:	2b02      	cmp	r3, #2
 80167d8:	bf8c      	ite	hi
 80167da:	2301      	movhi	r3, #1
 80167dc:	2300      	movls	r3, #0
 80167de:	b2db      	uxtb	r3, r3
}
 80167e0:	4618      	mov	r0, r3
 80167e2:	3708      	adds	r7, #8
 80167e4:	46bd      	mov	sp, r7
 80167e6:	bd80      	pop	{r7, pc}
 80167e8:	0802929c 	.word	0x0802929c
 80167ec:	0802ab14 	.word	0x0802ab14

080167f0 <gap_security_level>:

/**
 * @brief get current security level
 */
gap_security_level_t gap_security_level(hci_con_handle_t con_handle){
 80167f0:	b580      	push	{r7, lr}
 80167f2:	b084      	sub	sp, #16
 80167f4:	af00      	add	r7, sp, #0
 80167f6:	4603      	mov	r3, r0
 80167f8:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * connection = hci_connection_for_handle(con_handle);
 80167fa:	88fb      	ldrh	r3, [r7, #6]
 80167fc:	4618      	mov	r0, r3
 80167fe:	f7f9 f861 	bl	800f8c4 <hci_connection_for_handle>
 8016802:	60f8      	str	r0, [r7, #12]
    if (!connection) return LEVEL_0;
 8016804:	68fb      	ldr	r3, [r7, #12]
 8016806:	2b00      	cmp	r3, #0
 8016808:	d101      	bne.n	801680e <gap_security_level+0x1e>
 801680a:	2300      	movs	r3, #0
 801680c:	e003      	b.n	8016816 <gap_security_level+0x26>
    return gap_security_level_for_connection(connection);
 801680e:	68f8      	ldr	r0, [r7, #12]
 8016810:	f7ff ff36 	bl	8016680 <gap_security_level_for_connection>
 8016814:	4603      	mov	r3, r0
}
 8016816:	4618      	mov	r0, r3
 8016818:	3710      	adds	r7, #16
 801681a:	46bd      	mov	sp, r7
 801681c:	bd80      	pop	{r7, pc}
	...

08016820 <gap_request_security_level>:

/**
 * @brief request connection to device to
 * @result GAP_AUTHENTICATION_RESULT
 */
void gap_request_security_level(hci_con_handle_t con_handle, gap_security_level_t requested_level){
 8016820:	b580      	push	{r7, lr}
 8016822:	b088      	sub	sp, #32
 8016824:	af04      	add	r7, sp, #16
 8016826:	4603      	mov	r3, r0
 8016828:	460a      	mov	r2, r1
 801682a:	80fb      	strh	r3, [r7, #6]
 801682c:	4613      	mov	r3, r2
 801682e:	717b      	strb	r3, [r7, #5]
    hci_connection_t * connection = hci_connection_for_handle(con_handle);
 8016830:	88fb      	ldrh	r3, [r7, #6]
 8016832:	4618      	mov	r0, r3
 8016834:	f7f9 f846 	bl	800f8c4 <hci_connection_for_handle>
 8016838:	60f8      	str	r0, [r7, #12]
    if (!connection){
 801683a:	68fb      	ldr	r3, [r7, #12]
 801683c:	2b00      	cmp	r3, #0
 801683e:	d105      	bne.n	801684c <gap_request_security_level+0x2c>
        hci_emit_security_level(con_handle, LEVEL_0);
 8016840:	88fb      	ldrh	r3, [r7, #6]
 8016842:	2100      	movs	r1, #0
 8016844:	4618      	mov	r0, r3
 8016846:	f7ff fed1 	bl	80165ec <hci_emit_security_level>
        return;
 801684a:	e042      	b.n	80168d2 <gap_request_security_level+0xb2>
    }

    btstack_assert(hci_is_le_connection(connection) == false);

    gap_security_level_t current_level = gap_security_level(con_handle);
 801684c:	88fb      	ldrh	r3, [r7, #6]
 801684e:	4618      	mov	r0, r3
 8016850:	f7ff ffce 	bl	80167f0 <gap_security_level>
 8016854:	4603      	mov	r3, r0
 8016856:	72fb      	strb	r3, [r7, #11]
    log_info("gap_request_security_level requested level %u, planned level %u, current level %u", 
 8016858:	797b      	ldrb	r3, [r7, #5]
 801685a:	68fa      	ldr	r2, [r7, #12]
 801685c:	7d12      	ldrb	r2, [r2, #20]
 801685e:	4611      	mov	r1, r2
 8016860:	7afa      	ldrb	r2, [r7, #11]
 8016862:	9202      	str	r2, [sp, #8]
 8016864:	9101      	str	r1, [sp, #4]
 8016866:	9300      	str	r3, [sp, #0]
 8016868:	f241 4347 	movw	r3, #5191	; 0x1447
 801686c:	4a1a      	ldr	r2, [pc, #104]	; (80168d8 <gap_request_security_level+0xb8>)
 801686e:	491b      	ldr	r1, [pc, #108]	; (80168dc <gap_request_security_level+0xbc>)
 8016870:	2001      	movs	r0, #1
 8016872:	f000 fde5 	bl	8017440 <hci_dump_log>
        requested_level, connection->requested_security_level, current_level);

    // assumption: earlier requested security higher than current level => security request is active
    if (current_level < connection->requested_security_level){
 8016876:	68fb      	ldr	r3, [r7, #12]
 8016878:	7d1b      	ldrb	r3, [r3, #20]
 801687a:	7afa      	ldrb	r2, [r7, #11]
 801687c:	429a      	cmp	r2, r3
 801687e:	d208      	bcs.n	8016892 <gap_request_security_level+0x72>
        if (connection->requested_security_level < requested_level){
 8016880:	68fb      	ldr	r3, [r7, #12]
 8016882:	7d1b      	ldrb	r3, [r3, #20]
 8016884:	797a      	ldrb	r2, [r7, #5]
 8016886:	429a      	cmp	r2, r3
 8016888:	d920      	bls.n	80168cc <gap_request_security_level+0xac>
            // increase requested level as new level is higher

            // TODO: handle re-authentication when done

            connection->requested_security_level = requested_level;
 801688a:	68fb      	ldr	r3, [r7, #12]
 801688c:	797a      	ldrb	r2, [r7, #5]
 801688e:	751a      	strb	r2, [r3, #20]
        }
        return;
 8016890:	e01c      	b.n	80168cc <gap_request_security_level+0xac>
    }

    // no request active, notify if security sufficient
    if (requested_level <= current_level){
 8016892:	797a      	ldrb	r2, [r7, #5]
 8016894:	7afb      	ldrb	r3, [r7, #11]
 8016896:	429a      	cmp	r2, r3
 8016898:	d806      	bhi.n	80168a8 <gap_request_security_level+0x88>
        hci_emit_security_level(con_handle, current_level);
 801689a:	7afa      	ldrb	r2, [r7, #11]
 801689c:	88fb      	ldrh	r3, [r7, #6]
 801689e:	4611      	mov	r1, r2
 80168a0:	4618      	mov	r0, r3
 80168a2:	f7ff fea3 	bl	80165ec <hci_emit_security_level>
        return;
 80168a6:	e014      	b.n	80168d2 <gap_request_security_level+0xb2>
    }

    // store request
    connection->requested_security_level = requested_level;
 80168a8:	68fb      	ldr	r3, [r7, #12]
 80168aa:	797a      	ldrb	r2, [r7, #5]
 80168ac:	751a      	strb	r2, [r3, #20]

    // start to authenticate connection if authentication not already active
    if ((connection->bonding_flags & BONDING_SENT_AUTHENTICATE_REQUEST) != 0) return;
 80168ae:	68fb      	ldr	r3, [r7, #12]
 80168b0:	8a1b      	ldrh	r3, [r3, #16]
 80168b2:	b21b      	sxth	r3, r3
 80168b4:	2b00      	cmp	r3, #0
 80168b6:	db0b      	blt.n	80168d0 <gap_request_security_level+0xb0>
    connection->bonding_flags |= BONDING_SEND_AUTHENTICATE_REQUEST;
 80168b8:	68fb      	ldr	r3, [r7, #12]
 80168ba:	8a1b      	ldrh	r3, [r3, #16]
 80168bc:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80168c0:	b29a      	uxth	r2, r3
 80168c2:	68fb      	ldr	r3, [r7, #12]
 80168c4:	821a      	strh	r2, [r3, #16]
    hci_run();
 80168c6:	f7fe ffeb 	bl	80158a0 <hci_run>
 80168ca:	e002      	b.n	80168d2 <gap_request_security_level+0xb2>
        return;
 80168cc:	bf00      	nop
 80168ce:	e000      	b.n	80168d2 <gap_request_security_level+0xb2>
    if ((connection->bonding_flags & BONDING_SENT_AUTHENTICATE_REQUEST) != 0) return;
 80168d0:	bf00      	nop
}
 80168d2:	3710      	adds	r7, #16
 80168d4:	46bd      	mov	sp, r7
 80168d6:	bd80      	pop	{r7, pc}
 80168d8:	0802929c 	.word	0x0802929c
 80168dc:	0802ab50 	.word	0x0802ab50

080168e0 <gap_get_outgoing_connection>:
    hci_run();
    return ERROR_CODE_SUCCESS;
}

// @assumption: only a single outgoing LE Connection exists
static hci_connection_t * gap_get_outgoing_connection(void){
 80168e0:	b580      	push	{r7, lr}
 80168e2:	b082      	sub	sp, #8
 80168e4:	af00      	add	r7, sp, #0
    btstack_linked_item_t *it;
    for (it = (btstack_linked_item_t *) hci_stack->connections; it != NULL; it = it->next){
 80168e6:	4b13      	ldr	r3, [pc, #76]	; (8016934 <gap_get_outgoing_connection+0x54>)
 80168e8:	681b      	ldr	r3, [r3, #0]
 80168ea:	695b      	ldr	r3, [r3, #20]
 80168ec:	607b      	str	r3, [r7, #4]
 80168ee:	e018      	b.n	8016922 <gap_get_outgoing_connection+0x42>
        hci_connection_t * conn = (hci_connection_t *) it;
 80168f0:	687b      	ldr	r3, [r7, #4]
 80168f2:	603b      	str	r3, [r7, #0]
        if (!hci_is_le_connection(conn)) continue;
 80168f4:	6838      	ldr	r0, [r7, #0]
 80168f6:	f7f9 f969 	bl	800fbcc <hci_is_le_connection>
 80168fa:	4603      	mov	r3, r0
 80168fc:	2b00      	cmp	r3, #0
 80168fe:	d00a      	beq.n	8016916 <gap_get_outgoing_connection+0x36>
        switch (conn->state){
 8016900:	683b      	ldr	r3, [r7, #0]
 8016902:	7b9b      	ldrb	r3, [r3, #14]
 8016904:	2b00      	cmp	r3, #0
 8016906:	db08      	blt.n	801691a <gap_get_outgoing_connection+0x3a>
 8016908:	2b01      	cmp	r3, #1
 801690a:	dd02      	ble.n	8016912 <gap_get_outgoing_connection+0x32>
 801690c:	2b03      	cmp	r3, #3
 801690e:	d000      	beq.n	8016912 <gap_get_outgoing_connection+0x32>
            case SEND_CREATE_CONNECTION:
            case SENT_CREATE_CONNECTION:
            case SENT_CANCEL_CONNECTION:
                return conn;
            default:
                break;
 8016910:	e003      	b.n	801691a <gap_get_outgoing_connection+0x3a>
                return conn;
 8016912:	683b      	ldr	r3, [r7, #0]
 8016914:	e009      	b.n	801692a <gap_get_outgoing_connection+0x4a>
        if (!hci_is_le_connection(conn)) continue;
 8016916:	bf00      	nop
 8016918:	e000      	b.n	801691c <gap_get_outgoing_connection+0x3c>
                break;
 801691a:	bf00      	nop
    for (it = (btstack_linked_item_t *) hci_stack->connections; it != NULL; it = it->next){
 801691c:	687b      	ldr	r3, [r7, #4]
 801691e:	681b      	ldr	r3, [r3, #0]
 8016920:	607b      	str	r3, [r7, #4]
 8016922:	687b      	ldr	r3, [r7, #4]
 8016924:	2b00      	cmp	r3, #0
 8016926:	d1e3      	bne.n	80168f0 <gap_get_outgoing_connection+0x10>
        };
    }
    return NULL;
 8016928:	2300      	movs	r3, #0
}
 801692a:	4618      	mov	r0, r3
 801692c:	3708      	adds	r7, #8
 801692e:	46bd      	mov	sp, r7
 8016930:	bd80      	pop	{r7, pc}
 8016932:	bf00      	nop
 8016934:	20009780 	.word	0x20009780

08016938 <gap_advertisements_set_data>:
 * @brief Set Advertisement Data
 * @param advertising_data_length
 * @param advertising_data (max 31 octets)
 * @note data is not copied, pointer has to stay valid
 */
void gap_advertisements_set_data(uint8_t advertising_data_length, uint8_t * advertising_data){
 8016938:	b580      	push	{r7, lr}
 801693a:	b082      	sub	sp, #8
 801693c:	af00      	add	r7, sp, #0
 801693e:	4603      	mov	r3, r0
 8016940:	6039      	str	r1, [r7, #0]
 8016942:	71fb      	strb	r3, [r7, #7]
    hci_stack->le_advertisements_data_len = advertising_data_length;
 8016944:	4b0d      	ldr	r3, [pc, #52]	; (801697c <gap_advertisements_set_data+0x44>)
 8016946:	681b      	ldr	r3, [r3, #0]
 8016948:	79fa      	ldrb	r2, [r7, #7]
 801694a:	f883 2790 	strb.w	r2, [r3, #1936]	; 0x790
    hci_stack->le_advertisements_data = advertising_data;
 801694e:	4b0b      	ldr	r3, [pc, #44]	; (801697c <gap_advertisements_set_data+0x44>)
 8016950:	681b      	ldr	r3, [r3, #0]
 8016952:	683a      	ldr	r2, [r7, #0]
 8016954:	f8c3 278c 	str.w	r2, [r3, #1932]	; 0x78c
    hci_stack->le_advertisements_todo |= LE_ADVERTISEMENT_TASKS_SET_ADV_DATA;
 8016958:	4b08      	ldr	r3, [pc, #32]	; (801697c <gap_advertisements_set_data+0x44>)
 801695a:	681b      	ldr	r3, [r3, #0]
 801695c:	f893 279c 	ldrb.w	r2, [r3, #1948]	; 0x79c
 8016960:	4b06      	ldr	r3, [pc, #24]	; (801697c <gap_advertisements_set_data+0x44>)
 8016962:	681b      	ldr	r3, [r3, #0]
 8016964:	f042 0201 	orr.w	r2, r2, #1
 8016968:	b2d2      	uxtb	r2, r2
 801696a:	f883 279c 	strb.w	r2, [r3, #1948]	; 0x79c
    hci_run();
 801696e:	f7fe ff97 	bl	80158a0 <hci_run>
}
 8016972:	bf00      	nop
 8016974:	3708      	adds	r7, #8
 8016976:	46bd      	mov	sp, r7
 8016978:	bd80      	pop	{r7, pc}
 801697a:	bf00      	nop
 801697c:	20009780 	.word	0x20009780

08016980 <hci_le_advertisements_set_params>:
 *
 * @note internal use. use gap_advertisements_set_params from gap_le.h instead.
 */
 void hci_le_advertisements_set_params(uint16_t adv_int_min, uint16_t adv_int_max, uint8_t adv_type,
    uint8_t direct_address_typ, bd_addr_t direct_address,
    uint8_t channel_map, uint8_t filter_policy) {
 8016980:	b590      	push	{r4, r7, lr}
 8016982:	b083      	sub	sp, #12
 8016984:	af00      	add	r7, sp, #0
 8016986:	4604      	mov	r4, r0
 8016988:	4608      	mov	r0, r1
 801698a:	4611      	mov	r1, r2
 801698c:	461a      	mov	r2, r3
 801698e:	4623      	mov	r3, r4
 8016990:	80fb      	strh	r3, [r7, #6]
 8016992:	4603      	mov	r3, r0
 8016994:	80bb      	strh	r3, [r7, #4]
 8016996:	460b      	mov	r3, r1
 8016998:	70fb      	strb	r3, [r7, #3]
 801699a:	4613      	mov	r3, r2
 801699c:	70bb      	strb	r3, [r7, #2]

    hci_stack->le_advertisements_interval_min = adv_int_min;
 801699e:	4b1c      	ldr	r3, [pc, #112]	; (8016a10 <hci_le_advertisements_set_params+0x90>)
 80169a0:	681b      	ldr	r3, [r3, #0]
 80169a2:	88fa      	ldrh	r2, [r7, #6]
 80169a4:	f8a3 279e 	strh.w	r2, [r3, #1950]	; 0x79e
    hci_stack->le_advertisements_interval_max = adv_int_max;
 80169a8:	4b19      	ldr	r3, [pc, #100]	; (8016a10 <hci_le_advertisements_set_params+0x90>)
 80169aa:	681b      	ldr	r3, [r3, #0]
 80169ac:	88ba      	ldrh	r2, [r7, #4]
 80169ae:	f8a3 27a0 	strh.w	r2, [r3, #1952]	; 0x7a0
    hci_stack->le_advertisements_type = adv_type;
 80169b2:	4b17      	ldr	r3, [pc, #92]	; (8016a10 <hci_le_advertisements_set_params+0x90>)
 80169b4:	681b      	ldr	r3, [r3, #0]
 80169b6:	78fa      	ldrb	r2, [r7, #3]
 80169b8:	f883 27a2 	strb.w	r2, [r3, #1954]	; 0x7a2
    hci_stack->le_advertisements_direct_address_type = direct_address_typ;
 80169bc:	4b14      	ldr	r3, [pc, #80]	; (8016a10 <hci_le_advertisements_set_params+0x90>)
 80169be:	681b      	ldr	r3, [r3, #0]
 80169c0:	78ba      	ldrb	r2, [r7, #2]
 80169c2:	f883 27a3 	strb.w	r2, [r3, #1955]	; 0x7a3
    hci_stack->le_advertisements_channel_map = channel_map;
 80169c6:	4b12      	ldr	r3, [pc, #72]	; (8016a10 <hci_le_advertisements_set_params+0x90>)
 80169c8:	681b      	ldr	r3, [r3, #0]
 80169ca:	7f3a      	ldrb	r2, [r7, #28]
 80169cc:	f883 27a4 	strb.w	r2, [r3, #1956]	; 0x7a4
    hci_stack->le_advertisements_filter_policy = filter_policy;
 80169d0:	4b0f      	ldr	r3, [pc, #60]	; (8016a10 <hci_le_advertisements_set_params+0x90>)
 80169d2:	681b      	ldr	r3, [r3, #0]
 80169d4:	f897 2020 	ldrb.w	r2, [r7, #32]
 80169d8:	f883 27a5 	strb.w	r2, [r3, #1957]	; 0x7a5
    (void)memcpy(hci_stack->le_advertisements_direct_address, direct_address,
 80169dc:	4b0c      	ldr	r3, [pc, #48]	; (8016a10 <hci_le_advertisements_set_params+0x90>)
 80169de:	681b      	ldr	r3, [r3, #0]
 80169e0:	f203 73a6 	addw	r3, r3, #1958	; 0x7a6
 80169e4:	2206      	movs	r2, #6
 80169e6:	69b9      	ldr	r1, [r7, #24]
 80169e8:	4618      	mov	r0, r3
 80169ea:	f011 f846 	bl	8027a7a <memcpy>
                 6);

    hci_stack->le_advertisements_todo |= LE_ADVERTISEMENT_TASKS_SET_PARAMS;
 80169ee:	4b08      	ldr	r3, [pc, #32]	; (8016a10 <hci_le_advertisements_set_params+0x90>)
 80169f0:	681b      	ldr	r3, [r3, #0]
 80169f2:	f893 279c 	ldrb.w	r2, [r3, #1948]	; 0x79c
 80169f6:	4b06      	ldr	r3, [pc, #24]	; (8016a10 <hci_le_advertisements_set_params+0x90>)
 80169f8:	681b      	ldr	r3, [r3, #0]
 80169fa:	f042 0204 	orr.w	r2, r2, #4
 80169fe:	b2d2      	uxtb	r2, r2
 8016a00:	f883 279c 	strb.w	r2, [r3, #1948]	; 0x79c
    hci_run();
 8016a04:	f7fe ff4c 	bl	80158a0 <hci_run>
 }
 8016a08:	bf00      	nop
 8016a0a:	370c      	adds	r7, #12
 8016a0c:	46bd      	mov	sp, r7
 8016a0e:	bd90      	pop	{r4, r7, pc}
 8016a10:	20009780 	.word	0x20009780

08016a14 <gap_advertisements_enable>:

/**
 * @brief Enable/Disable Advertisements
 * @param enabled
 */
void gap_advertisements_enable(int enabled){
 8016a14:	b580      	push	{r7, lr}
 8016a16:	b082      	sub	sp, #8
 8016a18:	af00      	add	r7, sp, #0
 8016a1a:	6078      	str	r0, [r7, #4]
    hci_stack->le_advertisements_enabled = enabled != 0;
 8016a1c:	4b08      	ldr	r3, [pc, #32]	; (8016a40 <gap_advertisements_enable+0x2c>)
 8016a1e:	681b      	ldr	r3, [r3, #0]
 8016a20:	687a      	ldr	r2, [r7, #4]
 8016a22:	2a00      	cmp	r2, #0
 8016a24:	bf14      	ite	ne
 8016a26:	2201      	movne	r2, #1
 8016a28:	2200      	moveq	r2, #0
 8016a2a:	b2d2      	uxtb	r2, r2
 8016a2c:	f883 279a 	strb.w	r2, [r3, #1946]	; 0x79a
    hci_update_advertisements_enabled_for_current_roles();
 8016a30:	f7f9 fff8 	bl	8010a24 <hci_update_advertisements_enabled_for_current_roles>
    hci_run();
 8016a34:	f7fe ff34 	bl	80158a0 <hci_run>
}
 8016a38:	bf00      	nop
 8016a3a:	3708      	adds	r7, #8
 8016a3c:	46bd      	mov	sp, r7
 8016a3e:	bd80      	pop	{r7, pc}
 8016a40:	20009780 	.word	0x20009780

08016a44 <hci_le_set_own_address_type>:

#endif

void hci_le_set_own_address_type(uint8_t own_address_type){
 8016a44:	b580      	push	{r7, lr}
 8016a46:	b084      	sub	sp, #16
 8016a48:	af02      	add	r7, sp, #8
 8016a4a:	4603      	mov	r3, r0
 8016a4c:	71fb      	strb	r3, [r7, #7]
    log_info("hci_le_set_own_address_type: old %u, new %u", hci_stack->le_own_addr_type, own_address_type);
 8016a4e:	4b16      	ldr	r3, [pc, #88]	; (8016aa8 <hci_le_set_own_address_type+0x64>)
 8016a50:	681b      	ldr	r3, [r3, #0]
 8016a52:	f893 3754 	ldrb.w	r3, [r3, #1876]	; 0x754
 8016a56:	461a      	mov	r2, r3
 8016a58:	79fb      	ldrb	r3, [r7, #7]
 8016a5a:	9301      	str	r3, [sp, #4]
 8016a5c:	9200      	str	r2, [sp, #0]
 8016a5e:	f241 5390 	movw	r3, #5520	; 0x1590
 8016a62:	4a12      	ldr	r2, [pc, #72]	; (8016aac <hci_le_set_own_address_type+0x68>)
 8016a64:	4912      	ldr	r1, [pc, #72]	; (8016ab0 <hci_le_set_own_address_type+0x6c>)
 8016a66:	2001      	movs	r0, #1
 8016a68:	f000 fcea 	bl	8017440 <hci_dump_log>
    if (own_address_type == hci_stack->le_own_addr_type) return;
 8016a6c:	4b0e      	ldr	r3, [pc, #56]	; (8016aa8 <hci_le_set_own_address_type+0x64>)
 8016a6e:	681b      	ldr	r3, [r3, #0]
 8016a70:	f893 3754 	ldrb.w	r3, [r3, #1876]	; 0x754
 8016a74:	79fa      	ldrb	r2, [r7, #7]
 8016a76:	429a      	cmp	r2, r3
 8016a78:	d012      	beq.n	8016aa0 <hci_le_set_own_address_type+0x5c>
    hci_stack->le_own_addr_type = own_address_type;
 8016a7a:	4b0b      	ldr	r3, [pc, #44]	; (8016aa8 <hci_le_set_own_address_type+0x64>)
 8016a7c:	681b      	ldr	r3, [r3, #0]
 8016a7e:	79fa      	ldrb	r2, [r7, #7]
 8016a80:	f883 2754 	strb.w	r2, [r3, #1876]	; 0x754

#ifdef ENABLE_LE_PERIPHERAL
    // update advertisement parameters, too
    hci_stack->le_advertisements_todo |= LE_ADVERTISEMENT_TASKS_SET_PARAMS;
 8016a84:	4b08      	ldr	r3, [pc, #32]	; (8016aa8 <hci_le_set_own_address_type+0x64>)
 8016a86:	681b      	ldr	r3, [r3, #0]
 8016a88:	f893 279c 	ldrb.w	r2, [r3, #1948]	; 0x79c
 8016a8c:	4b06      	ldr	r3, [pc, #24]	; (8016aa8 <hci_le_set_own_address_type+0x64>)
 8016a8e:	681b      	ldr	r3, [r3, #0]
 8016a90:	f042 0204 	orr.w	r2, r2, #4
 8016a94:	b2d2      	uxtb	r2, r2
 8016a96:	f883 279c 	strb.w	r2, [r3, #1948]	; 0x79c
    hci_run();
 8016a9a:	f7fe ff01 	bl	80158a0 <hci_run>
 8016a9e:	e000      	b.n	8016aa2 <hci_le_set_own_address_type+0x5e>
    if (own_address_type == hci_stack->le_own_addr_type) return;
 8016aa0:	bf00      	nop
#endif
#ifdef ENABLE_LE_CENTRAL
    // note: we don't update scan parameters or modify ongoing connection attempts
#endif
}
 8016aa2:	3708      	adds	r7, #8
 8016aa4:	46bd      	mov	sp, r7
 8016aa6:	bd80      	pop	{r7, pc}
 8016aa8:	20009780 	.word	0x20009780
 8016aac:	0802929c 	.word	0x0802929c
 8016ab0:	0802ad60 	.word	0x0802ad60

08016ab4 <gap_get_connection_type>:
/**
 * @brief Get connection type
 * @param con_handle
 * @result connection_type
 */
gap_connection_type_t gap_get_connection_type(hci_con_handle_t connection_handle){
 8016ab4:	b580      	push	{r7, lr}
 8016ab6:	b084      	sub	sp, #16
 8016ab8:	af00      	add	r7, sp, #0
 8016aba:	4603      	mov	r3, r0
 8016abc:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * conn = hci_connection_for_handle(connection_handle);
 8016abe:	88fb      	ldrh	r3, [r7, #6]
 8016ac0:	4618      	mov	r0, r3
 8016ac2:	f7f8 feff 	bl	800f8c4 <hci_connection_for_handle>
 8016ac6:	60f8      	str	r0, [r7, #12]
    if (!conn) return GAP_CONNECTION_INVALID;
 8016ac8:	68fb      	ldr	r3, [r7, #12]
 8016aca:	2b00      	cmp	r3, #0
 8016acc:	d101      	bne.n	8016ad2 <gap_get_connection_type+0x1e>
 8016ace:	2300      	movs	r3, #0
 8016ad0:	e013      	b.n	8016afa <gap_get_connection_type+0x46>
    switch (conn->address_type){
 8016ad2:	68fb      	ldr	r3, [r7, #12]
 8016ad4:	7b1b      	ldrb	r3, [r3, #12]
 8016ad6:	2bfc      	cmp	r3, #252	; 0xfc
 8016ad8:	d00a      	beq.n	8016af0 <gap_get_connection_type+0x3c>
 8016ada:	2bfc      	cmp	r3, #252	; 0xfc
 8016adc:	dc03      	bgt.n	8016ae6 <gap_get_connection_type+0x32>
 8016ade:	3300      	adds	r3, #0
 8016ae0:	2b01      	cmp	r3, #1
 8016ae2:	d809      	bhi.n	8016af8 <gap_get_connection_type+0x44>
 8016ae4:	e002      	b.n	8016aec <gap_get_connection_type+0x38>
 8016ae6:	2bfd      	cmp	r3, #253	; 0xfd
 8016ae8:	d004      	beq.n	8016af4 <gap_get_connection_type+0x40>
 8016aea:	e005      	b.n	8016af8 <gap_get_connection_type+0x44>
        case BD_ADDR_TYPE_LE_PUBLIC:
        case BD_ADDR_TYPE_LE_RANDOM:
            return GAP_CONNECTION_LE;
 8016aec:	2303      	movs	r3, #3
 8016aee:	e004      	b.n	8016afa <gap_get_connection_type+0x46>
        case BD_ADDR_TYPE_SCO:
            return GAP_CONNECTION_SCO;
 8016af0:	2302      	movs	r3, #2
 8016af2:	e002      	b.n	8016afa <gap_get_connection_type+0x46>
        case BD_ADDR_TYPE_ACL:
            return GAP_CONNECTION_ACL;
 8016af4:	2301      	movs	r3, #1
 8016af6:	e000      	b.n	8016afa <gap_get_connection_type+0x46>
        default:
            return GAP_CONNECTION_INVALID;
 8016af8:	2300      	movs	r3, #0
    }
}
 8016afa:	4618      	mov	r0, r3
 8016afc:	3710      	adds	r7, #16
 8016afe:	46bd      	mov	sp, r7
 8016b00:	bd80      	pop	{r7, pc}
	...

08016b04 <hci_have_usb_transport>:
 */
uint16_t hci_get_sco_voice_setting(void){
    return hci_stack->sco_voice_setting;
}

static int hci_have_usb_transport(void){
 8016b04:	b480      	push	{r7}
 8016b06:	b083      	sub	sp, #12
 8016b08:	af00      	add	r7, sp, #0
    if (!hci_stack->hci_transport) return 0;
 8016b0a:	4b11      	ldr	r3, [pc, #68]	; (8016b50 <hci_have_usb_transport+0x4c>)
 8016b0c:	681b      	ldr	r3, [r3, #0]
 8016b0e:	681b      	ldr	r3, [r3, #0]
 8016b10:	2b00      	cmp	r3, #0
 8016b12:	d101      	bne.n	8016b18 <hci_have_usb_transport+0x14>
 8016b14:	2300      	movs	r3, #0
 8016b16:	e015      	b.n	8016b44 <hci_have_usb_transport+0x40>
    const char * transport_name = hci_stack->hci_transport->name;
 8016b18:	4b0d      	ldr	r3, [pc, #52]	; (8016b50 <hci_have_usb_transport+0x4c>)
 8016b1a:	681b      	ldr	r3, [r3, #0]
 8016b1c:	681b      	ldr	r3, [r3, #0]
 8016b1e:	681b      	ldr	r3, [r3, #0]
 8016b20:	607b      	str	r3, [r7, #4]
    if (!transport_name) return 0;
 8016b22:	687b      	ldr	r3, [r7, #4]
 8016b24:	2b00      	cmp	r3, #0
 8016b26:	d101      	bne.n	8016b2c <hci_have_usb_transport+0x28>
 8016b28:	2300      	movs	r3, #0
 8016b2a:	e00b      	b.n	8016b44 <hci_have_usb_transport+0x40>
    return (transport_name[0] == 'H') && (transport_name[1] == '2');
 8016b2c:	687b      	ldr	r3, [r7, #4]
 8016b2e:	781b      	ldrb	r3, [r3, #0]
 8016b30:	2b48      	cmp	r3, #72	; 0x48
 8016b32:	d106      	bne.n	8016b42 <hci_have_usb_transport+0x3e>
 8016b34:	687b      	ldr	r3, [r7, #4]
 8016b36:	3301      	adds	r3, #1
 8016b38:	781b      	ldrb	r3, [r3, #0]
 8016b3a:	2b32      	cmp	r3, #50	; 0x32
 8016b3c:	d101      	bne.n	8016b42 <hci_have_usb_transport+0x3e>
 8016b3e:	2301      	movs	r3, #1
 8016b40:	e000      	b.n	8016b44 <hci_have_usb_transport+0x40>
 8016b42:	2300      	movs	r3, #0
}
 8016b44:	4618      	mov	r0, r3
 8016b46:	370c      	adds	r7, #12
 8016b48:	46bd      	mov	sp, r7
 8016b4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016b4e:	4770      	bx	lr
 8016b50:	20009780 	.word	0x20009780

08016b54 <hci_get_state>:
    hci_stack->master_slave_policy = policy;
}

#endif

HCI_STATE hci_get_state(void){
 8016b54:	b480      	push	{r7}
 8016b56:	af00      	add	r7, sp, #0
    return hci_stack->state;
 8016b58:	4b04      	ldr	r3, [pc, #16]	; (8016b6c <hci_get_state+0x18>)
 8016b5a:	681b      	ldr	r3, [r3, #0]
 8016b5c:	f893 3716 	ldrb.w	r3, [r3, #1814]	; 0x716
}
 8016b60:	4618      	mov	r0, r3
 8016b62:	46bd      	mov	sp, r7
 8016b64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016b68:	4770      	bx	lr
 8016b6a:	bf00      	nop
 8016b6c:	20009780 	.word	0x20009780

08016b70 <sm_get_connection_for_handle>:
    return hci_stack->manufacturer;
}

#ifdef ENABLE_BLE

static sm_connection_t * sm_get_connection_for_handle(hci_con_handle_t con_handle){
 8016b70:	b580      	push	{r7, lr}
 8016b72:	b084      	sub	sp, #16
 8016b74:	af00      	add	r7, sp, #0
 8016b76:	4603      	mov	r3, r0
 8016b78:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * hci_con = hci_connection_for_handle(con_handle);
 8016b7a:	88fb      	ldrh	r3, [r7, #6]
 8016b7c:	4618      	mov	r0, r3
 8016b7e:	f7f8 fea1 	bl	800f8c4 <hci_connection_for_handle>
 8016b82:	60f8      	str	r0, [r7, #12]
    if (!hci_con) return NULL;
 8016b84:	68fb      	ldr	r3, [r7, #12]
 8016b86:	2b00      	cmp	r3, #0
 8016b88:	d101      	bne.n	8016b8e <sm_get_connection_for_handle+0x1e>
 8016b8a:	2300      	movs	r3, #0
 8016b8c:	e002      	b.n	8016b94 <sm_get_connection_for_handle+0x24>
    return &hci_con->sm_connection;
 8016b8e:	68fb      	ldr	r3, [r7, #12]
 8016b90:	f203 731c 	addw	r3, r3, #1820	; 0x71c
}
 8016b94:	4618      	mov	r0, r3
 8016b96:	3710      	adds	r7, #16
 8016b98:	46bd      	mov	sp, r7
 8016b9a:	bd80      	pop	{r7, pc}

08016b9c <gap_encryption_key_size>:

// extracted from sm.c to allow enabling of l2cap le data channels without adding sm.c to the build
// without sm.c default values from create_connection_for_bd_addr_and_type() resulg in non-encrypted, not-authenticated

int gap_encryption_key_size(hci_con_handle_t con_handle){
 8016b9c:	b580      	push	{r7, lr}
 8016b9e:	b084      	sub	sp, #16
 8016ba0:	af00      	add	r7, sp, #0
 8016ba2:	4603      	mov	r3, r0
 8016ba4:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * hci_connection = hci_connection_for_handle(con_handle);
 8016ba6:	88fb      	ldrh	r3, [r7, #6]
 8016ba8:	4618      	mov	r0, r3
 8016baa:	f7f8 fe8b 	bl	800f8c4 <hci_connection_for_handle>
 8016bae:	60f8      	str	r0, [r7, #12]
    if (hci_connection == NULL) return 0;
 8016bb0:	68fb      	ldr	r3, [r7, #12]
 8016bb2:	2b00      	cmp	r3, #0
 8016bb4:	d101      	bne.n	8016bba <gap_encryption_key_size+0x1e>
 8016bb6:	2300      	movs	r3, #0
 8016bb8:	e01a      	b.n	8016bf0 <gap_encryption_key_size+0x54>
    if (hci_is_le_connection(hci_connection)){
 8016bba:	68f8      	ldr	r0, [r7, #12]
 8016bbc:	f7f9 f806 	bl	800fbcc <hci_is_le_connection>
 8016bc0:	4603      	mov	r3, r0
 8016bc2:	2b00      	cmp	r3, #0
 8016bc4:	d00a      	beq.n	8016bdc <gap_encryption_key_size+0x40>
        sm_connection_t * sm_conn = &hci_connection->sm_connection;
 8016bc6:	68fb      	ldr	r3, [r7, #12]
 8016bc8:	f203 731c 	addw	r3, r3, #1820	; 0x71c
 8016bcc:	60bb      	str	r3, [r7, #8]
        if (sm_conn->sm_connection_encrypted) {
 8016bce:	68bb      	ldr	r3, [r7, #8]
 8016bd0:	7b9b      	ldrb	r3, [r3, #14]
 8016bd2:	2b00      	cmp	r3, #0
 8016bd4:	d00b      	beq.n	8016bee <gap_encryption_key_size+0x52>
            return sm_conn->sm_actual_encryption_key_size;
 8016bd6:	68bb      	ldr	r3, [r7, #8]
 8016bd8:	7c5b      	ldrb	r3, [r3, #17]
 8016bda:	e009      	b.n	8016bf0 <gap_encryption_key_size+0x54>
        }
    }
#ifdef ENABLE_CLASSIC
    else {
        if ((hci_connection->authentication_flags & CONNECTION_ENCRYPTED)){
 8016bdc:	68fb      	ldr	r3, [r7, #12]
 8016bde:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8016be0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8016be4:	2b00      	cmp	r3, #0
 8016be6:	d002      	beq.n	8016bee <gap_encryption_key_size+0x52>
            return hci_connection->encryption_key_size;
 8016be8:	68fb      	ldr	r3, [r7, #12]
 8016bea:	7cdb      	ldrb	r3, [r3, #19]
 8016bec:	e000      	b.n	8016bf0 <gap_encryption_key_size+0x54>
        }
    }
#endif
    return 0;
 8016bee:	2300      	movs	r3, #0
}
 8016bf0:	4618      	mov	r0, r3
 8016bf2:	3710      	adds	r7, #16
 8016bf4:	46bd      	mov	sp, r7
 8016bf6:	bd80      	pop	{r7, pc}

08016bf8 <gap_authenticated>:

int gap_authenticated(hci_con_handle_t con_handle){
 8016bf8:	b580      	push	{r7, lr}
 8016bfa:	b084      	sub	sp, #16
 8016bfc:	af00      	add	r7, sp, #0
 8016bfe:	4603      	mov	r3, r0
 8016c00:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * hci_connection = hci_connection_for_handle(con_handle);
 8016c02:	88fb      	ldrh	r3, [r7, #6]
 8016c04:	4618      	mov	r0, r3
 8016c06:	f7f8 fe5d 	bl	800f8c4 <hci_connection_for_handle>
 8016c0a:	60f8      	str	r0, [r7, #12]
    if (hci_connection == NULL) return 0;
 8016c0c:	68fb      	ldr	r3, [r7, #12]
 8016c0e:	2b00      	cmp	r3, #0
 8016c10:	d101      	bne.n	8016c16 <gap_authenticated+0x1e>
 8016c12:	2300      	movs	r3, #0
 8016c14:	e01c      	b.n	8016c50 <gap_authenticated+0x58>

    switch (hci_connection->address_type){
 8016c16:	68fb      	ldr	r3, [r7, #12]
 8016c18:	7b1b      	ldrb	r3, [r3, #12]
 8016c1a:	2b00      	cmp	r3, #0
 8016c1c:	db17      	blt.n	8016c4e <gap_authenticated+0x56>
 8016c1e:	2b01      	cmp	r3, #1
 8016c20:	dd03      	ble.n	8016c2a <gap_authenticated+0x32>
 8016c22:	3bfc      	subs	r3, #252	; 0xfc
 8016c24:	2b01      	cmp	r3, #1
 8016c26:	d812      	bhi.n	8016c4e <gap_authenticated+0x56>
 8016c28:	e00a      	b.n	8016c40 <gap_authenticated+0x48>
        case BD_ADDR_TYPE_LE_PUBLIC:
        case BD_ADDR_TYPE_LE_RANDOM:
            if (hci_connection->sm_connection.sm_connection_encrypted == 0) return 0; // unencrypted connection cannot be authenticated
 8016c2a:	68fb      	ldr	r3, [r7, #12]
 8016c2c:	f893 372a 	ldrb.w	r3, [r3, #1834]	; 0x72a
 8016c30:	2b00      	cmp	r3, #0
 8016c32:	d101      	bne.n	8016c38 <gap_authenticated+0x40>
 8016c34:	2300      	movs	r3, #0
 8016c36:	e00b      	b.n	8016c50 <gap_authenticated+0x58>
            return hci_connection->sm_connection.sm_connection_authenticated;
 8016c38:	68fb      	ldr	r3, [r7, #12]
 8016c3a:	f893 372b 	ldrb.w	r3, [r3, #1835]	; 0x72b
 8016c3e:	e007      	b.n	8016c50 <gap_authenticated+0x58>
#ifdef ENABLE_CLASSIC
        case BD_ADDR_TYPE_SCO:
        case BD_ADDR_TYPE_ACL:
            return gap_authenticated_for_link_key_type(hci_connection->link_key_type);
 8016c40:	68fb      	ldr	r3, [r7, #12]
 8016c42:	7d5b      	ldrb	r3, [r3, #21]
 8016c44:	4618      	mov	r0, r3
 8016c46:	f7ff fda3 	bl	8016790 <gap_authenticated_for_link_key_type>
 8016c4a:	4603      	mov	r3, r0
 8016c4c:	e000      	b.n	8016c50 <gap_authenticated+0x58>
#endif
        default:
            return 0;
 8016c4e:	2300      	movs	r3, #0
    }
}
 8016c50:	4618      	mov	r0, r3
 8016c52:	3710      	adds	r7, #16
 8016c54:	46bd      	mov	sp, r7
 8016c56:	bd80      	pop	{r7, pc}

08016c58 <gap_secure_connection>:

int gap_secure_connection(hci_con_handle_t con_handle){
 8016c58:	b580      	push	{r7, lr}
 8016c5a:	b084      	sub	sp, #16
 8016c5c:	af00      	add	r7, sp, #0
 8016c5e:	4603      	mov	r3, r0
 8016c60:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * hci_connection = hci_connection_for_handle(con_handle);
 8016c62:	88fb      	ldrh	r3, [r7, #6]
 8016c64:	4618      	mov	r0, r3
 8016c66:	f7f8 fe2d 	bl	800f8c4 <hci_connection_for_handle>
 8016c6a:	60f8      	str	r0, [r7, #12]
    if (hci_connection == NULL) return 0;
 8016c6c:	68fb      	ldr	r3, [r7, #12]
 8016c6e:	2b00      	cmp	r3, #0
 8016c70:	d101      	bne.n	8016c76 <gap_secure_connection+0x1e>
 8016c72:	2300      	movs	r3, #0
 8016c74:	e01c      	b.n	8016cb0 <gap_secure_connection+0x58>

    switch (hci_connection->address_type){
 8016c76:	68fb      	ldr	r3, [r7, #12]
 8016c78:	7b1b      	ldrb	r3, [r3, #12]
 8016c7a:	2b00      	cmp	r3, #0
 8016c7c:	db17      	blt.n	8016cae <gap_secure_connection+0x56>
 8016c7e:	2b01      	cmp	r3, #1
 8016c80:	dd03      	ble.n	8016c8a <gap_secure_connection+0x32>
 8016c82:	3bfc      	subs	r3, #252	; 0xfc
 8016c84:	2b01      	cmp	r3, #1
 8016c86:	d812      	bhi.n	8016cae <gap_secure_connection+0x56>
 8016c88:	e00a      	b.n	8016ca0 <gap_secure_connection+0x48>
        case BD_ADDR_TYPE_LE_PUBLIC:
        case BD_ADDR_TYPE_LE_RANDOM:
            if (hci_connection->sm_connection.sm_connection_encrypted == 0) return 0; // unencrypted connection cannot be authenticated
 8016c8a:	68fb      	ldr	r3, [r7, #12]
 8016c8c:	f893 372a 	ldrb.w	r3, [r3, #1834]	; 0x72a
 8016c90:	2b00      	cmp	r3, #0
 8016c92:	d101      	bne.n	8016c98 <gap_secure_connection+0x40>
 8016c94:	2300      	movs	r3, #0
 8016c96:	e00b      	b.n	8016cb0 <gap_secure_connection+0x58>
            return hci_connection->sm_connection.sm_connection_sc;
 8016c98:	68fb      	ldr	r3, [r7, #12]
 8016c9a:	f893 372c 	ldrb.w	r3, [r3, #1836]	; 0x72c
 8016c9e:	e007      	b.n	8016cb0 <gap_secure_connection+0x58>
#ifdef ENABLE_CLASSIC
        case BD_ADDR_TYPE_SCO:
        case BD_ADDR_TYPE_ACL:
            return gap_secure_connection_for_link_key_type(hci_connection->link_key_type);
 8016ca0:	68fb      	ldr	r3, [r7, #12]
 8016ca2:	7d5b      	ldrb	r3, [r3, #21]
 8016ca4:	4618      	mov	r0, r3
 8016ca6:	f7ff fd61 	bl	801676c <gap_secure_connection_for_link_key_type>
 8016caa:	4603      	mov	r3, r0
 8016cac:	e000      	b.n	8016cb0 <gap_secure_connection+0x58>
#endif
        default:
            return 0;
 8016cae:	2300      	movs	r3, #0
    }
}
 8016cb0:	4618      	mov	r0, r3
 8016cb2:	3710      	adds	r7, #16
 8016cb4:	46bd      	mov	sp, r7
 8016cb6:	bd80      	pop	{r7, pc}

08016cb8 <gap_authorization_state>:
			return false;
	}
}


authorization_state_t gap_authorization_state(hci_con_handle_t con_handle){
 8016cb8:	b580      	push	{r7, lr}
 8016cba:	b084      	sub	sp, #16
 8016cbc:	af00      	add	r7, sp, #0
 8016cbe:	4603      	mov	r3, r0
 8016cc0:	80fb      	strh	r3, [r7, #6]
    sm_connection_t * sm_conn = sm_get_connection_for_handle(con_handle);
 8016cc2:	88fb      	ldrh	r3, [r7, #6]
 8016cc4:	4618      	mov	r0, r3
 8016cc6:	f7ff ff53 	bl	8016b70 <sm_get_connection_for_handle>
 8016cca:	60f8      	str	r0, [r7, #12]
    if (!sm_conn) return AUTHORIZATION_UNKNOWN;     // wrong connection
 8016ccc:	68fb      	ldr	r3, [r7, #12]
 8016cce:	2b00      	cmp	r3, #0
 8016cd0:	d101      	bne.n	8016cd6 <gap_authorization_state+0x1e>
 8016cd2:	2300      	movs	r3, #0
 8016cd4:	e00d      	b.n	8016cf2 <gap_authorization_state+0x3a>
    if (!sm_conn->sm_connection_encrypted)               return AUTHORIZATION_UNKNOWN; // unencrypted connection cannot be authorized
 8016cd6:	68fb      	ldr	r3, [r7, #12]
 8016cd8:	7b9b      	ldrb	r3, [r3, #14]
 8016cda:	2b00      	cmp	r3, #0
 8016cdc:	d101      	bne.n	8016ce2 <gap_authorization_state+0x2a>
 8016cde:	2300      	movs	r3, #0
 8016ce0:	e007      	b.n	8016cf2 <gap_authorization_state+0x3a>
    if (!sm_conn->sm_connection_authenticated)           return AUTHORIZATION_UNKNOWN; // unauthenticatd connection cannot be authorized
 8016ce2:	68fb      	ldr	r3, [r7, #12]
 8016ce4:	7bdb      	ldrb	r3, [r3, #15]
 8016ce6:	2b00      	cmp	r3, #0
 8016ce8:	d101      	bne.n	8016cee <gap_authorization_state+0x36>
 8016cea:	2300      	movs	r3, #0
 8016cec:	e001      	b.n	8016cf2 <gap_authorization_state+0x3a>
    return sm_conn->sm_connection_authorization_state;
 8016cee:	68fb      	ldr	r3, [r7, #12]
 8016cf0:	7e5b      	ldrb	r3, [r3, #25]
}
 8016cf2:	4618      	mov	r0, r3
 8016cf4:	3710      	adds	r7, #16
 8016cf6:	46bd      	mov	sp, r7
 8016cf8:	bd80      	pop	{r7, pc}
	...

08016cfc <hci_halting_defer>:
    hci_run();
    return 0;
}
#endif

void hci_halting_defer(void){
 8016cfc:	b480      	push	{r7}
 8016cfe:	af00      	add	r7, sp, #0
    if (hci_stack->state != HCI_STATE_HALTING) return;
 8016d00:	4b0c      	ldr	r3, [pc, #48]	; (8016d34 <hci_halting_defer+0x38>)
 8016d02:	681b      	ldr	r3, [r3, #0]
 8016d04:	f893 3716 	ldrb.w	r3, [r3, #1814]	; 0x716
 8016d08:	2b03      	cmp	r3, #3
 8016d0a:	d10e      	bne.n	8016d2a <hci_halting_defer+0x2e>
    switch (hci_stack->substate){
 8016d0c:	4b09      	ldr	r3, [pc, #36]	; (8016d34 <hci_halting_defer+0x38>)
 8016d0e:	681b      	ldr	r3, [r3, #0]
 8016d10:	f893 3717 	ldrb.w	r3, [r3, #1815]	; 0x717
 8016d14:	2b49      	cmp	r3, #73	; 0x49
 8016d16:	d002      	beq.n	8016d1e <hci_halting_defer+0x22>
 8016d18:	2b4c      	cmp	r3, #76	; 0x4c
 8016d1a:	d000      	beq.n	8016d1e <hci_halting_defer+0x22>
        case HCI_HALTING_DISCONNECT_ALL_NO_TIMER:
        case HCI_HALTING_CLOSE:
            hci_stack->substate = HCI_HALTING_DISCONNECT_ALL_TIMER;
            break;
        default:
            break;
 8016d1c:	e006      	b.n	8016d2c <hci_halting_defer+0x30>
            hci_stack->substate = HCI_HALTING_DISCONNECT_ALL_TIMER;
 8016d1e:	4b05      	ldr	r3, [pc, #20]	; (8016d34 <hci_halting_defer+0x38>)
 8016d20:	681b      	ldr	r3, [r3, #0]
 8016d22:	224a      	movs	r2, #74	; 0x4a
 8016d24:	f883 2717 	strb.w	r2, [r3, #1815]	; 0x717
            break;
 8016d28:	e000      	b.n	8016d2c <hci_halting_defer+0x30>
    if (hci_stack->state != HCI_STATE_HALTING) return;
 8016d2a:	bf00      	nop
    }
}
 8016d2c:	46bd      	mov	sp, r7
 8016d2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016d32:	4770      	bx	lr
 8016d34:	20009780 	.word	0x20009780

08016d38 <hci_cmd_create_from_template>:
 *   P: 16 byte data block. Pairing code, Simple Pairing Hash and Randomizer
 *   A: 31 bytes advertising data
 *   S: Service Record (Data Element Sequence)
 *   Q: 32 byte data block, e.g. for X and Y coordinates of P-256 public key
 */
uint16_t hci_cmd_create_from_template(uint8_t *hci_cmd_buffer, const hci_cmd_t *cmd, va_list argptr){
 8016d38:	b580      	push	{r7, lr}
 8016d3a:	b08a      	sub	sp, #40	; 0x28
 8016d3c:	af00      	add	r7, sp, #0
 8016d3e:	60f8      	str	r0, [r7, #12]
 8016d40:	60b9      	str	r1, [r7, #8]
 8016d42:	607a      	str	r2, [r7, #4]
    
    hci_cmd_buffer[0] = cmd->opcode & 0xffu;
 8016d44:	68bb      	ldr	r3, [r7, #8]
 8016d46:	881b      	ldrh	r3, [r3, #0]
 8016d48:	b2da      	uxtb	r2, r3
 8016d4a:	68fb      	ldr	r3, [r7, #12]
 8016d4c:	701a      	strb	r2, [r3, #0]
    hci_cmd_buffer[1] = cmd->opcode >> 8;
 8016d4e:	68bb      	ldr	r3, [r7, #8]
 8016d50:	881b      	ldrh	r3, [r3, #0]
 8016d52:	0a1b      	lsrs	r3, r3, #8
 8016d54:	b29a      	uxth	r2, r3
 8016d56:	68fb      	ldr	r3, [r7, #12]
 8016d58:	3301      	adds	r3, #1
 8016d5a:	b2d2      	uxtb	r2, r2
 8016d5c:	701a      	strb	r2, [r3, #0]
    int pos = 3;
 8016d5e:	2303      	movs	r3, #3
 8016d60:	627b      	str	r3, [r7, #36]	; 0x24
    
    const char *format = cmd->format;
 8016d62:	68bb      	ldr	r3, [r7, #8]
 8016d64:	685b      	ldr	r3, [r3, #4]
 8016d66:	623b      	str	r3, [r7, #32]
    uint16_t word;
    uint32_t longword;
    uint8_t * ptr;
    while (*format) {
 8016d68:	e180      	b.n	801706c <hci_cmd_create_from_template+0x334>
        switch(*format) {
 8016d6a:	6a3b      	ldr	r3, [r7, #32]
 8016d6c:	781b      	ldrb	r3, [r3, #0]
 8016d6e:	3b31      	subs	r3, #49	; 0x31
 8016d70:	2b20      	cmp	r3, #32
 8016d72:	f200 8173 	bhi.w	801705c <hci_cmd_create_from_template+0x324>
 8016d76:	a201      	add	r2, pc, #4	; (adr r2, 8016d7c <hci_cmd_create_from_template+0x44>)
 8016d78:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8016d7c:	08016e01 	.word	0x08016e01
 8016d80:	08016e01 	.word	0x08016e01
 8016d84:	08016e5f 	.word	0x08016e5f
 8016d88:	08016e5f 	.word	0x08016e5f
 8016d8c:	0801705d 	.word	0x0801705d
 8016d90:	0801705d 	.word	0x0801705d
 8016d94:	0801705d 	.word	0x0801705d
 8016d98:	0801705d 	.word	0x0801705d
 8016d9c:	0801705d 	.word	0x0801705d
 8016da0:	0801705d 	.word	0x0801705d
 8016da4:	0801705d 	.word	0x0801705d
 8016da8:	0801705d 	.word	0x0801705d
 8016dac:	0801705d 	.word	0x0801705d
 8016db0:	0801705d 	.word	0x0801705d
 8016db4:	0801705d 	.word	0x0801705d
 8016db8:	0801705d 	.word	0x0801705d
 8016dbc:	08016ff7 	.word	0x08016ff7
 8016dc0:	08016ec3 	.word	0x08016ec3
 8016dc4:	0801705d 	.word	0x0801705d
 8016dc8:	08016f3b 	.word	0x08016f3b
 8016dcc:	08016f5d 	.word	0x08016f5d
 8016dd0:	0801705d 	.word	0x0801705d
 8016dd4:	0801705d 	.word	0x0801705d
 8016dd8:	08016e01 	.word	0x08016e01
 8016ddc:	0801705d 	.word	0x0801705d
 8016de0:	0801705d 	.word	0x0801705d
 8016de4:	0801703b 	.word	0x0801703b
 8016de8:	0801705d 	.word	0x0801705d
 8016dec:	0801705d 	.word	0x0801705d
 8016df0:	08016f7f 	.word	0x08016f7f
 8016df4:	0801705d 	.word	0x0801705d
 8016df8:	08016fd5 	.word	0x08016fd5
 8016dfc:	08017019 	.word	0x08017019
            case '1': //  8 bit value
            case '2': // 16 bit value
            case 'H': // hci_handle
                word = va_arg(argptr, int);  // minimal va_arg is int: 2 bytes on 8+16 bit CPUs
 8016e00:	687b      	ldr	r3, [r7, #4]
 8016e02:	1d1a      	adds	r2, r3, #4
 8016e04:	607a      	str	r2, [r7, #4]
 8016e06:	681b      	ldr	r3, [r3, #0]
 8016e08:	827b      	strh	r3, [r7, #18]
                hci_cmd_buffer[pos++] = word & 0xffu;
 8016e0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e0c:	1c5a      	adds	r2, r3, #1
 8016e0e:	627a      	str	r2, [r7, #36]	; 0x24
 8016e10:	461a      	mov	r2, r3
 8016e12:	68fb      	ldr	r3, [r7, #12]
 8016e14:	4413      	add	r3, r2
 8016e16:	8a7a      	ldrh	r2, [r7, #18]
 8016e18:	b2d2      	uxtb	r2, r2
 8016e1a:	701a      	strb	r2, [r3, #0]
                if (*format == '2') {
 8016e1c:	6a3b      	ldr	r3, [r7, #32]
 8016e1e:	781b      	ldrb	r3, [r3, #0]
 8016e20:	2b32      	cmp	r3, #50	; 0x32
 8016e22:	d10b      	bne.n	8016e3c <hci_cmd_create_from_template+0x104>
                    hci_cmd_buffer[pos++] = word >> 8;
 8016e24:	8a7b      	ldrh	r3, [r7, #18]
 8016e26:	0a1b      	lsrs	r3, r3, #8
 8016e28:	b299      	uxth	r1, r3
 8016e2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e2c:	1c5a      	adds	r2, r3, #1
 8016e2e:	627a      	str	r2, [r7, #36]	; 0x24
 8016e30:	461a      	mov	r2, r3
 8016e32:	68fb      	ldr	r3, [r7, #12]
 8016e34:	4413      	add	r3, r2
 8016e36:	b2ca      	uxtb	r2, r1
 8016e38:	701a      	strb	r2, [r3, #0]
                } else if (*format == 'H') {
                    // TODO implement opaque client connection handles
                    //      pass module handle for now
                    hci_cmd_buffer[pos++] = word >> 8;
                } 
                break;
 8016e3a:	e111      	b.n	8017060 <hci_cmd_create_from_template+0x328>
                } else if (*format == 'H') {
 8016e3c:	6a3b      	ldr	r3, [r7, #32]
 8016e3e:	781b      	ldrb	r3, [r3, #0]
 8016e40:	2b48      	cmp	r3, #72	; 0x48
 8016e42:	f040 810d 	bne.w	8017060 <hci_cmd_create_from_template+0x328>
                    hci_cmd_buffer[pos++] = word >> 8;
 8016e46:	8a7b      	ldrh	r3, [r7, #18]
 8016e48:	0a1b      	lsrs	r3, r3, #8
 8016e4a:	b299      	uxth	r1, r3
 8016e4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e4e:	1c5a      	adds	r2, r3, #1
 8016e50:	627a      	str	r2, [r7, #36]	; 0x24
 8016e52:	461a      	mov	r2, r3
 8016e54:	68fb      	ldr	r3, [r7, #12]
 8016e56:	4413      	add	r3, r2
 8016e58:	b2ca      	uxtb	r2, r1
 8016e5a:	701a      	strb	r2, [r3, #0]
                break;
 8016e5c:	e100      	b.n	8017060 <hci_cmd_create_from_template+0x328>
            case '3':
            case '4':
                longword = va_arg(argptr, uint32_t);
 8016e5e:	687b      	ldr	r3, [r7, #4]
 8016e60:	1d1a      	adds	r2, r3, #4
 8016e62:	607a      	str	r2, [r7, #4]
 8016e64:	681b      	ldr	r3, [r3, #0]
 8016e66:	617b      	str	r3, [r7, #20]
                // longword = va_arg(argptr, int);
                hci_cmd_buffer[pos++] = longword;
 8016e68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e6a:	1c5a      	adds	r2, r3, #1
 8016e6c:	627a      	str	r2, [r7, #36]	; 0x24
 8016e6e:	461a      	mov	r2, r3
 8016e70:	68fb      	ldr	r3, [r7, #12]
 8016e72:	4413      	add	r3, r2
 8016e74:	697a      	ldr	r2, [r7, #20]
 8016e76:	b2d2      	uxtb	r2, r2
 8016e78:	701a      	strb	r2, [r3, #0]
                hci_cmd_buffer[pos++] = longword >> 8;
 8016e7a:	697b      	ldr	r3, [r7, #20]
 8016e7c:	0a19      	lsrs	r1, r3, #8
 8016e7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e80:	1c5a      	adds	r2, r3, #1
 8016e82:	627a      	str	r2, [r7, #36]	; 0x24
 8016e84:	461a      	mov	r2, r3
 8016e86:	68fb      	ldr	r3, [r7, #12]
 8016e88:	4413      	add	r3, r2
 8016e8a:	b2ca      	uxtb	r2, r1
 8016e8c:	701a      	strb	r2, [r3, #0]
                hci_cmd_buffer[pos++] = longword >> 16;
 8016e8e:	697b      	ldr	r3, [r7, #20]
 8016e90:	0c19      	lsrs	r1, r3, #16
 8016e92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e94:	1c5a      	adds	r2, r3, #1
 8016e96:	627a      	str	r2, [r7, #36]	; 0x24
 8016e98:	461a      	mov	r2, r3
 8016e9a:	68fb      	ldr	r3, [r7, #12]
 8016e9c:	4413      	add	r3, r2
 8016e9e:	b2ca      	uxtb	r2, r1
 8016ea0:	701a      	strb	r2, [r3, #0]
                if (*format == '4'){
 8016ea2:	6a3b      	ldr	r3, [r7, #32]
 8016ea4:	781b      	ldrb	r3, [r3, #0]
 8016ea6:	2b34      	cmp	r3, #52	; 0x34
 8016ea8:	f040 80dc 	bne.w	8017064 <hci_cmd_create_from_template+0x32c>
                    hci_cmd_buffer[pos++] = longword >> 24;
 8016eac:	697b      	ldr	r3, [r7, #20]
 8016eae:	0e19      	lsrs	r1, r3, #24
 8016eb0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016eb2:	1c5a      	adds	r2, r3, #1
 8016eb4:	627a      	str	r2, [r7, #36]	; 0x24
 8016eb6:	461a      	mov	r2, r3
 8016eb8:	68fb      	ldr	r3, [r7, #12]
 8016eba:	4413      	add	r3, r2
 8016ebc:	b2ca      	uxtb	r2, r1
 8016ebe:	701a      	strb	r2, [r3, #0]
                }
                break;
 8016ec0:	e0d0      	b.n	8017064 <hci_cmd_create_from_template+0x32c>
            case 'B': // bt-addr
                ptr = va_arg(argptr, uint8_t *);
 8016ec2:	687b      	ldr	r3, [r7, #4]
 8016ec4:	1d1a      	adds	r2, r3, #4
 8016ec6:	607a      	str	r2, [r7, #4]
 8016ec8:	681b      	ldr	r3, [r3, #0]
 8016eca:	61bb      	str	r3, [r7, #24]
                hci_cmd_buffer[pos++] = ptr[5];
 8016ecc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016ece:	1c5a      	adds	r2, r3, #1
 8016ed0:	627a      	str	r2, [r7, #36]	; 0x24
 8016ed2:	461a      	mov	r2, r3
 8016ed4:	68fb      	ldr	r3, [r7, #12]
 8016ed6:	4413      	add	r3, r2
 8016ed8:	69ba      	ldr	r2, [r7, #24]
 8016eda:	7952      	ldrb	r2, [r2, #5]
 8016edc:	701a      	strb	r2, [r3, #0]
                hci_cmd_buffer[pos++] = ptr[4];
 8016ede:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016ee0:	1c5a      	adds	r2, r3, #1
 8016ee2:	627a      	str	r2, [r7, #36]	; 0x24
 8016ee4:	461a      	mov	r2, r3
 8016ee6:	68fb      	ldr	r3, [r7, #12]
 8016ee8:	4413      	add	r3, r2
 8016eea:	69ba      	ldr	r2, [r7, #24]
 8016eec:	7912      	ldrb	r2, [r2, #4]
 8016eee:	701a      	strb	r2, [r3, #0]
                hci_cmd_buffer[pos++] = ptr[3];
 8016ef0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016ef2:	1c5a      	adds	r2, r3, #1
 8016ef4:	627a      	str	r2, [r7, #36]	; 0x24
 8016ef6:	461a      	mov	r2, r3
 8016ef8:	68fb      	ldr	r3, [r7, #12]
 8016efa:	4413      	add	r3, r2
 8016efc:	69ba      	ldr	r2, [r7, #24]
 8016efe:	78d2      	ldrb	r2, [r2, #3]
 8016f00:	701a      	strb	r2, [r3, #0]
                hci_cmd_buffer[pos++] = ptr[2];
 8016f02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016f04:	1c5a      	adds	r2, r3, #1
 8016f06:	627a      	str	r2, [r7, #36]	; 0x24
 8016f08:	461a      	mov	r2, r3
 8016f0a:	68fb      	ldr	r3, [r7, #12]
 8016f0c:	4413      	add	r3, r2
 8016f0e:	69ba      	ldr	r2, [r7, #24]
 8016f10:	7892      	ldrb	r2, [r2, #2]
 8016f12:	701a      	strb	r2, [r3, #0]
                hci_cmd_buffer[pos++] = ptr[1];
 8016f14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016f16:	1c5a      	adds	r2, r3, #1
 8016f18:	627a      	str	r2, [r7, #36]	; 0x24
 8016f1a:	461a      	mov	r2, r3
 8016f1c:	68fb      	ldr	r3, [r7, #12]
 8016f1e:	4413      	add	r3, r2
 8016f20:	69ba      	ldr	r2, [r7, #24]
 8016f22:	7852      	ldrb	r2, [r2, #1]
 8016f24:	701a      	strb	r2, [r3, #0]
                hci_cmd_buffer[pos++] = ptr[0];
 8016f26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016f28:	1c5a      	adds	r2, r3, #1
 8016f2a:	627a      	str	r2, [r7, #36]	; 0x24
 8016f2c:	461a      	mov	r2, r3
 8016f2e:	68fb      	ldr	r3, [r7, #12]
 8016f30:	4413      	add	r3, r2
 8016f32:	69ba      	ldr	r2, [r7, #24]
 8016f34:	7812      	ldrb	r2, [r2, #0]
 8016f36:	701a      	strb	r2, [r3, #0]
                break;
 8016f38:	e095      	b.n	8017066 <hci_cmd_create_from_template+0x32e>
            case 'D': // 8 byte data block
                ptr = va_arg(argptr, uint8_t *);
 8016f3a:	687b      	ldr	r3, [r7, #4]
 8016f3c:	1d1a      	adds	r2, r3, #4
 8016f3e:	607a      	str	r2, [r7, #4]
 8016f40:	681b      	ldr	r3, [r3, #0]
 8016f42:	61bb      	str	r3, [r7, #24]
                (void)memcpy(&hci_cmd_buffer[pos], ptr, 8);
 8016f44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016f46:	68fa      	ldr	r2, [r7, #12]
 8016f48:	4413      	add	r3, r2
 8016f4a:	2208      	movs	r2, #8
 8016f4c:	69b9      	ldr	r1, [r7, #24]
 8016f4e:	4618      	mov	r0, r3
 8016f50:	f010 fd93 	bl	8027a7a <memcpy>
                pos += 8;
 8016f54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016f56:	3308      	adds	r3, #8
 8016f58:	627b      	str	r3, [r7, #36]	; 0x24
                break;
 8016f5a:	e084      	b.n	8017066 <hci_cmd_create_from_template+0x32e>
            case 'E': // Extended Inquiry Information 240 octets
                ptr = va_arg(argptr, uint8_t *);
 8016f5c:	687b      	ldr	r3, [r7, #4]
 8016f5e:	1d1a      	adds	r2, r3, #4
 8016f60:	607a      	str	r2, [r7, #4]
 8016f62:	681b      	ldr	r3, [r3, #0]
 8016f64:	61bb      	str	r3, [r7, #24]
                (void)memcpy(&hci_cmd_buffer[pos], ptr, 240);
 8016f66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016f68:	68fa      	ldr	r2, [r7, #12]
 8016f6a:	4413      	add	r3, r2
 8016f6c:	22f0      	movs	r2, #240	; 0xf0
 8016f6e:	69b9      	ldr	r1, [r7, #24]
 8016f70:	4618      	mov	r0, r3
 8016f72:	f010 fd82 	bl	8027a7a <memcpy>
                pos += 240;
 8016f76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016f78:	33f0      	adds	r3, #240	; 0xf0
 8016f7a:	627b      	str	r3, [r7, #36]	; 0x24
                break;
 8016f7c:	e073      	b.n	8017066 <hci_cmd_create_from_template+0x32e>
            case 'N': { // UTF-8 string, null terminated
                ptr = va_arg(argptr, uint8_t *);
 8016f7e:	687b      	ldr	r3, [r7, #4]
 8016f80:	1d1a      	adds	r2, r3, #4
 8016f82:	607a      	str	r2, [r7, #4]
 8016f84:	681b      	ldr	r3, [r3, #0]
 8016f86:	61bb      	str	r3, [r7, #24]
                uint16_t len = strlen((const char*) ptr);
 8016f88:	69b8      	ldr	r0, [r7, #24]
 8016f8a:	f7e9 f929 	bl	80001e0 <strlen>
 8016f8e:	4603      	mov	r3, r0
 8016f90:	83fb      	strh	r3, [r7, #30]
                if (len > 248u) {
 8016f92:	8bfb      	ldrh	r3, [r7, #30]
 8016f94:	2bf8      	cmp	r3, #248	; 0xf8
 8016f96:	d901      	bls.n	8016f9c <hci_cmd_create_from_template+0x264>
                    len = 248;
 8016f98:	23f8      	movs	r3, #248	; 0xf8
 8016f9a:	83fb      	strh	r3, [r7, #30]
                }
                (void)memcpy(&hci_cmd_buffer[pos], ptr, len);
 8016f9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016f9e:	68fa      	ldr	r2, [r7, #12]
 8016fa0:	4413      	add	r3, r2
 8016fa2:	8bfa      	ldrh	r2, [r7, #30]
 8016fa4:	69b9      	ldr	r1, [r7, #24]
 8016fa6:	4618      	mov	r0, r3
 8016fa8:	f010 fd67 	bl	8027a7a <memcpy>
                if (len < 248u) {
 8016fac:	8bfb      	ldrh	r3, [r7, #30]
 8016fae:	2bf7      	cmp	r3, #247	; 0xf7
 8016fb0:	d80c      	bhi.n	8016fcc <hci_cmd_create_from_template+0x294>
                    // fill remaining space with zeroes
                    memset(&hci_cmd_buffer[pos+len], 0u, 248u-len);
 8016fb2:	8bfa      	ldrh	r2, [r7, #30]
 8016fb4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016fb6:	4413      	add	r3, r2
 8016fb8:	461a      	mov	r2, r3
 8016fba:	68fb      	ldr	r3, [r7, #12]
 8016fbc:	1898      	adds	r0, r3, r2
 8016fbe:	8bfb      	ldrh	r3, [r7, #30]
 8016fc0:	f1c3 03f8 	rsb	r3, r3, #248	; 0xf8
 8016fc4:	461a      	mov	r2, r3
 8016fc6:	2100      	movs	r1, #0
 8016fc8:	f010 fd7b 	bl	8027ac2 <memset>
                }
                pos += 248;
 8016fcc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016fce:	33f8      	adds	r3, #248	; 0xf8
 8016fd0:	627b      	str	r3, [r7, #36]	; 0x24
                break;
 8016fd2:	e048      	b.n	8017066 <hci_cmd_create_from_template+0x32e>
            }
            case 'P': // 16 byte PIN code or link key in little endian
                ptr = va_arg(argptr, uint8_t *);
 8016fd4:	687b      	ldr	r3, [r7, #4]
 8016fd6:	1d1a      	adds	r2, r3, #4
 8016fd8:	607a      	str	r2, [r7, #4]
 8016fda:	681b      	ldr	r3, [r3, #0]
 8016fdc:	61bb      	str	r3, [r7, #24]
                (void)memcpy(&hci_cmd_buffer[pos], ptr, 16);
 8016fde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016fe0:	68fa      	ldr	r2, [r7, #12]
 8016fe2:	4413      	add	r3, r2
 8016fe4:	2210      	movs	r2, #16
 8016fe6:	69b9      	ldr	r1, [r7, #24]
 8016fe8:	4618      	mov	r0, r3
 8016fea:	f010 fd46 	bl	8027a7a <memcpy>
                pos += 16;
 8016fee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016ff0:	3310      	adds	r3, #16
 8016ff2:	627b      	str	r3, [r7, #36]	; 0x24
                break;
 8016ff4:	e037      	b.n	8017066 <hci_cmd_create_from_template+0x32e>
#ifdef ENABLE_BLE
            case 'A': // 31 bytes advertising data
                ptr = va_arg(argptr, uint8_t *);
 8016ff6:	687b      	ldr	r3, [r7, #4]
 8016ff8:	1d1a      	adds	r2, r3, #4
 8016ffa:	607a      	str	r2, [r7, #4]
 8016ffc:	681b      	ldr	r3, [r3, #0]
 8016ffe:	61bb      	str	r3, [r7, #24]
                (void)memcpy(&hci_cmd_buffer[pos], ptr, 31);
 8017000:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017002:	68fa      	ldr	r2, [r7, #12]
 8017004:	4413      	add	r3, r2
 8017006:	221f      	movs	r2, #31
 8017008:	69b9      	ldr	r1, [r7, #24]
 801700a:	4618      	mov	r0, r3
 801700c:	f010 fd35 	bl	8027a7a <memcpy>
                pos += 31;
 8017010:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017012:	331f      	adds	r3, #31
 8017014:	627b      	str	r3, [r7, #36]	; 0x24
                break;
 8017016:	e026      	b.n	8017066 <hci_cmd_create_from_template+0x32e>
                break;
            }
#endif
#ifdef ENABLE_LE_SECURE_CONNECTIONS
            case 'Q':
                ptr = va_arg(argptr, uint8_t *);
 8017018:	687b      	ldr	r3, [r7, #4]
 801701a:	1d1a      	adds	r2, r3, #4
 801701c:	607a      	str	r2, [r7, #4]
 801701e:	681b      	ldr	r3, [r3, #0]
 8017020:	61bb      	str	r3, [r7, #24]
                reverse_bytes(ptr, &hci_cmd_buffer[pos], 32);
 8017022:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017024:	68fa      	ldr	r2, [r7, #12]
 8017026:	4413      	add	r3, r2
 8017028:	2220      	movs	r2, #32
 801702a:	4619      	mov	r1, r3
 801702c:	69b8      	ldr	r0, [r7, #24]
 801702e:	f7f8 f806 	bl	800f03e <reverse_bytes>
                pos += 32;
 8017032:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017034:	3320      	adds	r3, #32
 8017036:	627b      	str	r3, [r7, #36]	; 0x24
                break;
 8017038:	e015      	b.n	8017066 <hci_cmd_create_from_template+0x32e>
#endif
            case 'K':   // 16 byte OOB Data or Link Key in big endian
                ptr = va_arg(argptr, uint8_t *);
 801703a:	687b      	ldr	r3, [r7, #4]
 801703c:	1d1a      	adds	r2, r3, #4
 801703e:	607a      	str	r2, [r7, #4]
 8017040:	681b      	ldr	r3, [r3, #0]
 8017042:	61bb      	str	r3, [r7, #24]
                reverse_bytes(ptr, &hci_cmd_buffer[pos], 16);
 8017044:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017046:	68fa      	ldr	r2, [r7, #12]
 8017048:	4413      	add	r3, r2
 801704a:	2210      	movs	r2, #16
 801704c:	4619      	mov	r1, r3
 801704e:	69b8      	ldr	r0, [r7, #24]
 8017050:	f7f7 fff5 	bl	800f03e <reverse_bytes>
                pos += 16;
 8017054:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017056:	3310      	adds	r3, #16
 8017058:	627b      	str	r3, [r7, #36]	; 0x24
                break;
 801705a:	e004      	b.n	8017066 <hci_cmd_create_from_template+0x32e>
            default:
                break;
 801705c:	bf00      	nop
 801705e:	e002      	b.n	8017066 <hci_cmd_create_from_template+0x32e>
                break;
 8017060:	bf00      	nop
 8017062:	e000      	b.n	8017066 <hci_cmd_create_from_template+0x32e>
                break;
 8017064:	bf00      	nop
        }
        format++;
 8017066:	6a3b      	ldr	r3, [r7, #32]
 8017068:	3301      	adds	r3, #1
 801706a:	623b      	str	r3, [r7, #32]
    while (*format) {
 801706c:	6a3b      	ldr	r3, [r7, #32]
 801706e:	781b      	ldrb	r3, [r3, #0]
 8017070:	2b00      	cmp	r3, #0
 8017072:	f47f ae7a 	bne.w	8016d6a <hci_cmd_create_from_template+0x32>
    };
    hci_cmd_buffer[2] = pos - 3;
 8017076:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017078:	b2da      	uxtb	r2, r3
 801707a:	68fb      	ldr	r3, [r7, #12]
 801707c:	3302      	adds	r3, #2
 801707e:	3a03      	subs	r2, #3
 8017080:	b2d2      	uxtb	r2, r2
 8017082:	701a      	strb	r2, [r3, #0]
    return pos;
 8017084:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017086:	b29b      	uxth	r3, r3
}
 8017088:	4618      	mov	r0, r3
 801708a:	3728      	adds	r7, #40	; 0x28
 801708c:	46bd      	mov	sp, r7
 801708e:	bd80      	pop	{r7, pc}

08017090 <hci_dump_open>:
#endif

// levels: debug, info, error
static int log_level_enabled[3] = { 1, 1, 1};

void hci_dump_open(const char *filename, hci_dump_format_t format){
 8017090:	b480      	push	{r7}
 8017092:	b083      	sub	sp, #12
 8017094:	af00      	add	r7, sp, #0
 8017096:	6078      	str	r0, [r7, #4]
 8017098:	460b      	mov	r3, r1
 801709a:	70fb      	strb	r3, [r7, #3]

    dump_format = format;
 801709c:	78fb      	ldrb	r3, [r7, #3]
 801709e:	4a05      	ldr	r2, [pc, #20]	; (80170b4 <hci_dump_open+0x24>)
 80170a0:	6013      	str	r3, [r2, #0]
        default:
            break;
    }
#endif
    
    dump_file = 1;
 80170a2:	4b05      	ldr	r3, [pc, #20]	; (80170b8 <hci_dump_open+0x28>)
 80170a4:	2201      	movs	r2, #1
 80170a6:	601a      	str	r2, [r3, #0]
#endif
}
 80170a8:	bf00      	nop
 80170aa:	370c      	adds	r7, #12
 80170ac:	46bd      	mov	sp, r7
 80170ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80170b2:	4770      	bx	lr
 80170b4:	20009788 	.word	0x20009788
 80170b8:	2000002c 	.word	0x2000002c

080170bc <hci_dump_packetlogger_setup_header>:
void hci_dump_set_max_packets(int packets){
    max_nr_packets = packets;
}
#endif

static void hci_dump_packetlogger_setup_header(uint8_t * buffer, uint32_t tv_sec, uint32_t tv_us, uint8_t packet_type, uint8_t in, uint16_t len){
 80170bc:	b580      	push	{r7, lr}
 80170be:	b086      	sub	sp, #24
 80170c0:	af00      	add	r7, sp, #0
 80170c2:	60f8      	str	r0, [r7, #12]
 80170c4:	60b9      	str	r1, [r7, #8]
 80170c6:	607a      	str	r2, [r7, #4]
 80170c8:	70fb      	strb	r3, [r7, #3]
    big_endian_store_32( buffer, 0, PKTLOG_HDR_SIZE - 4 + len);
 80170ca:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80170cc:	3309      	adds	r3, #9
 80170ce:	461a      	mov	r2, r3
 80170d0:	2100      	movs	r1, #0
 80170d2:	68f8      	ldr	r0, [r7, #12]
 80170d4:	f7f7 ff7f 	bl	800efd6 <big_endian_store_32>
    big_endian_store_32( buffer, 4, tv_sec);
 80170d8:	68ba      	ldr	r2, [r7, #8]
 80170da:	2104      	movs	r1, #4
 80170dc:	68f8      	ldr	r0, [r7, #12]
 80170de:	f7f7 ff7a 	bl	800efd6 <big_endian_store_32>
    big_endian_store_32( buffer, 8, tv_us);
 80170e2:	687a      	ldr	r2, [r7, #4]
 80170e4:	2108      	movs	r1, #8
 80170e6:	68f8      	ldr	r0, [r7, #12]
 80170e8:	f7f7 ff75 	bl	800efd6 <big_endian_store_32>
    uint8_t packet_logger_type = 0;
 80170ec:	2300      	movs	r3, #0
 80170ee:	75fb      	strb	r3, [r7, #23]
    switch (packet_type){
 80170f0:	78fb      	ldrb	r3, [r7, #3]
 80170f2:	2b03      	cmp	r3, #3
 80170f4:	d017      	beq.n	8017126 <hci_dump_packetlogger_setup_header+0x6a>
 80170f6:	2b03      	cmp	r3, #3
 80170f8:	dc04      	bgt.n	8017104 <hci_dump_packetlogger_setup_header+0x48>
 80170fa:	2b01      	cmp	r3, #1
 80170fc:	d007      	beq.n	801710e <hci_dump_packetlogger_setup_header+0x52>
 80170fe:	2b02      	cmp	r3, #2
 8017100:	d008      	beq.n	8017114 <hci_dump_packetlogger_setup_header+0x58>
            break;
        case LOG_MESSAGE_PACKET:
            packet_logger_type = 0xfc;
            break;
        default:
            return;
 8017102:	e023      	b.n	801714c <hci_dump_packetlogger_setup_header+0x90>
    switch (packet_type){
 8017104:	2b04      	cmp	r3, #4
 8017106:	d017      	beq.n	8017138 <hci_dump_packetlogger_setup_header+0x7c>
 8017108:	2bfc      	cmp	r3, #252	; 0xfc
 801710a:	d018      	beq.n	801713e <hci_dump_packetlogger_setup_header+0x82>
            return;
 801710c:	e01e      	b.n	801714c <hci_dump_packetlogger_setup_header+0x90>
            packet_logger_type = 0x00;
 801710e:	2300      	movs	r3, #0
 8017110:	75fb      	strb	r3, [r7, #23]
            break;
 8017112:	e017      	b.n	8017144 <hci_dump_packetlogger_setup_header+0x88>
            packet_logger_type = in ? 0x03 : 0x02;
 8017114:	f897 3020 	ldrb.w	r3, [r7, #32]
 8017118:	2b00      	cmp	r3, #0
 801711a:	d001      	beq.n	8017120 <hci_dump_packetlogger_setup_header+0x64>
 801711c:	2303      	movs	r3, #3
 801711e:	e000      	b.n	8017122 <hci_dump_packetlogger_setup_header+0x66>
 8017120:	2302      	movs	r3, #2
 8017122:	75fb      	strb	r3, [r7, #23]
            break;
 8017124:	e00e      	b.n	8017144 <hci_dump_packetlogger_setup_header+0x88>
            packet_logger_type = in ? 0x09 : 0x08;
 8017126:	f897 3020 	ldrb.w	r3, [r7, #32]
 801712a:	2b00      	cmp	r3, #0
 801712c:	d001      	beq.n	8017132 <hci_dump_packetlogger_setup_header+0x76>
 801712e:	2309      	movs	r3, #9
 8017130:	e000      	b.n	8017134 <hci_dump_packetlogger_setup_header+0x78>
 8017132:	2308      	movs	r3, #8
 8017134:	75fb      	strb	r3, [r7, #23]
            break;
 8017136:	e005      	b.n	8017144 <hci_dump_packetlogger_setup_header+0x88>
            packet_logger_type = 0x01;
 8017138:	2301      	movs	r3, #1
 801713a:	75fb      	strb	r3, [r7, #23]
            break;
 801713c:	e002      	b.n	8017144 <hci_dump_packetlogger_setup_header+0x88>
            packet_logger_type = 0xfc;
 801713e:	23fc      	movs	r3, #252	; 0xfc
 8017140:	75fb      	strb	r3, [r7, #23]
            break;
 8017142:	bf00      	nop
    }
    buffer[12] = packet_logger_type;
 8017144:	68fb      	ldr	r3, [r7, #12]
 8017146:	330c      	adds	r3, #12
 8017148:	7dfa      	ldrb	r2, [r7, #23]
 801714a:	701a      	strb	r2, [r3, #0]
}
 801714c:	3718      	adds	r7, #24
 801714e:	46bd      	mov	sp, r7
 8017150:	bd80      	pop	{r7, pc}

08017152 <hci_dump_bluez_setup_header>:

static void hci_dump_bluez_setup_header(uint8_t * buffer, uint32_t tv_sec, uint32_t tv_us, uint8_t packet_type, uint8_t in, uint16_t len){
 8017152:	b580      	push	{r7, lr}
 8017154:	b084      	sub	sp, #16
 8017156:	af00      	add	r7, sp, #0
 8017158:	60f8      	str	r0, [r7, #12]
 801715a:	60b9      	str	r1, [r7, #8]
 801715c:	607a      	str	r2, [r7, #4]
 801715e:	70fb      	strb	r3, [r7, #3]
    little_endian_store_16( buffer, 0u, 1u + len);
 8017160:	8bbb      	ldrh	r3, [r7, #28]
 8017162:	3301      	adds	r3, #1
 8017164:	b29b      	uxth	r3, r3
 8017166:	461a      	mov	r2, r3
 8017168:	2100      	movs	r1, #0
 801716a:	68f8      	ldr	r0, [r7, #12]
 801716c:	f7f7 fe7b 	bl	800ee66 <little_endian_store_16>
    buffer[2] = in;
 8017170:	68fb      	ldr	r3, [r7, #12]
 8017172:	3302      	adds	r3, #2
 8017174:	7e3a      	ldrb	r2, [r7, #24]
 8017176:	701a      	strb	r2, [r3, #0]
    buffer[3] = 0;
 8017178:	68fb      	ldr	r3, [r7, #12]
 801717a:	3303      	adds	r3, #3
 801717c:	2200      	movs	r2, #0
 801717e:	701a      	strb	r2, [r3, #0]
    little_endian_store_32( buffer, 4, tv_sec);
 8017180:	68ba      	ldr	r2, [r7, #8]
 8017182:	2104      	movs	r1, #4
 8017184:	68f8      	ldr	r0, [r7, #12]
 8017186:	f7f7 fe90 	bl	800eeaa <little_endian_store_32>
    little_endian_store_32( buffer, 8, tv_us);
 801718a:	687a      	ldr	r2, [r7, #4]
 801718c:	2108      	movs	r1, #8
 801718e:	68f8      	ldr	r0, [r7, #12]
 8017190:	f7f7 fe8b 	bl	800eeaa <little_endian_store_32>
    buffer[12] = packet_type;
 8017194:	68fb      	ldr	r3, [r7, #12]
 8017196:	330c      	adds	r3, #12
 8017198:	78fa      	ldrb	r2, [r7, #3]
 801719a:	701a      	strb	r2, [r3, #0]
}
 801719c:	bf00      	nop
 801719e:	3710      	adds	r7, #16
 80171a0:	46bd      	mov	sp, r7
 80171a2:	bd80      	pop	{r7, pc}

080171a4 <printf_packet>:

static void printf_packet(uint8_t packet_type, uint8_t in, uint8_t * packet, uint16_t len){
 80171a4:	b580      	push	{r7, lr}
 80171a6:	b082      	sub	sp, #8
 80171a8:	af00      	add	r7, sp, #0
 80171aa:	603a      	str	r2, [r7, #0]
 80171ac:	461a      	mov	r2, r3
 80171ae:	4603      	mov	r3, r0
 80171b0:	71fb      	strb	r3, [r7, #7]
 80171b2:	460b      	mov	r3, r1
 80171b4:	71bb      	strb	r3, [r7, #6]
 80171b6:	4613      	mov	r3, r2
 80171b8:	80bb      	strh	r3, [r7, #4]
    switch (packet_type){
 80171ba:	79fb      	ldrb	r3, [r7, #7]
 80171bc:	2b03      	cmp	r3, #3
 80171be:	d01e      	beq.n	80171fe <printf_packet+0x5a>
 80171c0:	2b03      	cmp	r3, #3
 80171c2:	dc04      	bgt.n	80171ce <printf_packet+0x2a>
 80171c4:	2b01      	cmp	r3, #1
 80171c6:	d007      	beq.n	80171d8 <printf_packet+0x34>
 80171c8:	2b02      	cmp	r3, #2
 80171ca:	d00d      	beq.n	80171e8 <printf_packet+0x44>
            break;
        case LOG_MESSAGE_PACKET:
            printf("LOG -- %s\n", (char*) packet);
            return;
        default:
            return;
 80171cc:	e02c      	b.n	8017228 <printf_packet+0x84>
    switch (packet_type){
 80171ce:	2b04      	cmp	r3, #4
 80171d0:	d006      	beq.n	80171e0 <printf_packet+0x3c>
 80171d2:	2bfc      	cmp	r3, #252	; 0xfc
 80171d4:	d01e      	beq.n	8017214 <printf_packet+0x70>
            return;
 80171d6:	e027      	b.n	8017228 <printf_packet+0x84>
            printf("CMD => ");
 80171d8:	4815      	ldr	r0, [pc, #84]	; (8017230 <printf_packet+0x8c>)
 80171da:	f010 fc7b 	bl	8027ad4 <iprintf>
            break;
 80171de:	e01e      	b.n	801721e <printf_packet+0x7a>
            printf("EVT <= ");
 80171e0:	4814      	ldr	r0, [pc, #80]	; (8017234 <printf_packet+0x90>)
 80171e2:	f010 fc77 	bl	8027ad4 <iprintf>
            break;
 80171e6:	e01a      	b.n	801721e <printf_packet+0x7a>
            if (in != 0) {
 80171e8:	79bb      	ldrb	r3, [r7, #6]
 80171ea:	2b00      	cmp	r3, #0
 80171ec:	d003      	beq.n	80171f6 <printf_packet+0x52>
                printf("ACL <= ");
 80171ee:	4812      	ldr	r0, [pc, #72]	; (8017238 <printf_packet+0x94>)
 80171f0:	f010 fc70 	bl	8027ad4 <iprintf>
            break;
 80171f4:	e013      	b.n	801721e <printf_packet+0x7a>
                printf("ACL => ");
 80171f6:	4811      	ldr	r0, [pc, #68]	; (801723c <printf_packet+0x98>)
 80171f8:	f010 fc6c 	bl	8027ad4 <iprintf>
            break;
 80171fc:	e00f      	b.n	801721e <printf_packet+0x7a>
            if (in != 0) {
 80171fe:	79bb      	ldrb	r3, [r7, #6]
 8017200:	2b00      	cmp	r3, #0
 8017202:	d003      	beq.n	801720c <printf_packet+0x68>
                printf("SCO <= ");
 8017204:	480e      	ldr	r0, [pc, #56]	; (8017240 <printf_packet+0x9c>)
 8017206:	f010 fc65 	bl	8027ad4 <iprintf>
            break;
 801720a:	e008      	b.n	801721e <printf_packet+0x7a>
                printf("SCO => ");
 801720c:	480d      	ldr	r0, [pc, #52]	; (8017244 <printf_packet+0xa0>)
 801720e:	f010 fc61 	bl	8027ad4 <iprintf>
            break;
 8017212:	e004      	b.n	801721e <printf_packet+0x7a>
            printf("LOG -- %s\n", (char*) packet);
 8017214:	6839      	ldr	r1, [r7, #0]
 8017216:	480c      	ldr	r0, [pc, #48]	; (8017248 <printf_packet+0xa4>)
 8017218:	f010 fc5c 	bl	8027ad4 <iprintf>
            return;
 801721c:	e004      	b.n	8017228 <printf_packet+0x84>
    }
    printf_hexdump(packet, len);  
 801721e:	88bb      	ldrh	r3, [r7, #4]
 8017220:	4619      	mov	r1, r3
 8017222:	6838      	ldr	r0, [r7, #0]
 8017224:	f7f7 ffd8 	bl	800f1d8 <printf_hexdump>
}
 8017228:	3708      	adds	r7, #8
 801722a:	46bd      	mov	sp, r7
 801722c:	bd80      	pop	{r7, pc}
 801722e:	bf00      	nop
 8017230:	0802af30 	.word	0x0802af30
 8017234:	0802af38 	.word	0x0802af38
 8017238:	0802af40 	.word	0x0802af40
 801723c:	0802af48 	.word	0x0802af48
 8017240:	0802af50 	.word	0x0802af50
 8017244:	0802af58 	.word	0x0802af58
 8017248:	0802af60 	.word	0x0802af60

0801724c <printf_timestamp>:

static void printf_timestamp(void){
 801724c:	b580      	push	{r7, lr}
 801724e:	b088      	sub	sp, #32
 8017250:	af02      	add	r7, sp, #8
    /* Compute milliseconds from microseconds. */
    uint16_t milliseconds = curr_time.tv_usec / 1000;
    /* Print the formatted time, in seconds, followed by a decimal point and the milliseconds. */
    printf ("%s.%03u] ", time_string, milliseconds);
#else
    uint32_t time_ms = btstack_run_loop_get_time_ms();
 8017252:	f7f7 fd4b 	bl	800ecec <btstack_run_loop_get_time_ms>
 8017256:	6178      	str	r0, [r7, #20]
    int      seconds = time_ms / 1000u;
 8017258:	697b      	ldr	r3, [r7, #20]
 801725a:	4a23      	ldr	r2, [pc, #140]	; (80172e8 <printf_timestamp+0x9c>)
 801725c:	fba2 2303 	umull	r2, r3, r2, r3
 8017260:	099b      	lsrs	r3, r3, #6
 8017262:	613b      	str	r3, [r7, #16]
    int      minutes = seconds / 60;
 8017264:	693b      	ldr	r3, [r7, #16]
 8017266:	4a21      	ldr	r2, [pc, #132]	; (80172ec <printf_timestamp+0xa0>)
 8017268:	fb82 1203 	smull	r1, r2, r2, r3
 801726c:	441a      	add	r2, r3
 801726e:	1152      	asrs	r2, r2, #5
 8017270:	17db      	asrs	r3, r3, #31
 8017272:	1ad3      	subs	r3, r2, r3
 8017274:	60fb      	str	r3, [r7, #12]
    unsigned int hours = minutes / 60;
 8017276:	68fb      	ldr	r3, [r7, #12]
 8017278:	4a1c      	ldr	r2, [pc, #112]	; (80172ec <printf_timestamp+0xa0>)
 801727a:	fb82 1203 	smull	r1, r2, r2, r3
 801727e:	441a      	add	r2, r3
 8017280:	1152      	asrs	r2, r2, #5
 8017282:	17db      	asrs	r3, r3, #31
 8017284:	1ad3      	subs	r3, r2, r3
 8017286:	60bb      	str	r3, [r7, #8]

    uint16_t p_ms      = time_ms - (seconds * 1000u);
 8017288:	697b      	ldr	r3, [r7, #20]
 801728a:	b29a      	uxth	r2, r3
 801728c:	693b      	ldr	r3, [r7, #16]
 801728e:	b29b      	uxth	r3, r3
 8017290:	4619      	mov	r1, r3
 8017292:	0149      	lsls	r1, r1, #5
 8017294:	1ac9      	subs	r1, r1, r3
 8017296:	0089      	lsls	r1, r1, #2
 8017298:	440b      	add	r3, r1
 801729a:	00db      	lsls	r3, r3, #3
 801729c:	b29b      	uxth	r3, r3
 801729e:	1ad3      	subs	r3, r2, r3
 80172a0:	80fb      	strh	r3, [r7, #6]
    uint16_t p_seconds = seconds - (minutes * 60);
 80172a2:	68fb      	ldr	r3, [r7, #12]
 80172a4:	b29b      	uxth	r3, r3
 80172a6:	461a      	mov	r2, r3
 80172a8:	011b      	lsls	r3, r3, #4
 80172aa:	1ad3      	subs	r3, r2, r3
 80172ac:	009b      	lsls	r3, r3, #2
 80172ae:	b29a      	uxth	r2, r3
 80172b0:	693b      	ldr	r3, [r7, #16]
 80172b2:	b29b      	uxth	r3, r3
 80172b4:	4413      	add	r3, r2
 80172b6:	80bb      	strh	r3, [r7, #4]
    uint16_t p_minutes = minutes - (hours   * 60u);     
 80172b8:	68fb      	ldr	r3, [r7, #12]
 80172ba:	b29a      	uxth	r2, r3
 80172bc:	68bb      	ldr	r3, [r7, #8]
 80172be:	b29b      	uxth	r3, r3
 80172c0:	4619      	mov	r1, r3
 80172c2:	0109      	lsls	r1, r1, #4
 80172c4:	1acb      	subs	r3, r1, r3
 80172c6:	009b      	lsls	r3, r3, #2
 80172c8:	b29b      	uxth	r3, r3
 80172ca:	1ad3      	subs	r3, r2, r3
 80172cc:	807b      	strh	r3, [r7, #2]
    printf("[%02u:%02u:%02u.%03u] ", hours, p_minutes, p_seconds, p_ms);
 80172ce:	887a      	ldrh	r2, [r7, #2]
 80172d0:	88b9      	ldrh	r1, [r7, #4]
 80172d2:	88fb      	ldrh	r3, [r7, #6]
 80172d4:	9300      	str	r3, [sp, #0]
 80172d6:	460b      	mov	r3, r1
 80172d8:	68b9      	ldr	r1, [r7, #8]
 80172da:	4805      	ldr	r0, [pc, #20]	; (80172f0 <printf_timestamp+0xa4>)
 80172dc:	f010 fbfa 	bl	8027ad4 <iprintf>
#endif
}
 80172e0:	bf00      	nop
 80172e2:	3718      	adds	r7, #24
 80172e4:	46bd      	mov	sp, r7
 80172e6:	bd80      	pop	{r7, pc}
 80172e8:	10624dd3 	.word	0x10624dd3
 80172ec:	88888889 	.word	0x88888889
 80172f0:	0802af6c 	.word	0x0802af6c

080172f4 <hci_dump_packet>:

void hci_dump_packet(uint8_t packet_type, uint8_t in, uint8_t *packet, uint16_t len) {
 80172f4:	b580      	push	{r7, lr}
 80172f6:	b088      	sub	sp, #32
 80172f8:	af02      	add	r7, sp, #8
 80172fa:	603a      	str	r2, [r7, #0]
 80172fc:	461a      	mov	r2, r3
 80172fe:	4603      	mov	r3, r0
 8017300:	71fb      	strb	r3, [r7, #7]
 8017302:	460b      	mov	r3, r1
 8017304:	71bb      	strb	r3, [r7, #6]
 8017306:	4613      	mov	r3, r2
 8017308:	80bb      	strh	r3, [r7, #4]
    static union {
        uint8_t header_bluez[HCIDUMP_HDR_SIZE];
        uint8_t header_packetlogger[PKTLOG_HDR_SIZE];
    } header;

    if (dump_file < 0) return; // not activated yet
 801730a:	4b2b      	ldr	r3, [pc, #172]	; (80173b8 <hci_dump_packet+0xc4>)
 801730c:	681b      	ldr	r3, [r3, #0]
 801730e:	2b00      	cmp	r3, #0
 8017310:	db4e      	blt.n	80173b0 <hci_dump_packet+0xbc>
        }
        nr_packets++;
    }
#endif

    if (dump_format == HCI_DUMP_STDOUT){
 8017312:	4b2a      	ldr	r3, [pc, #168]	; (80173bc <hci_dump_packet+0xc8>)
 8017314:	681b      	ldr	r3, [r3, #0]
 8017316:	2b02      	cmp	r3, #2
 8017318:	d108      	bne.n	801732c <hci_dump_packet+0x38>
        printf_timestamp();
 801731a:	f7ff ff97 	bl	801724c <printf_timestamp>
        printf_packet(packet_type, in, packet, len);
 801731e:	88bb      	ldrh	r3, [r7, #4]
 8017320:	79b9      	ldrb	r1, [r7, #6]
 8017322:	79f8      	ldrb	r0, [r7, #7]
 8017324:	683a      	ldr	r2, [r7, #0]
 8017326:	f7ff ff3d 	bl	80171a4 <printf_packet>
        return;        
 801732a:	e042      	b.n	80173b2 <hci_dump_packet+0xbe>
    }

    uint32_t tv_sec = 0;
 801732c:	2300      	movs	r3, #0
 801732e:	617b      	str	r3, [r7, #20]
    uint32_t tv_us  = 0;
 8017330:	2300      	movs	r3, #0
 8017332:	613b      	str	r3, [r7, #16]
    struct timeval curr_time;
    gettimeofday(&curr_time, NULL);
    tv_sec = curr_time.tv_sec;
    tv_us  = curr_time.tv_usec;
#else
    uint32_t time_ms = btstack_run_loop_get_time_ms();
 8017334:	f7f7 fcda 	bl	800ecec <btstack_run_loop_get_time_ms>
 8017338:	60f8      	str	r0, [r7, #12]
	tv_sec  = time_ms / 1000u;
 801733a:	68fb      	ldr	r3, [r7, #12]
 801733c:	4a20      	ldr	r2, [pc, #128]	; (80173c0 <hci_dump_packet+0xcc>)
 801733e:	fba2 2303 	umull	r2, r3, r2, r3
 8017342:	099b      	lsrs	r3, r3, #6
 8017344:	617b      	str	r3, [r7, #20]
	tv_us   = (time_ms - (tv_sec * 1000)) * 1000;
 8017346:	697b      	ldr	r3, [r7, #20]
 8017348:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801734c:	fb02 f303 	mul.w	r3, r2, r3
 8017350:	68fa      	ldr	r2, [r7, #12]
 8017352:	1ad3      	subs	r3, r2, r3
 8017354:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8017358:	fb02 f303 	mul.w	r3, r2, r3
 801735c:	613b      	str	r3, [r7, #16]
	// Saturday, January 1, 2000 12:00:00
    tv_sec += 946728000UL;
 801735e:	697a      	ldr	r2, [r7, #20]
 8017360:	4b18      	ldr	r3, [pc, #96]	; (80173c4 <hci_dump_packet+0xd0>)
 8017362:	4413      	add	r3, r2
 8017364:	617b      	str	r3, [r7, #20]
        len         = sizeof(rtt_warning)-1;
    }
#endif
#endif

    uint16_t header_len = 0;
 8017366:	2300      	movs	r3, #0
 8017368:	817b      	strh	r3, [r7, #10]
    switch (dump_format){
 801736a:	4b14      	ldr	r3, [pc, #80]	; (80173bc <hci_dump_packet+0xc8>)
 801736c:	681b      	ldr	r3, [r3, #0]
 801736e:	2b00      	cmp	r3, #0
 8017370:	d002      	beq.n	8017378 <hci_dump_packet+0x84>
 8017372:	2b01      	cmp	r3, #1
 8017374:	d00e      	beq.n	8017394 <hci_dump_packet+0xa0>
        case HCI_DUMP_PACKETLOGGER:
            hci_dump_packetlogger_setup_header(header.header_packetlogger, tv_sec, tv_us, packet_type, in, len);
            header_len = PKTLOG_HDR_SIZE;
            break;
        default:
            return;
 8017376:	e01c      	b.n	80173b2 <hci_dump_packet+0xbe>
            hci_dump_bluez_setup_header(header.header_bluez, tv_sec, tv_us, packet_type, in, len);
 8017378:	79fa      	ldrb	r2, [r7, #7]
 801737a:	88bb      	ldrh	r3, [r7, #4]
 801737c:	9301      	str	r3, [sp, #4]
 801737e:	79bb      	ldrb	r3, [r7, #6]
 8017380:	9300      	str	r3, [sp, #0]
 8017382:	4613      	mov	r3, r2
 8017384:	693a      	ldr	r2, [r7, #16]
 8017386:	6979      	ldr	r1, [r7, #20]
 8017388:	480f      	ldr	r0, [pc, #60]	; (80173c8 <hci_dump_packet+0xd4>)
 801738a:	f7ff fee2 	bl	8017152 <hci_dump_bluez_setup_header>
            header_len = HCIDUMP_HDR_SIZE;
 801738e:	230d      	movs	r3, #13
 8017390:	817b      	strh	r3, [r7, #10]
            break;
 8017392:	e00e      	b.n	80173b2 <hci_dump_packet+0xbe>
            hci_dump_packetlogger_setup_header(header.header_packetlogger, tv_sec, tv_us, packet_type, in, len);
 8017394:	79fa      	ldrb	r2, [r7, #7]
 8017396:	88bb      	ldrh	r3, [r7, #4]
 8017398:	9301      	str	r3, [sp, #4]
 801739a:	79bb      	ldrb	r3, [r7, #6]
 801739c:	9300      	str	r3, [sp, #0]
 801739e:	4613      	mov	r3, r2
 80173a0:	693a      	ldr	r2, [r7, #16]
 80173a2:	6979      	ldr	r1, [r7, #20]
 80173a4:	4808      	ldr	r0, [pc, #32]	; (80173c8 <hci_dump_packet+0xd4>)
 80173a6:	f7ff fe89 	bl	80170bc <hci_dump_packetlogger_setup_header>
            header_len = PKTLOG_HDR_SIZE;
 80173aa:	230d      	movs	r3, #13
 80173ac:	817b      	strh	r3, [r7, #10]
            break;
 80173ae:	e000      	b.n	80173b2 <hci_dump_packet+0xbe>
    if (dump_file < 0) return; // not activated yet
 80173b0:	bf00      	nop

    SEGGER_RTT_Write(SEGGER_RTT_PACKETLOG_CHANNEL, &header, header_len);
    SEGGER_RTT_Write(SEGGER_RTT_PACKETLOG_CHANNEL, packet, len);
#endif
    UNUSED(header_len);
}
 80173b2:	3718      	adds	r7, #24
 80173b4:	46bd      	mov	sp, r7
 80173b6:	bd80      	pop	{r7, pc}
 80173b8:	2000002c 	.word	0x2000002c
 80173bc:	20009788 	.word	0x20009788
 80173c0:	10624dd3 	.word	0x10624dd3
 80173c4:	386dec40 	.word	0x386dec40
 80173c8:	2000978c 	.word	0x2000978c

080173cc <hci_dump_log_level_active>:

static int hci_dump_log_level_active(int log_level){
 80173cc:	b480      	push	{r7}
 80173ce:	b083      	sub	sp, #12
 80173d0:	af00      	add	r7, sp, #0
 80173d2:	6078      	str	r0, [r7, #4]
    if (log_level < HCI_DUMP_LOG_LEVEL_DEBUG) return 0;
 80173d4:	687b      	ldr	r3, [r7, #4]
 80173d6:	2b00      	cmp	r3, #0
 80173d8:	da01      	bge.n	80173de <hci_dump_log_level_active+0x12>
 80173da:	2300      	movs	r3, #0
 80173dc:	e008      	b.n	80173f0 <hci_dump_log_level_active+0x24>
    if (log_level > HCI_DUMP_LOG_LEVEL_ERROR) return 0;
 80173de:	687b      	ldr	r3, [r7, #4]
 80173e0:	2b02      	cmp	r3, #2
 80173e2:	dd01      	ble.n	80173e8 <hci_dump_log_level_active+0x1c>
 80173e4:	2300      	movs	r3, #0
 80173e6:	e003      	b.n	80173f0 <hci_dump_log_level_active+0x24>
    return log_level_enabled[log_level];
 80173e8:	4a04      	ldr	r2, [pc, #16]	; (80173fc <hci_dump_log_level_active+0x30>)
 80173ea:	687b      	ldr	r3, [r7, #4]
 80173ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 80173f0:	4618      	mov	r0, r3
 80173f2:	370c      	adds	r7, #12
 80173f4:	46bd      	mov	sp, r7
 80173f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80173fa:	4770      	bx	lr
 80173fc:	20000030 	.word	0x20000030

08017400 <hci_dump_log_va_arg>:

void hci_dump_log_va_arg(int log_level, const char * format, va_list argptr){
 8017400:	b580      	push	{r7, lr}
 8017402:	b084      	sub	sp, #16
 8017404:	af00      	add	r7, sp, #0
 8017406:	60f8      	str	r0, [r7, #12]
 8017408:	60b9      	str	r1, [r7, #8]
 801740a:	607a      	str	r2, [r7, #4]
    if (!hci_dump_log_level_active(log_level)) return;
 801740c:	68f8      	ldr	r0, [r7, #12]
 801740e:	f7ff ffdd 	bl	80173cc <hci_dump_log_level_active>
 8017412:	4603      	mov	r3, r0
 8017414:	2b00      	cmp	r3, #0
 8017416:	d00c      	beq.n	8017432 <hci_dump_log_va_arg+0x32>
        hci_dump_packet(LOG_MESSAGE_PACKET, 0, (uint8_t*) log_message_buffer, len);
        return;
    }
#endif

    printf_timestamp();
 8017418:	f7ff ff18 	bl	801724c <printf_timestamp>
    printf("LOG -- ");
 801741c:	4807      	ldr	r0, [pc, #28]	; (801743c <hci_dump_log_va_arg+0x3c>)
 801741e:	f010 fb59 	bl	8027ad4 <iprintf>
    vprintf(format, argptr);
 8017422:	6879      	ldr	r1, [r7, #4]
 8017424:	68b8      	ldr	r0, [r7, #8]
 8017426:	f010 fbc5 	bl	8027bb4 <viprintf>
    printf("\n");
 801742a:	200a      	movs	r0, #10
 801742c:	f010 fb6a 	bl	8027b04 <putchar>
 8017430:	e000      	b.n	8017434 <hci_dump_log_va_arg+0x34>
    if (!hci_dump_log_level_active(log_level)) return;
 8017432:	bf00      	nop
}
 8017434:	3710      	adds	r7, #16
 8017436:	46bd      	mov	sp, r7
 8017438:	bd80      	pop	{r7, pc}
 801743a:	bf00      	nop
 801743c:	0802af84 	.word	0x0802af84

08017440 <hci_dump_log>:

void hci_dump_log(int log_level, const char * format, ...){
 8017440:	b40e      	push	{r1, r2, r3}
 8017442:	b580      	push	{r7, lr}
 8017444:	b085      	sub	sp, #20
 8017446:	af00      	add	r7, sp, #0
 8017448:	6078      	str	r0, [r7, #4]
    va_list argptr;
    va_start(argptr, format);
 801744a:	f107 0320 	add.w	r3, r7, #32
 801744e:	60fb      	str	r3, [r7, #12]
    hci_dump_log_va_arg(log_level, format, argptr);
 8017450:	68fa      	ldr	r2, [r7, #12]
 8017452:	69f9      	ldr	r1, [r7, #28]
 8017454:	6878      	ldr	r0, [r7, #4]
 8017456:	f7ff ffd3 	bl	8017400 <hci_dump_log_va_arg>
    va_end(argptr);
}
 801745a:	bf00      	nop
 801745c:	3714      	adds	r7, #20
 801745e:	46bd      	mov	sp, r7
 8017460:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8017464:	b003      	add	sp, #12
 8017466:	4770      	bx	lr

08017468 <hci_transport_h4_set_baudrate>:
    BAUDRATE_CHANGE_WORKAROUND_BAUDRATE_COMMAND_SENT,
    BAUDRATE_CHANGE_WORKAROUND_DONE
} baudrate_change_workaround_state;
#endif

static int hci_transport_h4_set_baudrate(uint32_t baudrate){
 8017468:	b580      	push	{r7, lr}
 801746a:	b084      	sub	sp, #16
 801746c:	af02      	add	r7, sp, #8
 801746e:	6078      	str	r0, [r7, #4]
    log_info("hci_transport_h4_set_baudrate %"PRIu32, baudrate);
 8017470:	687b      	ldr	r3, [r7, #4]
 8017472:	9300      	str	r3, [sp, #0]
 8017474:	23af      	movs	r3, #175	; 0xaf
 8017476:	4a07      	ldr	r2, [pc, #28]	; (8017494 <hci_transport_h4_set_baudrate+0x2c>)
 8017478:	4907      	ldr	r1, [pc, #28]	; (8017498 <hci_transport_h4_set_baudrate+0x30>)
 801747a:	2001      	movs	r0, #1
 801747c:	f7ff ffe0 	bl	8017440 <hci_dump_log>
    return btstack_uart->set_baudrate(baudrate);
 8017480:	4b06      	ldr	r3, [pc, #24]	; (801749c <hci_transport_h4_set_baudrate+0x34>)
 8017482:	681b      	ldr	r3, [r3, #0]
 8017484:	695b      	ldr	r3, [r3, #20]
 8017486:	6878      	ldr	r0, [r7, #4]
 8017488:	4798      	blx	r3
 801748a:	4603      	mov	r3, r0
}
 801748c:	4618      	mov	r0, r3
 801748e:	3708      	adds	r7, #8
 8017490:	46bd      	mov	sp, r7
 8017492:	bd80      	pop	{r7, pc}
 8017494:	0802af8c 	.word	0x0802af8c
 8017498:	0802afa0 	.word	0x0802afa0
 801749c:	2000979c 	.word	0x2000979c

080174a0 <hci_transport_h4_reset_statemachine>:

static void hci_transport_h4_reset_statemachine(void){
 80174a0:	b480      	push	{r7}
 80174a2:	af00      	add	r7, sp, #0
    h4_state = H4_W4_PACKET_TYPE;
 80174a4:	4b06      	ldr	r3, [pc, #24]	; (80174c0 <hci_transport_h4_reset_statemachine+0x20>)
 80174a6:	2201      	movs	r2, #1
 80174a8:	701a      	strb	r2, [r3, #0]
    read_pos = 0;
 80174aa:	4b06      	ldr	r3, [pc, #24]	; (80174c4 <hci_transport_h4_reset_statemachine+0x24>)
 80174ac:	2200      	movs	r2, #0
 80174ae:	801a      	strh	r2, [r3, #0]
    bytes_to_read = 1;
 80174b0:	4b05      	ldr	r3, [pc, #20]	; (80174c8 <hci_transport_h4_reset_statemachine+0x28>)
 80174b2:	2201      	movs	r2, #1
 80174b4:	801a      	strh	r2, [r3, #0]
}
 80174b6:	bf00      	nop
 80174b8:	46bd      	mov	sp, r7
 80174ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80174be:	4770      	bx	lr
 80174c0:	200097ad 	.word	0x200097ad
 80174c4:	200097b0 	.word	0x200097b0
 80174c8:	200097ae 	.word	0x200097ae

080174cc <hci_transport_h4_trigger_next_read>:

static void hci_transport_h4_trigger_next_read(void){
 80174cc:	b580      	push	{r7, lr}
 80174ce:	af00      	add	r7, sp, #0
    // log_info("hci_transport_h4_trigger_next_read: %u bytes", bytes_to_read);
    btstack_uart->receive_block(&hci_packet[read_pos], bytes_to_read);  
 80174d0:	4b06      	ldr	r3, [pc, #24]	; (80174ec <hci_transport_h4_trigger_next_read+0x20>)
 80174d2:	681b      	ldr	r3, [r3, #0]
 80174d4:	6a1b      	ldr	r3, [r3, #32]
 80174d6:	4a06      	ldr	r2, [pc, #24]	; (80174f0 <hci_transport_h4_trigger_next_read+0x24>)
 80174d8:	6812      	ldr	r2, [r2, #0]
 80174da:	4906      	ldr	r1, [pc, #24]	; (80174f4 <hci_transport_h4_trigger_next_read+0x28>)
 80174dc:	8809      	ldrh	r1, [r1, #0]
 80174de:	1850      	adds	r0, r2, r1
 80174e0:	4a05      	ldr	r2, [pc, #20]	; (80174f8 <hci_transport_h4_trigger_next_read+0x2c>)
 80174e2:	8812      	ldrh	r2, [r2, #0]
 80174e4:	4611      	mov	r1, r2
 80174e6:	4798      	blx	r3
}
 80174e8:	bf00      	nop
 80174ea:	bd80      	pop	{r7, pc}
 80174ec:	2000979c 	.word	0x2000979c
 80174f0:	20000040 	.word	0x20000040
 80174f4:	200097b0 	.word	0x200097b0
 80174f8:	200097ae 	.word	0x200097ae

080174fc <hci_transport_h4_packet_complete>:

static void hci_transport_h4_packet_complete(void){
 80174fc:	b580      	push	{r7, lr}
 80174fe:	b082      	sub	sp, #8
 8017500:	af00      	add	r7, sp, #0
#ifdef ENABLE_BAUDRATE_CHANGE_FLOWCONTROL_BUG_WORKAROUND
    if (baudrate_change_workaround_state == BAUDRATE_CHANGE_WORKAROUND_IDLE
 8017502:	4b1f      	ldr	r3, [pc, #124]	; (8017580 <hci_transport_h4_packet_complete+0x84>)
 8017504:	781b      	ldrb	r3, [r3, #0]
 8017506:	2b00      	cmp	r3, #0
 8017508:	d125      	bne.n	8017556 <hci_transport_h4_packet_complete+0x5a>
            && memcmp(hci_packet, local_version_event_prefix, sizeof(local_version_event_prefix)) == 0){
 801750a:	4b1e      	ldr	r3, [pc, #120]	; (8017584 <hci_transport_h4_packet_complete+0x88>)
 801750c:	681b      	ldr	r3, [r3, #0]
 801750e:	2206      	movs	r2, #6
 8017510:	491d      	ldr	r1, [pc, #116]	; (8017588 <hci_transport_h4_packet_complete+0x8c>)
 8017512:	4618      	mov	r0, r3
 8017514:	f010 faa2 	bl	8027a5c <memcmp>
 8017518:	4603      	mov	r3, r0
 801751a:	2b00      	cmp	r3, #0
 801751c:	d11b      	bne.n	8017556 <hci_transport_h4_packet_complete+0x5a>
#ifdef ENABLE_CC256X_BAUDRATE_CHANGE_FLOWCONTROL_BUG_WORKAROUND
                if (little_endian_read_16(hci_packet, 11) == BLUETOOTH_COMPANY_ID_TEXAS_INSTRUMENTS_INC){
 801751e:	4b19      	ldr	r3, [pc, #100]	; (8017584 <hci_transport_h4_packet_complete+0x88>)
 8017520:	681b      	ldr	r3, [r3, #0]
 8017522:	210b      	movs	r1, #11
 8017524:	4618      	mov	r0, r3
 8017526:	f7f7 fc5e 	bl	800ede6 <little_endian_read_16>
 801752a:	4603      	mov	r3, r0
 801752c:	2b0d      	cmp	r3, #13
 801752e:	d109      	bne.n	8017544 <hci_transport_h4_packet_complete+0x48>
                    // detect TI CC256x controller based on manufacturer
                    log_info("Detected CC256x controller");
 8017530:	23c5      	movs	r3, #197	; 0xc5
 8017532:	4a16      	ldr	r2, [pc, #88]	; (801758c <hci_transport_h4_packet_complete+0x90>)
 8017534:	4916      	ldr	r1, [pc, #88]	; (8017590 <hci_transport_h4_packet_complete+0x94>)
 8017536:	2001      	movs	r0, #1
 8017538:	f7ff ff82 	bl	8017440 <hci_dump_log>
                    baudrate_change_workaround_state = BAUDRATE_CHANGE_WORKAROUND_CHIPSET_DETECTED;
 801753c:	4b10      	ldr	r3, [pc, #64]	; (8017580 <hci_transport_h4_packet_complete+0x84>)
 801753e:	2201      	movs	r2, #1
 8017540:	701a      	strb	r2, [r3, #0]
 8017542:	e008      	b.n	8017556 <hci_transport_h4_packet_complete+0x5a>
                } else {
                    // work around not needed
                    log_info("Bluetooth controller not by TI");
 8017544:	23c9      	movs	r3, #201	; 0xc9
 8017546:	4a11      	ldr	r2, [pc, #68]	; (801758c <hci_transport_h4_packet_complete+0x90>)
 8017548:	4912      	ldr	r1, [pc, #72]	; (8017594 <hci_transport_h4_packet_complete+0x98>)
 801754a:	2001      	movs	r0, #1
 801754c:	f7ff ff78 	bl	8017440 <hci_dump_log>
                    baudrate_change_workaround_state = BAUDRATE_CHANGE_WORKAROUND_DONE;
 8017550:	4b0b      	ldr	r3, [pc, #44]	; (8017580 <hci_transport_h4_packet_complete+0x84>)
 8017552:	2203      	movs	r2, #3
 8017554:	701a      	strb	r2, [r3, #0]
                    baudrate_change_workaround_state = BAUDRATE_CHANGE_WORKAROUND_DONE;
                }
#endif
            }
#endif
    uint16_t packet_len = read_pos-1u;
 8017556:	4b10      	ldr	r3, [pc, #64]	; (8017598 <hci_transport_h4_packet_complete+0x9c>)
 8017558:	881b      	ldrh	r3, [r3, #0]
 801755a:	3b01      	subs	r3, #1
 801755c:	80fb      	strh	r3, [r7, #6]

    // reset state machine before delivering packet to stack as it might close the transport
    hci_transport_h4_reset_statemachine();
 801755e:	f7ff ff9f 	bl	80174a0 <hci_transport_h4_reset_statemachine>
    packet_handler(hci_packet[0], &hci_packet[1], packet_len);
 8017562:	4b0e      	ldr	r3, [pc, #56]	; (801759c <hci_transport_h4_packet_complete+0xa0>)
 8017564:	681b      	ldr	r3, [r3, #0]
 8017566:	4a07      	ldr	r2, [pc, #28]	; (8017584 <hci_transport_h4_packet_complete+0x88>)
 8017568:	6812      	ldr	r2, [r2, #0]
 801756a:	7810      	ldrb	r0, [r2, #0]
 801756c:	4a05      	ldr	r2, [pc, #20]	; (8017584 <hci_transport_h4_packet_complete+0x88>)
 801756e:	6812      	ldr	r2, [r2, #0]
 8017570:	1c51      	adds	r1, r2, #1
 8017572:	88fa      	ldrh	r2, [r7, #6]
 8017574:	4798      	blx	r3
}
 8017576:	bf00      	nop
 8017578:	3708      	adds	r7, #8
 801757a:	46bd      	mov	sp, r7
 801757c:	bd80      	pop	{r7, pc}
 801757e:	bf00      	nop
 8017580:	20009e66 	.word	0x20009e66
 8017584:	20000040 	.word	0x20000040
 8017588:	08030c4c 	.word	0x08030c4c
 801758c:	0802af8c 	.word	0x0802af8c
 8017590:	0802afcc 	.word	0x0802afcc
 8017594:	0802aff0 	.word	0x0802aff0
 8017598:	200097b0 	.word	0x200097b0
 801759c:	2000003c 	.word	0x2000003c

080175a0 <hci_transport_h4_block_read>:

static void hci_transport_h4_block_read(void){
 80175a0:	b580      	push	{r7, lr}
 80175a2:	b082      	sub	sp, #8
 80175a4:	af02      	add	r7, sp, #8

    read_pos += bytes_to_read;
 80175a6:	4b6c      	ldr	r3, [pc, #432]	; (8017758 <hci_transport_h4_block_read+0x1b8>)
 80175a8:	881a      	ldrh	r2, [r3, #0]
 80175aa:	4b6c      	ldr	r3, [pc, #432]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 80175ac:	881b      	ldrh	r3, [r3, #0]
 80175ae:	4413      	add	r3, r2
 80175b0:	b29a      	uxth	r2, r3
 80175b2:	4b69      	ldr	r3, [pc, #420]	; (8017758 <hci_transport_h4_block_read+0x1b8>)
 80175b4:	801a      	strh	r2, [r3, #0]

    switch (h4_state) {
 80175b6:	4b6a      	ldr	r3, [pc, #424]	; (8017760 <hci_transport_h4_block_read+0x1c0>)
 80175b8:	781b      	ldrb	r3, [r3, #0]
 80175ba:	2b05      	cmp	r3, #5
 80175bc:	f200 80ab 	bhi.w	8017716 <hci_transport_h4_block_read+0x176>
 80175c0:	a201      	add	r2, pc, #4	; (adr r2, 80175c8 <hci_transport_h4_block_read+0x28>)
 80175c2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80175c6:	bf00      	nop
 80175c8:	0801770f 	.word	0x0801770f
 80175cc:	080175e1 	.word	0x080175e1
 80175d0:	0801763b 	.word	0x0801763b
 80175d4:	0801767f 	.word	0x0801767f
 80175d8:	080176c7 	.word	0x080176c7
 80175dc:	08017709 	.word	0x08017709
        case H4_W4_PACKET_TYPE:
            switch (hci_packet[0]){
 80175e0:	4b60      	ldr	r3, [pc, #384]	; (8017764 <hci_transport_h4_block_read+0x1c4>)
 80175e2:	681b      	ldr	r3, [r3, #0]
 80175e4:	781b      	ldrb	r3, [r3, #0]
 80175e6:	2b03      	cmp	r3, #3
 80175e8:	d012      	beq.n	8017610 <hci_transport_h4_block_read+0x70>
 80175ea:	2b04      	cmp	r3, #4
 80175ec:	d002      	beq.n	80175f4 <hci_transport_h4_block_read+0x54>
 80175ee:	2b02      	cmp	r3, #2
 80175f0:	d007      	beq.n	8017602 <hci_transport_h4_block_read+0x62>
 80175f2:	e014      	b.n	801761e <hci_transport_h4_block_read+0x7e>
                case HCI_EVENT_PACKET:
                    bytes_to_read = HCI_EVENT_HEADER_SIZE;
 80175f4:	4b59      	ldr	r3, [pc, #356]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 80175f6:	2202      	movs	r2, #2
 80175f8:	801a      	strh	r2, [r3, #0]
                    h4_state = H4_W4_EVENT_HEADER;
 80175fa:	4b59      	ldr	r3, [pc, #356]	; (8017760 <hci_transport_h4_block_read+0x1c0>)
 80175fc:	2202      	movs	r2, #2
 80175fe:	701a      	strb	r2, [r3, #0]
                    break;
 8017600:	e01a      	b.n	8017638 <hci_transport_h4_block_read+0x98>
                case HCI_ACL_DATA_PACKET:
                    bytes_to_read = HCI_ACL_HEADER_SIZE;
 8017602:	4b56      	ldr	r3, [pc, #344]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 8017604:	2204      	movs	r2, #4
 8017606:	801a      	strh	r2, [r3, #0]
                    h4_state = H4_W4_ACL_HEADER;
 8017608:	4b55      	ldr	r3, [pc, #340]	; (8017760 <hci_transport_h4_block_read+0x1c0>)
 801760a:	2203      	movs	r2, #3
 801760c:	701a      	strb	r2, [r3, #0]
                    break;
 801760e:	e013      	b.n	8017638 <hci_transport_h4_block_read+0x98>
                case HCI_SCO_DATA_PACKET:
                    bytes_to_read = HCI_SCO_HEADER_SIZE;
 8017610:	4b52      	ldr	r3, [pc, #328]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 8017612:	2203      	movs	r2, #3
 8017614:	801a      	strh	r2, [r3, #0]
                    h4_state = H4_W4_SCO_HEADER;
 8017616:	4b52      	ldr	r3, [pc, #328]	; (8017760 <hci_transport_h4_block_read+0x1c0>)
 8017618:	2204      	movs	r2, #4
 801761a:	701a      	strb	r2, [r3, #0]
                    break;
 801761c:	e00c      	b.n	8017638 <hci_transport_h4_block_read+0x98>
                    hci_transport_h4_ehcill_handle_command(hci_packet[0]);
                    hci_transport_h4_reset_statemachine();
                    break;
#endif
                default:
                    log_error("hci_transport_h4: invalid packet type 0x%02x", hci_packet[0]);
 801761e:	4b51      	ldr	r3, [pc, #324]	; (8017764 <hci_transport_h4_block_read+0x1c4>)
 8017620:	681b      	ldr	r3, [r3, #0]
 8017622:	781b      	ldrb	r3, [r3, #0]
 8017624:	9300      	str	r3, [sp, #0]
 8017626:	23fe      	movs	r3, #254	; 0xfe
 8017628:	4a4f      	ldr	r2, [pc, #316]	; (8017768 <hci_transport_h4_block_read+0x1c8>)
 801762a:	4950      	ldr	r1, [pc, #320]	; (801776c <hci_transport_h4_block_read+0x1cc>)
 801762c:	2002      	movs	r0, #2
 801762e:	f7ff ff07 	bl	8017440 <hci_dump_log>
                    hci_transport_h4_reset_statemachine();
 8017632:	f7ff ff35 	bl	80174a0 <hci_transport_h4_reset_statemachine>
                    break;
 8017636:	bf00      	nop
            }
            break;
 8017638:	e06e      	b.n	8017718 <hci_transport_h4_block_read+0x178>
            
        case H4_W4_EVENT_HEADER:
            bytes_to_read = hci_packet[2];
 801763a:	4b4a      	ldr	r3, [pc, #296]	; (8017764 <hci_transport_h4_block_read+0x1c4>)
 801763c:	681b      	ldr	r3, [r3, #0]
 801763e:	3302      	adds	r3, #2
 8017640:	781b      	ldrb	r3, [r3, #0]
 8017642:	b29a      	uxth	r2, r3
 8017644:	4b45      	ldr	r3, [pc, #276]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 8017646:	801a      	strh	r2, [r3, #0]
            // check Event length
            if (bytes_to_read > (HCI_INCOMING_PACKET_BUFFER_SIZE - HCI_EVENT_HEADER_SIZE)){
 8017648:	4b44      	ldr	r3, [pc, #272]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 801764a:	881b      	ldrh	r3, [r3, #0]
 801764c:	f240 62a1 	movw	r2, #1697	; 0x6a1
 8017650:	4293      	cmp	r3, r2
 8017652:	d910      	bls.n	8017676 <hci_transport_h4_block_read+0xd6>
                log_error("hci_transport_h4: invalid Event len %d - only space for %u", bytes_to_read, HCI_INCOMING_PACKET_BUFFER_SIZE - HCI_EVENT_HEADER_SIZE);
 8017654:	4b41      	ldr	r3, [pc, #260]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 8017656:	881b      	ldrh	r3, [r3, #0]
 8017658:	461a      	mov	r2, r3
 801765a:	f240 63a1 	movw	r3, #1697	; 0x6a1
 801765e:	9301      	str	r3, [sp, #4]
 8017660:	9200      	str	r2, [sp, #0]
 8017662:	f44f 7384 	mov.w	r3, #264	; 0x108
 8017666:	4a40      	ldr	r2, [pc, #256]	; (8017768 <hci_transport_h4_block_read+0x1c8>)
 8017668:	4941      	ldr	r1, [pc, #260]	; (8017770 <hci_transport_h4_block_read+0x1d0>)
 801766a:	2002      	movs	r0, #2
 801766c:	f7ff fee8 	bl	8017440 <hci_dump_log>
                hci_transport_h4_reset_statemachine();
 8017670:	f7ff ff16 	bl	80174a0 <hci_transport_h4_reset_statemachine>
                break;
 8017674:	e050      	b.n	8017718 <hci_transport_h4_block_read+0x178>
            }
            h4_state = H4_W4_PAYLOAD;
 8017676:	4b3a      	ldr	r3, [pc, #232]	; (8017760 <hci_transport_h4_block_read+0x1c0>)
 8017678:	2205      	movs	r2, #5
 801767a:	701a      	strb	r2, [r3, #0]
            break;
 801767c:	e04c      	b.n	8017718 <hci_transport_h4_block_read+0x178>
            
        case H4_W4_ACL_HEADER:
            bytes_to_read = little_endian_read_16( hci_packet, 3);
 801767e:	4b39      	ldr	r3, [pc, #228]	; (8017764 <hci_transport_h4_block_read+0x1c4>)
 8017680:	681b      	ldr	r3, [r3, #0]
 8017682:	2103      	movs	r1, #3
 8017684:	4618      	mov	r0, r3
 8017686:	f7f7 fbae 	bl	800ede6 <little_endian_read_16>
 801768a:	4603      	mov	r3, r0
 801768c:	461a      	mov	r2, r3
 801768e:	4b33      	ldr	r3, [pc, #204]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 8017690:	801a      	strh	r2, [r3, #0]
            // check ACL length
            if (bytes_to_read > (HCI_INCOMING_PACKET_BUFFER_SIZE - HCI_ACL_HEADER_SIZE)){
 8017692:	4b32      	ldr	r3, [pc, #200]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 8017694:	881b      	ldrh	r3, [r3, #0]
 8017696:	f5b3 6fd4 	cmp.w	r3, #1696	; 0x6a0
 801769a:	d310      	bcc.n	80176be <hci_transport_h4_block_read+0x11e>
                log_error("hci_transport_h4: invalid ACL payload len %d - only space for %u", bytes_to_read, HCI_INCOMING_PACKET_BUFFER_SIZE - HCI_ACL_HEADER_SIZE);
 801769c:	4b2f      	ldr	r3, [pc, #188]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 801769e:	881b      	ldrh	r3, [r3, #0]
 80176a0:	461a      	mov	r2, r3
 80176a2:	f240 639f 	movw	r3, #1695	; 0x69f
 80176a6:	9301      	str	r3, [sp, #4]
 80176a8:	9200      	str	r2, [sp, #0]
 80176aa:	f240 1313 	movw	r3, #275	; 0x113
 80176ae:	4a2e      	ldr	r2, [pc, #184]	; (8017768 <hci_transport_h4_block_read+0x1c8>)
 80176b0:	4930      	ldr	r1, [pc, #192]	; (8017774 <hci_transport_h4_block_read+0x1d4>)
 80176b2:	2002      	movs	r0, #2
 80176b4:	f7ff fec4 	bl	8017440 <hci_dump_log>
                hci_transport_h4_reset_statemachine();
 80176b8:	f7ff fef2 	bl	80174a0 <hci_transport_h4_reset_statemachine>
                break;
 80176bc:	e02c      	b.n	8017718 <hci_transport_h4_block_read+0x178>
            }
            h4_state = H4_W4_PAYLOAD;
 80176be:	4b28      	ldr	r3, [pc, #160]	; (8017760 <hci_transport_h4_block_read+0x1c0>)
 80176c0:	2205      	movs	r2, #5
 80176c2:	701a      	strb	r2, [r3, #0]
            break;
 80176c4:	e028      	b.n	8017718 <hci_transport_h4_block_read+0x178>
            
        case H4_W4_SCO_HEADER:
            bytes_to_read = hci_packet[3];
 80176c6:	4b27      	ldr	r3, [pc, #156]	; (8017764 <hci_transport_h4_block_read+0x1c4>)
 80176c8:	681b      	ldr	r3, [r3, #0]
 80176ca:	3303      	adds	r3, #3
 80176cc:	781b      	ldrb	r3, [r3, #0]
 80176ce:	b29a      	uxth	r2, r3
 80176d0:	4b22      	ldr	r3, [pc, #136]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 80176d2:	801a      	strh	r2, [r3, #0]
            // check SCO length
            if (bytes_to_read > (HCI_INCOMING_PACKET_BUFFER_SIZE - HCI_SCO_HEADER_SIZE)){
 80176d4:	4b21      	ldr	r3, [pc, #132]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 80176d6:	881b      	ldrh	r3, [r3, #0]
 80176d8:	f5b3 6fd4 	cmp.w	r3, #1696	; 0x6a0
 80176dc:	d910      	bls.n	8017700 <hci_transport_h4_block_read+0x160>
                log_error("hci_transport_h4: invalid SCO payload len %d - only space for %u", bytes_to_read, HCI_INCOMING_PACKET_BUFFER_SIZE - HCI_SCO_HEADER_SIZE);
 80176de:	4b1f      	ldr	r3, [pc, #124]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 80176e0:	881b      	ldrh	r3, [r3, #0]
 80176e2:	461a      	mov	r2, r3
 80176e4:	f44f 63d4 	mov.w	r3, #1696	; 0x6a0
 80176e8:	9301      	str	r3, [sp, #4]
 80176ea:	9200      	str	r2, [sp, #0]
 80176ec:	f44f 738f 	mov.w	r3, #286	; 0x11e
 80176f0:	4a1d      	ldr	r2, [pc, #116]	; (8017768 <hci_transport_h4_block_read+0x1c8>)
 80176f2:	4921      	ldr	r1, [pc, #132]	; (8017778 <hci_transport_h4_block_read+0x1d8>)
 80176f4:	2002      	movs	r0, #2
 80176f6:	f7ff fea3 	bl	8017440 <hci_dump_log>
                hci_transport_h4_reset_statemachine();
 80176fa:	f7ff fed1 	bl	80174a0 <hci_transport_h4_reset_statemachine>
                break;
 80176fe:	e00b      	b.n	8017718 <hci_transport_h4_block_read+0x178>
            }
            h4_state = H4_W4_PAYLOAD;
 8017700:	4b17      	ldr	r3, [pc, #92]	; (8017760 <hci_transport_h4_block_read+0x1c0>)
 8017702:	2205      	movs	r2, #5
 8017704:	701a      	strb	r2, [r3, #0]
            break;
 8017706:	e007      	b.n	8017718 <hci_transport_h4_block_read+0x178>

        case H4_W4_PAYLOAD:
            hci_transport_h4_packet_complete();
 8017708:	f7ff fef8 	bl	80174fc <hci_transport_h4_packet_complete>
            break;
 801770c:	e004      	b.n	8017718 <hci_transport_h4_block_read+0x178>

        case H4_OFF:
            bytes_to_read = 0;
 801770e:	4b13      	ldr	r3, [pc, #76]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 8017710:	2200      	movs	r2, #0
 8017712:	801a      	strh	r2, [r3, #0]
            break;
 8017714:	e000      	b.n	8017718 <hci_transport_h4_block_read+0x178>
        default:
            btstack_assert(false);
            break; 
 8017716:	bf00      	nop
    }

#ifdef ENABLE_BAUDRATE_CHANGE_FLOWCONTROL_BUG_WORKAROUND
    if (baudrate_change_workaround_state == BAUDRATE_CHANGE_WORKAROUND_BAUDRATE_COMMAND_SENT){
 8017718:	4b18      	ldr	r3, [pc, #96]	; (801777c <hci_transport_h4_block_read+0x1dc>)
 801771a:	781b      	ldrb	r3, [r3, #0]
 801771c:	2b02      	cmp	r3, #2
 801771e:	d108      	bne.n	8017732 <hci_transport_h4_block_read+0x192>
        baudrate_change_workaround_state = BAUDRATE_CHANGE_WORKAROUND_IDLE;
 8017720:	4b16      	ldr	r3, [pc, #88]	; (801777c <hci_transport_h4_block_read+0x1dc>)
 8017722:	2200      	movs	r2, #0
 8017724:	701a      	strb	r2, [r3, #0]
        // avoid flowcontrol problem by reading expected hci command complete event of 7 bytes in a single block read
        h4_state = H4_W4_PAYLOAD;
 8017726:	4b0e      	ldr	r3, [pc, #56]	; (8017760 <hci_transport_h4_block_read+0x1c0>)
 8017728:	2205      	movs	r2, #5
 801772a:	701a      	strb	r2, [r3, #0]
        bytes_to_read = 7;
 801772c:	4b0b      	ldr	r3, [pc, #44]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 801772e:	2207      	movs	r2, #7
 8017730:	801a      	strh	r2, [r3, #0]
    }
#endif

    // forward packet if payload size == 0
    if (h4_state == H4_W4_PAYLOAD && bytes_to_read == 0u) {
 8017732:	4b0b      	ldr	r3, [pc, #44]	; (8017760 <hci_transport_h4_block_read+0x1c0>)
 8017734:	781b      	ldrb	r3, [r3, #0]
 8017736:	2b05      	cmp	r3, #5
 8017738:	d105      	bne.n	8017746 <hci_transport_h4_block_read+0x1a6>
 801773a:	4b08      	ldr	r3, [pc, #32]	; (801775c <hci_transport_h4_block_read+0x1bc>)
 801773c:	881b      	ldrh	r3, [r3, #0]
 801773e:	2b00      	cmp	r3, #0
 8017740:	d101      	bne.n	8017746 <hci_transport_h4_block_read+0x1a6>
        hci_transport_h4_packet_complete();
 8017742:	f7ff fedb 	bl	80174fc <hci_transport_h4_packet_complete>
    }

    if (h4_state != H4_OFF) {
 8017746:	4b06      	ldr	r3, [pc, #24]	; (8017760 <hci_transport_h4_block_read+0x1c0>)
 8017748:	781b      	ldrb	r3, [r3, #0]
 801774a:	2b00      	cmp	r3, #0
 801774c:	d001      	beq.n	8017752 <hci_transport_h4_block_read+0x1b2>
        hci_transport_h4_trigger_next_read();
 801774e:	f7ff febd 	bl	80174cc <hci_transport_h4_trigger_next_read>
    }
}
 8017752:	bf00      	nop
 8017754:	46bd      	mov	sp, r7
 8017756:	bd80      	pop	{r7, pc}
 8017758:	200097b0 	.word	0x200097b0
 801775c:	200097ae 	.word	0x200097ae
 8017760:	200097ad 	.word	0x200097ad
 8017764:	20000040 	.word	0x20000040
 8017768:	0802af8c 	.word	0x0802af8c
 801776c:	0802b018 	.word	0x0802b018
 8017770:	0802b04c 	.word	0x0802b04c
 8017774:	0802b090 	.word	0x0802b090
 8017778:	0802b0d8 	.word	0x0802b0d8
 801777c:	20009e66 	.word	0x20009e66

08017780 <hci_transport_h4_block_sent>:

static void hci_transport_h4_block_sent(void){
 8017780:	b580      	push	{r7, lr}
 8017782:	af00      	add	r7, sp, #0

    static const uint8_t packet_sent_event[] = { HCI_EVENT_TRANSPORT_PACKET_SENT, 0};

    switch (tx_state){
 8017784:	4b08      	ldr	r3, [pc, #32]	; (80177a8 <hci_transport_h4_block_sent+0x28>)
 8017786:	781b      	ldrb	r3, [r3, #0]
 8017788:	2b02      	cmp	r3, #2
 801778a:	d000      	beq.n	801778e <hci_transport_h4_block_sent+0xe>
            hci_transport_h4_ehcill_handle_ehcill_command_sent();
            break;
#endif

        default:
            break;
 801778c:	e009      	b.n	80177a2 <hci_transport_h4_block_sent+0x22>
            tx_state = TX_IDLE;
 801778e:	4b06      	ldr	r3, [pc, #24]	; (80177a8 <hci_transport_h4_block_sent+0x28>)
 8017790:	2201      	movs	r2, #1
 8017792:	701a      	strb	r2, [r3, #0]
            packet_handler(HCI_EVENT_PACKET, (uint8_t *) &packet_sent_event[0], sizeof(packet_sent_event));
 8017794:	4b05      	ldr	r3, [pc, #20]	; (80177ac <hci_transport_h4_block_sent+0x2c>)
 8017796:	681b      	ldr	r3, [r3, #0]
 8017798:	2202      	movs	r2, #2
 801779a:	4905      	ldr	r1, [pc, #20]	; (80177b0 <hci_transport_h4_block_sent+0x30>)
 801779c:	2004      	movs	r0, #4
 801779e:	4798      	blx	r3
            break;
 80177a0:	bf00      	nop
    }
}
 80177a2:	bf00      	nop
 80177a4:	bd80      	pop	{r7, pc}
 80177a6:	bf00      	nop
 80177a8:	200097ac 	.word	0x200097ac
 80177ac:	2000003c 	.word	0x2000003c
 80177b0:	08030c54 	.word	0x08030c54

080177b4 <hci_transport_h4_can_send_now>:

static int hci_transport_h4_can_send_now(uint8_t packet_type){
 80177b4:	b480      	push	{r7}
 80177b6:	b083      	sub	sp, #12
 80177b8:	af00      	add	r7, sp, #0
 80177ba:	4603      	mov	r3, r0
 80177bc:	71fb      	strb	r3, [r7, #7]
    UNUSED(packet_type);
    return tx_state == TX_IDLE;
 80177be:	4b06      	ldr	r3, [pc, #24]	; (80177d8 <hci_transport_h4_can_send_now+0x24>)
 80177c0:	781b      	ldrb	r3, [r3, #0]
 80177c2:	2b01      	cmp	r3, #1
 80177c4:	bf0c      	ite	eq
 80177c6:	2301      	moveq	r3, #1
 80177c8:	2300      	movne	r3, #0
 80177ca:	b2db      	uxtb	r3, r3
}
 80177cc:	4618      	mov	r0, r3
 80177ce:	370c      	adds	r7, #12
 80177d0:	46bd      	mov	sp, r7
 80177d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80177d6:	4770      	bx	lr
 80177d8:	200097ac 	.word	0x200097ac

080177dc <hci_transport_h4_send_packet>:

static int hci_transport_h4_send_packet(uint8_t packet_type, uint8_t * packet, int size){
 80177dc:	b580      	push	{r7, lr}
 80177de:	b084      	sub	sp, #16
 80177e0:	af00      	add	r7, sp, #0
 80177e2:	4603      	mov	r3, r0
 80177e4:	60b9      	str	r1, [r7, #8]
 80177e6:	607a      	str	r2, [r7, #4]
 80177e8:	73fb      	strb	r3, [r7, #15]

    // store packet type before actual data and increase size
    size++;
 80177ea:	687b      	ldr	r3, [r7, #4]
 80177ec:	3301      	adds	r3, #1
 80177ee:	607b      	str	r3, [r7, #4]
    packet--;
 80177f0:	68bb      	ldr	r3, [r7, #8]
 80177f2:	3b01      	subs	r3, #1
 80177f4:	60bb      	str	r3, [r7, #8]
    *packet = packet_type;
 80177f6:	68bb      	ldr	r3, [r7, #8]
 80177f8:	7bfa      	ldrb	r2, [r7, #15]
 80177fa:	701a      	strb	r2, [r3, #0]

#ifdef ENABLE_BAUDRATE_CHANGE_FLOWCONTROL_BUG_WORKAROUND
    if ((baudrate_change_workaround_state == BAUDRATE_CHANGE_WORKAROUND_CHIPSET_DETECTED)
 80177fc:	4b12      	ldr	r3, [pc, #72]	; (8017848 <hci_transport_h4_send_packet+0x6c>)
 80177fe:	781b      	ldrb	r3, [r3, #0]
 8017800:	2b01      	cmp	r3, #1
 8017802:	d111      	bne.n	8017828 <hci_transport_h4_send_packet+0x4c>
    && (memcmp(packet, baud_rate_command_prefix, sizeof(baud_rate_command_prefix)) == 0)) {
 8017804:	2204      	movs	r2, #4
 8017806:	4911      	ldr	r1, [pc, #68]	; (801784c <hci_transport_h4_send_packet+0x70>)
 8017808:	68b8      	ldr	r0, [r7, #8]
 801780a:	f010 f927 	bl	8027a5c <memcmp>
 801780e:	4603      	mov	r3, r0
 8017810:	2b00      	cmp	r3, #0
 8017812:	d109      	bne.n	8017828 <hci_transport_h4_send_packet+0x4c>
        log_info("Baud rate command detected, expect command complete event next");
 8017814:	f240 1373 	movw	r3, #371	; 0x173
 8017818:	4a0d      	ldr	r2, [pc, #52]	; (8017850 <hci_transport_h4_send_packet+0x74>)
 801781a:	490e      	ldr	r1, [pc, #56]	; (8017854 <hci_transport_h4_send_packet+0x78>)
 801781c:	2001      	movs	r0, #1
 801781e:	f7ff fe0f 	bl	8017440 <hci_dump_log>
        baudrate_change_workaround_state = BAUDRATE_CHANGE_WORKAROUND_BAUDRATE_COMMAND_SENT;
 8017822:	4b09      	ldr	r3, [pc, #36]	; (8017848 <hci_transport_h4_send_packet+0x6c>)
 8017824:	2202      	movs	r2, #2
 8017826:	701a      	strb	r2, [r3, #0]
            break;    
    }
#endif

    // start sending
    tx_state = TX_W4_PACKET_SENT;
 8017828:	4b0b      	ldr	r3, [pc, #44]	; (8017858 <hci_transport_h4_send_packet+0x7c>)
 801782a:	2202      	movs	r2, #2
 801782c:	701a      	strb	r2, [r3, #0]
    btstack_uart->send_block(packet, size);
 801782e:	4b0b      	ldr	r3, [pc, #44]	; (801785c <hci_transport_h4_send_packet+0x80>)
 8017830:	681b      	ldr	r3, [r3, #0]
 8017832:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017834:	687a      	ldr	r2, [r7, #4]
 8017836:	b292      	uxth	r2, r2
 8017838:	4611      	mov	r1, r2
 801783a:	68b8      	ldr	r0, [r7, #8]
 801783c:	4798      	blx	r3
    return 0;
 801783e:	2300      	movs	r3, #0
}
 8017840:	4618      	mov	r0, r3
 8017842:	3710      	adds	r7, #16
 8017844:	46bd      	mov	sp, r7
 8017846:	bd80      	pop	{r7, pc}
 8017848:	20009e66 	.word	0x20009e66
 801784c:	08030c48 	.word	0x08030c48
 8017850:	0802af8c 	.word	0x0802af8c
 8017854:	0802b120 	.word	0x0802b120
 8017858:	200097ac 	.word	0x200097ac
 801785c:	2000979c 	.word	0x2000979c

08017860 <hci_transport_h4_init>:

static void hci_transport_h4_init(const void * transport_config){
 8017860:	b580      	push	{r7, lr}
 8017862:	b084      	sub	sp, #16
 8017864:	af00      	add	r7, sp, #0
 8017866:	6078      	str	r0, [r7, #4]
    // check for hci_transport_config_uart_t
    if (!transport_config) {
 8017868:	687b      	ldr	r3, [r7, #4]
 801786a:	2b00      	cmp	r3, #0
 801786c:	d107      	bne.n	801787e <hci_transport_h4_init+0x1e>
        log_error("hci_transport_h4: no config!");
 801786e:	f240 1391 	movw	r3, #401	; 0x191
 8017872:	4a1c      	ldr	r2, [pc, #112]	; (80178e4 <hci_transport_h4_init+0x84>)
 8017874:	491c      	ldr	r1, [pc, #112]	; (80178e8 <hci_transport_h4_init+0x88>)
 8017876:	2002      	movs	r0, #2
 8017878:	f7ff fde2 	bl	8017440 <hci_dump_log>
        return;
 801787c:	e02e      	b.n	80178dc <hci_transport_h4_init+0x7c>
    }
    if (((hci_transport_config_t*)transport_config)->type != HCI_TRANSPORT_CONFIG_UART) {
 801787e:	687b      	ldr	r3, [r7, #4]
 8017880:	781b      	ldrb	r3, [r3, #0]
 8017882:	2b00      	cmp	r3, #0
 8017884:	d007      	beq.n	8017896 <hci_transport_h4_init+0x36>
        log_error("hci_transport_h4: config not of type != HCI_TRANSPORT_CONFIG_UART!");
 8017886:	f240 1395 	movw	r3, #405	; 0x195
 801788a:	4a16      	ldr	r2, [pc, #88]	; (80178e4 <hci_transport_h4_init+0x84>)
 801788c:	4917      	ldr	r1, [pc, #92]	; (80178ec <hci_transport_h4_init+0x8c>)
 801788e:	2002      	movs	r0, #2
 8017890:	f7ff fdd6 	bl	8017440 <hci_dump_log>
        return;
 8017894:	e022      	b.n	80178dc <hci_transport_h4_init+0x7c>
    }

    // extract UART config from transport config
    hci_transport_config_uart_t * hci_transport_config_uart = (hci_transport_config_uart_t*) transport_config;
 8017896:	687b      	ldr	r3, [r7, #4]
 8017898:	60fb      	str	r3, [r7, #12]
    uart_config.baudrate    = hci_transport_config_uart->baudrate_init;
 801789a:	68fb      	ldr	r3, [r7, #12]
 801789c:	685b      	ldr	r3, [r3, #4]
 801789e:	4a14      	ldr	r2, [pc, #80]	; (80178f0 <hci_transport_h4_init+0x90>)
 80178a0:	6013      	str	r3, [r2, #0]
    uart_config.flowcontrol = hci_transport_config_uart->flowcontrol;
 80178a2:	68fb      	ldr	r3, [r7, #12]
 80178a4:	68db      	ldr	r3, [r3, #12]
 80178a6:	4a12      	ldr	r2, [pc, #72]	; (80178f0 <hci_transport_h4_init+0x90>)
 80178a8:	6053      	str	r3, [r2, #4]
    uart_config.device_name = hci_transport_config_uart->device_name;
 80178aa:	68fb      	ldr	r3, [r7, #12]
 80178ac:	691b      	ldr	r3, [r3, #16]
 80178ae:	4a10      	ldr	r2, [pc, #64]	; (80178f0 <hci_transport_h4_init+0x90>)
 80178b0:	6093      	str	r3, [r2, #8]

    // set state to off
    tx_state = TX_OFF;
 80178b2:	4b10      	ldr	r3, [pc, #64]	; (80178f4 <hci_transport_h4_init+0x94>)
 80178b4:	2200      	movs	r2, #0
 80178b6:	701a      	strb	r2, [r3, #0]
    h4_state = H4_OFF;
 80178b8:	4b0f      	ldr	r3, [pc, #60]	; (80178f8 <hci_transport_h4_init+0x98>)
 80178ba:	2200      	movs	r2, #0
 80178bc:	701a      	strb	r2, [r3, #0]

    // setup UART driver
    btstack_uart->init(&uart_config);
 80178be:	4b0f      	ldr	r3, [pc, #60]	; (80178fc <hci_transport_h4_init+0x9c>)
 80178c0:	681b      	ldr	r3, [r3, #0]
 80178c2:	681b      	ldr	r3, [r3, #0]
 80178c4:	480a      	ldr	r0, [pc, #40]	; (80178f0 <hci_transport_h4_init+0x90>)
 80178c6:	4798      	blx	r3
    btstack_uart->set_block_received(&hci_transport_h4_block_read);
 80178c8:	4b0c      	ldr	r3, [pc, #48]	; (80178fc <hci_transport_h4_init+0x9c>)
 80178ca:	681b      	ldr	r3, [r3, #0]
 80178cc:	68db      	ldr	r3, [r3, #12]
 80178ce:	480c      	ldr	r0, [pc, #48]	; (8017900 <hci_transport_h4_init+0xa0>)
 80178d0:	4798      	blx	r3
    btstack_uart->set_block_sent(&hci_transport_h4_block_sent);
 80178d2:	4b0a      	ldr	r3, [pc, #40]	; (80178fc <hci_transport_h4_init+0x9c>)
 80178d4:	681b      	ldr	r3, [r3, #0]
 80178d6:	691b      	ldr	r3, [r3, #16]
 80178d8:	480a      	ldr	r0, [pc, #40]	; (8017904 <hci_transport_h4_init+0xa4>)
 80178da:	4798      	blx	r3
}
 80178dc:	3710      	adds	r7, #16
 80178de:	46bd      	mov	sp, r7
 80178e0:	bd80      	pop	{r7, pc}
 80178e2:	bf00      	nop
 80178e4:	0802af8c 	.word	0x0802af8c
 80178e8:	0802b168 	.word	0x0802b168
 80178ec:	0802b18c 	.word	0x0802b18c
 80178f0:	200097a0 	.word	0x200097a0
 80178f4:	200097ac 	.word	0x200097ac
 80178f8:	200097ad 	.word	0x200097ad
 80178fc:	2000979c 	.word	0x2000979c
 8017900:	080175a1 	.word	0x080175a1
 8017904:	08017781 	.word	0x08017781

08017908 <hci_transport_h4_open>:

static int hci_transport_h4_open(void){
 8017908:	b580      	push	{r7, lr}
 801790a:	b082      	sub	sp, #8
 801790c:	af00      	add	r7, sp, #0
    // open uart driver
    int res = btstack_uart->open();
 801790e:	4b0b      	ldr	r3, [pc, #44]	; (801793c <hci_transport_h4_open+0x34>)
 8017910:	681b      	ldr	r3, [r3, #0]
 8017912:	685b      	ldr	r3, [r3, #4]
 8017914:	4798      	blx	r3
 8017916:	6078      	str	r0, [r7, #4]
    if (res != 0){
 8017918:	687b      	ldr	r3, [r7, #4]
 801791a:	2b00      	cmp	r3, #0
 801791c:	d001      	beq.n	8017922 <hci_transport_h4_open+0x1a>
        return res;
 801791e:	687b      	ldr	r3, [r7, #4]
 8017920:	e007      	b.n	8017932 <hci_transport_h4_open+0x2a>
    }

    // init rx + tx state machines
    hci_transport_h4_reset_statemachine();
 8017922:	f7ff fdbd 	bl	80174a0 <hci_transport_h4_reset_statemachine>
    hci_transport_h4_trigger_next_read();
 8017926:	f7ff fdd1 	bl	80174cc <hci_transport_h4_trigger_next_read>
    tx_state = TX_IDLE;
 801792a:	4b05      	ldr	r3, [pc, #20]	; (8017940 <hci_transport_h4_open+0x38>)
 801792c:	2201      	movs	r2, #1
 801792e:	701a      	strb	r2, [r3, #0]

#ifdef ENABLE_EHCILL
    hci_transport_h4_ehcill_open();
#endif
    return 0;
 8017930:	2300      	movs	r3, #0
}
 8017932:	4618      	mov	r0, r3
 8017934:	3708      	adds	r7, #8
 8017936:	46bd      	mov	sp, r7
 8017938:	bd80      	pop	{r7, pc}
 801793a:	bf00      	nop
 801793c:	2000979c 	.word	0x2000979c
 8017940:	200097ac 	.word	0x200097ac

08017944 <hci_transport_h4_close>:

static int hci_transport_h4_close(void){
 8017944:	b580      	push	{r7, lr}
 8017946:	af00      	add	r7, sp, #0
    // set state to off
    tx_state = TX_OFF;
 8017948:	4b06      	ldr	r3, [pc, #24]	; (8017964 <hci_transport_h4_close+0x20>)
 801794a:	2200      	movs	r2, #0
 801794c:	701a      	strb	r2, [r3, #0]
    h4_state = H4_OFF;
 801794e:	4b06      	ldr	r3, [pc, #24]	; (8017968 <hci_transport_h4_close+0x24>)
 8017950:	2200      	movs	r2, #0
 8017952:	701a      	strb	r2, [r3, #0]

    // close uart driver
    return btstack_uart->close();
 8017954:	4b05      	ldr	r3, [pc, #20]	; (801796c <hci_transport_h4_close+0x28>)
 8017956:	681b      	ldr	r3, [r3, #0]
 8017958:	689b      	ldr	r3, [r3, #8]
 801795a:	4798      	blx	r3
 801795c:	4603      	mov	r3, r0
}
 801795e:	4618      	mov	r0, r3
 8017960:	bd80      	pop	{r7, pc}
 8017962:	bf00      	nop
 8017964:	200097ac 	.word	0x200097ac
 8017968:	200097ad 	.word	0x200097ad
 801796c:	2000979c 	.word	0x2000979c

08017970 <hci_transport_h4_register_packet_handler>:

static void hci_transport_h4_register_packet_handler(void (*handler)(uint8_t packet_type, uint8_t *packet, uint16_t size)){
 8017970:	b480      	push	{r7}
 8017972:	b083      	sub	sp, #12
 8017974:	af00      	add	r7, sp, #0
 8017976:	6078      	str	r0, [r7, #4]
    packet_handler = handler;
 8017978:	4a04      	ldr	r2, [pc, #16]	; (801798c <hci_transport_h4_register_packet_handler+0x1c>)
 801797a:	687b      	ldr	r3, [r7, #4]
 801797c:	6013      	str	r3, [r2, #0]
}
 801797e:	bf00      	nop
 8017980:	370c      	adds	r7, #12
 8017982:	46bd      	mov	sp, r7
 8017984:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017988:	4770      	bx	lr
 801798a:	bf00      	nop
 801798c:	2000003c 	.word	0x2000003c

08017990 <dummy_handler>:

static void dummy_handler(uint8_t packet_type, uint8_t *packet, uint16_t size){
 8017990:	b480      	push	{r7}
 8017992:	b083      	sub	sp, #12
 8017994:	af00      	add	r7, sp, #0
 8017996:	4603      	mov	r3, r0
 8017998:	6039      	str	r1, [r7, #0]
 801799a:	71fb      	strb	r3, [r7, #7]
 801799c:	4613      	mov	r3, r2
 801799e:	80bb      	strh	r3, [r7, #4]
    UNUSED(packet_type);
    UNUSED(packet);
    UNUSED(size);
}
 80179a0:	bf00      	nop
 80179a2:	370c      	adds	r7, #12
 80179a4:	46bd      	mov	sp, r7
 80179a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80179aa:	4770      	bx	lr

080179ac <hci_transport_h4_instance>:
#endif
// --- end of eHCILL implementation ---------


// configure and return h4 singleton
const hci_transport_t * hci_transport_h4_instance(const btstack_uart_block_t * uart_driver) {
 80179ac:	b480      	push	{r7}
 80179ae:	b083      	sub	sp, #12
 80179b0:	af00      	add	r7, sp, #0
 80179b2:	6078      	str	r0, [r7, #4]
            /* int    (*set_baudrate)(uint32_t baudrate); */                &hci_transport_h4_set_baudrate,
            /* void   (*reset_link)(void); */                               NULL,
            /* void   (*set_sco_config)(uint16_t voice_setting, int num_connections); */ NULL,
    };

    btstack_uart = uart_driver;
 80179b4:	4a04      	ldr	r2, [pc, #16]	; (80179c8 <hci_transport_h4_instance+0x1c>)
 80179b6:	687b      	ldr	r3, [r7, #4]
 80179b8:	6013      	str	r3, [r2, #0]
    return &hci_transport_h4;
 80179ba:	4b04      	ldr	r3, [pc, #16]	; (80179cc <hci_transport_h4_instance+0x20>)
}
 80179bc:	4618      	mov	r0, r3
 80179be:	370c      	adds	r7, #12
 80179c0:	46bd      	mov	sp, r7
 80179c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80179c6:	4770      	bx	lr
 80179c8:	2000979c 	.word	0x2000979c
 80179cc:	08030c58 	.word	0x08030c58

080179d0 <hci_event_packet_get_type>:
static inline uint8_t hci_event_packet_get_type(const uint8_t * event){
 80179d0:	b480      	push	{r7}
 80179d2:	b083      	sub	sp, #12
 80179d4:	af00      	add	r7, sp, #0
 80179d6:	6078      	str	r0, [r7, #4]
    return event[0];
 80179d8:	687b      	ldr	r3, [r7, #4]
 80179da:	781b      	ldrb	r3, [r3, #0]
}
 80179dc:	4618      	mov	r0, r3
 80179de:	370c      	adds	r7, #12
 80179e0:	46bd      	mov	sp, r7
 80179e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80179e6:	4770      	bx	lr

080179e8 <hci_event_command_status_get_status>:
static inline uint8_t hci_event_command_status_get_status(const uint8_t * event){
 80179e8:	b480      	push	{r7}
 80179ea:	b083      	sub	sp, #12
 80179ec:	af00      	add	r7, sp, #0
 80179ee:	6078      	str	r0, [r7, #4]
    return event[2];
 80179f0:	687b      	ldr	r3, [r7, #4]
 80179f2:	3302      	adds	r3, #2
 80179f4:	781b      	ldrb	r3, [r3, #0]
}
 80179f6:	4618      	mov	r0, r3
 80179f8:	370c      	adds	r7, #12
 80179fa:	46bd      	mov	sp, r7
 80179fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017a00:	4770      	bx	lr
	...

08017a04 <crc16_calc>:
    0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40, 0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841,
    0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40, 0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41,
    0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641, 0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040, 
};

static uint16_t crc16_calc(uint8_t * data, uint16_t len){
 8017a04:	b480      	push	{r7}
 8017a06:	b085      	sub	sp, #20
 8017a08:	af00      	add	r7, sp, #0
 8017a0a:	6078      	str	r0, [r7, #4]
 8017a0c:	460b      	mov	r3, r1
 8017a0e:	807b      	strh	r3, [r7, #2]
    uint16_t crc = 0;   // initial value = 0 
 8017a10:	2300      	movs	r3, #0
 8017a12:	81fb      	strh	r3, [r7, #14]
    while (len--){
 8017a14:	e00e      	b.n	8017a34 <crc16_calc+0x30>
        crc = (crc >> 8) ^ crc16_table[ (crc ^ ((uint16_t) *data++)) & 0x00FF ];
 8017a16:	89fb      	ldrh	r3, [r7, #14]
 8017a18:	0a1b      	lsrs	r3, r3, #8
 8017a1a:	b29a      	uxth	r2, r3
 8017a1c:	89f9      	ldrh	r1, [r7, #14]
 8017a1e:	687b      	ldr	r3, [r7, #4]
 8017a20:	1c58      	adds	r0, r3, #1
 8017a22:	6078      	str	r0, [r7, #4]
 8017a24:	781b      	ldrb	r3, [r3, #0]
 8017a26:	404b      	eors	r3, r1
 8017a28:	b2db      	uxtb	r3, r3
 8017a2a:	4908      	ldr	r1, [pc, #32]	; (8017a4c <crc16_calc+0x48>)
 8017a2c:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 8017a30:	4053      	eors	r3, r2
 8017a32:	81fb      	strh	r3, [r7, #14]
    while (len--){
 8017a34:	887b      	ldrh	r3, [r7, #2]
 8017a36:	1e5a      	subs	r2, r3, #1
 8017a38:	807a      	strh	r2, [r7, #2]
 8017a3a:	2b00      	cmp	r3, #0
 8017a3c:	d1eb      	bne.n	8017a16 <crc16_calc+0x12>
    }
    return crc;
 8017a3e:	89fb      	ldrh	r3, [r7, #14]
}
 8017a40:	4618      	mov	r0, r3
 8017a42:	3714      	adds	r7, #20
 8017a44:	46bd      	mov	sp, r7
 8017a46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017a4a:	4770      	bx	lr
 8017a4c:	08030c80 	.word	0x08030c80

08017a50 <l2cap_encanced_control_field_for_information_frame>:

static inline uint16_t l2cap_encanced_control_field_for_information_frame(uint8_t tx_seq, int final, uint8_t req_seq, l2cap_segmentation_and_reassembly_t sar){
 8017a50:	b480      	push	{r7}
 8017a52:	b083      	sub	sp, #12
 8017a54:	af00      	add	r7, sp, #0
 8017a56:	6039      	str	r1, [r7, #0]
 8017a58:	4611      	mov	r1, r2
 8017a5a:	461a      	mov	r2, r3
 8017a5c:	4603      	mov	r3, r0
 8017a5e:	71fb      	strb	r3, [r7, #7]
 8017a60:	460b      	mov	r3, r1
 8017a62:	71bb      	strb	r3, [r7, #6]
 8017a64:	4613      	mov	r3, r2
 8017a66:	717b      	strb	r3, [r7, #5]
    return (((uint16_t) sar) << 14) | (req_seq << 8) | (final << 7) | (tx_seq << 1) | 0; 
 8017a68:	797b      	ldrb	r3, [r7, #5]
 8017a6a:	039b      	lsls	r3, r3, #14
 8017a6c:	b21a      	sxth	r2, r3
 8017a6e:	79bb      	ldrb	r3, [r7, #6]
 8017a70:	021b      	lsls	r3, r3, #8
 8017a72:	b21b      	sxth	r3, r3
 8017a74:	4313      	orrs	r3, r2
 8017a76:	b21a      	sxth	r2, r3
 8017a78:	683b      	ldr	r3, [r7, #0]
 8017a7a:	01db      	lsls	r3, r3, #7
 8017a7c:	b21b      	sxth	r3, r3
 8017a7e:	4313      	orrs	r3, r2
 8017a80:	b21a      	sxth	r2, r3
 8017a82:	79fb      	ldrb	r3, [r7, #7]
 8017a84:	005b      	lsls	r3, r3, #1
 8017a86:	b21b      	sxth	r3, r3
 8017a88:	4313      	orrs	r3, r2
 8017a8a:	b21b      	sxth	r3, r3
 8017a8c:	b29b      	uxth	r3, r3
}
 8017a8e:	4618      	mov	r0, r3
 8017a90:	370c      	adds	r7, #12
 8017a92:	46bd      	mov	sp, r7
 8017a94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017a98:	4770      	bx	lr

08017a9a <l2cap_encanced_control_field_for_supevisor_frame>:

static inline uint16_t l2cap_encanced_control_field_for_supevisor_frame(l2cap_supervisory_function_t supervisory_function, int poll, int final, uint8_t req_seq){
 8017a9a:	b480      	push	{r7}
 8017a9c:	b085      	sub	sp, #20
 8017a9e:	af00      	add	r7, sp, #0
 8017aa0:	60b9      	str	r1, [r7, #8]
 8017aa2:	607a      	str	r2, [r7, #4]
 8017aa4:	461a      	mov	r2, r3
 8017aa6:	4603      	mov	r3, r0
 8017aa8:	73fb      	strb	r3, [r7, #15]
 8017aaa:	4613      	mov	r3, r2
 8017aac:	73bb      	strb	r3, [r7, #14]
    return (req_seq << 8) | (final << 7) | (poll << 4) | (((int) supervisory_function) << 2) | 1; 
 8017aae:	7bbb      	ldrb	r3, [r7, #14]
 8017ab0:	021b      	lsls	r3, r3, #8
 8017ab2:	b21a      	sxth	r2, r3
 8017ab4:	687b      	ldr	r3, [r7, #4]
 8017ab6:	01db      	lsls	r3, r3, #7
 8017ab8:	b21b      	sxth	r3, r3
 8017aba:	4313      	orrs	r3, r2
 8017abc:	b21a      	sxth	r2, r3
 8017abe:	68bb      	ldr	r3, [r7, #8]
 8017ac0:	011b      	lsls	r3, r3, #4
 8017ac2:	b21b      	sxth	r3, r3
 8017ac4:	4313      	orrs	r3, r2
 8017ac6:	b21a      	sxth	r2, r3
 8017ac8:	7bfb      	ldrb	r3, [r7, #15]
 8017aca:	009b      	lsls	r3, r3, #2
 8017acc:	b21b      	sxth	r3, r3
 8017ace:	4313      	orrs	r3, r2
 8017ad0:	b21b      	sxth	r3, r3
 8017ad2:	f043 0301 	orr.w	r3, r3, #1
 8017ad6:	b21b      	sxth	r3, r3
 8017ad8:	b29b      	uxth	r3, r3
}
 8017ada:	4618      	mov	r0, r3
 8017adc:	3714      	adds	r7, #20
 8017ade:	46bd      	mov	sp, r7
 8017ae0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017ae4:	4770      	bx	lr

08017ae6 <l2cap_next_ertm_seq_nr>:

static int l2cap_next_ertm_seq_nr(int seq_nr){
 8017ae6:	b480      	push	{r7}
 8017ae8:	b083      	sub	sp, #12
 8017aea:	af00      	add	r7, sp, #0
 8017aec:	6078      	str	r0, [r7, #4]
    return (seq_nr + 1) & 0x3f;
 8017aee:	687b      	ldr	r3, [r7, #4]
 8017af0:	3301      	adds	r3, #1
 8017af2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
}
 8017af6:	4618      	mov	r0, r3
 8017af8:	370c      	adds	r7, #12
 8017afa:	46bd      	mov	sp, r7
 8017afc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017b00:	4770      	bx	lr

08017b02 <l2cap_ertm_can_store_packet_now>:

static int l2cap_ertm_can_store_packet_now(l2cap_channel_t * channel){
 8017b02:	b580      	push	{r7, lr}
 8017b04:	b086      	sub	sp, #24
 8017b06:	af00      	add	r7, sp, #0
 8017b08:	6078      	str	r0, [r7, #4]
    // get num free tx buffers
    int num_free_tx_buffers = channel->num_tx_buffers - channel->num_stored_tx_frames;
 8017b0a:	687b      	ldr	r3, [r7, #4]
 8017b0c:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
 8017b10:	461a      	mov	r2, r3
 8017b12:	687b      	ldr	r3, [r7, #4]
 8017b14:	f893 308a 	ldrb.w	r3, [r3, #138]	; 0x8a
 8017b18:	1ad3      	subs	r3, r2, r3
 8017b1a:	613b      	str	r3, [r7, #16]
    // calculate num tx buffers for remote MTU
    int num_tx_buffers_for_max_remote_mtu;
    uint16_t effective_mps = btstack_min(channel->remote_mps, channel->local_mps);
 8017b1c:	687b      	ldr	r3, [r7, #4]
 8017b1e:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 8017b22:	461a      	mov	r2, r3
 8017b24:	687b      	ldr	r3, [r7, #4]
 8017b26:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8017b2a:	4619      	mov	r1, r3
 8017b2c:	4610      	mov	r0, r2
 8017b2e:	f7f7 faee 	bl	800f10e <btstack_min>
 8017b32:	4603      	mov	r3, r0
 8017b34:	81fb      	strh	r3, [r7, #14]
    if (channel->remote_mtu <= effective_mps){
 8017b36:	687b      	ldr	r3, [r7, #4]
 8017b38:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8017b3a:	89fa      	ldrh	r2, [r7, #14]
 8017b3c:	429a      	cmp	r2, r3
 8017b3e:	d302      	bcc.n	8017b46 <l2cap_ertm_can_store_packet_now+0x44>
        // MTU fits into single packet
        num_tx_buffers_for_max_remote_mtu = 1;
 8017b40:	2301      	movs	r3, #1
 8017b42:	617b      	str	r3, [r7, #20]
 8017b44:	e009      	b.n	8017b5a <l2cap_ertm_can_store_packet_now+0x58>
    } else {
        // include SDU Length
        num_tx_buffers_for_max_remote_mtu = (channel->remote_mtu + 2 + (effective_mps - 1)) / effective_mps;
 8017b46:	687b      	ldr	r3, [r7, #4]
 8017b48:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8017b4a:	1c9a      	adds	r2, r3, #2
 8017b4c:	89fb      	ldrh	r3, [r7, #14]
 8017b4e:	3b01      	subs	r3, #1
 8017b50:	441a      	add	r2, r3
 8017b52:	89fb      	ldrh	r3, [r7, #14]
 8017b54:	fb92 f3f3 	sdiv	r3, r2, r3
 8017b58:	617b      	str	r3, [r7, #20]
    }
    log_debug("num_free_tx_buffers %u, num_tx_buffers_for_max_remote_mtu %u", num_free_tx_buffers, num_tx_buffers_for_max_remote_mtu);
    return num_tx_buffers_for_max_remote_mtu <= num_free_tx_buffers;
 8017b5a:	697a      	ldr	r2, [r7, #20]
 8017b5c:	693b      	ldr	r3, [r7, #16]
 8017b5e:	429a      	cmp	r2, r3
 8017b60:	bfd4      	ite	le
 8017b62:	2301      	movle	r3, #1
 8017b64:	2300      	movgt	r3, #0
 8017b66:	b2db      	uxtb	r3, r3
}
 8017b68:	4618      	mov	r0, r3
 8017b6a:	3718      	adds	r7, #24
 8017b6c:	46bd      	mov	sp, r7
 8017b6e:	bd80      	pop	{r7, pc}

08017b70 <l2cap_ertm_retransmit_unacknowleded_frames>:

static void l2cap_ertm_retransmit_unacknowleded_frames(l2cap_channel_t * l2cap_channel){
 8017b70:	b580      	push	{r7, lr}
 8017b72:	b082      	sub	sp, #8
 8017b74:	af00      	add	r7, sp, #0
 8017b76:	6078      	str	r0, [r7, #4]
    log_info("Retransmit unacknowleged frames");
 8017b78:	f44f 738e 	mov.w	r3, #284	; 0x11c
 8017b7c:	4a09      	ldr	r2, [pc, #36]	; (8017ba4 <l2cap_ertm_retransmit_unacknowleded_frames+0x34>)
 8017b7e:	490a      	ldr	r1, [pc, #40]	; (8017ba8 <l2cap_ertm_retransmit_unacknowleded_frames+0x38>)
 8017b80:	2001      	movs	r0, #1
 8017b82:	f7ff fc5d 	bl	8017440 <hci_dump_log>
    l2cap_channel->unacked_frames = 0;;
 8017b86:	687b      	ldr	r3, [r7, #4]
 8017b88:	2200      	movs	r2, #0
 8017b8a:	f883 208b 	strb.w	r2, [r3, #139]	; 0x8b
    l2cap_channel->tx_send_index  = l2cap_channel->tx_read_index;
 8017b8e:	687b      	ldr	r3, [r7, #4]
 8017b90:	f893 208c 	ldrb.w	r2, [r3, #140]	; 0x8c
 8017b94:	687b      	ldr	r3, [r7, #4]
 8017b96:	f883 208e 	strb.w	r2, [r3, #142]	; 0x8e
}
 8017b9a:	bf00      	nop
 8017b9c:	3708      	adds	r7, #8
 8017b9e:	46bd      	mov	sp, r7
 8017ba0:	bd80      	pop	{r7, pc}
 8017ba2:	bf00      	nop
 8017ba4:	0802b1dc 	.word	0x0802b1dc
 8017ba8:	0802b1e4 	.word	0x0802b1e4

08017bac <l2cap_ertm_start_monitor_timer>:
    channel->tx_write_index++;
    if (channel->tx_write_index < channel->num_tx_buffers) return;
    channel->tx_write_index = 0;
}

static void l2cap_ertm_start_monitor_timer(l2cap_channel_t * channel){
 8017bac:	b580      	push	{r7, lr}
 8017bae:	b082      	sub	sp, #8
 8017bb0:	af00      	add	r7, sp, #0
 8017bb2:	6078      	str	r0, [r7, #4]
    log_info("Start Monitor timer");
 8017bb4:	f44f 7394 	mov.w	r3, #296	; 0x128
 8017bb8:	4a14      	ldr	r2, [pc, #80]	; (8017c0c <l2cap_ertm_start_monitor_timer+0x60>)
 8017bba:	4915      	ldr	r1, [pc, #84]	; (8017c10 <l2cap_ertm_start_monitor_timer+0x64>)
 8017bbc:	2001      	movs	r0, #1
 8017bbe:	f7ff fc3f 	bl	8017440 <hci_dump_log>
    btstack_run_loop_remove_timer(&channel->monitor_timer);
 8017bc2:	687b      	ldr	r3, [r7, #4]
 8017bc4:	336c      	adds	r3, #108	; 0x6c
 8017bc6:	4618      	mov	r0, r3
 8017bc8:	f7f7 f880 	bl	800eccc <btstack_run_loop_remove_timer>
    btstack_run_loop_set_timer_handler(&channel->monitor_timer, &l2cap_ertm_monitor_timeout_callback);
 8017bcc:	687b      	ldr	r3, [r7, #4]
 8017bce:	336c      	adds	r3, #108	; 0x6c
 8017bd0:	4910      	ldr	r1, [pc, #64]	; (8017c14 <l2cap_ertm_start_monitor_timer+0x68>)
 8017bd2:	4618      	mov	r0, r3
 8017bd4:	f7f6 ffda 	bl	800eb8c <btstack_run_loop_set_timer_handler>
    btstack_run_loop_set_timer_context(&channel->monitor_timer, channel);
 8017bd8:	687b      	ldr	r3, [r7, #4]
 8017bda:	336c      	adds	r3, #108	; 0x6c
 8017bdc:	6879      	ldr	r1, [r7, #4]
 8017bde:	4618      	mov	r0, r3
 8017be0:	f7f7 f84a 	bl	800ec78 <btstack_run_loop_set_timer_context>
    btstack_run_loop_set_timer(&channel->monitor_timer, channel->local_monitor_timeout_ms);
 8017be4:	687b      	ldr	r3, [r7, #4]
 8017be6:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 8017bea:	687b      	ldr	r3, [r7, #4]
 8017bec:	f8b3 307e 	ldrh.w	r3, [r3, #126]	; 0x7e
 8017bf0:	4619      	mov	r1, r3
 8017bf2:	4610      	mov	r0, r2
 8017bf4:	f7f7 f82e 	bl	800ec54 <btstack_run_loop_set_timer>
    btstack_run_loop_add_timer(&channel->monitor_timer);
 8017bf8:	687b      	ldr	r3, [r7, #4]
 8017bfa:	336c      	adds	r3, #108	; 0x6c
 8017bfc:	4618      	mov	r0, r3
 8017bfe:	f7f7 f855 	bl	800ecac <btstack_run_loop_add_timer>
}
 8017c02:	bf00      	nop
 8017c04:	3708      	adds	r7, #8
 8017c06:	46bd      	mov	sp, r7
 8017c08:	bd80      	pop	{r7, pc}
 8017c0a:	bf00      	nop
 8017c0c:	0802b1dc 	.word	0x0802b1dc
 8017c10:	0802b20c 	.word	0x0802b20c
 8017c14:	08017ce5 	.word	0x08017ce5

08017c18 <l2cap_ertm_stop_monitor_timer>:

static void l2cap_ertm_stop_monitor_timer(l2cap_channel_t * channel){
 8017c18:	b580      	push	{r7, lr}
 8017c1a:	b082      	sub	sp, #8
 8017c1c:	af00      	add	r7, sp, #0
 8017c1e:	6078      	str	r0, [r7, #4]
    log_info("Stop Monitor timer");
 8017c20:	f240 1331 	movw	r3, #305	; 0x131
 8017c24:	4a06      	ldr	r2, [pc, #24]	; (8017c40 <l2cap_ertm_stop_monitor_timer+0x28>)
 8017c26:	4907      	ldr	r1, [pc, #28]	; (8017c44 <l2cap_ertm_stop_monitor_timer+0x2c>)
 8017c28:	2001      	movs	r0, #1
 8017c2a:	f7ff fc09 	bl	8017440 <hci_dump_log>
    btstack_run_loop_remove_timer(&channel->monitor_timer);
 8017c2e:	687b      	ldr	r3, [r7, #4]
 8017c30:	336c      	adds	r3, #108	; 0x6c
 8017c32:	4618      	mov	r0, r3
 8017c34:	f7f7 f84a 	bl	800eccc <btstack_run_loop_remove_timer>
}
 8017c38:	bf00      	nop
 8017c3a:	3708      	adds	r7, #8
 8017c3c:	46bd      	mov	sp, r7
 8017c3e:	bd80      	pop	{r7, pc}
 8017c40:	0802b1dc 	.word	0x0802b1dc
 8017c44:	0802b228 	.word	0x0802b228

08017c48 <l2cap_ertm_start_retransmission_timer>:

static void l2cap_ertm_start_retransmission_timer(l2cap_channel_t * channel){
 8017c48:	b580      	push	{r7, lr}
 8017c4a:	b082      	sub	sp, #8
 8017c4c:	af00      	add	r7, sp, #0
 8017c4e:	6078      	str	r0, [r7, #4]
    log_info("Start Retransmission timer");
 8017c50:	f44f 739b 	mov.w	r3, #310	; 0x136
 8017c54:	4a14      	ldr	r2, [pc, #80]	; (8017ca8 <l2cap_ertm_start_retransmission_timer+0x60>)
 8017c56:	4915      	ldr	r1, [pc, #84]	; (8017cac <l2cap_ertm_start_retransmission_timer+0x64>)
 8017c58:	2001      	movs	r0, #1
 8017c5a:	f7ff fbf1 	bl	8017440 <hci_dump_log>
    btstack_run_loop_remove_timer(&channel->retransmission_timer);
 8017c5e:	687b      	ldr	r3, [r7, #4]
 8017c60:	335c      	adds	r3, #92	; 0x5c
 8017c62:	4618      	mov	r0, r3
 8017c64:	f7f7 f832 	bl	800eccc <btstack_run_loop_remove_timer>
    btstack_run_loop_set_timer_handler(&channel->retransmission_timer, &l2cap_ertm_retransmission_timeout_callback);
 8017c68:	687b      	ldr	r3, [r7, #4]
 8017c6a:	335c      	adds	r3, #92	; 0x5c
 8017c6c:	4910      	ldr	r1, [pc, #64]	; (8017cb0 <l2cap_ertm_start_retransmission_timer+0x68>)
 8017c6e:	4618      	mov	r0, r3
 8017c70:	f7f6 ff8c 	bl	800eb8c <btstack_run_loop_set_timer_handler>
    btstack_run_loop_set_timer_context(&channel->retransmission_timer, channel);
 8017c74:	687b      	ldr	r3, [r7, #4]
 8017c76:	335c      	adds	r3, #92	; 0x5c
 8017c78:	6879      	ldr	r1, [r7, #4]
 8017c7a:	4618      	mov	r0, r3
 8017c7c:	f7f6 fffc 	bl	800ec78 <btstack_run_loop_set_timer_context>
    btstack_run_loop_set_timer(&channel->retransmission_timer, channel->local_retransmission_timeout_ms);
 8017c80:	687b      	ldr	r3, [r7, #4]
 8017c82:	f103 025c 	add.w	r2, r3, #92	; 0x5c
 8017c86:	687b      	ldr	r3, [r7, #4]
 8017c88:	f8b3 307c 	ldrh.w	r3, [r3, #124]	; 0x7c
 8017c8c:	4619      	mov	r1, r3
 8017c8e:	4610      	mov	r0, r2
 8017c90:	f7f6 ffe0 	bl	800ec54 <btstack_run_loop_set_timer>
    btstack_run_loop_add_timer(&channel->retransmission_timer);
 8017c94:	687b      	ldr	r3, [r7, #4]
 8017c96:	335c      	adds	r3, #92	; 0x5c
 8017c98:	4618      	mov	r0, r3
 8017c9a:	f7f7 f807 	bl	800ecac <btstack_run_loop_add_timer>
}
 8017c9e:	bf00      	nop
 8017ca0:	3708      	adds	r7, #8
 8017ca2:	46bd      	mov	sp, r7
 8017ca4:	bd80      	pop	{r7, pc}
 8017ca6:	bf00      	nop
 8017ca8:	0802b1dc 	.word	0x0802b1dc
 8017cac:	0802b244 	.word	0x0802b244
 8017cb0:	08017d75 	.word	0x08017d75

08017cb4 <l2cap_ertm_stop_retransmission_timer>:

static void l2cap_ertm_stop_retransmission_timer(l2cap_channel_t * l2cap_channel){
 8017cb4:	b580      	push	{r7, lr}
 8017cb6:	b082      	sub	sp, #8
 8017cb8:	af00      	add	r7, sp, #0
 8017cba:	6078      	str	r0, [r7, #4]
    log_info("Stop Retransmission timer");
 8017cbc:	f240 133f 	movw	r3, #319	; 0x13f
 8017cc0:	4a06      	ldr	r2, [pc, #24]	; (8017cdc <l2cap_ertm_stop_retransmission_timer+0x28>)
 8017cc2:	4907      	ldr	r1, [pc, #28]	; (8017ce0 <l2cap_ertm_stop_retransmission_timer+0x2c>)
 8017cc4:	2001      	movs	r0, #1
 8017cc6:	f7ff fbbb 	bl	8017440 <hci_dump_log>
    btstack_run_loop_remove_timer(&l2cap_channel->retransmission_timer);
 8017cca:	687b      	ldr	r3, [r7, #4]
 8017ccc:	335c      	adds	r3, #92	; 0x5c
 8017cce:	4618      	mov	r0, r3
 8017cd0:	f7f6 fffc 	bl	800eccc <btstack_run_loop_remove_timer>
}    
 8017cd4:	bf00      	nop
 8017cd6:	3708      	adds	r7, #8
 8017cd8:	46bd      	mov	sp, r7
 8017cda:	bd80      	pop	{r7, pc}
 8017cdc:	0802b1dc 	.word	0x0802b1dc
 8017ce0:	0802b268 	.word	0x0802b268

08017ce4 <l2cap_ertm_monitor_timeout_callback>:

static void l2cap_ertm_monitor_timeout_callback(btstack_timer_source_t * ts){
 8017ce4:	b580      	push	{r7, lr}
 8017ce6:	b084      	sub	sp, #16
 8017ce8:	af00      	add	r7, sp, #0
 8017cea:	6078      	str	r0, [r7, #4]
    log_info("Monitor timeout");
 8017cec:	f44f 73a2 	mov.w	r3, #324	; 0x144
 8017cf0:	4a1d      	ldr	r2, [pc, #116]	; (8017d68 <l2cap_ertm_monitor_timeout_callback+0x84>)
 8017cf2:	491e      	ldr	r1, [pc, #120]	; (8017d6c <l2cap_ertm_monitor_timeout_callback+0x88>)
 8017cf4:	2001      	movs	r0, #1
 8017cf6:	f7ff fba3 	bl	8017440 <hci_dump_log>
    l2cap_channel_t * l2cap_channel = (l2cap_channel_t *) btstack_run_loop_get_timer_context(ts);
 8017cfa:	6878      	ldr	r0, [r7, #4]
 8017cfc:	f7f6 ffca 	bl	800ec94 <btstack_run_loop_get_timer_context>
 8017d00:	60f8      	str	r0, [r7, #12]

    // TODO: we assume that it's the oldest packet
    l2cap_ertm_tx_packet_state_t * tx_state;
    tx_state = &l2cap_channel->tx_packets_state[l2cap_channel->tx_read_index];
 8017d02:	68fb      	ldr	r3, [r7, #12]
 8017d04:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 8017d08:	68fb      	ldr	r3, [r7, #12]
 8017d0a:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
 8017d0e:	00db      	lsls	r3, r3, #3
 8017d10:	4413      	add	r3, r2
 8017d12:	60bb      	str	r3, [r7, #8]

    // check retry count
    if (tx_state->retry_count < l2cap_channel->remote_max_transmit){
 8017d14:	68bb      	ldr	r3, [r7, #8]
 8017d16:	795a      	ldrb	r2, [r3, #5]
 8017d18:	68fb      	ldr	r3, [r7, #12]
 8017d1a:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
 8017d1e:	429a      	cmp	r2, r3
 8017d20:	d210      	bcs.n	8017d44 <l2cap_ertm_monitor_timeout_callback+0x60>
        // increment retry count
        tx_state->retry_count++;
 8017d22:	68bb      	ldr	r3, [r7, #8]
 8017d24:	795b      	ldrb	r3, [r3, #5]
 8017d26:	3301      	adds	r3, #1
 8017d28:	b2da      	uxtb	r2, r3
 8017d2a:	68bb      	ldr	r3, [r7, #8]
 8017d2c:	715a      	strb	r2, [r3, #5]

        // start retransmit
        l2cap_ertm_retransmit_unacknowleded_frames(l2cap_channel);
 8017d2e:	68f8      	ldr	r0, [r7, #12]
 8017d30:	f7ff ff1e 	bl	8017b70 <l2cap_ertm_retransmit_unacknowleded_frames>

        // start monitor timer
        l2cap_ertm_start_monitor_timer(l2cap_channel);
 8017d34:	68f8      	ldr	r0, [r7, #12]
 8017d36:	f7ff ff39 	bl	8017bac <l2cap_ertm_start_monitor_timer>

        // send RR/P=1
        l2cap_channel->send_supervisor_frame_receiver_ready_poll = 1;
 8017d3a:	68fb      	ldr	r3, [r7, #12]
 8017d3c:	2201      	movs	r2, #1
 8017d3e:	f883 2097 	strb.w	r2, [r3, #151]	; 0x97
 8017d42:	e00a      	b.n	8017d5a <l2cap_ertm_monitor_timeout_callback+0x76>
    } else {
        log_info("Monitor timer expired & retry count >= max transmit -> disconnect");
 8017d44:	f240 1359 	movw	r3, #345	; 0x159
 8017d48:	4a07      	ldr	r2, [pc, #28]	; (8017d68 <l2cap_ertm_monitor_timeout_callback+0x84>)
 8017d4a:	4909      	ldr	r1, [pc, #36]	; (8017d70 <l2cap_ertm_monitor_timeout_callback+0x8c>)
 8017d4c:	2001      	movs	r0, #1
 8017d4e:	f7ff fb77 	bl	8017440 <hci_dump_log>
        l2cap_channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST;
 8017d52:	68fb      	ldr	r3, [r7, #12]
 8017d54:	2212      	movs	r2, #18
 8017d56:	f883 2020 	strb.w	r2, [r3, #32]
    }
    l2cap_run();
 8017d5a:	f002 f94d 	bl	8019ff8 <l2cap_run>
}
 8017d5e:	bf00      	nop
 8017d60:	3710      	adds	r7, #16
 8017d62:	46bd      	mov	sp, r7
 8017d64:	bd80      	pop	{r7, pc}
 8017d66:	bf00      	nop
 8017d68:	0802b1dc 	.word	0x0802b1dc
 8017d6c:	0802b28c 	.word	0x0802b28c
 8017d70:	0802b2a4 	.word	0x0802b2a4

08017d74 <l2cap_ertm_retransmission_timeout_callback>:

static void l2cap_ertm_retransmission_timeout_callback(btstack_timer_source_t * ts){
 8017d74:	b580      	push	{r7, lr}
 8017d76:	b084      	sub	sp, #16
 8017d78:	af00      	add	r7, sp, #0
 8017d7a:	6078      	str	r0, [r7, #4]
    log_info("Retransmission timeout");
 8017d7c:	f44f 73b0 	mov.w	r3, #352	; 0x160
 8017d80:	4a12      	ldr	r2, [pc, #72]	; (8017dcc <l2cap_ertm_retransmission_timeout_callback+0x58>)
 8017d82:	4913      	ldr	r1, [pc, #76]	; (8017dd0 <l2cap_ertm_retransmission_timeout_callback+0x5c>)
 8017d84:	2001      	movs	r0, #1
 8017d86:	f7ff fb5b 	bl	8017440 <hci_dump_log>
    l2cap_channel_t * l2cap_channel = (l2cap_channel_t *) btstack_run_loop_get_timer_context(ts);
 8017d8a:	6878      	ldr	r0, [r7, #4]
 8017d8c:	f7f6 ff82 	bl	800ec94 <btstack_run_loop_get_timer_context>
 8017d90:	60f8      	str	r0, [r7, #12]
    
    // TODO: we assume that it's the oldest packet
    l2cap_ertm_tx_packet_state_t * tx_state;
    tx_state = &l2cap_channel->tx_packets_state[l2cap_channel->tx_read_index];
 8017d92:	68fb      	ldr	r3, [r7, #12]
 8017d94:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 8017d98:	68fb      	ldr	r3, [r7, #12]
 8017d9a:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
 8017d9e:	00db      	lsls	r3, r3, #3
 8017da0:	4413      	add	r3, r2
 8017da2:	60bb      	str	r3, [r7, #8]

    // set retry count = 1
    tx_state->retry_count = 1;
 8017da4:	68bb      	ldr	r3, [r7, #8]
 8017da6:	2201      	movs	r2, #1
 8017da8:	715a      	strb	r2, [r3, #5]

    // start retransmit
    l2cap_ertm_retransmit_unacknowleded_frames(l2cap_channel);
 8017daa:	68f8      	ldr	r0, [r7, #12]
 8017dac:	f7ff fee0 	bl	8017b70 <l2cap_ertm_retransmit_unacknowleded_frames>

    // start monitor timer
    l2cap_ertm_start_monitor_timer(l2cap_channel);
 8017db0:	68f8      	ldr	r0, [r7, #12]
 8017db2:	f7ff fefb 	bl	8017bac <l2cap_ertm_start_monitor_timer>
 
    // send RR/P=1
    l2cap_channel->send_supervisor_frame_receiver_ready_poll = 1;
 8017db6:	68fb      	ldr	r3, [r7, #12]
 8017db8:	2201      	movs	r2, #1
 8017dba:	f883 2097 	strb.w	r2, [r3, #151]	; 0x97
    l2cap_run();
 8017dbe:	f002 f91b 	bl	8019ff8 <l2cap_run>
}
 8017dc2:	bf00      	nop
 8017dc4:	3710      	adds	r7, #16
 8017dc6:	46bd      	mov	sp, r7
 8017dc8:	bd80      	pop	{r7, pc}
 8017dca:	bf00      	nop
 8017dcc:	0802b1dc 	.word	0x0802b1dc
 8017dd0:	0802b2f0 	.word	0x0802b2f0

08017dd4 <l2cap_ertm_send_information_frame>:

static int l2cap_ertm_send_information_frame(l2cap_channel_t * channel, int index, int final){
 8017dd4:	b580      	push	{r7, lr}
 8017dd6:	b08a      	sub	sp, #40	; 0x28
 8017dd8:	af02      	add	r7, sp, #8
 8017dda:	60f8      	str	r0, [r7, #12]
 8017ddc:	60b9      	str	r1, [r7, #8]
 8017dde:	607a      	str	r2, [r7, #4]
    l2cap_ertm_tx_packet_state_t * tx_state = &channel->tx_packets_state[index];
 8017de0:	68fb      	ldr	r3, [r7, #12]
 8017de2:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 8017de6:	68bb      	ldr	r3, [r7, #8]
 8017de8:	00db      	lsls	r3, r3, #3
 8017dea:	4413      	add	r3, r2
 8017dec:	61fb      	str	r3, [r7, #28]
    hci_reserve_packet_buffer();
 8017dee:	f7f8 f961 	bl	80100b4 <hci_reserve_packet_buffer>
    uint8_t *acl_buffer = hci_get_outgoing_packet_buffer();
 8017df2:	f7f8 fccf 	bl	8010794 <hci_get_outgoing_packet_buffer>
 8017df6:	61b8      	str	r0, [r7, #24]
    uint16_t control = l2cap_encanced_control_field_for_information_frame(tx_state->tx_seq, final, channel->req_seq, tx_state->sar);
 8017df8:	69fb      	ldr	r3, [r7, #28]
 8017dfa:	7918      	ldrb	r0, [r3, #4]
 8017dfc:	68fb      	ldr	r3, [r7, #12]
 8017dfe:	f893 2094 	ldrb.w	r2, [r3, #148]	; 0x94
 8017e02:	69fb      	ldr	r3, [r7, #28]
 8017e04:	781b      	ldrb	r3, [r3, #0]
 8017e06:	6879      	ldr	r1, [r7, #4]
 8017e08:	f7ff fe22 	bl	8017a50 <l2cap_encanced_control_field_for_information_frame>
 8017e0c:	4603      	mov	r3, r0
 8017e0e:	82fb      	strh	r3, [r7, #22]
    log_info("I-Frame: control 0x%04x", control);
 8017e10:	8afb      	ldrh	r3, [r7, #22]
 8017e12:	9300      	str	r3, [sp, #0]
 8017e14:	f44f 73bd 	mov.w	r3, #378	; 0x17a
 8017e18:	4a17      	ldr	r2, [pc, #92]	; (8017e78 <l2cap_ertm_send_information_frame+0xa4>)
 8017e1a:	4918      	ldr	r1, [pc, #96]	; (8017e7c <l2cap_ertm_send_information_frame+0xa8>)
 8017e1c:	2001      	movs	r0, #1
 8017e1e:	f7ff fb0f 	bl	8017440 <hci_dump_log>
    little_endian_store_16(acl_buffer, 8, control);
 8017e22:	8afb      	ldrh	r3, [r7, #22]
 8017e24:	461a      	mov	r2, r3
 8017e26:	2108      	movs	r1, #8
 8017e28:	69b8      	ldr	r0, [r7, #24]
 8017e2a:	f7f7 f81c 	bl	800ee66 <little_endian_store_16>
    (void)memcpy(&acl_buffer[8 + 2],
 8017e2e:	69bb      	ldr	r3, [r7, #24]
 8017e30:	f103 000a 	add.w	r0, r3, #10
                 &channel->tx_packets_data[index * channel->local_mps],
 8017e34:	68fb      	ldr	r3, [r7, #12]
 8017e36:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8017e3a:	68fa      	ldr	r2, [r7, #12]
 8017e3c:	f8b2 2058 	ldrh.w	r2, [r2, #88]	; 0x58
 8017e40:	4611      	mov	r1, r2
 8017e42:	68ba      	ldr	r2, [r7, #8]
 8017e44:	fb02 f201 	mul.w	r2, r2, r1
 8017e48:	1899      	adds	r1, r3, r2
                 tx_state->len);
 8017e4a:	69fb      	ldr	r3, [r7, #28]
 8017e4c:	885b      	ldrh	r3, [r3, #2]
    (void)memcpy(&acl_buffer[8 + 2],
 8017e4e:	461a      	mov	r2, r3
 8017e50:	f00f fe13 	bl	8027a7a <memcpy>
    // (re-)start retransmission timer on 
    l2cap_ertm_start_retransmission_timer(channel);
 8017e54:	68f8      	ldr	r0, [r7, #12]
 8017e56:	f7ff fef7 	bl	8017c48 <l2cap_ertm_start_retransmission_timer>
    // send
    return l2cap_send_prepared(channel->local_cid, 2 + tx_state->len);
 8017e5a:	68fb      	ldr	r3, [r7, #12]
 8017e5c:	88da      	ldrh	r2, [r3, #6]
 8017e5e:	69fb      	ldr	r3, [r7, #28]
 8017e60:	885b      	ldrh	r3, [r3, #2]
 8017e62:	3302      	adds	r3, #2
 8017e64:	b29b      	uxth	r3, r3
 8017e66:	4619      	mov	r1, r3
 8017e68:	4610      	mov	r0, r2
 8017e6a:	f001 f859 	bl	8018f20 <l2cap_send_prepared>
 8017e6e:	4603      	mov	r3, r0
}
 8017e70:	4618      	mov	r0, r3
 8017e72:	3720      	adds	r7, #32
 8017e74:	46bd      	mov	sp, r7
 8017e76:	bd80      	pop	{r7, pc}
 8017e78:	0802b1dc 	.word	0x0802b1dc
 8017e7c:	0802b310 	.word	0x0802b310

08017e80 <l2cap_setup_options_ertm_request>:
    // try to send
    l2cap_notify_channel_can_send();
    return 0;
}

static uint16_t l2cap_setup_options_ertm_request(l2cap_channel_t * channel, uint8_t * config_options){
 8017e80:	b580      	push	{r7, lr}
 8017e82:	b084      	sub	sp, #16
 8017e84:	af00      	add	r7, sp, #0
 8017e86:	6078      	str	r0, [r7, #4]
 8017e88:	6039      	str	r1, [r7, #0]
    int pos = 0;
 8017e8a:	2300      	movs	r3, #0
 8017e8c:	60fb      	str	r3, [r7, #12]
    config_options[pos++] = L2CAP_CONFIG_OPTION_TYPE_RETRANSMISSION_AND_FLOW_CONTROL;
 8017e8e:	68fb      	ldr	r3, [r7, #12]
 8017e90:	1c5a      	adds	r2, r3, #1
 8017e92:	60fa      	str	r2, [r7, #12]
 8017e94:	461a      	mov	r2, r3
 8017e96:	683b      	ldr	r3, [r7, #0]
 8017e98:	4413      	add	r3, r2
 8017e9a:	2204      	movs	r2, #4
 8017e9c:	701a      	strb	r2, [r3, #0]
    config_options[pos++] = 9;      // length
 8017e9e:	68fb      	ldr	r3, [r7, #12]
 8017ea0:	1c5a      	adds	r2, r3, #1
 8017ea2:	60fa      	str	r2, [r7, #12]
 8017ea4:	461a      	mov	r2, r3
 8017ea6:	683b      	ldr	r3, [r7, #0]
 8017ea8:	4413      	add	r3, r2
 8017eaa:	2209      	movs	r2, #9
 8017eac:	701a      	strb	r2, [r3, #0]
    config_options[pos++] = (uint8_t) channel->mode;
 8017eae:	68fb      	ldr	r3, [r7, #12]
 8017eb0:	1c5a      	adds	r2, r3, #1
 8017eb2:	60fa      	str	r2, [r7, #12]
 8017eb4:	461a      	mov	r2, r3
 8017eb6:	683b      	ldr	r3, [r7, #0]
 8017eb8:	4413      	add	r3, r2
 8017eba:	687a      	ldr	r2, [r7, #4]
 8017ebc:	f892 2056 	ldrb.w	r2, [r2, #86]	; 0x56
 8017ec0:	701a      	strb	r2, [r3, #0]
    config_options[pos++] = channel->num_rx_buffers;    // == TxWindows size
 8017ec2:	68fb      	ldr	r3, [r7, #12]
 8017ec4:	1c5a      	adds	r2, r3, #1
 8017ec6:	60fa      	str	r2, [r7, #12]
 8017ec8:	461a      	mov	r2, r3
 8017eca:	683b      	ldr	r3, [r7, #0]
 8017ecc:	4413      	add	r3, r2
 8017ece:	687a      	ldr	r2, [r7, #4]
 8017ed0:	f892 2091 	ldrb.w	r2, [r2, #145]	; 0x91
 8017ed4:	701a      	strb	r2, [r3, #0]
    config_options[pos++] = channel->local_max_transmit;
 8017ed6:	68fb      	ldr	r3, [r7, #12]
 8017ed8:	1c5a      	adds	r2, r3, #1
 8017eda:	60fa      	str	r2, [r7, #12]
 8017edc:	461a      	mov	r2, r3
 8017ede:	683b      	ldr	r3, [r7, #0]
 8017ee0:	4413      	add	r3, r2
 8017ee2:	687a      	ldr	r2, [r7, #4]
 8017ee4:	f892 2085 	ldrb.w	r2, [r2, #133]	; 0x85
 8017ee8:	701a      	strb	r2, [r3, #0]
    little_endian_store_16( config_options, pos, channel->local_retransmission_timeout_ms);
 8017eea:	68fb      	ldr	r3, [r7, #12]
 8017eec:	b299      	uxth	r1, r3
 8017eee:	687b      	ldr	r3, [r7, #4]
 8017ef0:	f8b3 307c 	ldrh.w	r3, [r3, #124]	; 0x7c
 8017ef4:	461a      	mov	r2, r3
 8017ef6:	6838      	ldr	r0, [r7, #0]
 8017ef8:	f7f6 ffb5 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 8017efc:	68fb      	ldr	r3, [r7, #12]
 8017efe:	3302      	adds	r3, #2
 8017f00:	60fb      	str	r3, [r7, #12]
    little_endian_store_16( config_options, pos, channel->local_monitor_timeout_ms);
 8017f02:	68fb      	ldr	r3, [r7, #12]
 8017f04:	b299      	uxth	r1, r3
 8017f06:	687b      	ldr	r3, [r7, #4]
 8017f08:	f8b3 307e 	ldrh.w	r3, [r3, #126]	; 0x7e
 8017f0c:	461a      	mov	r2, r3
 8017f0e:	6838      	ldr	r0, [r7, #0]
 8017f10:	f7f6 ffa9 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 8017f14:	68fb      	ldr	r3, [r7, #12]
 8017f16:	3302      	adds	r3, #2
 8017f18:	60fb      	str	r3, [r7, #12]
    little_endian_store_16( config_options, pos, channel->local_mps);
 8017f1a:	68fb      	ldr	r3, [r7, #12]
 8017f1c:	b299      	uxth	r1, r3
 8017f1e:	687b      	ldr	r3, [r7, #4]
 8017f20:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8017f24:	461a      	mov	r2, r3
 8017f26:	6838      	ldr	r0, [r7, #0]
 8017f28:	f7f6 ff9d 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 8017f2c:	68fb      	ldr	r3, [r7, #12]
 8017f2e:	3302      	adds	r3, #2
 8017f30:	60fb      	str	r3, [r7, #12]
    //
    config_options[pos++] = L2CAP_CONFIG_OPTION_TYPE_MAX_TRANSMISSION_UNIT;
 8017f32:	68fb      	ldr	r3, [r7, #12]
 8017f34:	1c5a      	adds	r2, r3, #1
 8017f36:	60fa      	str	r2, [r7, #12]
 8017f38:	461a      	mov	r2, r3
 8017f3a:	683b      	ldr	r3, [r7, #0]
 8017f3c:	4413      	add	r3, r2
 8017f3e:	2201      	movs	r2, #1
 8017f40:	701a      	strb	r2, [r3, #0]
    config_options[pos++] = 2;     // length
 8017f42:	68fb      	ldr	r3, [r7, #12]
 8017f44:	1c5a      	adds	r2, r3, #1
 8017f46:	60fa      	str	r2, [r7, #12]
 8017f48:	461a      	mov	r2, r3
 8017f4a:	683b      	ldr	r3, [r7, #0]
 8017f4c:	4413      	add	r3, r2
 8017f4e:	2202      	movs	r2, #2
 8017f50:	701a      	strb	r2, [r3, #0]
    little_endian_store_16(config_options, pos, channel->local_mtu);
 8017f52:	68fb      	ldr	r3, [r7, #12]
 8017f54:	b299      	uxth	r1, r3
 8017f56:	687b      	ldr	r3, [r7, #4]
 8017f58:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8017f5a:	461a      	mov	r2, r3
 8017f5c:	6838      	ldr	r0, [r7, #0]
 8017f5e:	f7f6 ff82 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 8017f62:	68fb      	ldr	r3, [r7, #12]
 8017f64:	3302      	adds	r3, #2
 8017f66:	60fb      	str	r3, [r7, #12]

    // Issue: iOS (e.g. 10.2) uses "No FCS" as default while Core 5.0 specifies "FCS" as default
    // Workaround: try to actively negotiate FCS option
    config_options[pos++] = L2CAP_CONFIG_OPTION_TYPE_FRAME_CHECK_SEQUENCE;
 8017f68:	68fb      	ldr	r3, [r7, #12]
 8017f6a:	1c5a      	adds	r2, r3, #1
 8017f6c:	60fa      	str	r2, [r7, #12]
 8017f6e:	461a      	mov	r2, r3
 8017f70:	683b      	ldr	r3, [r7, #0]
 8017f72:	4413      	add	r3, r2
 8017f74:	2205      	movs	r2, #5
 8017f76:	701a      	strb	r2, [r3, #0]
    config_options[pos++] = 1;     // length
 8017f78:	68fb      	ldr	r3, [r7, #12]
 8017f7a:	1c5a      	adds	r2, r3, #1
 8017f7c:	60fa      	str	r2, [r7, #12]
 8017f7e:	461a      	mov	r2, r3
 8017f80:	683b      	ldr	r3, [r7, #0]
 8017f82:	4413      	add	r3, r2
 8017f84:	2201      	movs	r2, #1
 8017f86:	701a      	strb	r2, [r3, #0]
    config_options[pos++] = channel->fcs_option;
 8017f88:	68fb      	ldr	r3, [r7, #12]
 8017f8a:	1c5a      	adds	r2, r3, #1
 8017f8c:	60fa      	str	r2, [r7, #12]
 8017f8e:	461a      	mov	r2, r3
 8017f90:	683b      	ldr	r3, [r7, #0]
 8017f92:	4413      	add	r3, r2
 8017f94:	687a      	ldr	r2, [r7, #4]
 8017f96:	f892 2088 	ldrb.w	r2, [r2, #136]	; 0x88
 8017f9a:	701a      	strb	r2, [r3, #0]
    return pos; // 11+4+3=18
 8017f9c:	68fb      	ldr	r3, [r7, #12]
 8017f9e:	b29b      	uxth	r3, r3
}
 8017fa0:	4618      	mov	r0, r3
 8017fa2:	3710      	adds	r7, #16
 8017fa4:	46bd      	mov	sp, r7
 8017fa6:	bd80      	pop	{r7, pc}

08017fa8 <l2cap_setup_options_ertm_response>:

static uint16_t l2cap_setup_options_ertm_response(l2cap_channel_t * channel, uint8_t * config_options){
 8017fa8:	b580      	push	{r7, lr}
 8017faa:	b084      	sub	sp, #16
 8017fac:	af00      	add	r7, sp, #0
 8017fae:	6078      	str	r0, [r7, #4]
 8017fb0:	6039      	str	r1, [r7, #0]
    int pos = 0;
 8017fb2:	2300      	movs	r3, #0
 8017fb4:	60fb      	str	r3, [r7, #12]
    config_options[pos++] = L2CAP_CONFIG_OPTION_TYPE_RETRANSMISSION_AND_FLOW_CONTROL;
 8017fb6:	68fb      	ldr	r3, [r7, #12]
 8017fb8:	1c5a      	adds	r2, r3, #1
 8017fba:	60fa      	str	r2, [r7, #12]
 8017fbc:	461a      	mov	r2, r3
 8017fbe:	683b      	ldr	r3, [r7, #0]
 8017fc0:	4413      	add	r3, r2
 8017fc2:	2204      	movs	r2, #4
 8017fc4:	701a      	strb	r2, [r3, #0]
    config_options[pos++] = 9;      // length
 8017fc6:	68fb      	ldr	r3, [r7, #12]
 8017fc8:	1c5a      	adds	r2, r3, #1
 8017fca:	60fa      	str	r2, [r7, #12]
 8017fcc:	461a      	mov	r2, r3
 8017fce:	683b      	ldr	r3, [r7, #0]
 8017fd0:	4413      	add	r3, r2
 8017fd2:	2209      	movs	r2, #9
 8017fd4:	701a      	strb	r2, [r3, #0]
    config_options[pos++] = (uint8_t) channel->mode;
 8017fd6:	68fb      	ldr	r3, [r7, #12]
 8017fd8:	1c5a      	adds	r2, r3, #1
 8017fda:	60fa      	str	r2, [r7, #12]
 8017fdc:	461a      	mov	r2, r3
 8017fde:	683b      	ldr	r3, [r7, #0]
 8017fe0:	4413      	add	r3, r2
 8017fe2:	687a      	ldr	r2, [r7, #4]
 8017fe4:	f892 2056 	ldrb.w	r2, [r2, #86]	; 0x56
 8017fe8:	701a      	strb	r2, [r3, #0]
    // less or equal to remote tx window size
    config_options[pos++] = btstack_min(channel->num_tx_buffers, channel->remote_tx_window_size);
 8017fea:	687b      	ldr	r3, [r7, #4]
 8017fec:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
 8017ff0:	461a      	mov	r2, r3
 8017ff2:	687b      	ldr	r3, [r7, #4]
 8017ff4:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8017ff8:	4619      	mov	r1, r3
 8017ffa:	4610      	mov	r0, r2
 8017ffc:	f7f7 f887 	bl	800f10e <btstack_min>
 8018000:	4601      	mov	r1, r0
 8018002:	68fb      	ldr	r3, [r7, #12]
 8018004:	1c5a      	adds	r2, r3, #1
 8018006:	60fa      	str	r2, [r7, #12]
 8018008:	461a      	mov	r2, r3
 801800a:	683b      	ldr	r3, [r7, #0]
 801800c:	4413      	add	r3, r2
 801800e:	b2ca      	uxtb	r2, r1
 8018010:	701a      	strb	r2, [r3, #0]
    // max transmit in response shall be ignored -> use sender values
    config_options[pos++] = channel->remote_max_transmit;
 8018012:	68fb      	ldr	r3, [r7, #12]
 8018014:	1c5a      	adds	r2, r3, #1
 8018016:	60fa      	str	r2, [r7, #12]
 8018018:	461a      	mov	r2, r3
 801801a:	683b      	ldr	r3, [r7, #0]
 801801c:	4413      	add	r3, r2
 801801e:	687a      	ldr	r2, [r7, #4]
 8018020:	f892 2086 	ldrb.w	r2, [r2, #134]	; 0x86
 8018024:	701a      	strb	r2, [r3, #0]
    // A value for the Retransmission time-out shall be sent in a positive Configuration Response
    // and indicates the value that will be used by the sender of the Configuration Response -> use our value
    little_endian_store_16( config_options, pos, channel->local_retransmission_timeout_ms);
 8018026:	68fb      	ldr	r3, [r7, #12]
 8018028:	b299      	uxth	r1, r3
 801802a:	687b      	ldr	r3, [r7, #4]
 801802c:	f8b3 307c 	ldrh.w	r3, [r3, #124]	; 0x7c
 8018030:	461a      	mov	r2, r3
 8018032:	6838      	ldr	r0, [r7, #0]
 8018034:	f7f6 ff17 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 8018038:	68fb      	ldr	r3, [r7, #12]
 801803a:	3302      	adds	r3, #2
 801803c:	60fb      	str	r3, [r7, #12]
    // A value for the Monitor time-out shall be sent in a positive Configuration Response
    // and indicates the value that will be used by the sender of the Configuration Response -> use our value
    little_endian_store_16( config_options, pos, channel->local_monitor_timeout_ms);
 801803e:	68fb      	ldr	r3, [r7, #12]
 8018040:	b299      	uxth	r1, r3
 8018042:	687b      	ldr	r3, [r7, #4]
 8018044:	f8b3 307e 	ldrh.w	r3, [r3, #126]	; 0x7e
 8018048:	461a      	mov	r2, r3
 801804a:	6838      	ldr	r0, [r7, #0]
 801804c:	f7f6 ff0b 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 8018050:	68fb      	ldr	r3, [r7, #12]
 8018052:	3302      	adds	r3, #2
 8018054:	60fb      	str	r3, [r7, #12]
    // less or equal to remote mps
    uint16_t effective_mps = btstack_min(channel->remote_mps, channel->local_mps);
 8018056:	687b      	ldr	r3, [r7, #4]
 8018058:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 801805c:	461a      	mov	r2, r3
 801805e:	687b      	ldr	r3, [r7, #4]
 8018060:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8018064:	4619      	mov	r1, r3
 8018066:	4610      	mov	r0, r2
 8018068:	f7f7 f851 	bl	800f10e <btstack_min>
 801806c:	4603      	mov	r3, r0
 801806e:	817b      	strh	r3, [r7, #10]
    little_endian_store_16( config_options, pos, effective_mps);
 8018070:	68fb      	ldr	r3, [r7, #12]
 8018072:	b29b      	uxth	r3, r3
 8018074:	897a      	ldrh	r2, [r7, #10]
 8018076:	4619      	mov	r1, r3
 8018078:	6838      	ldr	r0, [r7, #0]
 801807a:	f7f6 fef4 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 801807e:	68fb      	ldr	r3, [r7, #12]
 8018080:	3302      	adds	r3, #2
 8018082:	60fb      	str	r3, [r7, #12]
    //
    config_options[pos++] = L2CAP_CONFIG_OPTION_TYPE_MAX_TRANSMISSION_UNIT; // MTU
 8018084:	68fb      	ldr	r3, [r7, #12]
 8018086:	1c5a      	adds	r2, r3, #1
 8018088:	60fa      	str	r2, [r7, #12]
 801808a:	461a      	mov	r2, r3
 801808c:	683b      	ldr	r3, [r7, #0]
 801808e:	4413      	add	r3, r2
 8018090:	2201      	movs	r2, #1
 8018092:	701a      	strb	r2, [r3, #0]
    config_options[pos++] = 2;     // length
 8018094:	68fb      	ldr	r3, [r7, #12]
 8018096:	1c5a      	adds	r2, r3, #1
 8018098:	60fa      	str	r2, [r7, #12]
 801809a:	461a      	mov	r2, r3
 801809c:	683b      	ldr	r3, [r7, #0]
 801809e:	4413      	add	r3, r2
 80180a0:	2202      	movs	r2, #2
 80180a2:	701a      	strb	r2, [r3, #0]
    little_endian_store_16(config_options, pos, channel->remote_mtu);
 80180a4:	68fb      	ldr	r3, [r7, #12]
 80180a6:	b299      	uxth	r1, r3
 80180a8:	687b      	ldr	r3, [r7, #4]
 80180aa:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 80180ac:	461a      	mov	r2, r3
 80180ae:	6838      	ldr	r0, [r7, #0]
 80180b0:	f7f6 fed9 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 80180b4:	68fb      	ldr	r3, [r7, #12]
 80180b6:	3302      	adds	r3, #2
 80180b8:	60fb      	str	r3, [r7, #12]
    //
    config_options[pos++] = L2CAP_CONFIG_OPTION_TYPE_FRAME_CHECK_SEQUENCE;
    config_options[pos++] = 1;     // length
    config_options[pos++] = channel->fcs_option;
#endif
    return pos; // 11+4=15
 80180ba:	68fb      	ldr	r3, [r7, #12]
 80180bc:	b29b      	uxth	r3, r3
}
 80180be:	4618      	mov	r0, r3
 80180c0:	3710      	adds	r7, #16
 80180c2:	46bd      	mov	sp, r7
 80180c4:	bd80      	pop	{r7, pc}
	...

080180c8 <l2cap_ertm_send_supervisor_frame>:

static int l2cap_ertm_send_supervisor_frame(l2cap_channel_t * channel, uint16_t control){
 80180c8:	b580      	push	{r7, lr}
 80180ca:	b086      	sub	sp, #24
 80180cc:	af02      	add	r7, sp, #8
 80180ce:	6078      	str	r0, [r7, #4]
 80180d0:	460b      	mov	r3, r1
 80180d2:	807b      	strh	r3, [r7, #2]
    hci_reserve_packet_buffer();
 80180d4:	f7f7 ffee 	bl	80100b4 <hci_reserve_packet_buffer>
    uint8_t *acl_buffer = hci_get_outgoing_packet_buffer();
 80180d8:	f7f8 fb5c 	bl	8010794 <hci_get_outgoing_packet_buffer>
 80180dc:	60f8      	str	r0, [r7, #12]
    log_info("S-Frame: control 0x%04x", control);
 80180de:	887b      	ldrh	r3, [r7, #2]
 80180e0:	9300      	str	r3, [sp, #0]
 80180e2:	f240 2312 	movw	r3, #530	; 0x212
 80180e6:	4a0b      	ldr	r2, [pc, #44]	; (8018114 <l2cap_ertm_send_supervisor_frame+0x4c>)
 80180e8:	490b      	ldr	r1, [pc, #44]	; (8018118 <l2cap_ertm_send_supervisor_frame+0x50>)
 80180ea:	2001      	movs	r0, #1
 80180ec:	f7ff f9a8 	bl	8017440 <hci_dump_log>
    little_endian_store_16(acl_buffer, 8, control);
 80180f0:	887b      	ldrh	r3, [r7, #2]
 80180f2:	461a      	mov	r2, r3
 80180f4:	2108      	movs	r1, #8
 80180f6:	68f8      	ldr	r0, [r7, #12]
 80180f8:	f7f6 feb5 	bl	800ee66 <little_endian_store_16>
    return l2cap_send_prepared(channel->local_cid, 2);
 80180fc:	687b      	ldr	r3, [r7, #4]
 80180fe:	88db      	ldrh	r3, [r3, #6]
 8018100:	2102      	movs	r1, #2
 8018102:	4618      	mov	r0, r3
 8018104:	f000 ff0c 	bl	8018f20 <l2cap_send_prepared>
 8018108:	4603      	mov	r3, r0
}
 801810a:	4618      	mov	r0, r3
 801810c:	3710      	adds	r7, #16
 801810e:	46bd      	mov	sp, r7
 8018110:	bd80      	pop	{r7, pc}
 8018112:	bf00      	nop
 8018114:	0802b1dc 	.word	0x0802b1dc
 8018118:	0802b404 	.word	0x0802b404

0801811c <l2cap_ertm_notify_channel_can_send>:
    l2cap_run(); 

    return 0;     
}

static void l2cap_ertm_notify_channel_can_send(l2cap_channel_t * channel){
 801811c:	b580      	push	{r7, lr}
 801811e:	b082      	sub	sp, #8
 8018120:	af00      	add	r7, sp, #0
 8018122:	6078      	str	r0, [r7, #4]
    if (l2cap_ertm_can_store_packet_now(channel)){
 8018124:	6878      	ldr	r0, [r7, #4]
 8018126:	f7ff fcec 	bl	8017b02 <l2cap_ertm_can_store_packet_now>
 801812a:	4603      	mov	r3, r0
 801812c:	2b00      	cmp	r3, #0
 801812e:	d00a      	beq.n	8018146 <l2cap_ertm_notify_channel_can_send+0x2a>
        channel->waiting_for_can_send_now = 0;
 8018130:	687b      	ldr	r3, [r7, #4]
 8018132:	2200      	movs	r2, #0
 8018134:	731a      	strb	r2, [r3, #12]
        l2cap_emit_can_send_now(channel->packet_handler, channel->local_cid);
 8018136:	687b      	ldr	r3, [r7, #4]
 8018138:	689a      	ldr	r2, [r3, #8]
 801813a:	687b      	ldr	r3, [r7, #4]
 801813c:	88db      	ldrh	r3, [r3, #6]
 801813e:	4619      	mov	r1, r3
 8018140:	4610      	mov	r0, r2
 8018142:	f000 fb95 	bl	8018870 <l2cap_emit_can_send_now>
    }
}
 8018146:	bf00      	nop
 8018148:	3708      	adds	r7, #8
 801814a:	46bd      	mov	sp, r7
 801814c:	bd80      	pop	{r7, pc}
	...

08018150 <l2cap_ertm_process_req_seq>:
    }
    return ERROR_CODE_SUCCESS;
}

// Process-ReqSeq
static void l2cap_ertm_process_req_seq(l2cap_channel_t * l2cap_channel, uint8_t req_seq){
 8018150:	b580      	push	{r7, lr}
 8018152:	b08a      	sub	sp, #40	; 0x28
 8018154:	af04      	add	r7, sp, #16
 8018156:	6078      	str	r0, [r7, #4]
 8018158:	460b      	mov	r3, r1
 801815a:	70fb      	strb	r3, [r7, #3]
    int num_buffers_acked = 0;
 801815c:	2300      	movs	r3, #0
 801815e:	617b      	str	r3, [r7, #20]
    l2cap_ertm_tx_packet_state_t * tx_state;
    log_info("l2cap_ertm_process_req_seq: tx_read_index %u, tx_write_index %u, req_seq %u", l2cap_channel->tx_read_index, l2cap_channel->tx_write_index, req_seq);
 8018160:	687b      	ldr	r3, [r7, #4]
 8018162:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
 8018166:	461a      	mov	r2, r3
 8018168:	687b      	ldr	r3, [r7, #4]
 801816a:	f893 308d 	ldrb.w	r3, [r3, #141]	; 0x8d
 801816e:	4619      	mov	r1, r3
 8018170:	78fb      	ldrb	r3, [r7, #3]
 8018172:	9302      	str	r3, [sp, #8]
 8018174:	9101      	str	r1, [sp, #4]
 8018176:	9200      	str	r2, [sp, #0]
 8018178:	f240 23d7 	movw	r3, #727	; 0x2d7
 801817c:	4a39      	ldr	r2, [pc, #228]	; (8018264 <l2cap_ertm_process_req_seq+0x114>)
 801817e:	493a      	ldr	r1, [pc, #232]	; (8018268 <l2cap_ertm_process_req_seq+0x118>)
 8018180:	2001      	movs	r0, #1
 8018182:	f7ff f95d 	bl	8017440 <hci_dump_log>
    while (true){

        // no unack packets left
        if (l2cap_channel->unacked_frames == 0) {
 8018186:	687b      	ldr	r3, [r7, #4]
 8018188:	f893 308b 	ldrb.w	r3, [r3, #139]	; 0x8b
 801818c:	2b00      	cmp	r3, #0
 801818e:	d103      	bne.n	8018198 <l2cap_ertm_process_req_seq+0x48>
            // stop retransmission timer
            l2cap_ertm_stop_retransmission_timer(l2cap_channel);
 8018190:	6878      	ldr	r0, [r7, #4]
 8018192:	f7ff fd8f 	bl	8017cb4 <l2cap_ertm_stop_retransmission_timer>
            break;
 8018196:	e051      	b.n	801823c <l2cap_ertm_process_req_seq+0xec>
        }

        tx_state = &l2cap_channel->tx_packets_state[l2cap_channel->tx_read_index];
 8018198:	687b      	ldr	r3, [r7, #4]
 801819a:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 801819e:	687b      	ldr	r3, [r7, #4]
 80181a0:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
 80181a4:	00db      	lsls	r3, r3, #3
 80181a6:	4413      	add	r3, r2
 80181a8:	613b      	str	r3, [r7, #16]
        // calc delta
        int delta = (req_seq - tx_state->tx_seq) & 0x03f;
 80181aa:	693b      	ldr	r3, [r7, #16]
 80181ac:	791b      	ldrb	r3, [r3, #4]
 80181ae:	78fa      	ldrb	r2, [r7, #3]
 80181b0:	1ad3      	subs	r3, r2, r3
 80181b2:	b2db      	uxtb	r3, r3
 80181b4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80181b8:	60fb      	str	r3, [r7, #12]
        if (delta == 0) break;  // all packets acknowledged
 80181ba:	68fb      	ldr	r3, [r7, #12]
 80181bc:	2b00      	cmp	r3, #0
 80181be:	d03a      	beq.n	8018236 <l2cap_ertm_process_req_seq+0xe6>
        if (delta > l2cap_channel->remote_tx_window_size) break;   
 80181c0:	687b      	ldr	r3, [r7, #4]
 80181c2:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 80181c6:	461a      	mov	r2, r3
 80181c8:	68fb      	ldr	r3, [r7, #12]
 80181ca:	4293      	cmp	r3, r2
 80181cc:	dc35      	bgt.n	801823a <l2cap_ertm_process_req_seq+0xea>

        num_buffers_acked++;
 80181ce:	697b      	ldr	r3, [r7, #20]
 80181d0:	3301      	adds	r3, #1
 80181d2:	617b      	str	r3, [r7, #20]
        l2cap_channel->num_stored_tx_frames--;
 80181d4:	687b      	ldr	r3, [r7, #4]
 80181d6:	f893 308a 	ldrb.w	r3, [r3, #138]	; 0x8a
 80181da:	3b01      	subs	r3, #1
 80181dc:	b2da      	uxtb	r2, r3
 80181de:	687b      	ldr	r3, [r7, #4]
 80181e0:	f883 208a 	strb.w	r2, [r3, #138]	; 0x8a
        l2cap_channel->unacked_frames--;
 80181e4:	687b      	ldr	r3, [r7, #4]
 80181e6:	f893 308b 	ldrb.w	r3, [r3, #139]	; 0x8b
 80181ea:	3b01      	subs	r3, #1
 80181ec:	b2da      	uxtb	r2, r3
 80181ee:	687b      	ldr	r3, [r7, #4]
 80181f0:	f883 208b 	strb.w	r2, [r3, #139]	; 0x8b
        log_info("RR seq %u => packet with tx_seq %u done", req_seq, tx_state->tx_seq);
 80181f4:	78fb      	ldrb	r3, [r7, #3]
 80181f6:	693a      	ldr	r2, [r7, #16]
 80181f8:	7912      	ldrb	r2, [r2, #4]
 80181fa:	9201      	str	r2, [sp, #4]
 80181fc:	9300      	str	r3, [sp, #0]
 80181fe:	f240 23ea 	movw	r3, #746	; 0x2ea
 8018202:	4a18      	ldr	r2, [pc, #96]	; (8018264 <l2cap_ertm_process_req_seq+0x114>)
 8018204:	4919      	ldr	r1, [pc, #100]	; (801826c <l2cap_ertm_process_req_seq+0x11c>)
 8018206:	2001      	movs	r0, #1
 8018208:	f7ff f91a 	bl	8017440 <hci_dump_log>

        l2cap_channel->tx_read_index++;
 801820c:	687b      	ldr	r3, [r7, #4]
 801820e:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
 8018212:	3301      	adds	r3, #1
 8018214:	b2da      	uxtb	r2, r3
 8018216:	687b      	ldr	r3, [r7, #4]
 8018218:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
        if (l2cap_channel->tx_read_index >= l2cap_channel->num_rx_buffers){
 801821c:	687b      	ldr	r3, [r7, #4]
 801821e:	f893 208c 	ldrb.w	r2, [r3, #140]	; 0x8c
 8018222:	687b      	ldr	r3, [r7, #4]
 8018224:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
 8018228:	429a      	cmp	r2, r3
 801822a:	d3ac      	bcc.n	8018186 <l2cap_ertm_process_req_seq+0x36>
            l2cap_channel->tx_read_index = 0;
 801822c:	687b      	ldr	r3, [r7, #4]
 801822e:	2200      	movs	r2, #0
 8018230:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
    while (true){
 8018234:	e7a7      	b.n	8018186 <l2cap_ertm_process_req_seq+0x36>
        if (delta == 0) break;  // all packets acknowledged
 8018236:	bf00      	nop
 8018238:	e000      	b.n	801823c <l2cap_ertm_process_req_seq+0xec>
        if (delta > l2cap_channel->remote_tx_window_size) break;   
 801823a:	bf00      	nop
        }
    }
    if (num_buffers_acked){
 801823c:	697b      	ldr	r3, [r7, #20]
 801823e:	2b00      	cmp	r3, #0
 8018240:	d00b      	beq.n	801825a <l2cap_ertm_process_req_seq+0x10a>
        log_info("num_buffers_acked %u", num_buffers_acked);
 8018242:	697b      	ldr	r3, [r7, #20]
 8018244:	9300      	str	r3, [sp, #0]
 8018246:	f240 23f2 	movw	r3, #754	; 0x2f2
 801824a:	4a06      	ldr	r2, [pc, #24]	; (8018264 <l2cap_ertm_process_req_seq+0x114>)
 801824c:	4908      	ldr	r1, [pc, #32]	; (8018270 <l2cap_ertm_process_req_seq+0x120>)
 801824e:	2001      	movs	r0, #1
 8018250:	f7ff f8f6 	bl	8017440 <hci_dump_log>
    l2cap_ertm_notify_channel_can_send(l2cap_channel);
 8018254:	6878      	ldr	r0, [r7, #4]
 8018256:	f7ff ff61 	bl	801811c <l2cap_ertm_notify_channel_can_send>
}     
}     
 801825a:	bf00      	nop
 801825c:	3718      	adds	r7, #24
 801825e:	46bd      	mov	sp, r7
 8018260:	bd80      	pop	{r7, pc}
 8018262:	bf00      	nop
 8018264:	0802b1dc 	.word	0x0802b1dc
 8018268:	0802b6a8 	.word	0x0802b6a8
 801826c:	0802b6fc 	.word	0x0802b6fc
 8018270:	0802b72c 	.word	0x0802b72c

08018274 <l2cap_ertm_get_tx_state>:

static l2cap_ertm_tx_packet_state_t * l2cap_ertm_get_tx_state(l2cap_channel_t * l2cap_channel, uint8_t tx_seq){
 8018274:	b480      	push	{r7}
 8018276:	b085      	sub	sp, #20
 8018278:	af00      	add	r7, sp, #0
 801827a:	6078      	str	r0, [r7, #4]
 801827c:	460b      	mov	r3, r1
 801827e:	70fb      	strb	r3, [r7, #3]
    int i;
    for (i=0;i<l2cap_channel->num_tx_buffers;i++){
 8018280:	2300      	movs	r3, #0
 8018282:	60fb      	str	r3, [r7, #12]
 8018284:	e010      	b.n	80182a8 <l2cap_ertm_get_tx_state+0x34>
        l2cap_ertm_tx_packet_state_t * tx_state = &l2cap_channel->tx_packets_state[i];
 8018286:	687b      	ldr	r3, [r7, #4]
 8018288:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 801828c:	68fb      	ldr	r3, [r7, #12]
 801828e:	00db      	lsls	r3, r3, #3
 8018290:	4413      	add	r3, r2
 8018292:	60bb      	str	r3, [r7, #8]
        if (tx_state->tx_seq == tx_seq) return tx_state;
 8018294:	68bb      	ldr	r3, [r7, #8]
 8018296:	791b      	ldrb	r3, [r3, #4]
 8018298:	78fa      	ldrb	r2, [r7, #3]
 801829a:	429a      	cmp	r2, r3
 801829c:	d101      	bne.n	80182a2 <l2cap_ertm_get_tx_state+0x2e>
 801829e:	68bb      	ldr	r3, [r7, #8]
 80182a0:	e00a      	b.n	80182b8 <l2cap_ertm_get_tx_state+0x44>
    for (i=0;i<l2cap_channel->num_tx_buffers;i++){
 80182a2:	68fb      	ldr	r3, [r7, #12]
 80182a4:	3301      	adds	r3, #1
 80182a6:	60fb      	str	r3, [r7, #12]
 80182a8:	687b      	ldr	r3, [r7, #4]
 80182aa:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
 80182ae:	461a      	mov	r2, r3
 80182b0:	68fb      	ldr	r3, [r7, #12]
 80182b2:	4293      	cmp	r3, r2
 80182b4:	dbe7      	blt.n	8018286 <l2cap_ertm_get_tx_state+0x12>
    }
    return NULL;
 80182b6:	2300      	movs	r3, #0
}
 80182b8:	4618      	mov	r0, r3
 80182ba:	3714      	adds	r7, #20
 80182bc:	46bd      	mov	sp, r7
 80182be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80182c2:	4770      	bx	lr

080182c4 <l2cap_ertm_handle_out_of_sequence_sdu>:

// @param delta number of frames in the future, >= 1
// @assumption size <= l2cap_channel->local_mps (checked in l2cap_acl_classic_handler)
static void l2cap_ertm_handle_out_of_sequence_sdu(l2cap_channel_t * l2cap_channel, l2cap_segmentation_and_reassembly_t sar, int delta, const uint8_t * payload, uint16_t size){
 80182c4:	b580      	push	{r7, lr}
 80182c6:	b08a      	sub	sp, #40	; 0x28
 80182c8:	af02      	add	r7, sp, #8
 80182ca:	60f8      	str	r0, [r7, #12]
 80182cc:	607a      	str	r2, [r7, #4]
 80182ce:	603b      	str	r3, [r7, #0]
 80182d0:	460b      	mov	r3, r1
 80182d2:	72fb      	strb	r3, [r7, #11]
    log_info("Store SDU with delta %u", delta);
 80182d4:	687b      	ldr	r3, [r7, #4]
 80182d6:	9300      	str	r3, [sp, #0]
 80182d8:	f240 3303 	movw	r3, #771	; 0x303
 80182dc:	4a28      	ldr	r2, [pc, #160]	; (8018380 <l2cap_ertm_handle_out_of_sequence_sdu+0xbc>)
 80182de:	4929      	ldr	r1, [pc, #164]	; (8018384 <l2cap_ertm_handle_out_of_sequence_sdu+0xc0>)
 80182e0:	2001      	movs	r0, #1
 80182e2:	f7ff f8ad 	bl	8017440 <hci_dump_log>
    // get rx state for packet to store
    int index = l2cap_channel->rx_store_index + delta - 1;
 80182e6:	68fb      	ldr	r3, [r7, #12]
 80182e8:	f893 3092 	ldrb.w	r3, [r3, #146]	; 0x92
 80182ec:	461a      	mov	r2, r3
 80182ee:	687b      	ldr	r3, [r7, #4]
 80182f0:	4413      	add	r3, r2
 80182f2:	3b01      	subs	r3, #1
 80182f4:	61fb      	str	r3, [r7, #28]
    if (index > l2cap_channel->num_rx_buffers){
 80182f6:	68fb      	ldr	r3, [r7, #12]
 80182f8:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
 80182fc:	461a      	mov	r2, r3
 80182fe:	69fb      	ldr	r3, [r7, #28]
 8018300:	4293      	cmp	r3, r2
 8018302:	dd06      	ble.n	8018312 <l2cap_ertm_handle_out_of_sequence_sdu+0x4e>
        index -= l2cap_channel->num_rx_buffers;
 8018304:	68fb      	ldr	r3, [r7, #12]
 8018306:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
 801830a:	461a      	mov	r2, r3
 801830c:	69fb      	ldr	r3, [r7, #28]
 801830e:	1a9b      	subs	r3, r3, r2
 8018310:	61fb      	str	r3, [r7, #28]
    }
    log_info("Index of packet to store %u", index);
 8018312:	69fb      	ldr	r3, [r7, #28]
 8018314:	9300      	str	r3, [sp, #0]
 8018316:	f240 3309 	movw	r3, #777	; 0x309
 801831a:	4a19      	ldr	r2, [pc, #100]	; (8018380 <l2cap_ertm_handle_out_of_sequence_sdu+0xbc>)
 801831c:	491a      	ldr	r1, [pc, #104]	; (8018388 <l2cap_ertm_handle_out_of_sequence_sdu+0xc4>)
 801831e:	2001      	movs	r0, #1
 8018320:	f7ff f88e 	bl	8017440 <hci_dump_log>
    l2cap_ertm_rx_packet_state_t * rx_state = &l2cap_channel->rx_packets_state[index];
 8018324:	68fb      	ldr	r3, [r7, #12]
 8018326:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
 801832a:	69fa      	ldr	r2, [r7, #28]
 801832c:	4613      	mov	r3, r2
 801832e:	005b      	lsls	r3, r3, #1
 8018330:	4413      	add	r3, r2
 8018332:	005b      	lsls	r3, r3, #1
 8018334:	440b      	add	r3, r1
 8018336:	61bb      	str	r3, [r7, #24]
    // check if buffer is free
    if (rx_state->valid){
 8018338:	69bb      	ldr	r3, [r7, #24]
 801833a:	791b      	ldrb	r3, [r3, #4]
 801833c:	2b00      	cmp	r3, #0
 801833e:	d007      	beq.n	8018350 <l2cap_ertm_handle_out_of_sequence_sdu+0x8c>
        log_error("Packet buffer already used");
 8018340:	f240 330d 	movw	r3, #781	; 0x30d
 8018344:	4a0e      	ldr	r2, [pc, #56]	; (8018380 <l2cap_ertm_handle_out_of_sequence_sdu+0xbc>)
 8018346:	4911      	ldr	r1, [pc, #68]	; (801838c <l2cap_ertm_handle_out_of_sequence_sdu+0xc8>)
 8018348:	2002      	movs	r0, #2
 801834a:	f7ff f879 	bl	8017440 <hci_dump_log>
        return;
 801834e:	e014      	b.n	801837a <l2cap_ertm_handle_out_of_sequence_sdu+0xb6>
    }
    rx_state->valid = 1;
 8018350:	69bb      	ldr	r3, [r7, #24]
 8018352:	2201      	movs	r2, #1
 8018354:	711a      	strb	r2, [r3, #4]
    rx_state->sar = sar;
 8018356:	69bb      	ldr	r3, [r7, #24]
 8018358:	7afa      	ldrb	r2, [r7, #11]
 801835a:	701a      	strb	r2, [r3, #0]
    rx_state->len = size;
 801835c:	69bb      	ldr	r3, [r7, #24]
 801835e:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8018360:	805a      	strh	r2, [r3, #2]
    uint8_t * rx_buffer = &l2cap_channel->rx_packets_data[index];
 8018362:	68fb      	ldr	r3, [r7, #12]
 8018364:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 8018368:	69fb      	ldr	r3, [r7, #28]
 801836a:	4413      	add	r3, r2
 801836c:	617b      	str	r3, [r7, #20]
    (void)memcpy(rx_buffer, payload, size);
 801836e:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8018370:	461a      	mov	r2, r3
 8018372:	6839      	ldr	r1, [r7, #0]
 8018374:	6978      	ldr	r0, [r7, #20]
 8018376:	f00f fb80 	bl	8027a7a <memcpy>
}
 801837a:	3720      	adds	r7, #32
 801837c:	46bd      	mov	sp, r7
 801837e:	bd80      	pop	{r7, pc}
 8018380:	0802b1dc 	.word	0x0802b1dc
 8018384:	0802b748 	.word	0x0802b748
 8018388:	0802b768 	.word	0x0802b768
 801838c:	0802b78c 	.word	0x0802b78c

08018390 <l2cap_ertm_handle_in_sequence_sdu>:

// @assumption size <= l2cap_channel->local_mps (checked in l2cap_acl_classic_handler)
static void l2cap_ertm_handle_in_sequence_sdu(l2cap_channel_t * l2cap_channel, l2cap_segmentation_and_reassembly_t sar, const uint8_t * payload, uint16_t size){
 8018390:	b580      	push	{r7, lr}
 8018392:	b086      	sub	sp, #24
 8018394:	af00      	add	r7, sp, #0
 8018396:	60f8      	str	r0, [r7, #12]
 8018398:	607a      	str	r2, [r7, #4]
 801839a:	461a      	mov	r2, r3
 801839c:	460b      	mov	r3, r1
 801839e:	72fb      	strb	r3, [r7, #11]
 80183a0:	4613      	mov	r3, r2
 80183a2:	813b      	strh	r3, [r7, #8]
    uint16_t reassembly_sdu_length;
    switch (sar){
 80183a4:	7afb      	ldrb	r3, [r7, #11]
 80183a6:	2b03      	cmp	r3, #3
 80183a8:	f200 8091 	bhi.w	80184ce <l2cap_ertm_handle_in_sequence_sdu+0x13e>
 80183ac:	a201      	add	r2, pc, #4	; (adr r2, 80183b4 <l2cap_ertm_handle_in_sequence_sdu+0x24>)
 80183ae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80183b2:	bf00      	nop
 80183b4:	080183c5 	.word	0x080183c5
 80183b8:	080183df 	.word	0x080183df
 80183bc:	08018463 	.word	0x08018463
 80183c0:	08018423 	.word	0x08018423
        case L2CAP_SEGMENTATION_AND_REASSEMBLY_UNSEGMENTED_L2CAP_SDU:
            // assert total packet size <= our mtu
            if (size > l2cap_channel->local_mtu) break;
 80183c4:	68fb      	ldr	r3, [r7, #12]
 80183c6:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 80183c8:	893a      	ldrh	r2, [r7, #8]
 80183ca:	429a      	cmp	r2, r3
 80183cc:	f200 8081 	bhi.w	80184d2 <l2cap_ertm_handle_in_sequence_sdu+0x142>
            // packet complete -> disapatch
            l2cap_dispatch_to_channel(l2cap_channel, L2CAP_DATA_PACKET, (uint8_t*) payload, size);
 80183d0:	893b      	ldrh	r3, [r7, #8]
 80183d2:	687a      	ldr	r2, [r7, #4]
 80183d4:	2106      	movs	r1, #6
 80183d6:	68f8      	ldr	r0, [r7, #12]
 80183d8:	f000 fa6d 	bl	80188b6 <l2cap_dispatch_to_channel>
            break;
 80183dc:	e082      	b.n	80184e4 <l2cap_ertm_handle_in_sequence_sdu+0x154>
        case L2CAP_SEGMENTATION_AND_REASSEMBLY_START_OF_L2CAP_SDU:
            // read SDU len
            reassembly_sdu_length = little_endian_read_16(payload, 0);
 80183de:	2100      	movs	r1, #0
 80183e0:	6878      	ldr	r0, [r7, #4]
 80183e2:	f7f6 fd00 	bl	800ede6 <little_endian_read_16>
 80183e6:	4603      	mov	r3, r0
 80183e8:	82fb      	strh	r3, [r7, #22]
            payload += 2;
 80183ea:	687b      	ldr	r3, [r7, #4]
 80183ec:	3302      	adds	r3, #2
 80183ee:	607b      	str	r3, [r7, #4]
            size    -= 2;
 80183f0:	893b      	ldrh	r3, [r7, #8]
 80183f2:	3b02      	subs	r3, #2
 80183f4:	813b      	strh	r3, [r7, #8]
            // assert reassembled size <= our mtu
            if (reassembly_sdu_length > l2cap_channel->local_mtu) break;
 80183f6:	68fb      	ldr	r3, [r7, #12]
 80183f8:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 80183fa:	8afa      	ldrh	r2, [r7, #22]
 80183fc:	429a      	cmp	r2, r3
 80183fe:	d86a      	bhi.n	80184d6 <l2cap_ertm_handle_in_sequence_sdu+0x146>
            // store start segment
            l2cap_channel->reassembly_sdu_length = reassembly_sdu_length;
 8018400:	68fb      	ldr	r3, [r7, #12]
 8018402:	8afa      	ldrh	r2, [r7, #22]
 8018404:	f8a3 20a6 	strh.w	r2, [r3, #166]	; 0xa6
            (void)memcpy(&l2cap_channel->reassembly_buffer[0], payload, size);
 8018408:	68fb      	ldr	r3, [r7, #12]
 801840a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 801840e:	893a      	ldrh	r2, [r7, #8]
 8018410:	6879      	ldr	r1, [r7, #4]
 8018412:	4618      	mov	r0, r3
 8018414:	f00f fb31 	bl	8027a7a <memcpy>
            l2cap_channel->reassembly_pos = size;
 8018418:	68fb      	ldr	r3, [r7, #12]
 801841a:	893a      	ldrh	r2, [r7, #8]
 801841c:	f8a3 20a4 	strh.w	r2, [r3, #164]	; 0xa4
            break;
 8018420:	e060      	b.n	80184e4 <l2cap_ertm_handle_in_sequence_sdu+0x154>
        case L2CAP_SEGMENTATION_AND_REASSEMBLY_CONTINUATION_OF_L2CAP_SDU:
            // assert size of reassembled data <= our mtu
            if (l2cap_channel->reassembly_pos + size > l2cap_channel->local_mtu) break;
 8018422:	68fb      	ldr	r3, [r7, #12]
 8018424:	f8b3 30a4 	ldrh.w	r3, [r3, #164]	; 0xa4
 8018428:	461a      	mov	r2, r3
 801842a:	893b      	ldrh	r3, [r7, #8]
 801842c:	4413      	add	r3, r2
 801842e:	68fa      	ldr	r2, [r7, #12]
 8018430:	8e52      	ldrh	r2, [r2, #50]	; 0x32
 8018432:	4293      	cmp	r3, r2
 8018434:	dc51      	bgt.n	80184da <l2cap_ertm_handle_in_sequence_sdu+0x14a>
            // store continuation segment
            (void)memcpy(&l2cap_channel->reassembly_buffer[l2cap_channel->reassembly_pos],
 8018436:	68fb      	ldr	r3, [r7, #12]
 8018438:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 801843c:	68fa      	ldr	r2, [r7, #12]
 801843e:	f8b2 20a4 	ldrh.w	r2, [r2, #164]	; 0xa4
 8018442:	4413      	add	r3, r2
 8018444:	893a      	ldrh	r2, [r7, #8]
 8018446:	6879      	ldr	r1, [r7, #4]
 8018448:	4618      	mov	r0, r3
 801844a:	f00f fb16 	bl	8027a7a <memcpy>
                         payload, size);
            l2cap_channel->reassembly_pos += size;
 801844e:	68fb      	ldr	r3, [r7, #12]
 8018450:	f8b3 20a4 	ldrh.w	r2, [r3, #164]	; 0xa4
 8018454:	893b      	ldrh	r3, [r7, #8]
 8018456:	4413      	add	r3, r2
 8018458:	b29a      	uxth	r2, r3
 801845a:	68fb      	ldr	r3, [r7, #12]
 801845c:	f8a3 20a4 	strh.w	r2, [r3, #164]	; 0xa4
            break;
 8018460:	e040      	b.n	80184e4 <l2cap_ertm_handle_in_sequence_sdu+0x154>
        case L2CAP_SEGMENTATION_AND_REASSEMBLY_END_OF_L2CAP_SDU:
            // assert size of reassembled data <= our mtu
            if (l2cap_channel->reassembly_pos + size > l2cap_channel->local_mtu) break;
 8018462:	68fb      	ldr	r3, [r7, #12]
 8018464:	f8b3 30a4 	ldrh.w	r3, [r3, #164]	; 0xa4
 8018468:	461a      	mov	r2, r3
 801846a:	893b      	ldrh	r3, [r7, #8]
 801846c:	4413      	add	r3, r2
 801846e:	68fa      	ldr	r2, [r7, #12]
 8018470:	8e52      	ldrh	r2, [r2, #50]	; 0x32
 8018472:	4293      	cmp	r3, r2
 8018474:	dc33      	bgt.n	80184de <l2cap_ertm_handle_in_sequence_sdu+0x14e>
            // store continuation segment
            (void)memcpy(&l2cap_channel->reassembly_buffer[l2cap_channel->reassembly_pos],
 8018476:	68fb      	ldr	r3, [r7, #12]
 8018478:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 801847c:	68fa      	ldr	r2, [r7, #12]
 801847e:	f8b2 20a4 	ldrh.w	r2, [r2, #164]	; 0xa4
 8018482:	4413      	add	r3, r2
 8018484:	893a      	ldrh	r2, [r7, #8]
 8018486:	6879      	ldr	r1, [r7, #4]
 8018488:	4618      	mov	r0, r3
 801848a:	f00f faf6 	bl	8027a7a <memcpy>
                         payload, size);
            l2cap_channel->reassembly_pos += size;
 801848e:	68fb      	ldr	r3, [r7, #12]
 8018490:	f8b3 20a4 	ldrh.w	r2, [r3, #164]	; 0xa4
 8018494:	893b      	ldrh	r3, [r7, #8]
 8018496:	4413      	add	r3, r2
 8018498:	b29a      	uxth	r2, r3
 801849a:	68fb      	ldr	r3, [r7, #12]
 801849c:	f8a3 20a4 	strh.w	r2, [r3, #164]	; 0xa4
            // assert size of reassembled data matches announced sdu length
            if (l2cap_channel->reassembly_pos != l2cap_channel->reassembly_sdu_length) break;
 80184a0:	68fb      	ldr	r3, [r7, #12]
 80184a2:	f8b3 20a4 	ldrh.w	r2, [r3, #164]	; 0xa4
 80184a6:	68fb      	ldr	r3, [r7, #12]
 80184a8:	f8b3 30a6 	ldrh.w	r3, [r3, #166]	; 0xa6
 80184ac:	429a      	cmp	r2, r3
 80184ae:	d118      	bne.n	80184e2 <l2cap_ertm_handle_in_sequence_sdu+0x152>
            // packet complete -> disapatch
            l2cap_dispatch_to_channel(l2cap_channel, L2CAP_DATA_PACKET, l2cap_channel->reassembly_buffer, l2cap_channel->reassembly_pos);
 80184b0:	68fb      	ldr	r3, [r7, #12]
 80184b2:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 80184b6:	68fb      	ldr	r3, [r7, #12]
 80184b8:	f8b3 30a4 	ldrh.w	r3, [r3, #164]	; 0xa4
 80184bc:	2106      	movs	r1, #6
 80184be:	68f8      	ldr	r0, [r7, #12]
 80184c0:	f000 f9f9 	bl	80188b6 <l2cap_dispatch_to_channel>
            l2cap_channel->reassembly_pos = 0;    
 80184c4:	68fb      	ldr	r3, [r7, #12]
 80184c6:	2200      	movs	r2, #0
 80184c8:	f8a3 20a4 	strh.w	r2, [r3, #164]	; 0xa4
            break; 
 80184cc:	e00a      	b.n	80184e4 <l2cap_ertm_handle_in_sequence_sdu+0x154>
        default:
            btstack_assert(false);
            break;
 80184ce:	bf00      	nop
 80184d0:	e008      	b.n	80184e4 <l2cap_ertm_handle_in_sequence_sdu+0x154>
            if (size > l2cap_channel->local_mtu) break;
 80184d2:	bf00      	nop
 80184d4:	e006      	b.n	80184e4 <l2cap_ertm_handle_in_sequence_sdu+0x154>
            if (reassembly_sdu_length > l2cap_channel->local_mtu) break;
 80184d6:	bf00      	nop
 80184d8:	e004      	b.n	80184e4 <l2cap_ertm_handle_in_sequence_sdu+0x154>
            if (l2cap_channel->reassembly_pos + size > l2cap_channel->local_mtu) break;
 80184da:	bf00      	nop
 80184dc:	e002      	b.n	80184e4 <l2cap_ertm_handle_in_sequence_sdu+0x154>
            if (l2cap_channel->reassembly_pos + size > l2cap_channel->local_mtu) break;
 80184de:	bf00      	nop
 80184e0:	e000      	b.n	80184e4 <l2cap_ertm_handle_in_sequence_sdu+0x154>
            if (l2cap_channel->reassembly_pos != l2cap_channel->reassembly_sdu_length) break;
 80184e2:	bf00      	nop
    }
}
 80184e4:	bf00      	nop
 80184e6:	3718      	adds	r7, #24
 80184e8:	46bd      	mov	sp, r7
 80184ea:	bd80      	pop	{r7, pc}

080184ec <l2cap_ertm_channel_send_information_frame>:

static void l2cap_ertm_channel_send_information_frame(l2cap_channel_t * channel){
 80184ec:	b580      	push	{r7, lr}
 80184ee:	b084      	sub	sp, #16
 80184f0:	af00      	add	r7, sp, #0
 80184f2:	6078      	str	r0, [r7, #4]
    channel->unacked_frames++;
 80184f4:	687b      	ldr	r3, [r7, #4]
 80184f6:	f893 308b 	ldrb.w	r3, [r3, #139]	; 0x8b
 80184fa:	3301      	adds	r3, #1
 80184fc:	b2da      	uxtb	r2, r3
 80184fe:	687b      	ldr	r3, [r7, #4]
 8018500:	f883 208b 	strb.w	r2, [r3, #139]	; 0x8b
    int index = channel->tx_send_index;
 8018504:	687b      	ldr	r3, [r7, #4]
 8018506:	f893 308e 	ldrb.w	r3, [r3, #142]	; 0x8e
 801850a:	60fb      	str	r3, [r7, #12]
    channel->tx_send_index++;
 801850c:	687b      	ldr	r3, [r7, #4]
 801850e:	f893 308e 	ldrb.w	r3, [r3, #142]	; 0x8e
 8018512:	3301      	adds	r3, #1
 8018514:	b2da      	uxtb	r2, r3
 8018516:	687b      	ldr	r3, [r7, #4]
 8018518:	f883 208e 	strb.w	r2, [r3, #142]	; 0x8e
    if (channel->tx_send_index >= channel->num_tx_buffers){
 801851c:	687b      	ldr	r3, [r7, #4]
 801851e:	f893 208e 	ldrb.w	r2, [r3, #142]	; 0x8e
 8018522:	687b      	ldr	r3, [r7, #4]
 8018524:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
 8018528:	429a      	cmp	r2, r3
 801852a:	d303      	bcc.n	8018534 <l2cap_ertm_channel_send_information_frame+0x48>
        channel->tx_send_index = 0;
 801852c:	687b      	ldr	r3, [r7, #4]
 801852e:	2200      	movs	r2, #0
 8018530:	f883 208e 	strb.w	r2, [r3, #142]	; 0x8e
    }
    l2cap_ertm_send_information_frame(channel, index, 0);   // final = 0
 8018534:	2200      	movs	r2, #0
 8018536:	68f9      	ldr	r1, [r7, #12]
 8018538:	6878      	ldr	r0, [r7, #4]
 801853a:	f7ff fc4b 	bl	8017dd4 <l2cap_ertm_send_information_frame>
}
 801853e:	bf00      	nop
 8018540:	3710      	adds	r7, #16
 8018542:	46bd      	mov	sp, r7
 8018544:	bd80      	pop	{r7, pc}
	...

08018548 <l2cap_next_local_cid>:

#endif

#ifdef L2CAP_USES_CHANNELS
static uint16_t l2cap_next_local_cid(void){
 8018548:	b580      	push	{r7, lr}
 801854a:	af00      	add	r7, sp, #0
    do {
        if (local_source_cid == 0xffffu) {
 801854c:	4b0d      	ldr	r3, [pc, #52]	; (8018584 <l2cap_next_local_cid+0x3c>)
 801854e:	881b      	ldrh	r3, [r3, #0]
 8018550:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8018554:	4293      	cmp	r3, r2
 8018556:	d103      	bne.n	8018560 <l2cap_next_local_cid+0x18>
            local_source_cid = 0x40;
 8018558:	4b0a      	ldr	r3, [pc, #40]	; (8018584 <l2cap_next_local_cid+0x3c>)
 801855a:	2240      	movs	r2, #64	; 0x40
 801855c:	801a      	strh	r2, [r3, #0]
 801855e:	e005      	b.n	801856c <l2cap_next_local_cid+0x24>
        } else {
            local_source_cid++;
 8018560:	4b08      	ldr	r3, [pc, #32]	; (8018584 <l2cap_next_local_cid+0x3c>)
 8018562:	881b      	ldrh	r3, [r3, #0]
 8018564:	3301      	adds	r3, #1
 8018566:	b29a      	uxth	r2, r3
 8018568:	4b06      	ldr	r3, [pc, #24]	; (8018584 <l2cap_next_local_cid+0x3c>)
 801856a:	801a      	strh	r2, [r3, #0]
        }
    } while (l2cap_get_channel_for_local_cid(local_source_cid) != NULL);
 801856c:	4b05      	ldr	r3, [pc, #20]	; (8018584 <l2cap_next_local_cid+0x3c>)
 801856e:	881b      	ldrh	r3, [r3, #0]
 8018570:	4618      	mov	r0, r3
 8018572:	f000 fb7a 	bl	8018c6a <l2cap_get_channel_for_local_cid>
 8018576:	4603      	mov	r3, r0
 8018578:	2b00      	cmp	r3, #0
 801857a:	d1e7      	bne.n	801854c <l2cap_next_local_cid+0x4>
    return local_source_cid;
 801857c:	4b01      	ldr	r3, [pc, #4]	; (8018584 <l2cap_next_local_cid+0x3c>)
 801857e:	881b      	ldrh	r3, [r3, #0]
}
 8018580:	4618      	mov	r0, r3
 8018582:	bd80      	pop	{r7, pc}
 8018584:	20009eb0 	.word	0x20009eb0

08018588 <l2cap_next_sig_id>:
#endif

static uint8_t l2cap_next_sig_id(void){
 8018588:	b480      	push	{r7}
 801858a:	af00      	add	r7, sp, #0
    if (sig_seq_nr == 0xffu) {
 801858c:	4b0a      	ldr	r3, [pc, #40]	; (80185b8 <l2cap_next_sig_id+0x30>)
 801858e:	781b      	ldrb	r3, [r3, #0]
 8018590:	2bff      	cmp	r3, #255	; 0xff
 8018592:	d103      	bne.n	801859c <l2cap_next_sig_id+0x14>
        sig_seq_nr = 1;
 8018594:	4b08      	ldr	r3, [pc, #32]	; (80185b8 <l2cap_next_sig_id+0x30>)
 8018596:	2201      	movs	r2, #1
 8018598:	701a      	strb	r2, [r3, #0]
 801859a:	e005      	b.n	80185a8 <l2cap_next_sig_id+0x20>
    } else {
        sig_seq_nr++;
 801859c:	4b06      	ldr	r3, [pc, #24]	; (80185b8 <l2cap_next_sig_id+0x30>)
 801859e:	781b      	ldrb	r3, [r3, #0]
 80185a0:	3301      	adds	r3, #1
 80185a2:	b2da      	uxtb	r2, r3
 80185a4:	4b04      	ldr	r3, [pc, #16]	; (80185b8 <l2cap_next_sig_id+0x30>)
 80185a6:	701a      	strb	r2, [r3, #0]
    }
    return sig_seq_nr;
 80185a8:	4b03      	ldr	r3, [pc, #12]	; (80185b8 <l2cap_next_sig_id+0x30>)
 80185aa:	781b      	ldrb	r3, [r3, #0]
}
 80185ac:	4618      	mov	r0, r3
 80185ae:	46bd      	mov	sp, r7
 80185b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80185b4:	4770      	bx	lr
 80185b6:	bf00      	nop
 80185b8:	20009eb2 	.word	0x20009eb2

080185bc <l2cap_init>:

void l2cap_init(void){
 80185bc:	b580      	push	{r7, lr}
 80185be:	af00      	add	r7, sp, #0
    signaling_responses_pending = 0;
 80185c0:	4b23      	ldr	r3, [pc, #140]	; (8018650 <l2cap_init+0x94>)
 80185c2:	2200      	movs	r2, #0
 80185c4:	601a      	str	r2, [r3, #0]
#ifdef L2CAP_USES_CHANNELS
    local_source_cid  = 0x40;
 80185c6:	4b23      	ldr	r3, [pc, #140]	; (8018654 <l2cap_init+0x98>)
 80185c8:	2240      	movs	r2, #64	; 0x40
 80185ca:	801a      	strh	r2, [r3, #0]
#endif
    sig_seq_nr  = 0xff;
 80185cc:	4b22      	ldr	r3, [pc, #136]	; (8018658 <l2cap_init+0x9c>)
 80185ce:	22ff      	movs	r2, #255	; 0xff
 80185d0:	701a      	strb	r2, [r3, #0]
    l2cap_channels = NULL;
 80185d2:	4b22      	ldr	r3, [pc, #136]	; (801865c <l2cap_init+0xa0>)
 80185d4:	2200      	movs	r2, #0
 80185d6:	601a      	str	r2, [r3, #0]

#ifdef ENABLE_CLASSIC
    l2cap_services = NULL;
 80185d8:	4b21      	ldr	r3, [pc, #132]	; (8018660 <l2cap_init+0xa4>)
 80185da:	2200      	movs	r2, #0
 80185dc:	601a      	str	r2, [r3, #0]
    require_security_level2_for_outgoing_sdp = 0;
 80185de:	4b21      	ldr	r3, [pc, #132]	; (8018664 <l2cap_init+0xa8>)
 80185e0:	2200      	movs	r2, #0
 80185e2:	701a      	strb	r2, [r3, #0]

    // Setup Connectionless Channel
    l2cap_fixed_channel_connectionless.local_cid     = L2CAP_CID_CONNECTIONLESS_CHANNEL;
 80185e4:	4b20      	ldr	r3, [pc, #128]	; (8018668 <l2cap_init+0xac>)
 80185e6:	2202      	movs	r2, #2
 80185e8:	80da      	strh	r2, [r3, #6]
    l2cap_fixed_channel_connectionless.channel_type  = L2CAP_CHANNEL_TYPE_CONNECTIONLESS;
 80185ea:	4b1f      	ldr	r3, [pc, #124]	; (8018668 <l2cap_init+0xac>)
 80185ec:	2201      	movs	r2, #1
 80185ee:	711a      	strb	r2, [r3, #4]
    btstack_linked_list_add(&l2cap_channels, (btstack_linked_item_t *) &l2cap_fixed_channel_connectionless);
 80185f0:	491d      	ldr	r1, [pc, #116]	; (8018668 <l2cap_init+0xac>)
 80185f2:	481a      	ldr	r0, [pc, #104]	; (801865c <l2cap_init+0xa0>)
 80185f4:	f7f6 f81d 	bl	800e632 <btstack_linked_list_add>
#endif

#ifdef ENABLE_LE_DATA_CHANNELS
    l2cap_le_services = NULL;
 80185f8:	4b1c      	ldr	r3, [pc, #112]	; (801866c <l2cap_init+0xb0>)
 80185fa:	2200      	movs	r2, #0
 80185fc:	601a      	str	r2, [r3, #0]
#endif

#ifdef ENABLE_BLE
    l2cap_event_packet_handler = NULL;
 80185fe:	4b1c      	ldr	r3, [pc, #112]	; (8018670 <l2cap_init+0xb4>)
 8018600:	2200      	movs	r2, #0
 8018602:	601a      	str	r2, [r3, #0]
    l2cap_le_custom_max_mtu = 0;
 8018604:	4b1b      	ldr	r3, [pc, #108]	; (8018674 <l2cap_init+0xb8>)
 8018606:	2200      	movs	r2, #0
 8018608:	801a      	strh	r2, [r3, #0]

    // Setup fixed ATT Channel
    l2cap_fixed_channel_att.local_cid    = L2CAP_CID_ATTRIBUTE_PROTOCOL;
 801860a:	4b1b      	ldr	r3, [pc, #108]	; (8018678 <l2cap_init+0xbc>)
 801860c:	2204      	movs	r2, #4
 801860e:	80da      	strh	r2, [r3, #6]
    l2cap_fixed_channel_att.channel_type = L2CAP_CHANNEL_TYPE_LE_FIXED;
 8018610:	4b19      	ldr	r3, [pc, #100]	; (8018678 <l2cap_init+0xbc>)
 8018612:	2203      	movs	r2, #3
 8018614:	711a      	strb	r2, [r3, #4]
    btstack_linked_list_add(&l2cap_channels, (btstack_linked_item_t *) &l2cap_fixed_channel_att);
 8018616:	4918      	ldr	r1, [pc, #96]	; (8018678 <l2cap_init+0xbc>)
 8018618:	4810      	ldr	r0, [pc, #64]	; (801865c <l2cap_init+0xa0>)
 801861a:	f7f6 f80a 	bl	800e632 <btstack_linked_list_add>

    // Setup fixed SM Channel
    l2cap_fixed_channel_sm.local_cid     = L2CAP_CID_SECURITY_MANAGER_PROTOCOL;
 801861e:	4b17      	ldr	r3, [pc, #92]	; (801867c <l2cap_init+0xc0>)
 8018620:	2206      	movs	r2, #6
 8018622:	80da      	strh	r2, [r3, #6]
    l2cap_fixed_channel_sm.channel_type  = L2CAP_CHANNEL_TYPE_LE_FIXED;
 8018624:	4b15      	ldr	r3, [pc, #84]	; (801867c <l2cap_init+0xc0>)
 8018626:	2203      	movs	r2, #3
 8018628:	711a      	strb	r2, [r3, #4]
    btstack_linked_list_add(&l2cap_channels, (btstack_linked_item_t *) &l2cap_fixed_channel_sm);
 801862a:	4914      	ldr	r1, [pc, #80]	; (801867c <l2cap_init+0xc0>)
 801862c:	480b      	ldr	r0, [pc, #44]	; (801865c <l2cap_init+0xa0>)
 801862e:	f7f6 f800 	bl	800e632 <btstack_linked_list_add>
#endif
    
    // 
    // register callback with HCI
    //
    hci_event_callback_registration.callback = &l2cap_hci_event_handler;
 8018632:	4b13      	ldr	r3, [pc, #76]	; (8018680 <l2cap_init+0xc4>)
 8018634:	4a13      	ldr	r2, [pc, #76]	; (8018684 <l2cap_init+0xc8>)
 8018636:	605a      	str	r2, [r3, #4]
    hci_add_event_handler(&hci_event_callback_registration);
 8018638:	4811      	ldr	r0, [pc, #68]	; (8018680 <l2cap_init+0xc4>)
 801863a:	f7fb fc5b 	bl	8013ef4 <hci_add_event_handler>

    hci_register_acl_packet_handler(&l2cap_acl_handler);
 801863e:	4812      	ldr	r0, [pc, #72]	; (8018688 <l2cap_init+0xcc>)
 8018640:	f7fb fc6a 	bl	8013f18 <hci_register_acl_packet_handler>

#ifndef ENABLE_EXPLICIT_CONNECTABLE_MODE_CONTROL
#ifdef ENABLE_CLASSIC
    gap_connectable_control(0); // no services yet
 8018644:	2000      	movs	r0, #0
 8018646:	f7fc f85f 	bl	8014708 <gap_connectable_control>
#endif
#endif
}
 801864a:	bf00      	nop
 801864c:	bd80      	pop	{r7, pc}
 801864e:	bf00      	nop
 8018650:	20009ecc 	.word	0x20009ecc
 8018654:	20009eb0 	.word	0x20009eb0
 8018658:	20009eb2 	.word	0x20009eb2
 801865c:	20009eac 	.word	0x20009eac
 8018660:	20009e98 	.word	0x20009e98
 8018664:	20009e9c 	.word	0x20009e9c
 8018668:	20009e88 	.word	0x20009e88
 801866c:	20009ea8 	.word	0x20009ea8
 8018670:	20009ed8 	.word	0x20009ed8
 8018674:	20009edc 	.word	0x20009edc
 8018678:	20009e68 	.word	0x20009e68
 801867c:	20009e78 	.word	0x20009e78
 8018680:	20009ed0 	.word	0x20009ed0
 8018684:	0801ab3d 	.word	0x0801ab3d
 8018688:	0801ca25 	.word	0x0801ca25

0801868c <l2cap_request_can_send_fix_channel_now_event>:
#else
    UNUSED(handler);    // ok: no code
#endif
}

void l2cap_request_can_send_fix_channel_now_event(hci_con_handle_t con_handle, uint16_t channel_id){
 801868c:	b580      	push	{r7, lr}
 801868e:	b084      	sub	sp, #16
 8018690:	af00      	add	r7, sp, #0
 8018692:	4603      	mov	r3, r0
 8018694:	460a      	mov	r2, r1
 8018696:	80fb      	strh	r3, [r7, #6]
 8018698:	4613      	mov	r3, r2
 801869a:	80bb      	strh	r3, [r7, #4]
    UNUSED(con_handle);  // ok: there is no con handle

    l2cap_fixed_channel_t * channel = l2cap_fixed_channel_for_channel_id(channel_id);
 801869c:	88bb      	ldrh	r3, [r7, #4]
 801869e:	4618      	mov	r0, r3
 80186a0:	f000 fad0 	bl	8018c44 <l2cap_fixed_channel_for_channel_id>
 80186a4:	60f8      	str	r0, [r7, #12]
    if (!channel) return;
 80186a6:	68fb      	ldr	r3, [r7, #12]
 80186a8:	2b00      	cmp	r3, #0
 80186aa:	d005      	beq.n	80186b8 <l2cap_request_can_send_fix_channel_now_event+0x2c>
    channel->waiting_for_can_send_now = 1;
 80186ac:	68fb      	ldr	r3, [r7, #12]
 80186ae:	2201      	movs	r2, #1
 80186b0:	731a      	strb	r2, [r3, #12]
    l2cap_notify_channel_can_send();
 80186b2:	f001 ffcb 	bl	801a64c <l2cap_notify_channel_can_send>
 80186b6:	e000      	b.n	80186ba <l2cap_request_can_send_fix_channel_now_event+0x2e>
    if (!channel) return;
 80186b8:	bf00      	nop
}
 80186ba:	3710      	adds	r7, #16
 80186bc:	46bd      	mov	sp, r7
 80186be:	bd80      	pop	{r7, pc}

080186c0 <l2cap_can_send_fixed_channel_packet_now>:

int  l2cap_can_send_fixed_channel_packet_now(hci_con_handle_t con_handle, uint16_t channel_id){
 80186c0:	b580      	push	{r7, lr}
 80186c2:	b082      	sub	sp, #8
 80186c4:	af00      	add	r7, sp, #0
 80186c6:	4603      	mov	r3, r0
 80186c8:	460a      	mov	r2, r1
 80186ca:	80fb      	strh	r3, [r7, #6]
 80186cc:	4613      	mov	r3, r2
 80186ce:	80bb      	strh	r3, [r7, #4]
    UNUSED(channel_id); // ok: only depends on Controller LE buffers

    return hci_can_send_acl_packet_now(con_handle);
 80186d0:	88fb      	ldrh	r3, [r7, #6]
 80186d2:	4618      	mov	r0, r3
 80186d4:	f7f7 fc84 	bl	800ffe0 <hci_can_send_acl_packet_now>
 80186d8:	4603      	mov	r3, r0
}
 80186da:	4618      	mov	r0, r3
 80186dc:	3708      	adds	r7, #8
 80186de:	46bd      	mov	sp, r7
 80186e0:	bd80      	pop	{r7, pc}

080186e2 <l2cap_get_outgoing_buffer>:

uint8_t *l2cap_get_outgoing_buffer(void){
 80186e2:	b580      	push	{r7, lr}
 80186e4:	af00      	add	r7, sp, #0
    return hci_get_outgoing_packet_buffer() + COMPLETE_L2CAP_HEADER; // 8 bytes
 80186e6:	f7f8 f855 	bl	8010794 <hci_get_outgoing_packet_buffer>
 80186ea:	4603      	mov	r3, r0
 80186ec:	3308      	adds	r3, #8
}
 80186ee:	4618      	mov	r0, r3
 80186f0:	bd80      	pop	{r7, pc}

080186f2 <l2cap_reserve_packet_buffer>:

// only for L2CAP Basic Channels
int l2cap_reserve_packet_buffer(void){
 80186f2:	b580      	push	{r7, lr}
 80186f4:	af00      	add	r7, sp, #0
    return hci_reserve_packet_buffer();
 80186f6:	f7f7 fcdd 	bl	80100b4 <hci_reserve_packet_buffer>
 80186fa:	4603      	mov	r3, r0
}
 80186fc:	4618      	mov	r0, r3
 80186fe:	bd80      	pop	{r7, pc}

08018700 <l2cap_release_packet_buffer>:

// only for L2CAP Basic Channels
void l2cap_release_packet_buffer(void){
 8018700:	b580      	push	{r7, lr}
 8018702:	af00      	add	r7, sp, #0
    hci_release_packet_buffer();
 8018704:	f7f7 fcf6 	bl	80100f4 <hci_release_packet_buffer>
}
 8018708:	bf00      	nop
 801870a:	bd80      	pop	{r7, pc}

0801870c <l2cap_setup_header>:

static void l2cap_setup_header(uint8_t * acl_buffer, hci_con_handle_t con_handle, uint8_t packet_boundary, uint16_t remote_cid, uint16_t len){
 801870c:	b580      	push	{r7, lr}
 801870e:	b084      	sub	sp, #16
 8018710:	af00      	add	r7, sp, #0
 8018712:	60f8      	str	r0, [r7, #12]
 8018714:	4608      	mov	r0, r1
 8018716:	4611      	mov	r1, r2
 8018718:	461a      	mov	r2, r3
 801871a:	4603      	mov	r3, r0
 801871c:	817b      	strh	r3, [r7, #10]
 801871e:	460b      	mov	r3, r1
 8018720:	727b      	strb	r3, [r7, #9]
 8018722:	4613      	mov	r3, r2
 8018724:	80fb      	strh	r3, [r7, #6]
    // 0 - Connection handle : PB=pb : BC=00 
    little_endian_store_16(acl_buffer, 0u, con_handle | (packet_boundary << 12u) | (0u << 14u));
 8018726:	7a7b      	ldrb	r3, [r7, #9]
 8018728:	031b      	lsls	r3, r3, #12
 801872a:	b21a      	sxth	r2, r3
 801872c:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8018730:	4313      	orrs	r3, r2
 8018732:	b21b      	sxth	r3, r3
 8018734:	b29b      	uxth	r3, r3
 8018736:	461a      	mov	r2, r3
 8018738:	2100      	movs	r1, #0
 801873a:	68f8      	ldr	r0, [r7, #12]
 801873c:	f7f6 fb93 	bl	800ee66 <little_endian_store_16>
    // 2 - ACL length
    little_endian_store_16(acl_buffer, 2u,  len + 4u);
 8018740:	8b3b      	ldrh	r3, [r7, #24]
 8018742:	3304      	adds	r3, #4
 8018744:	b29b      	uxth	r3, r3
 8018746:	461a      	mov	r2, r3
 8018748:	2102      	movs	r1, #2
 801874a:	68f8      	ldr	r0, [r7, #12]
 801874c:	f7f6 fb8b 	bl	800ee66 <little_endian_store_16>
    // 4 - L2CAP packet length
    little_endian_store_16(acl_buffer, 4u,  len + 0u);
 8018750:	8b3b      	ldrh	r3, [r7, #24]
 8018752:	461a      	mov	r2, r3
 8018754:	2104      	movs	r1, #4
 8018756:	68f8      	ldr	r0, [r7, #12]
 8018758:	f7f6 fb85 	bl	800ee66 <little_endian_store_16>
    // 6 - L2CAP channel DEST
    little_endian_store_16(acl_buffer, 6,  remote_cid);    
 801875c:	88fb      	ldrh	r3, [r7, #6]
 801875e:	461a      	mov	r2, r3
 8018760:	2106      	movs	r1, #6
 8018762:	68f8      	ldr	r0, [r7, #12]
 8018764:	f7f6 fb7f 	bl	800ee66 <little_endian_store_16>
}
 8018768:	bf00      	nop
 801876a:	3710      	adds	r7, #16
 801876c:	46bd      	mov	sp, r7
 801876e:	bd80      	pop	{r7, pc}

08018770 <l2cap_send_prepared_connectionless>:

// assumption - only on LE connections
int l2cap_send_prepared_connectionless(hci_con_handle_t con_handle, uint16_t cid, uint16_t len){
 8018770:	b580      	push	{r7, lr}
 8018772:	b086      	sub	sp, #24
 8018774:	af02      	add	r7, sp, #8
 8018776:	4603      	mov	r3, r0
 8018778:	80fb      	strh	r3, [r7, #6]
 801877a:	460b      	mov	r3, r1
 801877c:	80bb      	strh	r3, [r7, #4]
 801877e:	4613      	mov	r3, r2
 8018780:	807b      	strh	r3, [r7, #2]
    
    if (!hci_is_packet_buffer_reserved()){
 8018782:	f7f7 fc89 	bl	8010098 <hci_is_packet_buffer_reserved>
 8018786:	4603      	mov	r3, r0
 8018788:	2b00      	cmp	r3, #0
 801878a:	d108      	bne.n	801879e <l2cap_send_prepared_connectionless+0x2e>
        log_error("l2cap_send_prepared_connectionless called without reserving packet first");
 801878c:	f44f 7377 	mov.w	r3, #988	; 0x3dc
 8018790:	4a18      	ldr	r2, [pc, #96]	; (80187f4 <l2cap_send_prepared_connectionless+0x84>)
 8018792:	4919      	ldr	r1, [pc, #100]	; (80187f8 <l2cap_send_prepared_connectionless+0x88>)
 8018794:	2002      	movs	r0, #2
 8018796:	f7fe fe53 	bl	8017440 <hci_dump_log>
        return BTSTACK_ACL_BUFFERS_FULL;
 801879a:	2357      	movs	r3, #87	; 0x57
 801879c:	e025      	b.n	80187ea <l2cap_send_prepared_connectionless+0x7a>
    }

    if (!hci_can_send_prepared_acl_packet_now(con_handle)){
 801879e:	88fb      	ldrh	r3, [r7, #6]
 80187a0:	4618      	mov	r0, r3
 80187a2:	f7f7 fc01 	bl	800ffa8 <hci_can_send_prepared_acl_packet_now>
 80187a6:	4603      	mov	r3, r0
 80187a8:	2b00      	cmp	r3, #0
 80187aa:	d10c      	bne.n	80187c6 <l2cap_send_prepared_connectionless+0x56>
        log_info("l2cap_send_prepared_connectionless handle 0x%02x, cid 0x%02x, cannot send", con_handle, cid);
 80187ac:	88fb      	ldrh	r3, [r7, #6]
 80187ae:	88ba      	ldrh	r2, [r7, #4]
 80187b0:	9201      	str	r2, [sp, #4]
 80187b2:	9300      	str	r3, [sp, #0]
 80187b4:	f240 33e1 	movw	r3, #993	; 0x3e1
 80187b8:	4a0e      	ldr	r2, [pc, #56]	; (80187f4 <l2cap_send_prepared_connectionless+0x84>)
 80187ba:	4910      	ldr	r1, [pc, #64]	; (80187fc <l2cap_send_prepared_connectionless+0x8c>)
 80187bc:	2001      	movs	r0, #1
 80187be:	f7fe fe3f 	bl	8017440 <hci_dump_log>
        return BTSTACK_ACL_BUFFERS_FULL;
 80187c2:	2357      	movs	r3, #87	; 0x57
 80187c4:	e011      	b.n	80187ea <l2cap_send_prepared_connectionless+0x7a>
    }
    
    log_debug("l2cap_send_prepared_connectionless handle %u, cid 0x%02x", con_handle, cid);
    
    uint8_t *acl_buffer = hci_get_outgoing_packet_buffer();
 80187c6:	f7f7 ffe5 	bl	8010794 <hci_get_outgoing_packet_buffer>
 80187ca:	60f8      	str	r0, [r7, #12]
    l2cap_setup_header(acl_buffer, con_handle, 0, cid, len);
 80187cc:	88ba      	ldrh	r2, [r7, #4]
 80187ce:	88f9      	ldrh	r1, [r7, #6]
 80187d0:	887b      	ldrh	r3, [r7, #2]
 80187d2:	9300      	str	r3, [sp, #0]
 80187d4:	4613      	mov	r3, r2
 80187d6:	2200      	movs	r2, #0
 80187d8:	68f8      	ldr	r0, [r7, #12]
 80187da:	f7ff ff97 	bl	801870c <l2cap_setup_header>
    // send
    return hci_send_acl_packet_buffer(len+8u);
 80187de:	887b      	ldrh	r3, [r7, #2]
 80187e0:	3308      	adds	r3, #8
 80187e2:	4618      	mov	r0, r3
 80187e4:	f7f7 fd68 	bl	80102b8 <hci_send_acl_packet_buffer>
 80187e8:	4603      	mov	r3, r0
}
 80187ea:	4618      	mov	r0, r3
 80187ec:	3710      	adds	r7, #16
 80187ee:	46bd      	mov	sp, r7
 80187f0:	bd80      	pop	{r7, pc}
 80187f2:	bf00      	nop
 80187f4:	0802b1dc 	.word	0x0802b1dc
 80187f8:	0802b7b0 	.word	0x0802b7b0
 80187fc:	0802b800 	.word	0x0802b800

08018800 <l2cap_send_connectionless>:

// assumption - only on LE connections
int l2cap_send_connectionless(hci_con_handle_t con_handle, uint16_t cid, uint8_t *data, uint16_t len){
 8018800:	b580      	push	{r7, lr}
 8018802:	b088      	sub	sp, #32
 8018804:	af02      	add	r7, sp, #8
 8018806:	60ba      	str	r2, [r7, #8]
 8018808:	461a      	mov	r2, r3
 801880a:	4603      	mov	r3, r0
 801880c:	81fb      	strh	r3, [r7, #14]
 801880e:	460b      	mov	r3, r1
 8018810:	81bb      	strh	r3, [r7, #12]
 8018812:	4613      	mov	r3, r2
 8018814:	80fb      	strh	r3, [r7, #6]
    
    if (!hci_can_send_acl_packet_now(con_handle)){
 8018816:	89fb      	ldrh	r3, [r7, #14]
 8018818:	4618      	mov	r0, r3
 801881a:	f7f7 fbe1 	bl	800ffe0 <hci_can_send_acl_packet_now>
 801881e:	4603      	mov	r3, r0
 8018820:	2b00      	cmp	r3, #0
 8018822:	d10a      	bne.n	801883a <l2cap_send_connectionless+0x3a>
        log_info("l2cap_send cid 0x%02x, cannot send", cid);
 8018824:	89bb      	ldrh	r3, [r7, #12]
 8018826:	9300      	str	r3, [sp, #0]
 8018828:	f240 33f1 	movw	r3, #1009	; 0x3f1
 801882c:	4a0e      	ldr	r2, [pc, #56]	; (8018868 <l2cap_send_connectionless+0x68>)
 801882e:	490f      	ldr	r1, [pc, #60]	; (801886c <l2cap_send_connectionless+0x6c>)
 8018830:	2001      	movs	r0, #1
 8018832:	f7fe fe05 	bl	8017440 <hci_dump_log>
        return BTSTACK_ACL_BUFFERS_FULL;
 8018836:	2357      	movs	r3, #87	; 0x57
 8018838:	e012      	b.n	8018860 <l2cap_send_connectionless+0x60>
    }
    
    hci_reserve_packet_buffer();
 801883a:	f7f7 fc3b 	bl	80100b4 <hci_reserve_packet_buffer>
    uint8_t *acl_buffer = hci_get_outgoing_packet_buffer();
 801883e:	f7f7 ffa9 	bl	8010794 <hci_get_outgoing_packet_buffer>
 8018842:	6178      	str	r0, [r7, #20]
    
    (void)memcpy(&acl_buffer[8], data, len);
 8018844:	697b      	ldr	r3, [r7, #20]
 8018846:	3308      	adds	r3, #8
 8018848:	88fa      	ldrh	r2, [r7, #6]
 801884a:	68b9      	ldr	r1, [r7, #8]
 801884c:	4618      	mov	r0, r3
 801884e:	f00f f914 	bl	8027a7a <memcpy>
    
    return l2cap_send_prepared_connectionless(con_handle, cid, len);
 8018852:	88fa      	ldrh	r2, [r7, #6]
 8018854:	89b9      	ldrh	r1, [r7, #12]
 8018856:	89fb      	ldrh	r3, [r7, #14]
 8018858:	4618      	mov	r0, r3
 801885a:	f7ff ff89 	bl	8018770 <l2cap_send_prepared_connectionless>
 801885e:	4603      	mov	r3, r0
}
 8018860:	4618      	mov	r0, r3
 8018862:	3718      	adds	r7, #24
 8018864:	46bd      	mov	sp, r7
 8018866:	bd80      	pop	{r7, pc}
 8018868:	0802b1dc 	.word	0x0802b1dc
 801886c:	0802b854 	.word	0x0802b854

08018870 <l2cap_emit_can_send_now>:

static void l2cap_emit_can_send_now(btstack_packet_handler_t packet_handler, uint16_t channel) {
 8018870:	b590      	push	{r4, r7, lr}
 8018872:	b085      	sub	sp, #20
 8018874:	af00      	add	r7, sp, #0
 8018876:	6078      	str	r0, [r7, #4]
 8018878:	460b      	mov	r3, r1
 801887a:	807b      	strh	r3, [r7, #2]
    log_debug("L2CAP_EVENT_CHANNEL_CAN_SEND_NOW local_cid 0x%x", channel);
    uint8_t event[4];
    event[0] = L2CAP_EVENT_CAN_SEND_NOW;
 801887c:	2378      	movs	r3, #120	; 0x78
 801887e:	733b      	strb	r3, [r7, #12]
    event[1] = sizeof(event) - 2u;
 8018880:	2302      	movs	r3, #2
 8018882:	737b      	strb	r3, [r7, #13]
    little_endian_store_16(event, 2, channel);
 8018884:	887a      	ldrh	r2, [r7, #2]
 8018886:	f107 030c 	add.w	r3, r7, #12
 801888a:	2102      	movs	r1, #2
 801888c:	4618      	mov	r0, r3
 801888e:	f7f6 faea 	bl	800ee66 <little_endian_store_16>
    hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
 8018892:	f107 020c 	add.w	r2, r7, #12
 8018896:	2304      	movs	r3, #4
 8018898:	2100      	movs	r1, #0
 801889a:	2004      	movs	r0, #4
 801889c:	f7fe fd2a 	bl	80172f4 <hci_dump_packet>
    packet_handler(HCI_EVENT_PACKET, channel, event, sizeof(event));
 80188a0:	f107 020c 	add.w	r2, r7, #12
 80188a4:	8879      	ldrh	r1, [r7, #2]
 80188a6:	687c      	ldr	r4, [r7, #4]
 80188a8:	2304      	movs	r3, #4
 80188aa:	2004      	movs	r0, #4
 80188ac:	47a0      	blx	r4
}
 80188ae:	bf00      	nop
 80188b0:	3714      	adds	r7, #20
 80188b2:	46bd      	mov	sp, r7
 80188b4:	bd90      	pop	{r4, r7, pc}

080188b6 <l2cap_dispatch_to_channel>:

#ifdef L2CAP_USES_CHANNELS
static void l2cap_dispatch_to_channel(l2cap_channel_t *channel, uint8_t type, uint8_t * data, uint16_t size){
 80188b6:	b590      	push	{r4, r7, lr}
 80188b8:	b085      	sub	sp, #20
 80188ba:	af00      	add	r7, sp, #0
 80188bc:	60f8      	str	r0, [r7, #12]
 80188be:	607a      	str	r2, [r7, #4]
 80188c0:	461a      	mov	r2, r3
 80188c2:	460b      	mov	r3, r1
 80188c4:	72fb      	strb	r3, [r7, #11]
 80188c6:	4613      	mov	r3, r2
 80188c8:	813b      	strh	r3, [r7, #8]
    (* (channel->packet_handler))(type, channel->local_cid, data, size);
 80188ca:	68fb      	ldr	r3, [r7, #12]
 80188cc:	689c      	ldr	r4, [r3, #8]
 80188ce:	68fb      	ldr	r3, [r7, #12]
 80188d0:	88d9      	ldrh	r1, [r3, #6]
 80188d2:	893b      	ldrh	r3, [r7, #8]
 80188d4:	7af8      	ldrb	r0, [r7, #11]
 80188d6:	687a      	ldr	r2, [r7, #4]
 80188d8:	47a0      	blx	r4
}
 80188da:	bf00      	nop
 80188dc:	3714      	adds	r7, #20
 80188de:	46bd      	mov	sp, r7
 80188e0:	bd90      	pop	{r4, r7, pc}

080188e2 <l2cap_emit_simple_event_with_cid>:

static void l2cap_emit_simple_event_with_cid(l2cap_channel_t * channel, uint8_t event_code){
 80188e2:	b580      	push	{r7, lr}
 80188e4:	b084      	sub	sp, #16
 80188e6:	af00      	add	r7, sp, #0
 80188e8:	6078      	str	r0, [r7, #4]
 80188ea:	460b      	mov	r3, r1
 80188ec:	70fb      	strb	r3, [r7, #3]
    uint8_t event[4];
    event[0] = event_code;
 80188ee:	78fb      	ldrb	r3, [r7, #3]
 80188f0:	733b      	strb	r3, [r7, #12]
    event[1] = sizeof(event) - 2u;
 80188f2:	2302      	movs	r3, #2
 80188f4:	737b      	strb	r3, [r7, #13]
    little_endian_store_16(event, 2, channel->local_cid);
 80188f6:	687b      	ldr	r3, [r7, #4]
 80188f8:	88da      	ldrh	r2, [r3, #6]
 80188fa:	f107 030c 	add.w	r3, r7, #12
 80188fe:	2102      	movs	r1, #2
 8018900:	4618      	mov	r0, r3
 8018902:	f7f6 fab0 	bl	800ee66 <little_endian_store_16>
    hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
 8018906:	f107 020c 	add.w	r2, r7, #12
 801890a:	2304      	movs	r3, #4
 801890c:	2100      	movs	r1, #0
 801890e:	2004      	movs	r0, #4
 8018910:	f7fe fcf0 	bl	80172f4 <hci_dump_packet>
    l2cap_dispatch_to_channel(channel, HCI_EVENT_PACKET, event, sizeof(event));
 8018914:	f107 020c 	add.w	r2, r7, #12
 8018918:	2304      	movs	r3, #4
 801891a:	2104      	movs	r1, #4
 801891c:	6878      	ldr	r0, [r7, #4]
 801891e:	f7ff ffca 	bl	80188b6 <l2cap_dispatch_to_channel>
}
 8018922:	bf00      	nop
 8018924:	3710      	adds	r7, #16
 8018926:	46bd      	mov	sp, r7
 8018928:	bd80      	pop	{r7, pc}
	...

0801892c <l2cap_emit_channel_opened>:
#endif

#ifdef ENABLE_CLASSIC
void l2cap_emit_channel_opened(l2cap_channel_t *channel, uint8_t status) {
 801892c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801892e:	b097      	sub	sp, #92	; 0x5c
 8018930:	af0a      	add	r7, sp, #40	; 0x28
 8018932:	60f8      	str	r0, [r7, #12]
 8018934:	460b      	mov	r3, r1
 8018936:	72fb      	strb	r3, [r7, #11]
    log_info("L2CAP_EVENT_CHANNEL_OPENED status 0x%x addr %s handle 0x%x psm 0x%x local_cid 0x%x remote_cid 0x%x local_mtu %u, remote_mtu %u, flush_timeout %u",
 8018938:	7afc      	ldrb	r4, [r7, #11]
 801893a:	68fb      	ldr	r3, [r7, #12]
 801893c:	3326      	adds	r3, #38	; 0x26
 801893e:	4618      	mov	r0, r3
 8018940:	f7f6 fd66 	bl	800f410 <bd_addr_to_str>
 8018944:	4602      	mov	r2, r0
 8018946:	68fb      	ldr	r3, [r7, #12]
 8018948:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801894a:	4619      	mov	r1, r3
 801894c:	68fb      	ldr	r3, [r7, #12]
 801894e:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8018950:	4618      	mov	r0, r3
 8018952:	68fb      	ldr	r3, [r7, #12]
 8018954:	88db      	ldrh	r3, [r3, #6]
 8018956:	461d      	mov	r5, r3
 8018958:	68fb      	ldr	r3, [r7, #12]
 801895a:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801895c:	461e      	mov	r6, r3
 801895e:	68fb      	ldr	r3, [r7, #12]
 8018960:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8018962:	607b      	str	r3, [r7, #4]
 8018964:	68fb      	ldr	r3, [r7, #12]
 8018966:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8018968:	603b      	str	r3, [r7, #0]
 801896a:	68fb      	ldr	r3, [r7, #12]
 801896c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 801896e:	9308      	str	r3, [sp, #32]
 8018970:	683b      	ldr	r3, [r7, #0]
 8018972:	9307      	str	r3, [sp, #28]
 8018974:	687b      	ldr	r3, [r7, #4]
 8018976:	9306      	str	r3, [sp, #24]
 8018978:	9605      	str	r6, [sp, #20]
 801897a:	9504      	str	r5, [sp, #16]
 801897c:	9003      	str	r0, [sp, #12]
 801897e:	9102      	str	r1, [sp, #8]
 8018980:	9201      	str	r2, [sp, #4]
 8018982:	9400      	str	r4, [sp, #0]
 8018984:	f240 431a 	movw	r3, #1050	; 0x41a
 8018988:	4a41      	ldr	r2, [pc, #260]	; (8018a90 <l2cap_emit_channel_opened+0x164>)
 801898a:	4942      	ldr	r1, [pc, #264]	; (8018a94 <l2cap_emit_channel_opened+0x168>)
 801898c:	2001      	movs	r0, #1
 801898e:	f7fe fd57 	bl	8017440 <hci_dump_log>
             status, bd_addr_to_str(channel->address), channel->con_handle, channel->psm,
             channel->local_cid, channel->remote_cid, channel->local_mtu, channel->remote_mtu, channel->flush_timeout);
    uint8_t event[26];
    event[0] = L2CAP_EVENT_CHANNEL_OPENED;
 8018992:	2370      	movs	r3, #112	; 0x70
 8018994:	753b      	strb	r3, [r7, #20]
    event[1] = sizeof(event) - 2;
 8018996:	2318      	movs	r3, #24
 8018998:	757b      	strb	r3, [r7, #21]
    event[2] = status;
 801899a:	7afb      	ldrb	r3, [r7, #11]
 801899c:	75bb      	strb	r3, [r7, #22]
    reverse_bd_addr(channel->address, &event[3]);
 801899e:	68fb      	ldr	r3, [r7, #12]
 80189a0:	f103 0226 	add.w	r2, r3, #38	; 0x26
 80189a4:	f107 0314 	add.w	r3, r7, #20
 80189a8:	3303      	adds	r3, #3
 80189aa:	4619      	mov	r1, r3
 80189ac:	4610      	mov	r0, r2
 80189ae:	f7f6 fba0 	bl	800f0f2 <reverse_bd_addr>
    little_endian_store_16(event,  9, channel->con_handle);
 80189b2:	68fb      	ldr	r3, [r7, #12]
 80189b4:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 80189b6:	f107 0314 	add.w	r3, r7, #20
 80189ba:	2109      	movs	r1, #9
 80189bc:	4618      	mov	r0, r3
 80189be:	f7f6 fa52 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 11, channel->psm);
 80189c2:	68fb      	ldr	r3, [r7, #12]
 80189c4:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 80189c6:	f107 0314 	add.w	r3, r7, #20
 80189ca:	210b      	movs	r1, #11
 80189cc:	4618      	mov	r0, r3
 80189ce:	f7f6 fa4a 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 13, channel->local_cid);
 80189d2:	68fb      	ldr	r3, [r7, #12]
 80189d4:	88da      	ldrh	r2, [r3, #6]
 80189d6:	f107 0314 	add.w	r3, r7, #20
 80189da:	210d      	movs	r1, #13
 80189dc:	4618      	mov	r0, r3
 80189de:	f7f6 fa42 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 15, channel->remote_cid);
 80189e2:	68fb      	ldr	r3, [r7, #12]
 80189e4:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 80189e6:	f107 0314 	add.w	r3, r7, #20
 80189ea:	210f      	movs	r1, #15
 80189ec:	4618      	mov	r0, r3
 80189ee:	f7f6 fa3a 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 17, channel->local_mtu);
 80189f2:	68fb      	ldr	r3, [r7, #12]
 80189f4:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
 80189f6:	f107 0314 	add.w	r3, r7, #20
 80189fa:	2111      	movs	r1, #17
 80189fc:	4618      	mov	r0, r3
 80189fe:	f7f6 fa32 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 19, channel->remote_mtu); 
 8018a02:	68fb      	ldr	r3, [r7, #12]
 8018a04:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
 8018a06:	f107 0314 	add.w	r3, r7, #20
 8018a0a:	2113      	movs	r1, #19
 8018a0c:	4618      	mov	r0, r3
 8018a0e:	f7f6 fa2a 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 21, channel->flush_timeout); 
 8018a12:	68fb      	ldr	r3, [r7, #12]
 8018a14:	8eda      	ldrh	r2, [r3, #54]	; 0x36
 8018a16:	f107 0314 	add.w	r3, r7, #20
 8018a1a:	2115      	movs	r1, #21
 8018a1c:	4618      	mov	r0, r3
 8018a1e:	f7f6 fa22 	bl	800ee66 <little_endian_store_16>
    event[23] = (channel->state_var & L2CAP_CHANNEL_STATE_VAR_INCOMING) ? 1 : 0;
 8018a22:	68fb      	ldr	r3, [r7, #12]
 8018a24:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8018a26:	b21b      	sxth	r3, r3
 8018a28:	13db      	asrs	r3, r3, #15
 8018a2a:	b21b      	sxth	r3, r3
 8018a2c:	b2db      	uxtb	r3, r3
 8018a2e:	f003 0301 	and.w	r3, r3, #1
 8018a32:	b2db      	uxtb	r3, r3
 8018a34:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    log_info("ERTM mode %u, fcs enabled %u", channel->mode, channel->fcs_option);
 8018a38:	68fb      	ldr	r3, [r7, #12]
 8018a3a:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 8018a3e:	461a      	mov	r2, r3
 8018a40:	68fb      	ldr	r3, [r7, #12]
 8018a42:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 8018a46:	9301      	str	r3, [sp, #4]
 8018a48:	9200      	str	r2, [sp, #0]
 8018a4a:	f240 4329 	movw	r3, #1065	; 0x429
 8018a4e:	4a10      	ldr	r2, [pc, #64]	; (8018a90 <l2cap_emit_channel_opened+0x164>)
 8018a50:	4911      	ldr	r1, [pc, #68]	; (8018a98 <l2cap_emit_channel_opened+0x16c>)
 8018a52:	2001      	movs	r0, #1
 8018a54:	f7fe fcf4 	bl	8017440 <hci_dump_log>
    event[24] = channel->mode;
 8018a58:	68fb      	ldr	r3, [r7, #12]
 8018a5a:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 8018a5e:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    event[25] = channel->fcs_option;
 8018a62:	68fb      	ldr	r3, [r7, #12]
 8018a64:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 8018a68:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d

#else
    event[24] = L2CAP_CHANNEL_MODE_BASIC;
    event[25] = 0;
#endif
    hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
 8018a6c:	f107 0214 	add.w	r2, r7, #20
 8018a70:	231a      	movs	r3, #26
 8018a72:	2100      	movs	r1, #0
 8018a74:	2004      	movs	r0, #4
 8018a76:	f7fe fc3d 	bl	80172f4 <hci_dump_packet>
    l2cap_dispatch_to_channel(channel, HCI_EVENT_PACKET, event, sizeof(event));
 8018a7a:	f107 0214 	add.w	r2, r7, #20
 8018a7e:	231a      	movs	r3, #26
 8018a80:	2104      	movs	r1, #4
 8018a82:	68f8      	ldr	r0, [r7, #12]
 8018a84:	f7ff ff17 	bl	80188b6 <l2cap_dispatch_to_channel>
}
 8018a88:	bf00      	nop
 8018a8a:	3734      	adds	r7, #52	; 0x34
 8018a8c:	46bd      	mov	sp, r7
 8018a8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8018a90:	0802b1dc 	.word	0x0802b1dc
 8018a94:	0802b880 	.word	0x0802b880
 8018a98:	0802b918 	.word	0x0802b918

08018a9c <l2cap_emit_channel_closed>:

static void l2cap_emit_channel_closed(l2cap_channel_t *channel) {
 8018a9c:	b580      	push	{r7, lr}
 8018a9e:	b084      	sub	sp, #16
 8018aa0:	af02      	add	r7, sp, #8
 8018aa2:	6078      	str	r0, [r7, #4]
    log_info("L2CAP_EVENT_CHANNEL_CLOSED local_cid 0x%x", channel->local_cid);
 8018aa4:	687b      	ldr	r3, [r7, #4]
 8018aa6:	88db      	ldrh	r3, [r3, #6]
 8018aa8:	9300      	str	r3, [sp, #0]
 8018aaa:	f240 4336 	movw	r3, #1078	; 0x436
 8018aae:	4a06      	ldr	r2, [pc, #24]	; (8018ac8 <l2cap_emit_channel_closed+0x2c>)
 8018ab0:	4906      	ldr	r1, [pc, #24]	; (8018acc <l2cap_emit_channel_closed+0x30>)
 8018ab2:	2001      	movs	r0, #1
 8018ab4:	f7fe fcc4 	bl	8017440 <hci_dump_log>
    l2cap_emit_simple_event_with_cid(channel, L2CAP_EVENT_CHANNEL_CLOSED);
 8018ab8:	2171      	movs	r1, #113	; 0x71
 8018aba:	6878      	ldr	r0, [r7, #4]
 8018abc:	f7ff ff11 	bl	80188e2 <l2cap_emit_simple_event_with_cid>
}
 8018ac0:	bf00      	nop
 8018ac2:	3708      	adds	r7, #8
 8018ac4:	46bd      	mov	sp, r7
 8018ac6:	bd80      	pop	{r7, pc}
 8018ac8:	0802b1dc 	.word	0x0802b1dc
 8018acc:	0802b93c 	.word	0x0802b93c

08018ad0 <l2cap_emit_incoming_connection>:

static void l2cap_emit_incoming_connection(l2cap_channel_t *channel) {
 8018ad0:	b590      	push	{r4, r7, lr}
 8018ad2:	b08d      	sub	sp, #52	; 0x34
 8018ad4:	af06      	add	r7, sp, #24
 8018ad6:	6078      	str	r0, [r7, #4]
    log_info("L2CAP_EVENT_INCOMING_CONNECTION addr %s handle 0x%x psm 0x%x local_cid 0x%x remote_cid 0x%x",
 8018ad8:	687b      	ldr	r3, [r7, #4]
 8018ada:	3326      	adds	r3, #38	; 0x26
 8018adc:	4618      	mov	r0, r3
 8018ade:	f7f6 fc97 	bl	800f410 <bd_addr_to_str>
 8018ae2:	4602      	mov	r2, r0
 8018ae4:	687b      	ldr	r3, [r7, #4]
 8018ae6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8018ae8:	4619      	mov	r1, r3
 8018aea:	687b      	ldr	r3, [r7, #4]
 8018aec:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8018aee:	4618      	mov	r0, r3
 8018af0:	687b      	ldr	r3, [r7, #4]
 8018af2:	88db      	ldrh	r3, [r3, #6]
 8018af4:	461c      	mov	r4, r3
 8018af6:	687b      	ldr	r3, [r7, #4]
 8018af8:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8018afa:	9304      	str	r3, [sp, #16]
 8018afc:	9403      	str	r4, [sp, #12]
 8018afe:	9002      	str	r0, [sp, #8]
 8018b00:	9101      	str	r1, [sp, #4]
 8018b02:	9200      	str	r2, [sp, #0]
 8018b04:	f240 433c 	movw	r3, #1084	; 0x43c
 8018b08:	4a22      	ldr	r2, [pc, #136]	; (8018b94 <l2cap_emit_incoming_connection+0xc4>)
 8018b0a:	4923      	ldr	r1, [pc, #140]	; (8018b98 <l2cap_emit_incoming_connection+0xc8>)
 8018b0c:	2001      	movs	r0, #1
 8018b0e:	f7fe fc97 	bl	8017440 <hci_dump_log>
             bd_addr_to_str(channel->address), channel->con_handle,  channel->psm, channel->local_cid, channel->remote_cid);
    uint8_t event[16];
    event[0] = L2CAP_EVENT_INCOMING_CONNECTION;
 8018b12:	2372      	movs	r3, #114	; 0x72
 8018b14:	723b      	strb	r3, [r7, #8]
    event[1] = sizeof(event) - 2;
 8018b16:	230e      	movs	r3, #14
 8018b18:	727b      	strb	r3, [r7, #9]
    reverse_bd_addr(channel->address, &event[2]);
 8018b1a:	687b      	ldr	r3, [r7, #4]
 8018b1c:	f103 0226 	add.w	r2, r3, #38	; 0x26
 8018b20:	f107 0308 	add.w	r3, r7, #8
 8018b24:	3302      	adds	r3, #2
 8018b26:	4619      	mov	r1, r3
 8018b28:	4610      	mov	r0, r2
 8018b2a:	f7f6 fae2 	bl	800f0f2 <reverse_bd_addr>
    little_endian_store_16(event,  8, channel->con_handle);
 8018b2e:	687b      	ldr	r3, [r7, #4]
 8018b30:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 8018b32:	f107 0308 	add.w	r3, r7, #8
 8018b36:	2108      	movs	r1, #8
 8018b38:	4618      	mov	r0, r3
 8018b3a:	f7f6 f994 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 10, channel->psm);
 8018b3e:	687b      	ldr	r3, [r7, #4]
 8018b40:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 8018b42:	f107 0308 	add.w	r3, r7, #8
 8018b46:	210a      	movs	r1, #10
 8018b48:	4618      	mov	r0, r3
 8018b4a:	f7f6 f98c 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 12, channel->local_cid);
 8018b4e:	687b      	ldr	r3, [r7, #4]
 8018b50:	88da      	ldrh	r2, [r3, #6]
 8018b52:	f107 0308 	add.w	r3, r7, #8
 8018b56:	210c      	movs	r1, #12
 8018b58:	4618      	mov	r0, r3
 8018b5a:	f7f6 f984 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 14, channel->remote_cid);
 8018b5e:	687b      	ldr	r3, [r7, #4]
 8018b60:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 8018b62:	f107 0308 	add.w	r3, r7, #8
 8018b66:	210e      	movs	r1, #14
 8018b68:	4618      	mov	r0, r3
 8018b6a:	f7f6 f97c 	bl	800ee66 <little_endian_store_16>
    hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
 8018b6e:	f107 0208 	add.w	r2, r7, #8
 8018b72:	2310      	movs	r3, #16
 8018b74:	2100      	movs	r1, #0
 8018b76:	2004      	movs	r0, #4
 8018b78:	f7fe fbbc 	bl	80172f4 <hci_dump_packet>
    l2cap_dispatch_to_channel(channel, HCI_EVENT_PACKET, event, sizeof(event));
 8018b7c:	f107 0208 	add.w	r2, r7, #8
 8018b80:	2310      	movs	r3, #16
 8018b82:	2104      	movs	r1, #4
 8018b84:	6878      	ldr	r0, [r7, #4]
 8018b86:	f7ff fe96 	bl	80188b6 <l2cap_dispatch_to_channel>
}
 8018b8a:	bf00      	nop
 8018b8c:	371c      	adds	r7, #28
 8018b8e:	46bd      	mov	sp, r7
 8018b90:	bd90      	pop	{r4, r7, pc}
 8018b92:	bf00      	nop
 8018b94:	0802b1dc 	.word	0x0802b1dc
 8018b98:	0802b970 	.word	0x0802b970

08018b9c <l2cap_handle_channel_open_failed>:

static void l2cap_handle_channel_open_failed(l2cap_channel_t * channel, uint8_t status){
 8018b9c:	b580      	push	{r7, lr}
 8018b9e:	b082      	sub	sp, #8
 8018ba0:	af00      	add	r7, sp, #0
 8018ba2:	6078      	str	r0, [r7, #4]
 8018ba4:	460b      	mov	r3, r1
 8018ba6:	70fb      	strb	r3, [r7, #3]
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    // emit ertm buffer released, as it's not needed. if in basic mode, it was either not allocated or already released
    if (channel->mode == L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION){
 8018ba8:	687b      	ldr	r3, [r7, #4]
 8018baa:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 8018bae:	2b03      	cmp	r3, #3
 8018bb0:	d103      	bne.n	8018bba <l2cap_handle_channel_open_failed+0x1e>
        l2cap_emit_simple_event_with_cid(channel, L2CAP_EVENT_ERTM_BUFFER_RELEASED);
 8018bb2:	217e      	movs	r1, #126	; 0x7e
 8018bb4:	6878      	ldr	r0, [r7, #4]
 8018bb6:	f7ff fe94 	bl	80188e2 <l2cap_emit_simple_event_with_cid>
    }
#endif
    l2cap_emit_channel_opened(channel, status);
 8018bba:	78fb      	ldrb	r3, [r7, #3]
 8018bbc:	4619      	mov	r1, r3
 8018bbe:	6878      	ldr	r0, [r7, #4]
 8018bc0:	f7ff feb4 	bl	801892c <l2cap_emit_channel_opened>
}
 8018bc4:	bf00      	nop
 8018bc6:	3708      	adds	r7, #8
 8018bc8:	46bd      	mov	sp, r7
 8018bca:	bd80      	pop	{r7, pc}

08018bcc <l2cap_handle_channel_closed>:

static void l2cap_handle_channel_closed(l2cap_channel_t * channel){
 8018bcc:	b580      	push	{r7, lr}
 8018bce:	b082      	sub	sp, #8
 8018bd0:	af00      	add	r7, sp, #0
 8018bd2:	6078      	str	r0, [r7, #4]
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    // emit ertm buffer released, as it's not needed anymore. if in basic mode, it was either not allocated or already released
    if (channel->mode == L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION){
 8018bd4:	687b      	ldr	r3, [r7, #4]
 8018bd6:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 8018bda:	2b03      	cmp	r3, #3
 8018bdc:	d103      	bne.n	8018be6 <l2cap_handle_channel_closed+0x1a>
        l2cap_emit_simple_event_with_cid(channel, L2CAP_EVENT_ERTM_BUFFER_RELEASED);
 8018bde:	217e      	movs	r1, #126	; 0x7e
 8018be0:	6878      	ldr	r0, [r7, #4]
 8018be2:	f7ff fe7e 	bl	80188e2 <l2cap_emit_simple_event_with_cid>
    }
#endif
    l2cap_emit_channel_closed(channel);
 8018be6:	6878      	ldr	r0, [r7, #4]
 8018be8:	f7ff ff58 	bl	8018a9c <l2cap_emit_channel_closed>
}
 8018bec:	bf00      	nop
 8018bee:	3708      	adds	r7, #8
 8018bf0:	46bd      	mov	sp, r7
 8018bf2:	bd80      	pop	{r7, pc}

08018bf4 <l2cap_channel_item_by_cid>:
#endif

static l2cap_fixed_channel_t * l2cap_channel_item_by_cid(uint16_t cid){
 8018bf4:	b580      	push	{r7, lr}
 8018bf6:	b086      	sub	sp, #24
 8018bf8:	af00      	add	r7, sp, #0
 8018bfa:	4603      	mov	r3, r0
 8018bfc:	80fb      	strh	r3, [r7, #6]
    btstack_linked_list_iterator_t it;    
    btstack_linked_list_iterator_init(&it, &l2cap_channels);
 8018bfe:	f107 0308 	add.w	r3, r7, #8
 8018c02:	490f      	ldr	r1, [pc, #60]	; (8018c40 <l2cap_channel_item_by_cid+0x4c>)
 8018c04:	4618      	mov	r0, r3
 8018c06:	f7f5 fda2 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 8018c0a:	e00c      	b.n	8018c26 <l2cap_channel_item_by_cid+0x32>
        l2cap_fixed_channel_t * channel = (l2cap_fixed_channel_t*) btstack_linked_list_iterator_next(&it);
 8018c0c:	f107 0308 	add.w	r3, r7, #8
 8018c10:	4618      	mov	r0, r3
 8018c12:	f7f5 fddf 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8018c16:	6178      	str	r0, [r7, #20]
        if (channel->local_cid == cid) {
 8018c18:	697b      	ldr	r3, [r7, #20]
 8018c1a:	88db      	ldrh	r3, [r3, #6]
 8018c1c:	88fa      	ldrh	r2, [r7, #6]
 8018c1e:	429a      	cmp	r2, r3
 8018c20:	d101      	bne.n	8018c26 <l2cap_channel_item_by_cid+0x32>
            return channel;
 8018c22:	697b      	ldr	r3, [r7, #20]
 8018c24:	e008      	b.n	8018c38 <l2cap_channel_item_by_cid+0x44>
    while (btstack_linked_list_iterator_has_next(&it)){
 8018c26:	f107 0308 	add.w	r3, r7, #8
 8018c2a:	4618      	mov	r0, r3
 8018c2c:	f7f5 fda4 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8018c30:	4603      	mov	r3, r0
 8018c32:	2b00      	cmp	r3, #0
 8018c34:	d1ea      	bne.n	8018c0c <l2cap_channel_item_by_cid+0x18>
        }
    } 
    return NULL;
 8018c36:	2300      	movs	r3, #0
}
 8018c38:	4618      	mov	r0, r3
 8018c3a:	3718      	adds	r7, #24
 8018c3c:	46bd      	mov	sp, r7
 8018c3e:	bd80      	pop	{r7, pc}
 8018c40:	20009eac 	.word	0x20009eac

08018c44 <l2cap_fixed_channel_for_channel_id>:

// used for fixed channels in LE (ATT/SM) and Classic (Connectionless Channel). CID < 0x04
static l2cap_fixed_channel_t * l2cap_fixed_channel_for_channel_id(uint16_t local_cid){
 8018c44:	b580      	push	{r7, lr}
 8018c46:	b082      	sub	sp, #8
 8018c48:	af00      	add	r7, sp, #0
 8018c4a:	4603      	mov	r3, r0
 8018c4c:	80fb      	strh	r3, [r7, #6]
    if (local_cid >= 0x40u) return NULL;
 8018c4e:	88fb      	ldrh	r3, [r7, #6]
 8018c50:	2b3f      	cmp	r3, #63	; 0x3f
 8018c52:	d901      	bls.n	8018c58 <l2cap_fixed_channel_for_channel_id+0x14>
 8018c54:	2300      	movs	r3, #0
 8018c56:	e004      	b.n	8018c62 <l2cap_fixed_channel_for_channel_id+0x1e>
    return (l2cap_fixed_channel_t*) l2cap_channel_item_by_cid(local_cid);
 8018c58:	88fb      	ldrh	r3, [r7, #6]
 8018c5a:	4618      	mov	r0, r3
 8018c5c:	f7ff ffca 	bl	8018bf4 <l2cap_channel_item_by_cid>
 8018c60:	4603      	mov	r3, r0
}
 8018c62:	4618      	mov	r0, r3
 8018c64:	3708      	adds	r7, #8
 8018c66:	46bd      	mov	sp, r7
 8018c68:	bd80      	pop	{r7, pc}

08018c6a <l2cap_get_channel_for_local_cid>:

// used for Classic Channels + LE Data Channels. local_cid >= 0x40
#ifdef L2CAP_USES_CHANNELS
static l2cap_channel_t * l2cap_get_channel_for_local_cid(uint16_t local_cid){
 8018c6a:	b580      	push	{r7, lr}
 8018c6c:	b082      	sub	sp, #8
 8018c6e:	af00      	add	r7, sp, #0
 8018c70:	4603      	mov	r3, r0
 8018c72:	80fb      	strh	r3, [r7, #6]
    if (local_cid < 0x40u) return NULL;
 8018c74:	88fb      	ldrh	r3, [r7, #6]
 8018c76:	2b3f      	cmp	r3, #63	; 0x3f
 8018c78:	d801      	bhi.n	8018c7e <l2cap_get_channel_for_local_cid+0x14>
 8018c7a:	2300      	movs	r3, #0
 8018c7c:	e004      	b.n	8018c88 <l2cap_get_channel_for_local_cid+0x1e>
    return (l2cap_channel_t*) l2cap_channel_item_by_cid(local_cid);
 8018c7e:	88fb      	ldrh	r3, [r7, #6]
 8018c80:	4618      	mov	r0, r3
 8018c82:	f7ff ffb7 	bl	8018bf4 <l2cap_channel_item_by_cid>
 8018c86:	4603      	mov	r3, r0
}
 8018c88:	4618      	mov	r0, r3
 8018c8a:	3708      	adds	r7, #8
 8018c8c:	46bd      	mov	sp, r7
 8018c8e:	bd80      	pop	{r7, pc}

08018c90 <l2cap_get_channel_for_local_cid_and_handle>:

static l2cap_channel_t * l2cap_get_channel_for_local_cid_and_handle(uint16_t local_cid, hci_con_handle_t con_handle){
 8018c90:	b580      	push	{r7, lr}
 8018c92:	b084      	sub	sp, #16
 8018c94:	af00      	add	r7, sp, #0
 8018c96:	4603      	mov	r3, r0
 8018c98:	460a      	mov	r2, r1
 8018c9a:	80fb      	strh	r3, [r7, #6]
 8018c9c:	4613      	mov	r3, r2
 8018c9e:	80bb      	strh	r3, [r7, #4]
    if (local_cid < 0x40u) return NULL;
 8018ca0:	88fb      	ldrh	r3, [r7, #6]
 8018ca2:	2b3f      	cmp	r3, #63	; 0x3f
 8018ca4:	d801      	bhi.n	8018caa <l2cap_get_channel_for_local_cid_and_handle+0x1a>
 8018ca6:	2300      	movs	r3, #0
 8018ca8:	e011      	b.n	8018cce <l2cap_get_channel_for_local_cid_and_handle+0x3e>
    l2cap_channel_t * l2cap_channel = (l2cap_channel_t*) l2cap_channel_item_by_cid(local_cid);
 8018caa:	88fb      	ldrh	r3, [r7, #6]
 8018cac:	4618      	mov	r0, r3
 8018cae:	f7ff ffa1 	bl	8018bf4 <l2cap_channel_item_by_cid>
 8018cb2:	60f8      	str	r0, [r7, #12]
    if (l2cap_channel == NULL)  return NULL;
 8018cb4:	68fb      	ldr	r3, [r7, #12]
 8018cb6:	2b00      	cmp	r3, #0
 8018cb8:	d101      	bne.n	8018cbe <l2cap_get_channel_for_local_cid_and_handle+0x2e>
 8018cba:	2300      	movs	r3, #0
 8018cbc:	e007      	b.n	8018cce <l2cap_get_channel_for_local_cid_and_handle+0x3e>
    if (l2cap_channel->con_handle != con_handle) return NULL;
 8018cbe:	68fb      	ldr	r3, [r7, #12]
 8018cc0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8018cc2:	88ba      	ldrh	r2, [r7, #4]
 8018cc4:	429a      	cmp	r2, r3
 8018cc6:	d001      	beq.n	8018ccc <l2cap_get_channel_for_local_cid_and_handle+0x3c>
 8018cc8:	2300      	movs	r3, #0
 8018cca:	e000      	b.n	8018cce <l2cap_get_channel_for_local_cid_and_handle+0x3e>
    return l2cap_channel;
 8018ccc:	68fb      	ldr	r3, [r7, #12]
}
 8018cce:	4618      	mov	r0, r3
 8018cd0:	3710      	adds	r7, #16
 8018cd2:	46bd      	mov	sp, r7
 8018cd4:	bd80      	pop	{r7, pc}

08018cd6 <l2cap_is_dynamic_channel_type>:
    return 0;
}
#endif

#ifdef L2CAP_USES_CHANNELS
static int l2cap_is_dynamic_channel_type(l2cap_channel_type_t channel_type){
 8018cd6:	b480      	push	{r7}
 8018cd8:	b083      	sub	sp, #12
 8018cda:	af00      	add	r7, sp, #0
 8018cdc:	4603      	mov	r3, r0
 8018cde:	71fb      	strb	r3, [r7, #7]
    switch (channel_type){
 8018ce0:	79fb      	ldrb	r3, [r7, #7]
 8018ce2:	2b00      	cmp	r3, #0
 8018ce4:	d001      	beq.n	8018cea <l2cap_is_dynamic_channel_type+0x14>
 8018ce6:	2b02      	cmp	r3, #2
 8018ce8:	d101      	bne.n	8018cee <l2cap_is_dynamic_channel_type+0x18>
        case L2CAP_CHANNEL_TYPE_CLASSIC:
        case L2CAP_CHANNEL_TYPE_LE_DATA_CHANNEL:
            return 1;
 8018cea:	2301      	movs	r3, #1
 8018cec:	e000      	b.n	8018cf0 <l2cap_is_dynamic_channel_type+0x1a>
        default:
            return 0;
 8018cee:	2300      	movs	r3, #0
    }
}
 8018cf0:	4618      	mov	r0, r3
 8018cf2:	370c      	adds	r7, #12
 8018cf4:	46bd      	mov	sp, r7
 8018cf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018cfa:	4770      	bx	lr

08018cfc <l2cap_channel_for_rtx_timer>:
#endif

#ifdef ENABLE_CLASSIC
// RTX Timer only exist for dynamic channels
static l2cap_channel_t * l2cap_channel_for_rtx_timer(btstack_timer_source_t * ts){
 8018cfc:	b580      	push	{r7, lr}
 8018cfe:	b086      	sub	sp, #24
 8018d00:	af00      	add	r7, sp, #0
 8018d02:	6078      	str	r0, [r7, #4]
    btstack_linked_list_iterator_t it;    
    btstack_linked_list_iterator_init(&it, &l2cap_channels);
 8018d04:	f107 0308 	add.w	r3, r7, #8
 8018d08:	4913      	ldr	r1, [pc, #76]	; (8018d58 <l2cap_channel_for_rtx_timer+0x5c>)
 8018d0a:	4618      	mov	r0, r3
 8018d0c:	f7f5 fd1f 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 8018d10:	e015      	b.n	8018d3e <l2cap_channel_for_rtx_timer+0x42>
        l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 8018d12:	f107 0308 	add.w	r3, r7, #8
 8018d16:	4618      	mov	r0, r3
 8018d18:	f7f5 fd5c 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8018d1c:	6178      	str	r0, [r7, #20]
        if (!l2cap_is_dynamic_channel_type(channel->channel_type)) continue;
 8018d1e:	697b      	ldr	r3, [r7, #20]
 8018d20:	791b      	ldrb	r3, [r3, #4]
 8018d22:	4618      	mov	r0, r3
 8018d24:	f7ff ffd7 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 8018d28:	4603      	mov	r3, r0
 8018d2a:	2b00      	cmp	r3, #0
 8018d2c:	d100      	bne.n	8018d30 <l2cap_channel_for_rtx_timer+0x34>
 8018d2e:	e006      	b.n	8018d3e <l2cap_channel_for_rtx_timer+0x42>
        if (&channel->rtx == ts) {
 8018d30:	697b      	ldr	r3, [r7, #20]
 8018d32:	3310      	adds	r3, #16
 8018d34:	687a      	ldr	r2, [r7, #4]
 8018d36:	429a      	cmp	r2, r3
 8018d38:	d101      	bne.n	8018d3e <l2cap_channel_for_rtx_timer+0x42>
            return channel;
 8018d3a:	697b      	ldr	r3, [r7, #20]
 8018d3c:	e008      	b.n	8018d50 <l2cap_channel_for_rtx_timer+0x54>
    while (btstack_linked_list_iterator_has_next(&it)){
 8018d3e:	f107 0308 	add.w	r3, r7, #8
 8018d42:	4618      	mov	r0, r3
 8018d44:	f7f5 fd18 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8018d48:	4603      	mov	r3, r0
 8018d4a:	2b00      	cmp	r3, #0
 8018d4c:	d1e1      	bne.n	8018d12 <l2cap_channel_for_rtx_timer+0x16>
        }
    }
    return NULL;
 8018d4e:	2300      	movs	r3, #0
}
 8018d50:	4618      	mov	r0, r3
 8018d52:	3718      	adds	r7, #24
 8018d54:	46bd      	mov	sp, r7
 8018d56:	bd80      	pop	{r7, pc}
 8018d58:	20009eac 	.word	0x20009eac

08018d5c <l2cap_rtx_timeout>:

static void l2cap_rtx_timeout(btstack_timer_source_t * ts){
 8018d5c:	b580      	push	{r7, lr}
 8018d5e:	b086      	sub	sp, #24
 8018d60:	af02      	add	r7, sp, #8
 8018d62:	6078      	str	r0, [r7, #4]
    l2cap_channel_t * channel = l2cap_channel_for_rtx_timer(ts);
 8018d64:	6878      	ldr	r0, [r7, #4]
 8018d66:	f7ff ffc9 	bl	8018cfc <l2cap_channel_for_rtx_timer>
 8018d6a:	60f8      	str	r0, [r7, #12]
    if (!channel) return;
 8018d6c:	68fb      	ldr	r3, [r7, #12]
 8018d6e:	2b00      	cmp	r3, #0
 8018d70:	d015      	beq.n	8018d9e <l2cap_rtx_timeout+0x42>

    log_info("l2cap_rtx_timeout for local cid 0x%02x", channel->local_cid);
 8018d72:	68fb      	ldr	r3, [r7, #12]
 8018d74:	88db      	ldrh	r3, [r3, #6]
 8018d76:	9300      	str	r3, [sp, #0]
 8018d78:	f240 43ca 	movw	r3, #1226	; 0x4ca
 8018d7c:	4a0a      	ldr	r2, [pc, #40]	; (8018da8 <l2cap_rtx_timeout+0x4c>)
 8018d7e:	490b      	ldr	r1, [pc, #44]	; (8018dac <l2cap_rtx_timeout+0x50>)
 8018d80:	2001      	movs	r0, #1
 8018d82:	f7fe fb5d 	bl	8017440 <hci_dump_log>

    // "When terminating the channel, it is not necessary to send a L2CAP_DisconnectReq
    //  and enter WAIT_DISCONNECT state. Channels can be transitioned directly to the CLOSED state."
    // notify client
    l2cap_handle_channel_open_failed(channel, L2CAP_CONNECTION_RESPONSE_RESULT_RTX_TIMEOUT);
 8018d86:	2169      	movs	r1, #105	; 0x69
 8018d88:	68f8      	ldr	r0, [r7, #12]
 8018d8a:	f7ff ff07 	bl	8018b9c <l2cap_handle_channel_open_failed>

    // discard channel
    btstack_linked_list_remove(&l2cap_channels, (btstack_linked_item_t *) channel);
 8018d8e:	68f9      	ldr	r1, [r7, #12]
 8018d90:	4807      	ldr	r0, [pc, #28]	; (8018db0 <l2cap_rtx_timeout+0x54>)
 8018d92:	f7f5 fc94 	bl	800e6be <btstack_linked_list_remove>
    l2cap_free_channel_entry(channel);
 8018d96:	68f8      	ldr	r0, [r7, #12]
 8018d98:	f001 faaa 	bl	801a2f0 <l2cap_free_channel_entry>
 8018d9c:	e000      	b.n	8018da0 <l2cap_rtx_timeout+0x44>
    if (!channel) return;
 8018d9e:	bf00      	nop
}
 8018da0:	3710      	adds	r7, #16
 8018da2:	46bd      	mov	sp, r7
 8018da4:	bd80      	pop	{r7, pc}
 8018da6:	bf00      	nop
 8018da8:	0802b1dc 	.word	0x0802b1dc
 8018dac:	0802b9d4 	.word	0x0802b9d4
 8018db0:	20009eac 	.word	0x20009eac

08018db4 <l2cap_stop_rtx>:

#endif

#ifdef L2CAP_USES_CHANNELS
static void l2cap_stop_rtx(l2cap_channel_t * channel){
 8018db4:	b580      	push	{r7, lr}
 8018db6:	b084      	sub	sp, #16
 8018db8:	af02      	add	r7, sp, #8
 8018dba:	6078      	str	r0, [r7, #4]
    log_info("l2cap_stop_rtx for local cid 0x%02x", channel->local_cid);
 8018dbc:	687b      	ldr	r3, [r7, #4]
 8018dbe:	88db      	ldrh	r3, [r3, #6]
 8018dc0:	9300      	str	r3, [sp, #0]
 8018dc2:	f240 43da 	movw	r3, #1242	; 0x4da
 8018dc6:	4a07      	ldr	r2, [pc, #28]	; (8018de4 <l2cap_stop_rtx+0x30>)
 8018dc8:	4907      	ldr	r1, [pc, #28]	; (8018de8 <l2cap_stop_rtx+0x34>)
 8018dca:	2001      	movs	r0, #1
 8018dcc:	f7fe fb38 	bl	8017440 <hci_dump_log>
    btstack_run_loop_remove_timer(&channel->rtx);
 8018dd0:	687b      	ldr	r3, [r7, #4]
 8018dd2:	3310      	adds	r3, #16
 8018dd4:	4618      	mov	r0, r3
 8018dd6:	f7f5 ff79 	bl	800eccc <btstack_run_loop_remove_timer>
}
 8018dda:	bf00      	nop
 8018ddc:	3708      	adds	r7, #8
 8018dde:	46bd      	mov	sp, r7
 8018de0:	bd80      	pop	{r7, pc}
 8018de2:	bf00      	nop
 8018de4:	0802b1dc 	.word	0x0802b1dc
 8018de8:	0802ba04 	.word	0x0802ba04

08018dec <l2cap_start_rtx>:
#endif

#ifdef ENABLE_CLASSIC

static void l2cap_start_rtx(l2cap_channel_t * channel){
 8018dec:	b580      	push	{r7, lr}
 8018dee:	b084      	sub	sp, #16
 8018df0:	af02      	add	r7, sp, #8
 8018df2:	6078      	str	r0, [r7, #4]
    l2cap_stop_rtx(channel);
 8018df4:	6878      	ldr	r0, [r7, #4]
 8018df6:	f7ff ffdd 	bl	8018db4 <l2cap_stop_rtx>
    log_info("l2cap_start_rtx for local cid 0x%02x", channel->local_cid);
 8018dfa:	687b      	ldr	r3, [r7, #4]
 8018dfc:	88db      	ldrh	r3, [r3, #6]
 8018dfe:	9300      	str	r3, [sp, #0]
 8018e00:	f240 43e3 	movw	r3, #1251	; 0x4e3
 8018e04:	4a0d      	ldr	r2, [pc, #52]	; (8018e3c <l2cap_start_rtx+0x50>)
 8018e06:	490e      	ldr	r1, [pc, #56]	; (8018e40 <l2cap_start_rtx+0x54>)
 8018e08:	2001      	movs	r0, #1
 8018e0a:	f7fe fb19 	bl	8017440 <hci_dump_log>
    btstack_run_loop_set_timer_handler(&channel->rtx, l2cap_rtx_timeout);
 8018e0e:	687b      	ldr	r3, [r7, #4]
 8018e10:	3310      	adds	r3, #16
 8018e12:	490c      	ldr	r1, [pc, #48]	; (8018e44 <l2cap_start_rtx+0x58>)
 8018e14:	4618      	mov	r0, r3
 8018e16:	f7f5 feb9 	bl	800eb8c <btstack_run_loop_set_timer_handler>
    btstack_run_loop_set_timer(&channel->rtx, L2CAP_RTX_TIMEOUT_MS);
 8018e1a:	687b      	ldr	r3, [r7, #4]
 8018e1c:	3310      	adds	r3, #16
 8018e1e:	f242 7110 	movw	r1, #10000	; 0x2710
 8018e22:	4618      	mov	r0, r3
 8018e24:	f7f5 ff16 	bl	800ec54 <btstack_run_loop_set_timer>
    btstack_run_loop_add_timer(&channel->rtx);
 8018e28:	687b      	ldr	r3, [r7, #4]
 8018e2a:	3310      	adds	r3, #16
 8018e2c:	4618      	mov	r0, r3
 8018e2e:	f7f5 ff3d 	bl	800ecac <btstack_run_loop_add_timer>
}
 8018e32:	bf00      	nop
 8018e34:	3708      	adds	r7, #8
 8018e36:	46bd      	mov	sp, r7
 8018e38:	bd80      	pop	{r7, pc}
 8018e3a:	bf00      	nop
 8018e3c:	0802b1dc 	.word	0x0802b1dc
 8018e40:	0802ba30 	.word	0x0802ba30
 8018e44:	08018d5d 	.word	0x08018d5d

08018e48 <l2cap_start_ertx>:

static void l2cap_start_ertx(l2cap_channel_t * channel){
 8018e48:	b580      	push	{r7, lr}
 8018e4a:	b084      	sub	sp, #16
 8018e4c:	af02      	add	r7, sp, #8
 8018e4e:	6078      	str	r0, [r7, #4]
    log_info("l2cap_start_ertx for local cid 0x%02x", channel->local_cid);
 8018e50:	687b      	ldr	r3, [r7, #4]
 8018e52:	88db      	ldrh	r3, [r3, #6]
 8018e54:	9300      	str	r3, [sp, #0]
 8018e56:	f240 43ea 	movw	r3, #1258	; 0x4ea
 8018e5a:	4a0e      	ldr	r2, [pc, #56]	; (8018e94 <l2cap_start_ertx+0x4c>)
 8018e5c:	490e      	ldr	r1, [pc, #56]	; (8018e98 <l2cap_start_ertx+0x50>)
 8018e5e:	2001      	movs	r0, #1
 8018e60:	f7fe faee 	bl	8017440 <hci_dump_log>
    l2cap_stop_rtx(channel);
 8018e64:	6878      	ldr	r0, [r7, #4]
 8018e66:	f7ff ffa5 	bl	8018db4 <l2cap_stop_rtx>
    btstack_run_loop_set_timer_handler(&channel->rtx, l2cap_rtx_timeout);
 8018e6a:	687b      	ldr	r3, [r7, #4]
 8018e6c:	3310      	adds	r3, #16
 8018e6e:	490b      	ldr	r1, [pc, #44]	; (8018e9c <l2cap_start_ertx+0x54>)
 8018e70:	4618      	mov	r0, r3
 8018e72:	f7f5 fe8b 	bl	800eb8c <btstack_run_loop_set_timer_handler>
    btstack_run_loop_set_timer(&channel->rtx, L2CAP_ERTX_TIMEOUT_MS);
 8018e76:	687b      	ldr	r3, [r7, #4]
 8018e78:	3310      	adds	r3, #16
 8018e7a:	4909      	ldr	r1, [pc, #36]	; (8018ea0 <l2cap_start_ertx+0x58>)
 8018e7c:	4618      	mov	r0, r3
 8018e7e:	f7f5 fee9 	bl	800ec54 <btstack_run_loop_set_timer>
    btstack_run_loop_add_timer(&channel->rtx);
 8018e82:	687b      	ldr	r3, [r7, #4]
 8018e84:	3310      	adds	r3, #16
 8018e86:	4618      	mov	r0, r3
 8018e88:	f7f5 ff10 	bl	800ecac <btstack_run_loop_add_timer>
}
 8018e8c:	bf00      	nop
 8018e8e:	3708      	adds	r7, #8
 8018e90:	46bd      	mov	sp, r7
 8018e92:	bd80      	pop	{r7, pc}
 8018e94:	0802b1dc 	.word	0x0802b1dc
 8018e98:	0802ba5c 	.word	0x0802ba5c
 8018e9c:	08018d5d 	.word	0x08018d5d
 8018ea0:	0001d4c0 	.word	0x0001d4c0

08018ea4 <l2cap_send_signaling_packet>:

static int l2cap_security_level_0_allowed_for_PSM(uint16_t psm){
    return (psm == BLUETOOTH_PSM_SDP) && (!require_security_level2_for_outgoing_sdp);
}

static int l2cap_send_signaling_packet(hci_con_handle_t handle, L2CAP_SIGNALING_COMMANDS cmd, int identifier, ...){
 8018ea4:	b40c      	push	{r2, r3}
 8018ea6:	b580      	push	{r7, lr}
 8018ea8:	b088      	sub	sp, #32
 8018eaa:	af02      	add	r7, sp, #8
 8018eac:	4603      	mov	r3, r0
 8018eae:	460a      	mov	r2, r1
 8018eb0:	80fb      	strh	r3, [r7, #6]
 8018eb2:	4613      	mov	r3, r2
 8018eb4:	717b      	strb	r3, [r7, #5]
    if (!hci_can_send_acl_packet_now(handle)){
 8018eb6:	88fb      	ldrh	r3, [r7, #6]
 8018eb8:	4618      	mov	r0, r3
 8018eba:	f7f7 f891 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8018ebe:	4603      	mov	r3, r0
 8018ec0:	2b00      	cmp	r3, #0
 8018ec2:	d108      	bne.n	8018ed6 <l2cap_send_signaling_packet+0x32>
        log_info("l2cap_send_signaling_packet, cannot send");
 8018ec4:	f240 43fb 	movw	r3, #1275	; 0x4fb
 8018ec8:	4a13      	ldr	r2, [pc, #76]	; (8018f18 <l2cap_send_signaling_packet+0x74>)
 8018eca:	4914      	ldr	r1, [pc, #80]	; (8018f1c <l2cap_send_signaling_packet+0x78>)
 8018ecc:	2001      	movs	r0, #1
 8018ece:	f7fe fab7 	bl	8017440 <hci_dump_log>
        return BTSTACK_ACL_BUFFERS_FULL;
 8018ed2:	2357      	movs	r3, #87	; 0x57
 8018ed4:	e018      	b.n	8018f08 <l2cap_send_signaling_packet+0x64>
    }
    
    // log_info("l2cap_send_signaling_packet type %u", cmd);
    hci_reserve_packet_buffer();
 8018ed6:	f7f7 f8ed 	bl	80100b4 <hci_reserve_packet_buffer>
    uint8_t *acl_buffer = hci_get_outgoing_packet_buffer();
 8018eda:	f7f7 fc5b 	bl	8010794 <hci_get_outgoing_packet_buffer>
 8018ede:	6178      	str	r0, [r7, #20]
    va_list argptr;
    va_start(argptr, identifier);
 8018ee0:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8018ee4:	60fb      	str	r3, [r7, #12]
    uint16_t len = l2cap_create_signaling_classic(acl_buffer, handle, cmd, identifier, argptr);
 8018ee6:	6a3b      	ldr	r3, [r7, #32]
 8018ee8:	b2d8      	uxtb	r0, r3
 8018eea:	797a      	ldrb	r2, [r7, #5]
 8018eec:	88f9      	ldrh	r1, [r7, #6]
 8018eee:	68fb      	ldr	r3, [r7, #12]
 8018ef0:	9300      	str	r3, [sp, #0]
 8018ef2:	4603      	mov	r3, r0
 8018ef4:	6978      	ldr	r0, [r7, #20]
 8018ef6:	f004 f929 	bl	801d14c <l2cap_create_signaling_classic>
 8018efa:	4603      	mov	r3, r0
 8018efc:	827b      	strh	r3, [r7, #18]
    va_end(argptr);
    // log_info("l2cap_send_signaling_packet con %u!", handle);
    return hci_send_acl_packet_buffer(len);
 8018efe:	8a7b      	ldrh	r3, [r7, #18]
 8018f00:	4618      	mov	r0, r3
 8018f02:	f7f7 f9d9 	bl	80102b8 <hci_send_acl_packet_buffer>
 8018f06:	4603      	mov	r3, r0
}
 8018f08:	4618      	mov	r0, r3
 8018f0a:	3718      	adds	r7, #24
 8018f0c:	46bd      	mov	sp, r7
 8018f0e:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8018f12:	b002      	add	sp, #8
 8018f14:	4770      	bx	lr
 8018f16:	bf00      	nop
 8018f18:	0802b1dc 	.word	0x0802b1dc
 8018f1c:	0802ba8c 	.word	0x0802ba8c

08018f20 <l2cap_send_prepared>:

// assumption - only on Classic connections
// cannot be used for L2CAP ERTM
int l2cap_send_prepared(uint16_t local_cid, uint16_t len){
 8018f20:	b580      	push	{r7, lr}
 8018f22:	b088      	sub	sp, #32
 8018f24:	af02      	add	r7, sp, #8
 8018f26:	4603      	mov	r3, r0
 8018f28:	460a      	mov	r2, r1
 8018f2a:	80fb      	strh	r3, [r7, #6]
 8018f2c:	4613      	mov	r3, r2
 8018f2e:	80bb      	strh	r3, [r7, #4]
    
    if (!hci_is_packet_buffer_reserved()){
 8018f30:	f7f7 f8b2 	bl	8010098 <hci_is_packet_buffer_reserved>
 8018f34:	4603      	mov	r3, r0
 8018f36:	2b00      	cmp	r3, #0
 8018f38:	d108      	bne.n	8018f4c <l2cap_send_prepared+0x2c>
        log_error("l2cap_send_prepared called without reserving packet first");
 8018f3a:	f240 530f 	movw	r3, #1295	; 0x50f
 8018f3e:	4a41      	ldr	r2, [pc, #260]	; (8019044 <l2cap_send_prepared+0x124>)
 8018f40:	4941      	ldr	r1, [pc, #260]	; (8019048 <l2cap_send_prepared+0x128>)
 8018f42:	2002      	movs	r0, #2
 8018f44:	f7fe fa7c 	bl	8017440 <hci_dump_log>
        return BTSTACK_ACL_BUFFERS_FULL;
 8018f48:	2357      	movs	r3, #87	; 0x57
 8018f4a:	e077      	b.n	801903c <l2cap_send_prepared+0x11c>
    }

    l2cap_channel_t * channel = l2cap_get_channel_for_local_cid(local_cid);
 8018f4c:	88fb      	ldrh	r3, [r7, #6]
 8018f4e:	4618      	mov	r0, r3
 8018f50:	f7ff fe8b 	bl	8018c6a <l2cap_get_channel_for_local_cid>
 8018f54:	6138      	str	r0, [r7, #16]
    if (!channel) {
 8018f56:	693b      	ldr	r3, [r7, #16]
 8018f58:	2b00      	cmp	r3, #0
 8018f5a:	d10b      	bne.n	8018f74 <l2cap_send_prepared+0x54>
        log_error("l2cap_send_prepared no channel for cid 0x%02x", local_cid);
 8018f5c:	88fb      	ldrh	r3, [r7, #6]
 8018f5e:	9300      	str	r3, [sp, #0]
 8018f60:	f240 5315 	movw	r3, #1301	; 0x515
 8018f64:	4a37      	ldr	r2, [pc, #220]	; (8019044 <l2cap_send_prepared+0x124>)
 8018f66:	4939      	ldr	r1, [pc, #228]	; (801904c <l2cap_send_prepared+0x12c>)
 8018f68:	2002      	movs	r0, #2
 8018f6a:	f7fe fa69 	bl	8017440 <hci_dump_log>
        return -1;   // TODO: define error
 8018f6e:	f04f 33ff 	mov.w	r3, #4294967295
 8018f72:	e063      	b.n	801903c <l2cap_send_prepared+0x11c>
    }

    if (!hci_can_send_prepared_acl_packet_now(channel->con_handle)){
 8018f74:	693b      	ldr	r3, [r7, #16]
 8018f76:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8018f78:	4618      	mov	r0, r3
 8018f7a:	f7f7 f815 	bl	800ffa8 <hci_can_send_prepared_acl_packet_now>
 8018f7e:	4603      	mov	r3, r0
 8018f80:	2b00      	cmp	r3, #0
 8018f82:	d10a      	bne.n	8018f9a <l2cap_send_prepared+0x7a>
        log_info("l2cap_send_prepared cid 0x%02x, cannot send", local_cid);
 8018f84:	88fb      	ldrh	r3, [r7, #6]
 8018f86:	9300      	str	r3, [sp, #0]
 8018f88:	f240 531a 	movw	r3, #1306	; 0x51a
 8018f8c:	4a2d      	ldr	r2, [pc, #180]	; (8019044 <l2cap_send_prepared+0x124>)
 8018f8e:	4930      	ldr	r1, [pc, #192]	; (8019050 <l2cap_send_prepared+0x130>)
 8018f90:	2001      	movs	r0, #1
 8018f92:	f7fe fa55 	bl	8017440 <hci_dump_log>
        return BTSTACK_ACL_BUFFERS_FULL;
 8018f96:	2357      	movs	r3, #87	; 0x57
 8018f98:	e050      	b.n	801903c <l2cap_send_prepared+0x11c>
    }
    
    log_debug("l2cap_send_prepared cid 0x%02x, handle %u, 1 credit used", local_cid, channel->con_handle);
    
    int fcs_size = 0;
 8018f9a:	2300      	movs	r3, #0
 8018f9c:	617b      	str	r3, [r7, #20]

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    if (channel->mode == L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION && channel->fcs_option){
 8018f9e:	693b      	ldr	r3, [r7, #16]
 8018fa0:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 8018fa4:	2b03      	cmp	r3, #3
 8018fa6:	d106      	bne.n	8018fb6 <l2cap_send_prepared+0x96>
 8018fa8:	693b      	ldr	r3, [r7, #16]
 8018faa:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 8018fae:	2b00      	cmp	r3, #0
 8018fb0:	d001      	beq.n	8018fb6 <l2cap_send_prepared+0x96>
        fcs_size = 2;
 8018fb2:	2302      	movs	r3, #2
 8018fb4:	617b      	str	r3, [r7, #20]
    }
#endif

    // set non-flushable packet boundary flag if supported on Controller
    uint8_t *acl_buffer = hci_get_outgoing_packet_buffer();
 8018fb6:	f7f7 fbed 	bl	8010794 <hci_get_outgoing_packet_buffer>
 8018fba:	60f8      	str	r0, [r7, #12]
    uint8_t packet_boundary_flag = hci_non_flushable_packet_boundary_flag_supported() ? 0x00 : 0x02;
 8018fbc:	f7f7 fc16 	bl	80107ec <hci_non_flushable_packet_boundary_flag_supported>
 8018fc0:	4603      	mov	r3, r0
 8018fc2:	2b00      	cmp	r3, #0
 8018fc4:	d001      	beq.n	8018fca <l2cap_send_prepared+0xaa>
 8018fc6:	2300      	movs	r3, #0
 8018fc8:	e000      	b.n	8018fcc <l2cap_send_prepared+0xac>
 8018fca:	2302      	movs	r3, #2
 8018fcc:	72fb      	strb	r3, [r7, #11]
    l2cap_setup_header(acl_buffer, channel->con_handle, packet_boundary_flag, channel->remote_cid, len + fcs_size);
 8018fce:	693b      	ldr	r3, [r7, #16]
 8018fd0:	8c99      	ldrh	r1, [r3, #36]	; 0x24
 8018fd2:	693b      	ldr	r3, [r7, #16]
 8018fd4:	8e18      	ldrh	r0, [r3, #48]	; 0x30
 8018fd6:	697b      	ldr	r3, [r7, #20]
 8018fd8:	b29a      	uxth	r2, r3
 8018fda:	88bb      	ldrh	r3, [r7, #4]
 8018fdc:	4413      	add	r3, r2
 8018fde:	b29b      	uxth	r3, r3
 8018fe0:	7afa      	ldrb	r2, [r7, #11]
 8018fe2:	9300      	str	r3, [sp, #0]
 8018fe4:	4603      	mov	r3, r0
 8018fe6:	68f8      	ldr	r0, [r7, #12]
 8018fe8:	f7ff fb90 	bl	801870c <l2cap_setup_header>

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    if (fcs_size){
 8018fec:	697b      	ldr	r3, [r7, #20]
 8018fee:	2b00      	cmp	r3, #0
 8018ff0:	d01b      	beq.n	801902a <l2cap_send_prepared+0x10a>
        // calculate FCS over l2cap data
        uint16_t fcs = crc16_calc(acl_buffer + 4, 4 + len);
 8018ff2:	68fb      	ldr	r3, [r7, #12]
 8018ff4:	1d1a      	adds	r2, r3, #4
 8018ff6:	88bb      	ldrh	r3, [r7, #4]
 8018ff8:	3304      	adds	r3, #4
 8018ffa:	b29b      	uxth	r3, r3
 8018ffc:	4619      	mov	r1, r3
 8018ffe:	4610      	mov	r0, r2
 8019000:	f7fe fd00 	bl	8017a04 <crc16_calc>
 8019004:	4603      	mov	r3, r0
 8019006:	813b      	strh	r3, [r7, #8]
        log_info("I-Frame: fcs 0x%04x", fcs);
 8019008:	893b      	ldrh	r3, [r7, #8]
 801900a:	9300      	str	r3, [sp, #0]
 801900c:	f240 5331 	movw	r3, #1329	; 0x531
 8019010:	4a0c      	ldr	r2, [pc, #48]	; (8019044 <l2cap_send_prepared+0x124>)
 8019012:	4910      	ldr	r1, [pc, #64]	; (8019054 <l2cap_send_prepared+0x134>)
 8019014:	2001      	movs	r0, #1
 8019016:	f7fe fa13 	bl	8017440 <hci_dump_log>
        little_endian_store_16(acl_buffer, 8 + len, fcs);
 801901a:	88bb      	ldrh	r3, [r7, #4]
 801901c:	3308      	adds	r3, #8
 801901e:	b29b      	uxth	r3, r3
 8019020:	893a      	ldrh	r2, [r7, #8]
 8019022:	4619      	mov	r1, r3
 8019024:	68f8      	ldr	r0, [r7, #12]
 8019026:	f7f5 ff1e 	bl	800ee66 <little_endian_store_16>
    }
#endif

    // send
    return hci_send_acl_packet_buffer(len+8+fcs_size);
 801902a:	88bb      	ldrh	r3, [r7, #4]
 801902c:	f103 0208 	add.w	r2, r3, #8
 8019030:	697b      	ldr	r3, [r7, #20]
 8019032:	4413      	add	r3, r2
 8019034:	4618      	mov	r0, r3
 8019036:	f7f7 f93f 	bl	80102b8 <hci_send_acl_packet_buffer>
 801903a:	4603      	mov	r3, r0
}
 801903c:	4618      	mov	r0, r3
 801903e:	3718      	adds	r7, #24
 8019040:	46bd      	mov	sp, r7
 8019042:	bd80      	pop	{r7, pc}
 8019044:	0802b1dc 	.word	0x0802b1dc
 8019048:	0802babc 	.word	0x0802babc
 801904c:	0802bb00 	.word	0x0802bb00
 8019050:	0802bb38 	.word	0x0802bb38
 8019054:	0802bb6c 	.word	0x0802bb6c

08019058 <channelStateVarSetFlag>:

int l2cap_send_echo_request(hci_con_handle_t con_handle, uint8_t *data, uint16_t len){
    return l2cap_send_signaling_packet(con_handle, ECHO_REQUEST, 0x77, len, data);
}

static inline void channelStateVarSetFlag(l2cap_channel_t *channel, L2CAP_CHANNEL_STATE_VAR flag){
 8019058:	b480      	push	{r7}
 801905a:	b083      	sub	sp, #12
 801905c:	af00      	add	r7, sp, #0
 801905e:	6078      	str	r0, [r7, #4]
 8019060:	460b      	mov	r3, r1
 8019062:	807b      	strh	r3, [r7, #2]
    channel->state_var = (L2CAP_CHANNEL_STATE_VAR) (channel->state_var | flag);
 8019064:	687b      	ldr	r3, [r7, #4]
 8019066:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 8019068:	887b      	ldrh	r3, [r7, #2]
 801906a:	4313      	orrs	r3, r2
 801906c:	b29a      	uxth	r2, r3
 801906e:	687b      	ldr	r3, [r7, #4]
 8019070:	845a      	strh	r2, [r3, #34]	; 0x22
}
 8019072:	bf00      	nop
 8019074:	370c      	adds	r7, #12
 8019076:	46bd      	mov	sp, r7
 8019078:	f85d 7b04 	ldr.w	r7, [sp], #4
 801907c:	4770      	bx	lr

0801907e <channelStateVarClearFlag>:

static inline void channelStateVarClearFlag(l2cap_channel_t *channel, L2CAP_CHANNEL_STATE_VAR flag){
 801907e:	b480      	push	{r7}
 8019080:	b083      	sub	sp, #12
 8019082:	af00      	add	r7, sp, #0
 8019084:	6078      	str	r0, [r7, #4]
 8019086:	460b      	mov	r3, r1
 8019088:	807b      	strh	r3, [r7, #2]
    channel->state_var = (L2CAP_CHANNEL_STATE_VAR) (channel->state_var & ~flag);
 801908a:	687b      	ldr	r3, [r7, #4]
 801908c:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801908e:	b21a      	sxth	r2, r3
 8019090:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8019094:	43db      	mvns	r3, r3
 8019096:	b21b      	sxth	r3, r3
 8019098:	4013      	ands	r3, r2
 801909a:	b21b      	sxth	r3, r3
 801909c:	b29a      	uxth	r2, r3
 801909e:	687b      	ldr	r3, [r7, #4]
 80190a0:	845a      	strh	r2, [r3, #34]	; 0x22
}
 80190a2:	bf00      	nop
 80190a4:	370c      	adds	r7, #12
 80190a6:	46bd      	mov	sp, r7
 80190a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80190ac:	4770      	bx	lr
	...

080190b0 <l2cap_send_le_signaling_packet>:
#endif


#ifdef ENABLE_BLE
static int l2cap_send_le_signaling_packet(hci_con_handle_t handle, L2CAP_SIGNALING_COMMANDS cmd, int identifier, ...){
 80190b0:	b40c      	push	{r2, r3}
 80190b2:	b580      	push	{r7, lr}
 80190b4:	b088      	sub	sp, #32
 80190b6:	af02      	add	r7, sp, #8
 80190b8:	4603      	mov	r3, r0
 80190ba:	460a      	mov	r2, r1
 80190bc:	80fb      	strh	r3, [r7, #6]
 80190be:	4613      	mov	r3, r2
 80190c0:	717b      	strb	r3, [r7, #5]

    if (!hci_can_send_acl_packet_now(handle)){
 80190c2:	88fb      	ldrh	r3, [r7, #6]
 80190c4:	4618      	mov	r0, r3
 80190c6:	f7f6 ff8b 	bl	800ffe0 <hci_can_send_acl_packet_now>
 80190ca:	4603      	mov	r3, r0
 80190cc:	2b00      	cmp	r3, #0
 80190ce:	d108      	bne.n	80190e2 <l2cap_send_le_signaling_packet+0x32>
        log_info("l2cap_send_le_signaling_packet, cannot send");
 80190d0:	f240 536b 	movw	r3, #1387	; 0x56b
 80190d4:	4a13      	ldr	r2, [pc, #76]	; (8019124 <l2cap_send_le_signaling_packet+0x74>)
 80190d6:	4914      	ldr	r1, [pc, #80]	; (8019128 <l2cap_send_le_signaling_packet+0x78>)
 80190d8:	2001      	movs	r0, #1
 80190da:	f7fe f9b1 	bl	8017440 <hci_dump_log>
        return BTSTACK_ACL_BUFFERS_FULL;
 80190de:	2357      	movs	r3, #87	; 0x57
 80190e0:	e018      	b.n	8019114 <l2cap_send_le_signaling_packet+0x64>
    }
    
    // log_info("l2cap_send_le_signaling_packet type %u", cmd);
    hci_reserve_packet_buffer();
 80190e2:	f7f6 ffe7 	bl	80100b4 <hci_reserve_packet_buffer>
    uint8_t *acl_buffer = hci_get_outgoing_packet_buffer();
 80190e6:	f7f7 fb55 	bl	8010794 <hci_get_outgoing_packet_buffer>
 80190ea:	6178      	str	r0, [r7, #20]
    va_list argptr;
    va_start(argptr, identifier);
 80190ec:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80190f0:	60fb      	str	r3, [r7, #12]
    uint16_t len = l2cap_create_signaling_le(acl_buffer, handle, cmd, identifier, argptr);
 80190f2:	6a3b      	ldr	r3, [r7, #32]
 80190f4:	b2d8      	uxtb	r0, r3
 80190f6:	797a      	ldrb	r2, [r7, #5]
 80190f8:	88f9      	ldrh	r1, [r7, #6]
 80190fa:	68fb      	ldr	r3, [r7, #12]
 80190fc:	9300      	str	r3, [sp, #0]
 80190fe:	4603      	mov	r3, r0
 8019100:	6978      	ldr	r0, [r7, #20]
 8019102:	f004 f841 	bl	801d188 <l2cap_create_signaling_le>
 8019106:	4603      	mov	r3, r0
 8019108:	827b      	strh	r3, [r7, #18]
    va_end(argptr);
    // log_info("l2cap_send_le_signaling_packet con %u!", handle);
    return hci_send_acl_packet_buffer(len);
 801910a:	8a7b      	ldrh	r3, [r7, #18]
 801910c:	4618      	mov	r0, r3
 801910e:	f7f7 f8d3 	bl	80102b8 <hci_send_acl_packet_buffer>
 8019112:	4603      	mov	r3, r0
}
 8019114:	4618      	mov	r0, r3
 8019116:	3718      	adds	r7, #24
 8019118:	46bd      	mov	sp, r7
 801911a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 801911e:	b002      	add	sp, #8
 8019120:	4770      	bx	lr
 8019122:	bf00      	nop
 8019124:	0802b1dc 	.word	0x0802b1dc
 8019128:	0802bbf4 	.word	0x0802bbf4

0801912c <l2cap_max_mtu>:
#endif

uint16_t l2cap_max_mtu(void){
 801912c:	b480      	push	{r7}
 801912e:	af00      	add	r7, sp, #0
    return HCI_ACL_PAYLOAD_SIZE - L2CAP_HEADER_SIZE;
 8019130:	f240 639b 	movw	r3, #1691	; 0x69b
}
 8019134:	4618      	mov	r0, r3
 8019136:	46bd      	mov	sp, r7
 8019138:	f85d 7b04 	ldr.w	r7, [sp], #4
 801913c:	4770      	bx	lr
	...

08019140 <l2cap_max_le_mtu>:

#ifdef ENABLE_BLE
uint16_t l2cap_max_le_mtu(void){
 8019140:	b580      	push	{r7, lr}
 8019142:	af00      	add	r7, sp, #0
    if (l2cap_le_custom_max_mtu != 0u) return l2cap_le_custom_max_mtu;
 8019144:	4b05      	ldr	r3, [pc, #20]	; (801915c <l2cap_max_le_mtu+0x1c>)
 8019146:	881b      	ldrh	r3, [r3, #0]
 8019148:	2b00      	cmp	r3, #0
 801914a:	d002      	beq.n	8019152 <l2cap_max_le_mtu+0x12>
 801914c:	4b03      	ldr	r3, [pc, #12]	; (801915c <l2cap_max_le_mtu+0x1c>)
 801914e:	881b      	ldrh	r3, [r3, #0]
 8019150:	e002      	b.n	8019158 <l2cap_max_le_mtu+0x18>
    return l2cap_max_mtu();
 8019152:	f7ff ffeb 	bl	801912c <l2cap_max_mtu>
 8019156:	4603      	mov	r3, r0
}
 8019158:	4618      	mov	r0, r3
 801915a:	bd80      	pop	{r7, pc}
 801915c:	20009edc 	.word	0x20009edc

08019160 <l2cap_setup_options_mtu>:
}
#endif

#ifdef ENABLE_CLASSIC

static uint16_t l2cap_setup_options_mtu(uint8_t * config_options, uint16_t mtu){
 8019160:	b580      	push	{r7, lr}
 8019162:	b082      	sub	sp, #8
 8019164:	af00      	add	r7, sp, #0
 8019166:	6078      	str	r0, [r7, #4]
 8019168:	460b      	mov	r3, r1
 801916a:	807b      	strh	r3, [r7, #2]
    config_options[0] = L2CAP_CONFIG_OPTION_TYPE_MAX_TRANSMISSION_UNIT; // MTU
 801916c:	687b      	ldr	r3, [r7, #4]
 801916e:	2201      	movs	r2, #1
 8019170:	701a      	strb	r2, [r3, #0]
    config_options[1] = 2; // len param
 8019172:	687b      	ldr	r3, [r7, #4]
 8019174:	3301      	adds	r3, #1
 8019176:	2202      	movs	r2, #2
 8019178:	701a      	strb	r2, [r3, #0]
    little_endian_store_16(config_options, 2, mtu);
 801917a:	887b      	ldrh	r3, [r7, #2]
 801917c:	461a      	mov	r2, r3
 801917e:	2102      	movs	r1, #2
 8019180:	6878      	ldr	r0, [r7, #4]
 8019182:	f7f5 fe70 	bl	800ee66 <little_endian_store_16>
    return 4;
 8019186:	2304      	movs	r3, #4
}
 8019188:	4618      	mov	r0, r3
 801918a:	3708      	adds	r7, #8
 801918c:	46bd      	mov	sp, r7
 801918e:	bd80      	pop	{r7, pc}

08019190 <l2cap_ertm_mode>:

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
static int l2cap_ertm_mode(l2cap_channel_t * channel){
 8019190:	b580      	push	{r7, lr}
 8019192:	b084      	sub	sp, #16
 8019194:	af00      	add	r7, sp, #0
 8019196:	6078      	str	r0, [r7, #4]
    hci_connection_t * connection = hci_connection_for_handle(channel->con_handle);
 8019198:	687b      	ldr	r3, [r7, #4]
 801919a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801919c:	4618      	mov	r0, r3
 801919e:	f7f6 fb91 	bl	800f8c4 <hci_connection_for_handle>
 80191a2:	60f8      	str	r0, [r7, #12]
    return ((connection->l2cap_state.information_state == L2CAP_INFORMATION_STATE_DONE) 
 80191a4:	68fb      	ldr	r3, [r7, #12]
 80191a6:	f893 3e24 	ldrb.w	r3, [r3, #3620]	; 0xe24
        &&  (connection->l2cap_state.extended_feature_mask & 0x08));
 80191aa:	2b03      	cmp	r3, #3
 80191ac:	d108      	bne.n	80191c0 <l2cap_ertm_mode+0x30>
 80191ae:	68fb      	ldr	r3, [r7, #12]
 80191b0:	f8b3 3e26 	ldrh.w	r3, [r3, #3622]	; 0xe26
 80191b4:	f003 0308 	and.w	r3, r3, #8
 80191b8:	2b00      	cmp	r3, #0
 80191ba:	d001      	beq.n	80191c0 <l2cap_ertm_mode+0x30>
 80191bc:	2301      	movs	r3, #1
 80191be:	e000      	b.n	80191c2 <l2cap_ertm_mode+0x32>
 80191c0:	2300      	movs	r3, #0
}
 80191c2:	4618      	mov	r0, r3
 80191c4:	3710      	adds	r7, #16
 80191c6:	46bd      	mov	sp, r7
 80191c8:	bd80      	pop	{r7, pc}

080191ca <l2cap_setup_options_request>:
#endif

static uint16_t l2cap_setup_options_request(l2cap_channel_t * channel, uint8_t * config_options){
 80191ca:	b580      	push	{r7, lr}
 80191cc:	b084      	sub	sp, #16
 80191ce:	af00      	add	r7, sp, #0
 80191d0:	6078      	str	r0, [r7, #4]
 80191d2:	6039      	str	r1, [r7, #0]
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    // use ERTM options if supported by remote and channel ready to use it
    if (l2cap_ertm_mode(channel) && channel->mode == L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION){
 80191d4:	6878      	ldr	r0, [r7, #4]
 80191d6:	f7ff ffdb 	bl	8019190 <l2cap_ertm_mode>
 80191da:	4603      	mov	r3, r0
 80191dc:	2b00      	cmp	r3, #0
 80191de:	d00a      	beq.n	80191f6 <l2cap_setup_options_request+0x2c>
 80191e0:	687b      	ldr	r3, [r7, #4]
 80191e2:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 80191e6:	2b03      	cmp	r3, #3
 80191e8:	d105      	bne.n	80191f6 <l2cap_setup_options_request+0x2c>
        return l2cap_setup_options_ertm_request(channel, config_options);
 80191ea:	6839      	ldr	r1, [r7, #0]
 80191ec:	6878      	ldr	r0, [r7, #4]
 80191ee:	f7fe fe47 	bl	8017e80 <l2cap_setup_options_ertm_request>
 80191f2:	4603      	mov	r3, r0
 80191f4:	e008      	b.n	8019208 <l2cap_setup_options_request+0x3e>
    }
#endif
    uint16_t mtu = channel->local_mtu;
 80191f6:	687b      	ldr	r3, [r7, #4]
 80191f8:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 80191fa:	81fb      	strh	r3, [r7, #14]
    return l2cap_setup_options_mtu(config_options, mtu);
 80191fc:	89fb      	ldrh	r3, [r7, #14]
 80191fe:	4619      	mov	r1, r3
 8019200:	6838      	ldr	r0, [r7, #0]
 8019202:	f7ff ffad 	bl	8019160 <l2cap_setup_options_mtu>
 8019206:	4603      	mov	r3, r0
}
 8019208:	4618      	mov	r0, r3
 801920a:	3710      	adds	r7, #16
 801920c:	46bd      	mov	sp, r7
 801920e:	bd80      	pop	{r7, pc}

08019210 <l2cap_setup_options_mtu_response>:

static uint16_t l2cap_setup_options_mtu_response(l2cap_channel_t * channel, uint8_t * config_options){
 8019210:	b580      	push	{r7, lr}
 8019212:	b084      	sub	sp, #16
 8019214:	af00      	add	r7, sp, #0
 8019216:	6078      	str	r0, [r7, #4]
 8019218:	6039      	str	r1, [r7, #0]
    uint16_t mtu = btstack_min(channel->local_mtu, channel->remote_mtu);
 801921a:	687b      	ldr	r3, [r7, #4]
 801921c:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 801921e:	461a      	mov	r2, r3
 8019220:	687b      	ldr	r3, [r7, #4]
 8019222:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8019224:	4619      	mov	r1, r3
 8019226:	4610      	mov	r0, r2
 8019228:	f7f5 ff71 	bl	800f10e <btstack_min>
 801922c:	4603      	mov	r3, r0
 801922e:	81fb      	strh	r3, [r7, #14]
    return l2cap_setup_options_mtu(config_options, mtu);
 8019230:	89fb      	ldrh	r3, [r7, #14]
 8019232:	4619      	mov	r1, r3
 8019234:	6838      	ldr	r0, [r7, #0]
 8019236:	f7ff ff93 	bl	8019160 <l2cap_setup_options_mtu>
 801923a:	4603      	mov	r3, r0
}
 801923c:	4618      	mov	r0, r3
 801923e:	3710      	adds	r7, #16
 8019240:	46bd      	mov	sp, r7
 8019242:	bd80      	pop	{r7, pc}

08019244 <l2cap_extended_features_mask>:

static uint32_t l2cap_extended_features_mask(void){
 8019244:	b480      	push	{r7}
 8019246:	b083      	sub	sp, #12
 8019248:	af00      	add	r7, sp, #0
    // extended features request supported, features: fixed channels, unicast connectionless data reception
    uint32_t features = 0x280;
 801924a:	f44f 7320 	mov.w	r3, #640	; 0x280
 801924e:	607b      	str	r3, [r7, #4]
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    features |= 0x0028;
 8019250:	687b      	ldr	r3, [r7, #4]
 8019252:	f043 0328 	orr.w	r3, r3, #40	; 0x28
 8019256:	607b      	str	r3, [r7, #4]
#endif
    return features;
 8019258:	687b      	ldr	r3, [r7, #4]
}
 801925a:	4618      	mov	r0, r3
 801925c:	370c      	adds	r7, #12
 801925e:	46bd      	mov	sp, r7
 8019260:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019264:	4770      	bx	lr
	...

08019268 <l2cap_run_for_classic_channel>:

//
#ifdef ENABLE_CLASSIC

// returns true if channel was finalized
static bool l2cap_run_for_classic_channel(l2cap_channel_t * channel){
 8019268:	b5b0      	push	{r4, r5, r7, lr}
 801926a:	b08e      	sub	sp, #56	; 0x38
 801926c:	af04      	add	r7, sp, #16
 801926e:	6078      	str	r0, [r7, #4]
    uint8_t  config_options[18];
#else
    uint8_t  config_options[10];
#endif

    switch (channel->state){
 8019270:	687b      	ldr	r3, [r7, #4]
 8019272:	f893 3020 	ldrb.w	r3, [r3, #32]
 8019276:	3b02      	subs	r3, #2
 8019278:	2b11      	cmp	r3, #17
 801927a:	f200 828f 	bhi.w	801979c <l2cap_run_for_classic_channel+0x534>
 801927e:	a201      	add	r2, pc, #4	; (adr r2, 8019284 <l2cap_run_for_classic_channel+0x1c>)
 8019280:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019284:	08019327 	.word	0x08019327
 8019288:	0801979d 	.word	0x0801979d
 801928c:	0801979d 	.word	0x0801979d
 8019290:	080192cd 	.word	0x080192cd
 8019294:	0801979d 	.word	0x0801979d
 8019298:	0801979d 	.word	0x0801979d
 801929c:	0801979d 	.word	0x0801979d
 80192a0:	080192cd 	.word	0x080192cd
 80192a4:	0801979d 	.word	0x0801979d
 80192a8:	0801947d 	.word	0x0801947d
 80192ac:	0801979d 	.word	0x0801979d
 80192b0:	0801979d 	.word	0x0801979d
 80192b4:	0801942b 	.word	0x0801942b
 80192b8:	0801979d 	.word	0x0801979d
 80192bc:	08019377 	.word	0x08019377
 80192c0:	080193d9 	.word	0x080193d9
 80192c4:	08019751 	.word	0x08019751
 80192c8:	08019709 	.word	0x08019709

        case L2CAP_STATE_WAIT_INCOMING_SECURITY_LEVEL_UPDATE:
        case L2CAP_STATE_WAIT_CLIENT_ACCEPT_OR_REJECT:
            if (!hci_can_send_acl_packet_now(channel->con_handle)) return false;
 80192cc:	687b      	ldr	r3, [r7, #4]
 80192ce:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80192d0:	4618      	mov	r0, r3
 80192d2:	f7f6 fe85 	bl	800ffe0 <hci_can_send_acl_packet_now>
 80192d6:	4603      	mov	r3, r0
 80192d8:	2b00      	cmp	r3, #0
 80192da:	d101      	bne.n	80192e0 <l2cap_run_for_classic_channel+0x78>
 80192dc:	2300      	movs	r3, #0
 80192de:	e26a      	b.n	80197b6 <l2cap_run_for_classic_channel+0x54e>
            if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONN_RESP_PEND) {
 80192e0:	687b      	ldr	r3, [r7, #4]
 80192e2:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 80192e4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80192e8:	2b00      	cmp	r3, #0
 80192ea:	f000 8259 	beq.w	80197a0 <l2cap_run_for_classic_channel+0x538>
                channelStateVarClearFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONN_RESP_PEND);
 80192ee:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80192f2:	6878      	ldr	r0, [r7, #4]
 80192f4:	f7ff fec3 	bl	801907e <channelStateVarClearFlag>
                l2cap_send_signaling_packet(channel->con_handle, CONNECTION_RESPONSE, channel->remote_sig_id, channel->local_cid, channel->remote_cid, 1, 0);
 80192f8:	687b      	ldr	r3, [r7, #4]
 80192fa:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 80192fc:	687b      	ldr	r3, [r7, #4]
 80192fe:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8019302:	4619      	mov	r1, r3
 8019304:	687b      	ldr	r3, [r7, #4]
 8019306:	88db      	ldrh	r3, [r3, #6]
 8019308:	461c      	mov	r4, r3
 801930a:	687b      	ldr	r3, [r7, #4]
 801930c:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801930e:	461a      	mov	r2, r3
 8019310:	2300      	movs	r3, #0
 8019312:	9302      	str	r3, [sp, #8]
 8019314:	2301      	movs	r3, #1
 8019316:	9301      	str	r3, [sp, #4]
 8019318:	9200      	str	r2, [sp, #0]
 801931a:	4623      	mov	r3, r4
 801931c:	460a      	mov	r2, r1
 801931e:	2103      	movs	r1, #3
 8019320:	f7ff fdc0 	bl	8018ea4 <l2cap_send_signaling_packet>
            }
            break;
 8019324:	e23c      	b.n	80197a0 <l2cap_run_for_classic_channel+0x538>

        case L2CAP_STATE_WILL_SEND_CREATE_CONNECTION:
            if (!hci_can_send_command_packet_now()) break;
 8019326:	f7f6 fddf 	bl	800fee8 <hci_can_send_command_packet_now>
 801932a:	4603      	mov	r3, r0
 801932c:	2b00      	cmp	r3, #0
 801932e:	f000 8239 	beq.w	80197a4 <l2cap_run_for_classic_channel+0x53c>
            // send connection request - set state first
            channel->state = L2CAP_STATE_WAIT_CONNECTION_COMPLETE;
 8019332:	687b      	ldr	r3, [r7, #4]
 8019334:	2203      	movs	r2, #3
 8019336:	f883 2020 	strb.w	r2, [r3, #32]
            // BD_ADDR, Packet_Type, Page_Scan_Repetition_Mode, Reserved, Clock_Offset, Allow_Role_Switch
            (void)memcpy(l2cap_outgoing_classic_addr, channel->address, 6);
 801933a:	687b      	ldr	r3, [r7, #4]
 801933c:	f103 0226 	add.w	r2, r3, #38	; 0x26
 8019340:	4ba9      	ldr	r3, [pc, #676]	; (80195e8 <l2cap_run_for_classic_channel+0x380>)
 8019342:	6810      	ldr	r0, [r2, #0]
 8019344:	6018      	str	r0, [r3, #0]
 8019346:	8892      	ldrh	r2, [r2, #4]
 8019348:	809a      	strh	r2, [r3, #4]
            hci_send_cmd(&hci_create_connection, channel->address, hci_usable_acl_packet_types(), 0, 0, 0, hci_get_allow_role_switch());
 801934a:	687b      	ldr	r3, [r7, #4]
 801934c:	f103 0426 	add.w	r4, r3, #38	; 0x26
 8019350:	f7f7 fa12 	bl	8010778 <hci_usable_acl_packet_types>
 8019354:	4603      	mov	r3, r0
 8019356:	461d      	mov	r5, r3
 8019358:	f7fa ff44 	bl	80141e4 <hci_get_allow_role_switch>
 801935c:	4603      	mov	r3, r0
 801935e:	9302      	str	r3, [sp, #8]
 8019360:	2300      	movs	r3, #0
 8019362:	9301      	str	r3, [sp, #4]
 8019364:	2300      	movs	r3, #0
 8019366:	9300      	str	r3, [sp, #0]
 8019368:	2300      	movs	r3, #0
 801936a:	462a      	mov	r2, r5
 801936c:	4621      	mov	r1, r4
 801936e:	489f      	ldr	r0, [pc, #636]	; (80195ec <l2cap_run_for_classic_channel+0x384>)
 8019370:	f7fc fe36 	bl	8015fe0 <hci_send_cmd>
            break;
 8019374:	e219      	b.n	80197aa <l2cap_run_for_classic_channel+0x542>

        case L2CAP_STATE_WILL_SEND_CONNECTION_RESPONSE_DECLINE:
            if (!hci_can_send_acl_packet_now(channel->con_handle)) return false;
 8019376:	687b      	ldr	r3, [r7, #4]
 8019378:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801937a:	4618      	mov	r0, r3
 801937c:	f7f6 fe30 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019380:	4603      	mov	r3, r0
 8019382:	2b00      	cmp	r3, #0
 8019384:	d101      	bne.n	801938a <l2cap_run_for_classic_channel+0x122>
 8019386:	2300      	movs	r3, #0
 8019388:	e215      	b.n	80197b6 <l2cap_run_for_classic_channel+0x54e>
            channel->state = L2CAP_STATE_INVALID;
 801938a:	687b      	ldr	r3, [r7, #4]
 801938c:	2219      	movs	r2, #25
 801938e:	f883 2020 	strb.w	r2, [r3, #32]
            l2cap_send_signaling_packet(channel->con_handle, CONNECTION_RESPONSE, channel->remote_sig_id, channel->local_cid, channel->remote_cid, channel->reason, 0);
 8019392:	687b      	ldr	r3, [r7, #4]
 8019394:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 8019396:	687b      	ldr	r3, [r7, #4]
 8019398:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 801939c:	461c      	mov	r4, r3
 801939e:	687b      	ldr	r3, [r7, #4]
 80193a0:	88db      	ldrh	r3, [r3, #6]
 80193a2:	461d      	mov	r5, r3
 80193a4:	687b      	ldr	r3, [r7, #4]
 80193a6:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 80193a8:	461a      	mov	r2, r3
 80193aa:	687b      	ldr	r3, [r7, #4]
 80193ac:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
 80193b0:	4619      	mov	r1, r3
 80193b2:	2300      	movs	r3, #0
 80193b4:	9302      	str	r3, [sp, #8]
 80193b6:	9101      	str	r1, [sp, #4]
 80193b8:	9200      	str	r2, [sp, #0]
 80193ba:	462b      	mov	r3, r5
 80193bc:	4622      	mov	r2, r4
 80193be:	2103      	movs	r1, #3
 80193c0:	f7ff fd70 	bl	8018ea4 <l2cap_send_signaling_packet>
            // discard channel - l2cap_finialize_channel_close without sending l2cap close event
            btstack_linked_list_remove(&l2cap_channels, (btstack_linked_item_t *) channel);
 80193c4:	6879      	ldr	r1, [r7, #4]
 80193c6:	488a      	ldr	r0, [pc, #552]	; (80195f0 <l2cap_run_for_classic_channel+0x388>)
 80193c8:	f7f5 f979 	bl	800e6be <btstack_linked_list_remove>
            l2cap_free_channel_entry(channel);
 80193cc:	6878      	ldr	r0, [r7, #4]
 80193ce:	f000 ff8f 	bl	801a2f0 <l2cap_free_channel_entry>
            channel = NULL;
 80193d2:	2300      	movs	r3, #0
 80193d4:	607b      	str	r3, [r7, #4]
            break;
 80193d6:	e1e8      	b.n	80197aa <l2cap_run_for_classic_channel+0x542>

        case L2CAP_STATE_WILL_SEND_CONNECTION_RESPONSE_ACCEPT:
            if (!hci_can_send_acl_packet_now(channel->con_handle)) return false;
 80193d8:	687b      	ldr	r3, [r7, #4]
 80193da:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80193dc:	4618      	mov	r0, r3
 80193de:	f7f6 fdff 	bl	800ffe0 <hci_can_send_acl_packet_now>
 80193e2:	4603      	mov	r3, r0
 80193e4:	2b00      	cmp	r3, #0
 80193e6:	d101      	bne.n	80193ec <l2cap_run_for_classic_channel+0x184>
 80193e8:	2300      	movs	r3, #0
 80193ea:	e1e4      	b.n	80197b6 <l2cap_run_for_classic_channel+0x54e>
            channel->state = L2CAP_STATE_CONFIG;
 80193ec:	687b      	ldr	r3, [r7, #4]
 80193ee:	220b      	movs	r2, #11
 80193f0:	f883 2020 	strb.w	r2, [r3, #32]
            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_REQ);
 80193f4:	2104      	movs	r1, #4
 80193f6:	6878      	ldr	r0, [r7, #4]
 80193f8:	f7ff fe2e 	bl	8019058 <channelStateVarSetFlag>
            l2cap_send_signaling_packet(channel->con_handle, CONNECTION_RESPONSE, channel->remote_sig_id, channel->local_cid, channel->remote_cid, 0, 0);
 80193fc:	687b      	ldr	r3, [r7, #4]
 80193fe:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 8019400:	687b      	ldr	r3, [r7, #4]
 8019402:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8019406:	4619      	mov	r1, r3
 8019408:	687b      	ldr	r3, [r7, #4]
 801940a:	88db      	ldrh	r3, [r3, #6]
 801940c:	461c      	mov	r4, r3
 801940e:	687b      	ldr	r3, [r7, #4]
 8019410:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8019412:	461a      	mov	r2, r3
 8019414:	2300      	movs	r3, #0
 8019416:	9302      	str	r3, [sp, #8]
 8019418:	2300      	movs	r3, #0
 801941a:	9301      	str	r3, [sp, #4]
 801941c:	9200      	str	r2, [sp, #0]
 801941e:	4623      	mov	r3, r4
 8019420:	460a      	mov	r2, r1
 8019422:	2103      	movs	r1, #3
 8019424:	f7ff fd3e 	bl	8018ea4 <l2cap_send_signaling_packet>
            break;
 8019428:	e1bf      	b.n	80197aa <l2cap_run_for_classic_channel+0x542>

        case L2CAP_STATE_WILL_SEND_CONNECTION_REQUEST:
            if (!hci_can_send_acl_packet_now(channel->con_handle)) return false;
 801942a:	687b      	ldr	r3, [r7, #4]
 801942c:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801942e:	4618      	mov	r0, r3
 8019430:	f7f6 fdd6 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019434:	4603      	mov	r3, r0
 8019436:	2b00      	cmp	r3, #0
 8019438:	d101      	bne.n	801943e <l2cap_run_for_classic_channel+0x1d6>
 801943a:	2300      	movs	r3, #0
 801943c:	e1bb      	b.n	80197b6 <l2cap_run_for_classic_channel+0x54e>
            // success, start l2cap handshake
            channel->local_sig_id = l2cap_next_sig_id();
 801943e:	f7ff f8a3 	bl	8018588 <l2cap_next_sig_id>
 8019442:	4603      	mov	r3, r0
 8019444:	461a      	mov	r2, r3
 8019446:	687b      	ldr	r3, [r7, #4]
 8019448:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
            channel->state = L2CAP_STATE_WAIT_CONNECT_RSP;
 801944c:	687b      	ldr	r3, [r7, #4]
 801944e:	220a      	movs	r2, #10
 8019450:	f883 2020 	strb.w	r2, [r3, #32]
            l2cap_send_signaling_packet( channel->con_handle, CONNECTION_REQUEST, channel->local_sig_id, channel->psm, channel->local_cid);
 8019454:	687b      	ldr	r3, [r7, #4]
 8019456:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 8019458:	687b      	ldr	r3, [r7, #4]
 801945a:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 801945e:	461a      	mov	r2, r3
 8019460:	687b      	ldr	r3, [r7, #4]
 8019462:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8019464:	4619      	mov	r1, r3
 8019466:	687b      	ldr	r3, [r7, #4]
 8019468:	88db      	ldrh	r3, [r3, #6]
 801946a:	9300      	str	r3, [sp, #0]
 801946c:	460b      	mov	r3, r1
 801946e:	2102      	movs	r1, #2
 8019470:	f7ff fd18 	bl	8018ea4 <l2cap_send_signaling_packet>
            l2cap_start_rtx(channel);
 8019474:	6878      	ldr	r0, [r7, #4]
 8019476:	f7ff fcb9 	bl	8018dec <l2cap_start_rtx>
            break;
 801947a:	e196      	b.n	80197aa <l2cap_run_for_classic_channel+0x542>

        case L2CAP_STATE_CONFIG:
            if (!hci_can_send_acl_packet_now(channel->con_handle)) return false;
 801947c:	687b      	ldr	r3, [r7, #4]
 801947e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8019480:	4618      	mov	r0, r3
 8019482:	f7f6 fdad 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019486:	4603      	mov	r3, r0
 8019488:	2b00      	cmp	r3, #0
 801948a:	d101      	bne.n	8019490 <l2cap_run_for_classic_channel+0x228>
 801948c:	2300      	movs	r3, #0
 801948e:	e192      	b.n	80197b6 <l2cap_run_for_classic_channel+0x54e>
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
            // fallback to basic mode if ERTM requested but not not supported by remote
            if (channel->mode == L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION){
 8019490:	687b      	ldr	r3, [r7, #4]
 8019492:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 8019496:	2b03      	cmp	r3, #3
 8019498:	d10d      	bne.n	80194b6 <l2cap_run_for_classic_channel+0x24e>
                if (!l2cap_ertm_mode(channel)){
 801949a:	6878      	ldr	r0, [r7, #4]
 801949c:	f7ff fe78 	bl	8019190 <l2cap_ertm_mode>
 80194a0:	4603      	mov	r3, r0
 80194a2:	2b00      	cmp	r3, #0
 80194a4:	d107      	bne.n	80194b6 <l2cap_run_for_classic_channel+0x24e>
                    l2cap_emit_simple_event_with_cid(channel, L2CAP_EVENT_ERTM_BUFFER_RELEASED);
 80194a6:	217e      	movs	r1, #126	; 0x7e
 80194a8:	6878      	ldr	r0, [r7, #4]
 80194aa:	f7ff fa1a 	bl	80188e2 <l2cap_emit_simple_event_with_cid>
                    channel->mode = L2CAP_CHANNEL_MODE_BASIC;
 80194ae:	687b      	ldr	r3, [r7, #4]
 80194b0:	2200      	movs	r2, #0
 80194b2:	f883 2056 	strb.w	r2, [r3, #86]	; 0x56
                }
            }
#endif
            if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP){
 80194b6:	687b      	ldr	r3, [r7, #4]
 80194b8:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 80194ba:	f003 0308 	and.w	r3, r3, #8
 80194be:	2b00      	cmp	r3, #0
 80194c0:	f000 80de 	beq.w	8019680 <l2cap_run_for_classic_channel+0x418>
                uint16_t flags = 0;
 80194c4:	2300      	movs	r3, #0
 80194c6:	84fb      	strh	r3, [r7, #38]	; 0x26
                channelStateVarClearFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP);
 80194c8:	2108      	movs	r1, #8
 80194ca:	6878      	ldr	r0, [r7, #4]
 80194cc:	f7ff fdd7 	bl	801907e <channelStateVarClearFlag>
                if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_CONT) {
 80194d0:	687b      	ldr	r3, [r7, #4]
 80194d2:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 80194d4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80194d8:	2b00      	cmp	r3, #0
 80194da:	d002      	beq.n	80194e2 <l2cap_run_for_classic_channel+0x27a>
                    flags = 1;
 80194dc:	2301      	movs	r3, #1
 80194de:	84fb      	strh	r3, [r7, #38]	; 0x26
 80194e0:	e003      	b.n	80194ea <l2cap_run_for_classic_channel+0x282>
                } else {
                    channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SENT_CONF_RSP);
 80194e2:	2120      	movs	r1, #32
 80194e4:	6878      	ldr	r0, [r7, #4]
 80194e6:	f7ff fdb7 	bl	8019058 <channelStateVarSetFlag>
                }
                if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_INVALID){
 80194ea:	687b      	ldr	r3, [r7, #4]
 80194ec:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 80194ee:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80194f2:	2b00      	cmp	r3, #0
 80194f4:	d01a      	beq.n	801952c <l2cap_run_for_classic_channel+0x2c4>
                    channelStateVarClearFlag(channel, L2CAP_CHANNEL_STATE_VAR_SENT_CONF_RSP);
 80194f6:	2120      	movs	r1, #32
 80194f8:	6878      	ldr	r0, [r7, #4]
 80194fa:	f7ff fdc0 	bl	801907e <channelStateVarClearFlag>
                    l2cap_send_signaling_packet(channel->con_handle, CONFIGURE_RESPONSE, channel->remote_sig_id, channel->remote_cid, flags, L2CAP_CONF_RESULT_UNKNOWN_OPTIONS, 0, NULL);
 80194fe:	687b      	ldr	r3, [r7, #4]
 8019500:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 8019502:	687b      	ldr	r3, [r7, #4]
 8019504:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8019508:	4619      	mov	r1, r3
 801950a:	687b      	ldr	r3, [r7, #4]
 801950c:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801950e:	461c      	mov	r4, r3
 8019510:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8019512:	2200      	movs	r2, #0
 8019514:	9203      	str	r2, [sp, #12]
 8019516:	2200      	movs	r2, #0
 8019518:	9202      	str	r2, [sp, #8]
 801951a:	2203      	movs	r2, #3
 801951c:	9201      	str	r2, [sp, #4]
 801951e:	9300      	str	r3, [sp, #0]
 8019520:	4623      	mov	r3, r4
 8019522:	460a      	mov	r2, r1
 8019524:	2105      	movs	r1, #5
 8019526:	f7ff fcbd 	bl	8018ea4 <l2cap_send_signaling_packet>
 801952a:	e0a3      	b.n	8019674 <l2cap_run_for_classic_channel+0x40c>
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
                } else if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_REJECTED){
 801952c:	687b      	ldr	r3, [r7, #4]
 801952e:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8019530:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8019534:	2b00      	cmp	r3, #0
 8019536:	d028      	beq.n	801958a <l2cap_run_for_classic_channel+0x322>
                    channelStateVarClearFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_REJECTED);
 8019538:	f44f 6180 	mov.w	r1, #1024	; 0x400
 801953c:	6878      	ldr	r0, [r7, #4]
 801953e:	f7ff fd9e 	bl	801907e <channelStateVarClearFlag>
                    channelStateVarClearFlag(channel, L2CAP_CHANNEL_STATE_VAR_SENT_CONF_RSP);
 8019542:	2120      	movs	r1, #32
 8019544:	6878      	ldr	r0, [r7, #4]
 8019546:	f7ff fd9a 	bl	801907e <channelStateVarClearFlag>
                    uint16_t options_size = l2cap_setup_options_ertm_response(channel, config_options);
 801954a:	f107 030c 	add.w	r3, r7, #12
 801954e:	4619      	mov	r1, r3
 8019550:	6878      	ldr	r0, [r7, #4]
 8019552:	f7fe fd29 	bl	8017fa8 <l2cap_setup_options_ertm_response>
 8019556:	4603      	mov	r3, r0
 8019558:	83fb      	strh	r3, [r7, #30]
                    l2cap_send_signaling_packet(channel->con_handle, CONFIGURE_RESPONSE, channel->remote_sig_id, channel->remote_cid, flags, L2CAP_CONF_RESULT_UNACCEPTABLE_PARAMETERS, options_size, &config_options);
 801955a:	687b      	ldr	r3, [r7, #4]
 801955c:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 801955e:	687b      	ldr	r3, [r7, #4]
 8019560:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8019564:	461c      	mov	r4, r3
 8019566:	687b      	ldr	r3, [r7, #4]
 8019568:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801956a:	461d      	mov	r5, r3
 801956c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801956e:	8bfa      	ldrh	r2, [r7, #30]
 8019570:	f107 010c 	add.w	r1, r7, #12
 8019574:	9103      	str	r1, [sp, #12]
 8019576:	9202      	str	r2, [sp, #8]
 8019578:	2201      	movs	r2, #1
 801957a:	9201      	str	r2, [sp, #4]
 801957c:	9300      	str	r3, [sp, #0]
 801957e:	462b      	mov	r3, r5
 8019580:	4622      	mov	r2, r4
 8019582:	2105      	movs	r1, #5
 8019584:	f7ff fc8e 	bl	8018ea4 <l2cap_send_signaling_packet>
 8019588:	e074      	b.n	8019674 <l2cap_run_for_classic_channel+0x40c>
                } else if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_ERTM){
 801958a:	687b      	ldr	r3, [r7, #4]
 801958c:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801958e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8019592:	2b00      	cmp	r3, #0
 8019594:	d02e      	beq.n	80195f4 <l2cap_run_for_classic_channel+0x38c>
                    channelStateVarClearFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_ERTM);
 8019596:	2180      	movs	r1, #128	; 0x80
 8019598:	6878      	ldr	r0, [r7, #4]
 801959a:	f7ff fd70 	bl	801907e <channelStateVarClearFlag>
                    channelStateVarClearFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_MTU);
 801959e:	2140      	movs	r1, #64	; 0x40
 80195a0:	6878      	ldr	r0, [r7, #4]
 80195a2:	f7ff fd6c 	bl	801907e <channelStateVarClearFlag>
                    uint16_t options_size = l2cap_setup_options_ertm_response(channel, config_options);
 80195a6:	f107 030c 	add.w	r3, r7, #12
 80195aa:	4619      	mov	r1, r3
 80195ac:	6878      	ldr	r0, [r7, #4]
 80195ae:	f7fe fcfb 	bl	8017fa8 <l2cap_setup_options_ertm_response>
 80195b2:	4603      	mov	r3, r0
 80195b4:	843b      	strh	r3, [r7, #32]
                    l2cap_send_signaling_packet(channel->con_handle, CONFIGURE_RESPONSE, channel->remote_sig_id, channel->remote_cid, flags, L2CAP_CONF_RESULT_SUCCESS, options_size, &config_options);
 80195b6:	687b      	ldr	r3, [r7, #4]
 80195b8:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 80195ba:	687b      	ldr	r3, [r7, #4]
 80195bc:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 80195c0:	461c      	mov	r4, r3
 80195c2:	687b      	ldr	r3, [r7, #4]
 80195c4:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 80195c6:	461d      	mov	r5, r3
 80195c8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80195ca:	8c3a      	ldrh	r2, [r7, #32]
 80195cc:	f107 010c 	add.w	r1, r7, #12
 80195d0:	9103      	str	r1, [sp, #12]
 80195d2:	9202      	str	r2, [sp, #8]
 80195d4:	2200      	movs	r2, #0
 80195d6:	9201      	str	r2, [sp, #4]
 80195d8:	9300      	str	r3, [sp, #0]
 80195da:	462b      	mov	r3, r5
 80195dc:	4622      	mov	r2, r4
 80195de:	2105      	movs	r1, #5
 80195e0:	f7ff fc60 	bl	8018ea4 <l2cap_send_signaling_packet>
 80195e4:	e046      	b.n	8019674 <l2cap_run_for_classic_channel+0x40c>
 80195e6:	bf00      	nop
 80195e8:	20009ea0 	.word	0x20009ea0
 80195ec:	08030a08 	.word	0x08030a08
 80195f0:	20009eac 	.word	0x20009eac
#endif
                } else if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_MTU){
 80195f4:	687b      	ldr	r3, [r7, #4]
 80195f6:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 80195f8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80195fc:	2b00      	cmp	r3, #0
 80195fe:	d023      	beq.n	8019648 <l2cap_run_for_classic_channel+0x3e0>
                    channelStateVarClearFlag(channel,L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_MTU);
 8019600:	2140      	movs	r1, #64	; 0x40
 8019602:	6878      	ldr	r0, [r7, #4]
 8019604:	f7ff fd3b 	bl	801907e <channelStateVarClearFlag>
                    uint16_t options_size = l2cap_setup_options_mtu_response(channel, config_options);
 8019608:	f107 030c 	add.w	r3, r7, #12
 801960c:	4619      	mov	r1, r3
 801960e:	6878      	ldr	r0, [r7, #4]
 8019610:	f7ff fdfe 	bl	8019210 <l2cap_setup_options_mtu_response>
 8019614:	4603      	mov	r3, r0
 8019616:	847b      	strh	r3, [r7, #34]	; 0x22
                    l2cap_send_signaling_packet(channel->con_handle, CONFIGURE_RESPONSE, channel->remote_sig_id, channel->remote_cid, flags, L2CAP_CONF_RESULT_SUCCESS, options_size, &config_options);
 8019618:	687b      	ldr	r3, [r7, #4]
 801961a:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 801961c:	687b      	ldr	r3, [r7, #4]
 801961e:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8019622:	461c      	mov	r4, r3
 8019624:	687b      	ldr	r3, [r7, #4]
 8019626:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8019628:	461d      	mov	r5, r3
 801962a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801962c:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 801962e:	f107 010c 	add.w	r1, r7, #12
 8019632:	9103      	str	r1, [sp, #12]
 8019634:	9202      	str	r2, [sp, #8]
 8019636:	2200      	movs	r2, #0
 8019638:	9201      	str	r2, [sp, #4]
 801963a:	9300      	str	r3, [sp, #0]
 801963c:	462b      	mov	r3, r5
 801963e:	4622      	mov	r2, r4
 8019640:	2105      	movs	r1, #5
 8019642:	f7ff fc2f 	bl	8018ea4 <l2cap_send_signaling_packet>
 8019646:	e015      	b.n	8019674 <l2cap_run_for_classic_channel+0x40c>
                } else {
                    l2cap_send_signaling_packet(channel->con_handle, CONFIGURE_RESPONSE, channel->remote_sig_id, channel->remote_cid, flags, L2CAP_CONF_RESULT_SUCCESS, 0, NULL);
 8019648:	687b      	ldr	r3, [r7, #4]
 801964a:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 801964c:	687b      	ldr	r3, [r7, #4]
 801964e:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8019652:	4619      	mov	r1, r3
 8019654:	687b      	ldr	r3, [r7, #4]
 8019656:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8019658:	461c      	mov	r4, r3
 801965a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801965c:	2200      	movs	r2, #0
 801965e:	9203      	str	r2, [sp, #12]
 8019660:	2200      	movs	r2, #0
 8019662:	9202      	str	r2, [sp, #8]
 8019664:	2200      	movs	r2, #0
 8019666:	9201      	str	r2, [sp, #4]
 8019668:	9300      	str	r3, [sp, #0]
 801966a:	4623      	mov	r3, r4
 801966c:	460a      	mov	r2, r1
 801966e:	2105      	movs	r1, #5
 8019670:	f7ff fc18 	bl	8018ea4 <l2cap_send_signaling_packet>
                }
                channelStateVarClearFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_CONT);
 8019674:	f44f 7180 	mov.w	r1, #256	; 0x100
 8019678:	6878      	ldr	r0, [r7, #4]
 801967a:	f7ff fd00 	bl	801907e <channelStateVarClearFlag>
 801967e:	e034      	b.n	80196ea <l2cap_run_for_classic_channel+0x482>
            }
            else if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONF_REQ){
 8019680:	687b      	ldr	r3, [r7, #4]
 8019682:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8019684:	f003 0304 	and.w	r3, r3, #4
 8019688:	2b00      	cmp	r3, #0
 801968a:	d02e      	beq.n	80196ea <l2cap_run_for_classic_channel+0x482>
                channelStateVarClearFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_REQ);
 801968c:	2104      	movs	r1, #4
 801968e:	6878      	ldr	r0, [r7, #4]
 8019690:	f7ff fcf5 	bl	801907e <channelStateVarClearFlag>
                channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SENT_CONF_REQ);
 8019694:	2110      	movs	r1, #16
 8019696:	6878      	ldr	r0, [r7, #4]
 8019698:	f7ff fcde 	bl	8019058 <channelStateVarSetFlag>
                channel->local_sig_id = l2cap_next_sig_id();
 801969c:	f7fe ff74 	bl	8018588 <l2cap_next_sig_id>
 80196a0:	4603      	mov	r3, r0
 80196a2:	461a      	mov	r2, r3
 80196a4:	687b      	ldr	r3, [r7, #4]
 80196a6:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
                uint16_t options_size = l2cap_setup_options_request(channel, config_options);
 80196aa:	f107 030c 	add.w	r3, r7, #12
 80196ae:	4619      	mov	r1, r3
 80196b0:	6878      	ldr	r0, [r7, #4]
 80196b2:	f7ff fd8a 	bl	80191ca <l2cap_setup_options_request>
 80196b6:	4603      	mov	r3, r0
 80196b8:	84bb      	strh	r3, [r7, #36]	; 0x24
                l2cap_send_signaling_packet(channel->con_handle, CONFIGURE_REQUEST, channel->local_sig_id, channel->remote_cid, 0, options_size, &config_options);
 80196ba:	687b      	ldr	r3, [r7, #4]
 80196bc:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 80196be:	687b      	ldr	r3, [r7, #4]
 80196c0:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 80196c4:	4619      	mov	r1, r3
 80196c6:	687b      	ldr	r3, [r7, #4]
 80196c8:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 80196ca:	461c      	mov	r4, r3
 80196cc:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80196ce:	f107 020c 	add.w	r2, r7, #12
 80196d2:	9202      	str	r2, [sp, #8]
 80196d4:	9301      	str	r3, [sp, #4]
 80196d6:	2300      	movs	r3, #0
 80196d8:	9300      	str	r3, [sp, #0]
 80196da:	4623      	mov	r3, r4
 80196dc:	460a      	mov	r2, r1
 80196de:	2104      	movs	r1, #4
 80196e0:	f7ff fbe0 	bl	8018ea4 <l2cap_send_signaling_packet>
                l2cap_start_rtx(channel);
 80196e4:	6878      	ldr	r0, [r7, #4]
 80196e6:	f7ff fb81 	bl	8018dec <l2cap_start_rtx>
            }
            if (l2cap_channel_ready_for_open(channel)){
 80196ea:	6878      	ldr	r0, [r7, #4]
 80196ec:	f001 fe22 	bl	801b334 <l2cap_channel_ready_for_open>
 80196f0:	4603      	mov	r3, r0
 80196f2:	2b00      	cmp	r3, #0
 80196f4:	d058      	beq.n	80197a8 <l2cap_run_for_classic_channel+0x540>
                channel->state = L2CAP_STATE_OPEN;
 80196f6:	687b      	ldr	r3, [r7, #4]
 80196f8:	220c      	movs	r2, #12
 80196fa:	f883 2020 	strb.w	r2, [r3, #32]
                l2cap_emit_channel_opened(channel, 0);  // success
 80196fe:	2100      	movs	r1, #0
 8019700:	6878      	ldr	r0, [r7, #4]
 8019702:	f7ff f913 	bl	801892c <l2cap_emit_channel_opened>
            }
            break;
 8019706:	e04f      	b.n	80197a8 <l2cap_run_for_classic_channel+0x540>

        case L2CAP_STATE_WILL_SEND_DISCONNECT_RESPONSE:
            if (!hci_can_send_acl_packet_now(channel->con_handle)) return false;
 8019708:	687b      	ldr	r3, [r7, #4]
 801970a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801970c:	4618      	mov	r0, r3
 801970e:	f7f6 fc67 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019712:	4603      	mov	r3, r0
 8019714:	2b00      	cmp	r3, #0
 8019716:	d101      	bne.n	801971c <l2cap_run_for_classic_channel+0x4b4>
 8019718:	2300      	movs	r3, #0
 801971a:	e04c      	b.n	80197b6 <l2cap_run_for_classic_channel+0x54e>
            channel->state = L2CAP_STATE_INVALID;
 801971c:	687b      	ldr	r3, [r7, #4]
 801971e:	2219      	movs	r2, #25
 8019720:	f883 2020 	strb.w	r2, [r3, #32]
            l2cap_send_signaling_packet( channel->con_handle, DISCONNECTION_RESPONSE, channel->remote_sig_id, channel->local_cid, channel->remote_cid);
 8019724:	687b      	ldr	r3, [r7, #4]
 8019726:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 8019728:	687b      	ldr	r3, [r7, #4]
 801972a:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 801972e:	461a      	mov	r2, r3
 8019730:	687b      	ldr	r3, [r7, #4]
 8019732:	88db      	ldrh	r3, [r3, #6]
 8019734:	4619      	mov	r1, r3
 8019736:	687b      	ldr	r3, [r7, #4]
 8019738:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801973a:	9300      	str	r3, [sp, #0]
 801973c:	460b      	mov	r3, r1
 801973e:	2107      	movs	r1, #7
 8019740:	f7ff fbb0 	bl	8018ea4 <l2cap_send_signaling_packet>
            // we don't start an RTX timer for a disconnect - there's no point in closing the channel if the other side doesn't respond :)
            l2cap_finialize_channel_close(channel);  // -- remove from list
 8019744:	6878      	ldr	r0, [r7, #4]
 8019746:	f003 f9bb 	bl	801cac0 <l2cap_finialize_channel_close>
            channel = NULL;
 801974a:	2300      	movs	r3, #0
 801974c:	607b      	str	r3, [r7, #4]
            break;
 801974e:	e02c      	b.n	80197aa <l2cap_run_for_classic_channel+0x542>

        case L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST:
            if (!hci_can_send_acl_packet_now(channel->con_handle)) return false;
 8019750:	687b      	ldr	r3, [r7, #4]
 8019752:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8019754:	4618      	mov	r0, r3
 8019756:	f7f6 fc43 	bl	800ffe0 <hci_can_send_acl_packet_now>
 801975a:	4603      	mov	r3, r0
 801975c:	2b00      	cmp	r3, #0
 801975e:	d101      	bne.n	8019764 <l2cap_run_for_classic_channel+0x4fc>
 8019760:	2300      	movs	r3, #0
 8019762:	e028      	b.n	80197b6 <l2cap_run_for_classic_channel+0x54e>
            channel->local_sig_id = l2cap_next_sig_id();
 8019764:	f7fe ff10 	bl	8018588 <l2cap_next_sig_id>
 8019768:	4603      	mov	r3, r0
 801976a:	461a      	mov	r2, r3
 801976c:	687b      	ldr	r3, [r7, #4]
 801976e:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
            channel->state = L2CAP_STATE_WAIT_DISCONNECT;
 8019772:	687b      	ldr	r3, [r7, #4]
 8019774:	220d      	movs	r2, #13
 8019776:	f883 2020 	strb.w	r2, [r3, #32]
            l2cap_send_signaling_packet( channel->con_handle, DISCONNECTION_REQUEST, channel->local_sig_id, channel->remote_cid, channel->local_cid);
 801977a:	687b      	ldr	r3, [r7, #4]
 801977c:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 801977e:	687b      	ldr	r3, [r7, #4]
 8019780:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8019784:	461a      	mov	r2, r3
 8019786:	687b      	ldr	r3, [r7, #4]
 8019788:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801978a:	4619      	mov	r1, r3
 801978c:	687b      	ldr	r3, [r7, #4]
 801978e:	88db      	ldrh	r3, [r3, #6]
 8019790:	9300      	str	r3, [sp, #0]
 8019792:	460b      	mov	r3, r1
 8019794:	2106      	movs	r1, #6
 8019796:	f7ff fb85 	bl	8018ea4 <l2cap_send_signaling_packet>
            break;
 801979a:	e006      	b.n	80197aa <l2cap_run_for_classic_channel+0x542>
        default:
            break;
 801979c:	bf00      	nop
 801979e:	e004      	b.n	80197aa <l2cap_run_for_classic_channel+0x542>
            break;
 80197a0:	bf00      	nop
 80197a2:	e002      	b.n	80197aa <l2cap_run_for_classic_channel+0x542>
            if (!hci_can_send_command_packet_now()) break;
 80197a4:	bf00      	nop
 80197a6:	e000      	b.n	80197aa <l2cap_run_for_classic_channel+0x542>
            break;
 80197a8:	bf00      	nop
    }

    // handle channel finalize on L2CAP_STATE_WILL_SEND_DISCONNECT_RESPONSE and L2CAP_STATE_WILL_SEND_CONNECTION_RESPONSE_DECLINE
    return channel == NULL;
 80197aa:	687b      	ldr	r3, [r7, #4]
 80197ac:	2b00      	cmp	r3, #0
 80197ae:	bf0c      	ite	eq
 80197b0:	2301      	moveq	r3, #1
 80197b2:	2300      	movne	r3, #0
 80197b4:	b2db      	uxtb	r3, r3
}
 80197b6:	4618      	mov	r0, r3
 80197b8:	3728      	adds	r7, #40	; 0x28
 80197ba:	46bd      	mov	sp, r7
 80197bc:	bdb0      	pop	{r4, r5, r7, pc}
 80197be:	bf00      	nop

080197c0 <l2cap_run_for_classic_channel_ertm>:

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
static void l2cap_run_for_classic_channel_ertm(l2cap_channel_t * channel){
 80197c0:	b580      	push	{r7, lr}
 80197c2:	b08a      	sub	sp, #40	; 0x28
 80197c4:	af02      	add	r7, sp, #8
 80197c6:	6078      	str	r0, [r7, #4]

    // ERTM mode
    if (channel->mode != L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION) return;
 80197c8:	687b      	ldr	r3, [r7, #4]
 80197ca:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 80197ce:	2b03      	cmp	r3, #3
 80197d0:	f040 8112 	bne.w	80199f8 <l2cap_run_for_classic_channel_ertm+0x238>

    // check if we can still send
    if (channel->con_handle == HCI_CON_HANDLE_INVALID) return;
 80197d4:	687b      	ldr	r3, [r7, #4]
 80197d6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80197d8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80197dc:	4293      	cmp	r3, r2
 80197de:	f000 810d 	beq.w	80199fc <l2cap_run_for_classic_channel_ertm+0x23c>
    if (!hci_can_send_acl_packet_now(channel->con_handle)) return;
 80197e2:	687b      	ldr	r3, [r7, #4]
 80197e4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80197e6:	4618      	mov	r0, r3
 80197e8:	f7f6 fbfa 	bl	800ffe0 <hci_can_send_acl_packet_now>
 80197ec:	4603      	mov	r3, r0
 80197ee:	2b00      	cmp	r3, #0
 80197f0:	f000 8106 	beq.w	8019a00 <l2cap_run_for_classic_channel_ertm+0x240>

    if (channel->send_supervisor_frame_receiver_ready){
 80197f4:	687b      	ldr	r3, [r7, #4]
 80197f6:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80197fa:	2b00      	cmp	r3, #0
 80197fc:	d02a      	beq.n	8019854 <l2cap_run_for_classic_channel_ertm+0x94>
        channel->send_supervisor_frame_receiver_ready = 0;
 80197fe:	687b      	ldr	r3, [r7, #4]
 8019800:	2200      	movs	r2, #0
 8019802:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
        log_info("Send S-Frame: RR %u, final %u", channel->req_seq, channel->set_final_bit_after_packet_with_poll_bit_set);
 8019806:	687b      	ldr	r3, [r7, #4]
 8019808:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 801980c:	461a      	mov	r2, r3
 801980e:	687b      	ldr	r3, [r7, #4]
 8019810:	f893 309b 	ldrb.w	r3, [r3, #155]	; 0x9b
 8019814:	9301      	str	r3, [sp, #4]
 8019816:	9200      	str	r2, [sp, #0]
 8019818:	f240 634d 	movw	r3, #1613	; 0x64d
 801981c:	4a7b      	ldr	r2, [pc, #492]	; (8019a0c <l2cap_run_for_classic_channel_ertm+0x24c>)
 801981e:	497c      	ldr	r1, [pc, #496]	; (8019a10 <l2cap_run_for_classic_channel_ertm+0x250>)
 8019820:	2001      	movs	r0, #1
 8019822:	f7fd fe0d 	bl	8017440 <hci_dump_log>
        uint16_t control = l2cap_encanced_control_field_for_supevisor_frame( L2CAP_SUPERVISORY_FUNCTION_RR_RECEIVER_READY, 0,  channel->set_final_bit_after_packet_with_poll_bit_set, channel->req_seq);
 8019826:	687b      	ldr	r3, [r7, #4]
 8019828:	f893 309b 	ldrb.w	r3, [r3, #155]	; 0x9b
 801982c:	461a      	mov	r2, r3
 801982e:	687b      	ldr	r3, [r7, #4]
 8019830:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8019834:	2100      	movs	r1, #0
 8019836:	2000      	movs	r0, #0
 8019838:	f7fe f92f 	bl	8017a9a <l2cap_encanced_control_field_for_supevisor_frame>
 801983c:	4603      	mov	r3, r0
 801983e:	81bb      	strh	r3, [r7, #12]
        channel->set_final_bit_after_packet_with_poll_bit_set = 0;
 8019840:	687b      	ldr	r3, [r7, #4]
 8019842:	2200      	movs	r2, #0
 8019844:	f883 209b 	strb.w	r2, [r3, #155]	; 0x9b
        l2cap_ertm_send_supervisor_frame(channel, control);
 8019848:	89bb      	ldrh	r3, [r7, #12]
 801984a:	4619      	mov	r1, r3
 801984c:	6878      	ldr	r0, [r7, #4]
 801984e:	f7fe fc3b 	bl	80180c8 <l2cap_ertm_send_supervisor_frame>
        return;
 8019852:	e0d8      	b.n	8019a06 <l2cap_run_for_classic_channel_ertm+0x246>
    }
    if (channel->send_supervisor_frame_receiver_ready_poll){
 8019854:	687b      	ldr	r3, [r7, #4]
 8019856:	f893 3097 	ldrb.w	r3, [r3, #151]	; 0x97
 801985a:	2b00      	cmp	r3, #0
 801985c:	d01e      	beq.n	801989c <l2cap_run_for_classic_channel_ertm+0xdc>
        channel->send_supervisor_frame_receiver_ready_poll = 0;
 801985e:	687b      	ldr	r3, [r7, #4]
 8019860:	2200      	movs	r2, #0
 8019862:	f883 2097 	strb.w	r2, [r3, #151]	; 0x97
        log_info("Send S-Frame: RR %u with poll=1 ", channel->req_seq);
 8019866:	687b      	ldr	r3, [r7, #4]
 8019868:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 801986c:	9300      	str	r3, [sp, #0]
 801986e:	f240 6355 	movw	r3, #1621	; 0x655
 8019872:	4a66      	ldr	r2, [pc, #408]	; (8019a0c <l2cap_run_for_classic_channel_ertm+0x24c>)
 8019874:	4967      	ldr	r1, [pc, #412]	; (8019a14 <l2cap_run_for_classic_channel_ertm+0x254>)
 8019876:	2001      	movs	r0, #1
 8019878:	f7fd fde2 	bl	8017440 <hci_dump_log>
        uint16_t control = l2cap_encanced_control_field_for_supevisor_frame( L2CAP_SUPERVISORY_FUNCTION_RR_RECEIVER_READY, 1, 0, channel->req_seq);
 801987c:	687b      	ldr	r3, [r7, #4]
 801987e:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8019882:	2200      	movs	r2, #0
 8019884:	2101      	movs	r1, #1
 8019886:	2000      	movs	r0, #0
 8019888:	f7fe f907 	bl	8017a9a <l2cap_encanced_control_field_for_supevisor_frame>
 801988c:	4603      	mov	r3, r0
 801988e:	81fb      	strh	r3, [r7, #14]
        l2cap_ertm_send_supervisor_frame(channel, control);
 8019890:	89fb      	ldrh	r3, [r7, #14]
 8019892:	4619      	mov	r1, r3
 8019894:	6878      	ldr	r0, [r7, #4]
 8019896:	f7fe fc17 	bl	80180c8 <l2cap_ertm_send_supervisor_frame>
        return;
 801989a:	e0b4      	b.n	8019a06 <l2cap_run_for_classic_channel_ertm+0x246>
    }
    if (channel->send_supervisor_frame_receiver_not_ready){
 801989c:	687b      	ldr	r3, [r7, #4]
 801989e:	f893 3098 	ldrb.w	r3, [r3, #152]	; 0x98
 80198a2:	2b00      	cmp	r3, #0
 80198a4:	d01e      	beq.n	80198e4 <l2cap_run_for_classic_channel_ertm+0x124>
        channel->send_supervisor_frame_receiver_not_ready = 0;
 80198a6:	687b      	ldr	r3, [r7, #4]
 80198a8:	2200      	movs	r2, #0
 80198aa:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
        log_info("Send S-Frame: RNR %u", channel->req_seq);
 80198ae:	687b      	ldr	r3, [r7, #4]
 80198b0:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 80198b4:	9300      	str	r3, [sp, #0]
 80198b6:	f240 635c 	movw	r3, #1628	; 0x65c
 80198ba:	4a54      	ldr	r2, [pc, #336]	; (8019a0c <l2cap_run_for_classic_channel_ertm+0x24c>)
 80198bc:	4956      	ldr	r1, [pc, #344]	; (8019a18 <l2cap_run_for_classic_channel_ertm+0x258>)
 80198be:	2001      	movs	r0, #1
 80198c0:	f7fd fdbe 	bl	8017440 <hci_dump_log>
        uint16_t control = l2cap_encanced_control_field_for_supevisor_frame( L2CAP_SUPERVISORY_FUNCTION_RNR_RECEIVER_NOT_READY, 0, 0, channel->req_seq);
 80198c4:	687b      	ldr	r3, [r7, #4]
 80198c6:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 80198ca:	2200      	movs	r2, #0
 80198cc:	2100      	movs	r1, #0
 80198ce:	2002      	movs	r0, #2
 80198d0:	f7fe f8e3 	bl	8017a9a <l2cap_encanced_control_field_for_supevisor_frame>
 80198d4:	4603      	mov	r3, r0
 80198d6:	823b      	strh	r3, [r7, #16]
        l2cap_ertm_send_supervisor_frame(channel, control);
 80198d8:	8a3b      	ldrh	r3, [r7, #16]
 80198da:	4619      	mov	r1, r3
 80198dc:	6878      	ldr	r0, [r7, #4]
 80198de:	f7fe fbf3 	bl	80180c8 <l2cap_ertm_send_supervisor_frame>
        return;
 80198e2:	e090      	b.n	8019a06 <l2cap_run_for_classic_channel_ertm+0x246>
    }
    if (channel->send_supervisor_frame_reject){
 80198e4:	687b      	ldr	r3, [r7, #4]
 80198e6:	f893 3099 	ldrb.w	r3, [r3, #153]	; 0x99
 80198ea:	2b00      	cmp	r3, #0
 80198ec:	d01e      	beq.n	801992c <l2cap_run_for_classic_channel_ertm+0x16c>
        channel->send_supervisor_frame_reject = 0;
 80198ee:	687b      	ldr	r3, [r7, #4]
 80198f0:	2200      	movs	r2, #0
 80198f2:	f883 2099 	strb.w	r2, [r3, #153]	; 0x99
        log_info("Send S-Frame: REJ %u", channel->req_seq);
 80198f6:	687b      	ldr	r3, [r7, #4]
 80198f8:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 80198fc:	9300      	str	r3, [sp, #0]
 80198fe:	f240 6363 	movw	r3, #1635	; 0x663
 8019902:	4a42      	ldr	r2, [pc, #264]	; (8019a0c <l2cap_run_for_classic_channel_ertm+0x24c>)
 8019904:	4945      	ldr	r1, [pc, #276]	; (8019a1c <l2cap_run_for_classic_channel_ertm+0x25c>)
 8019906:	2001      	movs	r0, #1
 8019908:	f7fd fd9a 	bl	8017440 <hci_dump_log>
        uint16_t control = l2cap_encanced_control_field_for_supevisor_frame( L2CAP_SUPERVISORY_FUNCTION_REJ_REJECT, 0, 0, channel->req_seq);
 801990c:	687b      	ldr	r3, [r7, #4]
 801990e:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8019912:	2200      	movs	r2, #0
 8019914:	2100      	movs	r1, #0
 8019916:	2001      	movs	r0, #1
 8019918:	f7fe f8bf 	bl	8017a9a <l2cap_encanced_control_field_for_supevisor_frame>
 801991c:	4603      	mov	r3, r0
 801991e:	827b      	strh	r3, [r7, #18]
        l2cap_ertm_send_supervisor_frame(channel, control);
 8019920:	8a7b      	ldrh	r3, [r7, #18]
 8019922:	4619      	mov	r1, r3
 8019924:	6878      	ldr	r0, [r7, #4]
 8019926:	f7fe fbcf 	bl	80180c8 <l2cap_ertm_send_supervisor_frame>
        return;
 801992a:	e06c      	b.n	8019a06 <l2cap_run_for_classic_channel_ertm+0x246>
    }
    if (channel->send_supervisor_frame_selective_reject){
 801992c:	687b      	ldr	r3, [r7, #4]
 801992e:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
 8019932:	2b00      	cmp	r3, #0
 8019934:	d025      	beq.n	8019982 <l2cap_run_for_classic_channel_ertm+0x1c2>
        channel->send_supervisor_frame_selective_reject = 0;
 8019936:	687b      	ldr	r3, [r7, #4]
 8019938:	2200      	movs	r2, #0
 801993a:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
        log_info("Send S-Frame: SREJ %u", channel->expected_tx_seq);
 801993e:	687b      	ldr	r3, [r7, #4]
 8019940:	f893 3093 	ldrb.w	r3, [r3, #147]	; 0x93
 8019944:	9300      	str	r3, [sp, #0]
 8019946:	f240 636a 	movw	r3, #1642	; 0x66a
 801994a:	4a30      	ldr	r2, [pc, #192]	; (8019a0c <l2cap_run_for_classic_channel_ertm+0x24c>)
 801994c:	4934      	ldr	r1, [pc, #208]	; (8019a20 <l2cap_run_for_classic_channel_ertm+0x260>)
 801994e:	2001      	movs	r0, #1
 8019950:	f7fd fd76 	bl	8017440 <hci_dump_log>
        uint16_t control = l2cap_encanced_control_field_for_supevisor_frame( L2CAP_SUPERVISORY_FUNCTION_SREJ_SELECTIVE_REJECT, 0, channel->set_final_bit_after_packet_with_poll_bit_set, channel->expected_tx_seq);
 8019954:	687b      	ldr	r3, [r7, #4]
 8019956:	f893 309b 	ldrb.w	r3, [r3, #155]	; 0x9b
 801995a:	461a      	mov	r2, r3
 801995c:	687b      	ldr	r3, [r7, #4]
 801995e:	f893 3093 	ldrb.w	r3, [r3, #147]	; 0x93
 8019962:	2100      	movs	r1, #0
 8019964:	2003      	movs	r0, #3
 8019966:	f7fe f898 	bl	8017a9a <l2cap_encanced_control_field_for_supevisor_frame>
 801996a:	4603      	mov	r3, r0
 801996c:	82bb      	strh	r3, [r7, #20]
        channel->set_final_bit_after_packet_with_poll_bit_set = 0;
 801996e:	687b      	ldr	r3, [r7, #4]
 8019970:	2200      	movs	r2, #0
 8019972:	f883 209b 	strb.w	r2, [r3, #155]	; 0x9b
        l2cap_ertm_send_supervisor_frame(channel, control);
 8019976:	8abb      	ldrh	r3, [r7, #20]
 8019978:	4619      	mov	r1, r3
 801997a:	6878      	ldr	r0, [r7, #4]
 801997c:	f7fe fba4 	bl	80180c8 <l2cap_ertm_send_supervisor_frame>
        return;
 8019980:	e041      	b.n	8019a06 <l2cap_run_for_classic_channel_ertm+0x246>
    }

    if (channel->srej_active){
 8019982:	687b      	ldr	r3, [r7, #4]
 8019984:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8019988:	2b00      	cmp	r3, #0
 801998a:	d03c      	beq.n	8019a06 <l2cap_run_for_classic_channel_ertm+0x246>
        int i;
        for (i=0;i<channel->num_tx_buffers;i++){
 801998c:	2300      	movs	r3, #0
 801998e:	61fb      	str	r3, [r7, #28]
 8019990:	e01f      	b.n	80199d2 <l2cap_run_for_classic_channel_ertm+0x212>
            l2cap_ertm_tx_packet_state_t * tx_state = &channel->tx_packets_state[i];
 8019992:	687b      	ldr	r3, [r7, #4]
 8019994:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 8019998:	69fb      	ldr	r3, [r7, #28]
 801999a:	00db      	lsls	r3, r3, #3
 801999c:	4413      	add	r3, r2
 801999e:	61bb      	str	r3, [r7, #24]
            if (tx_state->retransmission_requested) {
 80199a0:	69bb      	ldr	r3, [r7, #24]
 80199a2:	799b      	ldrb	r3, [r3, #6]
 80199a4:	2b00      	cmp	r3, #0
 80199a6:	d011      	beq.n	80199cc <l2cap_run_for_classic_channel_ertm+0x20c>
                tx_state->retransmission_requested = 0;
 80199a8:	69bb      	ldr	r3, [r7, #24]
 80199aa:	2200      	movs	r2, #0
 80199ac:	719a      	strb	r2, [r3, #6]
                uint8_t final = channel->set_final_bit_after_packet_with_poll_bit_set;
 80199ae:	687b      	ldr	r3, [r7, #4]
 80199b0:	f893 309b 	ldrb.w	r3, [r3, #155]	; 0x9b
 80199b4:	75fb      	strb	r3, [r7, #23]
                channel->set_final_bit_after_packet_with_poll_bit_set = 0;
 80199b6:	687b      	ldr	r3, [r7, #4]
 80199b8:	2200      	movs	r2, #0
 80199ba:	f883 209b 	strb.w	r2, [r3, #155]	; 0x9b
                l2cap_ertm_send_information_frame(channel, i, final);
 80199be:	7dfb      	ldrb	r3, [r7, #23]
 80199c0:	461a      	mov	r2, r3
 80199c2:	69f9      	ldr	r1, [r7, #28]
 80199c4:	6878      	ldr	r0, [r7, #4]
 80199c6:	f7fe fa05 	bl	8017dd4 <l2cap_ertm_send_information_frame>
                break;
 80199ca:	e009      	b.n	80199e0 <l2cap_run_for_classic_channel_ertm+0x220>
        for (i=0;i<channel->num_tx_buffers;i++){
 80199cc:	69fb      	ldr	r3, [r7, #28]
 80199ce:	3301      	adds	r3, #1
 80199d0:	61fb      	str	r3, [r7, #28]
 80199d2:	687b      	ldr	r3, [r7, #4]
 80199d4:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
 80199d8:	461a      	mov	r2, r3
 80199da:	69fb      	ldr	r3, [r7, #28]
 80199dc:	4293      	cmp	r3, r2
 80199de:	dbd8      	blt.n	8019992 <l2cap_run_for_classic_channel_ertm+0x1d2>
            }
        }
        if (i == channel->num_tx_buffers){
 80199e0:	687b      	ldr	r3, [r7, #4]
 80199e2:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
 80199e6:	461a      	mov	r2, r3
 80199e8:	69fb      	ldr	r3, [r7, #28]
 80199ea:	4293      	cmp	r3, r2
 80199ec:	d10a      	bne.n	8019a04 <l2cap_run_for_classic_channel_ertm+0x244>
            // no retransmission request found
            channel->srej_active = 0;
 80199ee:	687b      	ldr	r3, [r7, #4]
 80199f0:	2200      	movs	r2, #0
 80199f2:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
 80199f6:	e006      	b.n	8019a06 <l2cap_run_for_classic_channel_ertm+0x246>
    if (channel->mode != L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION) return;
 80199f8:	bf00      	nop
 80199fa:	e004      	b.n	8019a06 <l2cap_run_for_classic_channel_ertm+0x246>
    if (channel->con_handle == HCI_CON_HANDLE_INVALID) return;
 80199fc:	bf00      	nop
 80199fe:	e002      	b.n	8019a06 <l2cap_run_for_classic_channel_ertm+0x246>
    if (!hci_can_send_acl_packet_now(channel->con_handle)) return;
 8019a00:	bf00      	nop
 8019a02:	e000      	b.n	8019a06 <l2cap_run_for_classic_channel_ertm+0x246>
        } else {
            // packet was sent
            return;
 8019a04:	bf00      	nop
        }
    }
}
 8019a06:	3720      	adds	r7, #32
 8019a08:	46bd      	mov	sp, r7
 8019a0a:	bd80      	pop	{r7, pc}
 8019a0c:	0802b1dc 	.word	0x0802b1dc
 8019a10:	0802bc28 	.word	0x0802bc28
 8019a14:	0802bc50 	.word	0x0802bc50
 8019a18:	0802bc78 	.word	0x0802bc78
 8019a1c:	0802bc94 	.word	0x0802bc94
 8019a20:	0802bcb0 	.word	0x0802bcb0

08019a24 <l2cap_run_signaling_response>:
#endif /* ERTM */
#endif /* Classic */

static void l2cap_run_signaling_response(void) {
 8019a24:	b590      	push	{r4, r7, lr}
 8019a26:	b08d      	sub	sp, #52	; 0x34
 8019a28:	af04      	add	r7, sp, #16

    // check pending signaling responses
    while (signaling_responses_pending){
 8019a2a:	e117      	b.n	8019c5c <l2cap_run_signaling_response+0x238>

        hci_con_handle_t handle = signaling_responses[0].handle;
 8019a2c:	4b91      	ldr	r3, [pc, #580]	; (8019c74 <l2cap_run_signaling_response+0x250>)
 8019a2e:	881b      	ldrh	r3, [r3, #0]
 8019a30:	837b      	strh	r3, [r7, #26]

        if (!hci_can_send_acl_packet_now(handle)) break;
 8019a32:	8b7b      	ldrh	r3, [r7, #26]
 8019a34:	4618      	mov	r0, r3
 8019a36:	f7f6 fad3 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019a3a:	4603      	mov	r3, r0
 8019a3c:	2b00      	cmp	r3, #0
 8019a3e:	f000 8113 	beq.w	8019c68 <l2cap_run_signaling_response+0x244>

        uint8_t  sig_id        = signaling_responses[0].sig_id;
 8019a42:	4b8c      	ldr	r3, [pc, #560]	; (8019c74 <l2cap_run_signaling_response+0x250>)
 8019a44:	789b      	ldrb	r3, [r3, #2]
 8019a46:	767b      	strb	r3, [r7, #25]
        uint8_t  response_code = signaling_responses[0].code;
 8019a48:	4b8a      	ldr	r3, [pc, #552]	; (8019c74 <l2cap_run_signaling_response+0x250>)
 8019a4a:	78db      	ldrb	r3, [r3, #3]
 8019a4c:	763b      	strb	r3, [r7, #24]
        uint16_t result        = signaling_responses[0].data;  // CONNECTION_REQUEST, COMMAND_REJECT
 8019a4e:	4b89      	ldr	r3, [pc, #548]	; (8019c74 <l2cap_run_signaling_response+0x250>)
 8019a50:	88db      	ldrh	r3, [r3, #6]
 8019a52:	82fb      	strh	r3, [r7, #22]
#ifdef ENABLE_CLASSIC
        uint16_t info_type     = signaling_responses[0].data;  // INFORMATION_REQUEST
 8019a54:	4b87      	ldr	r3, [pc, #540]	; (8019c74 <l2cap_run_signaling_response+0x250>)
 8019a56:	88db      	ldrh	r3, [r3, #6]
 8019a58:	82bb      	strh	r3, [r7, #20]
        uint16_t source_cid    = signaling_responses[0].cid;   // CONNECTION_REQUEST
 8019a5a:	4b86      	ldr	r3, [pc, #536]	; (8019c74 <l2cap_run_signaling_response+0x250>)
 8019a5c:	889b      	ldrh	r3, [r3, #4]
 8019a5e:	827b      	strh	r3, [r7, #18]
#endif

        // remove first item before sending (to avoid sending response mutliple times)
        signaling_responses_pending--;
 8019a60:	4b85      	ldr	r3, [pc, #532]	; (8019c78 <l2cap_run_signaling_response+0x254>)
 8019a62:	681b      	ldr	r3, [r3, #0]
 8019a64:	3b01      	subs	r3, #1
 8019a66:	4a84      	ldr	r2, [pc, #528]	; (8019c78 <l2cap_run_signaling_response+0x254>)
 8019a68:	6013      	str	r3, [r2, #0]
        int i;
        for (i=0; i < signaling_responses_pending; i++){
 8019a6a:	2300      	movs	r3, #0
 8019a6c:	61fb      	str	r3, [r7, #28]
 8019a6e:	e00f      	b.n	8019a90 <l2cap_run_signaling_response+0x6c>
            (void)memcpy(&signaling_responses[i],
 8019a70:	69fb      	ldr	r3, [r7, #28]
 8019a72:	00db      	lsls	r3, r3, #3
 8019a74:	4a7f      	ldr	r2, [pc, #508]	; (8019c74 <l2cap_run_signaling_response+0x250>)
 8019a76:	1898      	adds	r0, r3, r2
                         &signaling_responses[i + 1],
 8019a78:	69fb      	ldr	r3, [r7, #28]
 8019a7a:	3301      	adds	r3, #1
 8019a7c:	00db      	lsls	r3, r3, #3
 8019a7e:	4a7d      	ldr	r2, [pc, #500]	; (8019c74 <l2cap_run_signaling_response+0x250>)
 8019a80:	4413      	add	r3, r2
            (void)memcpy(&signaling_responses[i],
 8019a82:	2208      	movs	r2, #8
 8019a84:	4619      	mov	r1, r3
 8019a86:	f00d fff8 	bl	8027a7a <memcpy>
        for (i=0; i < signaling_responses_pending; i++){
 8019a8a:	69fb      	ldr	r3, [r7, #28]
 8019a8c:	3301      	adds	r3, #1
 8019a8e:	61fb      	str	r3, [r7, #28]
 8019a90:	4b79      	ldr	r3, [pc, #484]	; (8019c78 <l2cap_run_signaling_response+0x254>)
 8019a92:	681b      	ldr	r3, [r3, #0]
 8019a94:	69fa      	ldr	r2, [r7, #28]
 8019a96:	429a      	cmp	r2, r3
 8019a98:	dbea      	blt.n	8019a70 <l2cap_run_signaling_response+0x4c>
                         sizeof(l2cap_signaling_response_t));
        }

        switch (response_code){
 8019a9a:	7e3b      	ldrb	r3, [r7, #24]
 8019a9c:	3b01      	subs	r3, #1
 8019a9e:	2b1e      	cmp	r3, #30
 8019aa0:	f200 80db 	bhi.w	8019c5a <l2cap_run_signaling_response+0x236>
 8019aa4:	a201      	add	r2, pc, #4	; (adr r2, 8019aac <l2cap_run_signaling_response+0x88>)
 8019aa6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019aaa:	bf00      	nop
 8019aac:	08019c0d 	.word	0x08019c0d
 8019ab0:	08019b29 	.word	0x08019b29
 8019ab4:	08019c5b 	.word	0x08019c5b
 8019ab8:	08019c5b 	.word	0x08019c5b
 8019abc:	08019c5b 	.word	0x08019c5b
 8019ac0:	08019c5b 	.word	0x08019c5b
 8019ac4:	08019c5b 	.word	0x08019c5b
 8019ac8:	08019b57 	.word	0x08019b57
 8019acc:	08019c5b 	.word	0x08019c5b
 8019ad0:	08019b69 	.word	0x08019b69
 8019ad4:	08019c5b 	.word	0x08019c5b
 8019ad8:	08019c5b 	.word	0x08019c5b
 8019adc:	08019c5b 	.word	0x08019c5b
 8019ae0:	08019c5b 	.word	0x08019c5b
 8019ae4:	08019c5b 	.word	0x08019c5b
 8019ae8:	08019c5b 	.word	0x08019c5b
 8019aec:	08019c5b 	.word	0x08019c5b
 8019af0:	08019c5b 	.word	0x08019c5b
 8019af4:	08019c5b 	.word	0x08019c5b
 8019af8:	08019c25 	.word	0x08019c25
 8019afc:	08019c5b 	.word	0x08019c5b
 8019b00:	08019c5b 	.word	0x08019c5b
 8019b04:	08019c5b 	.word	0x08019c5b
 8019b08:	08019c5b 	.word	0x08019c5b
 8019b0c:	08019c5b 	.word	0x08019c5b
 8019b10:	08019c5b 	.word	0x08019c5b
 8019b14:	08019c5b 	.word	0x08019c5b
 8019b18:	08019c5b 	.word	0x08019c5b
 8019b1c:	08019c5b 	.word	0x08019c5b
 8019b20:	08019c5b 	.word	0x08019c5b
 8019b24:	08019c43 	.word	0x08019c43
#ifdef ENABLE_CLASSIC
            case CONNECTION_REQUEST:
                l2cap_send_signaling_packet(handle, CONNECTION_RESPONSE, sig_id, source_cid, 0, result, 0);
 8019b28:	7e79      	ldrb	r1, [r7, #25]
 8019b2a:	8a7c      	ldrh	r4, [r7, #18]
 8019b2c:	8afb      	ldrh	r3, [r7, #22]
 8019b2e:	8b78      	ldrh	r0, [r7, #26]
 8019b30:	2200      	movs	r2, #0
 8019b32:	9202      	str	r2, [sp, #8]
 8019b34:	9301      	str	r3, [sp, #4]
 8019b36:	2300      	movs	r3, #0
 8019b38:	9300      	str	r3, [sp, #0]
 8019b3a:	4623      	mov	r3, r4
 8019b3c:	460a      	mov	r2, r1
 8019b3e:	2103      	movs	r1, #3
 8019b40:	f7ff f9b0 	bl	8018ea4 <l2cap_send_signaling_packet>
                // also disconnect if result is 0x0003 - security blocked
                if (result == 0x0003){
 8019b44:	8afb      	ldrh	r3, [r7, #22]
 8019b46:	2b03      	cmp	r3, #3
 8019b48:	f040 8088 	bne.w	8019c5c <l2cap_run_signaling_response+0x238>
                    hci_disconnect_security_block(handle);
 8019b4c:	8b7b      	ldrh	r3, [r7, #26]
 8019b4e:	4618      	mov	r0, r3
 8019b50:	f7fc f9e8 	bl	8015f24 <hci_disconnect_security_block>
                }
                break;
 8019b54:	e082      	b.n	8019c5c <l2cap_run_signaling_response+0x238>
            case ECHO_REQUEST:
                l2cap_send_signaling_packet(handle, ECHO_RESPONSE, sig_id, 0, NULL);
 8019b56:	7e7a      	ldrb	r2, [r7, #25]
 8019b58:	8b78      	ldrh	r0, [r7, #26]
 8019b5a:	2300      	movs	r3, #0
 8019b5c:	9300      	str	r3, [sp, #0]
 8019b5e:	2300      	movs	r3, #0
 8019b60:	2109      	movs	r1, #9
 8019b62:	f7ff f99f 	bl	8018ea4 <l2cap_send_signaling_packet>
                break;
 8019b66:	e079      	b.n	8019c5c <l2cap_run_signaling_response+0x238>
            case INFORMATION_REQUEST:
                switch (info_type){
 8019b68:	8abb      	ldrh	r3, [r7, #20]
 8019b6a:	2b02      	cmp	r3, #2
 8019b6c:	d016      	beq.n	8019b9c <l2cap_run_signaling_response+0x178>
 8019b6e:	2b03      	cmp	r3, #3
 8019b70:	d027      	beq.n	8019bc2 <l2cap_run_signaling_response+0x19e>
 8019b72:	2b01      	cmp	r3, #1
 8019b74:	d13b      	bne.n	8019bee <l2cap_run_signaling_response+0x1ca>
                    case L2CAP_INFO_TYPE_CONNECTIONLESS_MTU: {
                            uint16_t connectionless_mtu = hci_max_acl_data_packet_length();
 8019b76:	f7f6 fe19 	bl	80107ac <hci_max_acl_data_packet_length>
 8019b7a:	4603      	mov	r3, r0
 8019b7c:	823b      	strh	r3, [r7, #16]
                            l2cap_send_signaling_packet(handle, INFORMATION_RESPONSE, sig_id, info_type, 0, sizeof(connectionless_mtu), &connectionless_mtu);
 8019b7e:	7e7a      	ldrb	r2, [r7, #25]
 8019b80:	8ab9      	ldrh	r1, [r7, #20]
 8019b82:	8b78      	ldrh	r0, [r7, #26]
 8019b84:	f107 0310 	add.w	r3, r7, #16
 8019b88:	9302      	str	r3, [sp, #8]
 8019b8a:	2302      	movs	r3, #2
 8019b8c:	9301      	str	r3, [sp, #4]
 8019b8e:	2300      	movs	r3, #0
 8019b90:	9300      	str	r3, [sp, #0]
 8019b92:	460b      	mov	r3, r1
 8019b94:	210b      	movs	r1, #11
 8019b96:	f7ff f985 	bl	8018ea4 <l2cap_send_signaling_packet>
                        }
                        break;
 8019b9a:	e036      	b.n	8019c0a <l2cap_run_signaling_response+0x1e6>
                    case L2CAP_INFO_TYPE_EXTENDED_FEATURES_SUPPORTED: {
                            uint32_t features = l2cap_extended_features_mask();
 8019b9c:	f7ff fb52 	bl	8019244 <l2cap_extended_features_mask>
 8019ba0:	4603      	mov	r3, r0
 8019ba2:	60fb      	str	r3, [r7, #12]
                            l2cap_send_signaling_packet(handle, INFORMATION_RESPONSE, sig_id, info_type, 0, sizeof(features), &features);
 8019ba4:	7e7a      	ldrb	r2, [r7, #25]
 8019ba6:	8ab9      	ldrh	r1, [r7, #20]
 8019ba8:	8b78      	ldrh	r0, [r7, #26]
 8019baa:	f107 030c 	add.w	r3, r7, #12
 8019bae:	9302      	str	r3, [sp, #8]
 8019bb0:	2304      	movs	r3, #4
 8019bb2:	9301      	str	r3, [sp, #4]
 8019bb4:	2300      	movs	r3, #0
 8019bb6:	9300      	str	r3, [sp, #0]
 8019bb8:	460b      	mov	r3, r1
 8019bba:	210b      	movs	r1, #11
 8019bbc:	f7ff f972 	bl	8018ea4 <l2cap_send_signaling_packet>
                        }
                        break;
 8019bc0:	e023      	b.n	8019c0a <l2cap_run_signaling_response+0x1e6>
                    case L2CAP_INFO_TYPE_FIXED_CHANNELS_SUPPORTED: {
                            uint8_t map[8];
                            memset(map, 0, 8);
 8019bc2:	1d3b      	adds	r3, r7, #4
 8019bc4:	2208      	movs	r2, #8
 8019bc6:	2100      	movs	r1, #0
 8019bc8:	4618      	mov	r0, r3
 8019bca:	f00d ff7a 	bl	8027ac2 <memset>
                            map[0] = 0x06;  // L2CAP Signaling Channel (0x02) + Connectionless reception (0x04)
 8019bce:	2306      	movs	r3, #6
 8019bd0:	713b      	strb	r3, [r7, #4]
                            l2cap_send_signaling_packet(handle, INFORMATION_RESPONSE, sig_id, info_type, 0, sizeof(map), &map);
 8019bd2:	7e7a      	ldrb	r2, [r7, #25]
 8019bd4:	8ab9      	ldrh	r1, [r7, #20]
 8019bd6:	8b78      	ldrh	r0, [r7, #26]
 8019bd8:	1d3b      	adds	r3, r7, #4
 8019bda:	9302      	str	r3, [sp, #8]
 8019bdc:	2308      	movs	r3, #8
 8019bde:	9301      	str	r3, [sp, #4]
 8019be0:	2300      	movs	r3, #0
 8019be2:	9300      	str	r3, [sp, #0]
 8019be4:	460b      	mov	r3, r1
 8019be6:	210b      	movs	r1, #11
 8019be8:	f7ff f95c 	bl	8018ea4 <l2cap_send_signaling_packet>
                        }
                        break;
 8019bec:	e00d      	b.n	8019c0a <l2cap_run_signaling_response+0x1e6>
                    default:
                        // all other types are not supported
                        l2cap_send_signaling_packet(handle, INFORMATION_RESPONSE, sig_id, info_type, 1, 0, NULL);
 8019bee:	7e7a      	ldrb	r2, [r7, #25]
 8019bf0:	8ab9      	ldrh	r1, [r7, #20]
 8019bf2:	8b78      	ldrh	r0, [r7, #26]
 8019bf4:	2300      	movs	r3, #0
 8019bf6:	9302      	str	r3, [sp, #8]
 8019bf8:	2300      	movs	r3, #0
 8019bfa:	9301      	str	r3, [sp, #4]
 8019bfc:	2301      	movs	r3, #1
 8019bfe:	9300      	str	r3, [sp, #0]
 8019c00:	460b      	mov	r3, r1
 8019c02:	210b      	movs	r1, #11
 8019c04:	f7ff f94e 	bl	8018ea4 <l2cap_send_signaling_packet>
                        break;
 8019c08:	bf00      	nop
                }
                break;
 8019c0a:	e027      	b.n	8019c5c <l2cap_run_signaling_response+0x238>
            case COMMAND_REJECT:
                l2cap_send_signaling_packet(handle, COMMAND_REJECT, sig_id, result, 0, NULL);
 8019c0c:	7e7a      	ldrb	r2, [r7, #25]
 8019c0e:	8af9      	ldrh	r1, [r7, #22]
 8019c10:	8b78      	ldrh	r0, [r7, #26]
 8019c12:	2300      	movs	r3, #0
 8019c14:	9301      	str	r3, [sp, #4]
 8019c16:	2300      	movs	r3, #0
 8019c18:	9300      	str	r3, [sp, #0]
 8019c1a:	460b      	mov	r3, r1
 8019c1c:	2101      	movs	r1, #1
 8019c1e:	f7ff f941 	bl	8018ea4 <l2cap_send_signaling_packet>
                break;
 8019c22:	e01b      	b.n	8019c5c <l2cap_run_signaling_response+0x238>
#endif
#ifdef ENABLE_BLE
            case LE_CREDIT_BASED_CONNECTION_REQUEST:
                l2cap_send_le_signaling_packet(handle, LE_CREDIT_BASED_CONNECTION_RESPONSE, sig_id, 0, 0, 0, 0, result);
 8019c24:	7e7a      	ldrb	r2, [r7, #25]
 8019c26:	8afb      	ldrh	r3, [r7, #22]
 8019c28:	8b78      	ldrh	r0, [r7, #26]
 8019c2a:	9303      	str	r3, [sp, #12]
 8019c2c:	2300      	movs	r3, #0
 8019c2e:	9302      	str	r3, [sp, #8]
 8019c30:	2300      	movs	r3, #0
 8019c32:	9301      	str	r3, [sp, #4]
 8019c34:	2300      	movs	r3, #0
 8019c36:	9300      	str	r3, [sp, #0]
 8019c38:	2300      	movs	r3, #0
 8019c3a:	2115      	movs	r1, #21
 8019c3c:	f7ff fa38 	bl	80190b0 <l2cap_send_le_signaling_packet>
                break;
 8019c40:	e00c      	b.n	8019c5c <l2cap_run_signaling_response+0x238>
            case COMMAND_REJECT_LE:
                l2cap_send_le_signaling_packet(handle, COMMAND_REJECT, sig_id, result, 0, NULL);
 8019c42:	7e7a      	ldrb	r2, [r7, #25]
 8019c44:	8af9      	ldrh	r1, [r7, #22]
 8019c46:	8b78      	ldrh	r0, [r7, #26]
 8019c48:	2300      	movs	r3, #0
 8019c4a:	9301      	str	r3, [sp, #4]
 8019c4c:	2300      	movs	r3, #0
 8019c4e:	9300      	str	r3, [sp, #0]
 8019c50:	460b      	mov	r3, r1
 8019c52:	2101      	movs	r1, #1
 8019c54:	f7ff fa2c 	bl	80190b0 <l2cap_send_le_signaling_packet>
                break;
 8019c58:	e000      	b.n	8019c5c <l2cap_run_signaling_response+0x238>
#endif
            default:
                // should not happen
                break;
 8019c5a:	bf00      	nop
    while (signaling_responses_pending){
 8019c5c:	4b06      	ldr	r3, [pc, #24]	; (8019c78 <l2cap_run_signaling_response+0x254>)
 8019c5e:	681b      	ldr	r3, [r3, #0]
 8019c60:	2b00      	cmp	r3, #0
 8019c62:	f47f aee3 	bne.w	8019a2c <l2cap_run_signaling_response+0x8>
        }
    }
}
 8019c66:	e000      	b.n	8019c6a <l2cap_run_signaling_response+0x246>
        if (!hci_can_send_acl_packet_now(handle)) break;
 8019c68:	bf00      	nop
}
 8019c6a:	bf00      	nop
 8019c6c:	3724      	adds	r7, #36	; 0x24
 8019c6e:	46bd      	mov	sp, r7
 8019c70:	bd90      	pop	{r4, r7, pc}
 8019c72:	bf00      	nop
 8019c74:	20009eb4 	.word	0x20009eb4
 8019c78:	20009ecc 	.word	0x20009ecc

08019c7c <l2ap_run_ertm>:

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
static bool l2ap_run_ertm(void){
 8019c7c:	b580      	push	{r7, lr}
 8019c7e:	b086      	sub	sp, #24
 8019c80:	af00      	add	r7, sp, #0
    // send l2cap information request if neccessary
    btstack_linked_list_iterator_t it;
    hci_connections_get_iterator(&it);
 8019c82:	1d3b      	adds	r3, r7, #4
 8019c84:	4618      	mov	r0, r3
 8019c86:	f7f5 fe0b 	bl	800f8a0 <hci_connections_get_iterator>
    while(btstack_linked_list_iterator_has_next(&it)){
 8019c8a:	e024      	b.n	8019cd6 <l2ap_run_ertm+0x5a>
        hci_connection_t * connection = (hci_connection_t *) btstack_linked_list_iterator_next(&it);
 8019c8c:	1d3b      	adds	r3, r7, #4
 8019c8e:	4618      	mov	r0, r3
 8019c90:	f7f4 fda0 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8019c94:	6178      	str	r0, [r7, #20]
        if (connection->l2cap_state.information_state == L2CAP_INFORMATION_STATE_W2_SEND_EXTENDED_FEATURE_REQUEST){
 8019c96:	697b      	ldr	r3, [r7, #20]
 8019c98:	f893 3e24 	ldrb.w	r3, [r3, #3620]	; 0xe24
 8019c9c:	2b01      	cmp	r3, #1
 8019c9e:	d11a      	bne.n	8019cd6 <l2ap_run_ertm+0x5a>
            if (!hci_can_send_acl_packet_now(connection->con_handle)) break;
 8019ca0:	697b      	ldr	r3, [r7, #20]
 8019ca2:	895b      	ldrh	r3, [r3, #10]
 8019ca4:	4618      	mov	r0, r3
 8019ca6:	f7f6 f99b 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019caa:	4603      	mov	r3, r0
 8019cac:	2b00      	cmp	r3, #0
 8019cae:	d01a      	beq.n	8019ce6 <l2ap_run_ertm+0x6a>
            connection->l2cap_state.information_state = L2CAP_INFORMATION_STATE_W4_EXTENDED_FEATURE_RESPONSE;
 8019cb0:	697b      	ldr	r3, [r7, #20]
 8019cb2:	2202      	movs	r2, #2
 8019cb4:	f883 2e24 	strb.w	r2, [r3, #3620]	; 0xe24
            uint8_t sig_id = l2cap_next_sig_id();
 8019cb8:	f7fe fc66 	bl	8018588 <l2cap_next_sig_id>
 8019cbc:	4603      	mov	r3, r0
 8019cbe:	74fb      	strb	r3, [r7, #19]
            uint8_t info_type = L2CAP_INFO_TYPE_EXTENDED_FEATURES_SUPPORTED;
 8019cc0:	2302      	movs	r3, #2
 8019cc2:	74bb      	strb	r3, [r7, #18]
            l2cap_send_signaling_packet(connection->con_handle, INFORMATION_REQUEST, sig_id, info_type);
 8019cc4:	697b      	ldr	r3, [r7, #20]
 8019cc6:	8958      	ldrh	r0, [r3, #10]
 8019cc8:	7cfa      	ldrb	r2, [r7, #19]
 8019cca:	7cbb      	ldrb	r3, [r7, #18]
 8019ccc:	210a      	movs	r1, #10
 8019cce:	f7ff f8e9 	bl	8018ea4 <l2cap_send_signaling_packet>
            return true;
 8019cd2:	2301      	movs	r3, #1
 8019cd4:	e009      	b.n	8019cea <l2ap_run_ertm+0x6e>
    while(btstack_linked_list_iterator_has_next(&it)){
 8019cd6:	1d3b      	adds	r3, r7, #4
 8019cd8:	4618      	mov	r0, r3
 8019cda:	f7f4 fd4d 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8019cde:	4603      	mov	r3, r0
 8019ce0:	2b00      	cmp	r3, #0
 8019ce2:	d1d3      	bne.n	8019c8c <l2ap_run_ertm+0x10>
 8019ce4:	e000      	b.n	8019ce8 <l2ap_run_ertm+0x6c>
            if (!hci_can_send_acl_packet_now(connection->con_handle)) break;
 8019ce6:	bf00      	nop
        }
    }
    return false;
 8019ce8:	2300      	movs	r3, #0
}
 8019cea:	4618      	mov	r0, r3
 8019cec:	3718      	adds	r7, #24
 8019cee:	46bd      	mov	sp, r7
 8019cf0:	bd80      	pop	{r7, pc}
	...

08019cf4 <l2cap_run_le_data_channels>:
#endif

#ifdef ENABLE_LE_DATA_CHANNELS
static void l2cap_run_le_data_channels(void){
 8019cf4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8019cf6:	b08b      	sub	sp, #44	; 0x2c
 8019cf8:	af04      	add	r7, sp, #16
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &l2cap_channels);
 8019cfa:	1d3b      	adds	r3, r7, #4
 8019cfc:	49b4      	ldr	r1, [pc, #720]	; (8019fd0 <l2cap_run_le_data_channels+0x2dc>)
 8019cfe:	4618      	mov	r0, r3
 8019d00:	f7f4 fd25 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 8019d04:	e16b      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>
        uint16_t mps;
        l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 8019d06:	1d3b      	adds	r3, r7, #4
 8019d08:	4618      	mov	r0, r3
 8019d0a:	f7f4 fd63 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8019d0e:	6178      	str	r0, [r7, #20]

        if (channel->channel_type != L2CAP_CHANNEL_TYPE_LE_DATA_CHANNEL) continue;
 8019d10:	697b      	ldr	r3, [r7, #20]
 8019d12:	791b      	ldrb	r3, [r3, #4]
 8019d14:	2b02      	cmp	r3, #2
 8019d16:	d000      	beq.n	8019d1a <l2cap_run_le_data_channels+0x26>
 8019d18:	e161      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>

        // log_info("l2cap_run: channel %p, state %u, var 0x%02x", channel, channel->state, channel->state_var);
        switch (channel->state){
 8019d1a:	697b      	ldr	r3, [r7, #20]
 8019d1c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8019d20:	3b0c      	subs	r3, #12
 8019d22:	2b0a      	cmp	r3, #10
 8019d24:	f200 815a 	bhi.w	8019fdc <l2cap_run_le_data_channels+0x2e8>
 8019d28:	a201      	add	r2, pc, #4	; (adr r2, 8019d30 <l2cap_run_le_data_channels+0x3c>)
 8019d2a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019d2e:	bf00      	nop
 8019d30:	08019ec3 	.word	0x08019ec3
 8019d34:	08019fdd 	.word	0x08019fdd
 8019d38:	08019fdd 	.word	0x08019fdd
 8019d3c:	08019fdd 	.word	0x08019fdd
 8019d40:	08019fdd 	.word	0x08019fdd
 8019d44:	08019fdd 	.word	0x08019fdd
 8019d48:	08019f45 	.word	0x08019f45
 8019d4c:	08019f8f 	.word	0x08019f8f
 8019d50:	08019d5d 	.word	0x08019d5d
 8019d54:	08019e71 	.word	0x08019e71
 8019d58:	08019deb 	.word	0x08019deb
            case L2CAP_STATE_WILL_SEND_LE_CONNECTION_REQUEST:
                if (!hci_can_send_acl_packet_now(channel->con_handle)) break;
 8019d5c:	697b      	ldr	r3, [r7, #20]
 8019d5e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8019d60:	4618      	mov	r0, r3
 8019d62:	f7f6 f93d 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019d66:	4603      	mov	r3, r0
 8019d68:	2b00      	cmp	r3, #0
 8019d6a:	d100      	bne.n	8019d6e <l2cap_run_le_data_channels+0x7a>
 8019d6c:	e137      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>
                channel->state = L2CAP_STATE_WAIT_LE_CONNECTION_RESPONSE;
 8019d6e:	697b      	ldr	r3, [r7, #20]
 8019d70:	2217      	movs	r2, #23
 8019d72:	f883 2020 	strb.w	r2, [r3, #32]
                // le psm, source cid, mtu, mps, initial credits
                channel->local_sig_id = l2cap_next_sig_id();
 8019d76:	f7fe fc07 	bl	8018588 <l2cap_next_sig_id>
 8019d7a:	4603      	mov	r3, r0
 8019d7c:	461a      	mov	r2, r3
 8019d7e:	697b      	ldr	r3, [r7, #20]
 8019d80:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
                channel->credits_incoming =  channel->new_credits_incoming;
 8019d84:	697b      	ldr	r3, [r7, #20]
 8019d86:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 8019d8a:	697b      	ldr	r3, [r7, #20]
 8019d8c:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
                channel->new_credits_incoming = 0;
 8019d90:	697b      	ldr	r3, [r7, #20]
 8019d92:	2200      	movs	r2, #0
 8019d94:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
                mps = btstack_min(l2cap_max_le_mtu(), channel->local_mtu);
 8019d98:	f7ff f9d2 	bl	8019140 <l2cap_max_le_mtu>
 8019d9c:	4603      	mov	r3, r0
 8019d9e:	461a      	mov	r2, r3
 8019da0:	697b      	ldr	r3, [r7, #20]
 8019da2:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8019da4:	4619      	mov	r1, r3
 8019da6:	4610      	mov	r0, r2
 8019da8:	f7f5 f9b1 	bl	800f10e <btstack_min>
 8019dac:	4603      	mov	r3, r0
 8019dae:	827b      	strh	r3, [r7, #18]
                l2cap_send_le_signaling_packet( channel->con_handle, LE_CREDIT_BASED_CONNECTION_REQUEST, channel->local_sig_id, channel->psm, channel->local_cid, channel->local_mtu, mps, channel->credits_incoming);
 8019db0:	697b      	ldr	r3, [r7, #20]
 8019db2:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 8019db4:	697b      	ldr	r3, [r7, #20]
 8019db6:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8019dba:	461d      	mov	r5, r3
 8019dbc:	697b      	ldr	r3, [r7, #20]
 8019dbe:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8019dc0:	461e      	mov	r6, r3
 8019dc2:	697b      	ldr	r3, [r7, #20]
 8019dc4:	88db      	ldrh	r3, [r3, #6]
 8019dc6:	4619      	mov	r1, r3
 8019dc8:	697b      	ldr	r3, [r7, #20]
 8019dca:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8019dcc:	461c      	mov	r4, r3
 8019dce:	8a7b      	ldrh	r3, [r7, #18]
 8019dd0:	697a      	ldr	r2, [r7, #20]
 8019dd2:	f8b2 2052 	ldrh.w	r2, [r2, #82]	; 0x52
 8019dd6:	9203      	str	r2, [sp, #12]
 8019dd8:	9302      	str	r3, [sp, #8]
 8019dda:	9401      	str	r4, [sp, #4]
 8019ddc:	9100      	str	r1, [sp, #0]
 8019dde:	4633      	mov	r3, r6
 8019de0:	462a      	mov	r2, r5
 8019de2:	2114      	movs	r1, #20
 8019de4:	f7ff f964 	bl	80190b0 <l2cap_send_le_signaling_packet>
                break;
 8019de8:	e0f9      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>
            case L2CAP_STATE_WILL_SEND_LE_CONNECTION_RESPONSE_ACCEPT:
                if (!hci_can_send_acl_packet_now(channel->con_handle)) break;
 8019dea:	697b      	ldr	r3, [r7, #20]
 8019dec:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8019dee:	4618      	mov	r0, r3
 8019df0:	f7f6 f8f6 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019df4:	4603      	mov	r3, r0
 8019df6:	2b00      	cmp	r3, #0
 8019df8:	d100      	bne.n	8019dfc <l2cap_run_le_data_channels+0x108>
 8019dfa:	e0f0      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>
                // TODO: support larger MPS
                channel->state = L2CAP_STATE_OPEN;
 8019dfc:	697b      	ldr	r3, [r7, #20]
 8019dfe:	220c      	movs	r2, #12
 8019e00:	f883 2020 	strb.w	r2, [r3, #32]
                channel->credits_incoming =  channel->new_credits_incoming;
 8019e04:	697b      	ldr	r3, [r7, #20]
 8019e06:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 8019e0a:	697b      	ldr	r3, [r7, #20]
 8019e0c:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
                channel->new_credits_incoming = 0;
 8019e10:	697b      	ldr	r3, [r7, #20]
 8019e12:	2200      	movs	r2, #0
 8019e14:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
                mps = btstack_min(l2cap_max_le_mtu(), channel->local_mtu);
 8019e18:	f7ff f992 	bl	8019140 <l2cap_max_le_mtu>
 8019e1c:	4603      	mov	r3, r0
 8019e1e:	461a      	mov	r2, r3
 8019e20:	697b      	ldr	r3, [r7, #20]
 8019e22:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8019e24:	4619      	mov	r1, r3
 8019e26:	4610      	mov	r0, r2
 8019e28:	f7f5 f971 	bl	800f10e <btstack_min>
 8019e2c:	4603      	mov	r3, r0
 8019e2e:	827b      	strh	r3, [r7, #18]
                l2cap_send_le_signaling_packet(channel->con_handle, LE_CREDIT_BASED_CONNECTION_RESPONSE, channel->remote_sig_id, channel->local_cid, channel->local_mtu, mps, channel->credits_incoming, 0);
 8019e30:	697b      	ldr	r3, [r7, #20]
 8019e32:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 8019e34:	697b      	ldr	r3, [r7, #20]
 8019e36:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8019e3a:	461d      	mov	r5, r3
 8019e3c:	697b      	ldr	r3, [r7, #20]
 8019e3e:	88db      	ldrh	r3, [r3, #6]
 8019e40:	461e      	mov	r6, r3
 8019e42:	697b      	ldr	r3, [r7, #20]
 8019e44:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8019e46:	4619      	mov	r1, r3
 8019e48:	8a7b      	ldrh	r3, [r7, #18]
 8019e4a:	697a      	ldr	r2, [r7, #20]
 8019e4c:	f8b2 2052 	ldrh.w	r2, [r2, #82]	; 0x52
 8019e50:	4614      	mov	r4, r2
 8019e52:	2200      	movs	r2, #0
 8019e54:	9203      	str	r2, [sp, #12]
 8019e56:	9402      	str	r4, [sp, #8]
 8019e58:	9301      	str	r3, [sp, #4]
 8019e5a:	9100      	str	r1, [sp, #0]
 8019e5c:	4633      	mov	r3, r6
 8019e5e:	462a      	mov	r2, r5
 8019e60:	2115      	movs	r1, #21
 8019e62:	f7ff f925 	bl	80190b0 <l2cap_send_le_signaling_packet>
                // notify client
                l2cap_emit_le_channel_opened(channel, 0);
 8019e66:	2100      	movs	r1, #0
 8019e68:	6978      	ldr	r0, [r7, #20]
 8019e6a:	f002 ff0f 	bl	801cc8c <l2cap_emit_le_channel_opened>
                break;
 8019e6e:	e0b6      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>
            case L2CAP_STATE_WILL_SEND_LE_CONNECTION_RESPONSE_DECLINE:
                if (!hci_can_send_acl_packet_now(channel->con_handle)) break;
 8019e70:	697b      	ldr	r3, [r7, #20]
 8019e72:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8019e74:	4618      	mov	r0, r3
 8019e76:	f7f6 f8b3 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019e7a:	4603      	mov	r3, r0
 8019e7c:	2b00      	cmp	r3, #0
 8019e7e:	d100      	bne.n	8019e82 <l2cap_run_le_data_channels+0x18e>
 8019e80:	e0ad      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>
                channel->state = L2CAP_STATE_INVALID;
 8019e82:	697b      	ldr	r3, [r7, #20]
 8019e84:	2219      	movs	r2, #25
 8019e86:	f883 2020 	strb.w	r2, [r3, #32]
                l2cap_send_le_signaling_packet(channel->con_handle, LE_CREDIT_BASED_CONNECTION_RESPONSE, channel->remote_sig_id, 0, 0, 0, 0, channel->reason);
 8019e8a:	697b      	ldr	r3, [r7, #20]
 8019e8c:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 8019e8e:	697b      	ldr	r3, [r7, #20]
 8019e90:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8019e94:	461a      	mov	r2, r3
 8019e96:	697b      	ldr	r3, [r7, #20]
 8019e98:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
 8019e9c:	9303      	str	r3, [sp, #12]
 8019e9e:	2300      	movs	r3, #0
 8019ea0:	9302      	str	r3, [sp, #8]
 8019ea2:	2300      	movs	r3, #0
 8019ea4:	9301      	str	r3, [sp, #4]
 8019ea6:	2300      	movs	r3, #0
 8019ea8:	9300      	str	r3, [sp, #0]
 8019eaa:	2300      	movs	r3, #0
 8019eac:	2115      	movs	r1, #21
 8019eae:	f7ff f8ff 	bl	80190b0 <l2cap_send_le_signaling_packet>
                // discard channel - l2cap_finialize_channel_close without sending l2cap close event
                btstack_linked_list_iterator_remove(&it);
 8019eb2:	1d3b      	adds	r3, r7, #4
 8019eb4:	4618      	mov	r0, r3
 8019eb6:	f7f4 fcb7 	bl	800e828 <btstack_linked_list_iterator_remove>
                l2cap_free_channel_entry(channel);
 8019eba:	6978      	ldr	r0, [r7, #20]
 8019ebc:	f000 fa18 	bl	801a2f0 <l2cap_free_channel_entry>
                break;
 8019ec0:	e08d      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>
            case L2CAP_STATE_OPEN:
                if (!hci_can_send_acl_packet_now(channel->con_handle)) break;
 8019ec2:	697b      	ldr	r3, [r7, #20]
 8019ec4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8019ec6:	4618      	mov	r0, r3
 8019ec8:	f7f6 f88a 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019ecc:	4603      	mov	r3, r0
 8019ece:	2b00      	cmp	r3, #0
 8019ed0:	d100      	bne.n	8019ed4 <l2cap_run_le_data_channels+0x1e0>
 8019ed2:	e084      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>

                // send credits
                if (channel->new_credits_incoming){
 8019ed4:	697b      	ldr	r3, [r7, #20]
 8019ed6:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8019eda:	2b00      	cmp	r3, #0
 8019edc:	d07f      	beq.n	8019fde <l2cap_run_le_data_channels+0x2ea>
                    log_info("l2cap: sending %u credits", channel->new_credits_incoming);
 8019ede:	697b      	ldr	r3, [r7, #20]
 8019ee0:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8019ee4:	9300      	str	r3, [sp, #0]
 8019ee6:	f240 731d 	movw	r3, #1821	; 0x71d
 8019eea:	4a3a      	ldr	r2, [pc, #232]	; (8019fd4 <l2cap_run_le_data_channels+0x2e0>)
 8019eec:	493a      	ldr	r1, [pc, #232]	; (8019fd8 <l2cap_run_le_data_channels+0x2e4>)
 8019eee:	2001      	movs	r0, #1
 8019ef0:	f7fd faa6 	bl	8017440 <hci_dump_log>
                    channel->local_sig_id = l2cap_next_sig_id();
 8019ef4:	f7fe fb48 	bl	8018588 <l2cap_next_sig_id>
 8019ef8:	4603      	mov	r3, r0
 8019efa:	461a      	mov	r2, r3
 8019efc:	697b      	ldr	r3, [r7, #20]
 8019efe:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
                    uint16_t new_credits = channel->new_credits_incoming;
 8019f02:	697b      	ldr	r3, [r7, #20]
 8019f04:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8019f08:	823b      	strh	r3, [r7, #16]
                    channel->new_credits_incoming = 0;
 8019f0a:	697b      	ldr	r3, [r7, #20]
 8019f0c:	2200      	movs	r2, #0
 8019f0e:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
                    channel->credits_incoming += new_credits;
 8019f12:	697b      	ldr	r3, [r7, #20]
 8019f14:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 8019f18:	8a3b      	ldrh	r3, [r7, #16]
 8019f1a:	4413      	add	r3, r2
 8019f1c:	b29a      	uxth	r2, r3
 8019f1e:	697b      	ldr	r3, [r7, #20]
 8019f20:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
                    l2cap_send_le_signaling_packet(channel->con_handle, LE_FLOW_CONTROL_CREDIT, channel->local_sig_id, channel->remote_cid, new_credits);
 8019f24:	697b      	ldr	r3, [r7, #20]
 8019f26:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 8019f28:	697b      	ldr	r3, [r7, #20]
 8019f2a:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8019f2e:	461a      	mov	r2, r3
 8019f30:	697b      	ldr	r3, [r7, #20]
 8019f32:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8019f34:	4619      	mov	r1, r3
 8019f36:	8a3b      	ldrh	r3, [r7, #16]
 8019f38:	9300      	str	r3, [sp, #0]
 8019f3a:	460b      	mov	r3, r1
 8019f3c:	2116      	movs	r1, #22
 8019f3e:	f7ff f8b7 	bl	80190b0 <l2cap_send_le_signaling_packet>
                }
                break;
 8019f42:	e04c      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>

            case L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST:
                if (!hci_can_send_acl_packet_now(channel->con_handle)) break;
 8019f44:	697b      	ldr	r3, [r7, #20]
 8019f46:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8019f48:	4618      	mov	r0, r3
 8019f4a:	f7f6 f849 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019f4e:	4603      	mov	r3, r0
 8019f50:	2b00      	cmp	r3, #0
 8019f52:	d100      	bne.n	8019f56 <l2cap_run_le_data_channels+0x262>
 8019f54:	e043      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>
                channel->local_sig_id = l2cap_next_sig_id();
 8019f56:	f7fe fb17 	bl	8018588 <l2cap_next_sig_id>
 8019f5a:	4603      	mov	r3, r0
 8019f5c:	461a      	mov	r2, r3
 8019f5e:	697b      	ldr	r3, [r7, #20]
 8019f60:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
                channel->state = L2CAP_STATE_WAIT_DISCONNECT;
 8019f64:	697b      	ldr	r3, [r7, #20]
 8019f66:	220d      	movs	r2, #13
 8019f68:	f883 2020 	strb.w	r2, [r3, #32]
                l2cap_send_le_signaling_packet( channel->con_handle, DISCONNECTION_REQUEST, channel->local_sig_id, channel->remote_cid, channel->local_cid);
 8019f6c:	697b      	ldr	r3, [r7, #20]
 8019f6e:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 8019f70:	697b      	ldr	r3, [r7, #20]
 8019f72:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8019f76:	461a      	mov	r2, r3
 8019f78:	697b      	ldr	r3, [r7, #20]
 8019f7a:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8019f7c:	4619      	mov	r1, r3
 8019f7e:	697b      	ldr	r3, [r7, #20]
 8019f80:	88db      	ldrh	r3, [r3, #6]
 8019f82:	9300      	str	r3, [sp, #0]
 8019f84:	460b      	mov	r3, r1
 8019f86:	2106      	movs	r1, #6
 8019f88:	f7ff f892 	bl	80190b0 <l2cap_send_le_signaling_packet>
                break;
 8019f8c:	e027      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>
            case L2CAP_STATE_WILL_SEND_DISCONNECT_RESPONSE:
                if (!hci_can_send_acl_packet_now(channel->con_handle)) break;
 8019f8e:	697b      	ldr	r3, [r7, #20]
 8019f90:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8019f92:	4618      	mov	r0, r3
 8019f94:	f7f6 f824 	bl	800ffe0 <hci_can_send_acl_packet_now>
 8019f98:	4603      	mov	r3, r0
 8019f9a:	2b00      	cmp	r3, #0
 8019f9c:	d100      	bne.n	8019fa0 <l2cap_run_le_data_channels+0x2ac>
 8019f9e:	e01e      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>
                channel->state = L2CAP_STATE_INVALID;
 8019fa0:	697b      	ldr	r3, [r7, #20]
 8019fa2:	2219      	movs	r2, #25
 8019fa4:	f883 2020 	strb.w	r2, [r3, #32]
                l2cap_send_le_signaling_packet( channel->con_handle, DISCONNECTION_RESPONSE, channel->remote_sig_id, channel->local_cid, channel->remote_cid);
 8019fa8:	697b      	ldr	r3, [r7, #20]
 8019faa:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 8019fac:	697b      	ldr	r3, [r7, #20]
 8019fae:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8019fb2:	461a      	mov	r2, r3
 8019fb4:	697b      	ldr	r3, [r7, #20]
 8019fb6:	88db      	ldrh	r3, [r3, #6]
 8019fb8:	4619      	mov	r1, r3
 8019fba:	697b      	ldr	r3, [r7, #20]
 8019fbc:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8019fbe:	9300      	str	r3, [sp, #0]
 8019fc0:	460b      	mov	r3, r1
 8019fc2:	2107      	movs	r1, #7
 8019fc4:	f7ff f874 	bl	80190b0 <l2cap_send_le_signaling_packet>
                l2cap_le_finialize_channel_close(channel);  // -- remove from list
 8019fc8:	6978      	ldr	r0, [r7, #20]
 8019fca:	f002 ffc9 	bl	801cf60 <l2cap_le_finialize_channel_close>
                break;
 8019fce:	e006      	b.n	8019fde <l2cap_run_le_data_channels+0x2ea>
 8019fd0:	20009eac 	.word	0x20009eac
 8019fd4:	0802b1dc 	.word	0x0802b1dc
 8019fd8:	0802bcd0 	.word	0x0802bcd0
            default:
                break;
 8019fdc:	bf00      	nop
    while (btstack_linked_list_iterator_has_next(&it)){
 8019fde:	1d3b      	adds	r3, r7, #4
 8019fe0:	4618      	mov	r0, r3
 8019fe2:	f7f4 fbc9 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8019fe6:	4603      	mov	r3, r0
 8019fe8:	2b00      	cmp	r3, #0
 8019fea:	f47f ae8c 	bne.w	8019d06 <l2cap_run_le_data_channels+0x12>
        }
    }
}
 8019fee:	bf00      	nop
 8019ff0:	371c      	adds	r7, #28
 8019ff2:	46bd      	mov	sp, r7
 8019ff4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8019ff6:	bf00      	nop

08019ff8 <l2cap_run>:
#endif

// MARK: L2CAP_RUN
// process outstanding signaling tasks
static void l2cap_run(void){
 8019ff8:	b5b0      	push	{r4, r5, r7, lr}
 8019ffa:	b08c      	sub	sp, #48	; 0x30
 8019ffc:	af04      	add	r7, sp, #16
    
    // log_info("l2cap_run: entered");
    l2cap_run_signaling_response();
 8019ffe:	f7ff fd11 	bl	8019a24 <l2cap_run_signaling_response>
    
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    bool done = l2ap_run_ertm();
 801a002:	f7ff fe3b 	bl	8019c7c <l2ap_run_ertm>
 801a006:	4603      	mov	r3, r0
 801a008:	77fb      	strb	r3, [r7, #31]
    if (done) return;
 801a00a:	7ffb      	ldrb	r3, [r7, #31]
 801a00c:	2b00      	cmp	r3, #0
 801a00e:	f040 8096 	bne.w	801a13e <l2cap_run+0x146>
#if defined(ENABLE_CLASSIC) || defined(ENABLE_BLE)
    btstack_linked_list_iterator_t it;
#endif

#ifdef ENABLE_CLASSIC
    btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801a012:	1d3b      	adds	r3, r7, #4
 801a014:	494c      	ldr	r1, [pc, #304]	; (801a148 <l2cap_run+0x150>)
 801a016:	4618      	mov	r0, r3
 801a018:	f7f4 fb99 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 801a01c:	e017      	b.n	801a04e <l2cap_run+0x56>

        l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801a01e:	1d3b      	adds	r3, r7, #4
 801a020:	4618      	mov	r0, r3
 801a022:	f7f4 fbd7 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801a026:	6178      	str	r0, [r7, #20]

        if (channel->channel_type != L2CAP_CHANNEL_TYPE_CLASSIC) continue;
 801a028:	697b      	ldr	r3, [r7, #20]
 801a02a:	791b      	ldrb	r3, [r3, #4]
 801a02c:	2b00      	cmp	r3, #0
 801a02e:	d000      	beq.n	801a032 <l2cap_run+0x3a>
 801a030:	e00d      	b.n	801a04e <l2cap_run+0x56>

        // log_info("l2cap_run: channel %p, state %u, var 0x%02x", channel, channel->state, channel->state_var);
        bool finalized = l2cap_run_for_classic_channel(channel);
 801a032:	6978      	ldr	r0, [r7, #20]
 801a034:	f7ff f918 	bl	8019268 <l2cap_run_for_classic_channel>
 801a038:	4603      	mov	r3, r0
 801a03a:	74fb      	strb	r3, [r7, #19]

        if (!finalized) {
 801a03c:	7cfb      	ldrb	r3, [r7, #19]
 801a03e:	f083 0301 	eor.w	r3, r3, #1
 801a042:	b2db      	uxtb	r3, r3
 801a044:	2b00      	cmp	r3, #0
 801a046:	d002      	beq.n	801a04e <l2cap_run+0x56>
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
            l2cap_run_for_classic_channel_ertm(channel);
 801a048:	6978      	ldr	r0, [r7, #20]
 801a04a:	f7ff fbb9 	bl	80197c0 <l2cap_run_for_classic_channel_ertm>
    while (btstack_linked_list_iterator_has_next(&it)){
 801a04e:	1d3b      	adds	r3, r7, #4
 801a050:	4618      	mov	r0, r3
 801a052:	f7f4 fb91 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801a056:	4603      	mov	r3, r0
 801a058:	2b00      	cmp	r3, #0
 801a05a:	d1e0      	bne.n	801a01e <l2cap_run+0x26>
        }
    }
#endif

#ifdef ENABLE_LE_DATA_CHANNELS
    l2cap_run_le_data_channels();
 801a05c:	f7ff fe4a 	bl	8019cf4 <l2cap_run_le_data_channels>
#endif

#ifdef ENABLE_BLE
    // send l2cap con paramter update if necessary
    hci_connections_get_iterator(&it);
 801a060:	1d3b      	adds	r3, r7, #4
 801a062:	4618      	mov	r0, r3
 801a064:	f7f5 fc1c 	bl	800f8a0 <hci_connections_get_iterator>
    while(btstack_linked_list_iterator_has_next(&it)){
 801a068:	e061      	b.n	801a12e <l2cap_run+0x136>
        hci_connection_t * connection = (hci_connection_t *) btstack_linked_list_iterator_next(&it);
 801a06a:	1d3b      	adds	r3, r7, #4
 801a06c:	4618      	mov	r0, r3
 801a06e:	f7f4 fbb1 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801a072:	61b8      	str	r0, [r7, #24]
        if ((connection->address_type != BD_ADDR_TYPE_LE_PUBLIC) && (connection->address_type != BD_ADDR_TYPE_LE_RANDOM)) continue;
 801a074:	69bb      	ldr	r3, [r7, #24]
 801a076:	7b1b      	ldrb	r3, [r3, #12]
 801a078:	2b00      	cmp	r3, #0
 801a07a:	d004      	beq.n	801a086 <l2cap_run+0x8e>
 801a07c:	69bb      	ldr	r3, [r7, #24]
 801a07e:	7b1b      	ldrb	r3, [r3, #12]
 801a080:	2b01      	cmp	r3, #1
 801a082:	d000      	beq.n	801a086 <l2cap_run+0x8e>
 801a084:	e053      	b.n	801a12e <l2cap_run+0x136>
        if (!hci_can_send_acl_packet_now(connection->con_handle)) continue;
 801a086:	69bb      	ldr	r3, [r7, #24]
 801a088:	895b      	ldrh	r3, [r3, #10]
 801a08a:	4618      	mov	r0, r3
 801a08c:	f7f5 ffa8 	bl	800ffe0 <hci_can_send_acl_packet_now>
 801a090:	4603      	mov	r3, r0
 801a092:	2b00      	cmp	r3, #0
 801a094:	d100      	bne.n	801a098 <l2cap_run+0xa0>
 801a096:	e04a      	b.n	801a12e <l2cap_run+0x136>
        switch (connection->le_con_parameter_update_state){
 801a098:	69bb      	ldr	r3, [r7, #24]
 801a09a:	f893 370b 	ldrb.w	r3, [r3, #1803]	; 0x70b
 801a09e:	2b02      	cmp	r3, #2
 801a0a0:	d026      	beq.n	801a0f0 <l2cap_run+0xf8>
 801a0a2:	2b04      	cmp	r3, #4
 801a0a4:	d033      	beq.n	801a10e <l2cap_run+0x116>
 801a0a6:	2b01      	cmp	r3, #1
 801a0a8:	d140      	bne.n	801a12c <l2cap_run+0x134>
            case CON_PARAMETER_UPDATE_SEND_REQUEST:
                connection->le_con_parameter_update_state = CON_PARAMETER_UPDATE_NONE;
 801a0aa:	69bb      	ldr	r3, [r7, #24]
 801a0ac:	2200      	movs	r2, #0
 801a0ae:	f883 270b 	strb.w	r2, [r3, #1803]	; 0x70b
                l2cap_send_le_signaling_packet(connection->con_handle, CONNECTION_PARAMETER_UPDATE_REQUEST, l2cap_next_sig_id(),
 801a0b2:	69bb      	ldr	r3, [r7, #24]
 801a0b4:	895c      	ldrh	r4, [r3, #10]
 801a0b6:	f7fe fa67 	bl	8018588 <l2cap_next_sig_id>
 801a0ba:	4603      	mov	r3, r0
 801a0bc:	4618      	mov	r0, r3
                                               connection->le_conn_interval_min, connection->le_conn_interval_max, connection->le_conn_latency, connection->le_supervision_timeout);
 801a0be:	69bb      	ldr	r3, [r7, #24]
 801a0c0:	f8b3 370e 	ldrh.w	r3, [r3, #1806]	; 0x70e
                l2cap_send_le_signaling_packet(connection->con_handle, CONNECTION_PARAMETER_UPDATE_REQUEST, l2cap_next_sig_id(),
 801a0c4:	461d      	mov	r5, r3
                                               connection->le_conn_interval_min, connection->le_conn_interval_max, connection->le_conn_latency, connection->le_supervision_timeout);
 801a0c6:	69bb      	ldr	r3, [r7, #24]
 801a0c8:	f8b3 3710 	ldrh.w	r3, [r3, #1808]	; 0x710
                l2cap_send_le_signaling_packet(connection->con_handle, CONNECTION_PARAMETER_UPDATE_REQUEST, l2cap_next_sig_id(),
 801a0cc:	461a      	mov	r2, r3
                                               connection->le_conn_interval_min, connection->le_conn_interval_max, connection->le_conn_latency, connection->le_supervision_timeout);
 801a0ce:	69bb      	ldr	r3, [r7, #24]
 801a0d0:	f8b3 3712 	ldrh.w	r3, [r3, #1810]	; 0x712
                l2cap_send_le_signaling_packet(connection->con_handle, CONNECTION_PARAMETER_UPDATE_REQUEST, l2cap_next_sig_id(),
 801a0d4:	4619      	mov	r1, r3
                                               connection->le_conn_interval_min, connection->le_conn_interval_max, connection->le_conn_latency, connection->le_supervision_timeout);
 801a0d6:	69bb      	ldr	r3, [r7, #24]
 801a0d8:	f8b3 3714 	ldrh.w	r3, [r3, #1812]	; 0x714
                l2cap_send_le_signaling_packet(connection->con_handle, CONNECTION_PARAMETER_UPDATE_REQUEST, l2cap_next_sig_id(),
 801a0dc:	9302      	str	r3, [sp, #8]
 801a0de:	9101      	str	r1, [sp, #4]
 801a0e0:	9200      	str	r2, [sp, #0]
 801a0e2:	462b      	mov	r3, r5
 801a0e4:	4602      	mov	r2, r0
 801a0e6:	2112      	movs	r1, #18
 801a0e8:	4620      	mov	r0, r4
 801a0ea:	f7fe ffe1 	bl	80190b0 <l2cap_send_le_signaling_packet>
                break;
 801a0ee:	e01e      	b.n	801a12e <l2cap_run+0x136>
            case CON_PARAMETER_UPDATE_SEND_RESPONSE:
                connection->le_con_parameter_update_state = CON_PARAMETER_UPDATE_CHANGE_HCI_CON_PARAMETERS;
 801a0f0:	69bb      	ldr	r3, [r7, #24]
 801a0f2:	2203      	movs	r2, #3
 801a0f4:	f883 270b 	strb.w	r2, [r3, #1803]	; 0x70b
                l2cap_send_le_signaling_packet(connection->con_handle, CONNECTION_PARAMETER_UPDATE_RESPONSE, connection->le_con_param_update_identifier, 0);
 801a0f8:	69bb      	ldr	r3, [r7, #24]
 801a0fa:	8958      	ldrh	r0, [r3, #10]
 801a0fc:	69bb      	ldr	r3, [r7, #24]
 801a0fe:	f893 370c 	ldrb.w	r3, [r3, #1804]	; 0x70c
 801a102:	461a      	mov	r2, r3
 801a104:	2300      	movs	r3, #0
 801a106:	2113      	movs	r1, #19
 801a108:	f7fe ffd2 	bl	80190b0 <l2cap_send_le_signaling_packet>
                break;
 801a10c:	e00f      	b.n	801a12e <l2cap_run+0x136>
            case CON_PARAMETER_UPDATE_DENY:
                connection->le_con_parameter_update_state = CON_PARAMETER_UPDATE_NONE;
 801a10e:	69bb      	ldr	r3, [r7, #24]
 801a110:	2200      	movs	r2, #0
 801a112:	f883 270b 	strb.w	r2, [r3, #1803]	; 0x70b
                l2cap_send_le_signaling_packet(connection->con_handle, CONNECTION_PARAMETER_UPDATE_RESPONSE, connection->le_con_param_update_identifier, 1);
 801a116:	69bb      	ldr	r3, [r7, #24]
 801a118:	8958      	ldrh	r0, [r3, #10]
 801a11a:	69bb      	ldr	r3, [r7, #24]
 801a11c:	f893 370c 	ldrb.w	r3, [r3, #1804]	; 0x70c
 801a120:	461a      	mov	r2, r3
 801a122:	2301      	movs	r3, #1
 801a124:	2113      	movs	r1, #19
 801a126:	f7fe ffc3 	bl	80190b0 <l2cap_send_le_signaling_packet>
                break;
 801a12a:	e000      	b.n	801a12e <l2cap_run+0x136>
            default:
                break;
 801a12c:	bf00      	nop
    while(btstack_linked_list_iterator_has_next(&it)){
 801a12e:	1d3b      	adds	r3, r7, #4
 801a130:	4618      	mov	r0, r3
 801a132:	f7f4 fb21 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801a136:	4603      	mov	r3, r0
 801a138:	2b00      	cmp	r3, #0
 801a13a:	d196      	bne.n	801a06a <l2cap_run+0x72>
 801a13c:	e000      	b.n	801a140 <l2cap_run+0x148>
    if (done) return;
 801a13e:	bf00      	nop
        }
    }
#endif

    // log_info("l2cap_run: exit");
}
 801a140:	3720      	adds	r7, #32
 801a142:	46bd      	mov	sp, r7
 801a144:	bdb0      	pop	{r4, r5, r7, pc}
 801a146:	bf00      	nop
 801a148:	20009eac 	.word	0x20009eac

0801a14c <l2cap_handle_connection_complete>:

#ifdef ENABLE_CLASSIC
static void l2cap_handle_connection_complete(hci_con_handle_t con_handle, l2cap_channel_t * channel){
 801a14c:	b580      	push	{r7, lr}
 801a14e:	b086      	sub	sp, #24
 801a150:	af04      	add	r7, sp, #16
 801a152:	4603      	mov	r3, r0
 801a154:	6039      	str	r1, [r7, #0]
 801a156:	80fb      	strh	r3, [r7, #6]
    if ((channel->state == L2CAP_STATE_WAIT_CONNECTION_COMPLETE) || (channel->state == L2CAP_STATE_WILL_SEND_CREATE_CONNECTION)) {
 801a158:	683b      	ldr	r3, [r7, #0]
 801a15a:	f893 3020 	ldrb.w	r3, [r3, #32]
 801a15e:	2b03      	cmp	r3, #3
 801a160:	d004      	beq.n	801a16c <l2cap_handle_connection_complete+0x20>
 801a162:	683b      	ldr	r3, [r7, #0]
 801a164:	f893 3020 	ldrb.w	r3, [r3, #32]
 801a168:	2b02      	cmp	r3, #2
 801a16a:	d114      	bne.n	801a196 <l2cap_handle_connection_complete+0x4a>
        log_info("connection complete con_handle %04x - for channel %p cid 0x%04x", (int) con_handle, channel, channel->local_cid);
 801a16c:	88fb      	ldrh	r3, [r7, #6]
 801a16e:	683a      	ldr	r2, [r7, #0]
 801a170:	88d2      	ldrh	r2, [r2, #6]
 801a172:	9202      	str	r2, [sp, #8]
 801a174:	683a      	ldr	r2, [r7, #0]
 801a176:	9201      	str	r2, [sp, #4]
 801a178:	9300      	str	r3, [sp, #0]
 801a17a:	f240 7381 	movw	r3, #1921	; 0x781
 801a17e:	4a08      	ldr	r2, [pc, #32]	; (801a1a0 <l2cap_handle_connection_complete+0x54>)
 801a180:	4908      	ldr	r1, [pc, #32]	; (801a1a4 <l2cap_handle_connection_complete+0x58>)
 801a182:	2001      	movs	r0, #1
 801a184:	f7fd f95c 	bl	8017440 <hci_dump_log>
        // success, start l2cap handshake
        channel->con_handle = con_handle;
 801a188:	683b      	ldr	r3, [r7, #0]
 801a18a:	88fa      	ldrh	r2, [r7, #6]
 801a18c:	849a      	strh	r2, [r3, #36]	; 0x24
        // check remote SSP feature first
        channel->state = L2CAP_STATE_WAIT_REMOTE_SUPPORTED_FEATURES;
 801a18e:	683b      	ldr	r3, [r7, #0]
 801a190:	2204      	movs	r2, #4
 801a192:	f883 2020 	strb.w	r2, [r3, #32]
    }
}
 801a196:	bf00      	nop
 801a198:	3708      	adds	r7, #8
 801a19a:	46bd      	mov	sp, r7
 801a19c:	bd80      	pop	{r7, pc}
 801a19e:	bf00      	nop
 801a1a0:	0802b1dc 	.word	0x0802b1dc
 801a1a4:	0802bcf4 	.word	0x0802bcf4

0801a1a8 <l2cap_ready_to_connect>:

static void l2cap_ready_to_connect(l2cap_channel_t * channel){
 801a1a8:	b580      	push	{r7, lr}
 801a1aa:	b084      	sub	sp, #16
 801a1ac:	af00      	add	r7, sp, #0
 801a1ae:	6078      	str	r0, [r7, #4]

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    // assumption: outgoing connection
    hci_connection_t * connection = hci_connection_for_handle(channel->con_handle);
 801a1b0:	687b      	ldr	r3, [r7, #4]
 801a1b2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801a1b4:	4618      	mov	r0, r3
 801a1b6:	f7f5 fb85 	bl	800f8c4 <hci_connection_for_handle>
 801a1ba:	60f8      	str	r0, [r7, #12]
    if (connection->l2cap_state.information_state == L2CAP_INFORMATION_STATE_IDLE){
 801a1bc:	68fb      	ldr	r3, [r7, #12]
 801a1be:	f893 3e24 	ldrb.w	r3, [r3, #3620]	; 0xe24
 801a1c2:	2b00      	cmp	r3, #0
 801a1c4:	d108      	bne.n	801a1d8 <l2cap_ready_to_connect+0x30>
        connection->l2cap_state.information_state = L2CAP_INFORMATION_STATE_W2_SEND_EXTENDED_FEATURE_REQUEST;        
 801a1c6:	68fb      	ldr	r3, [r7, #12]
 801a1c8:	2201      	movs	r2, #1
 801a1ca:	f883 2e24 	strb.w	r2, [r3, #3620]	; 0xe24
        channel->state = L2CAP_STATE_WAIT_OUTGOING_EXTENDED_FEATURES;
 801a1ce:	687b      	ldr	r3, [r7, #4]
 801a1d0:	2208      	movs	r2, #8
 801a1d2:	f883 2020 	strb.w	r2, [r3, #32]
        return;
 801a1d6:	e003      	b.n	801a1e0 <l2cap_ready_to_connect+0x38>
    }
#endif

    // fine, go ahead
    channel->state = L2CAP_STATE_WILL_SEND_CONNECTION_REQUEST;
 801a1d8:	687b      	ldr	r3, [r7, #4]
 801a1da:	220e      	movs	r2, #14
 801a1dc:	f883 2020 	strb.w	r2, [r3, #32]
}
 801a1e0:	3710      	adds	r7, #16
 801a1e2:	46bd      	mov	sp, r7
 801a1e4:	bd80      	pop	{r7, pc}

0801a1e6 <l2cap_handle_remote_supported_features_received>:

static void l2cap_handle_remote_supported_features_received(l2cap_channel_t * channel){
 801a1e6:	b580      	push	{r7, lr}
 801a1e8:	b082      	sub	sp, #8
 801a1ea:	af00      	add	r7, sp, #0
 801a1ec:	6078      	str	r0, [r7, #4]
    if (channel->state != L2CAP_STATE_WAIT_REMOTE_SUPPORTED_FEATURES) return;
 801a1ee:	687b      	ldr	r3, [r7, #4]
 801a1f0:	f893 3020 	ldrb.w	r3, [r3, #32]
 801a1f4:	2b04      	cmp	r3, #4
 801a1f6:	d116      	bne.n	801a226 <l2cap_handle_remote_supported_features_received+0x40>

    // we have been waiting for remote supported features
    if (channel->required_security_level > LEVEL_0){
 801a1f8:	687b      	ldr	r3, [r7, #4]
 801a1fa:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 801a1fe:	2b00      	cmp	r3, #0
 801a200:	d00d      	beq.n	801a21e <l2cap_handle_remote_supported_features_received+0x38>
        // request security level
        channel->state = L2CAP_STATE_WAIT_OUTGOING_SECURITY_LEVEL_UPDATE;
 801a202:	687b      	ldr	r3, [r7, #4]
 801a204:	2206      	movs	r2, #6
 801a206:	f883 2020 	strb.w	r2, [r3, #32]
        gap_request_security_level(channel->con_handle, channel->required_security_level);
 801a20a:	687b      	ldr	r3, [r7, #4]
 801a20c:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 801a20e:	687b      	ldr	r3, [r7, #4]
 801a210:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 801a214:	4619      	mov	r1, r3
 801a216:	4610      	mov	r0, r2
 801a218:	f7fc fb02 	bl	8016820 <gap_request_security_level>
        return;
 801a21c:	e004      	b.n	801a228 <l2cap_handle_remote_supported_features_received+0x42>
    }

    l2cap_ready_to_connect(channel);
 801a21e:	6878      	ldr	r0, [r7, #4]
 801a220:	f7ff ffc2 	bl	801a1a8 <l2cap_ready_to_connect>
 801a224:	e000      	b.n	801a228 <l2cap_handle_remote_supported_features_received+0x42>
    if (channel->state != L2CAP_STATE_WAIT_REMOTE_SUPPORTED_FEATURES) return;
 801a226:	bf00      	nop
}
 801a228:	3708      	adds	r7, #8
 801a22a:	46bd      	mov	sp, r7
 801a22c:	bd80      	pop	{r7, pc}
	...

0801a230 <l2cap_create_channel_entry>:
#endif

#ifdef L2CAP_USES_CHANNELS
static l2cap_channel_t * l2cap_create_channel_entry(btstack_packet_handler_t packet_handler, l2cap_channel_type_t channel_type, bd_addr_t address, bd_addr_type_t address_type, 
    uint16_t psm, uint16_t local_mtu, gap_security_level_t security_level){
 801a230:	b580      	push	{r7, lr}
 801a232:	b088      	sub	sp, #32
 801a234:	af02      	add	r7, sp, #8
 801a236:	60f8      	str	r0, [r7, #12]
 801a238:	607a      	str	r2, [r7, #4]
 801a23a:	461a      	mov	r2, r3
 801a23c:	460b      	mov	r3, r1
 801a23e:	72fb      	strb	r3, [r7, #11]
 801a240:	4613      	mov	r3, r2
 801a242:	72bb      	strb	r3, [r7, #10]

    l2cap_channel_t * channel = btstack_memory_l2cap_channel_get();
 801a244:	f7f4 fb2e 	bl	800e8a4 <btstack_memory_l2cap_channel_get>
 801a248:	6178      	str	r0, [r7, #20]
    if (!channel) {
 801a24a:	697b      	ldr	r3, [r7, #20]
 801a24c:	2b00      	cmp	r3, #0
 801a24e:	d101      	bne.n	801a254 <l2cap_create_channel_entry+0x24>
        return NULL;
 801a250:	2300      	movs	r3, #0
 801a252:	e044      	b.n	801a2de <l2cap_create_channel_entry+0xae>
    }
        
    // fill in 
    channel->packet_handler = packet_handler;
 801a254:	697b      	ldr	r3, [r7, #20]
 801a256:	68fa      	ldr	r2, [r7, #12]
 801a258:	609a      	str	r2, [r3, #8]
    channel->channel_type   = channel_type;
 801a25a:	697b      	ldr	r3, [r7, #20]
 801a25c:	7afa      	ldrb	r2, [r7, #11]
 801a25e:	711a      	strb	r2, [r3, #4]
    bd_addr_copy(channel->address, address);
 801a260:	697b      	ldr	r3, [r7, #20]
 801a262:	3326      	adds	r3, #38	; 0x26
 801a264:	6879      	ldr	r1, [r7, #4]
 801a266:	4618      	mov	r0, r3
 801a268:	f7f4 fdaf 	bl	800edca <bd_addr_copy>
    channel->address_type = address_type;
 801a26c:	697b      	ldr	r3, [r7, #20]
 801a26e:	7aba      	ldrb	r2, [r7, #10]
 801a270:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    channel->psm = psm;
 801a274:	697b      	ldr	r3, [r7, #20]
 801a276:	8c3a      	ldrh	r2, [r7, #32]
 801a278:	871a      	strh	r2, [r3, #56]	; 0x38
    channel->local_mtu  = local_mtu;
 801a27a:	697b      	ldr	r3, [r7, #20]
 801a27c:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 801a27e:	865a      	strh	r2, [r3, #50]	; 0x32
    channel->remote_mtu = L2CAP_DEFAULT_MTU;
 801a280:	697b      	ldr	r3, [r7, #20]
 801a282:	f44f 7228 	mov.w	r2, #672	; 0x2a0
 801a286:	869a      	strh	r2, [r3, #52]	; 0x34
    channel->required_security_level = security_level;
 801a288:	697b      	ldr	r3, [r7, #20]
 801a28a:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
 801a28e:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a

    // 
    channel->local_cid = l2cap_next_local_cid();
 801a292:	f7fe f959 	bl	8018548 <l2cap_next_local_cid>
 801a296:	4603      	mov	r3, r0
 801a298:	461a      	mov	r2, r3
 801a29a:	697b      	ldr	r3, [r7, #20]
 801a29c:	80da      	strh	r2, [r3, #6]
    channel->con_handle = HCI_CON_HANDLE_INVALID;
 801a29e:	697b      	ldr	r3, [r7, #20]
 801a2a0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801a2a4:	849a      	strh	r2, [r3, #36]	; 0x24

    // set initial state
    channel->state = L2CAP_STATE_WILL_SEND_CREATE_CONNECTION;
 801a2a6:	697b      	ldr	r3, [r7, #20]
 801a2a8:	2202      	movs	r2, #2
 801a2aa:	f883 2020 	strb.w	r2, [r3, #32]
    channel->state_var = L2CAP_CHANNEL_STATE_VAR_NONE;
 801a2ae:	697b      	ldr	r3, [r7, #20]
 801a2b0:	2200      	movs	r2, #0
 801a2b2:	845a      	strh	r2, [r3, #34]	; 0x22
    channel->remote_sig_id = L2CAP_SIG_ID_INVALID;
 801a2b4:	697b      	ldr	r3, [r7, #20]
 801a2b6:	2200      	movs	r2, #0
 801a2b8:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    channel->local_sig_id = L2CAP_SIG_ID_INVALID;
 801a2bc:	697b      	ldr	r3, [r7, #20]
 801a2be:	2200      	movs	r2, #0
 801a2c0:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

    log_info("create channel %p, local_cid 0x%04x", channel, channel->local_cid);
 801a2c4:	697b      	ldr	r3, [r7, #20]
 801a2c6:	88db      	ldrh	r3, [r3, #6]
 801a2c8:	9301      	str	r3, [sp, #4]
 801a2ca:	697b      	ldr	r3, [r7, #20]
 801a2cc:	9300      	str	r3, [sp, #0]
 801a2ce:	f240 73c5 	movw	r3, #1989	; 0x7c5
 801a2d2:	4a05      	ldr	r2, [pc, #20]	; (801a2e8 <l2cap_create_channel_entry+0xb8>)
 801a2d4:	4905      	ldr	r1, [pc, #20]	; (801a2ec <l2cap_create_channel_entry+0xbc>)
 801a2d6:	2001      	movs	r0, #1
 801a2d8:	f7fd f8b2 	bl	8017440 <hci_dump_log>

    return channel;
 801a2dc:	697b      	ldr	r3, [r7, #20]
}
 801a2de:	4618      	mov	r0, r3
 801a2e0:	3718      	adds	r7, #24
 801a2e2:	46bd      	mov	sp, r7
 801a2e4:	bd80      	pop	{r7, pc}
 801a2e6:	bf00      	nop
 801a2e8:	0802b1dc 	.word	0x0802b1dc
 801a2ec:	0802bd3c 	.word	0x0802bd3c

0801a2f0 <l2cap_free_channel_entry>:

static void l2cap_free_channel_entry(l2cap_channel_t * channel){
 801a2f0:	b580      	push	{r7, lr}
 801a2f2:	b084      	sub	sp, #16
 801a2f4:	af02      	add	r7, sp, #8
 801a2f6:	6078      	str	r0, [r7, #4]
    log_info("free channel %p, local_cid 0x%04x", channel, channel->local_cid);
 801a2f8:	687b      	ldr	r3, [r7, #4]
 801a2fa:	88db      	ldrh	r3, [r3, #6]
 801a2fc:	9301      	str	r3, [sp, #4]
 801a2fe:	687b      	ldr	r3, [r7, #4]
 801a300:	9300      	str	r3, [sp, #0]
 801a302:	f240 73cb 	movw	r3, #1995	; 0x7cb
 801a306:	4a0a      	ldr	r2, [pc, #40]	; (801a330 <l2cap_free_channel_entry+0x40>)
 801a308:	490a      	ldr	r1, [pc, #40]	; (801a334 <l2cap_free_channel_entry+0x44>)
 801a30a:	2001      	movs	r0, #1
 801a30c:	f7fd f898 	bl	8017440 <hci_dump_log>
    // assert all timers are stopped
    l2cap_stop_rtx(channel);
 801a310:	6878      	ldr	r0, [r7, #4]
 801a312:	f7fe fd4f 	bl	8018db4 <l2cap_stop_rtx>
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    l2cap_ertm_stop_retransmission_timer(channel);
 801a316:	6878      	ldr	r0, [r7, #4]
 801a318:	f7fd fccc 	bl	8017cb4 <l2cap_ertm_stop_retransmission_timer>
    l2cap_ertm_stop_monitor_timer(channel);
 801a31c:	6878      	ldr	r0, [r7, #4]
 801a31e:	f7fd fc7b 	bl	8017c18 <l2cap_ertm_stop_monitor_timer>
#endif
    // free  memory
    btstack_memory_l2cap_channel_free(channel);
 801a322:	6878      	ldr	r0, [r7, #4]
 801a324:	f7f4 fad4 	bl	800e8d0 <btstack_memory_l2cap_channel_free>
}
 801a328:	bf00      	nop
 801a32a:	3708      	adds	r7, #8
 801a32c:	46bd      	mov	sp, r7
 801a32e:	bd80      	pop	{r7, pc}
 801a330:	0802b1dc 	.word	0x0802b1dc
 801a334:	0802bd68 	.word	0x0802bd68

0801a338 <l2cap_handle_connection_failed_for_addr>:
    }
    // process
    l2cap_run();
}

static void l2cap_handle_connection_failed_for_addr(bd_addr_t address, uint8_t status){
 801a338:	b580      	push	{r7, lr}
 801a33a:	b088      	sub	sp, #32
 801a33c:	af00      	add	r7, sp, #0
 801a33e:	6078      	str	r0, [r7, #4]
 801a340:	460b      	mov	r3, r1
 801a342:	70fb      	strb	r3, [r7, #3]
    // mark all channels before emitting open events as these could trigger new connetion requests to the same device
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801a344:	f107 0308 	add.w	r3, r7, #8
 801a348:	4937      	ldr	r1, [pc, #220]	; (801a428 <l2cap_handle_connection_failed_for_addr+0xf0>)
 801a34a:	4618      	mov	r0, r3
 801a34c:	f7f4 f9ff 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 801a350:	e024      	b.n	801a39c <l2cap_handle_connection_failed_for_addr+0x64>
        l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801a352:	f107 0308 	add.w	r3, r7, #8
 801a356:	4618      	mov	r0, r3
 801a358:	f7f4 fa3c 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801a35c:	6178      	str	r0, [r7, #20]
        if (!l2cap_is_dynamic_channel_type(channel->channel_type)) continue;
 801a35e:	697b      	ldr	r3, [r7, #20]
 801a360:	791b      	ldrb	r3, [r3, #4]
 801a362:	4618      	mov	r0, r3
 801a364:	f7fe fcb7 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801a368:	4603      	mov	r3, r0
 801a36a:	2b00      	cmp	r3, #0
 801a36c:	d100      	bne.n	801a370 <l2cap_handle_connection_failed_for_addr+0x38>
 801a36e:	e015      	b.n	801a39c <l2cap_handle_connection_failed_for_addr+0x64>
        if (bd_addr_cmp( channel->address, address) != 0) continue;
 801a370:	697b      	ldr	r3, [r7, #20]
 801a372:	3326      	adds	r3, #38	; 0x26
 801a374:	6879      	ldr	r1, [r7, #4]
 801a376:	4618      	mov	r0, r3
 801a378:	f7f4 fd18 	bl	800edac <bd_addr_cmp>
 801a37c:	4603      	mov	r3, r0
 801a37e:	2b00      	cmp	r3, #0
 801a380:	d000      	beq.n	801a384 <l2cap_handle_connection_failed_for_addr+0x4c>
 801a382:	e00b      	b.n	801a39c <l2cap_handle_connection_failed_for_addr+0x64>
        // channel for this address found
        switch (channel->state){
 801a384:	697b      	ldr	r3, [r7, #20]
 801a386:	f893 3020 	ldrb.w	r3, [r3, #32]
 801a38a:	3b02      	subs	r3, #2
 801a38c:	2b01      	cmp	r3, #1
 801a38e:	d804      	bhi.n	801a39a <l2cap_handle_connection_failed_for_addr+0x62>
            case L2CAP_STATE_WAIT_CONNECTION_COMPLETE:
            case L2CAP_STATE_WILL_SEND_CREATE_CONNECTION:
                channel->state = L2CAP_STATE_EMIT_OPEN_FAILED_AND_DISCARD;
 801a390:	697b      	ldr	r3, [r7, #20]
 801a392:	2218      	movs	r2, #24
 801a394:	f883 2020 	strb.w	r2, [r3, #32]
                break;
 801a398:	e000      	b.n	801a39c <l2cap_handle_connection_failed_for_addr+0x64>
            default:
                break;
 801a39a:	bf00      	nop
    while (btstack_linked_list_iterator_has_next(&it)){
 801a39c:	f107 0308 	add.w	r3, r7, #8
 801a3a0:	4618      	mov	r0, r3
 801a3a2:	f7f4 f9e9 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801a3a6:	4603      	mov	r3, r0
 801a3a8:	2b00      	cmp	r3, #0
 801a3aa:	d1d2      	bne.n	801a352 <l2cap_handle_connection_failed_for_addr+0x1a>
        }
    }
    // emit and free marked entries. restart loop to deal with list changes
    int done = 0;
 801a3ac:	2300      	movs	r3, #0
 801a3ae:	61fb      	str	r3, [r7, #28]
    while (!done) {
 801a3b0:	e033      	b.n	801a41a <l2cap_handle_connection_failed_for_addr+0xe2>
        done = 1;
 801a3b2:	2301      	movs	r3, #1
 801a3b4:	61fb      	str	r3, [r7, #28]
        btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801a3b6:	f107 0308 	add.w	r3, r7, #8
 801a3ba:	491b      	ldr	r1, [pc, #108]	; (801a428 <l2cap_handle_connection_failed_for_addr+0xf0>)
 801a3bc:	4618      	mov	r0, r3
 801a3be:	f7f4 f9c6 	bl	800e74e <btstack_linked_list_iterator_init>
        while (btstack_linked_list_iterator_has_next(&it)){
 801a3c2:	e022      	b.n	801a40a <l2cap_handle_connection_failed_for_addr+0xd2>
            l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801a3c4:	f107 0308 	add.w	r3, r7, #8
 801a3c8:	4618      	mov	r0, r3
 801a3ca:	f7f4 fa03 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801a3ce:	61b8      	str	r0, [r7, #24]
            if (!l2cap_is_dynamic_channel_type(channel->channel_type)) continue;
 801a3d0:	69bb      	ldr	r3, [r7, #24]
 801a3d2:	791b      	ldrb	r3, [r3, #4]
 801a3d4:	4618      	mov	r0, r3
 801a3d6:	f7fe fc7e 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801a3da:	4603      	mov	r3, r0
 801a3dc:	2b00      	cmp	r3, #0
 801a3de:	d100      	bne.n	801a3e2 <l2cap_handle_connection_failed_for_addr+0xaa>
 801a3e0:	e013      	b.n	801a40a <l2cap_handle_connection_failed_for_addr+0xd2>
            if (channel->state == L2CAP_STATE_EMIT_OPEN_FAILED_AND_DISCARD){
 801a3e2:	69bb      	ldr	r3, [r7, #24]
 801a3e4:	f893 3020 	ldrb.w	r3, [r3, #32]
 801a3e8:	2b18      	cmp	r3, #24
 801a3ea:	d10e      	bne.n	801a40a <l2cap_handle_connection_failed_for_addr+0xd2>
                done = 0;
 801a3ec:	2300      	movs	r3, #0
 801a3ee:	61fb      	str	r3, [r7, #28]
                // failure, forward error code
                l2cap_handle_channel_open_failed(channel, status);
 801a3f0:	78fb      	ldrb	r3, [r7, #3]
 801a3f2:	4619      	mov	r1, r3
 801a3f4:	69b8      	ldr	r0, [r7, #24]
 801a3f6:	f7fe fbd1 	bl	8018b9c <l2cap_handle_channel_open_failed>
                // discard channel
                btstack_linked_list_remove(&l2cap_channels, (btstack_linked_item_t *) channel);
 801a3fa:	69b9      	ldr	r1, [r7, #24]
 801a3fc:	480a      	ldr	r0, [pc, #40]	; (801a428 <l2cap_handle_connection_failed_for_addr+0xf0>)
 801a3fe:	f7f4 f95e 	bl	800e6be <btstack_linked_list_remove>
                l2cap_free_channel_entry(channel);
 801a402:	69b8      	ldr	r0, [r7, #24]
 801a404:	f7ff ff74 	bl	801a2f0 <l2cap_free_channel_entry>
                break;
 801a408:	e007      	b.n	801a41a <l2cap_handle_connection_failed_for_addr+0xe2>
        while (btstack_linked_list_iterator_has_next(&it)){
 801a40a:	f107 0308 	add.w	r3, r7, #8
 801a40e:	4618      	mov	r0, r3
 801a410:	f7f4 f9b2 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801a414:	4603      	mov	r3, r0
 801a416:	2b00      	cmp	r3, #0
 801a418:	d1d4      	bne.n	801a3c4 <l2cap_handle_connection_failed_for_addr+0x8c>
    while (!done) {
 801a41a:	69fb      	ldr	r3, [r7, #28]
 801a41c:	2b00      	cmp	r3, #0
 801a41e:	d0c8      	beq.n	801a3b2 <l2cap_handle_connection_failed_for_addr+0x7a>
            }
        }
    }

}
 801a420:	bf00      	nop
 801a422:	3720      	adds	r7, #32
 801a424:	46bd      	mov	sp, r7
 801a426:	bd80      	pop	{r7, pc}
 801a428:	20009eac 	.word	0x20009eac

0801a42c <l2cap_handle_connection_success_for_addr>:

static void l2cap_handle_connection_success_for_addr(bd_addr_t address, hci_con_handle_t handle){
 801a42c:	b580      	push	{r7, lr}
 801a42e:	b086      	sub	sp, #24
 801a430:	af00      	add	r7, sp, #0
 801a432:	6078      	str	r0, [r7, #4]
 801a434:	460b      	mov	r3, r1
 801a436:	807b      	strh	r3, [r7, #2]
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801a438:	f107 0308 	add.w	r3, r7, #8
 801a43c:	4917      	ldr	r1, [pc, #92]	; (801a49c <l2cap_handle_connection_success_for_addr+0x70>)
 801a43e:	4618      	mov	r0, r3
 801a440:	f7f4 f985 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 801a444:	e01c      	b.n	801a480 <l2cap_handle_connection_success_for_addr+0x54>
        l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801a446:	f107 0308 	add.w	r3, r7, #8
 801a44a:	4618      	mov	r0, r3
 801a44c:	f7f4 f9c2 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801a450:	6178      	str	r0, [r7, #20]
        if (!l2cap_is_dynamic_channel_type(channel->channel_type)) continue;
 801a452:	697b      	ldr	r3, [r7, #20]
 801a454:	791b      	ldrb	r3, [r3, #4]
 801a456:	4618      	mov	r0, r3
 801a458:	f7fe fc3d 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801a45c:	4603      	mov	r3, r0
 801a45e:	2b00      	cmp	r3, #0
 801a460:	d100      	bne.n	801a464 <l2cap_handle_connection_success_for_addr+0x38>
 801a462:	e00d      	b.n	801a480 <l2cap_handle_connection_success_for_addr+0x54>
        if ( ! bd_addr_cmp( channel->address, address) ){
 801a464:	697b      	ldr	r3, [r7, #20]
 801a466:	3326      	adds	r3, #38	; 0x26
 801a468:	6879      	ldr	r1, [r7, #4]
 801a46a:	4618      	mov	r0, r3
 801a46c:	f7f4 fc9e 	bl	800edac <bd_addr_cmp>
 801a470:	4603      	mov	r3, r0
 801a472:	2b00      	cmp	r3, #0
 801a474:	d104      	bne.n	801a480 <l2cap_handle_connection_success_for_addr+0x54>
            l2cap_handle_connection_complete(handle, channel);
 801a476:	887b      	ldrh	r3, [r7, #2]
 801a478:	6979      	ldr	r1, [r7, #20]
 801a47a:	4618      	mov	r0, r3
 801a47c:	f7ff fe66 	bl	801a14c <l2cap_handle_connection_complete>
    while (btstack_linked_list_iterator_has_next(&it)){
 801a480:	f107 0308 	add.w	r3, r7, #8
 801a484:	4618      	mov	r0, r3
 801a486:	f7f4 f977 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801a48a:	4603      	mov	r3, r0
 801a48c:	2b00      	cmp	r3, #0
 801a48e:	d1da      	bne.n	801a446 <l2cap_handle_connection_success_for_addr+0x1a>
        }
    }
    // process
    l2cap_run();
 801a490:	f7ff fdb2 	bl	8019ff8 <l2cap_run>
}
 801a494:	bf00      	nop
 801a496:	3718      	adds	r7, #24
 801a498:	46bd      	mov	sp, r7
 801a49a:	bd80      	pop	{r7, pc}
 801a49c:	20009eac 	.word	0x20009eac

0801a4a0 <l2cap_channel_ready_to_send>:
#endif

static bool l2cap_channel_ready_to_send(l2cap_channel_t * channel){
 801a4a0:	b590      	push	{r4, r7, lr}
 801a4a2:	b083      	sub	sp, #12
 801a4a4:	af00      	add	r7, sp, #0
 801a4a6:	6078      	str	r0, [r7, #4]
    switch (channel->channel_type){
 801a4a8:	687b      	ldr	r3, [r7, #4]
 801a4aa:	791b      	ldrb	r3, [r3, #4]
 801a4ac:	2b03      	cmp	r3, #3
 801a4ae:	d87e      	bhi.n	801a5ae <l2cap_channel_ready_to_send+0x10e>
 801a4b0:	a201      	add	r2, pc, #4	; (adr r2, 801a4b8 <l2cap_channel_ready_to_send+0x18>)
 801a4b2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a4b6:	bf00      	nop
 801a4b8:	0801a4c9 	.word	0x0801a4c9
 801a4bc:	0801a539 	.word	0x0801a539
 801a4c0:	0801a575 	.word	0x0801a575
 801a4c4:	0801a557 	.word	0x0801a557
#ifdef ENABLE_CLASSIC
        case L2CAP_CHANNEL_TYPE_CLASSIC:
            if (channel->state != L2CAP_STATE_OPEN) return false;
 801a4c8:	687b      	ldr	r3, [r7, #4]
 801a4ca:	f893 3020 	ldrb.w	r3, [r3, #32]
 801a4ce:	2b0c      	cmp	r3, #12
 801a4d0:	d001      	beq.n	801a4d6 <l2cap_channel_ready_to_send+0x36>
 801a4d2:	2300      	movs	r3, #0
 801a4d4:	e06c      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
            // send if we have more data and remote windows isn't full yet
            if (channel->mode == L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION) {
 801a4d6:	687b      	ldr	r3, [r7, #4]
 801a4d8:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 801a4dc:	2b03      	cmp	r3, #3
 801a4de:	d11c      	bne.n	801a51a <l2cap_channel_ready_to_send+0x7a>
                if (channel->unacked_frames >= btstack_min(channel->num_stored_tx_frames, channel->remote_tx_window_size)) return false;
 801a4e0:	687b      	ldr	r3, [r7, #4]
 801a4e2:	f893 308b 	ldrb.w	r3, [r3, #139]	; 0x8b
 801a4e6:	461c      	mov	r4, r3
 801a4e8:	687b      	ldr	r3, [r7, #4]
 801a4ea:	f893 308a 	ldrb.w	r3, [r3, #138]	; 0x8a
 801a4ee:	461a      	mov	r2, r3
 801a4f0:	687b      	ldr	r3, [r7, #4]
 801a4f2:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 801a4f6:	4619      	mov	r1, r3
 801a4f8:	4610      	mov	r0, r2
 801a4fa:	f7f4 fe08 	bl	800f10e <btstack_min>
 801a4fe:	4603      	mov	r3, r0
 801a500:	429c      	cmp	r4, r3
 801a502:	d301      	bcc.n	801a508 <l2cap_channel_ready_to_send+0x68>
 801a504:	2300      	movs	r3, #0
 801a506:	e053      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
                return hci_can_send_acl_classic_packet_now() != 0;
 801a508:	f7f5 fd82 	bl	8010010 <hci_can_send_acl_classic_packet_now>
 801a50c:	4603      	mov	r3, r0
 801a50e:	2b00      	cmp	r3, #0
 801a510:	bf14      	ite	ne
 801a512:	2301      	movne	r3, #1
 801a514:	2300      	moveq	r3, #0
 801a516:	b2db      	uxtb	r3, r3
 801a518:	e04a      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
            }
#endif
            if (!channel->waiting_for_can_send_now) return false;
 801a51a:	687b      	ldr	r3, [r7, #4]
 801a51c:	7b1b      	ldrb	r3, [r3, #12]
 801a51e:	2b00      	cmp	r3, #0
 801a520:	d101      	bne.n	801a526 <l2cap_channel_ready_to_send+0x86>
 801a522:	2300      	movs	r3, #0
 801a524:	e044      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
            return (hci_can_send_acl_classic_packet_now() != 0);
 801a526:	f7f5 fd73 	bl	8010010 <hci_can_send_acl_classic_packet_now>
 801a52a:	4603      	mov	r3, r0
 801a52c:	2b00      	cmp	r3, #0
 801a52e:	bf14      	ite	ne
 801a530:	2301      	movne	r3, #1
 801a532:	2300      	moveq	r3, #0
 801a534:	b2db      	uxtb	r3, r3
 801a536:	e03b      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
        case L2CAP_CHANNEL_TYPE_CONNECTIONLESS:
            if (!channel->waiting_for_can_send_now) return false;
 801a538:	687b      	ldr	r3, [r7, #4]
 801a53a:	7b1b      	ldrb	r3, [r3, #12]
 801a53c:	2b00      	cmp	r3, #0
 801a53e:	d101      	bne.n	801a544 <l2cap_channel_ready_to_send+0xa4>
 801a540:	2300      	movs	r3, #0
 801a542:	e035      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
            return hci_can_send_acl_classic_packet_now() != 0;
 801a544:	f7f5 fd64 	bl	8010010 <hci_can_send_acl_classic_packet_now>
 801a548:	4603      	mov	r3, r0
 801a54a:	2b00      	cmp	r3, #0
 801a54c:	bf14      	ite	ne
 801a54e:	2301      	movne	r3, #1
 801a550:	2300      	moveq	r3, #0
 801a552:	b2db      	uxtb	r3, r3
 801a554:	e02c      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
#endif
#ifdef ENABLE_BLE
        case L2CAP_CHANNEL_TYPE_LE_FIXED:
            if (!channel->waiting_for_can_send_now) return false;
 801a556:	687b      	ldr	r3, [r7, #4]
 801a558:	7b1b      	ldrb	r3, [r3, #12]
 801a55a:	2b00      	cmp	r3, #0
 801a55c:	d101      	bne.n	801a562 <l2cap_channel_ready_to_send+0xc2>
 801a55e:	2300      	movs	r3, #0
 801a560:	e026      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
            return hci_can_send_acl_le_packet_now() != 0;
 801a562:	f7f5 fd0f 	bl	800ff84 <hci_can_send_acl_le_packet_now>
 801a566:	4603      	mov	r3, r0
 801a568:	2b00      	cmp	r3, #0
 801a56a:	bf14      	ite	ne
 801a56c:	2301      	movne	r3, #1
 801a56e:	2300      	moveq	r3, #0
 801a570:	b2db      	uxtb	r3, r3
 801a572:	e01d      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
#ifdef ENABLE_LE_DATA_CHANNELS
        case L2CAP_CHANNEL_TYPE_LE_DATA_CHANNEL:
            if (channel->state != L2CAP_STATE_OPEN) return false;
 801a574:	687b      	ldr	r3, [r7, #4]
 801a576:	f893 3020 	ldrb.w	r3, [r3, #32]
 801a57a:	2b0c      	cmp	r3, #12
 801a57c:	d001      	beq.n	801a582 <l2cap_channel_ready_to_send+0xe2>
 801a57e:	2300      	movs	r3, #0
 801a580:	e016      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
            if (channel->send_sdu_buffer == NULL) return false;
 801a582:	687b      	ldr	r3, [r7, #4]
 801a584:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801a586:	2b00      	cmp	r3, #0
 801a588:	d101      	bne.n	801a58e <l2cap_channel_ready_to_send+0xee>
 801a58a:	2300      	movs	r3, #0
 801a58c:	e010      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
            if (channel->credits_outgoing == 0u) return false;
 801a58e:	687b      	ldr	r3, [r7, #4]
 801a590:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 801a594:	2b00      	cmp	r3, #0
 801a596:	d101      	bne.n	801a59c <l2cap_channel_ready_to_send+0xfc>
 801a598:	2300      	movs	r3, #0
 801a59a:	e009      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
            return hci_can_send_acl_le_packet_now() != 0;
 801a59c:	f7f5 fcf2 	bl	800ff84 <hci_can_send_acl_le_packet_now>
 801a5a0:	4603      	mov	r3, r0
 801a5a2:	2b00      	cmp	r3, #0
 801a5a4:	bf14      	ite	ne
 801a5a6:	2301      	movne	r3, #1
 801a5a8:	2300      	moveq	r3, #0
 801a5aa:	b2db      	uxtb	r3, r3
 801a5ac:	e000      	b.n	801a5b0 <l2cap_channel_ready_to_send+0x110>
#endif
#endif
        default:
            return false;
 801a5ae:	2300      	movs	r3, #0
    }
}
 801a5b0:	4618      	mov	r0, r3
 801a5b2:	370c      	adds	r7, #12
 801a5b4:	46bd      	mov	sp, r7
 801a5b6:	bd90      	pop	{r4, r7, pc}

0801a5b8 <l2cap_channel_trigger_send>:

static void l2cap_channel_trigger_send(l2cap_channel_t * channel){
 801a5b8:	b580      	push	{r7, lr}
 801a5ba:	b082      	sub	sp, #8
 801a5bc:	af00      	add	r7, sp, #0
 801a5be:	6078      	str	r0, [r7, #4]
    switch (channel->channel_type){
 801a5c0:	687b      	ldr	r3, [r7, #4]
 801a5c2:	791b      	ldrb	r3, [r3, #4]
 801a5c4:	2b03      	cmp	r3, #3
 801a5c6:	d83c      	bhi.n	801a642 <l2cap_channel_trigger_send+0x8a>
 801a5c8:	a201      	add	r2, pc, #4	; (adr r2, 801a5d0 <l2cap_channel_trigger_send+0x18>)
 801a5ca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a5ce:	bf00      	nop
 801a5d0:	0801a5e1 	.word	0x0801a5e1
 801a5d4:	0801a60b 	.word	0x0801a60b
 801a5d8:	0801a63b 	.word	0x0801a63b
 801a5dc:	0801a623 	.word	0x0801a623
#ifdef ENABLE_CLASSIC
        case L2CAP_CHANNEL_TYPE_CLASSIC:
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
            if (channel->mode == L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION) {
 801a5e0:	687b      	ldr	r3, [r7, #4]
 801a5e2:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 801a5e6:	2b03      	cmp	r3, #3
 801a5e8:	d103      	bne.n	801a5f2 <l2cap_channel_trigger_send+0x3a>
                l2cap_ertm_channel_send_information_frame(channel);
 801a5ea:	6878      	ldr	r0, [r7, #4]
 801a5ec:	f7fd ff7e 	bl	80184ec <l2cap_ertm_channel_send_information_frame>
                return;
 801a5f0:	e028      	b.n	801a644 <l2cap_channel_trigger_send+0x8c>
            }
#endif
            channel->waiting_for_can_send_now = 0;
 801a5f2:	687b      	ldr	r3, [r7, #4]
 801a5f4:	2200      	movs	r2, #0
 801a5f6:	731a      	strb	r2, [r3, #12]
            l2cap_emit_can_send_now(channel->packet_handler, channel->local_cid);
 801a5f8:	687b      	ldr	r3, [r7, #4]
 801a5fa:	689a      	ldr	r2, [r3, #8]
 801a5fc:	687b      	ldr	r3, [r7, #4]
 801a5fe:	88db      	ldrh	r3, [r3, #6]
 801a600:	4619      	mov	r1, r3
 801a602:	4610      	mov	r0, r2
 801a604:	f7fe f934 	bl	8018870 <l2cap_emit_can_send_now>
            break;
 801a608:	e01c      	b.n	801a644 <l2cap_channel_trigger_send+0x8c>
        case L2CAP_CHANNEL_TYPE_CONNECTIONLESS:
            channel->waiting_for_can_send_now = 0;
 801a60a:	687b      	ldr	r3, [r7, #4]
 801a60c:	2200      	movs	r2, #0
 801a60e:	731a      	strb	r2, [r3, #12]
            l2cap_emit_can_send_now(channel->packet_handler, channel->local_cid);
 801a610:	687b      	ldr	r3, [r7, #4]
 801a612:	689a      	ldr	r2, [r3, #8]
 801a614:	687b      	ldr	r3, [r7, #4]
 801a616:	88db      	ldrh	r3, [r3, #6]
 801a618:	4619      	mov	r1, r3
 801a61a:	4610      	mov	r0, r2
 801a61c:	f7fe f928 	bl	8018870 <l2cap_emit_can_send_now>
            break;
 801a620:	e010      	b.n	801a644 <l2cap_channel_trigger_send+0x8c>
#endif
#ifdef ENABLE_BLE
        case L2CAP_CHANNEL_TYPE_LE_FIXED:
            channel->waiting_for_can_send_now = 0;
 801a622:	687b      	ldr	r3, [r7, #4]
 801a624:	2200      	movs	r2, #0
 801a626:	731a      	strb	r2, [r3, #12]
            l2cap_emit_can_send_now(channel->packet_handler, channel->local_cid);
 801a628:	687b      	ldr	r3, [r7, #4]
 801a62a:	689a      	ldr	r2, [r3, #8]
 801a62c:	687b      	ldr	r3, [r7, #4]
 801a62e:	88db      	ldrh	r3, [r3, #6]
 801a630:	4619      	mov	r1, r3
 801a632:	4610      	mov	r0, r2
 801a634:	f7fe f91c 	bl	8018870 <l2cap_emit_can_send_now>
            break;
 801a638:	e004      	b.n	801a644 <l2cap_channel_trigger_send+0x8c>
#ifdef ENABLE_LE_DATA_CHANNELS
        case L2CAP_CHANNEL_TYPE_LE_DATA_CHANNEL:
            l2cap_le_send_pdu(channel);
 801a63a:	6878      	ldr	r0, [r7, #4]
 801a63c:	f002 fbee 	bl	801ce1c <l2cap_le_send_pdu>
            break;
 801a640:	e000      	b.n	801a644 <l2cap_channel_trigger_send+0x8c>
#endif
#endif
        default:
            break;
 801a642:	bf00      	nop
    }
}
 801a644:	3708      	adds	r7, #8
 801a646:	46bd      	mov	sp, r7
 801a648:	bd80      	pop	{r7, pc}
 801a64a:	bf00      	nop

0801a64c <l2cap_notify_channel_can_send>:

static void l2cap_notify_channel_can_send(void){
 801a64c:	b580      	push	{r7, lr}
 801a64e:	b086      	sub	sp, #24
 801a650:	af00      	add	r7, sp, #0
    bool done = false;
 801a652:	2300      	movs	r3, #0
 801a654:	75fb      	strb	r3, [r7, #23]
    while (!done){
 801a656:	e02d      	b.n	801a6b4 <l2cap_notify_channel_can_send+0x68>
        done = true;
 801a658:	2301      	movs	r3, #1
 801a65a:	75fb      	strb	r3, [r7, #23]
        btstack_linked_list_iterator_t it;
        btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801a65c:	463b      	mov	r3, r7
 801a65e:	491a      	ldr	r1, [pc, #104]	; (801a6c8 <l2cap_notify_channel_can_send+0x7c>)
 801a660:	4618      	mov	r0, r3
 801a662:	f7f4 f874 	bl	800e74e <btstack_linked_list_iterator_init>
        while (btstack_linked_list_iterator_has_next(&it)){
 801a666:	e01e      	b.n	801a6a6 <l2cap_notify_channel_can_send+0x5a>
            l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801a668:	463b      	mov	r3, r7
 801a66a:	4618      	mov	r0, r3
 801a66c:	f7f4 f8b2 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801a670:	6138      	str	r0, [r7, #16]
            bool ready = l2cap_channel_ready_to_send(channel);
 801a672:	6938      	ldr	r0, [r7, #16]
 801a674:	f7ff ff14 	bl	801a4a0 <l2cap_channel_ready_to_send>
 801a678:	4603      	mov	r3, r0
 801a67a:	73fb      	strb	r3, [r7, #15]
            if (!ready) continue;
 801a67c:	7bfb      	ldrb	r3, [r7, #15]
 801a67e:	f083 0301 	eor.w	r3, r3, #1
 801a682:	b2db      	uxtb	r3, r3
 801a684:	2b00      	cmp	r3, #0
 801a686:	d000      	beq.n	801a68a <l2cap_notify_channel_can_send+0x3e>
 801a688:	e00d      	b.n	801a6a6 <l2cap_notify_channel_can_send+0x5a>

            // requeue channel for fairness
            btstack_linked_list_remove(&l2cap_channels, (btstack_linked_item_t *) channel);
 801a68a:	6939      	ldr	r1, [r7, #16]
 801a68c:	480e      	ldr	r0, [pc, #56]	; (801a6c8 <l2cap_notify_channel_can_send+0x7c>)
 801a68e:	f7f4 f816 	bl	800e6be <btstack_linked_list_remove>
            btstack_linked_list_add_tail(&l2cap_channels, (btstack_linked_item_t *) channel);
 801a692:	6939      	ldr	r1, [r7, #16]
 801a694:	480c      	ldr	r0, [pc, #48]	; (801a6c8 <l2cap_notify_channel_can_send+0x7c>)
 801a696:	f7f3 ffef 	bl	800e678 <btstack_linked_list_add_tail>

            // trigger sending
            l2cap_channel_trigger_send(channel);
 801a69a:	6938      	ldr	r0, [r7, #16]
 801a69c:	f7ff ff8c 	bl	801a5b8 <l2cap_channel_trigger_send>

            // exit inner loop as we just broke the iterator, but try again
            done = false;
 801a6a0:	2300      	movs	r3, #0
 801a6a2:	75fb      	strb	r3, [r7, #23]
            break;
 801a6a4:	e006      	b.n	801a6b4 <l2cap_notify_channel_can_send+0x68>
        while (btstack_linked_list_iterator_has_next(&it)){
 801a6a6:	463b      	mov	r3, r7
 801a6a8:	4618      	mov	r0, r3
 801a6aa:	f7f4 f865 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801a6ae:	4603      	mov	r3, r0
 801a6b0:	2b00      	cmp	r3, #0
 801a6b2:	d1d9      	bne.n	801a668 <l2cap_notify_channel_can_send+0x1c>
    while (!done){
 801a6b4:	7dfb      	ldrb	r3, [r7, #23]
 801a6b6:	f083 0301 	eor.w	r3, r3, #1
 801a6ba:	b2db      	uxtb	r3, r3
 801a6bc:	2b00      	cmp	r3, #0
 801a6be:	d1cb      	bne.n	801a658 <l2cap_notify_channel_can_send+0xc>
        }
    }
}
 801a6c0:	bf00      	nop
 801a6c2:	3718      	adds	r7, #24
 801a6c4:	46bd      	mov	sp, r7
 801a6c6:	bd80      	pop	{r7, pc}
 801a6c8:	20009eac 	.word	0x20009eac

0801a6cc <l2cap_send_open_failed_on_hci_disconnect>:

#ifdef L2CAP_USES_CHANNELS

static int l2cap_send_open_failed_on_hci_disconnect(l2cap_channel_t * channel){
 801a6cc:	b480      	push	{r7}
 801a6ce:	b083      	sub	sp, #12
 801a6d0:	af00      	add	r7, sp, #0
 801a6d2:	6078      	str	r0, [r7, #4]
    // open cannot fail for for incoming connections
    if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_INCOMING) return 0;
 801a6d4:	687b      	ldr	r3, [r7, #4]
 801a6d6:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801a6d8:	b21b      	sxth	r3, r3
 801a6da:	2b00      	cmp	r3, #0
 801a6dc:	da01      	bge.n	801a6e2 <l2cap_send_open_failed_on_hci_disconnect+0x16>
 801a6de:	2300      	movs	r3, #0
 801a6e0:	e03f      	b.n	801a762 <l2cap_send_open_failed_on_hci_disconnect+0x96>

    // check state
    switch (channel->state){
 801a6e2:	687b      	ldr	r3, [r7, #4]
 801a6e4:	f893 3020 	ldrb.w	r3, [r3, #32]
 801a6e8:	3b01      	subs	r3, #1
 801a6ea:	2b18      	cmp	r3, #24
 801a6ec:	d838      	bhi.n	801a760 <l2cap_send_open_failed_on_hci_disconnect+0x94>
 801a6ee:	a201      	add	r2, pc, #4	; (adr r2, 801a6f4 <l2cap_send_open_failed_on_hci_disconnect+0x28>)
 801a6f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a6f4:	0801a75d 	.word	0x0801a75d
 801a6f8:	0801a759 	.word	0x0801a759
 801a6fc:	0801a759 	.word	0x0801a759
 801a700:	0801a759 	.word	0x0801a759
 801a704:	0801a75d 	.word	0x0801a75d
 801a708:	0801a759 	.word	0x0801a759
 801a70c:	0801a75d 	.word	0x0801a75d
 801a710:	0801a759 	.word	0x0801a759
 801a714:	0801a759 	.word	0x0801a759
 801a718:	0801a759 	.word	0x0801a759
 801a71c:	0801a759 	.word	0x0801a759
 801a720:	0801a75d 	.word	0x0801a75d
 801a724:	0801a75d 	.word	0x0801a75d
 801a728:	0801a759 	.word	0x0801a759
 801a72c:	0801a75d 	.word	0x0801a75d
 801a730:	0801a75d 	.word	0x0801a75d
 801a734:	0801a75d 	.word	0x0801a75d
 801a738:	0801a75d 	.word	0x0801a75d
 801a73c:	0801a75d 	.word	0x0801a75d
 801a740:	0801a759 	.word	0x0801a759
 801a744:	0801a75d 	.word	0x0801a75d
 801a748:	0801a75d 	.word	0x0801a75d
 801a74c:	0801a759 	.word	0x0801a759
 801a750:	0801a759 	.word	0x0801a759
 801a754:	0801a75d 	.word	0x0801a75d
        case L2CAP_STATE_CONFIG:
        case L2CAP_STATE_WILL_SEND_CONNECTION_REQUEST:
        case L2CAP_STATE_WILL_SEND_LE_CONNECTION_REQUEST:
        case L2CAP_STATE_WAIT_LE_CONNECTION_RESPONSE:
        case L2CAP_STATE_EMIT_OPEN_FAILED_AND_DISCARD:
            return 1;
 801a758:	2301      	movs	r3, #1
 801a75a:	e002      	b.n	801a762 <l2cap_send_open_failed_on_hci_disconnect+0x96>
        case L2CAP_STATE_WILL_SEND_DISCONNECT_RESPONSE:
        case L2CAP_STATE_WILL_SEND_LE_CONNECTION_RESPONSE_DECLINE:
        case L2CAP_STATE_WILL_SEND_LE_CONNECTION_RESPONSE_ACCEPT:
        case L2CAP_STATE_INVALID:
        case L2CAP_STATE_WAIT_INCOMING_SECURITY_LEVEL_UPDATE:
            return 0;
 801a75c:	2300      	movs	r3, #0
 801a75e:	e000      	b.n	801a762 <l2cap_send_open_failed_on_hci_disconnect+0x96>

        default:
            // get a "warning" about new states
            btstack_assert(false);
            return 0;
 801a760:	2300      	movs	r3, #0
    }
}
 801a762:	4618      	mov	r0, r3
 801a764:	370c      	adds	r7, #12
 801a766:	46bd      	mov	sp, r7
 801a768:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a76c:	4770      	bx	lr
 801a76e:	bf00      	nop

0801a770 <l2cap_handle_hci_disconnect_event>:
#endif

#ifdef ENABLE_CLASSIC
static void l2cap_handle_hci_disconnect_event(l2cap_channel_t * channel){
 801a770:	b580      	push	{r7, lr}
 801a772:	b082      	sub	sp, #8
 801a774:	af00      	add	r7, sp, #0
 801a776:	6078      	str	r0, [r7, #4]
    if (l2cap_send_open_failed_on_hci_disconnect(channel)){
 801a778:	6878      	ldr	r0, [r7, #4]
 801a77a:	f7ff ffa7 	bl	801a6cc <l2cap_send_open_failed_on_hci_disconnect>
 801a77e:	4603      	mov	r3, r0
 801a780:	2b00      	cmp	r3, #0
 801a782:	d004      	beq.n	801a78e <l2cap_handle_hci_disconnect_event+0x1e>
        l2cap_handle_channel_open_failed(channel, L2CAP_CONNECTION_BASEBAND_DISCONNECT);
 801a784:	216a      	movs	r1, #106	; 0x6a
 801a786:	6878      	ldr	r0, [r7, #4]
 801a788:	f7fe fa08 	bl	8018b9c <l2cap_handle_channel_open_failed>
 801a78c:	e002      	b.n	801a794 <l2cap_handle_hci_disconnect_event+0x24>
    } else {
        l2cap_handle_channel_closed(channel);
 801a78e:	6878      	ldr	r0, [r7, #4]
 801a790:	f7fe fa1c 	bl	8018bcc <l2cap_handle_channel_closed>
    }
    l2cap_free_channel_entry(channel);
 801a794:	6878      	ldr	r0, [r7, #4]
 801a796:	f7ff fdab 	bl	801a2f0 <l2cap_free_channel_entry>
}
 801a79a:	bf00      	nop
 801a79c:	3708      	adds	r7, #8
 801a79e:	46bd      	mov	sp, r7
 801a7a0:	bd80      	pop	{r7, pc}

0801a7a2 <l2cap_handle_hci_le_disconnect_event>:
#endif

#ifdef ENABLE_LE_DATA_CHANNELS
static void l2cap_handle_hci_le_disconnect_event(l2cap_channel_t * channel){
 801a7a2:	b580      	push	{r7, lr}
 801a7a4:	b082      	sub	sp, #8
 801a7a6:	af00      	add	r7, sp, #0
 801a7a8:	6078      	str	r0, [r7, #4]
    if (l2cap_send_open_failed_on_hci_disconnect(channel)){
 801a7aa:	6878      	ldr	r0, [r7, #4]
 801a7ac:	f7ff ff8e 	bl	801a6cc <l2cap_send_open_failed_on_hci_disconnect>
 801a7b0:	4603      	mov	r3, r0
 801a7b2:	2b00      	cmp	r3, #0
 801a7b4:	d004      	beq.n	801a7c0 <l2cap_handle_hci_le_disconnect_event+0x1e>
        l2cap_emit_le_channel_opened(channel, L2CAP_CONNECTION_BASEBAND_DISCONNECT);
 801a7b6:	216a      	movs	r1, #106	; 0x6a
 801a7b8:	6878      	ldr	r0, [r7, #4]
 801a7ba:	f002 fa67 	bl	801cc8c <l2cap_emit_le_channel_opened>
 801a7be:	e002      	b.n	801a7c6 <l2cap_handle_hci_le_disconnect_event+0x24>
    } else {
        l2cap_emit_le_channel_closed(channel);
 801a7c0:	6878      	ldr	r0, [r7, #4]
 801a7c2:	f002 fafb 	bl	801cdbc <l2cap_emit_le_channel_closed>
    }
    l2cap_free_channel_entry(channel);
 801a7c6:	6878      	ldr	r0, [r7, #4]
 801a7c8:	f7ff fd92 	bl	801a2f0 <l2cap_free_channel_entry>
}
 801a7cc:	bf00      	nop
 801a7ce:	3708      	adds	r7, #8
 801a7d0:	46bd      	mov	sp, r7
 801a7d2:	bd80      	pop	{r7, pc}

0801a7d4 <l2cap_check_classic_timeout>:
#endif

#ifdef ENABLE_CLASSIC
static void l2cap_check_classic_timeout(hci_con_handle_t handle){
 801a7d4:	b580      	push	{r7, lr}
 801a7d6:	b088      	sub	sp, #32
 801a7d8:	af00      	add	r7, sp, #0
 801a7da:	4603      	mov	r3, r0
 801a7dc:	80fb      	strh	r3, [r7, #6]
    if (gap_get_connection_type(handle) != GAP_CONNECTION_ACL) {
 801a7de:	88fb      	ldrh	r3, [r7, #6]
 801a7e0:	4618      	mov	r0, r3
 801a7e2:	f7fc f967 	bl	8016ab4 <gap_get_connection_type>
 801a7e6:	4603      	mov	r3, r0
 801a7e8:	2b01      	cmp	r3, #1
 801a7ea:	d13e      	bne.n	801a86a <l2cap_check_classic_timeout+0x96>
        return;
    }
    if (hci_authentication_active_for_handle(handle)) {
 801a7ec:	88fb      	ldrh	r3, [r7, #6]
 801a7ee:	4618      	mov	r0, r3
 801a7f0:	f7f5 f962 	bl	800fab8 <hci_authentication_active_for_handle>
 801a7f4:	4603      	mov	r3, r0
 801a7f6:	2b00      	cmp	r3, #0
 801a7f8:	d139      	bne.n	801a86e <l2cap_check_classic_timeout+0x9a>
        return;
    }
    bool hci_con_used = false;
 801a7fa:	2300      	movs	r3, #0
 801a7fc:	77fb      	strb	r3, [r7, #31]
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801a7fe:	f107 030c 	add.w	r3, r7, #12
 801a802:	491f      	ldr	r1, [pc, #124]	; (801a880 <l2cap_check_classic_timeout+0xac>)
 801a804:	4618      	mov	r0, r3
 801a806:	f7f3 ffa2 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 801a80a:	e017      	b.n	801a83c <l2cap_check_classic_timeout+0x68>
        l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801a80c:	f107 030c 	add.w	r3, r7, #12
 801a810:	4618      	mov	r0, r3
 801a812:	f7f3 ffdf 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801a816:	61b8      	str	r0, [r7, #24]
        if (!l2cap_is_dynamic_channel_type(channel->channel_type)) continue;
 801a818:	69bb      	ldr	r3, [r7, #24]
 801a81a:	791b      	ldrb	r3, [r3, #4]
 801a81c:	4618      	mov	r0, r3
 801a81e:	f7fe fa5a 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801a822:	4603      	mov	r3, r0
 801a824:	2b00      	cmp	r3, #0
 801a826:	d100      	bne.n	801a82a <l2cap_check_classic_timeout+0x56>
 801a828:	e008      	b.n	801a83c <l2cap_check_classic_timeout+0x68>
        if (channel->con_handle != handle) continue;
 801a82a:	69bb      	ldr	r3, [r7, #24]
 801a82c:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801a82e:	88fa      	ldrh	r2, [r7, #6]
 801a830:	429a      	cmp	r2, r3
 801a832:	d000      	beq.n	801a836 <l2cap_check_classic_timeout+0x62>
 801a834:	e002      	b.n	801a83c <l2cap_check_classic_timeout+0x68>
        hci_con_used = true;
 801a836:	2301      	movs	r3, #1
 801a838:	77fb      	strb	r3, [r7, #31]
        break;
 801a83a:	e007      	b.n	801a84c <l2cap_check_classic_timeout+0x78>
    while (btstack_linked_list_iterator_has_next(&it)){
 801a83c:	f107 030c 	add.w	r3, r7, #12
 801a840:	4618      	mov	r0, r3
 801a842:	f7f3 ff99 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801a846:	4603      	mov	r3, r0
 801a848:	2b00      	cmp	r3, #0
 801a84a:	d1df      	bne.n	801a80c <l2cap_check_classic_timeout+0x38>
    }
    if (hci_con_used) {
 801a84c:	7ffb      	ldrb	r3, [r7, #31]
 801a84e:	2b00      	cmp	r3, #0
 801a850:	d10f      	bne.n	801a872 <l2cap_check_classic_timeout+0x9e>
        return;
    }
    if (!hci_can_send_command_packet_now()) {
 801a852:	f7f5 fb49 	bl	800fee8 <hci_can_send_command_packet_now>
 801a856:	4603      	mov	r3, r0
 801a858:	2b00      	cmp	r3, #0
 801a85a:	d00c      	beq.n	801a876 <l2cap_check_classic_timeout+0xa2>
        return;
    }
    hci_send_cmd(&hci_disconnect, handle, 0x13); // remote closed connection
 801a85c:	88fb      	ldrh	r3, [r7, #6]
 801a85e:	2213      	movs	r2, #19
 801a860:	4619      	mov	r1, r3
 801a862:	4808      	ldr	r0, [pc, #32]	; (801a884 <l2cap_check_classic_timeout+0xb0>)
 801a864:	f7fb fbbc 	bl	8015fe0 <hci_send_cmd>
 801a868:	e006      	b.n	801a878 <l2cap_check_classic_timeout+0xa4>
        return;
 801a86a:	bf00      	nop
 801a86c:	e004      	b.n	801a878 <l2cap_check_classic_timeout+0xa4>
        return;
 801a86e:	bf00      	nop
 801a870:	e002      	b.n	801a878 <l2cap_check_classic_timeout+0xa4>
        return;
 801a872:	bf00      	nop
 801a874:	e000      	b.n	801a878 <l2cap_check_classic_timeout+0xa4>
        return;
 801a876:	bf00      	nop
}
 801a878:	3720      	adds	r7, #32
 801a87a:	46bd      	mov	sp, r7
 801a87c:	bd80      	pop	{r7, pc}
 801a87e:	bf00      	nop
 801a880:	20009eac 	.word	0x20009eac
 801a884:	08030a10 	.word	0x08030a10

0801a888 <l2cap_handle_features_complete>:
static void l2cap_handle_features_complete(hci_con_handle_t handle){
 801a888:	b580      	push	{r7, lr}
 801a88a:	b08c      	sub	sp, #48	; 0x30
 801a88c:	af04      	add	r7, sp, #16
 801a88e:	4603      	mov	r3, r0
 801a890:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * hci_connection = hci_connection_for_handle(handle);
 801a892:	88fb      	ldrh	r3, [r7, #6]
 801a894:	4618      	mov	r0, r3
 801a896:	f7f5 f815 	bl	800f8c4 <hci_connection_for_handle>
 801a89a:	61f8      	str	r0, [r7, #28]
    if (hci_connection == NULL) {
 801a89c:	69fb      	ldr	r3, [r7, #28]
 801a89e:	2b00      	cmp	r3, #0
 801a8a0:	d03e      	beq.n	801a920 <l2cap_handle_features_complete+0x98>
        return;
    };
    if ((hci_connection->bonding_flags & BONDING_RECEIVED_REMOTE_FEATURES) == 0) {
 801a8a2:	69fb      	ldr	r3, [r7, #28]
 801a8a4:	8a1b      	ldrh	r3, [r3, #16]
 801a8a6:	f003 0308 	and.w	r3, r3, #8
 801a8aa:	2b00      	cmp	r3, #0
 801a8ac:	d03a      	beq.n	801a924 <l2cap_handle_features_complete+0x9c>
        return;
    }
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801a8ae:	f107 030c 	add.w	r3, r7, #12
 801a8b2:	491e      	ldr	r1, [pc, #120]	; (801a92c <l2cap_handle_features_complete+0xa4>)
 801a8b4:	4618      	mov	r0, r3
 801a8b6:	f7f3 ff4a 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 801a8ba:	e028      	b.n	801a90e <l2cap_handle_features_complete+0x86>
        l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801a8bc:	f107 030c 	add.w	r3, r7, #12
 801a8c0:	4618      	mov	r0, r3
 801a8c2:	f7f3 ff87 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801a8c6:	61b8      	str	r0, [r7, #24]
        if (!l2cap_is_dynamic_channel_type(channel->channel_type)) continue;
 801a8c8:	69bb      	ldr	r3, [r7, #24]
 801a8ca:	791b      	ldrb	r3, [r3, #4]
 801a8cc:	4618      	mov	r0, r3
 801a8ce:	f7fe fa02 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801a8d2:	4603      	mov	r3, r0
 801a8d4:	2b00      	cmp	r3, #0
 801a8d6:	d100      	bne.n	801a8da <l2cap_handle_features_complete+0x52>
 801a8d8:	e019      	b.n	801a90e <l2cap_handle_features_complete+0x86>
        if (channel->con_handle != handle) continue;
 801a8da:	69bb      	ldr	r3, [r7, #24]
 801a8dc:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801a8de:	88fa      	ldrh	r2, [r7, #6]
 801a8e0:	429a      	cmp	r2, r3
 801a8e2:	d000      	beq.n	801a8e6 <l2cap_handle_features_complete+0x5e>
 801a8e4:	e013      	b.n	801a90e <l2cap_handle_features_complete+0x86>
        log_info("remote supported features, channel %p, cid %04x - state %u", channel, channel->local_cid, channel->state);
 801a8e6:	69bb      	ldr	r3, [r7, #24]
 801a8e8:	88db      	ldrh	r3, [r3, #6]
 801a8ea:	461a      	mov	r2, r3
 801a8ec:	69bb      	ldr	r3, [r7, #24]
 801a8ee:	f893 3020 	ldrb.w	r3, [r3, #32]
 801a8f2:	9302      	str	r3, [sp, #8]
 801a8f4:	9201      	str	r2, [sp, #4]
 801a8f6:	69bb      	ldr	r3, [r7, #24]
 801a8f8:	9300      	str	r3, [sp, #0]
 801a8fa:	f640 131c 	movw	r3, #2332	; 0x91c
 801a8fe:	4a0c      	ldr	r2, [pc, #48]	; (801a930 <l2cap_handle_features_complete+0xa8>)
 801a900:	490c      	ldr	r1, [pc, #48]	; (801a934 <l2cap_handle_features_complete+0xac>)
 801a902:	2001      	movs	r0, #1
 801a904:	f7fc fd9c 	bl	8017440 <hci_dump_log>
        l2cap_handle_remote_supported_features_received(channel);
 801a908:	69b8      	ldr	r0, [r7, #24]
 801a90a:	f7ff fc6c 	bl	801a1e6 <l2cap_handle_remote_supported_features_received>
    while (btstack_linked_list_iterator_has_next(&it)){
 801a90e:	f107 030c 	add.w	r3, r7, #12
 801a912:	4618      	mov	r0, r3
 801a914:	f7f3 ff30 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801a918:	4603      	mov	r3, r0
 801a91a:	2b00      	cmp	r3, #0
 801a91c:	d1ce      	bne.n	801a8bc <l2cap_handle_features_complete+0x34>
 801a91e:	e002      	b.n	801a926 <l2cap_handle_features_complete+0x9e>
        return;
 801a920:	bf00      	nop
 801a922:	e000      	b.n	801a926 <l2cap_handle_features_complete+0x9e>
        return;
 801a924:	bf00      	nop
    }
}
 801a926:	3720      	adds	r7, #32
 801a928:	46bd      	mov	sp, r7
 801a92a:	bd80      	pop	{r7, pc}
 801a92c:	20009eac 	.word	0x20009eac
 801a930:	0802b1dc 	.word	0x0802b1dc
 801a934:	0802be1c 	.word	0x0802be1c

0801a938 <l2cap_handle_security_level>:
static void l2cap_handle_security_level(hci_con_handle_t handle, gap_security_level_t actual_level){
 801a938:	b580      	push	{r7, lr}
 801a93a:	b08e      	sub	sp, #56	; 0x38
 801a93c:	af06      	add	r7, sp, #24
 801a93e:	4603      	mov	r3, r0
 801a940:	460a      	mov	r2, r1
 801a942:	80fb      	strh	r3, [r7, #6]
 801a944:	4613      	mov	r3, r2
 801a946:	717b      	strb	r3, [r7, #5]
    log_info("l2cap - security level update for handle 0x%04x", handle);
 801a948:	88fb      	ldrh	r3, [r7, #6]
 801a94a:	9300      	str	r3, [sp, #0]
 801a94c:	f640 1321 	movw	r3, #2337	; 0x921
 801a950:	4a42      	ldr	r2, [pc, #264]	; (801aa5c <l2cap_handle_security_level+0x124>)
 801a952:	4943      	ldr	r1, [pc, #268]	; (801aa60 <l2cap_handle_security_level+0x128>)
 801a954:	2001      	movs	r0, #1
 801a956:	f7fc fd73 	bl	8017440 <hci_dump_log>
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801a95a:	f107 0308 	add.w	r3, r7, #8
 801a95e:	4941      	ldr	r1, [pc, #260]	; (801aa64 <l2cap_handle_security_level+0x12c>)
 801a960:	4618      	mov	r0, r3
 801a962:	f7f3 fef4 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 801a966:	e06d      	b.n	801aa44 <l2cap_handle_security_level+0x10c>
        l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801a968:	f107 0308 	add.w	r3, r7, #8
 801a96c:	4618      	mov	r0, r3
 801a96e:	f7f3 ff31 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801a972:	61f8      	str	r0, [r7, #28]
        if (!l2cap_is_dynamic_channel_type(channel->channel_type)) continue;
 801a974:	69fb      	ldr	r3, [r7, #28]
 801a976:	791b      	ldrb	r3, [r3, #4]
 801a978:	4618      	mov	r0, r3
 801a97a:	f7fe f9ac 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801a97e:	4603      	mov	r3, r0
 801a980:	2b00      	cmp	r3, #0
 801a982:	d100      	bne.n	801a986 <l2cap_handle_security_level+0x4e>
 801a984:	e05e      	b.n	801aa44 <l2cap_handle_security_level+0x10c>
        if (channel->con_handle != handle) continue;
 801a986:	69fb      	ldr	r3, [r7, #28]
 801a988:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801a98a:	88fa      	ldrh	r2, [r7, #6]
 801a98c:	429a      	cmp	r2, r3
 801a98e:	d000      	beq.n	801a992 <l2cap_handle_security_level+0x5a>
 801a990:	e058      	b.n	801aa44 <l2cap_handle_security_level+0x10c>

         gap_security_level_t required_level = channel->required_security_level;
 801a992:	69fb      	ldr	r3, [r7, #28]
 801a994:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 801a998:	76fb      	strb	r3, [r7, #27]

        log_info("channel %p, cid %04x - state %u: actual %u >= required %u?", channel, channel->local_cid, channel->state, actual_level, required_level);
 801a99a:	69fb      	ldr	r3, [r7, #28]
 801a99c:	88db      	ldrh	r3, [r3, #6]
 801a99e:	4619      	mov	r1, r3
 801a9a0:	69fb      	ldr	r3, [r7, #28]
 801a9a2:	f893 3020 	ldrb.w	r3, [r3, #32]
 801a9a6:	4618      	mov	r0, r3
 801a9a8:	797b      	ldrb	r3, [r7, #5]
 801a9aa:	7efa      	ldrb	r2, [r7, #27]
 801a9ac:	9204      	str	r2, [sp, #16]
 801a9ae:	9303      	str	r3, [sp, #12]
 801a9b0:	9002      	str	r0, [sp, #8]
 801a9b2:	9101      	str	r1, [sp, #4]
 801a9b4:	69fb      	ldr	r3, [r7, #28]
 801a9b6:	9300      	str	r3, [sp, #0]
 801a9b8:	f640 132b 	movw	r3, #2347	; 0x92b
 801a9bc:	4a27      	ldr	r2, [pc, #156]	; (801aa5c <l2cap_handle_security_level+0x124>)
 801a9be:	492a      	ldr	r1, [pc, #168]	; (801aa68 <l2cap_handle_security_level+0x130>)
 801a9c0:	2001      	movs	r0, #1
 801a9c2:	f7fc fd3d 	bl	8017440 <hci_dump_log>

        switch (channel->state){
 801a9c6:	69fb      	ldr	r3, [r7, #28]
 801a9c8:	f893 3020 	ldrb.w	r3, [r3, #32]
 801a9cc:	2b05      	cmp	r3, #5
 801a9ce:	d002      	beq.n	801a9d6 <l2cap_handle_security_level+0x9e>
 801a9d0:	2b06      	cmp	r3, #6
 801a9d2:	d029      	beq.n	801aa28 <l2cap_handle_security_level+0xf0>
 801a9d4:	e035      	b.n	801aa42 <l2cap_handle_security_level+0x10a>
            case L2CAP_STATE_WAIT_INCOMING_SECURITY_LEVEL_UPDATE:
                if (actual_level >= required_level){
 801a9d6:	797a      	ldrb	r2, [r7, #5]
 801a9d8:	7efb      	ldrb	r3, [r7, #27]
 801a9da:	429a      	cmp	r2, r3
 801a9dc:	d31b      	bcc.n	801aa16 <l2cap_handle_security_level+0xde>
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
                    // we need to know if ERTM is supported before sending a config response
                    hci_connection_t * connection = hci_connection_for_handle(channel->con_handle);
 801a9de:	69fb      	ldr	r3, [r7, #28]
 801a9e0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801a9e2:	4618      	mov	r0, r3
 801a9e4:	f7f4 ff6e 	bl	800f8c4 <hci_connection_for_handle>
 801a9e8:	6178      	str	r0, [r7, #20]
                    if (connection->l2cap_state.information_state != L2CAP_INFORMATION_STATE_DONE){
 801a9ea:	697b      	ldr	r3, [r7, #20]
 801a9ec:	f893 3e24 	ldrb.w	r3, [r3, #3620]	; 0xe24
 801a9f0:	2b03      	cmp	r3, #3
 801a9f2:	d008      	beq.n	801aa06 <l2cap_handle_security_level+0xce>
                        connection->l2cap_state.information_state = L2CAP_INFORMATION_STATE_W2_SEND_EXTENDED_FEATURE_REQUEST;
 801a9f4:	697b      	ldr	r3, [r7, #20]
 801a9f6:	2201      	movs	r2, #1
 801a9f8:	f883 2e24 	strb.w	r2, [r3, #3620]	; 0xe24
                        channel->state = L2CAP_STATE_WAIT_INCOMING_EXTENDED_FEATURES;
 801a9fc:	69fb      	ldr	r3, [r7, #28]
 801a9fe:	2207      	movs	r2, #7
 801aa00:	f883 2020 	strb.w	r2, [r3, #32]
                        break;
 801aa04:	e01e      	b.n	801aa44 <l2cap_handle_security_level+0x10c>
                    }
#endif
                    channel->state = L2CAP_STATE_WAIT_CLIENT_ACCEPT_OR_REJECT;
 801aa06:	69fb      	ldr	r3, [r7, #28]
 801aa08:	2209      	movs	r2, #9
 801aa0a:	f883 2020 	strb.w	r2, [r3, #32]
                    l2cap_emit_incoming_connection(channel);
 801aa0e:	69f8      	ldr	r0, [r7, #28]
 801aa10:	f7fe f85e 	bl	8018ad0 <l2cap_emit_incoming_connection>
 801aa14:	e016      	b.n	801aa44 <l2cap_handle_security_level+0x10c>
                } else {
                    channel->reason = 0x0003; // security block
 801aa16:	69fb      	ldr	r3, [r7, #28]
 801aa18:	2203      	movs	r2, #3
 801aa1a:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
                    channel->state = L2CAP_STATE_WILL_SEND_CONNECTION_RESPONSE_DECLINE;
 801aa1e:	69fb      	ldr	r3, [r7, #28]
 801aa20:	2210      	movs	r2, #16
 801aa22:	f883 2020 	strb.w	r2, [r3, #32]
                }
                break;
 801aa26:	e00d      	b.n	801aa44 <l2cap_handle_security_level+0x10c>

            case L2CAP_STATE_WAIT_OUTGOING_SECURITY_LEVEL_UPDATE:
                if (actual_level >= required_level){
 801aa28:	797a      	ldrb	r2, [r7, #5]
 801aa2a:	7efb      	ldrb	r3, [r7, #27]
 801aa2c:	429a      	cmp	r2, r3
 801aa2e:	d303      	bcc.n	801aa38 <l2cap_handle_security_level+0x100>
                    l2cap_ready_to_connect(channel);
 801aa30:	69f8      	ldr	r0, [r7, #28]
 801aa32:	f7ff fbb9 	bl	801a1a8 <l2cap_ready_to_connect>
 801aa36:	e005      	b.n	801aa44 <l2cap_handle_security_level+0x10c>
                } else {
                    // disconnnect, authentication not good enough
                    hci_disconnect_security_block(handle);
 801aa38:	88fb      	ldrh	r3, [r7, #6]
 801aa3a:	4618      	mov	r0, r3
 801aa3c:	f7fb fa72 	bl	8015f24 <hci_disconnect_security_block>
                }
                break;
 801aa40:	e000      	b.n	801aa44 <l2cap_handle_security_level+0x10c>

            default:
                break;
 801aa42:	bf00      	nop
    while (btstack_linked_list_iterator_has_next(&it)){
 801aa44:	f107 0308 	add.w	r3, r7, #8
 801aa48:	4618      	mov	r0, r3
 801aa4a:	f7f3 fe95 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801aa4e:	4603      	mov	r3, r0
 801aa50:	2b00      	cmp	r3, #0
 801aa52:	d189      	bne.n	801a968 <l2cap_handle_security_level+0x30>
        }
    }
}
 801aa54:	bf00      	nop
 801aa56:	3720      	adds	r7, #32
 801aa58:	46bd      	mov	sp, r7
 801aa5a:	bd80      	pop	{r7, pc}
 801aa5c:	0802b1dc 	.word	0x0802b1dc
 801aa60:	0802be60 	.word	0x0802be60
 801aa64:	20009eac 	.word	0x20009eac
 801aa68:	0802be98 	.word	0x0802be98

0801aa6c <l2cap_handle_disconnection_complete>:
#endif

#ifdef L2CAP_USES_CHANNELS
static void l2cap_handle_disconnection_complete(hci_con_handle_t handle){
 801aa6c:	b580      	push	{r7, lr}
 801aa6e:	b088      	sub	sp, #32
 801aa70:	af00      	add	r7, sp, #0
 801aa72:	4603      	mov	r3, r0
 801aa74:	80fb      	strh	r3, [r7, #6]
    // collect channels to close
    btstack_linked_list_t channels_to_close = NULL;
 801aa76:	2300      	movs	r3, #0
 801aa78:	617b      	str	r3, [r7, #20]
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801aa7a:	f107 0308 	add.w	r3, r7, #8
 801aa7e:	492e      	ldr	r1, [pc, #184]	; (801ab38 <l2cap_handle_disconnection_complete+0xcc>)
 801aa80:	4618      	mov	r0, r3
 801aa82:	f7f3 fe64 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)) {
 801aa86:	e01f      	b.n	801aac8 <l2cap_handle_disconnection_complete+0x5c>
        l2cap_channel_t *channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801aa88:	f107 0308 	add.w	r3, r7, #8
 801aa8c:	4618      	mov	r0, r3
 801aa8e:	f7f3 fea1 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801aa92:	61b8      	str	r0, [r7, #24]
        if (!l2cap_is_dynamic_channel_type(channel->channel_type)) continue;
 801aa94:	69bb      	ldr	r3, [r7, #24]
 801aa96:	791b      	ldrb	r3, [r3, #4]
 801aa98:	4618      	mov	r0, r3
 801aa9a:	f7fe f91c 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801aa9e:	4603      	mov	r3, r0
 801aaa0:	2b00      	cmp	r3, #0
 801aaa2:	d100      	bne.n	801aaa6 <l2cap_handle_disconnection_complete+0x3a>
 801aaa4:	e010      	b.n	801aac8 <l2cap_handle_disconnection_complete+0x5c>
        if (channel->con_handle != handle) continue;
 801aaa6:	69bb      	ldr	r3, [r7, #24]
 801aaa8:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801aaaa:	88fa      	ldrh	r2, [r7, #6]
 801aaac:	429a      	cmp	r2, r3
 801aaae:	d000      	beq.n	801aab2 <l2cap_handle_disconnection_complete+0x46>
 801aab0:	e00a      	b.n	801aac8 <l2cap_handle_disconnection_complete+0x5c>
        btstack_linked_list_iterator_remove(&it);
 801aab2:	f107 0308 	add.w	r3, r7, #8
 801aab6:	4618      	mov	r0, r3
 801aab8:	f7f3 feb6 	bl	800e828 <btstack_linked_list_iterator_remove>
        btstack_linked_list_add(&channels_to_close, (btstack_linked_item_t *) channel);
 801aabc:	f107 0314 	add.w	r3, r7, #20
 801aac0:	69b9      	ldr	r1, [r7, #24]
 801aac2:	4618      	mov	r0, r3
 801aac4:	f7f3 fdb5 	bl	800e632 <btstack_linked_list_add>
    while (btstack_linked_list_iterator_has_next(&it)) {
 801aac8:	f107 0308 	add.w	r3, r7, #8
 801aacc:	4618      	mov	r0, r3
 801aace:	f7f3 fe53 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801aad2:	4603      	mov	r3, r0
 801aad4:	2b00      	cmp	r3, #0
 801aad6:	d1d7      	bne.n	801aa88 <l2cap_handle_disconnection_complete+0x1c>
    }
    // send l2cap open failed or closed events for all channels on this handle and free them
    btstack_linked_list_iterator_init(&it, &channels_to_close);
 801aad8:	f107 0214 	add.w	r2, r7, #20
 801aadc:	f107 0308 	add.w	r3, r7, #8
 801aae0:	4611      	mov	r1, r2
 801aae2:	4618      	mov	r0, r3
 801aae4:	f7f3 fe33 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)) {
 801aae8:	e01a      	b.n	801ab20 <l2cap_handle_disconnection_complete+0xb4>
        l2cap_channel_t *channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801aaea:	f107 0308 	add.w	r3, r7, #8
 801aaee:	4618      	mov	r0, r3
 801aaf0:	f7f3 fe70 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801aaf4:	61f8      	str	r0, [r7, #28]
        btstack_linked_list_iterator_remove(&it);
 801aaf6:	f107 0308 	add.w	r3, r7, #8
 801aafa:	4618      	mov	r0, r3
 801aafc:	f7f3 fe94 	bl	800e828 <btstack_linked_list_iterator_remove>
        switch(channel->channel_type){
 801ab00:	69fb      	ldr	r3, [r7, #28]
 801ab02:	791b      	ldrb	r3, [r3, #4]
 801ab04:	2b00      	cmp	r3, #0
 801ab06:	d002      	beq.n	801ab0e <l2cap_handle_disconnection_complete+0xa2>
 801ab08:	2b02      	cmp	r3, #2
 801ab0a:	d004      	beq.n	801ab16 <l2cap_handle_disconnection_complete+0xaa>
 801ab0c:	e007      	b.n	801ab1e <l2cap_handle_disconnection_complete+0xb2>
#ifdef ENABLE_CLASSIC
            case L2CAP_CHANNEL_TYPE_CLASSIC:
                l2cap_handle_hci_disconnect_event(channel);
 801ab0e:	69f8      	ldr	r0, [r7, #28]
 801ab10:	f7ff fe2e 	bl	801a770 <l2cap_handle_hci_disconnect_event>
                break;
 801ab14:	e004      	b.n	801ab20 <l2cap_handle_disconnection_complete+0xb4>
#endif
#ifdef ENABLE_LE_DATA_CHANNELS
            case L2CAP_CHANNEL_TYPE_LE_DATA_CHANNEL:
                l2cap_handle_hci_le_disconnect_event(channel);
 801ab16:	69f8      	ldr	r0, [r7, #28]
 801ab18:	f7ff fe43 	bl	801a7a2 <l2cap_handle_hci_le_disconnect_event>
                break;
 801ab1c:	e000      	b.n	801ab20 <l2cap_handle_disconnection_complete+0xb4>
#endif
            default:
                break;
 801ab1e:	bf00      	nop
    while (btstack_linked_list_iterator_has_next(&it)) {
 801ab20:	f107 0308 	add.w	r3, r7, #8
 801ab24:	4618      	mov	r0, r3
 801ab26:	f7f3 fe27 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801ab2a:	4603      	mov	r3, r0
 801ab2c:	2b00      	cmp	r3, #0
 801ab2e:	d1dc      	bne.n	801aaea <l2cap_handle_disconnection_complete+0x7e>
        }
    }
}
 801ab30:	bf00      	nop
 801ab32:	3720      	adds	r7, #32
 801ab34:	46bd      	mov	sp, r7
 801ab36:	bd80      	pop	{r7, pc}
 801ab38:	20009eac 	.word	0x20009eac

0801ab3c <l2cap_hci_event_handler>:
#endif

static void l2cap_hci_event_handler(uint8_t packet_type, uint16_t cid, uint8_t *packet, uint16_t size){
 801ab3c:	b580      	push	{r7, lr}
 801ab3e:	b088      	sub	sp, #32
 801ab40:	af00      	add	r7, sp, #0
 801ab42:	60ba      	str	r2, [r7, #8]
 801ab44:	461a      	mov	r2, r3
 801ab46:	4603      	mov	r3, r0
 801ab48:	73fb      	strb	r3, [r7, #15]
 801ab4a:	460b      	mov	r3, r1
 801ab4c:	81bb      	strh	r3, [r7, #12]
 801ab4e:	4613      	mov	r3, r2
 801ab50:	80fb      	strh	r3, [r7, #6]
#endif
#ifdef L2CAP_USES_CHANNELS
    hci_con_handle_t handle;
#endif

    switch(hci_event_packet_get_type(packet)){
 801ab52:	68b8      	ldr	r0, [r7, #8]
 801ab54:	f7fc ff3c 	bl	80179d0 <hci_event_packet_get_type>
 801ab58:	4603      	mov	r3, r0
 801ab5a:	2b13      	cmp	r3, #19
 801ab5c:	d022      	beq.n	801aba4 <l2cap_hci_event_handler+0x68>
 801ab5e:	2b13      	cmp	r3, #19
 801ab60:	dc0f      	bgt.n	801ab82 <l2cap_hci_event_handler+0x46>
 801ab62:	2b0b      	cmp	r3, #11
 801ab64:	f000 80af 	beq.w	801acc6 <l2cap_hci_event_handler+0x18a>
 801ab68:	2b0b      	cmp	r3, #11
 801ab6a:	dc05      	bgt.n	801ab78 <l2cap_hci_event_handler+0x3c>
 801ab6c:	2b03      	cmp	r3, #3
 801ab6e:	d04b      	beq.n	801ac08 <l2cap_hci_event_handler+0xcc>
 801ab70:	2b05      	cmp	r3, #5
 801ab72:	f000 8092 	beq.w	801ac9a <l2cap_hci_event_handler+0x15e>
            security_level = (gap_security_level_t) packet[4];
            l2cap_handle_security_level(handle, security_level);
            break;
#endif
        default:
            break;
 801ab76:	e0c2      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
    switch(hci_event_packet_get_type(packet)){
 801ab78:	2b0e      	cmp	r3, #14
 801ab7a:	d06a      	beq.n	801ac52 <l2cap_hci_event_handler+0x116>
 801ab7c:	2b0f      	cmp	r3, #15
 801ab7e:	d016      	beq.n	801abae <l2cap_hci_event_handler+0x72>
            break;
 801ab80:	e0bd      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
    switch(hci_event_packet_get_type(packet)){
 801ab82:	2b6e      	cmp	r3, #110	; 0x6e
 801ab84:	d00e      	beq.n	801aba4 <l2cap_hci_event_handler+0x68>
 801ab86:	2b6e      	cmp	r3, #110	; 0x6e
 801ab88:	dc05      	bgt.n	801ab96 <l2cap_hci_event_handler+0x5a>
 801ab8a:	2b23      	cmp	r3, #35	; 0x23
 801ab8c:	f000 809b 	beq.w	801acc6 <l2cap_hci_event_handler+0x18a>
 801ab90:	2b61      	cmp	r3, #97	; 0x61
 801ab92:	d007      	beq.n	801aba4 <l2cap_hci_event_handler+0x68>
            break;
 801ab94:	e0b3      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
    switch(hci_event_packet_get_type(packet)){
 801ab96:	2b73      	cmp	r3, #115	; 0x73
 801ab98:	f000 808a 	beq.w	801acb0 <l2cap_hci_event_handler+0x174>
 801ab9c:	2be0      	cmp	r3, #224	; 0xe0
 801ab9e:	f000 809d 	beq.w	801acdc <l2cap_hci_event_handler+0x1a0>
            break;
 801aba2:	e0ac      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
            l2cap_run();    // try sending signaling packets first
 801aba4:	f7ff fa28 	bl	8019ff8 <l2cap_run>
            l2cap_notify_channel_can_send();
 801aba8:	f7ff fd50 	bl	801a64c <l2cap_notify_channel_can_send>
            break;
 801abac:	e0a7      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
            if (HCI_EVENT_IS_COMMAND_STATUS(packet, hci_create_connection)){
 801abae:	68bb      	ldr	r3, [r7, #8]
 801abb0:	781b      	ldrb	r3, [r3, #0]
 801abb2:	2b0f      	cmp	r3, #15
 801abb4:	d125      	bne.n	801ac02 <l2cap_hci_event_handler+0xc6>
 801abb6:	2104      	movs	r1, #4
 801abb8:	68b8      	ldr	r0, [r7, #8]
 801abba:	f7f4 f914 	bl	800ede6 <little_endian_read_16>
 801abbe:	4603      	mov	r3, r0
 801abc0:	461a      	mov	r2, r3
 801abc2:	4b52      	ldr	r3, [pc, #328]	; (801ad0c <l2cap_hci_event_handler+0x1d0>)
 801abc4:	881b      	ldrh	r3, [r3, #0]
 801abc6:	429a      	cmp	r2, r3
 801abc8:	d11b      	bne.n	801ac02 <l2cap_hci_event_handler+0xc6>
                (void)memcpy(address, l2cap_outgoing_classic_addr, 6);
 801abca:	4a51      	ldr	r2, [pc, #324]	; (801ad10 <l2cap_hci_event_handler+0x1d4>)
 801abcc:	f107 0314 	add.w	r3, r7, #20
 801abd0:	e892 0003 	ldmia.w	r2, {r0, r1}
 801abd4:	6018      	str	r0, [r3, #0]
 801abd6:	3304      	adds	r3, #4
 801abd8:	8019      	strh	r1, [r3, #0]
                memset(l2cap_outgoing_classic_addr, 0, 6);
 801abda:	2206      	movs	r2, #6
 801abdc:	2100      	movs	r1, #0
 801abde:	484c      	ldr	r0, [pc, #304]	; (801ad10 <l2cap_hci_event_handler+0x1d4>)
 801abe0:	f00c ff6f 	bl	8027ac2 <memset>
                uint8_t status = hci_event_command_status_get_status(packet);
 801abe4:	68b8      	ldr	r0, [r7, #8]
 801abe6:	f7fc feff 	bl	80179e8 <hci_event_command_status_get_status>
 801abea:	4603      	mov	r3, r0
 801abec:	773b      	strb	r3, [r7, #28]
                if (status){
 801abee:	7f3b      	ldrb	r3, [r7, #28]
 801abf0:	2b00      	cmp	r3, #0
 801abf2:	d006      	beq.n	801ac02 <l2cap_hci_event_handler+0xc6>
                    l2cap_handle_connection_failed_for_addr(address, status);
 801abf4:	7f3a      	ldrb	r2, [r7, #28]
 801abf6:	f107 0314 	add.w	r3, r7, #20
 801abfa:	4611      	mov	r1, r2
 801abfc:	4618      	mov	r0, r3
 801abfe:	f7ff fb9b 	bl	801a338 <l2cap_handle_connection_failed_for_addr>
            l2cap_run();    // try sending signaling packets first
 801ac02:	f7ff f9f9 	bl	8019ff8 <l2cap_run>
            break;
 801ac06:	e07a      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
            reverse_bd_addr(&packet[5], address);
 801ac08:	68bb      	ldr	r3, [r7, #8]
 801ac0a:	3305      	adds	r3, #5
 801ac0c:	f107 0214 	add.w	r2, r7, #20
 801ac10:	4611      	mov	r1, r2
 801ac12:	4618      	mov	r0, r3
 801ac14:	f7f4 fa6d 	bl	800f0f2 <reverse_bd_addr>
            if (packet[2] == 0){
 801ac18:	68bb      	ldr	r3, [r7, #8]
 801ac1a:	3302      	adds	r3, #2
 801ac1c:	781b      	ldrb	r3, [r3, #0]
 801ac1e:	2b00      	cmp	r3, #0
 801ac20:	d10d      	bne.n	801ac3e <l2cap_hci_event_handler+0x102>
                handle = little_endian_read_16(packet, 3);
 801ac22:	2103      	movs	r1, #3
 801ac24:	68b8      	ldr	r0, [r7, #8]
 801ac26:	f7f4 f8de 	bl	800ede6 <little_endian_read_16>
 801ac2a:	4603      	mov	r3, r0
 801ac2c:	83fb      	strh	r3, [r7, #30]
                l2cap_handle_connection_success_for_addr(address, handle);
 801ac2e:	8bfa      	ldrh	r2, [r7, #30]
 801ac30:	f107 0314 	add.w	r3, r7, #20
 801ac34:	4611      	mov	r1, r2
 801ac36:	4618      	mov	r0, r3
 801ac38:	f7ff fbf8 	bl	801a42c <l2cap_handle_connection_success_for_addr>
            break;
 801ac3c:	e05f      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
                l2cap_handle_connection_failed_for_addr(address, packet[2]);
 801ac3e:	68bb      	ldr	r3, [r7, #8]
 801ac40:	3302      	adds	r3, #2
 801ac42:	781a      	ldrb	r2, [r3, #0]
 801ac44:	f107 0314 	add.w	r3, r7, #20
 801ac48:	4611      	mov	r1, r2
 801ac4a:	4618      	mov	r0, r3
 801ac4c:	f7ff fb74 	bl	801a338 <l2cap_handle_connection_failed_for_addr>
            break;
 801ac50:	e055      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
            if (HCI_EVENT_IS_COMMAND_COMPLETE(packet, hci_create_connection_cancel)) {
 801ac52:	68bb      	ldr	r3, [r7, #8]
 801ac54:	781b      	ldrb	r3, [r3, #0]
 801ac56:	2b0e      	cmp	r3, #14
 801ac58:	d11c      	bne.n	801ac94 <l2cap_hci_event_handler+0x158>
 801ac5a:	2103      	movs	r1, #3
 801ac5c:	68b8      	ldr	r0, [r7, #8]
 801ac5e:	f7f4 f8c2 	bl	800ede6 <little_endian_read_16>
 801ac62:	4603      	mov	r3, r0
 801ac64:	461a      	mov	r2, r3
 801ac66:	4b2b      	ldr	r3, [pc, #172]	; (801ad14 <l2cap_hci_event_handler+0x1d8>)
 801ac68:	881b      	ldrh	r3, [r3, #0]
 801ac6a:	429a      	cmp	r2, r3
 801ac6c:	d112      	bne.n	801ac94 <l2cap_hci_event_handler+0x158>
                if (packet[5] == 0){
 801ac6e:	68bb      	ldr	r3, [r7, #8]
 801ac70:	3305      	adds	r3, #5
 801ac72:	781b      	ldrb	r3, [r3, #0]
 801ac74:	2b00      	cmp	r3, #0
 801ac76:	d10d      	bne.n	801ac94 <l2cap_hci_event_handler+0x158>
                    reverse_bd_addr(&packet[6], address);
 801ac78:	68bb      	ldr	r3, [r7, #8]
 801ac7a:	3306      	adds	r3, #6
 801ac7c:	f107 0214 	add.w	r2, r7, #20
 801ac80:	4611      	mov	r1, r2
 801ac82:	4618      	mov	r0, r3
 801ac84:	f7f4 fa35 	bl	800f0f2 <reverse_bd_addr>
                    l2cap_handle_connection_failed_for_addr(address, 0x16);
 801ac88:	f107 0314 	add.w	r3, r7, #20
 801ac8c:	2116      	movs	r1, #22
 801ac8e:	4618      	mov	r0, r3
 801ac90:	f7ff fb52 	bl	801a338 <l2cap_handle_connection_failed_for_addr>
            l2cap_run();    // try sending signaling packets first
 801ac94:	f7ff f9b0 	bl	8019ff8 <l2cap_run>
            break;
 801ac98:	e031      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
            handle = little_endian_read_16(packet, 3);
 801ac9a:	2103      	movs	r1, #3
 801ac9c:	68b8      	ldr	r0, [r7, #8]
 801ac9e:	f7f4 f8a2 	bl	800ede6 <little_endian_read_16>
 801aca2:	4603      	mov	r3, r0
 801aca4:	83fb      	strh	r3, [r7, #30]
            l2cap_handle_disconnection_complete(handle);
 801aca6:	8bfb      	ldrh	r3, [r7, #30]
 801aca8:	4618      	mov	r0, r3
 801acaa:	f7ff fedf 	bl	801aa6c <l2cap_handle_disconnection_complete>
            break;
 801acae:	e026      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
            handle = little_endian_read_16(packet, 2);
 801acb0:	2102      	movs	r1, #2
 801acb2:	68b8      	ldr	r0, [r7, #8]
 801acb4:	f7f4 f897 	bl	800ede6 <little_endian_read_16>
 801acb8:	4603      	mov	r3, r0
 801acba:	83fb      	strh	r3, [r7, #30]
            l2cap_check_classic_timeout(handle);
 801acbc:	8bfb      	ldrh	r3, [r7, #30]
 801acbe:	4618      	mov	r0, r3
 801acc0:	f7ff fd88 	bl	801a7d4 <l2cap_check_classic_timeout>
            break;
 801acc4:	e01b      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
            handle = little_endian_read_16(packet, 3);
 801acc6:	2103      	movs	r1, #3
 801acc8:	68b8      	ldr	r0, [r7, #8]
 801acca:	f7f4 f88c 	bl	800ede6 <little_endian_read_16>
 801acce:	4603      	mov	r3, r0
 801acd0:	83fb      	strh	r3, [r7, #30]
            l2cap_handle_features_complete(handle);
 801acd2:	8bfb      	ldrh	r3, [r7, #30]
 801acd4:	4618      	mov	r0, r3
 801acd6:	f7ff fdd7 	bl	801a888 <l2cap_handle_features_complete>
            break;
 801acda:	e010      	b.n	801acfe <l2cap_hci_event_handler+0x1c2>
            handle = little_endian_read_16(packet, 2);
 801acdc:	2102      	movs	r1, #2
 801acde:	68b8      	ldr	r0, [r7, #8]
 801ace0:	f7f4 f881 	bl	800ede6 <little_endian_read_16>
 801ace4:	4603      	mov	r3, r0
 801ace6:	83fb      	strh	r3, [r7, #30]
            security_level = (gap_security_level_t) packet[4];
 801ace8:	68bb      	ldr	r3, [r7, #8]
 801acea:	3304      	adds	r3, #4
 801acec:	781b      	ldrb	r3, [r3, #0]
 801acee:	777b      	strb	r3, [r7, #29]
            l2cap_handle_security_level(handle, security_level);
 801acf0:	7f7a      	ldrb	r2, [r7, #29]
 801acf2:	8bfb      	ldrh	r3, [r7, #30]
 801acf4:	4611      	mov	r1, r2
 801acf6:	4618      	mov	r0, r3
 801acf8:	f7ff fe1e 	bl	801a938 <l2cap_handle_security_level>
            break;
 801acfc:	bf00      	nop
    }
    
    l2cap_run();
 801acfe:	f7ff f97b 	bl	8019ff8 <l2cap_run>
}
 801ad02:	bf00      	nop
 801ad04:	3720      	adds	r7, #32
 801ad06:	46bd      	mov	sp, r7
 801ad08:	bd80      	pop	{r7, pc}
 801ad0a:	bf00      	nop
 801ad0c:	08030a08 	.word	0x08030a08
 801ad10:	20009ea0 	.word	0x20009ea0
 801ad14:	08030a18 	.word	0x08030a18

0801ad18 <l2cap_register_signaling_response>:

static void l2cap_register_signaling_response(hci_con_handle_t handle, uint8_t code, uint8_t sig_id, uint16_t cid, uint16_t data){
 801ad18:	b590      	push	{r4, r7, lr}
 801ad1a:	b083      	sub	sp, #12
 801ad1c:	af00      	add	r7, sp, #0
 801ad1e:	4604      	mov	r4, r0
 801ad20:	4608      	mov	r0, r1
 801ad22:	4611      	mov	r1, r2
 801ad24:	461a      	mov	r2, r3
 801ad26:	4623      	mov	r3, r4
 801ad28:	80fb      	strh	r3, [r7, #6]
 801ad2a:	4603      	mov	r3, r0
 801ad2c:	717b      	strb	r3, [r7, #5]
 801ad2e:	460b      	mov	r3, r1
 801ad30:	713b      	strb	r3, [r7, #4]
 801ad32:	4613      	mov	r3, r2
 801ad34:	807b      	strh	r3, [r7, #2]
    // Vol 3, Part A, 4.3: "The DCID and SCID fields shall be ignored when the result field indi- cates the connection was refused."
    if (signaling_responses_pending < NR_PENDING_SIGNALING_RESPONSES) {
 801ad36:	4b18      	ldr	r3, [pc, #96]	; (801ad98 <l2cap_register_signaling_response+0x80>)
 801ad38:	681b      	ldr	r3, [r3, #0]
 801ad3a:	2b02      	cmp	r3, #2
 801ad3c:	dc28      	bgt.n	801ad90 <l2cap_register_signaling_response+0x78>
        signaling_responses[signaling_responses_pending].handle = handle;
 801ad3e:	4b16      	ldr	r3, [pc, #88]	; (801ad98 <l2cap_register_signaling_response+0x80>)
 801ad40:	681b      	ldr	r3, [r3, #0]
 801ad42:	4916      	ldr	r1, [pc, #88]	; (801ad9c <l2cap_register_signaling_response+0x84>)
 801ad44:	88fa      	ldrh	r2, [r7, #6]
 801ad46:	f821 2033 	strh.w	r2, [r1, r3, lsl #3]
        signaling_responses[signaling_responses_pending].code = code;
 801ad4a:	4b13      	ldr	r3, [pc, #76]	; (801ad98 <l2cap_register_signaling_response+0x80>)
 801ad4c:	681b      	ldr	r3, [r3, #0]
 801ad4e:	4a13      	ldr	r2, [pc, #76]	; (801ad9c <l2cap_register_signaling_response+0x84>)
 801ad50:	00db      	lsls	r3, r3, #3
 801ad52:	4413      	add	r3, r2
 801ad54:	797a      	ldrb	r2, [r7, #5]
 801ad56:	70da      	strb	r2, [r3, #3]
        signaling_responses[signaling_responses_pending].sig_id = sig_id;
 801ad58:	4b0f      	ldr	r3, [pc, #60]	; (801ad98 <l2cap_register_signaling_response+0x80>)
 801ad5a:	681b      	ldr	r3, [r3, #0]
 801ad5c:	4a0f      	ldr	r2, [pc, #60]	; (801ad9c <l2cap_register_signaling_response+0x84>)
 801ad5e:	00db      	lsls	r3, r3, #3
 801ad60:	4413      	add	r3, r2
 801ad62:	793a      	ldrb	r2, [r7, #4]
 801ad64:	709a      	strb	r2, [r3, #2]
        signaling_responses[signaling_responses_pending].cid = cid;
 801ad66:	4b0c      	ldr	r3, [pc, #48]	; (801ad98 <l2cap_register_signaling_response+0x80>)
 801ad68:	681b      	ldr	r3, [r3, #0]
 801ad6a:	4a0c      	ldr	r2, [pc, #48]	; (801ad9c <l2cap_register_signaling_response+0x84>)
 801ad6c:	00db      	lsls	r3, r3, #3
 801ad6e:	4413      	add	r3, r2
 801ad70:	887a      	ldrh	r2, [r7, #2]
 801ad72:	809a      	strh	r2, [r3, #4]
        signaling_responses[signaling_responses_pending].data = data;
 801ad74:	4b08      	ldr	r3, [pc, #32]	; (801ad98 <l2cap_register_signaling_response+0x80>)
 801ad76:	681b      	ldr	r3, [r3, #0]
 801ad78:	4a08      	ldr	r2, [pc, #32]	; (801ad9c <l2cap_register_signaling_response+0x84>)
 801ad7a:	00db      	lsls	r3, r3, #3
 801ad7c:	4413      	add	r3, r2
 801ad7e:	8b3a      	ldrh	r2, [r7, #24]
 801ad80:	80da      	strh	r2, [r3, #6]
        signaling_responses_pending++;
 801ad82:	4b05      	ldr	r3, [pc, #20]	; (801ad98 <l2cap_register_signaling_response+0x80>)
 801ad84:	681b      	ldr	r3, [r3, #0]
 801ad86:	3301      	adds	r3, #1
 801ad88:	4a03      	ldr	r2, [pc, #12]	; (801ad98 <l2cap_register_signaling_response+0x80>)
 801ad8a:	6013      	str	r3, [r2, #0]
        l2cap_run();
 801ad8c:	f7ff f934 	bl	8019ff8 <l2cap_run>
    }
}
 801ad90:	bf00      	nop
 801ad92:	370c      	adds	r7, #12
 801ad94:	46bd      	mov	sp, r7
 801ad96:	bd90      	pop	{r4, r7, pc}
 801ad98:	20009ecc 	.word	0x20009ecc
 801ad9c:	20009eb4 	.word	0x20009eb4

0801ada0 <l2cap_handle_disconnect_request>:

#ifdef ENABLE_CLASSIC
static void l2cap_handle_disconnect_request(l2cap_channel_t *channel, uint16_t identifier){
 801ada0:	b580      	push	{r7, lr}
 801ada2:	b082      	sub	sp, #8
 801ada4:	af00      	add	r7, sp, #0
 801ada6:	6078      	str	r0, [r7, #4]
 801ada8:	460b      	mov	r3, r1
 801adaa:	807b      	strh	r3, [r7, #2]
    switch (channel->state){
 801adac:	687b      	ldr	r3, [r7, #4]
 801adae:	f893 3020 	ldrb.w	r3, [r3, #32]
 801adb2:	2b0b      	cmp	r3, #11
 801adb4:	db11      	blt.n	801adda <l2cap_handle_disconnect_request+0x3a>
 801adb6:	2b0d      	cmp	r3, #13
 801adb8:	dd02      	ble.n	801adc0 <l2cap_handle_disconnect_request+0x20>
 801adba:	2b12      	cmp	r3, #18
 801adbc:	d000      	beq.n	801adc0 <l2cap_handle_disconnect_request+0x20>
        case L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST:
        case L2CAP_STATE_WAIT_DISCONNECT:
            break;
        default:
            // ignore in other states
            return;
 801adbe:	e00c      	b.n	801adda <l2cap_handle_disconnect_request+0x3a>
            break;
 801adc0:	bf00      	nop
    }

    channel->remote_sig_id = identifier;
 801adc2:	887b      	ldrh	r3, [r7, #2]
 801adc4:	b2da      	uxtb	r2, r3
 801adc6:	687b      	ldr	r3, [r7, #4]
 801adc8:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_RESPONSE;
 801adcc:	687b      	ldr	r3, [r7, #4]
 801adce:	2213      	movs	r2, #19
 801add0:	f883 2020 	strb.w	r2, [r3, #32]
    l2cap_run();
 801add4:	f7ff f910 	bl	8019ff8 <l2cap_run>
 801add8:	e000      	b.n	801addc <l2cap_handle_disconnect_request+0x3c>
            return;
 801adda:	bf00      	nop
}
 801addc:	3708      	adds	r7, #8
 801adde:	46bd      	mov	sp, r7
 801ade0:	bd80      	pop	{r7, pc}
	...

0801ade4 <l2cap_handle_connection_request>:

static void l2cap_handle_connection_request(hci_con_handle_t handle, uint8_t sig_id, uint16_t psm, uint16_t source_cid){
 801ade4:	b590      	push	{r4, r7, lr}
 801ade6:	b08b      	sub	sp, #44	; 0x2c
 801ade8:	af04      	add	r7, sp, #16
 801adea:	4604      	mov	r4, r0
 801adec:	4608      	mov	r0, r1
 801adee:	4611      	mov	r1, r2
 801adf0:	461a      	mov	r2, r3
 801adf2:	4623      	mov	r3, r4
 801adf4:	80fb      	strh	r3, [r7, #6]
 801adf6:	4603      	mov	r3, r0
 801adf8:	717b      	strb	r3, [r7, #5]
 801adfa:	460b      	mov	r3, r1
 801adfc:	807b      	strh	r3, [r7, #2]
 801adfe:	4613      	mov	r3, r2
 801ae00:	803b      	strh	r3, [r7, #0]
    
    // log_info("l2cap_handle_connection_request for handle %u, psm %u cid 0x%02x", handle, psm, source_cid);
    l2cap_service_t *service = l2cap_get_service(psm);
 801ae02:	887b      	ldrh	r3, [r7, #2]
 801ae04:	4618      	mov	r0, r3
 801ae06:	f001 fe9b 	bl	801cb40 <l2cap_get_service>
 801ae0a:	6178      	str	r0, [r7, #20]
    if (!service) {
 801ae0c:	697b      	ldr	r3, [r7, #20]
 801ae0e:	2b00      	cmp	r3, #0
 801ae10:	d109      	bne.n	801ae26 <l2cap_handle_connection_request+0x42>
        // 0x0002 PSM not supported
        l2cap_register_signaling_response(handle, CONNECTION_REQUEST, sig_id, source_cid, 0x0002);
 801ae12:	8839      	ldrh	r1, [r7, #0]
 801ae14:	797a      	ldrb	r2, [r7, #5]
 801ae16:	88f8      	ldrh	r0, [r7, #6]
 801ae18:	2302      	movs	r3, #2
 801ae1a:	9300      	str	r3, [sp, #0]
 801ae1c:	460b      	mov	r3, r1
 801ae1e:	2102      	movs	r1, #2
 801ae20:	f7ff ff7a 	bl	801ad18 <l2cap_register_signaling_response>
        return;
 801ae24:	e05b      	b.n	801aede <l2cap_handle_connection_request+0xfa>
    }
    
    hci_connection_t * hci_connection = hci_connection_for_handle( handle );
 801ae26:	88fb      	ldrh	r3, [r7, #6]
 801ae28:	4618      	mov	r0, r3
 801ae2a:	f7f4 fd4b 	bl	800f8c4 <hci_connection_for_handle>
 801ae2e:	6138      	str	r0, [r7, #16]
    if (!hci_connection) {
 801ae30:	693b      	ldr	r3, [r7, #16]
 801ae32:	2b00      	cmp	r3, #0
 801ae34:	d109      	bne.n	801ae4a <l2cap_handle_connection_request+0x66>
        // 
        log_error("no hci_connection for handle %u", handle);
 801ae36:	88fb      	ldrh	r3, [r7, #6]
 801ae38:	9300      	str	r3, [sp, #0]
 801ae3a:	f640 2305 	movw	r3, #2565	; 0xa05
 801ae3e:	4a29      	ldr	r2, [pc, #164]	; (801aee4 <l2cap_handle_connection_request+0x100>)
 801ae40:	4929      	ldr	r1, [pc, #164]	; (801aee8 <l2cap_handle_connection_request+0x104>)
 801ae42:	2002      	movs	r0, #2
 801ae44:	f7fc fafc 	bl	8017440 <hci_dump_log>
        return;
 801ae48:	e049      	b.n	801aede <l2cap_handle_connection_request+0xfa>
    }

    // alloc structure
    // log_info("l2cap_handle_connection_request register channel");
    l2cap_channel_t * channel = l2cap_create_channel_entry(service->packet_handler, L2CAP_CHANNEL_TYPE_CLASSIC, hci_connection->address, BD_ADDR_TYPE_ACL, 
 801ae4a:	697b      	ldr	r3, [r7, #20]
 801ae4c:	6898      	ldr	r0, [r3, #8]
 801ae4e:	693b      	ldr	r3, [r7, #16]
 801ae50:	1d19      	adds	r1, r3, #4
 801ae52:	697b      	ldr	r3, [r7, #20]
 801ae54:	88db      	ldrh	r3, [r3, #6]
 801ae56:	697a      	ldr	r2, [r7, #20]
 801ae58:	7b12      	ldrb	r2, [r2, #12]
 801ae5a:	9202      	str	r2, [sp, #8]
 801ae5c:	9301      	str	r3, [sp, #4]
 801ae5e:	887b      	ldrh	r3, [r7, #2]
 801ae60:	9300      	str	r3, [sp, #0]
 801ae62:	23fd      	movs	r3, #253	; 0xfd
 801ae64:	460a      	mov	r2, r1
 801ae66:	2100      	movs	r1, #0
 801ae68:	f7ff f9e2 	bl	801a230 <l2cap_create_channel_entry>
 801ae6c:	60f8      	str	r0, [r7, #12]
    psm, service->mtu, service->required_security_level);
    if (!channel){
 801ae6e:	68fb      	ldr	r3, [r7, #12]
 801ae70:	2b00      	cmp	r3, #0
 801ae72:	d109      	bne.n	801ae88 <l2cap_handle_connection_request+0xa4>
        // 0x0004 No resources available
        l2cap_register_signaling_response(handle, CONNECTION_REQUEST, sig_id, source_cid, 0x0004);
 801ae74:	8839      	ldrh	r1, [r7, #0]
 801ae76:	797a      	ldrb	r2, [r7, #5]
 801ae78:	88f8      	ldrh	r0, [r7, #6]
 801ae7a:	2304      	movs	r3, #4
 801ae7c:	9300      	str	r3, [sp, #0]
 801ae7e:	460b      	mov	r3, r1
 801ae80:	2102      	movs	r1, #2
 801ae82:	f7ff ff49 	bl	801ad18 <l2cap_register_signaling_response>
        return;
 801ae86:	e02a      	b.n	801aede <l2cap_handle_connection_request+0xfa>
    }

    channel->con_handle = handle;
 801ae88:	68fb      	ldr	r3, [r7, #12]
 801ae8a:	88fa      	ldrh	r2, [r7, #6]
 801ae8c:	849a      	strh	r2, [r3, #36]	; 0x24
    channel->remote_cid = source_cid;
 801ae8e:	68fb      	ldr	r3, [r7, #12]
 801ae90:	883a      	ldrh	r2, [r7, #0]
 801ae92:	861a      	strh	r2, [r3, #48]	; 0x30
    channel->remote_sig_id = sig_id; 
 801ae94:	68fb      	ldr	r3, [r7, #12]
 801ae96:	797a      	ldrb	r2, [r7, #5]
 801ae98:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    // limit local mtu to max acl packet length - l2cap header
    if (channel->local_mtu > l2cap_max_mtu()) {
 801ae9c:	68fb      	ldr	r3, [r7, #12]
 801ae9e:	8e5c      	ldrh	r4, [r3, #50]	; 0x32
 801aea0:	f7fe f944 	bl	801912c <l2cap_max_mtu>
 801aea4:	4603      	mov	r3, r0
 801aea6:	429c      	cmp	r4, r3
 801aea8:	d905      	bls.n	801aeb6 <l2cap_handle_connection_request+0xd2>
        channel->local_mtu = l2cap_max_mtu();
 801aeaa:	f7fe f93f 	bl	801912c <l2cap_max_mtu>
 801aeae:	4603      	mov	r3, r0
 801aeb0:	461a      	mov	r2, r3
 801aeb2:	68fb      	ldr	r3, [r7, #12]
 801aeb4:	865a      	strh	r2, [r3, #50]	; 0x32
    }
    
    // set initial state
    channel->state =      L2CAP_STATE_WAIT_INCOMING_SECURITY_LEVEL_UPDATE;
 801aeb6:	68fb      	ldr	r3, [r7, #12]
 801aeb8:	2205      	movs	r2, #5
 801aeba:	f883 2020 	strb.w	r2, [r3, #32]
    channel->state_var  = (L2CAP_CHANNEL_STATE_VAR) (L2CAP_CHANNEL_STATE_VAR_SEND_CONN_RESP_PEND | L2CAP_CHANNEL_STATE_VAR_INCOMING);
 801aebe:	68fb      	ldr	r3, [r7, #12]
 801aec0:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 801aec4:	845a      	strh	r2, [r3, #34]	; 0x22
    
    // add to connections list
    btstack_linked_list_add_tail(&l2cap_channels, (btstack_linked_item_t *) channel);
 801aec6:	68f9      	ldr	r1, [r7, #12]
 801aec8:	4808      	ldr	r0, [pc, #32]	; (801aeec <l2cap_handle_connection_request+0x108>)
 801aeca:	f7f3 fbd5 	bl	800e678 <btstack_linked_list_add_tail>

    // assert security requirements
    gap_request_security_level(handle, channel->required_security_level);
 801aece:	68fb      	ldr	r3, [r7, #12]
 801aed0:	f893 203a 	ldrb.w	r2, [r3, #58]	; 0x3a
 801aed4:	88fb      	ldrh	r3, [r7, #6]
 801aed6:	4611      	mov	r1, r2
 801aed8:	4618      	mov	r0, r3
 801aeda:	f7fb fca1 	bl	8016820 <gap_request_security_level>
}
 801aede:	371c      	adds	r7, #28
 801aee0:	46bd      	mov	sp, r7
 801aee2:	bd90      	pop	{r4, r7, pc}
 801aee4:	0802b1dc 	.word	0x0802b1dc
 801aee8:	0802bedc 	.word	0x0802bedc
 801aeec:	20009eac 	.word	0x20009eac

0801aef0 <l2cap_signaling_handle_configure_request>:
    channel->reason = 0x04; // no resources available
    l2cap_run();
}

// @pre command len is valid, see check in l2cap_signaling_handler_channel
static void l2cap_signaling_handle_configure_request(l2cap_channel_t *channel, uint8_t *command){
 801aef0:	b590      	push	{r4, r7, lr}
 801aef2:	b08d      	sub	sp, #52	; 0x34
 801aef4:	af06      	add	r7, sp, #24
 801aef6:	6078      	str	r0, [r7, #4]
 801aef8:	6039      	str	r1, [r7, #0]

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    uint8_t use_fcs = 1;
 801aefa:	2301      	movs	r3, #1
 801aefc:	75fb      	strb	r3, [r7, #23]
#endif

    channel->remote_sig_id = command[L2CAP_SIGNALING_COMMAND_SIGID_OFFSET];
 801aefe:	683b      	ldr	r3, [r7, #0]
 801af00:	785a      	ldrb	r2, [r3, #1]
 801af02:	687b      	ldr	r3, [r7, #4]
 801af04:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    uint16_t flags = little_endian_read_16(command, 6);
 801af08:	2106      	movs	r1, #6
 801af0a:	6838      	ldr	r0, [r7, #0]
 801af0c:	f7f3 ff6b 	bl	800ede6 <little_endian_read_16>
 801af10:	4603      	mov	r3, r0
 801af12:	827b      	strh	r3, [r7, #18]
    if (flags & 1) {
 801af14:	8a7b      	ldrh	r3, [r7, #18]
 801af16:	f003 0301 	and.w	r3, r3, #1
 801af1a:	2b00      	cmp	r3, #0
 801af1c:	d004      	beq.n	801af28 <l2cap_signaling_handle_configure_request+0x38>
        channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_CONT);
 801af1e:	f44f 7180 	mov.w	r1, #256	; 0x100
 801af22:	6878      	ldr	r0, [r7, #4]
 801af24:	f7fe f898 	bl	8019058 <channelStateVarSetFlag>
    }

    // accept the other's configuration options
    uint16_t end_pos = 4 + little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_LENGTH_OFFSET);
 801af28:	2102      	movs	r1, #2
 801af2a:	6838      	ldr	r0, [r7, #0]
 801af2c:	f7f3 ff5b 	bl	800ede6 <little_endian_read_16>
 801af30:	4603      	mov	r3, r0
 801af32:	3304      	adds	r3, #4
 801af34:	823b      	strh	r3, [r7, #16]
    uint16_t pos     = 8;
 801af36:	2308      	movs	r3, #8
 801af38:	82bb      	strh	r3, [r7, #20]
    while (pos < end_pos){
 801af3a:	e127      	b.n	801b18c <l2cap_signaling_handle_configure_request+0x29c>
        uint8_t option_hint = command[pos] >> 7;
 801af3c:	8abb      	ldrh	r3, [r7, #20]
 801af3e:	683a      	ldr	r2, [r7, #0]
 801af40:	4413      	add	r3, r2
 801af42:	781b      	ldrb	r3, [r3, #0]
 801af44:	09db      	lsrs	r3, r3, #7
 801af46:	73bb      	strb	r3, [r7, #14]
        uint8_t option_type = command[pos] & 0x7f;
 801af48:	8abb      	ldrh	r3, [r7, #20]
 801af4a:	683a      	ldr	r2, [r7, #0]
 801af4c:	4413      	add	r3, r2
 801af4e:	781b      	ldrb	r3, [r3, #0]
 801af50:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801af54:	737b      	strb	r3, [r7, #13]
        // log_info("l2cap cid %u, hint %u, type %u", channel->local_cid, option_hint, option_type);
        pos++;
 801af56:	8abb      	ldrh	r3, [r7, #20]
 801af58:	3301      	adds	r3, #1
 801af5a:	82bb      	strh	r3, [r7, #20]
        uint8_t length = command[pos++];
 801af5c:	8abb      	ldrh	r3, [r7, #20]
 801af5e:	1c5a      	adds	r2, r3, #1
 801af60:	82ba      	strh	r2, [r7, #20]
 801af62:	461a      	mov	r2, r3
 801af64:	683b      	ldr	r3, [r7, #0]
 801af66:	4413      	add	r3, r2
 801af68:	781b      	ldrb	r3, [r3, #0]
 801af6a:	733b      	strb	r3, [r7, #12]
        // MTU { type(8): 1, len(8):2, MTU(16) }
        if ((option_type == L2CAP_CONFIG_OPTION_TYPE_MAX_TRANSMISSION_UNIT) && (length == 2)){
 801af6c:	7b7b      	ldrb	r3, [r7, #13]
 801af6e:	2b01      	cmp	r3, #1
 801af70:	d135      	bne.n	801afde <l2cap_signaling_handle_configure_request+0xee>
 801af72:	7b3b      	ldrb	r3, [r7, #12]
 801af74:	2b02      	cmp	r3, #2
 801af76:	d132      	bne.n	801afde <l2cap_signaling_handle_configure_request+0xee>
            channel->remote_mtu = little_endian_read_16(command, pos);
 801af78:	8abb      	ldrh	r3, [r7, #20]
 801af7a:	4619      	mov	r1, r3
 801af7c:	6838      	ldr	r0, [r7, #0]
 801af7e:	f7f3 ff32 	bl	800ede6 <little_endian_read_16>
 801af82:	4603      	mov	r3, r0
 801af84:	461a      	mov	r2, r3
 801af86:	687b      	ldr	r3, [r7, #4]
 801af88:	869a      	strh	r2, [r3, #52]	; 0x34
            log_info("Remote MTU %u", channel->remote_mtu);
 801af8a:	687b      	ldr	r3, [r7, #4]
 801af8c:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 801af8e:	9300      	str	r3, [sp, #0]
 801af90:	f44f 6326 	mov.w	r3, #2656	; 0xa60
 801af94:	4a9c      	ldr	r2, [pc, #624]	; (801b208 <l2cap_signaling_handle_configure_request+0x318>)
 801af96:	499d      	ldr	r1, [pc, #628]	; (801b20c <l2cap_signaling_handle_configure_request+0x31c>)
 801af98:	2001      	movs	r0, #1
 801af9a:	f7fc fa51 	bl	8017440 <hci_dump_log>
            if (channel->remote_mtu > l2cap_max_mtu()){
 801af9e:	687b      	ldr	r3, [r7, #4]
 801afa0:	8e9c      	ldrh	r4, [r3, #52]	; 0x34
 801afa2:	f7fe f8c3 	bl	801912c <l2cap_max_mtu>
 801afa6:	4603      	mov	r3, r0
 801afa8:	429c      	cmp	r4, r3
 801afaa:	d914      	bls.n	801afd6 <l2cap_signaling_handle_configure_request+0xe6>
                log_info("Remote MTU %u larger than outgoing buffer, only using MTU = %u", channel->remote_mtu, l2cap_max_mtu());
 801afac:	687b      	ldr	r3, [r7, #4]
 801afae:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 801afb0:	461c      	mov	r4, r3
 801afb2:	f7fe f8bb 	bl	801912c <l2cap_max_mtu>
 801afb6:	4603      	mov	r3, r0
 801afb8:	9301      	str	r3, [sp, #4]
 801afba:	9400      	str	r4, [sp, #0]
 801afbc:	f640 2362 	movw	r3, #2658	; 0xa62
 801afc0:	4a91      	ldr	r2, [pc, #580]	; (801b208 <l2cap_signaling_handle_configure_request+0x318>)
 801afc2:	4993      	ldr	r1, [pc, #588]	; (801b210 <l2cap_signaling_handle_configure_request+0x320>)
 801afc4:	2001      	movs	r0, #1
 801afc6:	f7fc fa3b 	bl	8017440 <hci_dump_log>
                channel->remote_mtu = l2cap_max_mtu();
 801afca:	f7fe f8af 	bl	801912c <l2cap_max_mtu>
 801afce:	4603      	mov	r3, r0
 801afd0:	461a      	mov	r2, r3
 801afd2:	687b      	ldr	r3, [r7, #4]
 801afd4:	869a      	strh	r2, [r3, #52]	; 0x34
            }
            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_MTU);
 801afd6:	2140      	movs	r1, #64	; 0x40
 801afd8:	6878      	ldr	r0, [r7, #4]
 801afda:	f7fe f83d 	bl	8019058 <channelStateVarSetFlag>
        }
        // Flush timeout { type(8):2, len(8): 2, Flush Timeout(16)}
        if ((option_type == L2CAP_CONFIG_OPTION_TYPE_FLUSH_TIMEOUT) && (length == 2)){
 801afde:	7b7b      	ldrb	r3, [r7, #13]
 801afe0:	2b02      	cmp	r3, #2
 801afe2:	d115      	bne.n	801b010 <l2cap_signaling_handle_configure_request+0x120>
 801afe4:	7b3b      	ldrb	r3, [r7, #12]
 801afe6:	2b02      	cmp	r3, #2
 801afe8:	d112      	bne.n	801b010 <l2cap_signaling_handle_configure_request+0x120>
            channel->flush_timeout = little_endian_read_16(command, pos);
 801afea:	8abb      	ldrh	r3, [r7, #20]
 801afec:	4619      	mov	r1, r3
 801afee:	6838      	ldr	r0, [r7, #0]
 801aff0:	f7f3 fef9 	bl	800ede6 <little_endian_read_16>
 801aff4:	4603      	mov	r3, r0
 801aff6:	461a      	mov	r2, r3
 801aff8:	687b      	ldr	r3, [r7, #4]
 801affa:	86da      	strh	r2, [r3, #54]	; 0x36
            log_info("Flush timeout: %u ms", channel->flush_timeout);
 801affc:	687b      	ldr	r3, [r7, #4]
 801affe:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 801b000:	9300      	str	r3, [sp, #0]
 801b002:	f640 236a 	movw	r3, #2666	; 0xa6a
 801b006:	4a80      	ldr	r2, [pc, #512]	; (801b208 <l2cap_signaling_handle_configure_request+0x318>)
 801b008:	4982      	ldr	r1, [pc, #520]	; (801b214 <l2cap_signaling_handle_configure_request+0x324>)
 801b00a:	2001      	movs	r0, #1
 801b00c:	f7fc fa18 	bl	8017440 <hci_dump_log>
        }

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
        // Retransmission and Flow Control Option
        if (option_type == L2CAP_CONFIG_OPTION_TYPE_RETRANSMISSION_AND_FLOW_CONTROL && length == 9){
 801b010:	7b7b      	ldrb	r3, [r7, #13]
 801b012:	2b04      	cmp	r3, #4
 801b014:	f040 8091 	bne.w	801b13a <l2cap_signaling_handle_configure_request+0x24a>
 801b018:	7b3b      	ldrb	r3, [r7, #12]
 801b01a:	2b09      	cmp	r3, #9
 801b01c:	f040 808d 	bne.w	801b13a <l2cap_signaling_handle_configure_request+0x24a>
            l2cap_channel_mode_t mode = (l2cap_channel_mode_t) command[pos];
 801b020:	8abb      	ldrh	r3, [r7, #20]
 801b022:	683a      	ldr	r2, [r7, #0]
 801b024:	4413      	add	r3, r2
 801b026:	781b      	ldrb	r3, [r3, #0]
 801b028:	72fb      	strb	r3, [r7, #11]
            switch(channel->mode){
 801b02a:	687b      	ldr	r3, [r7, #4]
 801b02c:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 801b030:	2b00      	cmp	r3, #0
 801b032:	d064      	beq.n	801b0fe <l2cap_signaling_handle_configure_request+0x20e>
 801b034:	2b03      	cmp	r3, #3
 801b036:	d000      	beq.n	801b03a <l2cap_signaling_handle_configure_request+0x14a>
                            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_ERTM);
                            break;
                    }
                    break;
                default:
                    break;
 801b038:	e080      	b.n	801b13c <l2cap_signaling_handle_configure_request+0x24c>
                    channel->remote_tx_window_size = command[pos+1];
 801b03a:	8abb      	ldrh	r3, [r7, #20]
 801b03c:	3301      	adds	r3, #1
 801b03e:	683a      	ldr	r2, [r7, #0]
 801b040:	4413      	add	r3, r2
 801b042:	781a      	ldrb	r2, [r3, #0]
 801b044:	687b      	ldr	r3, [r7, #4]
 801b046:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84
                    channel->remote_max_transmit   = command[pos+2];
 801b04a:	8abb      	ldrh	r3, [r7, #20]
 801b04c:	3302      	adds	r3, #2
 801b04e:	683a      	ldr	r2, [r7, #0]
 801b050:	4413      	add	r3, r2
 801b052:	781a      	ldrb	r2, [r3, #0]
 801b054:	687b      	ldr	r3, [r7, #4]
 801b056:	f883 2086 	strb.w	r2, [r3, #134]	; 0x86
                    channel->remote_retransmission_timeout_ms = little_endian_read_16(command, pos + 3);
 801b05a:	8abb      	ldrh	r3, [r7, #20]
 801b05c:	3303      	adds	r3, #3
 801b05e:	4619      	mov	r1, r3
 801b060:	6838      	ldr	r0, [r7, #0]
 801b062:	f7f3 fec0 	bl	800ede6 <little_endian_read_16>
 801b066:	4603      	mov	r3, r0
 801b068:	461a      	mov	r2, r3
 801b06a:	687b      	ldr	r3, [r7, #4]
 801b06c:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80
                    channel->remote_monitor_timeout_ms = little_endian_read_16(command, pos + 5);
 801b070:	8abb      	ldrh	r3, [r7, #20]
 801b072:	3305      	adds	r3, #5
 801b074:	4619      	mov	r1, r3
 801b076:	6838      	ldr	r0, [r7, #0]
 801b078:	f7f3 feb5 	bl	800ede6 <little_endian_read_16>
 801b07c:	4603      	mov	r3, r0
 801b07e:	461a      	mov	r2, r3
 801b080:	687b      	ldr	r3, [r7, #4]
 801b082:	f8a3 2082 	strh.w	r2, [r3, #130]	; 0x82
                    channel->remote_mps = little_endian_read_16(command, pos + 7);
 801b086:	8abb      	ldrh	r3, [r7, #20]
 801b088:	3307      	adds	r3, #7
 801b08a:	4619      	mov	r1, r3
 801b08c:	6838      	ldr	r0, [r7, #0]
 801b08e:	f7f3 feaa 	bl	800ede6 <little_endian_read_16>
 801b092:	4603      	mov	r3, r0
 801b094:	461a      	mov	r2, r3
 801b096:	687b      	ldr	r3, [r7, #4]
 801b098:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
                    log_info("FC&C config: tx window: %u, max transmit %u, retrans timeout %u, monitor timeout %u, mps %u",
 801b09c:	687b      	ldr	r3, [r7, #4]
 801b09e:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 801b0a2:	461a      	mov	r2, r3
 801b0a4:	687b      	ldr	r3, [r7, #4]
 801b0a6:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
 801b0aa:	4619      	mov	r1, r3
 801b0ac:	687b      	ldr	r3, [r7, #4]
 801b0ae:	f8b3 3080 	ldrh.w	r3, [r3, #128]	; 0x80
 801b0b2:	4618      	mov	r0, r3
 801b0b4:	687b      	ldr	r3, [r7, #4]
 801b0b6:	f8b3 3082 	ldrh.w	r3, [r3, #130]	; 0x82
 801b0ba:	461c      	mov	r4, r3
 801b0bc:	687b      	ldr	r3, [r7, #4]
 801b0be:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 801b0c2:	9304      	str	r3, [sp, #16]
 801b0c4:	9403      	str	r4, [sp, #12]
 801b0c6:	9002      	str	r0, [sp, #8]
 801b0c8:	9101      	str	r1, [sp, #4]
 801b0ca:	9200      	str	r2, [sp, #0]
 801b0cc:	f640 237e 	movw	r3, #2686	; 0xa7e
 801b0d0:	4a4d      	ldr	r2, [pc, #308]	; (801b208 <l2cap_signaling_handle_configure_request+0x318>)
 801b0d2:	4951      	ldr	r1, [pc, #324]	; (801b218 <l2cap_signaling_handle_configure_request+0x328>)
 801b0d4:	2001      	movs	r0, #1
 801b0d6:	f7fc f9b3 	bl	8017440 <hci_dump_log>
                    if (channel->ertm_mandatory && mode != L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION){
 801b0da:	687b      	ldr	r3, [r7, #4]
 801b0dc:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
 801b0e0:	2b00      	cmp	r3, #0
 801b0e2:	d007      	beq.n	801b0f4 <l2cap_signaling_handle_configure_request+0x204>
 801b0e4:	7afb      	ldrb	r3, [r7, #11]
 801b0e6:	2b03      	cmp	r3, #3
 801b0e8:	d004      	beq.n	801b0f4 <l2cap_signaling_handle_configure_request+0x204>
                        channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST;
 801b0ea:	687b      	ldr	r3, [r7, #4]
 801b0ec:	2212      	movs	r2, #18
 801b0ee:	f883 2020 	strb.w	r2, [r3, #32]
                    break;
 801b0f2:	e023      	b.n	801b13c <l2cap_signaling_handle_configure_request+0x24c>
                        channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_ERTM);
 801b0f4:	2180      	movs	r1, #128	; 0x80
 801b0f6:	6878      	ldr	r0, [r7, #4]
 801b0f8:	f7fd ffae 	bl	8019058 <channelStateVarSetFlag>
                    break;
 801b0fc:	e01e      	b.n	801b13c <l2cap_signaling_handle_configure_request+0x24c>
                    switch (mode){
 801b0fe:	7afb      	ldrb	r3, [r7, #11]
 801b100:	2b03      	cmp	r3, #3
 801b102:	d114      	bne.n	801b12e <l2cap_signaling_handle_configure_request+0x23e>
                            if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_BASIC_FALLBACK_TRIED){
 801b104:	687b      	ldr	r3, [r7, #4]
 801b106:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801b108:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801b10c:	2b00      	cmp	r3, #0
 801b10e:	d003      	beq.n	801b118 <l2cap_signaling_handle_configure_request+0x228>
                                channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST;
 801b110:	687b      	ldr	r3, [r7, #4]
 801b112:	2212      	movs	r2, #18
 801b114:	f883 2020 	strb.w	r2, [r3, #32]
                            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_BASIC_FALLBACK_TRIED);
 801b118:	f44f 6100 	mov.w	r1, #2048	; 0x800
 801b11c:	6878      	ldr	r0, [r7, #4]
 801b11e:	f7fd ff9b 	bl	8019058 <channelStateVarSetFlag>
                            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_REJECTED);
 801b122:	f44f 6180 	mov.w	r1, #1024	; 0x400
 801b126:	6878      	ldr	r0, [r7, #4]
 801b128:	f7fd ff96 	bl	8019058 <channelStateVarSetFlag>
                            break;
 801b12c:	e004      	b.n	801b138 <l2cap_signaling_handle_configure_request+0x248>
                            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_ERTM);
 801b12e:	2180      	movs	r1, #128	; 0x80
 801b130:	6878      	ldr	r0, [r7, #4]
 801b132:	f7fd ff91 	bl	8019058 <channelStateVarSetFlag>
                            break;
 801b136:	bf00      	nop
                    break;
 801b138:	e000      	b.n	801b13c <l2cap_signaling_handle_configure_request+0x24c>
            }
        }
 801b13a:	bf00      	nop
        if (option_type == L2CAP_CONFIG_OPTION_TYPE_FRAME_CHECK_SEQUENCE && length == 1){
 801b13c:	7b7b      	ldrb	r3, [r7, #13]
 801b13e:	2b05      	cmp	r3, #5
 801b140:	d107      	bne.n	801b152 <l2cap_signaling_handle_configure_request+0x262>
 801b142:	7b3b      	ldrb	r3, [r7, #12]
 801b144:	2b01      	cmp	r3, #1
 801b146:	d104      	bne.n	801b152 <l2cap_signaling_handle_configure_request+0x262>
            use_fcs = command[pos];
 801b148:	8abb      	ldrh	r3, [r7, #20]
 801b14a:	683a      	ldr	r2, [r7, #0]
 801b14c:	4413      	add	r3, r2
 801b14e:	781b      	ldrb	r3, [r3, #0]
 801b150:	75fb      	strb	r3, [r7, #23]
        }        
#endif        
        // check for unknown options
        if ((option_hint == 0) && ((option_type < L2CAP_CONFIG_OPTION_TYPE_MAX_TRANSMISSION_UNIT) || (option_type > L2CAP_CONFIG_OPTION_TYPE_EXTENDED_WINDOW_SIZE))){
 801b152:	7bbb      	ldrb	r3, [r7, #14]
 801b154:	2b00      	cmp	r3, #0
 801b156:	d114      	bne.n	801b182 <l2cap_signaling_handle_configure_request+0x292>
 801b158:	7b7b      	ldrb	r3, [r7, #13]
 801b15a:	2b00      	cmp	r3, #0
 801b15c:	d002      	beq.n	801b164 <l2cap_signaling_handle_configure_request+0x274>
 801b15e:	7b7b      	ldrb	r3, [r7, #13]
 801b160:	2b07      	cmp	r3, #7
 801b162:	d90e      	bls.n	801b182 <l2cap_signaling_handle_configure_request+0x292>
            log_info("l2cap cid %u, unknown options", channel->local_cid);
 801b164:	687b      	ldr	r3, [r7, #4]
 801b166:	88db      	ldrh	r3, [r3, #6]
 801b168:	9300      	str	r3, [sp, #0]
 801b16a:	f44f 632a 	mov.w	r3, #2720	; 0xaa0
 801b16e:	4a26      	ldr	r2, [pc, #152]	; (801b208 <l2cap_signaling_handle_configure_request+0x318>)
 801b170:	492a      	ldr	r1, [pc, #168]	; (801b21c <l2cap_signaling_handle_configure_request+0x32c>)
 801b172:	2001      	movs	r0, #1
 801b174:	f7fc f964 	bl	8017440 <hci_dump_log>
            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_INVALID);
 801b178:	f44f 7100 	mov.w	r1, #512	; 0x200
 801b17c:	6878      	ldr	r0, [r7, #4]
 801b17e:	f7fd ff6b 	bl	8019058 <channelStateVarSetFlag>
        }
        pos += length;
 801b182:	7b3b      	ldrb	r3, [r7, #12]
 801b184:	b29a      	uxth	r2, r3
 801b186:	8abb      	ldrh	r3, [r7, #20]
 801b188:	4413      	add	r3, r2
 801b18a:	82bb      	strh	r3, [r7, #20]
    while (pos < end_pos){
 801b18c:	8aba      	ldrh	r2, [r7, #20]
 801b18e:	8a3b      	ldrh	r3, [r7, #16]
 801b190:	429a      	cmp	r2, r3
 801b192:	f4ff aed3 	bcc.w	801af3c <l2cap_signaling_handle_configure_request+0x4c>
    }

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
        // "FCS" has precedence over "No FCS"
        uint8_t update = channel->fcs_option || use_fcs;
 801b196:	687b      	ldr	r3, [r7, #4]
 801b198:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 801b19c:	2b00      	cmp	r3, #0
 801b19e:	d102      	bne.n	801b1a6 <l2cap_signaling_handle_configure_request+0x2b6>
 801b1a0:	7dfb      	ldrb	r3, [r7, #23]
 801b1a2:	2b00      	cmp	r3, #0
 801b1a4:	d001      	beq.n	801b1aa <l2cap_signaling_handle_configure_request+0x2ba>
 801b1a6:	2301      	movs	r3, #1
 801b1a8:	e000      	b.n	801b1ac <l2cap_signaling_handle_configure_request+0x2bc>
 801b1aa:	2300      	movs	r3, #0
 801b1ac:	73fb      	strb	r3, [r7, #15]
        log_info("local fcs: %u, remote fcs: %u -> %u", channel->fcs_option, use_fcs, update);
 801b1ae:	687b      	ldr	r3, [r7, #4]
 801b1b0:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 801b1b4:	4619      	mov	r1, r3
 801b1b6:	7dfb      	ldrb	r3, [r7, #23]
 801b1b8:	7bfa      	ldrb	r2, [r7, #15]
 801b1ba:	9202      	str	r2, [sp, #8]
 801b1bc:	9301      	str	r3, [sp, #4]
 801b1be:	9100      	str	r1, [sp, #0]
 801b1c0:	f640 23a9 	movw	r3, #2729	; 0xaa9
 801b1c4:	4a10      	ldr	r2, [pc, #64]	; (801b208 <l2cap_signaling_handle_configure_request+0x318>)
 801b1c6:	4916      	ldr	r1, [pc, #88]	; (801b220 <l2cap_signaling_handle_configure_request+0x330>)
 801b1c8:	2001      	movs	r0, #1
 801b1ca:	f7fc f939 	bl	8017440 <hci_dump_log>
        channel->fcs_option = update;
 801b1ce:	687b      	ldr	r3, [r7, #4]
 801b1d0:	7bfa      	ldrb	r2, [r7, #15]
 801b1d2:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
        // If ERTM mandatory, but remote didn't send Retransmission and Flowcontrol options -> disconnect
        if (((channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_ERTM) == 0) & (channel->ertm_mandatory)){
 801b1d6:	687b      	ldr	r3, [r7, #4]
 801b1d8:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801b1da:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801b1de:	2b00      	cmp	r3, #0
 801b1e0:	bf0c      	ite	eq
 801b1e2:	2301      	moveq	r3, #1
 801b1e4:	2300      	movne	r3, #0
 801b1e6:	b2db      	uxtb	r3, r3
 801b1e8:	461a      	mov	r2, r3
 801b1ea:	687b      	ldr	r3, [r7, #4]
 801b1ec:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
 801b1f0:	4013      	ands	r3, r2
 801b1f2:	2b00      	cmp	r3, #0
 801b1f4:	d003      	beq.n	801b1fe <l2cap_signaling_handle_configure_request+0x30e>
            channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST;
 801b1f6:	687b      	ldr	r3, [r7, #4]
 801b1f8:	2212      	movs	r2, #18
 801b1fa:	f883 2020 	strb.w	r2, [r3, #32]
        }
#endif
}
 801b1fe:	bf00      	nop
 801b200:	371c      	adds	r7, #28
 801b202:	46bd      	mov	sp, r7
 801b204:	bd90      	pop	{r4, r7, pc}
 801b206:	bf00      	nop
 801b208:	0802b1dc 	.word	0x0802b1dc
 801b20c:	0802bf64 	.word	0x0802bf64
 801b210:	0802bf7c 	.word	0x0802bf7c
 801b214:	0802bfc4 	.word	0x0802bfc4
 801b218:	0802bfe0 	.word	0x0802bfe0
 801b21c:	0802c044 	.word	0x0802c044
 801b220:	0802c06c 	.word	0x0802c06c

0801b224 <l2cap_signaling_handle_configure_response>:

// @pre command len is valid, see check in l2cap_signaling_handler_channel
static void l2cap_signaling_handle_configure_response(l2cap_channel_t *channel, uint8_t result, uint8_t *command){
 801b224:	b580      	push	{r7, lr}
 801b226:	b088      	sub	sp, #32
 801b228:	af02      	add	r7, sp, #8
 801b22a:	60f8      	str	r0, [r7, #12]
 801b22c:	460b      	mov	r3, r1
 801b22e:	607a      	str	r2, [r7, #4]
 801b230:	72fb      	strb	r3, [r7, #11]
    log_info("l2cap_signaling_handle_configure_response");
 801b232:	f640 23b4 	movw	r3, #2740	; 0xab4
 801b236:	4a3c      	ldr	r2, [pc, #240]	; (801b328 <l2cap_signaling_handle_configure_response+0x104>)
 801b238:	493c      	ldr	r1, [pc, #240]	; (801b32c <l2cap_signaling_handle_configure_response+0x108>)
 801b23a:	2001      	movs	r0, #1
 801b23c:	f7fc f900 	bl	8017440 <hci_dump_log>
#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    uint16_t end_pos = 4 + little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_LENGTH_OFFSET);
 801b240:	2102      	movs	r1, #2
 801b242:	6878      	ldr	r0, [r7, #4]
 801b244:	f7f3 fdcf 	bl	800ede6 <little_endian_read_16>
 801b248:	4603      	mov	r3, r0
 801b24a:	3304      	adds	r3, #4
 801b24c:	82bb      	strh	r3, [r7, #20]
    uint16_t pos     = 10;
 801b24e:	230a      	movs	r3, #10
 801b250:	82fb      	strh	r3, [r7, #22]
    while (pos < end_pos){
 801b252:	e060      	b.n	801b316 <l2cap_signaling_handle_configure_response+0xf2>
        uint8_t option_hint = command[pos] >> 7;
 801b254:	8afb      	ldrh	r3, [r7, #22]
 801b256:	687a      	ldr	r2, [r7, #4]
 801b258:	4413      	add	r3, r2
 801b25a:	781b      	ldrb	r3, [r3, #0]
 801b25c:	09db      	lsrs	r3, r3, #7
 801b25e:	74fb      	strb	r3, [r7, #19]
        uint8_t option_type = command[pos] & 0x7f;
 801b260:	8afb      	ldrh	r3, [r7, #22]
 801b262:	687a      	ldr	r2, [r7, #4]
 801b264:	4413      	add	r3, r2
 801b266:	781b      	ldrb	r3, [r3, #0]
 801b268:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801b26c:	74bb      	strb	r3, [r7, #18]
        // log_info("l2cap cid %u, hint %u, type %u", channel->local_cid, option_hint, option_type);
        pos++;
 801b26e:	8afb      	ldrh	r3, [r7, #22]
 801b270:	3301      	adds	r3, #1
 801b272:	82fb      	strh	r3, [r7, #22]
        uint8_t length = command[pos++];
 801b274:	8afb      	ldrh	r3, [r7, #22]
 801b276:	1c5a      	adds	r2, r3, #1
 801b278:	82fa      	strh	r2, [r7, #22]
 801b27a:	461a      	mov	r2, r3
 801b27c:	687b      	ldr	r3, [r7, #4]
 801b27e:	4413      	add	r3, r2
 801b280:	781b      	ldrb	r3, [r3, #0]
 801b282:	747b      	strb	r3, [r7, #17]

        // Retransmission and Flow Control Option
        if (option_type == L2CAP_CONFIG_OPTION_TYPE_RETRANSMISSION_AND_FLOW_CONTROL && length == 9){
 801b284:	7cbb      	ldrb	r3, [r7, #18]
 801b286:	2b04      	cmp	r3, #4
 801b288:	d123      	bne.n	801b2d2 <l2cap_signaling_handle_configure_response+0xae>
 801b28a:	7c7b      	ldrb	r3, [r7, #17]
 801b28c:	2b09      	cmp	r3, #9
 801b28e:	d120      	bne.n	801b2d2 <l2cap_signaling_handle_configure_response+0xae>
            switch (channel->mode){
 801b290:	68fb      	ldr	r3, [r7, #12]
 801b292:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 801b296:	2b00      	cmp	r3, #0
 801b298:	d013      	beq.n	801b2c2 <l2cap_signaling_handle_configure_response+0x9e>
 801b29a:	2b03      	cmp	r3, #3
 801b29c:	d000      	beq.n	801b2a0 <l2cap_signaling_handle_configure_response+0x7c>
                        // On 'Reject - Unacceptable Parameters' to our Basic mode request, disconnect
                        channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST;
                    }
                    break;
                default:
                    break;
 801b29e:	e01d      	b.n	801b2dc <l2cap_signaling_handle_configure_response+0xb8>
                    if (channel->ertm_mandatory){
 801b2a0:	68fb      	ldr	r3, [r7, #12]
 801b2a2:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
 801b2a6:	2b00      	cmp	r3, #0
 801b2a8:	d115      	bne.n	801b2d6 <l2cap_signaling_handle_configure_response+0xb2>
                        if (result == L2CAP_CONF_RESULT_UNACCEPTABLE_PARAMETERS){
 801b2aa:	7afb      	ldrb	r3, [r7, #11]
 801b2ac:	2b01      	cmp	r3, #1
 801b2ae:	d112      	bne.n	801b2d6 <l2cap_signaling_handle_configure_response+0xb2>
                            l2cap_emit_simple_event_with_cid(channel, L2CAP_EVENT_ERTM_BUFFER_RELEASED);
 801b2b0:	217e      	movs	r1, #126	; 0x7e
 801b2b2:	68f8      	ldr	r0, [r7, #12]
 801b2b4:	f7fd fb15 	bl	80188e2 <l2cap_emit_simple_event_with_cid>
                            channel->mode = L2CAP_CHANNEL_MODE_BASIC;
 801b2b8:	68fb      	ldr	r3, [r7, #12]
 801b2ba:	2200      	movs	r2, #0
 801b2bc:	f883 2056 	strb.w	r2, [r3, #86]	; 0x56
                    break;
 801b2c0:	e009      	b.n	801b2d6 <l2cap_signaling_handle_configure_response+0xb2>
                    if (result == L2CAP_CONF_RESULT_UNACCEPTABLE_PARAMETERS){
 801b2c2:	7afb      	ldrb	r3, [r7, #11]
 801b2c4:	2b01      	cmp	r3, #1
 801b2c6:	d108      	bne.n	801b2da <l2cap_signaling_handle_configure_response+0xb6>
                        channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST;
 801b2c8:	68fb      	ldr	r3, [r7, #12]
 801b2ca:	2212      	movs	r2, #18
 801b2cc:	f883 2020 	strb.w	r2, [r3, #32]
                    break;
 801b2d0:	e003      	b.n	801b2da <l2cap_signaling_handle_configure_response+0xb6>
            }
        }
 801b2d2:	bf00      	nop
 801b2d4:	e002      	b.n	801b2dc <l2cap_signaling_handle_configure_response+0xb8>
                    break;
 801b2d6:	bf00      	nop
 801b2d8:	e000      	b.n	801b2dc <l2cap_signaling_handle_configure_response+0xb8>
                    break;
 801b2da:	bf00      	nop

        // check for unknown options
        if (option_hint == 0 && (option_type < L2CAP_CONFIG_OPTION_TYPE_MAX_TRANSMISSION_UNIT || option_type > L2CAP_CONFIG_OPTION_TYPE_EXTENDED_WINDOW_SIZE)){
 801b2dc:	7cfb      	ldrb	r3, [r7, #19]
 801b2de:	2b00      	cmp	r3, #0
 801b2e0:	d114      	bne.n	801b30c <l2cap_signaling_handle_configure_response+0xe8>
 801b2e2:	7cbb      	ldrb	r3, [r7, #18]
 801b2e4:	2b00      	cmp	r3, #0
 801b2e6:	d002      	beq.n	801b2ee <l2cap_signaling_handle_configure_response+0xca>
 801b2e8:	7cbb      	ldrb	r3, [r7, #18]
 801b2ea:	2b07      	cmp	r3, #7
 801b2ec:	d90e      	bls.n	801b30c <l2cap_signaling_handle_configure_response+0xe8>
            log_info("l2cap cid %u, unknown options", channel->local_cid);
 801b2ee:	68fb      	ldr	r3, [r7, #12]
 801b2f0:	88db      	ldrh	r3, [r3, #6]
 801b2f2:	9300      	str	r3, [sp, #0]
 801b2f4:	f640 23da 	movw	r3, #2778	; 0xada
 801b2f8:	4a0b      	ldr	r2, [pc, #44]	; (801b328 <l2cap_signaling_handle_configure_response+0x104>)
 801b2fa:	490d      	ldr	r1, [pc, #52]	; (801b330 <l2cap_signaling_handle_configure_response+0x10c>)
 801b2fc:	2001      	movs	r0, #1
 801b2fe:	f7fc f89f 	bl	8017440 <hci_dump_log>
            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_INVALID);
 801b302:	f44f 7100 	mov.w	r1, #512	; 0x200
 801b306:	68f8      	ldr	r0, [r7, #12]
 801b308:	f7fd fea6 	bl	8019058 <channelStateVarSetFlag>
        }

        pos += length;
 801b30c:	7c7b      	ldrb	r3, [r7, #17]
 801b30e:	b29a      	uxth	r2, r3
 801b310:	8afb      	ldrh	r3, [r7, #22]
 801b312:	4413      	add	r3, r2
 801b314:	82fb      	strh	r3, [r7, #22]
    while (pos < end_pos){
 801b316:	8afa      	ldrh	r2, [r7, #22]
 801b318:	8abb      	ldrh	r3, [r7, #20]
 801b31a:	429a      	cmp	r2, r3
 801b31c:	d39a      	bcc.n	801b254 <l2cap_signaling_handle_configure_response+0x30>
#else
    UNUSED(channel);  // ok: no code
    UNUSED(result);   // ok: no code
    UNUSED(command);  // ok: no code
#endif        
}
 801b31e:	bf00      	nop
 801b320:	3718      	adds	r7, #24
 801b322:	46bd      	mov	sp, r7
 801b324:	bd80      	pop	{r7, pc}
 801b326:	bf00      	nop
 801b328:	0802b1dc 	.word	0x0802b1dc
 801b32c:	0802c098 	.word	0x0802c098
 801b330:	0802c044 	.word	0x0802c044

0801b334 <l2cap_channel_ready_for_open>:

static int l2cap_channel_ready_for_open(l2cap_channel_t *channel){
 801b334:	b480      	push	{r7}
 801b336:	b083      	sub	sp, #12
 801b338:	af00      	add	r7, sp, #0
 801b33a:	6078      	str	r0, [r7, #4]
    // log_info("l2cap_channel_ready_for_open 0x%02x", channel->state_var);
    if ((channel->state_var & L2CAP_CHANNEL_STATE_VAR_RCVD_CONF_RSP) == 0) return 0;
 801b33c:	687b      	ldr	r3, [r7, #4]
 801b33e:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801b340:	f003 0302 	and.w	r3, r3, #2
 801b344:	2b00      	cmp	r3, #0
 801b346:	d101      	bne.n	801b34c <l2cap_channel_ready_for_open+0x18>
 801b348:	2300      	movs	r3, #0
 801b34a:	e00f      	b.n	801b36c <l2cap_channel_ready_for_open+0x38>
    if ((channel->state_var & L2CAP_CHANNEL_STATE_VAR_SENT_CONF_RSP) == 0) return 0;
 801b34c:	687b      	ldr	r3, [r7, #4]
 801b34e:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801b350:	f003 0320 	and.w	r3, r3, #32
 801b354:	2b00      	cmp	r3, #0
 801b356:	d101      	bne.n	801b35c <l2cap_channel_ready_for_open+0x28>
 801b358:	2300      	movs	r3, #0
 801b35a:	e007      	b.n	801b36c <l2cap_channel_ready_for_open+0x38>
    // addition check that fixes re-entrance issue causing l2cap event channel opened twice
    if (channel->state == L2CAP_STATE_OPEN) return 0;
 801b35c:	687b      	ldr	r3, [r7, #4]
 801b35e:	f893 3020 	ldrb.w	r3, [r3, #32]
 801b362:	2b0c      	cmp	r3, #12
 801b364:	d101      	bne.n	801b36a <l2cap_channel_ready_for_open+0x36>
 801b366:	2300      	movs	r3, #0
 801b368:	e000      	b.n	801b36c <l2cap_channel_ready_for_open+0x38>
    return 1;
 801b36a:	2301      	movs	r3, #1
}
 801b36c:	4618      	mov	r0, r3
 801b36e:	370c      	adds	r7, #12
 801b370:	46bd      	mov	sp, r7
 801b372:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b376:	4770      	bx	lr

0801b378 <l2cap_signaling_handler_channel>:


// @pre command len is valid, see check in l2cap_signaling_handler_dispatch
static void l2cap_signaling_handler_channel(l2cap_channel_t *channel, uint8_t *command){
 801b378:	b580      	push	{r7, lr}
 801b37a:	b088      	sub	sp, #32
 801b37c:	af02      	add	r7, sp, #8
 801b37e:	6078      	str	r0, [r7, #4]
 801b380:	6039      	str	r1, [r7, #0]

    uint8_t  code       = command[L2CAP_SIGNALING_COMMAND_CODE_OFFSET];
 801b382:	683b      	ldr	r3, [r7, #0]
 801b384:	781b      	ldrb	r3, [r3, #0]
 801b386:	75fb      	strb	r3, [r7, #23]
    uint8_t  identifier = command[L2CAP_SIGNALING_COMMAND_SIGID_OFFSET];
 801b388:	683b      	ldr	r3, [r7, #0]
 801b38a:	785b      	ldrb	r3, [r3, #1]
 801b38c:	75bb      	strb	r3, [r7, #22]
    uint16_t cmd_len    = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_LENGTH_OFFSET);
 801b38e:	2102      	movs	r1, #2
 801b390:	6838      	ldr	r0, [r7, #0]
 801b392:	f7f3 fd28 	bl	800ede6 <little_endian_read_16>
 801b396:	4603      	mov	r3, r0
 801b398:	82bb      	strh	r3, [r7, #20]
    uint16_t result = 0;
 801b39a:	2300      	movs	r3, #0
 801b39c:	827b      	strh	r3, [r7, #18]
    
    log_info("L2CAP signaling handler code %u, state %u", code, channel->state);
 801b39e:	7dfb      	ldrb	r3, [r7, #23]
 801b3a0:	687a      	ldr	r2, [r7, #4]
 801b3a2:	f892 2020 	ldrb.w	r2, [r2, #32]
 801b3a6:	9201      	str	r2, [sp, #4]
 801b3a8:	9300      	str	r3, [sp, #0]
 801b3aa:	f640 23f9 	movw	r3, #2809	; 0xaf9
 801b3ae:	4aa2      	ldr	r2, [pc, #648]	; (801b638 <l2cap_signaling_handler_channel+0x2c0>)
 801b3b0:	49a2      	ldr	r1, [pc, #648]	; (801b63c <l2cap_signaling_handler_channel+0x2c4>)
 801b3b2:	2001      	movs	r0, #1
 801b3b4:	f7fc f844 	bl	8017440 <hci_dump_log>
    
    // handle DISCONNECT REQUESTS seperately
    if (code == DISCONNECTION_REQUEST){
 801b3b8:	7dfb      	ldrb	r3, [r7, #23]
 801b3ba:	2b06      	cmp	r3, #6
 801b3bc:	d106      	bne.n	801b3cc <l2cap_signaling_handler_channel+0x54>
        l2cap_handle_disconnect_request(channel, identifier);
 801b3be:	7dbb      	ldrb	r3, [r7, #22]
 801b3c0:	b29b      	uxth	r3, r3
 801b3c2:	4619      	mov	r1, r3
 801b3c4:	6878      	ldr	r0, [r7, #4]
 801b3c6:	f7ff fceb 	bl	801ada0 <l2cap_handle_disconnect_request>
        return;
 801b3ca:	e132      	b.n	801b632 <l2cap_signaling_handler_channel+0x2ba>
    }
    
    // @STATEMACHINE(l2cap)
    switch (channel->state) {
 801b3cc:	687b      	ldr	r3, [r7, #4]
 801b3ce:	f893 3020 	ldrb.w	r3, [r3, #32]
 801b3d2:	3b01      	subs	r3, #1
 801b3d4:	2b0c      	cmp	r3, #12
 801b3d6:	f200 8129 	bhi.w	801b62c <l2cap_signaling_handler_channel+0x2b4>
 801b3da:	a201      	add	r2, pc, #4	; (adr r2, 801b3e0 <l2cap_signaling_handler_channel+0x68>)
 801b3dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801b3e0:	0801b62d 	.word	0x0801b62d
 801b3e4:	0801b62d 	.word	0x0801b62d
 801b3e8:	0801b62d 	.word	0x0801b62d
 801b3ec:	0801b62d 	.word	0x0801b62d
 801b3f0:	0801b62d 	.word	0x0801b62d
 801b3f4:	0801b62d 	.word	0x0801b62d
 801b3f8:	0801b62d 	.word	0x0801b62d
 801b3fc:	0801b62d 	.word	0x0801b62d
 801b400:	0801b62d 	.word	0x0801b62d
 801b404:	0801b415 	.word	0x0801b415
 801b408:	0801b4bb 	.word	0x0801b4bb
 801b40c:	0801b62d 	.word	0x0801b62d
 801b410:	0801b61b 	.word	0x0801b61b
            
        case L2CAP_STATE_WAIT_CONNECT_RSP:
            switch (code){
 801b414:	7dfb      	ldrb	r3, [r7, #23]
 801b416:	2b03      	cmp	r3, #3
 801b418:	d000      	beq.n	801b41c <l2cap_signaling_handler_channel+0xa4>
                    }
                    break;
                    
                default:
                    //@TODO: implement other signaling packets
                    break;
 801b41a:	e04d      	b.n	801b4b8 <l2cap_signaling_handler_channel+0x140>
                    if (cmd_len < 8){
 801b41c:	8abb      	ldrh	r3, [r7, #20]
 801b41e:	2b07      	cmp	r3, #7
 801b420:	d809      	bhi.n	801b436 <l2cap_signaling_handler_channel+0xbe>
                        l2cap_register_signaling_response(channel->con_handle, COMMAND_REJECT, identifier, 0, L2CAP_REJ_CMD_UNKNOWN);
 801b422:	687b      	ldr	r3, [r7, #4]
 801b424:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 801b426:	7dba      	ldrb	r2, [r7, #22]
 801b428:	2300      	movs	r3, #0
 801b42a:	9300      	str	r3, [sp, #0]
 801b42c:	2300      	movs	r3, #0
 801b42e:	2101      	movs	r1, #1
 801b430:	f7ff fc72 	bl	801ad18 <l2cap_register_signaling_response>
                        break;
 801b434:	e040      	b.n	801b4b8 <l2cap_signaling_handler_channel+0x140>
                    l2cap_stop_rtx(channel);
 801b436:	6878      	ldr	r0, [r7, #4]
 801b438:	f7fd fcbc 	bl	8018db4 <l2cap_stop_rtx>
                    result = little_endian_read_16 (command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET+4);
 801b43c:	2108      	movs	r1, #8
 801b43e:	6838      	ldr	r0, [r7, #0]
 801b440:	f7f3 fcd1 	bl	800ede6 <little_endian_read_16>
 801b444:	4603      	mov	r3, r0
 801b446:	827b      	strh	r3, [r7, #18]
                    switch (result) {
 801b448:	8a7b      	ldrh	r3, [r7, #18]
 801b44a:	2b00      	cmp	r3, #0
 801b44c:	d002      	beq.n	801b454 <l2cap_signaling_handler_channel+0xdc>
 801b44e:	2b01      	cmp	r3, #1
 801b450:	d011      	beq.n	801b476 <l2cap_signaling_handler_channel+0xfe>
 801b452:	e014      	b.n	801b47e <l2cap_signaling_handler_channel+0x106>
                            channel->remote_cid = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET);
 801b454:	2104      	movs	r1, #4
 801b456:	6838      	ldr	r0, [r7, #0]
 801b458:	f7f3 fcc5 	bl	800ede6 <little_endian_read_16>
 801b45c:	4603      	mov	r3, r0
 801b45e:	461a      	mov	r2, r3
 801b460:	687b      	ldr	r3, [r7, #4]
 801b462:	861a      	strh	r2, [r3, #48]	; 0x30
                            channel->state = L2CAP_STATE_CONFIG;
 801b464:	687b      	ldr	r3, [r7, #4]
 801b466:	220b      	movs	r2, #11
 801b468:	f883 2020 	strb.w	r2, [r3, #32]
                            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_REQ);
 801b46c:	2104      	movs	r1, #4
 801b46e:	6878      	ldr	r0, [r7, #4]
 801b470:	f7fd fdf2 	bl	8019058 <channelStateVarSetFlag>
                            break;
 801b474:	e01f      	b.n	801b4b6 <l2cap_signaling_handler_channel+0x13e>
                            l2cap_start_ertx(channel);
 801b476:	6878      	ldr	r0, [r7, #4]
 801b478:	f7fd fce6 	bl	8018e48 <l2cap_start_ertx>
                            break;
 801b47c:	e01b      	b.n	801b4b6 <l2cap_signaling_handler_channel+0x13e>
                            channel->state = L2CAP_STATE_CLOSED;
 801b47e:	687b      	ldr	r3, [r7, #4]
 801b480:	2201      	movs	r2, #1
 801b482:	f883 2020 	strb.w	r2, [r3, #32]
                            l2cap_handle_channel_open_failed(channel, L2CAP_CONNECTION_RESPONSE_RESULT_SUCCESSFUL + result);
 801b486:	8a7b      	ldrh	r3, [r7, #18]
 801b488:	b2db      	uxtb	r3, r3
 801b48a:	3363      	adds	r3, #99	; 0x63
 801b48c:	b2db      	uxtb	r3, r3
 801b48e:	4619      	mov	r1, r3
 801b490:	6878      	ldr	r0, [r7, #4]
 801b492:	f7fd fb83 	bl	8018b9c <l2cap_handle_channel_open_failed>
                            if ((L2CAP_CONNECTION_RESPONSE_RESULT_SUCCESSFUL + result) == L2CAP_CONNECTION_RESPONSE_RESULT_REFUSED_SECURITY){
 801b496:	8a7b      	ldrh	r3, [r7, #18]
 801b498:	2b03      	cmp	r3, #3
 801b49a:	d104      	bne.n	801b4a6 <l2cap_signaling_handler_channel+0x12e>
                                gap_drop_link_key_for_bd_addr(channel->address);
 801b49c:	687b      	ldr	r3, [r7, #4]
 801b49e:	3326      	adds	r3, #38	; 0x26
 801b4a0:	4618      	mov	r0, r3
 801b4a2:	f7f4 fb2d 	bl	800fb00 <gap_drop_link_key_for_bd_addr>
                            btstack_linked_list_remove(&l2cap_channels, (btstack_linked_item_t *) channel);
 801b4a6:	6879      	ldr	r1, [r7, #4]
 801b4a8:	4865      	ldr	r0, [pc, #404]	; (801b640 <l2cap_signaling_handler_channel+0x2c8>)
 801b4aa:	f7f3 f908 	bl	800e6be <btstack_linked_list_remove>
                            l2cap_free_channel_entry(channel);
 801b4ae:	6878      	ldr	r0, [r7, #4]
 801b4b0:	f7fe ff1e 	bl	801a2f0 <l2cap_free_channel_entry>
                            break;
 801b4b4:	bf00      	nop
                    break;
 801b4b6:	bf00      	nop
            }
            break;
 801b4b8:	e0bb      	b.n	801b632 <l2cap_signaling_handler_channel+0x2ba>

        case L2CAP_STATE_CONFIG:
            switch (code) {
 801b4ba:	7dfb      	ldrb	r3, [r7, #23]
 801b4bc:	2b04      	cmp	r3, #4
 801b4be:	d002      	beq.n	801b4c6 <l2cap_signaling_handler_channel+0x14e>
 801b4c0:	2b05      	cmp	r3, #5
 801b4c2:	d020      	beq.n	801b506 <l2cap_signaling_handler_channel+0x18e>
                            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_REQ);
                            break;
                    }
                    break;
                default:
                    break;
 801b4c4:	e061      	b.n	801b58a <l2cap_signaling_handler_channel+0x212>
                    if (cmd_len < 4){
 801b4c6:	8abb      	ldrh	r3, [r7, #20]
 801b4c8:	2b03      	cmp	r3, #3
 801b4ca:	d809      	bhi.n	801b4e0 <l2cap_signaling_handler_channel+0x168>
                        l2cap_register_signaling_response(channel->con_handle, COMMAND_REJECT, identifier, 0, L2CAP_REJ_CMD_UNKNOWN);
 801b4cc:	687b      	ldr	r3, [r7, #4]
 801b4ce:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 801b4d0:	7dba      	ldrb	r2, [r7, #22]
 801b4d2:	2300      	movs	r3, #0
 801b4d4:	9300      	str	r3, [sp, #0]
 801b4d6:	2300      	movs	r3, #0
 801b4d8:	2101      	movs	r1, #1
 801b4da:	f7ff fc1d 	bl	801ad18 <l2cap_register_signaling_response>
                        break;
 801b4de:	e054      	b.n	801b58a <l2cap_signaling_handler_channel+0x212>
                    channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP);
 801b4e0:	2108      	movs	r1, #8
 801b4e2:	6878      	ldr	r0, [r7, #4]
 801b4e4:	f7fd fdb8 	bl	8019058 <channelStateVarSetFlag>
                    l2cap_signaling_handle_configure_request(channel, command);
 801b4e8:	6839      	ldr	r1, [r7, #0]
 801b4ea:	6878      	ldr	r0, [r7, #4]
 801b4ec:	f7ff fd00 	bl	801aef0 <l2cap_signaling_handle_configure_request>
                    if (!(channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_CONT)){
 801b4f0:	687b      	ldr	r3, [r7, #4]
 801b4f2:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801b4f4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801b4f8:	2b00      	cmp	r3, #0
 801b4fa:	d145      	bne.n	801b588 <l2cap_signaling_handler_channel+0x210>
                        channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_RCVD_CONF_REQ);
 801b4fc:	2101      	movs	r1, #1
 801b4fe:	6878      	ldr	r0, [r7, #4]
 801b500:	f7fd fdaa 	bl	8019058 <channelStateVarSetFlag>
                    break;
 801b504:	e040      	b.n	801b588 <l2cap_signaling_handler_channel+0x210>
                    if (cmd_len < 6){
 801b506:	8abb      	ldrh	r3, [r7, #20]
 801b508:	2b05      	cmp	r3, #5
 801b50a:	d809      	bhi.n	801b520 <l2cap_signaling_handler_channel+0x1a8>
                        l2cap_register_signaling_response(channel->con_handle, COMMAND_REJECT, identifier, 0, L2CAP_REJ_CMD_UNKNOWN);
 801b50c:	687b      	ldr	r3, [r7, #4]
 801b50e:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 801b510:	7dba      	ldrb	r2, [r7, #22]
 801b512:	2300      	movs	r3, #0
 801b514:	9300      	str	r3, [sp, #0]
 801b516:	2300      	movs	r3, #0
 801b518:	2101      	movs	r1, #1
 801b51a:	f7ff fbfd 	bl	801ad18 <l2cap_register_signaling_response>
                        break;
 801b51e:	e034      	b.n	801b58a <l2cap_signaling_handler_channel+0x212>
                    result = little_endian_read_16 (command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET+4);
 801b520:	2108      	movs	r1, #8
 801b522:	6838      	ldr	r0, [r7, #0]
 801b524:	f7f3 fc5f 	bl	800ede6 <little_endian_read_16>
 801b528:	4603      	mov	r3, r0
 801b52a:	827b      	strh	r3, [r7, #18]
                    l2cap_stop_rtx(channel);
 801b52c:	6878      	ldr	r0, [r7, #4]
 801b52e:	f7fd fc41 	bl	8018db4 <l2cap_stop_rtx>
                    l2cap_signaling_handle_configure_response(channel, result, command);
 801b532:	8a7b      	ldrh	r3, [r7, #18]
 801b534:	b2db      	uxtb	r3, r3
 801b536:	683a      	ldr	r2, [r7, #0]
 801b538:	4619      	mov	r1, r3
 801b53a:	6878      	ldr	r0, [r7, #4]
 801b53c:	f7ff fe72 	bl	801b224 <l2cap_signaling_handle_configure_response>
                    switch (result){
 801b540:	8a7b      	ldrh	r3, [r7, #18]
 801b542:	2b00      	cmp	r3, #0
 801b544:	d002      	beq.n	801b54c <l2cap_signaling_handler_channel+0x1d4>
 801b546:	2b04      	cmp	r3, #4
 801b548:	d005      	beq.n	801b556 <l2cap_signaling_handler_channel+0x1de>
 801b54a:	e008      	b.n	801b55e <l2cap_signaling_handler_channel+0x1e6>
                            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_RCVD_CONF_RSP);
 801b54c:	2102      	movs	r1, #2
 801b54e:	6878      	ldr	r0, [r7, #4]
 801b550:	f7fd fd82 	bl	8019058 <channelStateVarSetFlag>
                            break;
 801b554:	e017      	b.n	801b586 <l2cap_signaling_handler_channel+0x20e>
                            l2cap_start_ertx(channel);
 801b556:	6878      	ldr	r0, [r7, #4]
 801b558:	f7fd fc76 	bl	8018e48 <l2cap_start_ertx>
                            break;
 801b55c:	e013      	b.n	801b586 <l2cap_signaling_handler_channel+0x20e>
                            if (channel->mode == L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION && channel->ertm_mandatory){
 801b55e:	687b      	ldr	r3, [r7, #4]
 801b560:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 801b564:	2b03      	cmp	r3, #3
 801b566:	d109      	bne.n	801b57c <l2cap_signaling_handler_channel+0x204>
 801b568:	687b      	ldr	r3, [r7, #4]
 801b56a:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
 801b56e:	2b00      	cmp	r3, #0
 801b570:	d004      	beq.n	801b57c <l2cap_signaling_handler_channel+0x204>
                                channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST;
 801b572:	687b      	ldr	r3, [r7, #4]
 801b574:	2212      	movs	r2, #18
 801b576:	f883 2020 	strb.w	r2, [r3, #32]
                                break;
 801b57a:	e004      	b.n	801b586 <l2cap_signaling_handler_channel+0x20e>
                            channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_REQ);
 801b57c:	2104      	movs	r1, #4
 801b57e:	6878      	ldr	r0, [r7, #4]
 801b580:	f7fd fd6a 	bl	8019058 <channelStateVarSetFlag>
                            break;
 801b584:	bf00      	nop
                    break;
 801b586:	e000      	b.n	801b58a <l2cap_signaling_handler_channel+0x212>
                    break;
 801b588:	bf00      	nop
            }
            if (l2cap_channel_ready_for_open(channel)){
 801b58a:	6878      	ldr	r0, [r7, #4]
 801b58c:	f7ff fed2 	bl	801b334 <l2cap_channel_ready_for_open>
 801b590:	4603      	mov	r3, r0
 801b592:	2b00      	cmp	r3, #0
 801b594:	d04c      	beq.n	801b630 <l2cap_signaling_handler_channel+0x2b8>

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
                // assert that packet can be stored in fragment buffers in ertm
                if (channel->mode == L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION){
 801b596:	687b      	ldr	r3, [r7, #4]
 801b598:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 801b59c:	2b03      	cmp	r3, #3
 801b59e:	d133      	bne.n	801b608 <l2cap_signaling_handler_channel+0x290>
                    uint16_t effective_mps = btstack_min(channel->remote_mps, channel->local_mps);
 801b5a0:	687b      	ldr	r3, [r7, #4]
 801b5a2:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 801b5a6:	461a      	mov	r2, r3
 801b5a8:	687b      	ldr	r3, [r7, #4]
 801b5aa:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 801b5ae:	4619      	mov	r1, r3
 801b5b0:	4610      	mov	r0, r2
 801b5b2:	f7f3 fdac 	bl	800f10e <btstack_min>
 801b5b6:	4603      	mov	r3, r0
 801b5b8:	823b      	strh	r3, [r7, #16]
                    uint16_t usable_mtu = channel->num_tx_buffers == 1 ? effective_mps : channel->num_tx_buffers * effective_mps - 2;
 801b5ba:	687b      	ldr	r3, [r7, #4]
 801b5bc:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
 801b5c0:	2b01      	cmp	r3, #1
 801b5c2:	d00a      	beq.n	801b5da <l2cap_signaling_handler_channel+0x262>
 801b5c4:	687b      	ldr	r3, [r7, #4]
 801b5c6:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
 801b5ca:	b29b      	uxth	r3, r3
 801b5cc:	8a3a      	ldrh	r2, [r7, #16]
 801b5ce:	fb12 f303 	smulbb	r3, r2, r3
 801b5d2:	b29b      	uxth	r3, r3
 801b5d4:	3b02      	subs	r3, #2
 801b5d6:	b29b      	uxth	r3, r3
 801b5d8:	e000      	b.n	801b5dc <l2cap_signaling_handler_channel+0x264>
 801b5da:	8a3b      	ldrh	r3, [r7, #16]
 801b5dc:	81fb      	strh	r3, [r7, #14]
                    if (usable_mtu < channel->remote_mtu){
 801b5de:	687b      	ldr	r3, [r7, #4]
 801b5e0:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 801b5e2:	89fa      	ldrh	r2, [r7, #14]
 801b5e4:	429a      	cmp	r2, r3
 801b5e6:	d20f      	bcs.n	801b608 <l2cap_signaling_handler_channel+0x290>
                        log_info("Remote MTU %u > max storable ERTM packet, only using MTU = %u", channel->remote_mtu, usable_mtu);
 801b5e8:	687b      	ldr	r3, [r7, #4]
 801b5ea:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 801b5ec:	461a      	mov	r2, r3
 801b5ee:	89fb      	ldrh	r3, [r7, #14]
 801b5f0:	9301      	str	r3, [sp, #4]
 801b5f2:	9200      	str	r2, [sp, #0]
 801b5f4:	f640 3368 	movw	r3, #2920	; 0xb68
 801b5f8:	4a0f      	ldr	r2, [pc, #60]	; (801b638 <l2cap_signaling_handler_channel+0x2c0>)
 801b5fa:	4912      	ldr	r1, [pc, #72]	; (801b644 <l2cap_signaling_handler_channel+0x2cc>)
 801b5fc:	2001      	movs	r0, #1
 801b5fe:	f7fb ff1f 	bl	8017440 <hci_dump_log>
                        channel->remote_mtu = usable_mtu;
 801b602:	687b      	ldr	r3, [r7, #4]
 801b604:	89fa      	ldrh	r2, [r7, #14]
 801b606:	869a      	strh	r2, [r3, #52]	; 0x34
                    }
                }
#endif
                // for open:
                channel->state = L2CAP_STATE_OPEN;
 801b608:	687b      	ldr	r3, [r7, #4]
 801b60a:	220c      	movs	r2, #12
 801b60c:	f883 2020 	strb.w	r2, [r3, #32]
                l2cap_emit_channel_opened(channel, 0);
 801b610:	2100      	movs	r1, #0
 801b612:	6878      	ldr	r0, [r7, #4]
 801b614:	f7fd f98a 	bl	801892c <l2cap_emit_channel_opened>
            }
            break;
 801b618:	e00a      	b.n	801b630 <l2cap_signaling_handler_channel+0x2b8>
            
        case L2CAP_STATE_WAIT_DISCONNECT:
            switch (code) {
 801b61a:	7dfb      	ldrb	r3, [r7, #23]
 801b61c:	2b07      	cmp	r3, #7
 801b61e:	d000      	beq.n	801b622 <l2cap_signaling_handler_channel+0x2aa>
                case DISCONNECTION_RESPONSE:
                    l2cap_finialize_channel_close(channel);
                    break;
                default:
                    //@TODO: implement other signaling packets
                    break;
 801b620:	e003      	b.n	801b62a <l2cap_signaling_handler_channel+0x2b2>
                    l2cap_finialize_channel_close(channel);
 801b622:	6878      	ldr	r0, [r7, #4]
 801b624:	f001 fa4c 	bl	801cac0 <l2cap_finialize_channel_close>
                    break;
 801b628:	bf00      	nop
            }
            break;
 801b62a:	e002      	b.n	801b632 <l2cap_signaling_handler_channel+0x2ba>
            
        case L2CAP_STATE_OPEN:
            //@TODO: implement other signaling packets, e.g. re-configure
            break;
        default:
            break;
 801b62c:	bf00      	nop
 801b62e:	e000      	b.n	801b632 <l2cap_signaling_handler_channel+0x2ba>
            break;
 801b630:	bf00      	nop
    }
    // log_info("new state %u", channel->state);
}
 801b632:	3718      	adds	r7, #24
 801b634:	46bd      	mov	sp, r7
 801b636:	bd80      	pop	{r7, pc}
 801b638:	0802b1dc 	.word	0x0802b1dc
 801b63c:	0802c0cc 	.word	0x0802c0cc
 801b640:	20009eac 	.word	0x20009eac
 801b644:	0802c100 	.word	0x0802c100

0801b648 <l2cap_signaling_handler_dispatch>:


// @pre command len is valid, see check in l2cap_acl_classic_handler
static void l2cap_signaling_handler_dispatch(hci_con_handle_t handle, uint8_t * command){
 801b648:	b580      	push	{r7, lr}
 801b64a:	b08e      	sub	sp, #56	; 0x38
 801b64c:	af02      	add	r7, sp, #8
 801b64e:	4603      	mov	r3, r0
 801b650:	6039      	str	r1, [r7, #0]
 801b652:	80fb      	strh	r3, [r7, #6]
    
    btstack_linked_list_iterator_t it;    

    // get code, signalind identifier and command len
    uint8_t code     = command[L2CAP_SIGNALING_COMMAND_CODE_OFFSET];
 801b654:	683b      	ldr	r3, [r7, #0]
 801b656:	781b      	ldrb	r3, [r3, #0]
 801b658:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    uint8_t sig_id   = command[L2CAP_SIGNALING_COMMAND_SIGID_OFFSET];
 801b65c:	683b      	ldr	r3, [r7, #0]
 801b65e:	785b      	ldrb	r3, [r3, #1]
 801b660:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
    uint16_t cmd_len = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_LENGTH_OFFSET);
 801b664:	2102      	movs	r1, #2
 801b666:	6838      	ldr	r0, [r7, #0]
 801b668:	f7f3 fbbd 	bl	800ede6 <little_endian_read_16>
 801b66c:	4603      	mov	r3, r0
 801b66e:	85bb      	strh	r3, [r7, #44]	; 0x2c

    // not for a particular channel, and not CONNECTION_REQUEST, ECHO_[REQUEST|RESPONSE], INFORMATION_RESPONSE 
    if ((code < 1) || (code == ECHO_RESPONSE) || (code > INFORMATION_RESPONSE)){
 801b670:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801b674:	2b00      	cmp	r3, #0
 801b676:	d007      	beq.n	801b688 <l2cap_signaling_handler_dispatch+0x40>
 801b678:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801b67c:	2b09      	cmp	r3, #9
 801b67e:	d003      	beq.n	801b688 <l2cap_signaling_handler_dispatch+0x40>
 801b680:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801b684:	2b0b      	cmp	r3, #11
 801b686:	d909      	bls.n	801b69c <l2cap_signaling_handler_dispatch+0x54>
        l2cap_register_signaling_response(handle, COMMAND_REJECT, sig_id, 0, L2CAP_REJ_CMD_UNKNOWN);
 801b688:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 801b68c:	88f8      	ldrh	r0, [r7, #6]
 801b68e:	2300      	movs	r3, #0
 801b690:	9300      	str	r3, [sp, #0]
 801b692:	2300      	movs	r3, #0
 801b694:	2101      	movs	r1, #1
 801b696:	f7ff fb3f 	bl	801ad18 <l2cap_register_signaling_response>
        return;
 801b69a:	e157      	b.n	801b94c <l2cap_signaling_handler_dispatch+0x304>
    }

    // general commands without an assigned channel
    switch(code) {
 801b69c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801b6a0:	3b02      	subs	r3, #2
 801b6a2:	2b09      	cmp	r3, #9
 801b6a4:	f200 8107 	bhi.w	801b8b6 <l2cap_signaling_handler_dispatch+0x26e>
 801b6a8:	a201      	add	r2, pc, #4	; (adr r2, 801b6b0 <l2cap_signaling_handler_dispatch+0x68>)
 801b6aa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801b6ae:	bf00      	nop
 801b6b0:	0801b6d9 	.word	0x0801b6d9
 801b6b4:	0801b8b7 	.word	0x0801b8b7
 801b6b8:	0801b8b7 	.word	0x0801b8b7
 801b6bc:	0801b8b7 	.word	0x0801b8b7
 801b6c0:	0801b8b7 	.word	0x0801b8b7
 801b6c4:	0801b8b7 	.word	0x0801b8b7
 801b6c8:	0801b71b 	.word	0x0801b71b
 801b6cc:	0801b8b7 	.word	0x0801b8b7
 801b6d0:	0801b731 	.word	0x0801b731
 801b6d4:	0801b76d 	.word	0x0801b76d
            
        case CONNECTION_REQUEST:
            if (cmd_len == 4){
 801b6d8:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801b6da:	2b04      	cmp	r3, #4
 801b6dc:	d113      	bne.n	801b706 <l2cap_signaling_handler_dispatch+0xbe>
                uint16_t psm =        little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET);
 801b6de:	2104      	movs	r1, #4
 801b6e0:	6838      	ldr	r0, [r7, #0]
 801b6e2:	f7f3 fb80 	bl	800ede6 <little_endian_read_16>
 801b6e6:	4603      	mov	r3, r0
 801b6e8:	83bb      	strh	r3, [r7, #28]
                uint16_t source_cid = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET+2);
 801b6ea:	2106      	movs	r1, #6
 801b6ec:	6838      	ldr	r0, [r7, #0]
 801b6ee:	f7f3 fb7a 	bl	800ede6 <little_endian_read_16>
 801b6f2:	4603      	mov	r3, r0
 801b6f4:	837b      	strh	r3, [r7, #26]
                l2cap_handle_connection_request(handle, sig_id, psm, source_cid);
 801b6f6:	8b7b      	ldrh	r3, [r7, #26]
 801b6f8:	8bba      	ldrh	r2, [r7, #28]
 801b6fa:	f897 102e 	ldrb.w	r1, [r7, #46]	; 0x2e
 801b6fe:	88f8      	ldrh	r0, [r7, #6]
 801b700:	f7ff fb70 	bl	801ade4 <l2cap_handle_connection_request>
            } else {
                l2cap_register_signaling_response(handle, COMMAND_REJECT, sig_id, 0, L2CAP_REJ_CMD_UNKNOWN);
            }
            return;
 801b704:	e122      	b.n	801b94c <l2cap_signaling_handler_dispatch+0x304>
                l2cap_register_signaling_response(handle, COMMAND_REJECT, sig_id, 0, L2CAP_REJ_CMD_UNKNOWN);
 801b706:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 801b70a:	88f8      	ldrh	r0, [r7, #6]
 801b70c:	2300      	movs	r3, #0
 801b70e:	9300      	str	r3, [sp, #0]
 801b710:	2300      	movs	r3, #0
 801b712:	2101      	movs	r1, #1
 801b714:	f7ff fb00 	bl	801ad18 <l2cap_register_signaling_response>
            return;
 801b718:	e118      	b.n	801b94c <l2cap_signaling_handler_dispatch+0x304>
            
        case ECHO_REQUEST:
            l2cap_register_signaling_response(handle, code, sig_id, 0, 0);
 801b71a:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 801b71e:	f897 102f 	ldrb.w	r1, [r7, #47]	; 0x2f
 801b722:	88f8      	ldrh	r0, [r7, #6]
 801b724:	2300      	movs	r3, #0
 801b726:	9300      	str	r3, [sp, #0]
 801b728:	2300      	movs	r3, #0
 801b72a:	f7ff faf5 	bl	801ad18 <l2cap_register_signaling_response>
            return;
 801b72e:	e10d      	b.n	801b94c <l2cap_signaling_handler_dispatch+0x304>
            
        case INFORMATION_REQUEST:
            if (cmd_len == 2) {
 801b730:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801b732:	2b02      	cmp	r3, #2
 801b734:	d110      	bne.n	801b758 <l2cap_signaling_handler_dispatch+0x110>
                uint16_t info_type = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET);
 801b736:	2104      	movs	r1, #4
 801b738:	6838      	ldr	r0, [r7, #0]
 801b73a:	f7f3 fb54 	bl	800ede6 <little_endian_read_16>
 801b73e:	4603      	mov	r3, r0
 801b740:	83fb      	strh	r3, [r7, #30]
                l2cap_register_signaling_response(handle, code, sig_id, 0, info_type);
 801b742:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 801b746:	f897 102f 	ldrb.w	r1, [r7, #47]	; 0x2f
 801b74a:	88f8      	ldrh	r0, [r7, #6]
 801b74c:	8bfb      	ldrh	r3, [r7, #30]
 801b74e:	9300      	str	r3, [sp, #0]
 801b750:	2300      	movs	r3, #0
 801b752:	f7ff fae1 	bl	801ad18 <l2cap_register_signaling_response>
            } else {
                l2cap_register_signaling_response(handle, COMMAND_REJECT, sig_id, 0, L2CAP_REJ_CMD_UNKNOWN);
            }
            return;
 801b756:	e0f9      	b.n	801b94c <l2cap_signaling_handler_dispatch+0x304>
                l2cap_register_signaling_response(handle, COMMAND_REJECT, sig_id, 0, L2CAP_REJ_CMD_UNKNOWN);
 801b758:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 801b75c:	88f8      	ldrh	r0, [r7, #6]
 801b75e:	2300      	movs	r3, #0
 801b760:	9300      	str	r3, [sp, #0]
 801b762:	2300      	movs	r3, #0
 801b764:	2101      	movs	r1, #1
 801b766:	f7ff fad7 	bl	801ad18 <l2cap_register_signaling_response>
            return;
 801b76a:	e0ef      	b.n	801b94c <l2cap_signaling_handler_dispatch+0x304>

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
        case INFORMATION_RESPONSE: {
            hci_connection_t * connection = hci_connection_for_handle(handle);
 801b76c:	88fb      	ldrh	r3, [r7, #6]
 801b76e:	4618      	mov	r0, r3
 801b770:	f7f4 f8a8 	bl	800f8c4 <hci_connection_for_handle>
 801b774:	62b8      	str	r0, [r7, #40]	; 0x28
            if (!connection) return;
 801b776:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b778:	2b00      	cmp	r3, #0
 801b77a:	f000 80e4 	beq.w	801b946 <l2cap_signaling_handler_dispatch+0x2fe>
            if (connection->l2cap_state.information_state != L2CAP_INFORMATION_STATE_W4_EXTENDED_FEATURE_RESPONSE) return;
 801b77e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b780:	f893 3e24 	ldrb.w	r3, [r3, #3620]	; 0xe24
 801b784:	2b02      	cmp	r3, #2
 801b786:	f040 80e0 	bne.w	801b94a <l2cap_signaling_handler_dispatch+0x302>

            // get extended features from response if valid
            connection->l2cap_state.extended_feature_mask = 0;
 801b78a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b78c:	2200      	movs	r2, #0
 801b78e:	f8a3 2e26 	strh.w	r2, [r3, #3622]	; 0xe26
            if (cmd_len >= 6) {
 801b792:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801b794:	2b05      	cmp	r3, #5
 801b796:	d91a      	bls.n	801b7ce <l2cap_signaling_handler_dispatch+0x186>
                uint16_t info_type = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET);
 801b798:	2104      	movs	r1, #4
 801b79a:	6838      	ldr	r0, [r7, #0]
 801b79c:	f7f3 fb23 	bl	800ede6 <little_endian_read_16>
 801b7a0:	4603      	mov	r3, r0
 801b7a2:	84fb      	strh	r3, [r7, #38]	; 0x26
                uint16_t result    = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET+2);
 801b7a4:	2106      	movs	r1, #6
 801b7a6:	6838      	ldr	r0, [r7, #0]
 801b7a8:	f7f3 fb1d 	bl	800ede6 <little_endian_read_16>
 801b7ac:	4603      	mov	r3, r0
 801b7ae:	84bb      	strh	r3, [r7, #36]	; 0x24
                if (result == 0 && info_type == L2CAP_INFO_TYPE_EXTENDED_FEATURES_SUPPORTED) {
 801b7b0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801b7b2:	2b00      	cmp	r3, #0
 801b7b4:	d10b      	bne.n	801b7ce <l2cap_signaling_handler_dispatch+0x186>
 801b7b6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801b7b8:	2b02      	cmp	r3, #2
 801b7ba:	d108      	bne.n	801b7ce <l2cap_signaling_handler_dispatch+0x186>
                    connection->l2cap_state.extended_feature_mask = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET+4);
 801b7bc:	2108      	movs	r1, #8
 801b7be:	6838      	ldr	r0, [r7, #0]
 801b7c0:	f7f3 fb11 	bl	800ede6 <little_endian_read_16>
 801b7c4:	4603      	mov	r3, r0
 801b7c6:	461a      	mov	r2, r3
 801b7c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b7ca:	f8a3 2e26 	strh.w	r2, [r3, #3622]	; 0xe26
                }
            }
            connection->l2cap_state.information_state = L2CAP_INFORMATION_STATE_DONE; 
 801b7ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b7d0:	2203      	movs	r2, #3
 801b7d2:	f883 2e24 	strb.w	r2, [r3, #3620]	; 0xe24
            log_info("extended features mask 0x%02x", connection->l2cap_state.extended_feature_mask);
 801b7d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b7d8:	f8b3 3e26 	ldrh.w	r3, [r3, #3622]	; 0xe26
 801b7dc:	9300      	str	r3, [sp, #0]
 801b7de:	f640 33c6 	movw	r3, #3014	; 0xbc6
 801b7e2:	4a5c      	ldr	r2, [pc, #368]	; (801b954 <l2cap_signaling_handler_dispatch+0x30c>)
 801b7e4:	495c      	ldr	r1, [pc, #368]	; (801b958 <l2cap_signaling_handler_dispatch+0x310>)
 801b7e6:	2001      	movs	r0, #1
 801b7e8:	f7fb fe2a 	bl	8017440 <hci_dump_log>

            // trigger connection request
            btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801b7ec:	f107 0308 	add.w	r3, r7, #8
 801b7f0:	495a      	ldr	r1, [pc, #360]	; (801b95c <l2cap_signaling_handler_dispatch+0x314>)
 801b7f2:	4618      	mov	r0, r3
 801b7f4:	f7f2 ffab 	bl	800e74e <btstack_linked_list_iterator_init>
            while (btstack_linked_list_iterator_has_next(&it)){
 801b7f8:	e054      	b.n	801b8a4 <l2cap_signaling_handler_dispatch+0x25c>
                l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801b7fa:	f107 0308 	add.w	r3, r7, #8
 801b7fe:	4618      	mov	r0, r3
 801b800:	f7f2 ffe8 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801b804:	6238      	str	r0, [r7, #32]
                if (!l2cap_is_dynamic_channel_type(channel->channel_type)) continue;
 801b806:	6a3b      	ldr	r3, [r7, #32]
 801b808:	791b      	ldrb	r3, [r3, #4]
 801b80a:	4618      	mov	r0, r3
 801b80c:	f7fd fa63 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801b810:	4603      	mov	r3, r0
 801b812:	2b00      	cmp	r3, #0
 801b814:	d100      	bne.n	801b818 <l2cap_signaling_handler_dispatch+0x1d0>
 801b816:	e045      	b.n	801b8a4 <l2cap_signaling_handler_dispatch+0x25c>
                if (channel->con_handle != handle) continue;
 801b818:	6a3b      	ldr	r3, [r7, #32]
 801b81a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801b81c:	88fa      	ldrh	r2, [r7, #6]
 801b81e:	429a      	cmp	r2, r3
 801b820:	d000      	beq.n	801b824 <l2cap_signaling_handler_dispatch+0x1dc>
 801b822:	e03f      	b.n	801b8a4 <l2cap_signaling_handler_dispatch+0x25c>

                // incoming connection: ask user for channel configuration, esp. if ertm will be mandatory
                if (channel->state == L2CAP_STATE_WAIT_INCOMING_EXTENDED_FEATURES){
 801b824:	6a3b      	ldr	r3, [r7, #32]
 801b826:	f893 3020 	ldrb.w	r3, [r3, #32]
 801b82a:	2b07      	cmp	r3, #7
 801b82c:	d107      	bne.n	801b83e <l2cap_signaling_handler_dispatch+0x1f6>
                    channel->state = L2CAP_STATE_WAIT_CLIENT_ACCEPT_OR_REJECT;
 801b82e:	6a3b      	ldr	r3, [r7, #32]
 801b830:	2209      	movs	r2, #9
 801b832:	f883 2020 	strb.w	r2, [r3, #32]
                    l2cap_emit_incoming_connection(channel);
 801b836:	6a38      	ldr	r0, [r7, #32]
 801b838:	f7fd f94a 	bl	8018ad0 <l2cap_emit_incoming_connection>
                    continue;
 801b83c:	e032      	b.n	801b8a4 <l2cap_signaling_handler_dispatch+0x25c>
                }

                // outgoing connection
                if (channel->state == L2CAP_STATE_WAIT_OUTGOING_EXTENDED_FEATURES){
 801b83e:	6a3b      	ldr	r3, [r7, #32]
 801b840:	f893 3020 	ldrb.w	r3, [r3, #32]
 801b844:	2b08      	cmp	r3, #8
 801b846:	d12d      	bne.n	801b8a4 <l2cap_signaling_handler_dispatch+0x25c>

                    // if ERTM was requested, but is not listed in extended feature mask:
                    if ((channel->mode == L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION) && ((connection->l2cap_state.extended_feature_mask & 0x08) == 0)){
 801b848:	6a3b      	ldr	r3, [r7, #32]
 801b84a:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 801b84e:	2b03      	cmp	r3, #3
 801b850:	d123      	bne.n	801b89a <l2cap_signaling_handler_dispatch+0x252>
 801b852:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b854:	f8b3 3e26 	ldrh.w	r3, [r3, #3622]	; 0xe26
 801b858:	f003 0308 	and.w	r3, r3, #8
 801b85c:	2b00      	cmp	r3, #0
 801b85e:	d11c      	bne.n	801b89a <l2cap_signaling_handler_dispatch+0x252>

                        if (channel->ertm_mandatory){
 801b860:	6a3b      	ldr	r3, [r7, #32]
 801b862:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
 801b866:	2b00      	cmp	r3, #0
 801b868:	d00f      	beq.n	801b88a <l2cap_signaling_handler_dispatch+0x242>
                            // bail if ERTM is mandatory
                            channel->state = L2CAP_STATE_CLOSED;
 801b86a:	6a3b      	ldr	r3, [r7, #32]
 801b86c:	2201      	movs	r2, #1
 801b86e:	f883 2020 	strb.w	r2, [r3, #32]
                            // map l2cap connection response result to BTstack status enumeration
                            l2cap_handle_channel_open_failed(channel, L2CAP_CONNECTION_RESPONSE_RESULT_ERTM_NOT_SUPPORTED);
 801b872:	2168      	movs	r1, #104	; 0x68
 801b874:	6a38      	ldr	r0, [r7, #32]
 801b876:	f7fd f991 	bl	8018b9c <l2cap_handle_channel_open_failed>
                            // discard channel
                            btstack_linked_list_remove(&l2cap_channels, (btstack_linked_item_t *) channel);
 801b87a:	6a39      	ldr	r1, [r7, #32]
 801b87c:	4837      	ldr	r0, [pc, #220]	; (801b95c <l2cap_signaling_handler_dispatch+0x314>)
 801b87e:	f7f2 ff1e 	bl	800e6be <btstack_linked_list_remove>
                            l2cap_free_channel_entry(channel);
 801b882:	6a38      	ldr	r0, [r7, #32]
 801b884:	f7fe fd34 	bl	801a2f0 <l2cap_free_channel_entry>
                            continue;
 801b888:	e00c      	b.n	801b8a4 <l2cap_signaling_handler_dispatch+0x25c>

                        } else {
                            // fallback to Basic mode
                            l2cap_emit_simple_event_with_cid(channel, L2CAP_EVENT_ERTM_BUFFER_RELEASED);
 801b88a:	217e      	movs	r1, #126	; 0x7e
 801b88c:	6a38      	ldr	r0, [r7, #32]
 801b88e:	f7fd f828 	bl	80188e2 <l2cap_emit_simple_event_with_cid>
                            channel->mode = L2CAP_CHANNEL_MODE_BASIC;
 801b892:	6a3b      	ldr	r3, [r7, #32]
 801b894:	2200      	movs	r2, #0
 801b896:	f883 2056 	strb.w	r2, [r3, #86]	; 0x56
                        }
                    }

                    // respond to connection request
                    channel->state = L2CAP_STATE_WILL_SEND_CONNECTION_REQUEST;
 801b89a:	6a3b      	ldr	r3, [r7, #32]
 801b89c:	220e      	movs	r2, #14
 801b89e:	f883 2020 	strb.w	r2, [r3, #32]
                    continue;
 801b8a2:	bf00      	nop
            while (btstack_linked_list_iterator_has_next(&it)){
 801b8a4:	f107 0308 	add.w	r3, r7, #8
 801b8a8:	4618      	mov	r0, r3
 801b8aa:	f7f2 ff65 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801b8ae:	4603      	mov	r3, r0
 801b8b0:	2b00      	cmp	r3, #0
 801b8b2:	d1a2      	bne.n	801b7fa <l2cap_signaling_handler_dispatch+0x1b2>
                }
            }
            return;
 801b8b4:	e04a      	b.n	801b94c <l2cap_signaling_handler_dispatch+0x304>
        }
#endif

        default:
            break;
 801b8b6:	bf00      	nop
    }
    
    // Get potential destination CID
    uint16_t dest_cid = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET);
 801b8b8:	2104      	movs	r1, #4
 801b8ba:	6838      	ldr	r0, [r7, #0]
 801b8bc:	f7f3 fa93 	bl	800ede6 <little_endian_read_16>
 801b8c0:	4603      	mov	r3, r0
 801b8c2:	833b      	strh	r3, [r7, #24]
    
    // Find channel for this sig_id and connection handle
    btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801b8c4:	f107 0308 	add.w	r3, r7, #8
 801b8c8:	4924      	ldr	r1, [pc, #144]	; (801b95c <l2cap_signaling_handler_dispatch+0x314>)
 801b8ca:	4618      	mov	r0, r3
 801b8cc:	f7f2 ff3f 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 801b8d0:	e030      	b.n	801b934 <l2cap_signaling_handler_dispatch+0x2ec>
        l2cap_channel_t * channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801b8d2:	f107 0308 	add.w	r3, r7, #8
 801b8d6:	4618      	mov	r0, r3
 801b8d8:	f7f2 ff7c 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801b8dc:	6178      	str	r0, [r7, #20]
        if (!l2cap_is_dynamic_channel_type(channel->channel_type)) continue;
 801b8de:	697b      	ldr	r3, [r7, #20]
 801b8e0:	791b      	ldrb	r3, [r3, #4]
 801b8e2:	4618      	mov	r0, r3
 801b8e4:	f7fd f9f7 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801b8e8:	4603      	mov	r3, r0
 801b8ea:	2b00      	cmp	r3, #0
 801b8ec:	d100      	bne.n	801b8f0 <l2cap_signaling_handler_dispatch+0x2a8>
 801b8ee:	e021      	b.n	801b934 <l2cap_signaling_handler_dispatch+0x2ec>
        if (channel->con_handle != handle) continue;
 801b8f0:	697b      	ldr	r3, [r7, #20]
 801b8f2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801b8f4:	88fa      	ldrh	r2, [r7, #6]
 801b8f6:	429a      	cmp	r2, r3
 801b8f8:	d000      	beq.n	801b8fc <l2cap_signaling_handler_dispatch+0x2b4>
 801b8fa:	e01b      	b.n	801b934 <l2cap_signaling_handler_dispatch+0x2ec>
        if (code & 1) {
 801b8fc:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801b900:	f003 0301 	and.w	r3, r3, #1
 801b904:	2b00      	cmp	r3, #0
 801b906:	d00b      	beq.n	801b920 <l2cap_signaling_handler_dispatch+0x2d8>
            // match odd commands (responses) by previous signaling identifier 
            if (channel->local_sig_id == sig_id) {
 801b908:	697b      	ldr	r3, [r7, #20]
 801b90a:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 801b90e:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 801b912:	429a      	cmp	r2, r3
 801b914:	d10e      	bne.n	801b934 <l2cap_signaling_handler_dispatch+0x2ec>
                l2cap_signaling_handler_channel(channel, command);
 801b916:	6839      	ldr	r1, [r7, #0]
 801b918:	6978      	ldr	r0, [r7, #20]
 801b91a:	f7ff fd2d 	bl	801b378 <l2cap_signaling_handler_channel>
                break;
 801b91e:	e015      	b.n	801b94c <l2cap_signaling_handler_dispatch+0x304>
            }
        } else {
            // match even commands (requests) by local channel id
            if (channel->local_cid == dest_cid) {
 801b920:	697b      	ldr	r3, [r7, #20]
 801b922:	88db      	ldrh	r3, [r3, #6]
 801b924:	8b3a      	ldrh	r2, [r7, #24]
 801b926:	429a      	cmp	r2, r3
 801b928:	d104      	bne.n	801b934 <l2cap_signaling_handler_dispatch+0x2ec>
                l2cap_signaling_handler_channel(channel, command);
 801b92a:	6839      	ldr	r1, [r7, #0]
 801b92c:	6978      	ldr	r0, [r7, #20]
 801b92e:	f7ff fd23 	bl	801b378 <l2cap_signaling_handler_channel>
                break;
 801b932:	e00b      	b.n	801b94c <l2cap_signaling_handler_dispatch+0x304>
    while (btstack_linked_list_iterator_has_next(&it)){
 801b934:	f107 0308 	add.w	r3, r7, #8
 801b938:	4618      	mov	r0, r3
 801b93a:	f7f2 ff1d 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801b93e:	4603      	mov	r3, r0
 801b940:	2b00      	cmp	r3, #0
 801b942:	d1c6      	bne.n	801b8d2 <l2cap_signaling_handler_dispatch+0x28a>
 801b944:	e002      	b.n	801b94c <l2cap_signaling_handler_dispatch+0x304>
            if (!connection) return;
 801b946:	bf00      	nop
 801b948:	e000      	b.n	801b94c <l2cap_signaling_handler_dispatch+0x304>
            if (connection->l2cap_state.information_state != L2CAP_INFORMATION_STATE_W4_EXTENDED_FEATURE_RESPONSE) return;
 801b94a:	bf00      	nop
            }
        }
    }
}
 801b94c:	3730      	adds	r7, #48	; 0x30
 801b94e:	46bd      	mov	sp, r7
 801b950:	bd80      	pop	{r7, pc}
 801b952:	bf00      	nop
 801b954:	0802b1dc 	.word	0x0802b1dc
 801b958:	0802c148 	.word	0x0802c148
 801b95c:	20009eac 	.word	0x20009eac

0801b960 <l2cap_emit_connection_parameter_update_response>:
#endif

#ifdef ENABLE_BLE

static void l2cap_emit_connection_parameter_update_response(hci_con_handle_t con_handle, uint16_t result){
 801b960:	b590      	push	{r4, r7, lr}
 801b962:	b085      	sub	sp, #20
 801b964:	af00      	add	r7, sp, #0
 801b966:	4603      	mov	r3, r0
 801b968:	460a      	mov	r2, r1
 801b96a:	80fb      	strh	r3, [r7, #6]
 801b96c:	4613      	mov	r3, r2
 801b96e:	80bb      	strh	r3, [r7, #4]
    uint8_t event[6];
    event[0] = L2CAP_EVENT_CONNECTION_PARAMETER_UPDATE_RESPONSE;
 801b970:	2377      	movs	r3, #119	; 0x77
 801b972:	723b      	strb	r3, [r7, #8]
    event[1] = 4;
 801b974:	2304      	movs	r3, #4
 801b976:	727b      	strb	r3, [r7, #9]
    little_endian_store_16(event, 2, con_handle);
 801b978:	88fa      	ldrh	r2, [r7, #6]
 801b97a:	f107 0308 	add.w	r3, r7, #8
 801b97e:	2102      	movs	r1, #2
 801b980:	4618      	mov	r0, r3
 801b982:	f7f3 fa70 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 4, result);
 801b986:	88ba      	ldrh	r2, [r7, #4]
 801b988:	f107 0308 	add.w	r3, r7, #8
 801b98c:	2104      	movs	r1, #4
 801b98e:	4618      	mov	r0, r3
 801b990:	f7f3 fa69 	bl	800ee66 <little_endian_store_16>
    hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
 801b994:	f107 0208 	add.w	r2, r7, #8
 801b998:	2306      	movs	r3, #6
 801b99a:	2100      	movs	r1, #0
 801b99c:	2004      	movs	r0, #4
 801b99e:	f7fb fca9 	bl	80172f4 <hci_dump_packet>
    if (!l2cap_event_packet_handler) return;
 801b9a2:	4b08      	ldr	r3, [pc, #32]	; (801b9c4 <l2cap_emit_connection_parameter_update_response+0x64>)
 801b9a4:	681b      	ldr	r3, [r3, #0]
 801b9a6:	2b00      	cmp	r3, #0
 801b9a8:	d008      	beq.n	801b9bc <l2cap_emit_connection_parameter_update_response+0x5c>
    (*l2cap_event_packet_handler)(HCI_EVENT_PACKET, 0, event, sizeof(event));
 801b9aa:	4b06      	ldr	r3, [pc, #24]	; (801b9c4 <l2cap_emit_connection_parameter_update_response+0x64>)
 801b9ac:	681c      	ldr	r4, [r3, #0]
 801b9ae:	f107 0208 	add.w	r2, r7, #8
 801b9b2:	2306      	movs	r3, #6
 801b9b4:	2100      	movs	r1, #0
 801b9b6:	2004      	movs	r0, #4
 801b9b8:	47a0      	blx	r4
 801b9ba:	e000      	b.n	801b9be <l2cap_emit_connection_parameter_update_response+0x5e>
    if (!l2cap_event_packet_handler) return;
 801b9bc:	bf00      	nop
}
 801b9be:	3714      	adds	r7, #20
 801b9c0:	46bd      	mov	sp, r7
 801b9c2:	bd90      	pop	{r4, r7, pc}
 801b9c4:	20009ed8 	.word	0x20009ed8

0801b9c8 <l2cap_le_signaling_handler_dispatch>:

// @returns valid
static int l2cap_le_signaling_handler_dispatch(hci_con_handle_t handle, uint8_t * command, uint8_t sig_id){
 801b9c8:	b590      	push	{r4, r7, lr}
 801b9ca:	b09f      	sub	sp, #124	; 0x7c
 801b9cc:	af04      	add	r7, sp, #16
 801b9ce:	4603      	mov	r3, r0
 801b9d0:	6039      	str	r1, [r7, #0]
 801b9d2:	80fb      	strh	r3, [r7, #6]
 801b9d4:	4613      	mov	r3, r2
 801b9d6:	717b      	strb	r3, [r7, #5]
    uint16_t credits_before;
    l2cap_service_t * service;
    uint16_t source_cid;
#endif

    uint8_t code   = command[L2CAP_SIGNALING_COMMAND_CODE_OFFSET];
 801b9d8:	683b      	ldr	r3, [r7, #0]
 801b9da:	781b      	ldrb	r3, [r3, #0]
 801b9dc:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
    uint16_t len   = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_LENGTH_OFFSET);
 801b9e0:	2102      	movs	r1, #2
 801b9e2:	6838      	ldr	r0, [r7, #0]
 801b9e4:	f7f3 f9ff 	bl	800ede6 <little_endian_read_16>
 801b9e8:	4603      	mov	r3, r0
 801b9ea:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    log_info("l2cap_le_signaling_handler_dispatch: command 0x%02x, sig id %u, len %u", code, sig_id, len);
 801b9ee:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 801b9f2:	797a      	ldrb	r2, [r7, #5]
 801b9f4:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 801b9f8:	9102      	str	r1, [sp, #8]
 801b9fa:	9201      	str	r2, [sp, #4]
 801b9fc:	9300      	str	r3, [sp, #0]
 801b9fe:	f640 4334 	movw	r3, #3124	; 0xc34
 801ba02:	4abe      	ldr	r2, [pc, #760]	; (801bcfc <l2cap_le_signaling_handler_dispatch+0x334>)
 801ba04:	49be      	ldr	r1, [pc, #760]	; (801bd00 <l2cap_le_signaling_handler_dispatch+0x338>)
 801ba06:	2001      	movs	r0, #1
 801ba08:	f7fb fd1a 	bl	8017440 <hci_dump_log>

    switch (code){
 801ba0c:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 801ba10:	3b01      	subs	r3, #1
 801ba12:	2b15      	cmp	r3, #21
 801ba14:	f200 8360 	bhi.w	801c0d8 <l2cap_le_signaling_handler_dispatch+0x710>
 801ba18:	a201      	add	r2, pc, #4	; (adr r2, 801ba20 <l2cap_le_signaling_handler_dispatch+0x58>)
 801ba1a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801ba1e:	bf00      	nop
 801ba20:	0801bbb1 	.word	0x0801bbb1
 801ba24:	0801c0d9 	.word	0x0801c0d9
 801ba28:	0801c0d9 	.word	0x0801c0d9
 801ba2c:	0801c0d9 	.word	0x0801c0d9
 801ba30:	0801c0d9 	.word	0x0801c0d9
 801ba34:	0801c081 	.word	0x0801c081
 801ba38:	0801c0dd 	.word	0x0801c0dd
 801ba3c:	0801c0d9 	.word	0x0801c0d9
 801ba40:	0801c0d9 	.word	0x0801c0d9
 801ba44:	0801c0d9 	.word	0x0801c0d9
 801ba48:	0801c0d9 	.word	0x0801c0d9
 801ba4c:	0801c0d9 	.word	0x0801c0d9
 801ba50:	0801c0d9 	.word	0x0801c0d9
 801ba54:	0801c0d9 	.word	0x0801c0d9
 801ba58:	0801c0d9 	.word	0x0801c0d9
 801ba5c:	0801c0d9 	.word	0x0801c0d9
 801ba60:	0801c0d9 	.word	0x0801c0d9
 801ba64:	0801ba79 	.word	0x0801ba79
 801ba68:	0801bb87 	.word	0x0801bb87
 801ba6c:	0801bc45 	.word	0x0801bc45
 801ba70:	0801beb3 	.word	0x0801beb3
 801ba74:	0801bfbf 	.word	0x0801bfbf

        case CONNECTION_PARAMETER_UPDATE_REQUEST:
            // check size
            if (len < 8u) return 0u;
 801ba78:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 801ba7c:	2b07      	cmp	r3, #7
 801ba7e:	d801      	bhi.n	801ba84 <l2cap_le_signaling_handler_dispatch+0xbc>
 801ba80:	2300      	movs	r3, #0
 801ba82:	e335      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>
            connection = hci_connection_for_handle(handle);
 801ba84:	88fb      	ldrh	r3, [r7, #6]
 801ba86:	4618      	mov	r0, r3
 801ba88:	f7f3 ff1c 	bl	800f8c4 <hci_connection_for_handle>
 801ba8c:	64f8      	str	r0, [r7, #76]	; 0x4c
            if (connection != NULL){
 801ba8e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ba90:	2b00      	cmp	r3, #0
 801ba92:	d04d      	beq.n	801bb30 <l2cap_le_signaling_handler_dispatch+0x168>
                if (connection->role != HCI_ROLE_MASTER){
 801ba94:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ba96:	7b5b      	ldrb	r3, [r3, #13]
 801ba98:	2b00      	cmp	r3, #0
 801ba9a:	d001      	beq.n	801baa0 <l2cap_le_signaling_handler_dispatch+0xd8>
                    // reject command without notifying upper layer when not in master role
                    return 0;
 801ba9c:	2300      	movs	r3, #0
 801ba9e:	e327      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>
                }
                le_connection_parameter_range_t existing_range;
                gap_get_connection_parameter_range(&existing_range);
 801baa0:	f107 0308 	add.w	r3, r7, #8
 801baa4:	4618      	mov	r0, r3
 801baa6:	f7f3 fea7 	bl	800f7f8 <gap_get_connection_parameter_range>

                uint16_t le_conn_interval_min   = little_endian_read_16(command,L2CAP_SIGNALING_COMMAND_DATA_OFFSET);
 801baaa:	2104      	movs	r1, #4
 801baac:	6838      	ldr	r0, [r7, #0]
 801baae:	f7f3 f99a 	bl	800ede6 <little_endian_read_16>
 801bab2:	4603      	mov	r3, r0
 801bab4:	877b      	strh	r3, [r7, #58]	; 0x3a
                uint16_t le_conn_interval_max   = little_endian_read_16(command,L2CAP_SIGNALING_COMMAND_DATA_OFFSET+2);
 801bab6:	2106      	movs	r1, #6
 801bab8:	6838      	ldr	r0, [r7, #0]
 801baba:	f7f3 f994 	bl	800ede6 <little_endian_read_16>
 801babe:	4603      	mov	r3, r0
 801bac0:	873b      	strh	r3, [r7, #56]	; 0x38
                uint16_t le_conn_latency        = little_endian_read_16(command,L2CAP_SIGNALING_COMMAND_DATA_OFFSET+4);
 801bac2:	2108      	movs	r1, #8
 801bac4:	6838      	ldr	r0, [r7, #0]
 801bac6:	f7f3 f98e 	bl	800ede6 <little_endian_read_16>
 801baca:	4603      	mov	r3, r0
 801bacc:	86fb      	strh	r3, [r7, #54]	; 0x36
                uint16_t le_supervision_timeout = little_endian_read_16(command,L2CAP_SIGNALING_COMMAND_DATA_OFFSET+6);
 801bace:	210a      	movs	r1, #10
 801bad0:	6838      	ldr	r0, [r7, #0]
 801bad2:	f7f3 f988 	bl	800ede6 <little_endian_read_16>
 801bad6:	4603      	mov	r3, r0
 801bad8:	86bb      	strh	r3, [r7, #52]	; 0x34

                int update_parameter = gap_connection_parameter_range_included(&existing_range, le_conn_interval_min, le_conn_interval_max, le_conn_latency, le_supervision_timeout);
 801bada:	8efc      	ldrh	r4, [r7, #54]	; 0x36
 801badc:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801bade:	8f79      	ldrh	r1, [r7, #58]	; 0x3a
 801bae0:	f107 0008 	add.w	r0, r7, #8
 801bae4:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 801bae6:	9300      	str	r3, [sp, #0]
 801bae8:	4623      	mov	r3, r4
 801baea:	f7f3 fe9b 	bl	800f824 <gap_connection_parameter_range_included>
 801baee:	6338      	str	r0, [r7, #48]	; 0x30
                if (update_parameter){
 801baf0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801baf2:	2b00      	cmp	r3, #0
 801baf4:	d014      	beq.n	801bb20 <l2cap_le_signaling_handler_dispatch+0x158>
                    connection->le_con_parameter_update_state = CON_PARAMETER_UPDATE_SEND_RESPONSE;
 801baf6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801baf8:	2202      	movs	r2, #2
 801bafa:	f883 270b 	strb.w	r2, [r3, #1803]	; 0x70b
                    connection->le_conn_interval_min = le_conn_interval_min;
 801bafe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb00:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 801bb02:	f8a3 270e 	strh.w	r2, [r3, #1806]	; 0x70e
                    connection->le_conn_interval_max = le_conn_interval_max;
 801bb06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb08:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801bb0a:	f8a3 2710 	strh.w	r2, [r3, #1808]	; 0x710
                    connection->le_conn_latency = le_conn_latency;
 801bb0e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb10:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801bb12:	f8a3 2712 	strh.w	r2, [r3, #1810]	; 0x712
                    connection->le_supervision_timeout = le_supervision_timeout;
 801bb16:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb18:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801bb1a:	f8a3 2714 	strh.w	r2, [r3, #1812]	; 0x714
 801bb1e:	e003      	b.n	801bb28 <l2cap_le_signaling_handler_dispatch+0x160>
                } else {
                    connection->le_con_parameter_update_state = CON_PARAMETER_UPDATE_DENY;
 801bb20:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb22:	2204      	movs	r2, #4
 801bb24:	f883 270b 	strb.w	r2, [r3, #1803]	; 0x70b
                }
                connection->le_con_param_update_identifier = sig_id;
 801bb28:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb2a:	797a      	ldrb	r2, [r7, #5]
 801bb2c:	f883 270c 	strb.w	r2, [r3, #1804]	; 0x70c
            }

            if (!l2cap_event_packet_handler) break;
 801bb30:	4b74      	ldr	r3, [pc, #464]	; (801bd04 <l2cap_le_signaling_handler_dispatch+0x33c>)
 801bb32:	681b      	ldr	r3, [r3, #0]
 801bb34:	2b00      	cmp	r3, #0
 801bb36:	f000 82d3 	beq.w	801c0e0 <l2cap_le_signaling_handler_dispatch+0x718>

            event[0] = L2CAP_EVENT_CONNECTION_PARAMETER_UPDATE_REQUEST;
 801bb3a:	2376      	movs	r3, #118	; 0x76
 801bb3c:	f887 3020 	strb.w	r3, [r7, #32]
            event[1] = 8;
 801bb40:	2308      	movs	r3, #8
 801bb42:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
            little_endian_store_16(event, 2, handle);
 801bb46:	88fa      	ldrh	r2, [r7, #6]
 801bb48:	f107 0320 	add.w	r3, r7, #32
 801bb4c:	2102      	movs	r1, #2
 801bb4e:	4618      	mov	r0, r3
 801bb50:	f7f3 f989 	bl	800ee66 <little_endian_store_16>
            (void)memcpy(&event[4], &command[4], 8);
 801bb54:	683b      	ldr	r3, [r7, #0]
 801bb56:	1d19      	adds	r1, r3, #4
 801bb58:	f107 0320 	add.w	r3, r7, #32
 801bb5c:	3304      	adds	r3, #4
 801bb5e:	2208      	movs	r2, #8
 801bb60:	4618      	mov	r0, r3
 801bb62:	f00b ff8a 	bl	8027a7a <memcpy>
            hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
 801bb66:	f107 0220 	add.w	r2, r7, #32
 801bb6a:	230c      	movs	r3, #12
 801bb6c:	2100      	movs	r1, #0
 801bb6e:	2004      	movs	r0, #4
 801bb70:	f7fb fbc0 	bl	80172f4 <hci_dump_packet>
            (*l2cap_event_packet_handler)( HCI_EVENT_PACKET, 0, event, sizeof(event));
 801bb74:	4b63      	ldr	r3, [pc, #396]	; (801bd04 <l2cap_le_signaling_handler_dispatch+0x33c>)
 801bb76:	681c      	ldr	r4, [r3, #0]
 801bb78:	f107 0220 	add.w	r2, r7, #32
 801bb7c:	230c      	movs	r3, #12
 801bb7e:	2100      	movs	r1, #0
 801bb80:	2004      	movs	r0, #4
 801bb82:	47a0      	blx	r4
            break;
 801bb84:	e2b3      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>

        case CONNECTION_PARAMETER_UPDATE_RESPONSE:
            // check size
            if (len < 2u) return 0u;
 801bb86:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 801bb8a:	2b01      	cmp	r3, #1
 801bb8c:	d801      	bhi.n	801bb92 <l2cap_le_signaling_handler_dispatch+0x1ca>
 801bb8e:	2300      	movs	r3, #0
 801bb90:	e2ae      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>
            result = little_endian_read_16(command, 4);
 801bb92:	2104      	movs	r1, #4
 801bb94:	6838      	ldr	r0, [r7, #0]
 801bb96:	f7f3 f926 	bl	800ede6 <little_endian_read_16>
 801bb9a:	4603      	mov	r3, r0
 801bb9c:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            l2cap_emit_connection_parameter_update_response(handle, result);
 801bba0:	f8b7 2052 	ldrh.w	r2, [r7, #82]	; 0x52
 801bba4:	88fb      	ldrh	r3, [r7, #6]
 801bba6:	4611      	mov	r1, r2
 801bba8:	4618      	mov	r0, r3
 801bbaa:	f7ff fed9 	bl	801b960 <l2cap_emit_connection_parameter_update_response>
            break;
 801bbae:	e29e      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>

#ifdef ENABLE_LE_DATA_CHANNELS

        case COMMAND_REJECT:
            // Find channel for this sig_id and connection handle
            channel = NULL;
 801bbb0:	2300      	movs	r3, #0
 801bbb2:	667b      	str	r3, [r7, #100]	; 0x64
            btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801bbb4:	f107 0314 	add.w	r3, r7, #20
 801bbb8:	4953      	ldr	r1, [pc, #332]	; (801bd08 <l2cap_le_signaling_handler_dispatch+0x340>)
 801bbba:	4618      	mov	r0, r3
 801bbbc:	f7f2 fdc7 	bl	800e74e <btstack_linked_list_iterator_init>
            while (btstack_linked_list_iterator_has_next(&it)){
 801bbc0:	e01e      	b.n	801bc00 <l2cap_le_signaling_handler_dispatch+0x238>
                l2cap_channel_t * a_channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801bbc2:	f107 0314 	add.w	r3, r7, #20
 801bbc6:	4618      	mov	r0, r3
 801bbc8:	f7f2 fe04 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801bbcc:	62f8      	str	r0, [r7, #44]	; 0x2c
                if (!l2cap_is_dynamic_channel_type(a_channel->channel_type)) continue;
 801bbce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801bbd0:	791b      	ldrb	r3, [r3, #4]
 801bbd2:	4618      	mov	r0, r3
 801bbd4:	f7fd f87f 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801bbd8:	4603      	mov	r3, r0
 801bbda:	2b00      	cmp	r3, #0
 801bbdc:	d100      	bne.n	801bbe0 <l2cap_le_signaling_handler_dispatch+0x218>
 801bbde:	e00f      	b.n	801bc00 <l2cap_le_signaling_handler_dispatch+0x238>
                if (a_channel->con_handle   != handle) continue;
 801bbe0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801bbe2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801bbe4:	88fa      	ldrh	r2, [r7, #6]
 801bbe6:	429a      	cmp	r2, r3
 801bbe8:	d000      	beq.n	801bbec <l2cap_le_signaling_handler_dispatch+0x224>
 801bbea:	e009      	b.n	801bc00 <l2cap_le_signaling_handler_dispatch+0x238>
                if (a_channel->local_sig_id != sig_id) continue;
 801bbec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801bbee:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 801bbf2:	797a      	ldrb	r2, [r7, #5]
 801bbf4:	429a      	cmp	r2, r3
 801bbf6:	d000      	beq.n	801bbfa <l2cap_le_signaling_handler_dispatch+0x232>
 801bbf8:	e002      	b.n	801bc00 <l2cap_le_signaling_handler_dispatch+0x238>
                channel = a_channel;
 801bbfa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801bbfc:	667b      	str	r3, [r7, #100]	; 0x64
                break; 
 801bbfe:	e007      	b.n	801bc10 <l2cap_le_signaling_handler_dispatch+0x248>
            while (btstack_linked_list_iterator_has_next(&it)){
 801bc00:	f107 0314 	add.w	r3, r7, #20
 801bc04:	4618      	mov	r0, r3
 801bc06:	f7f2 fdb7 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801bc0a:	4603      	mov	r3, r0
 801bc0c:	2b00      	cmp	r3, #0
 801bc0e:	d1d8      	bne.n	801bbc2 <l2cap_le_signaling_handler_dispatch+0x1fa>
            }
            if (!channel) break;
 801bc10:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801bc12:	2b00      	cmp	r3, #0
 801bc14:	f000 8266 	beq.w	801c0e4 <l2cap_le_signaling_handler_dispatch+0x71c>

            // if received while waiting for le connection response, assume legacy device
            if (channel->state == L2CAP_STATE_WAIT_LE_CONNECTION_RESPONSE){
 801bc18:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801bc1a:	f893 3020 	ldrb.w	r3, [r3, #32]
 801bc1e:	2b17      	cmp	r3, #23
 801bc20:	f040 8262 	bne.w	801c0e8 <l2cap_le_signaling_handler_dispatch+0x720>
                channel->state = L2CAP_STATE_CLOSED;
 801bc24:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801bc26:	2201      	movs	r2, #1
 801bc28:	f883 2020 	strb.w	r2, [r3, #32]
                // no official value for this, use: Connection refused – LE_PSM not supported - 0x0002
                l2cap_emit_le_channel_opened(channel, 0x0002);
 801bc2c:	2102      	movs	r1, #2
 801bc2e:	6e78      	ldr	r0, [r7, #100]	; 0x64
 801bc30:	f001 f82c 	bl	801cc8c <l2cap_emit_le_channel_opened>
                                
                // discard channel
                btstack_linked_list_remove(&l2cap_channels, (btstack_linked_item_t *) channel);
 801bc34:	6e79      	ldr	r1, [r7, #100]	; 0x64
 801bc36:	4834      	ldr	r0, [pc, #208]	; (801bd08 <l2cap_le_signaling_handler_dispatch+0x340>)
 801bc38:	f7f2 fd41 	bl	800e6be <btstack_linked_list_remove>
                l2cap_free_channel_entry(channel);
 801bc3c:	6e78      	ldr	r0, [r7, #100]	; 0x64
 801bc3e:	f7fe fb57 	bl	801a2f0 <l2cap_free_channel_entry>
                break;
 801bc42:	e254      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>
            }
            break;

        case LE_CREDIT_BASED_CONNECTION_REQUEST:
            // check size
            if (len < 10u) return 0u;
 801bc44:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 801bc48:	2b09      	cmp	r3, #9
 801bc4a:	d801      	bhi.n	801bc50 <l2cap_le_signaling_handler_dispatch+0x288>
 801bc4c:	2300      	movs	r3, #0
 801bc4e:	e24f      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>

            // get hci connection, bail if not found (must not happen)
            connection = hci_connection_for_handle(handle);
 801bc50:	88fb      	ldrh	r3, [r7, #6]
 801bc52:	4618      	mov	r0, r3
 801bc54:	f7f3 fe36 	bl	800f8c4 <hci_connection_for_handle>
 801bc58:	64f8      	str	r0, [r7, #76]	; 0x4c
            if (!connection) return 0;
 801bc5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bc5c:	2b00      	cmp	r3, #0
 801bc5e:	d101      	bne.n	801bc64 <l2cap_le_signaling_handler_dispatch+0x29c>
 801bc60:	2300      	movs	r3, #0
 801bc62:	e245      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>

            // check if service registered
            le_psm  = little_endian_read_16(command, 4);
 801bc64:	2104      	movs	r1, #4
 801bc66:	6838      	ldr	r0, [r7, #0]
 801bc68:	f7f3 f8bd 	bl	800ede6 <little_endian_read_16>
 801bc6c:	4603      	mov	r3, r0
 801bc6e:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
            service = l2cap_le_get_service(le_psm);
 801bc72:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 801bc76:	4618      	mov	r0, r3
 801bc78:	f001 f98c 	bl	801cf94 <l2cap_le_get_service>
 801bc7c:	6478      	str	r0, [r7, #68]	; 0x44
            source_cid = little_endian_read_16(command, 6);
 801bc7e:	2106      	movs	r1, #6
 801bc80:	6838      	ldr	r0, [r7, #0]
 801bc82:	f7f3 f8b0 	bl	800ede6 <little_endian_read_16>
 801bc86:	4603      	mov	r3, r0
 801bc88:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
                
            if (service){
 801bc8c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bc8e:	2b00      	cmp	r3, #0
 801bc90:	f000 8104 	beq.w	801be9c <l2cap_le_signaling_handler_dispatch+0x4d4>
                if (source_cid < 0x40u){
 801bc94:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 801bc98:	2b3f      	cmp	r3, #63	; 0x3f
 801bc9a:	d80b      	bhi.n	801bcb4 <l2cap_le_signaling_handler_dispatch+0x2ec>
                    // 0x0009 Connection refused - Invalid Source CID
                    l2cap_register_signaling_response(handle, LE_CREDIT_BASED_CONNECTION_REQUEST, sig_id, source_cid, 0x0009);
 801bc9c:	f8b7 1042 	ldrh.w	r1, [r7, #66]	; 0x42
 801bca0:	797a      	ldrb	r2, [r7, #5]
 801bca2:	88f8      	ldrh	r0, [r7, #6]
 801bca4:	2309      	movs	r3, #9
 801bca6:	9300      	str	r3, [sp, #0]
 801bca8:	460b      	mov	r3, r1
 801bcaa:	2114      	movs	r1, #20
 801bcac:	f7ff f834 	bl	801ad18 <l2cap_register_signaling_response>
                    return 1;
 801bcb0:	2301      	movs	r3, #1
 801bcb2:	e21d      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>
                }

                // go through list of channels for this ACL connection and check if we get a match
                btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801bcb4:	f107 0314 	add.w	r3, r7, #20
 801bcb8:	4913      	ldr	r1, [pc, #76]	; (801bd08 <l2cap_le_signaling_handler_dispatch+0x340>)
 801bcba:	4618      	mov	r0, r3
 801bcbc:	f7f2 fd47 	bl	800e74e <btstack_linked_list_iterator_init>
                while (btstack_linked_list_iterator_has_next(&it)){
 801bcc0:	e030      	b.n	801bd24 <l2cap_le_signaling_handler_dispatch+0x35c>
                    l2cap_channel_t * a_channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801bcc2:	f107 0314 	add.w	r3, r7, #20
 801bcc6:	4618      	mov	r0, r3
 801bcc8:	f7f2 fd84 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801bccc:	63f8      	str	r0, [r7, #60]	; 0x3c
                    if (!l2cap_is_dynamic_channel_type(a_channel->channel_type)) continue;
 801bcce:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bcd0:	791b      	ldrb	r3, [r3, #4]
 801bcd2:	4618      	mov	r0, r3
 801bcd4:	f7fc ffff 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801bcd8:	4603      	mov	r3, r0
 801bcda:	2b00      	cmp	r3, #0
 801bcdc:	d100      	bne.n	801bce0 <l2cap_le_signaling_handler_dispatch+0x318>
 801bcde:	e021      	b.n	801bd24 <l2cap_le_signaling_handler_dispatch+0x35c>
                    if (a_channel->con_handle != handle) continue;
 801bce0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bce2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801bce4:	88fa      	ldrh	r2, [r7, #6]
 801bce6:	429a      	cmp	r2, r3
 801bce8:	d000      	beq.n	801bcec <l2cap_le_signaling_handler_dispatch+0x324>
 801bcea:	e01b      	b.n	801bd24 <l2cap_le_signaling_handler_dispatch+0x35c>
                    if (a_channel->remote_cid != source_cid) continue;
 801bcec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bcee:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801bcf0:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 801bcf4:	429a      	cmp	r2, r3
 801bcf6:	d009      	beq.n	801bd0c <l2cap_le_signaling_handler_dispatch+0x344>
 801bcf8:	e014      	b.n	801bd24 <l2cap_le_signaling_handler_dispatch+0x35c>
 801bcfa:	bf00      	nop
 801bcfc:	0802b1dc 	.word	0x0802b1dc
 801bd00:	0802c170 	.word	0x0802c170
 801bd04:	20009ed8 	.word	0x20009ed8
 801bd08:	20009eac 	.word	0x20009eac
                    // 0x000a Connection refused - Source CID already allocated
                    l2cap_register_signaling_response(handle, LE_CREDIT_BASED_CONNECTION_REQUEST, sig_id, source_cid, 0x000a);
 801bd0c:	f8b7 1042 	ldrh.w	r1, [r7, #66]	; 0x42
 801bd10:	797a      	ldrb	r2, [r7, #5]
 801bd12:	88f8      	ldrh	r0, [r7, #6]
 801bd14:	230a      	movs	r3, #10
 801bd16:	9300      	str	r3, [sp, #0]
 801bd18:	460b      	mov	r3, r1
 801bd1a:	2114      	movs	r1, #20
 801bd1c:	f7fe fffc 	bl	801ad18 <l2cap_register_signaling_response>
                    return 1;
 801bd20:	2301      	movs	r3, #1
 801bd22:	e1e5      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>
                while (btstack_linked_list_iterator_has_next(&it)){
 801bd24:	f107 0314 	add.w	r3, r7, #20
 801bd28:	4618      	mov	r0, r3
 801bd2a:	f7f2 fd25 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801bd2e:	4603      	mov	r3, r0
 801bd30:	2b00      	cmp	r3, #0
 801bd32:	d1c6      	bne.n	801bcc2 <l2cap_le_signaling_handler_dispatch+0x2fa>
                }                    

                // security: check encryption
                if (service->required_security_level >= LEVEL_2){
 801bd34:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bd36:	7b1b      	ldrb	r3, [r3, #12]
 801bd38:	2b01      	cmp	r3, #1
 801bd3a:	d925      	bls.n	801bd88 <l2cap_le_signaling_handler_dispatch+0x3c0>
                    if (gap_encryption_key_size(handle) == 0){
 801bd3c:	88fb      	ldrh	r3, [r7, #6]
 801bd3e:	4618      	mov	r0, r3
 801bd40:	f7fa ff2c 	bl	8016b9c <gap_encryption_key_size>
 801bd44:	4603      	mov	r3, r0
 801bd46:	2b00      	cmp	r3, #0
 801bd48:	d10b      	bne.n	801bd62 <l2cap_le_signaling_handler_dispatch+0x39a>
                        // 0x0008 Connection refused - insufficient encryption 
                        l2cap_register_signaling_response(handle, LE_CREDIT_BASED_CONNECTION_REQUEST, sig_id, source_cid, 0x0008);
 801bd4a:	f8b7 1042 	ldrh.w	r1, [r7, #66]	; 0x42
 801bd4e:	797a      	ldrb	r2, [r7, #5]
 801bd50:	88f8      	ldrh	r0, [r7, #6]
 801bd52:	2308      	movs	r3, #8
 801bd54:	9300      	str	r3, [sp, #0]
 801bd56:	460b      	mov	r3, r1
 801bd58:	2114      	movs	r1, #20
 801bd5a:	f7fe ffdd 	bl	801ad18 <l2cap_register_signaling_response>
                        return 1;
 801bd5e:	2301      	movs	r3, #1
 801bd60:	e1c6      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>
                    }
                    // anything less than 16 byte key size is insufficient
                    if (gap_encryption_key_size(handle) < 16){
 801bd62:	88fb      	ldrh	r3, [r7, #6]
 801bd64:	4618      	mov	r0, r3
 801bd66:	f7fa ff19 	bl	8016b9c <gap_encryption_key_size>
 801bd6a:	4603      	mov	r3, r0
 801bd6c:	2b0f      	cmp	r3, #15
 801bd6e:	dc0b      	bgt.n	801bd88 <l2cap_le_signaling_handler_dispatch+0x3c0>
                        // 0x0007 Connection refused – insufficient encryption key size
                        l2cap_register_signaling_response(handle, LE_CREDIT_BASED_CONNECTION_REQUEST, sig_id, source_cid, 0x0007);
 801bd70:	f8b7 1042 	ldrh.w	r1, [r7, #66]	; 0x42
 801bd74:	797a      	ldrb	r2, [r7, #5]
 801bd76:	88f8      	ldrh	r0, [r7, #6]
 801bd78:	2307      	movs	r3, #7
 801bd7a:	9300      	str	r3, [sp, #0]
 801bd7c:	460b      	mov	r3, r1
 801bd7e:	2114      	movs	r1, #20
 801bd80:	f7fe ffca 	bl	801ad18 <l2cap_register_signaling_response>
                        return 1;
 801bd84:	2301      	movs	r3, #1
 801bd86:	e1b3      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>
                    }
                }

                // security: check authencation
                if (service->required_security_level >= LEVEL_3){
 801bd88:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bd8a:	7b1b      	ldrb	r3, [r3, #12]
 801bd8c:	2b02      	cmp	r3, #2
 801bd8e:	d912      	bls.n	801bdb6 <l2cap_le_signaling_handler_dispatch+0x3ee>
                    if (!gap_authenticated(handle)){
 801bd90:	88fb      	ldrh	r3, [r7, #6]
 801bd92:	4618      	mov	r0, r3
 801bd94:	f7fa ff30 	bl	8016bf8 <gap_authenticated>
 801bd98:	4603      	mov	r3, r0
 801bd9a:	2b00      	cmp	r3, #0
 801bd9c:	d10b      	bne.n	801bdb6 <l2cap_le_signaling_handler_dispatch+0x3ee>
                        // 0x0005 Connection refused – insufficient authentication
                        l2cap_register_signaling_response(handle, LE_CREDIT_BASED_CONNECTION_REQUEST, sig_id, source_cid, 0x0005);
 801bd9e:	f8b7 1042 	ldrh.w	r1, [r7, #66]	; 0x42
 801bda2:	797a      	ldrb	r2, [r7, #5]
 801bda4:	88f8      	ldrh	r0, [r7, #6]
 801bda6:	2305      	movs	r3, #5
 801bda8:	9300      	str	r3, [sp, #0]
 801bdaa:	460b      	mov	r3, r1
 801bdac:	2114      	movs	r1, #20
 801bdae:	f7fe ffb3 	bl	801ad18 <l2cap_register_signaling_response>
                        return 1;
 801bdb2:	2301      	movs	r3, #1
 801bdb4:	e19c      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>
                    }
                }

                // security: check authorization
                if (service->required_security_level >= LEVEL_4){
 801bdb6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bdb8:	7b1b      	ldrb	r3, [r3, #12]
 801bdba:	2b03      	cmp	r3, #3
 801bdbc:	d912      	bls.n	801bde4 <l2cap_le_signaling_handler_dispatch+0x41c>
                    if (gap_authorization_state(handle) != AUTHORIZATION_GRANTED){
 801bdbe:	88fb      	ldrh	r3, [r7, #6]
 801bdc0:	4618      	mov	r0, r3
 801bdc2:	f7fa ff79 	bl	8016cb8 <gap_authorization_state>
 801bdc6:	4603      	mov	r3, r0
 801bdc8:	2b03      	cmp	r3, #3
 801bdca:	d00b      	beq.n	801bde4 <l2cap_le_signaling_handler_dispatch+0x41c>
                        // 0x0006 Connection refused – insufficient authorization
                        l2cap_register_signaling_response(handle, LE_CREDIT_BASED_CONNECTION_REQUEST, sig_id, source_cid, 0x0006);
 801bdcc:	f8b7 1042 	ldrh.w	r1, [r7, #66]	; 0x42
 801bdd0:	797a      	ldrb	r2, [r7, #5]
 801bdd2:	88f8      	ldrh	r0, [r7, #6]
 801bdd4:	2306      	movs	r3, #6
 801bdd6:	9300      	str	r3, [sp, #0]
 801bdd8:	460b      	mov	r3, r1
 801bdda:	2114      	movs	r1, #20
 801bddc:	f7fe ff9c 	bl	801ad18 <l2cap_register_signaling_response>
                        return 1;
 801bde0:	2301      	movs	r3, #1
 801bde2:	e185      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>
                    }
                }

                // allocate channel
                channel = l2cap_create_channel_entry(service->packet_handler, L2CAP_CHANNEL_TYPE_LE_DATA_CHANNEL, connection->address,
 801bde4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bde6:	6898      	ldr	r0, [r3, #8]
 801bde8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bdea:	1d19      	adds	r1, r3, #4
 801bdec:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bdee:	88db      	ldrh	r3, [r3, #6]
 801bdf0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801bdf2:	7b12      	ldrb	r2, [r2, #12]
 801bdf4:	9202      	str	r2, [sp, #8]
 801bdf6:	9301      	str	r3, [sp, #4]
 801bdf8:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 801bdfc:	9300      	str	r3, [sp, #0]
 801bdfe:	2301      	movs	r3, #1
 801be00:	460a      	mov	r2, r1
 801be02:	2102      	movs	r1, #2
 801be04:	f7fe fa14 	bl	801a230 <l2cap_create_channel_entry>
 801be08:	6678      	str	r0, [r7, #100]	; 0x64
                    BD_ADDR_TYPE_LE_RANDOM, le_psm, service->mtu, service->required_security_level);
                if (!channel){
 801be0a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801be0c:	2b00      	cmp	r3, #0
 801be0e:	d10b      	bne.n	801be28 <l2cap_le_signaling_handler_dispatch+0x460>
                    // 0x0004 Connection refused – no resources available
                    l2cap_register_signaling_response(handle, LE_CREDIT_BASED_CONNECTION_REQUEST, sig_id, source_cid, 0x0004);
 801be10:	f8b7 1042 	ldrh.w	r1, [r7, #66]	; 0x42
 801be14:	797a      	ldrb	r2, [r7, #5]
 801be16:	88f8      	ldrh	r0, [r7, #6]
 801be18:	2304      	movs	r3, #4
 801be1a:	9300      	str	r3, [sp, #0]
 801be1c:	460b      	mov	r3, r1
 801be1e:	2114      	movs	r1, #20
 801be20:	f7fe ff7a 	bl	801ad18 <l2cap_register_signaling_response>
                    return 1;
 801be24:	2301      	movs	r3, #1
 801be26:	e163      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>
                }

                channel->con_handle = handle;
 801be28:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801be2a:	88fa      	ldrh	r2, [r7, #6]
 801be2c:	849a      	strh	r2, [r3, #36]	; 0x24
                channel->remote_cid = source_cid;
 801be2e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801be30:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 801be34:	861a      	strh	r2, [r3, #48]	; 0x30
                channel->remote_sig_id = sig_id; 
 801be36:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801be38:	797a      	ldrb	r2, [r7, #5]
 801be3a:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
                channel->remote_mtu = little_endian_read_16(command, 8);
 801be3e:	2108      	movs	r1, #8
 801be40:	6838      	ldr	r0, [r7, #0]
 801be42:	f7f2 ffd0 	bl	800ede6 <little_endian_read_16>
 801be46:	4603      	mov	r3, r0
 801be48:	461a      	mov	r2, r3
 801be4a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801be4c:	869a      	strh	r2, [r3, #52]	; 0x34
                channel->remote_mps = little_endian_read_16(command, 10);
 801be4e:	210a      	movs	r1, #10
 801be50:	6838      	ldr	r0, [r7, #0]
 801be52:	f7f2 ffc8 	bl	800ede6 <little_endian_read_16>
 801be56:	4603      	mov	r3, r0
 801be58:	461a      	mov	r2, r3
 801be5a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801be5c:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
                channel->credits_outgoing = little_endian_read_16(command, 12);
 801be60:	210c      	movs	r1, #12
 801be62:	6838      	ldr	r0, [r7, #0]
 801be64:	f7f2 ffbf 	bl	800ede6 <little_endian_read_16>
 801be68:	4603      	mov	r3, r0
 801be6a:	461a      	mov	r2, r3
 801be6c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801be6e:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e

                // set initial state
                channel->state      = L2CAP_STATE_WAIT_CLIENT_ACCEPT_OR_REJECT;
 801be72:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801be74:	2209      	movs	r2, #9
 801be76:	f883 2020 	strb.w	r2, [r3, #32]
                channel->state_var |= L2CAP_CHANNEL_STATE_VAR_INCOMING;
 801be7a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801be7c:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801be7e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801be82:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 801be86:	b29a      	uxth	r2, r3
 801be88:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801be8a:	845a      	strh	r2, [r3, #34]	; 0x22

                // add to connections list
                btstack_linked_list_add_tail(&l2cap_channels, (btstack_linked_item_t *) channel);
 801be8c:	6e79      	ldr	r1, [r7, #100]	; 0x64
 801be8e:	489a      	ldr	r0, [pc, #616]	; (801c0f8 <l2cap_le_signaling_handler_dispatch+0x730>)
 801be90:	f7f2 fbf2 	bl	800e678 <btstack_linked_list_add_tail>

                // post connection request event
                l2cap_emit_le_incoming_connection(channel);
 801be94:	6e78      	ldr	r0, [r7, #100]	; 0x64
 801be96:	f000 fe7f 	bl	801cb98 <l2cap_emit_le_incoming_connection>

            } else {
                // Connection refused – LE_PSM not supported
                l2cap_register_signaling_response(handle, LE_CREDIT_BASED_CONNECTION_REQUEST, sig_id, source_cid, 0x0002);
            }
            break;
 801be9a:	e128      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>
                l2cap_register_signaling_response(handle, LE_CREDIT_BASED_CONNECTION_REQUEST, sig_id, source_cid, 0x0002);
 801be9c:	f8b7 1042 	ldrh.w	r1, [r7, #66]	; 0x42
 801bea0:	797a      	ldrb	r2, [r7, #5]
 801bea2:	88f8      	ldrh	r0, [r7, #6]
 801bea4:	2302      	movs	r3, #2
 801bea6:	9300      	str	r3, [sp, #0]
 801bea8:	460b      	mov	r3, r1
 801beaa:	2114      	movs	r1, #20
 801beac:	f7fe ff34 	bl	801ad18 <l2cap_register_signaling_response>
            break;
 801beb0:	e11d      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>

        case LE_CREDIT_BASED_CONNECTION_RESPONSE:
            // check size
            if (len < 10u) return 0u;
 801beb2:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 801beb6:	2b09      	cmp	r3, #9
 801beb8:	d801      	bhi.n	801bebe <l2cap_le_signaling_handler_dispatch+0x4f6>
 801beba:	2300      	movs	r3, #0
 801bebc:	e118      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>

            // Find channel for this sig_id and connection handle
            channel = NULL;
 801bebe:	2300      	movs	r3, #0
 801bec0:	667b      	str	r3, [r7, #100]	; 0x64
            btstack_linked_list_iterator_init(&it, &l2cap_channels);
 801bec2:	f107 0314 	add.w	r3, r7, #20
 801bec6:	498c      	ldr	r1, [pc, #560]	; (801c0f8 <l2cap_le_signaling_handler_dispatch+0x730>)
 801bec8:	4618      	mov	r0, r3
 801beca:	f7f2 fc40 	bl	800e74e <btstack_linked_list_iterator_init>
            while (btstack_linked_list_iterator_has_next(&it)){
 801bece:	e01e      	b.n	801bf0e <l2cap_le_signaling_handler_dispatch+0x546>
                l2cap_channel_t * a_channel = (l2cap_channel_t *) btstack_linked_list_iterator_next(&it);
 801bed0:	f107 0314 	add.w	r3, r7, #20
 801bed4:	4618      	mov	r0, r3
 801bed6:	f7f2 fc7d 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801beda:	6578      	str	r0, [r7, #84]	; 0x54
                if (!l2cap_is_dynamic_channel_type(a_channel->channel_type)) continue;
 801bedc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bede:	791b      	ldrb	r3, [r3, #4]
 801bee0:	4618      	mov	r0, r3
 801bee2:	f7fc fef8 	bl	8018cd6 <l2cap_is_dynamic_channel_type>
 801bee6:	4603      	mov	r3, r0
 801bee8:	2b00      	cmp	r3, #0
 801beea:	d100      	bne.n	801beee <l2cap_le_signaling_handler_dispatch+0x526>
 801beec:	e00f      	b.n	801bf0e <l2cap_le_signaling_handler_dispatch+0x546>
                if (a_channel->con_handle   != handle) continue;
 801beee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bef0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801bef2:	88fa      	ldrh	r2, [r7, #6]
 801bef4:	429a      	cmp	r2, r3
 801bef6:	d000      	beq.n	801befa <l2cap_le_signaling_handler_dispatch+0x532>
 801bef8:	e009      	b.n	801bf0e <l2cap_le_signaling_handler_dispatch+0x546>
                if (a_channel->local_sig_id != sig_id) continue;
 801befa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801befc:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 801bf00:	797a      	ldrb	r2, [r7, #5]
 801bf02:	429a      	cmp	r2, r3
 801bf04:	d000      	beq.n	801bf08 <l2cap_le_signaling_handler_dispatch+0x540>
 801bf06:	e002      	b.n	801bf0e <l2cap_le_signaling_handler_dispatch+0x546>
                channel = a_channel;
 801bf08:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bf0a:	667b      	str	r3, [r7, #100]	; 0x64
                break; 
 801bf0c:	e007      	b.n	801bf1e <l2cap_le_signaling_handler_dispatch+0x556>
            while (btstack_linked_list_iterator_has_next(&it)){
 801bf0e:	f107 0314 	add.w	r3, r7, #20
 801bf12:	4618      	mov	r0, r3
 801bf14:	f7f2 fc30 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801bf18:	4603      	mov	r3, r0
 801bf1a:	2b00      	cmp	r3, #0
 801bf1c:	d1d8      	bne.n	801bed0 <l2cap_le_signaling_handler_dispatch+0x508>
            }
            if (!channel) break;
 801bf1e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801bf20:	2b00      	cmp	r3, #0
 801bf22:	f000 80e3 	beq.w	801c0ec <l2cap_le_signaling_handler_dispatch+0x724>

            // cid + 0
            result = little_endian_read_16 (command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET+8);
 801bf26:	210c      	movs	r1, #12
 801bf28:	6838      	ldr	r0, [r7, #0]
 801bf2a:	f7f2 ff5c 	bl	800ede6 <little_endian_read_16>
 801bf2e:	4603      	mov	r3, r0
 801bf30:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            if (result){
 801bf34:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 801bf38:	2b00      	cmp	r3, #0
 801bf3a:	d012      	beq.n	801bf62 <l2cap_le_signaling_handler_dispatch+0x59a>
                channel->state = L2CAP_STATE_CLOSED;
 801bf3c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801bf3e:	2201      	movs	r2, #1
 801bf40:	f883 2020 	strb.w	r2, [r3, #32]
                // map l2cap connection response result to BTstack status enumeration
                l2cap_emit_le_channel_opened(channel, result);
 801bf44:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 801bf48:	b2db      	uxtb	r3, r3
 801bf4a:	4619      	mov	r1, r3
 801bf4c:	6e78      	ldr	r0, [r7, #100]	; 0x64
 801bf4e:	f000 fe9d 	bl	801cc8c <l2cap_emit_le_channel_opened>
                                
                // discard channel
                btstack_linked_list_remove(&l2cap_channels, (btstack_linked_item_t *) channel);
 801bf52:	6e79      	ldr	r1, [r7, #100]	; 0x64
 801bf54:	4868      	ldr	r0, [pc, #416]	; (801c0f8 <l2cap_le_signaling_handler_dispatch+0x730>)
 801bf56:	f7f2 fbb2 	bl	800e6be <btstack_linked_list_remove>
                l2cap_free_channel_entry(channel);
 801bf5a:	6e78      	ldr	r0, [r7, #100]	; 0x64
 801bf5c:	f7fe f9c8 	bl	801a2f0 <l2cap_free_channel_entry>
                break;
 801bf60:	e0c5      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>
            }

            // success
            channel->remote_cid = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET + 0);
 801bf62:	2104      	movs	r1, #4
 801bf64:	6838      	ldr	r0, [r7, #0]
 801bf66:	f7f2 ff3e 	bl	800ede6 <little_endian_read_16>
 801bf6a:	4603      	mov	r3, r0
 801bf6c:	461a      	mov	r2, r3
 801bf6e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801bf70:	861a      	strh	r2, [r3, #48]	; 0x30
            channel->remote_mtu = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET + 2);
 801bf72:	2106      	movs	r1, #6
 801bf74:	6838      	ldr	r0, [r7, #0]
 801bf76:	f7f2 ff36 	bl	800ede6 <little_endian_read_16>
 801bf7a:	4603      	mov	r3, r0
 801bf7c:	461a      	mov	r2, r3
 801bf7e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801bf80:	869a      	strh	r2, [r3, #52]	; 0x34
            channel->remote_mps = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET + 4);
 801bf82:	2108      	movs	r1, #8
 801bf84:	6838      	ldr	r0, [r7, #0]
 801bf86:	f7f2 ff2e 	bl	800ede6 <little_endian_read_16>
 801bf8a:	4603      	mov	r3, r0
 801bf8c:	461a      	mov	r2, r3
 801bf8e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801bf90:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
            channel->credits_outgoing = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET + 6);
 801bf94:	210a      	movs	r1, #10
 801bf96:	6838      	ldr	r0, [r7, #0]
 801bf98:	f7f2 ff25 	bl	800ede6 <little_endian_read_16>
 801bf9c:	4603      	mov	r3, r0
 801bf9e:	461a      	mov	r2, r3
 801bfa0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801bfa2:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
            channel->state = L2CAP_STATE_OPEN;
 801bfa6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801bfa8:	220c      	movs	r2, #12
 801bfaa:	f883 2020 	strb.w	r2, [r3, #32]
            l2cap_emit_le_channel_opened(channel, result);
 801bfae:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 801bfb2:	b2db      	uxtb	r3, r3
 801bfb4:	4619      	mov	r1, r3
 801bfb6:	6e78      	ldr	r0, [r7, #100]	; 0x64
 801bfb8:	f000 fe68 	bl	801cc8c <l2cap_emit_le_channel_opened>
            break;
 801bfbc:	e097      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>

        case LE_FLOW_CONTROL_CREDIT:
            // check size
            if (len < 4u) return 0u;
 801bfbe:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 801bfc2:	2b03      	cmp	r3, #3
 801bfc4:	d801      	bhi.n	801bfca <l2cap_le_signaling_handler_dispatch+0x602>
 801bfc6:	2300      	movs	r3, #0
 801bfc8:	e092      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>

            // find channel
            local_cid = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET + 0);
 801bfca:	2104      	movs	r1, #4
 801bfcc:	6838      	ldr	r0, [r7, #0]
 801bfce:	f7f2 ff0a 	bl	800ede6 <little_endian_read_16>
 801bfd2:	4603      	mov	r3, r0
 801bfd4:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
            channel = l2cap_get_channel_for_local_cid_and_handle(local_cid, handle);
 801bfd8:	88fa      	ldrh	r2, [r7, #6]
 801bfda:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801bfde:	4611      	mov	r1, r2
 801bfe0:	4618      	mov	r0, r3
 801bfe2:	f7fc fe55 	bl	8018c90 <l2cap_get_channel_for_local_cid_and_handle>
 801bfe6:	6678      	str	r0, [r7, #100]	; 0x64
            if (!channel) {
 801bfe8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801bfea:	2b00      	cmp	r3, #0
 801bfec:	d10a      	bne.n	801c004 <l2cap_le_signaling_handler_dispatch+0x63c>
                log_error("l2cap: no channel for cid 0x%02x", local_cid);
 801bfee:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801bff2:	9300      	str	r3, [sp, #0]
 801bff4:	f640 5314 	movw	r3, #3348	; 0xd14
 801bff8:	4a40      	ldr	r2, [pc, #256]	; (801c0fc <l2cap_le_signaling_handler_dispatch+0x734>)
 801bffa:	4941      	ldr	r1, [pc, #260]	; (801c100 <l2cap_le_signaling_handler_dispatch+0x738>)
 801bffc:	2002      	movs	r0, #2
 801bffe:	f7fb fa1f 	bl	8017440 <hci_dump_log>
                break;
 801c002:	e074      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>
            }
            new_credits = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET + 2);
 801c004:	2106      	movs	r1, #6
 801c006:	6838      	ldr	r0, [r7, #0]
 801c008:	f7f2 feed 	bl	800ede6 <little_endian_read_16>
 801c00c:	4603      	mov	r3, r0
 801c00e:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            credits_before = channel->credits_outgoing;
 801c012:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801c014:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 801c018:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
            channel->credits_outgoing += new_credits;
 801c01c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801c01e:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 801c022:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 801c026:	4413      	add	r3, r2
 801c028:	b29a      	uxth	r2, r3
 801c02a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801c02c:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
            // check for credit overrun
            if (credits_before > channel->credits_outgoing){
 801c030:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801c032:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 801c036:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 801c03a:	429a      	cmp	r2, r3
 801c03c:	d90e      	bls.n	801c05c <l2cap_le_signaling_handler_dispatch+0x694>
                log_error("l2cap: new credits caused overrrun for cid 0x%02x, disconnecting", local_cid);
 801c03e:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801c042:	9300      	str	r3, [sp, #0]
 801c044:	f640 531c 	movw	r3, #3356	; 0xd1c
 801c048:	4a2c      	ldr	r2, [pc, #176]	; (801c0fc <l2cap_le_signaling_handler_dispatch+0x734>)
 801c04a:	492e      	ldr	r1, [pc, #184]	; (801c104 <l2cap_le_signaling_handler_dispatch+0x73c>)
 801c04c:	2002      	movs	r0, #2
 801c04e:	f7fb f9f7 	bl	8017440 <hci_dump_log>
                channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST;
 801c052:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801c054:	2212      	movs	r2, #18
 801c056:	f883 2020 	strb.w	r2, [r3, #32]
                break;
 801c05a:	e048      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>
            }            
            log_info("l2cap: %u credits for 0x%02x, now %u", new_credits, local_cid, channel->credits_outgoing);
 801c05c:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 801c060:	f8b7 205e 	ldrh.w	r2, [r7, #94]	; 0x5e
 801c064:	6e79      	ldr	r1, [r7, #100]	; 0x64
 801c066:	f8b1 104e 	ldrh.w	r1, [r1, #78]	; 0x4e
 801c06a:	9102      	str	r1, [sp, #8]
 801c06c:	9201      	str	r2, [sp, #4]
 801c06e:	9300      	str	r3, [sp, #0]
 801c070:	f44f 6352 	mov.w	r3, #3360	; 0xd20
 801c074:	4a21      	ldr	r2, [pc, #132]	; (801c0fc <l2cap_le_signaling_handler_dispatch+0x734>)
 801c076:	4924      	ldr	r1, [pc, #144]	; (801c108 <l2cap_le_signaling_handler_dispatch+0x740>)
 801c078:	2001      	movs	r0, #1
 801c07a:	f7fb f9e1 	bl	8017440 <hci_dump_log>
            break;
 801c07e:	e036      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>

        case DISCONNECTION_REQUEST:

            // check size
            if (len < 4u) return 0u;
 801c080:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 801c084:	2b03      	cmp	r3, #3
 801c086:	d801      	bhi.n	801c08c <l2cap_le_signaling_handler_dispatch+0x6c4>
 801c088:	2300      	movs	r3, #0
 801c08a:	e031      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>

            // find channel
            local_cid = little_endian_read_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET + 0);
 801c08c:	2104      	movs	r1, #4
 801c08e:	6838      	ldr	r0, [r7, #0]
 801c090:	f7f2 fea9 	bl	800ede6 <little_endian_read_16>
 801c094:	4603      	mov	r3, r0
 801c096:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
            channel = l2cap_get_channel_for_local_cid_and_handle(local_cid, handle);
 801c09a:	88fa      	ldrh	r2, [r7, #6]
 801c09c:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801c0a0:	4611      	mov	r1, r2
 801c0a2:	4618      	mov	r0, r3
 801c0a4:	f7fc fdf4 	bl	8018c90 <l2cap_get_channel_for_local_cid_and_handle>
 801c0a8:	6678      	str	r0, [r7, #100]	; 0x64
            if (!channel) {
 801c0aa:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801c0ac:	2b00      	cmp	r3, #0
 801c0ae:	d10a      	bne.n	801c0c6 <l2cap_le_signaling_handler_dispatch+0x6fe>
                log_error("l2cap: no channel for cid 0x%02x", local_cid);
 801c0b0:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801c0b4:	9300      	str	r3, [sp, #0]
 801c0b6:	f640 532c 	movw	r3, #3372	; 0xd2c
 801c0ba:	4a10      	ldr	r2, [pc, #64]	; (801c0fc <l2cap_le_signaling_handler_dispatch+0x734>)
 801c0bc:	4910      	ldr	r1, [pc, #64]	; (801c100 <l2cap_le_signaling_handler_dispatch+0x738>)
 801c0be:	2002      	movs	r0, #2
 801c0c0:	f7fb f9be 	bl	8017440 <hci_dump_log>
                break;
 801c0c4:	e013      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>
            }
            channel->remote_sig_id = sig_id;
 801c0c6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801c0c8:	797a      	ldrb	r2, [r7, #5]
 801c0ca:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
            channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_RESPONSE;
 801c0ce:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801c0d0:	2213      	movs	r2, #19
 801c0d2:	f883 2020 	strb.w	r2, [r3, #32]
            break;
 801c0d6:	e00a      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>
        case DISCONNECTION_RESPONSE:
            break;

        default:
            // command unknown -> reject command
            return 0;
 801c0d8:	2300      	movs	r3, #0
 801c0da:	e009      	b.n	801c0f0 <l2cap_le_signaling_handler_dispatch+0x728>
            break;
 801c0dc:	bf00      	nop
 801c0de:	e006      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>
            if (!l2cap_event_packet_handler) break;
 801c0e0:	bf00      	nop
 801c0e2:	e004      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>
            if (!channel) break;
 801c0e4:	bf00      	nop
 801c0e6:	e002      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>
            break;
 801c0e8:	bf00      	nop
 801c0ea:	e000      	b.n	801c0ee <l2cap_le_signaling_handler_dispatch+0x726>
            if (!channel) break;
 801c0ec:	bf00      	nop
    }
    return 1;
 801c0ee:	2301      	movs	r3, #1
}
 801c0f0:	4618      	mov	r0, r3
 801c0f2:	376c      	adds	r7, #108	; 0x6c
 801c0f4:	46bd      	mov	sp, r7
 801c0f6:	bd90      	pop	{r4, r7, pc}
 801c0f8:	20009eac 	.word	0x20009eac
 801c0fc:	0802b1dc 	.word	0x0802b1dc
 801c100:	0802c1c0 	.word	0x0802c1c0
 801c104:	0802c1e8 	.word	0x0802c1e8
 801c108:	0802c230 	.word	0x0802c230

0801c10c <l2cap_acl_classic_handler_for_channel>:
#endif

#ifdef ENABLE_CLASSIC
static void l2cap_acl_classic_handler_for_channel(l2cap_channel_t * l2cap_channel, uint8_t * packet, uint16_t size){
 801c10c:	b580      	push	{r7, lr}
 801c10e:	b09c      	sub	sp, #112	; 0x70
 801c110:	af04      	add	r7, sp, #16
 801c112:	60f8      	str	r0, [r7, #12]
 801c114:	60b9      	str	r1, [r7, #8]
 801c116:	4613      	mov	r3, r2
 801c118:	80fb      	strh	r3, [r7, #6]

    // forward data only in OPEN state
    if (l2cap_channel->state != L2CAP_STATE_OPEN) return;
 801c11a:	68fb      	ldr	r3, [r7, #12]
 801c11c:	f893 3020 	ldrb.w	r3, [r3, #32]
 801c120:	2b0c      	cmp	r3, #12
 801c122:	f040 82c1 	bne.w	801c6a8 <l2cap_acl_classic_handler_for_channel+0x59c>

#ifdef ENABLE_L2CAP_ENHANCED_RETRANSMISSION_MODE
    if (l2cap_channel->mode == L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION){
 801c126:	68fb      	ldr	r3, [r7, #12]
 801c128:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 801c12c:	2b03      	cmp	r3, #3
 801c12e:	f040 82a7 	bne.w	801c680 <l2cap_acl_classic_handler_for_channel+0x574>

        int fcs_size = l2cap_channel->fcs_option ? 2 : 0;
 801c132:	68fb      	ldr	r3, [r7, #12]
 801c134:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 801c138:	2b00      	cmp	r3, #0
 801c13a:	d001      	beq.n	801c140 <l2cap_acl_classic_handler_for_channel+0x34>
 801c13c:	2302      	movs	r3, #2
 801c13e:	e000      	b.n	801c142 <l2cap_acl_classic_handler_for_channel+0x36>
 801c140:	2300      	movs	r3, #0
 801c142:	647b      	str	r3, [r7, #68]	; 0x44

        // assert control + FCS fields are inside
        if (size < COMPLETE_L2CAP_HEADER+2+fcs_size) return;
 801c144:	88fa      	ldrh	r2, [r7, #6]
 801c146:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c148:	330a      	adds	r3, #10
 801c14a:	429a      	cmp	r2, r3
 801c14c:	f2c0 82ae 	blt.w	801c6ac <l2cap_acl_classic_handler_for_channel+0x5a0>

        if (l2cap_channel->fcs_option){
 801c150:	68fb      	ldr	r3, [r7, #12]
 801c152:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 801c156:	2b00      	cmp	r3, #0
 801c158:	d033      	beq.n	801c1c2 <l2cap_acl_classic_handler_for_channel+0xb6>
            // verify FCS (required if one side requested it)
            uint16_t fcs_calculated = crc16_calc(&packet[4], size - (4+2));
 801c15a:	68bb      	ldr	r3, [r7, #8]
 801c15c:	1d1a      	adds	r2, r3, #4
 801c15e:	88fb      	ldrh	r3, [r7, #6]
 801c160:	3b06      	subs	r3, #6
 801c162:	b29b      	uxth	r3, r3
 801c164:	4619      	mov	r1, r3
 801c166:	4610      	mov	r0, r2
 801c168:	f7fb fc4c 	bl	8017a04 <crc16_calc>
 801c16c:	4603      	mov	r3, r0
 801c16e:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
            uint16_t fcs_packet     = little_endian_read_16(packet, size-2);
 801c172:	88fb      	ldrh	r3, [r7, #6]
 801c174:	3b02      	subs	r3, #2
 801c176:	4619      	mov	r1, r3
 801c178:	68b8      	ldr	r0, [r7, #8]
 801c17a:	f7f2 fe34 	bl	800ede6 <little_endian_read_16>
 801c17e:	4603      	mov	r3, r0
 801c180:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
                            fcs_calculated++;
                            counter = 0;
                        }
#endif

            if (fcs_calculated == fcs_packet){
 801c184:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 801c188:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 801c18c:	429a      	cmp	r2, r3
 801c18e:	d10a      	bne.n	801c1a6 <l2cap_acl_classic_handler_for_channel+0x9a>
                log_info("Packet FCS 0x%04x verified", fcs_packet);
 801c190:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 801c194:	9300      	str	r3, [sp, #0]
 801c196:	f640 535e 	movw	r3, #3422	; 0xd5e
 801c19a:	4a8e      	ldr	r2, [pc, #568]	; (801c3d4 <l2cap_acl_classic_handler_for_channel+0x2c8>)
 801c19c:	498e      	ldr	r1, [pc, #568]	; (801c3d8 <l2cap_acl_classic_handler_for_channel+0x2cc>)
 801c19e:	2001      	movs	r0, #1
 801c1a0:	f7fb f94e 	bl	8017440 <hci_dump_log>
 801c1a4:	e00d      	b.n	801c1c2 <l2cap_acl_classic_handler_for_channel+0xb6>
            } else {
                log_error("FCS mismatch! Packet 0x%04x, calculated 0x%04x", fcs_packet, fcs_calculated);
 801c1a6:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 801c1aa:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 801c1ae:	9201      	str	r2, [sp, #4]
 801c1b0:	9300      	str	r3, [sp, #0]
 801c1b2:	f44f 6356 	mov.w	r3, #3424	; 0xd60
 801c1b6:	4a87      	ldr	r2, [pc, #540]	; (801c3d4 <l2cap_acl_classic_handler_for_channel+0x2c8>)
 801c1b8:	4988      	ldr	r1, [pc, #544]	; (801c3dc <l2cap_acl_classic_handler_for_channel+0x2d0>)
 801c1ba:	2002      	movs	r0, #2
 801c1bc:	f7fb f940 	bl	8017440 <hci_dump_log>
                // ERTM State Machine in Bluetooth Spec does not handle 'I-Frame with invalid FCS'
                return;
 801c1c0:	e277      	b.n	801c6b2 <l2cap_acl_classic_handler_for_channel+0x5a6>
            }
        }

        // switch on packet type
        uint16_t control = little_endian_read_16(packet, COMPLETE_L2CAP_HEADER);
 801c1c2:	2108      	movs	r1, #8
 801c1c4:	68b8      	ldr	r0, [r7, #8]
 801c1c6:	f7f2 fe0e 	bl	800ede6 <little_endian_read_16>
 801c1ca:	4603      	mov	r3, r0
 801c1cc:	87fb      	strh	r3, [r7, #62]	; 0x3e
        uint8_t  req_seq = (control >> 8) & 0x3f;
 801c1ce:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801c1d0:	0a1b      	lsrs	r3, r3, #8
 801c1d2:	b29b      	uxth	r3, r3
 801c1d4:	b2db      	uxtb	r3, r3
 801c1d6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801c1da:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
        int final = (control >> 7) & 0x01;
 801c1de:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801c1e0:	09db      	lsrs	r3, r3, #7
 801c1e2:	b29b      	uxth	r3, r3
 801c1e4:	f003 0301 	and.w	r3, r3, #1
 801c1e8:	63bb      	str	r3, [r7, #56]	; 0x38
        if (control & 1){
 801c1ea:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801c1ec:	f003 0301 	and.w	r3, r3, #1
 801c1f0:	2b00      	cmp	r3, #0
 801c1f2:	f000 8103 	beq.w	801c3fc <l2cap_acl_classic_handler_for_channel+0x2f0>
            // S-Frame
            int poll  = (control >> 4) & 0x01;
 801c1f6:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801c1f8:	091b      	lsrs	r3, r3, #4
 801c1fa:	b29b      	uxth	r3, r3
 801c1fc:	f003 0301 	and.w	r3, r3, #1
 801c200:	623b      	str	r3, [r7, #32]
            l2cap_supervisory_function_t s = (l2cap_supervisory_function_t) ((control >> 2) & 0x03);
 801c202:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801c204:	089b      	lsrs	r3, r3, #2
 801c206:	b29b      	uxth	r3, r3
 801c208:	b2db      	uxtb	r3, r3
 801c20a:	f003 0303 	and.w	r3, r3, #3
 801c20e:	77fb      	strb	r3, [r7, #31]
            log_info("Control: 0x%04x => Supervisory function %u, ReqSeq %02u", control, (int) s, req_seq);
 801c210:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801c212:	7ffa      	ldrb	r2, [r7, #31]
 801c214:	f897 103d 	ldrb.w	r1, [r7, #61]	; 0x3d
 801c218:	9102      	str	r1, [sp, #8]
 801c21a:	9201      	str	r2, [sp, #4]
 801c21c:	9300      	str	r3, [sp, #0]
 801c21e:	f640 536e 	movw	r3, #3438	; 0xd6e
 801c222:	4a6c      	ldr	r2, [pc, #432]	; (801c3d4 <l2cap_acl_classic_handler_for_channel+0x2c8>)
 801c224:	496e      	ldr	r1, [pc, #440]	; (801c3e0 <l2cap_acl_classic_handler_for_channel+0x2d4>)
 801c226:	2001      	movs	r0, #1
 801c228:	f7fb f90a 	bl	8017440 <hci_dump_log>
            l2cap_ertm_tx_packet_state_t * tx_state;
            switch (s){
 801c22c:	7ffb      	ldrb	r3, [r7, #31]
 801c22e:	2b03      	cmp	r3, #3
 801c230:	f200 8220 	bhi.w	801c674 <l2cap_acl_classic_handler_for_channel+0x568>
 801c234:	a201      	add	r2, pc, #4	; (adr r2, 801c23c <l2cap_acl_classic_handler_for_channel+0x130>)
 801c236:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c23a:	bf00      	nop
 801c23c:	0801c24d 	.word	0x0801c24d
 801c240:	0801c33d 	.word	0x0801c33d
 801c244:	0801c35f 	.word	0x0801c35f
 801c248:	0801c36f 	.word	0x0801c36f
                case L2CAP_SUPERVISORY_FUNCTION_RR_RECEIVER_READY:
                    log_info("L2CAP_SUPERVISORY_FUNCTION_RR_RECEIVER_READY");
 801c24c:	f640 5372 	movw	r3, #3442	; 0xd72
 801c250:	4a60      	ldr	r2, [pc, #384]	; (801c3d4 <l2cap_acl_classic_handler_for_channel+0x2c8>)
 801c252:	4964      	ldr	r1, [pc, #400]	; (801c3e4 <l2cap_acl_classic_handler_for_channel+0x2d8>)
 801c254:	2001      	movs	r0, #1
 801c256:	f7fb f8f3 	bl	8017440 <hci_dump_log>
                    l2cap_ertm_process_req_seq(l2cap_channel, req_seq);
 801c25a:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801c25e:	4619      	mov	r1, r3
 801c260:	68f8      	ldr	r0, [r7, #12]
 801c262:	f7fb ff75 	bl	8018150 <l2cap_ertm_process_req_seq>
                    if (poll && final){
 801c266:	6a3b      	ldr	r3, [r7, #32]
 801c268:	2b00      	cmp	r3, #0
 801c26a:	d00a      	beq.n	801c282 <l2cap_acl_classic_handler_for_channel+0x176>
 801c26c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c26e:	2b00      	cmp	r3, #0
 801c270:	d007      	beq.n	801c282 <l2cap_acl_classic_handler_for_channel+0x176>
                        // S-frames shall not be transmitted with both the F-bit and the P-bit set to 1 at the same time.
                        log_error("P=F=1 in S-Frame");
 801c272:	f640 5376 	movw	r3, #3446	; 0xd76
 801c276:	4a57      	ldr	r2, [pc, #348]	; (801c3d4 <l2cap_acl_classic_handler_for_channel+0x2c8>)
 801c278:	495b      	ldr	r1, [pc, #364]	; (801c3e8 <l2cap_acl_classic_handler_for_channel+0x2dc>)
 801c27a:	2002      	movs	r0, #2
 801c27c:	f7fb f8e0 	bl	8017440 <hci_dump_log>
                        break;
 801c280:	e1fd      	b.n	801c67e <l2cap_acl_classic_handler_for_channel+0x572>
                    }
                    if (poll){
 801c282:	6a3b      	ldr	r3, [r7, #32]
 801c284:	2b00      	cmp	r3, #0
 801c286:	d046      	beq.n	801c316 <l2cap_acl_classic_handler_for_channel+0x20a>
                        // check if we did request selective retransmission before <==> we have stored SDU segments
                        int i;
                        int num_stored_out_of_order_packets = 0;
 801c288:	2300      	movs	r3, #0
 801c28a:	65bb      	str	r3, [r7, #88]	; 0x58
                        for (i=0;i<l2cap_channel->num_rx_buffers;i++){
 801c28c:	2300      	movs	r3, #0
 801c28e:	65fb      	str	r3, [r7, #92]	; 0x5c
 801c290:	e02a      	b.n	801c2e8 <l2cap_acl_classic_handler_for_channel+0x1dc>
                            int index = l2cap_channel->rx_store_index + i;
 801c292:	68fb      	ldr	r3, [r7, #12]
 801c294:	f893 3092 	ldrb.w	r3, [r3, #146]	; 0x92
 801c298:	461a      	mov	r2, r3
 801c29a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801c29c:	4413      	add	r3, r2
 801c29e:	657b      	str	r3, [r7, #84]	; 0x54
                            if (index >= l2cap_channel->num_rx_buffers){
 801c2a0:	68fb      	ldr	r3, [r7, #12]
 801c2a2:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
 801c2a6:	461a      	mov	r2, r3
 801c2a8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801c2aa:	4293      	cmp	r3, r2
 801c2ac:	db06      	blt.n	801c2bc <l2cap_acl_classic_handler_for_channel+0x1b0>
                                index -= l2cap_channel->num_rx_buffers;
 801c2ae:	68fb      	ldr	r3, [r7, #12]
 801c2b0:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
 801c2b4:	461a      	mov	r2, r3
 801c2b6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801c2b8:	1a9b      	subs	r3, r3, r2
 801c2ba:	657b      	str	r3, [r7, #84]	; 0x54
                            }
                            l2cap_ertm_rx_packet_state_t * rx_state = &l2cap_channel->rx_packets_state[index];
 801c2bc:	68fb      	ldr	r3, [r7, #12]
 801c2be:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
 801c2c2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801c2c4:	4613      	mov	r3, r2
 801c2c6:	005b      	lsls	r3, r3, #1
 801c2c8:	4413      	add	r3, r2
 801c2ca:	005b      	lsls	r3, r3, #1
 801c2cc:	440b      	add	r3, r1
 801c2ce:	617b      	str	r3, [r7, #20]
                            if (!rx_state->valid) continue;
 801c2d0:	697b      	ldr	r3, [r7, #20]
 801c2d2:	791b      	ldrb	r3, [r3, #4]
 801c2d4:	2b00      	cmp	r3, #0
 801c2d6:	d003      	beq.n	801c2e0 <l2cap_acl_classic_handler_for_channel+0x1d4>
                            num_stored_out_of_order_packets++;
 801c2d8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801c2da:	3301      	adds	r3, #1
 801c2dc:	65bb      	str	r3, [r7, #88]	; 0x58
 801c2de:	e000      	b.n	801c2e2 <l2cap_acl_classic_handler_for_channel+0x1d6>
                            if (!rx_state->valid) continue;
 801c2e0:	bf00      	nop
                        for (i=0;i<l2cap_channel->num_rx_buffers;i++){
 801c2e2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801c2e4:	3301      	adds	r3, #1
 801c2e6:	65fb      	str	r3, [r7, #92]	; 0x5c
 801c2e8:	68fb      	ldr	r3, [r7, #12]
 801c2ea:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
 801c2ee:	461a      	mov	r2, r3
 801c2f0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801c2f2:	4293      	cmp	r3, r2
 801c2f4:	dbcd      	blt.n	801c292 <l2cap_acl_classic_handler_for_channel+0x186>
                        }
                        if (num_stored_out_of_order_packets){
 801c2f6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801c2f8:	2b00      	cmp	r3, #0
 801c2fa:	d004      	beq.n	801c306 <l2cap_acl_classic_handler_for_channel+0x1fa>
                            l2cap_channel->send_supervisor_frame_selective_reject = 1;
 801c2fc:	68fb      	ldr	r3, [r7, #12]
 801c2fe:	2201      	movs	r2, #1
 801c300:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
 801c304:	e003      	b.n	801c30e <l2cap_acl_classic_handler_for_channel+0x202>
                        } else {
                            l2cap_channel->send_supervisor_frame_receiver_ready   = 1;
 801c306:	68fb      	ldr	r3, [r7, #12]
 801c308:	2201      	movs	r2, #1
 801c30a:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
                        }
                        l2cap_channel->set_final_bit_after_packet_with_poll_bit_set = 1;
 801c30e:	68fb      	ldr	r3, [r7, #12]
 801c310:	2201      	movs	r2, #1
 801c312:	f883 209b 	strb.w	r2, [r3, #155]	; 0x9b
                    }
                    if (final){
 801c316:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c318:	2b00      	cmp	r3, #0
 801c31a:	f000 81ad 	beq.w	801c678 <l2cap_acl_classic_handler_for_channel+0x56c>
                        // Stop-MonitorTimer
                        l2cap_ertm_stop_monitor_timer(l2cap_channel);
 801c31e:	68f8      	ldr	r0, [r7, #12]
 801c320:	f7fb fc7a 	bl	8017c18 <l2cap_ertm_stop_monitor_timer>
                        // If UnackedFrames > 0 then Start-RetransTimer
                        if (l2cap_channel->unacked_frames){
 801c324:	68fb      	ldr	r3, [r7, #12]
 801c326:	f893 308b 	ldrb.w	r3, [r3, #139]	; 0x8b
 801c32a:	2b00      	cmp	r3, #0
 801c32c:	d002      	beq.n	801c334 <l2cap_acl_classic_handler_for_channel+0x228>
                            l2cap_ertm_start_retransmission_timer(l2cap_channel);
 801c32e:	68f8      	ldr	r0, [r7, #12]
 801c330:	f7fb fc8a 	bl	8017c48 <l2cap_ertm_start_retransmission_timer>
                        }
                        // final bit set <- response to RR with poll bit set. All not acknowledged packets need to be retransmitted
                        l2cap_ertm_retransmit_unacknowleded_frames(l2cap_channel);
 801c334:	68f8      	ldr	r0, [r7, #12]
 801c336:	f7fb fc1b 	bl	8017b70 <l2cap_ertm_retransmit_unacknowleded_frames>
                    }
                    break;
 801c33a:	e19d      	b.n	801c678 <l2cap_acl_classic_handler_for_channel+0x56c>
                case L2CAP_SUPERVISORY_FUNCTION_REJ_REJECT:
                    log_info("L2CAP_SUPERVISORY_FUNCTION_REJ_REJECT");
 801c33c:	f640 5399 	movw	r3, #3481	; 0xd99
 801c340:	4a24      	ldr	r2, [pc, #144]	; (801c3d4 <l2cap_acl_classic_handler_for_channel+0x2c8>)
 801c342:	492a      	ldr	r1, [pc, #168]	; (801c3ec <l2cap_acl_classic_handler_for_channel+0x2e0>)
 801c344:	2001      	movs	r0, #1
 801c346:	f7fb f87b 	bl	8017440 <hci_dump_log>
                    l2cap_ertm_process_req_seq(l2cap_channel, req_seq);
 801c34a:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801c34e:	4619      	mov	r1, r3
 801c350:	68f8      	ldr	r0, [r7, #12]
 801c352:	f7fb fefd 	bl	8018150 <l2cap_ertm_process_req_seq>
                    // restart transmittion from last unacknowledted packet (earlier packets already freed in l2cap_ertm_process_req_seq)
                    l2cap_ertm_retransmit_unacknowleded_frames(l2cap_channel);
 801c356:	68f8      	ldr	r0, [r7, #12]
 801c358:	f7fb fc0a 	bl	8017b70 <l2cap_ertm_retransmit_unacknowleded_frames>
                    break;
 801c35c:	e18f      	b.n	801c67e <l2cap_acl_classic_handler_for_channel+0x572>
                case L2CAP_SUPERVISORY_FUNCTION_RNR_RECEIVER_NOT_READY:
                    log_error("L2CAP_SUPERVISORY_FUNCTION_RNR_RECEIVER_NOT_READY");
 801c35e:	f640 539f 	movw	r3, #3487	; 0xd9f
 801c362:	4a1c      	ldr	r2, [pc, #112]	; (801c3d4 <l2cap_acl_classic_handler_for_channel+0x2c8>)
 801c364:	4922      	ldr	r1, [pc, #136]	; (801c3f0 <l2cap_acl_classic_handler_for_channel+0x2e4>)
 801c366:	2002      	movs	r0, #2
 801c368:	f7fb f86a 	bl	8017440 <hci_dump_log>
                    break;
 801c36c:	e187      	b.n	801c67e <l2cap_acl_classic_handler_for_channel+0x572>
                case L2CAP_SUPERVISORY_FUNCTION_SREJ_SELECTIVE_REJECT:
                    log_info("L2CAP_SUPERVISORY_FUNCTION_SREJ_SELECTIVE_REJECT");
 801c36e:	f640 53a2 	movw	r3, #3490	; 0xda2
 801c372:	4a18      	ldr	r2, [pc, #96]	; (801c3d4 <l2cap_acl_classic_handler_for_channel+0x2c8>)
 801c374:	491f      	ldr	r1, [pc, #124]	; (801c3f4 <l2cap_acl_classic_handler_for_channel+0x2e8>)
 801c376:	2001      	movs	r0, #1
 801c378:	f7fb f862 	bl	8017440 <hci_dump_log>
                    if (poll){
 801c37c:	6a3b      	ldr	r3, [r7, #32]
 801c37e:	2b00      	cmp	r3, #0
 801c380:	d005      	beq.n	801c38e <l2cap_acl_classic_handler_for_channel+0x282>
                        l2cap_ertm_process_req_seq(l2cap_channel, req_seq);
 801c382:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801c386:	4619      	mov	r1, r3
 801c388:	68f8      	ldr	r0, [r7, #12]
 801c38a:	f7fb fee1 	bl	8018150 <l2cap_ertm_process_req_seq>
                    }
                    // find requested i-frame
                    tx_state = l2cap_ertm_get_tx_state(l2cap_channel, req_seq);
 801c38e:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801c392:	4619      	mov	r1, r3
 801c394:	68f8      	ldr	r0, [r7, #12]
 801c396:	f7fb ff6d 	bl	8018274 <l2cap_ertm_get_tx_state>
 801c39a:	61b8      	str	r0, [r7, #24]
                    if (tx_state){
 801c39c:	69bb      	ldr	r3, [r7, #24]
 801c39e:	2b00      	cmp	r3, #0
 801c3a0:	f000 816c 	beq.w	801c67c <l2cap_acl_classic_handler_for_channel+0x570>
                        log_info("Retransmission for tx_seq %u requested", req_seq);
 801c3a4:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801c3a8:	9300      	str	r3, [sp, #0]
 801c3aa:	f640 53a9 	movw	r3, #3497	; 0xda9
 801c3ae:	4a09      	ldr	r2, [pc, #36]	; (801c3d4 <l2cap_acl_classic_handler_for_channel+0x2c8>)
 801c3b0:	4911      	ldr	r1, [pc, #68]	; (801c3f8 <l2cap_acl_classic_handler_for_channel+0x2ec>)
 801c3b2:	2001      	movs	r0, #1
 801c3b4:	f7fb f844 	bl	8017440 <hci_dump_log>
                        l2cap_channel->set_final_bit_after_packet_with_poll_bit_set = poll;
 801c3b8:	6a3b      	ldr	r3, [r7, #32]
 801c3ba:	b2da      	uxtb	r2, r3
 801c3bc:	68fb      	ldr	r3, [r7, #12]
 801c3be:	f883 209b 	strb.w	r2, [r3, #155]	; 0x9b
                        tx_state->retransmission_requested = 1;
 801c3c2:	69bb      	ldr	r3, [r7, #24]
 801c3c4:	2201      	movs	r2, #1
 801c3c6:	719a      	strb	r2, [r3, #6]
                        l2cap_channel->srej_active = 1;
 801c3c8:	68fb      	ldr	r3, [r7, #12]
 801c3ca:	2201      	movs	r2, #1
 801c3cc:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
                    }
                    break;
 801c3d0:	e154      	b.n	801c67c <l2cap_acl_classic_handler_for_channel+0x570>
 801c3d2:	bf00      	nop
 801c3d4:	0802b1dc 	.word	0x0802b1dc
 801c3d8:	0802c25c 	.word	0x0802c25c
 801c3dc:	0802c280 	.word	0x0802c280
 801c3e0:	0802c2b8 	.word	0x0802c2b8
 801c3e4:	0802c2f8 	.word	0x0802c2f8
 801c3e8:	0802c32c 	.word	0x0802c32c
 801c3ec:	0802c344 	.word	0x0802c344
 801c3f0:	0802c374 	.word	0x0802c374
 801c3f4:	0802c3b0 	.word	0x0802c3b0
 801c3f8:	0802c3e8 	.word	0x0802c3e8
                    break;
            }
        } else {
            // I-Frame
            // get control
            l2cap_segmentation_and_reassembly_t sar = (l2cap_segmentation_and_reassembly_t) (control >> 14);
 801c3fc:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801c3fe:	0b9b      	lsrs	r3, r3, #14
 801c400:	b29b      	uxth	r3, r3
 801c402:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
            uint8_t tx_seq = (control >> 1) & 0x3f;
 801c406:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801c408:	085b      	lsrs	r3, r3, #1
 801c40a:	b29b      	uxth	r3, r3
 801c40c:	b2db      	uxtb	r3, r3
 801c40e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801c412:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
            log_info("Control: 0x%04x => SAR %u, ReqSeq %02u, R?, TxSeq %02u", control, (int) sar, req_seq, tx_seq);
 801c416:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801c418:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 801c41c:	f897 103d 	ldrb.w	r1, [r7, #61]	; 0x3d
 801c420:	f897 0036 	ldrb.w	r0, [r7, #54]	; 0x36
 801c424:	9003      	str	r0, [sp, #12]
 801c426:	9102      	str	r1, [sp, #8]
 801c428:	9201      	str	r2, [sp, #4]
 801c42a:	9300      	str	r3, [sp, #0]
 801c42c:	f640 53b7 	movw	r3, #3511	; 0xdb7
 801c430:	4aa1      	ldr	r2, [pc, #644]	; (801c6b8 <l2cap_acl_classic_handler_for_channel+0x5ac>)
 801c432:	49a2      	ldr	r1, [pc, #648]	; (801c6bc <l2cap_acl_classic_handler_for_channel+0x5b0>)
 801c434:	2001      	movs	r0, #1
 801c436:	f7fb f803 	bl	8017440 <hci_dump_log>
            log_info("SAR: pos %u", l2cap_channel->reassembly_pos);
 801c43a:	68fb      	ldr	r3, [r7, #12]
 801c43c:	f8b3 30a4 	ldrh.w	r3, [r3, #164]	; 0xa4
 801c440:	9300      	str	r3, [sp, #0]
 801c442:	f640 53b8 	movw	r3, #3512	; 0xdb8
 801c446:	4a9c      	ldr	r2, [pc, #624]	; (801c6b8 <l2cap_acl_classic_handler_for_channel+0x5ac>)
 801c448:	499d      	ldr	r1, [pc, #628]	; (801c6c0 <l2cap_acl_classic_handler_for_channel+0x5b4>)
 801c44a:	2001      	movs	r0, #1
 801c44c:	f7fa fff8 	bl	8017440 <hci_dump_log>
            log_info("State: expected_tx_seq %02u, req_seq %02u", l2cap_channel->expected_tx_seq, l2cap_channel->req_seq);
 801c450:	68fb      	ldr	r3, [r7, #12]
 801c452:	f893 3093 	ldrb.w	r3, [r3, #147]	; 0x93
 801c456:	461a      	mov	r2, r3
 801c458:	68fb      	ldr	r3, [r7, #12]
 801c45a:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 801c45e:	9301      	str	r3, [sp, #4]
 801c460:	9200      	str	r2, [sp, #0]
 801c462:	f640 53b9 	movw	r3, #3513	; 0xdb9
 801c466:	4a94      	ldr	r2, [pc, #592]	; (801c6b8 <l2cap_acl_classic_handler_for_channel+0x5ac>)
 801c468:	4996      	ldr	r1, [pc, #600]	; (801c6c4 <l2cap_acl_classic_handler_for_channel+0x5b8>)
 801c46a:	2001      	movs	r0, #1
 801c46c:	f7fa ffe8 	bl	8017440 <hci_dump_log>
            l2cap_ertm_process_req_seq(l2cap_channel, req_seq);
 801c470:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801c474:	4619      	mov	r1, r3
 801c476:	68f8      	ldr	r0, [r7, #12]
 801c478:	f7fb fe6a 	bl	8018150 <l2cap_ertm_process_req_seq>
            if (final){
 801c47c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c47e:	2b00      	cmp	r3, #0
 801c480:	d002      	beq.n	801c488 <l2cap_acl_classic_handler_for_channel+0x37c>
                // final bit set <- response to RR with poll bit set. All not acknowledged packets need to be retransmitted
                l2cap_ertm_retransmit_unacknowleded_frames(l2cap_channel);
 801c482:	68f8      	ldr	r0, [r7, #12]
 801c484:	f7fb fb74 	bl	8017b70 <l2cap_ertm_retransmit_unacknowleded_frames>
            }

            // get SDU
            const uint8_t * payload_data = &packet[COMPLETE_L2CAP_HEADER+2];
 801c488:	68bb      	ldr	r3, [r7, #8]
 801c48a:	330a      	adds	r3, #10
 801c48c:	633b      	str	r3, [r7, #48]	; 0x30
            uint16_t        payload_len  = size-(COMPLETE_L2CAP_HEADER+2+fcs_size);
 801c48e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c490:	b29b      	uxth	r3, r3
 801c492:	88fa      	ldrh	r2, [r7, #6]
 801c494:	1ad3      	subs	r3, r2, r3
 801c496:	b29b      	uxth	r3, r3
 801c498:	3b0a      	subs	r3, #10
 801c49a:	85fb      	strh	r3, [r7, #46]	; 0x2e

            // assert SDU size is smaller or equal to our buffers
            uint16_t max_payload_size = 0;
 801c49c:	2300      	movs	r3, #0
 801c49e:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            switch (sar){
 801c4a2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801c4a6:	2b03      	cmp	r3, #3
 801c4a8:	d817      	bhi.n	801c4da <l2cap_acl_classic_handler_for_channel+0x3ce>
 801c4aa:	a201      	add	r2, pc, #4	; (adr r2, 801c4b0 <l2cap_acl_classic_handler_for_channel+0x3a4>)
 801c4ac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c4b0:	0801c4c1 	.word	0x0801c4c1
 801c4b4:	0801c4c1 	.word	0x0801c4c1
 801c4b8:	0801c4cf 	.word	0x0801c4cf
 801c4bc:	0801c4cf 	.word	0x0801c4cf
                case L2CAP_SEGMENTATION_AND_REASSEMBLY_UNSEGMENTED_L2CAP_SDU:
                case L2CAP_SEGMENTATION_AND_REASSEMBLY_START_OF_L2CAP_SDU:
                    // SDU Length + MPS
                    max_payload_size = l2cap_channel->local_mps + 2;
 801c4c0:	68fb      	ldr	r3, [r7, #12]
 801c4c2:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 801c4c6:	3302      	adds	r3, #2
 801c4c8:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                    break;
 801c4cc:	e006      	b.n	801c4dc <l2cap_acl_classic_handler_for_channel+0x3d0>
                case L2CAP_SEGMENTATION_AND_REASSEMBLY_CONTINUATION_OF_L2CAP_SDU:
                case L2CAP_SEGMENTATION_AND_REASSEMBLY_END_OF_L2CAP_SDU:
                    max_payload_size = l2cap_channel->local_mps;
 801c4ce:	68fb      	ldr	r3, [r7, #12]
 801c4d0:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 801c4d4:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                    break;
 801c4d8:	e000      	b.n	801c4dc <l2cap_acl_classic_handler_for_channel+0x3d0>
                default:
                    btstack_assert(false);
                    break;
 801c4da:	bf00      	nop
            }
            if (payload_len > max_payload_size){
 801c4dc:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801c4de:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 801c4e2:	429a      	cmp	r2, r3
 801c4e4:	d90c      	bls.n	801c500 <l2cap_acl_classic_handler_for_channel+0x3f4>
                log_info("payload len %u > max payload %u -> drop packet", payload_len, max_payload_size);
 801c4e6:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801c4e8:	f8b7 2052 	ldrh.w	r2, [r7, #82]	; 0x52
 801c4ec:	9201      	str	r2, [sp, #4]
 801c4ee:	9300      	str	r3, [sp, #0]
 801c4f0:	f640 53d5 	movw	r3, #3541	; 0xdd5
 801c4f4:	4a70      	ldr	r2, [pc, #448]	; (801c6b8 <l2cap_acl_classic_handler_for_channel+0x5ac>)
 801c4f6:	4974      	ldr	r1, [pc, #464]	; (801c6c8 <l2cap_acl_classic_handler_for_channel+0x5bc>)
 801c4f8:	2001      	movs	r0, #1
 801c4fa:	f7fa ffa1 	bl	8017440 <hci_dump_log>
                return;
 801c4fe:	e0d8      	b.n	801c6b2 <l2cap_acl_classic_handler_for_channel+0x5a6>
            }

            // check ordering
            if (l2cap_channel->expected_tx_seq == tx_seq){
 801c500:	68fb      	ldr	r3, [r7, #12]
 801c502:	f893 3093 	ldrb.w	r3, [r3, #147]	; 0x93
 801c506:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
 801c50a:	429a      	cmp	r2, r3
 801c50c:	d176      	bne.n	801c5fc <l2cap_acl_classic_handler_for_channel+0x4f0>
                log_info("Received expected frame with TxSeq == ExpectedTxSeq == %02u", tx_seq);
 801c50e:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801c512:	9300      	str	r3, [sp, #0]
 801c514:	f640 53db 	movw	r3, #3547	; 0xddb
 801c518:	4a67      	ldr	r2, [pc, #412]	; (801c6b8 <l2cap_acl_classic_handler_for_channel+0x5ac>)
 801c51a:	496c      	ldr	r1, [pc, #432]	; (801c6cc <l2cap_acl_classic_handler_for_channel+0x5c0>)
 801c51c:	2001      	movs	r0, #1
 801c51e:	f7fa ff8f 	bl	8017440 <hci_dump_log>
                l2cap_channel->expected_tx_seq = l2cap_next_ertm_seq_nr(l2cap_channel->expected_tx_seq);
 801c522:	68fb      	ldr	r3, [r7, #12]
 801c524:	f893 3093 	ldrb.w	r3, [r3, #147]	; 0x93
 801c528:	4618      	mov	r0, r3
 801c52a:	f7fb fadc 	bl	8017ae6 <l2cap_next_ertm_seq_nr>
 801c52e:	4603      	mov	r3, r0
 801c530:	b2da      	uxtb	r2, r3
 801c532:	68fb      	ldr	r3, [r7, #12]
 801c534:	f883 2093 	strb.w	r2, [r3, #147]	; 0x93
                l2cap_channel->req_seq         = l2cap_channel->expected_tx_seq;
 801c538:	68fb      	ldr	r3, [r7, #12]
 801c53a:	f893 2093 	ldrb.w	r2, [r3, #147]	; 0x93
 801c53e:	68fb      	ldr	r3, [r7, #12]
 801c540:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94

                // process SDU
                l2cap_ertm_handle_in_sequence_sdu(l2cap_channel, sar, payload_data, payload_len);
 801c544:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801c546:	f897 1037 	ldrb.w	r1, [r7, #55]	; 0x37
 801c54a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801c54c:	68f8      	ldr	r0, [r7, #12]
 801c54e:	f7fb ff1f 	bl	8018390 <l2cap_ertm_handle_in_sequence_sdu>

                // process stored segments
                while (true){
                    int index = l2cap_channel->rx_store_index;
 801c552:	68fb      	ldr	r3, [r7, #12]
 801c554:	f893 3092 	ldrb.w	r3, [r3, #146]	; 0x92
 801c558:	64fb      	str	r3, [r7, #76]	; 0x4c
                    l2cap_ertm_rx_packet_state_t * rx_state = &l2cap_channel->rx_packets_state[index];
 801c55a:	68fb      	ldr	r3, [r7, #12]
 801c55c:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
 801c560:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c562:	4613      	mov	r3, r2
 801c564:	005b      	lsls	r3, r3, #1
 801c566:	4413      	add	r3, r2
 801c568:	005b      	lsls	r3, r3, #1
 801c56a:	440b      	add	r3, r1
 801c56c:	627b      	str	r3, [r7, #36]	; 0x24
                    if (!rx_state->valid) break;
 801c56e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c570:	791b      	ldrb	r3, [r3, #4]
 801c572:	2b00      	cmp	r3, #0
 801c574:	d03c      	beq.n	801c5f0 <l2cap_acl_classic_handler_for_channel+0x4e4>

                    log_info("Processing stored frame with TxSeq == ExpectedTxSeq == %02u", l2cap_channel->expected_tx_seq);
 801c576:	68fb      	ldr	r3, [r7, #12]
 801c578:	f893 3093 	ldrb.w	r3, [r3, #147]	; 0x93
 801c57c:	9300      	str	r3, [sp, #0]
 801c57e:	f640 53e8 	movw	r3, #3560	; 0xde8
 801c582:	4a4d      	ldr	r2, [pc, #308]	; (801c6b8 <l2cap_acl_classic_handler_for_channel+0x5ac>)
 801c584:	4952      	ldr	r1, [pc, #328]	; (801c6d0 <l2cap_acl_classic_handler_for_channel+0x5c4>)
 801c586:	2001      	movs	r0, #1
 801c588:	f7fa ff5a 	bl	8017440 <hci_dump_log>
                    l2cap_channel->expected_tx_seq = l2cap_next_ertm_seq_nr(l2cap_channel->expected_tx_seq);
 801c58c:	68fb      	ldr	r3, [r7, #12]
 801c58e:	f893 3093 	ldrb.w	r3, [r3, #147]	; 0x93
 801c592:	4618      	mov	r0, r3
 801c594:	f7fb faa7 	bl	8017ae6 <l2cap_next_ertm_seq_nr>
 801c598:	4603      	mov	r3, r0
 801c59a:	b2da      	uxtb	r2, r3
 801c59c:	68fb      	ldr	r3, [r7, #12]
 801c59e:	f883 2093 	strb.w	r2, [r3, #147]	; 0x93
                    l2cap_channel->req_seq         = l2cap_channel->expected_tx_seq;
 801c5a2:	68fb      	ldr	r3, [r7, #12]
 801c5a4:	f893 2093 	ldrb.w	r2, [r3, #147]	; 0x93
 801c5a8:	68fb      	ldr	r3, [r7, #12]
 801c5aa:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94

                    rx_state->valid = 0;
 801c5ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c5b0:	2200      	movs	r2, #0
 801c5b2:	711a      	strb	r2, [r3, #4]
                    l2cap_ertm_handle_in_sequence_sdu(l2cap_channel, rx_state->sar, &l2cap_channel->rx_packets_data[index], rx_state->len);
 801c5b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c5b6:	7819      	ldrb	r1, [r3, #0]
 801c5b8:	68fb      	ldr	r3, [r7, #12]
 801c5ba:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 801c5be:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c5c0:	441a      	add	r2, r3
 801c5c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c5c4:	885b      	ldrh	r3, [r3, #2]
 801c5c6:	68f8      	ldr	r0, [r7, #12]
 801c5c8:	f7fb fee2 	bl	8018390 <l2cap_ertm_handle_in_sequence_sdu>

                    // update rx store index
                    index++;
 801c5cc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c5ce:	3301      	adds	r3, #1
 801c5d0:	64fb      	str	r3, [r7, #76]	; 0x4c
                    if (index >= l2cap_channel->num_rx_buffers){
 801c5d2:	68fb      	ldr	r3, [r7, #12]
 801c5d4:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
 801c5d8:	461a      	mov	r2, r3
 801c5da:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c5dc:	4293      	cmp	r3, r2
 801c5de:	db01      	blt.n	801c5e4 <l2cap_acl_classic_handler_for_channel+0x4d8>
                        index = 0;
 801c5e0:	2300      	movs	r3, #0
 801c5e2:	64fb      	str	r3, [r7, #76]	; 0x4c
                    }
                    l2cap_channel->rx_store_index = index;
 801c5e4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c5e6:	b2da      	uxtb	r2, r3
 801c5e8:	68fb      	ldr	r3, [r7, #12]
 801c5ea:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
                while (true){
 801c5ee:	e7b0      	b.n	801c552 <l2cap_acl_classic_handler_for_channel+0x446>
                    if (!rx_state->valid) break;
 801c5f0:	bf00      	nop
                }

                //
                l2cap_channel->send_supervisor_frame_receiver_ready = 1;
 801c5f2:	68fb      	ldr	r3, [r7, #12]
 801c5f4:	2201      	movs	r2, #1
 801c5f6:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
                    log_info("Received unexpected frame TxSeq %u but expected %u -> send S-REJ", tx_seq, l2cap_channel->expected_tx_seq);
                    l2cap_channel->send_supervisor_frame_reject = 1;
                }
            }
        }
        return;
 801c5fa:	e05a      	b.n	801c6b2 <l2cap_acl_classic_handler_for_channel+0x5a6>
                int delta = (tx_seq - l2cap_channel->expected_tx_seq) & 0x3f;
 801c5fc:	68fb      	ldr	r3, [r7, #12]
 801c5fe:	f893 3093 	ldrb.w	r3, [r3, #147]	; 0x93
 801c602:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
 801c606:	1ad3      	subs	r3, r2, r3
 801c608:	b2db      	uxtb	r3, r3
 801c60a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801c60e:	62bb      	str	r3, [r7, #40]	; 0x28
                if (delta < 2){
 801c610:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c612:	2b01      	cmp	r3, #1
 801c614:	dc1b      	bgt.n	801c64e <l2cap_acl_classic_handler_for_channel+0x542>
                    l2cap_ertm_handle_out_of_sequence_sdu(l2cap_channel, sar, delta, payload_data, payload_len);
 801c616:	f897 1037 	ldrb.w	r1, [r7, #55]	; 0x37
 801c61a:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801c61c:	9300      	str	r3, [sp, #0]
 801c61e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c620:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801c622:	68f8      	ldr	r0, [r7, #12]
 801c624:	f7fb fe4e 	bl	80182c4 <l2cap_ertm_handle_out_of_sequence_sdu>
                    log_info("Received unexpected frame TxSeq %u but expected %u -> send S-SREJ", tx_seq, l2cap_channel->expected_tx_seq);
 801c628:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801c62c:	68fa      	ldr	r2, [r7, #12]
 801c62e:	f892 2093 	ldrb.w	r2, [r2, #147]	; 0x93
 801c632:	9201      	str	r2, [sp, #4]
 801c634:	9300      	str	r3, [sp, #0]
 801c636:	f44f 6360 	mov.w	r3, #3584	; 0xe00
 801c63a:	4a1f      	ldr	r2, [pc, #124]	; (801c6b8 <l2cap_acl_classic_handler_for_channel+0x5ac>)
 801c63c:	4925      	ldr	r1, [pc, #148]	; (801c6d4 <l2cap_acl_classic_handler_for_channel+0x5c8>)
 801c63e:	2001      	movs	r0, #1
 801c640:	f7fa fefe 	bl	8017440 <hci_dump_log>
                    l2cap_channel->send_supervisor_frame_selective_reject = 1;
 801c644:	68fb      	ldr	r3, [r7, #12]
 801c646:	2201      	movs	r2, #1
 801c648:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
        return;
 801c64c:	e031      	b.n	801c6b2 <l2cap_acl_classic_handler_for_channel+0x5a6>
                    log_info("Received unexpected frame TxSeq %u but expected %u -> send S-REJ", tx_seq, l2cap_channel->expected_tx_seq);
 801c64e:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801c652:	68fa      	ldr	r2, [r7, #12]
 801c654:	f892 2093 	ldrb.w	r2, [r2, #147]	; 0x93
 801c658:	9201      	str	r2, [sp, #4]
 801c65a:	9300      	str	r3, [sp, #0]
 801c65c:	f640 6303 	movw	r3, #3587	; 0xe03
 801c660:	4a15      	ldr	r2, [pc, #84]	; (801c6b8 <l2cap_acl_classic_handler_for_channel+0x5ac>)
 801c662:	491d      	ldr	r1, [pc, #116]	; (801c6d8 <l2cap_acl_classic_handler_for_channel+0x5cc>)
 801c664:	2001      	movs	r0, #1
 801c666:	f7fa feeb 	bl	8017440 <hci_dump_log>
                    l2cap_channel->send_supervisor_frame_reject = 1;
 801c66a:	68fb      	ldr	r3, [r7, #12]
 801c66c:	2201      	movs	r2, #1
 801c66e:	f883 2099 	strb.w	r2, [r3, #153]	; 0x99
        return;
 801c672:	e01e      	b.n	801c6b2 <l2cap_acl_classic_handler_for_channel+0x5a6>
                    break;
 801c674:	bf00      	nop
 801c676:	e01c      	b.n	801c6b2 <l2cap_acl_classic_handler_for_channel+0x5a6>
                    break;
 801c678:	bf00      	nop
 801c67a:	e01a      	b.n	801c6b2 <l2cap_acl_classic_handler_for_channel+0x5a6>
                    break;
 801c67c:	bf00      	nop
        return;
 801c67e:	e018      	b.n	801c6b2 <l2cap_acl_classic_handler_for_channel+0x5a6>
    }
#endif

    // check size
    uint16_t payload_size = size - COMPLETE_L2CAP_HEADER;
 801c680:	88fb      	ldrh	r3, [r7, #6]
 801c682:	3b08      	subs	r3, #8
 801c684:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    if (l2cap_channel->local_mtu < payload_size) return;
 801c688:	68fb      	ldr	r3, [r7, #12]
 801c68a:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 801c68c:	f8b7 204a 	ldrh.w	r2, [r7, #74]	; 0x4a
 801c690:	429a      	cmp	r2, r3
 801c692:	d80d      	bhi.n	801c6b0 <l2cap_acl_classic_handler_for_channel+0x5a4>

    l2cap_dispatch_to_channel(l2cap_channel, L2CAP_DATA_PACKET, &packet[COMPLETE_L2CAP_HEADER], payload_size);
 801c694:	68bb      	ldr	r3, [r7, #8]
 801c696:	f103 0208 	add.w	r2, r3, #8
 801c69a:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 801c69e:	2106      	movs	r1, #6
 801c6a0:	68f8      	ldr	r0, [r7, #12]
 801c6a2:	f7fc f908 	bl	80188b6 <l2cap_dispatch_to_channel>
 801c6a6:	e004      	b.n	801c6b2 <l2cap_acl_classic_handler_for_channel+0x5a6>
    if (l2cap_channel->state != L2CAP_STATE_OPEN) return;
 801c6a8:	bf00      	nop
 801c6aa:	e002      	b.n	801c6b2 <l2cap_acl_classic_handler_for_channel+0x5a6>
        if (size < COMPLETE_L2CAP_HEADER+2+fcs_size) return;
 801c6ac:	bf00      	nop
 801c6ae:	e000      	b.n	801c6b2 <l2cap_acl_classic_handler_for_channel+0x5a6>
    if (l2cap_channel->local_mtu < payload_size) return;
 801c6b0:	bf00      	nop
}
 801c6b2:	3760      	adds	r7, #96	; 0x60
 801c6b4:	46bd      	mov	sp, r7
 801c6b6:	bd80      	pop	{r7, pc}
 801c6b8:	0802b1dc 	.word	0x0802b1dc
 801c6bc:	0802c418 	.word	0x0802c418
 801c6c0:	0802c458 	.word	0x0802c458
 801c6c4:	0802c46c 	.word	0x0802c46c
 801c6c8:	0802c4a0 	.word	0x0802c4a0
 801c6cc:	0802c4d8 	.word	0x0802c4d8
 801c6d0:	0802c51c 	.word	0x0802c51c
 801c6d4:	0802c560 	.word	0x0802c560
 801c6d8:	0802c5ac 	.word	0x0802c5ac

0801c6dc <l2cap_acl_classic_handler>:
#endif

static void l2cap_acl_classic_handler(hci_con_handle_t handle, uint8_t *packet, uint16_t size){
 801c6dc:	b590      	push	{r4, r7, lr}
 801c6de:	b089      	sub	sp, #36	; 0x24
 801c6e0:	af00      	add	r7, sp, #0
 801c6e2:	4603      	mov	r3, r0
 801c6e4:	6039      	str	r1, [r7, #0]
 801c6e6:	80fb      	strh	r3, [r7, #6]
 801c6e8:	4613      	mov	r3, r2
 801c6ea:	80bb      	strh	r3, [r7, #4]
#ifdef ENABLE_CLASSIC
    l2cap_channel_t * l2cap_channel;
    l2cap_fixed_channel_t * l2cap_fixed_channel;

    uint16_t channel_id = READ_L2CAP_CHANNEL_ID(packet);
 801c6ec:	2106      	movs	r1, #6
 801c6ee:	6838      	ldr	r0, [r7, #0]
 801c6f0:	f7f2 fb79 	bl	800ede6 <little_endian_read_16>
 801c6f4:	4603      	mov	r3, r0
 801c6f6:	837b      	strh	r3, [r7, #26]
    uint8_t  broadcast_flag = READ_ACL_FLAGS(packet) >> 2;
 801c6f8:	683b      	ldr	r3, [r7, #0]
 801c6fa:	3301      	adds	r3, #1
 801c6fc:	781b      	ldrb	r3, [r3, #0]
 801c6fe:	099b      	lsrs	r3, r3, #6
 801c700:	767b      	strb	r3, [r7, #25]
    switch (channel_id) {
 801c702:	8b7b      	ldrh	r3, [r7, #26]
 801c704:	2b01      	cmp	r3, #1
 801c706:	d002      	beq.n	801c70e <l2cap_acl_classic_handler+0x32>
 801c708:	2b02      	cmp	r3, #2
 801c70a:	d030      	beq.n	801c76e <l2cap_acl_classic_handler+0x92>
 801c70c:	e049      	b.n	801c7a2 <l2cap_acl_classic_handler+0xc6>
            
        case L2CAP_CID_SIGNALING: {
            if (broadcast_flag != 0) break;
 801c70e:	7e7b      	ldrb	r3, [r7, #25]
 801c710:	2b00      	cmp	r3, #0
 801c712:	d15a      	bne.n	801c7ca <l2cap_acl_classic_handler+0xee>
            uint32_t command_offset = 8;
 801c714:	2308      	movs	r3, #8
 801c716:	61fb      	str	r3, [r7, #28]
            while ((command_offset + L2CAP_SIGNALING_COMMAND_DATA_OFFSET) < size) {
 801c718:	e023      	b.n	801c762 <l2cap_acl_classic_handler+0x86>
                // assert signaling command is fully inside packet
                uint16_t data_len = little_endian_read_16(packet, command_offset + L2CAP_SIGNALING_COMMAND_LENGTH_OFFSET);
 801c71a:	69fb      	ldr	r3, [r7, #28]
 801c71c:	3302      	adds	r3, #2
 801c71e:	4619      	mov	r1, r3
 801c720:	6838      	ldr	r0, [r7, #0]
 801c722:	f7f2 fb60 	bl	800ede6 <little_endian_read_16>
 801c726:	4603      	mov	r3, r0
 801c728:	827b      	strh	r3, [r7, #18]
                uint32_t next_command_offset = command_offset + L2CAP_SIGNALING_COMMAND_DATA_OFFSET + data_len;
 801c72a:	8a7a      	ldrh	r2, [r7, #18]
 801c72c:	69fb      	ldr	r3, [r7, #28]
 801c72e:	4413      	add	r3, r2
 801c730:	3304      	adds	r3, #4
 801c732:	60fb      	str	r3, [r7, #12]
                if (next_command_offset > size){
 801c734:	88bb      	ldrh	r3, [r7, #4]
 801c736:	68fa      	ldr	r2, [r7, #12]
 801c738:	429a      	cmp	r2, r3
 801c73a:	d908      	bls.n	801c74e <l2cap_acl_classic_handler+0x72>
                    log_error("l2cap signaling command len invalid -> drop");
 801c73c:	f640 6325 	movw	r3, #3621	; 0xe25
 801c740:	4a29      	ldr	r2, [pc, #164]	; (801c7e8 <l2cap_acl_classic_handler+0x10c>)
 801c742:	492a      	ldr	r1, [pc, #168]	; (801c7ec <l2cap_acl_classic_handler+0x110>)
 801c744:	2002      	movs	r0, #2
 801c746:	f7fa fe7b 	bl	8017440 <hci_dump_log>
                    break;
 801c74a:	bf00      	nop
                // handle signaling command
                l2cap_signaling_handler_dispatch(handle, &packet[command_offset]);
                // go to next command
                command_offset = next_command_offset;
            }
            break;
 801c74c:	e048      	b.n	801c7e0 <l2cap_acl_classic_handler+0x104>
                l2cap_signaling_handler_dispatch(handle, &packet[command_offset]);
 801c74e:	683a      	ldr	r2, [r7, #0]
 801c750:	69fb      	ldr	r3, [r7, #28]
 801c752:	441a      	add	r2, r3
 801c754:	88fb      	ldrh	r3, [r7, #6]
 801c756:	4611      	mov	r1, r2
 801c758:	4618      	mov	r0, r3
 801c75a:	f7fe ff75 	bl	801b648 <l2cap_signaling_handler_dispatch>
                command_offset = next_command_offset;
 801c75e:	68fb      	ldr	r3, [r7, #12]
 801c760:	61fb      	str	r3, [r7, #28]
            while ((command_offset + L2CAP_SIGNALING_COMMAND_DATA_OFFSET) < size) {
 801c762:	69fb      	ldr	r3, [r7, #28]
 801c764:	1d1a      	adds	r2, r3, #4
 801c766:	88bb      	ldrh	r3, [r7, #4]
 801c768:	429a      	cmp	r2, r3
 801c76a:	d3d6      	bcc.n	801c71a <l2cap_acl_classic_handler+0x3e>
            break;
 801c76c:	e038      	b.n	801c7e0 <l2cap_acl_classic_handler+0x104>
        }
        case L2CAP_CID_CONNECTIONLESS_CHANNEL:
            if (broadcast_flag == 0) break;
 801c76e:	7e7b      	ldrb	r3, [r7, #25]
 801c770:	2b00      	cmp	r3, #0
 801c772:	d02c      	beq.n	801c7ce <l2cap_acl_classic_handler+0xf2>
            l2cap_fixed_channel = l2cap_fixed_channel_for_channel_id(L2CAP_CID_CONNECTIONLESS_CHANNEL);
 801c774:	2002      	movs	r0, #2
 801c776:	f7fc fa65 	bl	8018c44 <l2cap_fixed_channel_for_channel_id>
 801c77a:	6178      	str	r0, [r7, #20]
            if (!l2cap_fixed_channel) break;
 801c77c:	697b      	ldr	r3, [r7, #20]
 801c77e:	2b00      	cmp	r3, #0
 801c780:	d027      	beq.n	801c7d2 <l2cap_acl_classic_handler+0xf6>
            if (!l2cap_fixed_channel->packet_handler) break;
 801c782:	697b      	ldr	r3, [r7, #20]
 801c784:	689b      	ldr	r3, [r3, #8]
 801c786:	2b00      	cmp	r3, #0
 801c788:	d025      	beq.n	801c7d6 <l2cap_acl_classic_handler+0xfa>
            (*l2cap_fixed_channel->packet_handler)(UCD_DATA_PACKET, handle, &packet[COMPLETE_L2CAP_HEADER], size-COMPLETE_L2CAP_HEADER);
 801c78a:	697b      	ldr	r3, [r7, #20]
 801c78c:	689c      	ldr	r4, [r3, #8]
 801c78e:	683b      	ldr	r3, [r7, #0]
 801c790:	f103 0208 	add.w	r2, r3, #8
 801c794:	88bb      	ldrh	r3, [r7, #4]
 801c796:	3b08      	subs	r3, #8
 801c798:	b29b      	uxth	r3, r3
 801c79a:	88f9      	ldrh	r1, [r7, #6]
 801c79c:	200c      	movs	r0, #12
 801c79e:	47a0      	blx	r4
            break;
 801c7a0:	e01e      	b.n	801c7e0 <l2cap_acl_classic_handler+0x104>

        default:
            if (broadcast_flag != 0) break;
 801c7a2:	7e7b      	ldrb	r3, [r7, #25]
 801c7a4:	2b00      	cmp	r3, #0
 801c7a6:	d118      	bne.n	801c7da <l2cap_acl_classic_handler+0xfe>
            // Find channel for this channel_id and connection handle
            l2cap_channel = l2cap_get_channel_for_local_cid_and_handle(channel_id, handle);
 801c7a8:	88fa      	ldrh	r2, [r7, #6]
 801c7aa:	8b7b      	ldrh	r3, [r7, #26]
 801c7ac:	4611      	mov	r1, r2
 801c7ae:	4618      	mov	r0, r3
 801c7b0:	f7fc fa6e 	bl	8018c90 <l2cap_get_channel_for_local_cid_and_handle>
 801c7b4:	60b8      	str	r0, [r7, #8]
            if (l2cap_channel != NULL){
 801c7b6:	68bb      	ldr	r3, [r7, #8]
 801c7b8:	2b00      	cmp	r3, #0
 801c7ba:	d010      	beq.n	801c7de <l2cap_acl_classic_handler+0x102>
                l2cap_acl_classic_handler_for_channel(l2cap_channel, packet, size);
 801c7bc:	88bb      	ldrh	r3, [r7, #4]
 801c7be:	461a      	mov	r2, r3
 801c7c0:	6839      	ldr	r1, [r7, #0]
 801c7c2:	68b8      	ldr	r0, [r7, #8]
 801c7c4:	f7ff fca2 	bl	801c10c <l2cap_acl_classic_handler_for_channel>
            }
            break;
 801c7c8:	e009      	b.n	801c7de <l2cap_acl_classic_handler+0x102>
            if (broadcast_flag != 0) break;
 801c7ca:	bf00      	nop
 801c7cc:	e008      	b.n	801c7e0 <l2cap_acl_classic_handler+0x104>
            if (broadcast_flag == 0) break;
 801c7ce:	bf00      	nop
 801c7d0:	e006      	b.n	801c7e0 <l2cap_acl_classic_handler+0x104>
            if (!l2cap_fixed_channel) break;
 801c7d2:	bf00      	nop
 801c7d4:	e004      	b.n	801c7e0 <l2cap_acl_classic_handler+0x104>
            if (!l2cap_fixed_channel->packet_handler) break;
 801c7d6:	bf00      	nop
 801c7d8:	e002      	b.n	801c7e0 <l2cap_acl_classic_handler+0x104>
            if (broadcast_flag != 0) break;
 801c7da:	bf00      	nop
 801c7dc:	e000      	b.n	801c7e0 <l2cap_acl_classic_handler+0x104>
            break;
 801c7de:	bf00      	nop
#else
    UNUSED(handle); // ok: no code
    UNUSED(packet); // ok: no code
    UNUSED(size);   // ok: no code
#endif
}
 801c7e0:	bf00      	nop
 801c7e2:	3724      	adds	r7, #36	; 0x24
 801c7e4:	46bd      	mov	sp, r7
 801c7e6:	bd90      	pop	{r4, r7, pc}
 801c7e8:	0802b1dc 	.word	0x0802b1dc
 801c7ec:	0802c5f4 	.word	0x0802c5f4

0801c7f0 <l2cap_acl_le_handler>:

static void l2cap_acl_le_handler(hci_con_handle_t handle, uint8_t *packet, uint16_t size){
 801c7f0:	b590      	push	{r4, r7, lr}
 801c7f2:	b08d      	sub	sp, #52	; 0x34
 801c7f4:	af02      	add	r7, sp, #8
 801c7f6:	4603      	mov	r3, r0
 801c7f8:	6039      	str	r1, [r7, #0]
 801c7fa:	80fb      	strh	r3, [r7, #6]
 801c7fc:	4613      	mov	r3, r2
 801c7fe:	80bb      	strh	r3, [r7, #4]
    l2cap_fixed_channel_t * l2cap_fixed_channel;

#ifdef ENABLE_LE_DATA_CHANNELS
    l2cap_channel_t * l2cap_channel;
#endif
    uint16_t channel_id = READ_L2CAP_CHANNEL_ID(packet);
 801c800:	2106      	movs	r1, #6
 801c802:	6838      	ldr	r0, [r7, #0]
 801c804:	f7f2 faef 	bl	800ede6 <little_endian_read_16>
 801c808:	4603      	mov	r3, r0
 801c80a:	84bb      	strh	r3, [r7, #36]	; 0x24
    switch (channel_id) {
 801c80c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801c80e:	2b05      	cmp	r3, #5
 801c810:	d004      	beq.n	801c81c <l2cap_acl_le_handler+0x2c>
 801c812:	2b06      	cmp	r3, #6
 801c814:	d044      	beq.n	801c8a0 <l2cap_acl_le_handler+0xb0>
 801c816:	2b04      	cmp	r3, #4
 801c818:	d029      	beq.n	801c86e <l2cap_acl_le_handler+0x7e>
 801c81a:	e05a      	b.n	801c8d2 <l2cap_acl_le_handler+0xe2>

        case L2CAP_CID_SIGNALING_LE: {
            uint16_t sig_id = packet[COMPLETE_L2CAP_HEADER + 1];
 801c81c:	683b      	ldr	r3, [r7, #0]
 801c81e:	3309      	adds	r3, #9
 801c820:	781b      	ldrb	r3, [r3, #0]
 801c822:	83fb      	strh	r3, [r7, #30]
            uint16_t len = little_endian_read_16(packet, COMPLETE_L2CAP_HEADER + 2);
 801c824:	210a      	movs	r1, #10
 801c826:	6838      	ldr	r0, [r7, #0]
 801c828:	f7f2 fadd 	bl	800ede6 <little_endian_read_16>
 801c82c:	4603      	mov	r3, r0
 801c82e:	83bb      	strh	r3, [r7, #28]
            if ((COMPLETE_L2CAP_HEADER + 4u + len) > size) break;
 801c830:	8bbb      	ldrh	r3, [r7, #28]
 801c832:	f103 020c 	add.w	r2, r3, #12
 801c836:	88bb      	ldrh	r3, [r7, #4]
 801c838:	429a      	cmp	r2, r3
 801c83a:	f200 80da 	bhi.w	801c9f2 <l2cap_acl_le_handler+0x202>
            int      valid  = l2cap_le_signaling_handler_dispatch(handle, &packet[COMPLETE_L2CAP_HEADER], sig_id);
 801c83e:	683b      	ldr	r3, [r7, #0]
 801c840:	f103 0108 	add.w	r1, r3, #8
 801c844:	8bfb      	ldrh	r3, [r7, #30]
 801c846:	b2da      	uxtb	r2, r3
 801c848:	88fb      	ldrh	r3, [r7, #6]
 801c84a:	4618      	mov	r0, r3
 801c84c:	f7ff f8bc 	bl	801b9c8 <l2cap_le_signaling_handler_dispatch>
 801c850:	61b8      	str	r0, [r7, #24]
            if (!valid){
 801c852:	69bb      	ldr	r3, [r7, #24]
 801c854:	2b00      	cmp	r3, #0
 801c856:	f040 80ce 	bne.w	801c9f6 <l2cap_acl_le_handler+0x206>
                l2cap_register_signaling_response(handle, COMMAND_REJECT_LE, sig_id, 0, L2CAP_REJ_CMD_UNKNOWN);
 801c85a:	8bfb      	ldrh	r3, [r7, #30]
 801c85c:	b2da      	uxtb	r2, r3
 801c85e:	88f8      	ldrh	r0, [r7, #6]
 801c860:	2300      	movs	r3, #0
 801c862:	9300      	str	r3, [sp, #0]
 801c864:	2300      	movs	r3, #0
 801c866:	211f      	movs	r1, #31
 801c868:	f7fe fa56 	bl	801ad18 <l2cap_register_signaling_response>
            }
            break;
 801c86c:	e0c3      	b.n	801c9f6 <l2cap_acl_le_handler+0x206>
        }

        case L2CAP_CID_ATTRIBUTE_PROTOCOL:
            l2cap_fixed_channel = l2cap_fixed_channel_for_channel_id(L2CAP_CID_ATTRIBUTE_PROTOCOL);
 801c86e:	2004      	movs	r0, #4
 801c870:	f7fc f9e8 	bl	8018c44 <l2cap_fixed_channel_for_channel_id>
 801c874:	6238      	str	r0, [r7, #32]
            if (!l2cap_fixed_channel) break;
 801c876:	6a3b      	ldr	r3, [r7, #32]
 801c878:	2b00      	cmp	r3, #0
 801c87a:	f000 80be 	beq.w	801c9fa <l2cap_acl_le_handler+0x20a>
            if (!l2cap_fixed_channel->packet_handler) break;
 801c87e:	6a3b      	ldr	r3, [r7, #32]
 801c880:	689b      	ldr	r3, [r3, #8]
 801c882:	2b00      	cmp	r3, #0
 801c884:	f000 80bb 	beq.w	801c9fe <l2cap_acl_le_handler+0x20e>
            (*l2cap_fixed_channel->packet_handler)(ATT_DATA_PACKET, handle, &packet[COMPLETE_L2CAP_HEADER], size-COMPLETE_L2CAP_HEADER);
 801c888:	6a3b      	ldr	r3, [r7, #32]
 801c88a:	689c      	ldr	r4, [r3, #8]
 801c88c:	683b      	ldr	r3, [r7, #0]
 801c88e:	f103 0208 	add.w	r2, r3, #8
 801c892:	88bb      	ldrh	r3, [r7, #4]
 801c894:	3b08      	subs	r3, #8
 801c896:	b29b      	uxth	r3, r3
 801c898:	88f9      	ldrh	r1, [r7, #6]
 801c89a:	2008      	movs	r0, #8
 801c89c:	47a0      	blx	r4
            break;
 801c89e:	e0b9      	b.n	801ca14 <l2cap_acl_le_handler+0x224>

        case L2CAP_CID_SECURITY_MANAGER_PROTOCOL:
            l2cap_fixed_channel = l2cap_fixed_channel_for_channel_id(L2CAP_CID_SECURITY_MANAGER_PROTOCOL);
 801c8a0:	2006      	movs	r0, #6
 801c8a2:	f7fc f9cf 	bl	8018c44 <l2cap_fixed_channel_for_channel_id>
 801c8a6:	6238      	str	r0, [r7, #32]
            if (!l2cap_fixed_channel) break;
 801c8a8:	6a3b      	ldr	r3, [r7, #32]
 801c8aa:	2b00      	cmp	r3, #0
 801c8ac:	f000 80a9 	beq.w	801ca02 <l2cap_acl_le_handler+0x212>
            if (!l2cap_fixed_channel->packet_handler) break;
 801c8b0:	6a3b      	ldr	r3, [r7, #32]
 801c8b2:	689b      	ldr	r3, [r3, #8]
 801c8b4:	2b00      	cmp	r3, #0
 801c8b6:	f000 80a6 	beq.w	801ca06 <l2cap_acl_le_handler+0x216>
            (*l2cap_fixed_channel->packet_handler)(SM_DATA_PACKET, handle, &packet[COMPLETE_L2CAP_HEADER], size-COMPLETE_L2CAP_HEADER);
 801c8ba:	6a3b      	ldr	r3, [r7, #32]
 801c8bc:	689c      	ldr	r4, [r3, #8]
 801c8be:	683b      	ldr	r3, [r7, #0]
 801c8c0:	f103 0208 	add.w	r2, r3, #8
 801c8c4:	88bb      	ldrh	r3, [r7, #4]
 801c8c6:	3b08      	subs	r3, #8
 801c8c8:	b29b      	uxth	r3, r3
 801c8ca:	88f9      	ldrh	r1, [r7, #6]
 801c8cc:	2009      	movs	r0, #9
 801c8ce:	47a0      	blx	r4
            break;
 801c8d0:	e0a0      	b.n	801ca14 <l2cap_acl_le_handler+0x224>

        default:

#ifdef ENABLE_LE_DATA_CHANNELS
            l2cap_channel = l2cap_get_channel_for_local_cid_and_handle(channel_id, handle);
 801c8d2:	88fa      	ldrh	r2, [r7, #6]
 801c8d4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801c8d6:	4611      	mov	r1, r2
 801c8d8:	4618      	mov	r0, r3
 801c8da:	f7fc f9d9 	bl	8018c90 <l2cap_get_channel_for_local_cid_and_handle>
 801c8de:	6178      	str	r0, [r7, #20]
            if (l2cap_channel != NULL) {
 801c8e0:	697b      	ldr	r3, [r7, #20]
 801c8e2:	2b00      	cmp	r3, #0
 801c8e4:	f000 8091 	beq.w	801ca0a <l2cap_acl_le_handler+0x21a>
                // credit counting
                if (l2cap_channel->credits_incoming == 0u){
 801c8e8:	697b      	ldr	r3, [r7, #20]
 801c8ea:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 801c8ee:	2b00      	cmp	r3, #0
 801c8f0:	d10b      	bne.n	801c90a <l2cap_acl_le_handler+0x11a>
                    log_info("LE Data Channel packet received but no incoming credits");
 801c8f2:	f640 6372 	movw	r3, #3698	; 0xe72
 801c8f6:	4a49      	ldr	r2, [pc, #292]	; (801ca1c <l2cap_acl_le_handler+0x22c>)
 801c8f8:	4949      	ldr	r1, [pc, #292]	; (801ca20 <l2cap_acl_le_handler+0x230>)
 801c8fa:	2001      	movs	r0, #1
 801c8fc:	f7fa fda0 	bl	8017440 <hci_dump_log>
                    l2cap_channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST;
 801c900:	697b      	ldr	r3, [r7, #20]
 801c902:	2212      	movs	r2, #18
 801c904:	f883 2020 	strb.w	r2, [r3, #32]
                    break;
 801c908:	e084      	b.n	801ca14 <l2cap_acl_le_handler+0x224>
                }
                l2cap_channel->credits_incoming--;
 801c90a:	697b      	ldr	r3, [r7, #20]
 801c90c:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 801c910:	3b01      	subs	r3, #1
 801c912:	b29a      	uxth	r2, r3
 801c914:	697b      	ldr	r3, [r7, #20]
 801c916:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52

                // automatic credits
                if ((l2cap_channel->credits_incoming < L2CAP_LE_DATA_CHANNELS_AUTOMATIC_CREDITS_WATERMARK) && l2cap_channel->automatic_credits){
 801c91a:	697b      	ldr	r3, [r7, #20]
 801c91c:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 801c920:	2b04      	cmp	r3, #4
 801c922:	d808      	bhi.n	801c936 <l2cap_acl_le_handler+0x146>
 801c924:	697b      	ldr	r3, [r7, #20]
 801c926:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 801c92a:	2b00      	cmp	r3, #0
 801c92c:	d003      	beq.n	801c936 <l2cap_acl_le_handler+0x146>
                    l2cap_channel->new_credits_incoming = L2CAP_LE_DATA_CHANNELS_AUTOMATIC_CREDITS_INCREMENT;
 801c92e:	697b      	ldr	r3, [r7, #20]
 801c930:	2205      	movs	r2, #5
 801c932:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
                }

                // first fragment
                uint16_t pos = 0;
 801c936:	2300      	movs	r3, #0
 801c938:	84fb      	strh	r3, [r7, #38]	; 0x26
                if (!l2cap_channel->receive_sdu_len){
 801c93a:	697b      	ldr	r3, [r7, #20]
 801c93c:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801c940:	2b00      	cmp	r3, #0
 801c942:	d118      	bne.n	801c976 <l2cap_acl_le_handler+0x186>
                    uint16_t sdu_len = little_endian_read_16(packet, COMPLETE_L2CAP_HEADER);
 801c944:	2108      	movs	r1, #8
 801c946:	6838      	ldr	r0, [r7, #0]
 801c948:	f7f2 fa4d 	bl	800ede6 <little_endian_read_16>
 801c94c:	4603      	mov	r3, r0
 801c94e:	827b      	strh	r3, [r7, #18]
                    if(sdu_len > l2cap_channel->local_mtu) break;   // SDU would be larger than our buffer
 801c950:	697b      	ldr	r3, [r7, #20]
 801c952:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 801c954:	8a7a      	ldrh	r2, [r7, #18]
 801c956:	429a      	cmp	r2, r3
 801c958:	d859      	bhi.n	801ca0e <l2cap_acl_le_handler+0x21e>
                    l2cap_channel->receive_sdu_len = sdu_len;
 801c95a:	697b      	ldr	r3, [r7, #20]
 801c95c:	8a7a      	ldrh	r2, [r7, #18]
 801c95e:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
                    l2cap_channel->receive_sdu_pos = 0;                   
 801c962:	697b      	ldr	r3, [r7, #20]
 801c964:	2200      	movs	r2, #0
 801c966:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
                    pos  += 2u;
 801c96a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801c96c:	3302      	adds	r3, #2
 801c96e:	84fb      	strh	r3, [r7, #38]	; 0x26
                    size -= 2u;
 801c970:	88bb      	ldrh	r3, [r7, #4]
 801c972:	3b02      	subs	r3, #2
 801c974:	80bb      	strh	r3, [r7, #4]
                }
                uint16_t fragment_size   = size-COMPLETE_L2CAP_HEADER;
 801c976:	88bb      	ldrh	r3, [r7, #4]
 801c978:	3b08      	subs	r3, #8
 801c97a:	823b      	strh	r3, [r7, #16]
                uint16_t remaining_space = l2cap_channel->local_mtu - l2cap_channel->receive_sdu_pos;
 801c97c:	697b      	ldr	r3, [r7, #20]
 801c97e:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
 801c980:	697b      	ldr	r3, [r7, #20]
 801c982:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 801c986:	1ad3      	subs	r3, r2, r3
 801c988:	81fb      	strh	r3, [r7, #14]
                if (fragment_size > remaining_space) break;         // SDU would cause buffer overrun
 801c98a:	8a3a      	ldrh	r2, [r7, #16]
 801c98c:	89fb      	ldrh	r3, [r7, #14]
 801c98e:	429a      	cmp	r2, r3
 801c990:	d83f      	bhi.n	801ca12 <l2cap_acl_le_handler+0x222>
                (void)memcpy(&l2cap_channel->receive_sdu_buffer[l2cap_channel->receive_sdu_pos],
 801c992:	697b      	ldr	r3, [r7, #20]
 801c994:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801c996:	697a      	ldr	r2, [r7, #20]
 801c998:	f8b2 2042 	ldrh.w	r2, [r2, #66]	; 0x42
 801c99c:	1898      	adds	r0, r3, r2
                             &packet[COMPLETE_L2CAP_HEADER + pos],
 801c99e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801c9a0:	3308      	adds	r3, #8
 801c9a2:	461a      	mov	r2, r3
 801c9a4:	683b      	ldr	r3, [r7, #0]
 801c9a6:	4413      	add	r3, r2
                (void)memcpy(&l2cap_channel->receive_sdu_buffer[l2cap_channel->receive_sdu_pos],
 801c9a8:	8a3a      	ldrh	r2, [r7, #16]
 801c9aa:	4619      	mov	r1, r3
 801c9ac:	f00b f865 	bl	8027a7a <memcpy>
                             fragment_size);
                l2cap_channel->receive_sdu_pos += size - COMPLETE_L2CAP_HEADER;
 801c9b0:	697b      	ldr	r3, [r7, #20]
 801c9b2:	f8b3 2042 	ldrh.w	r2, [r3, #66]	; 0x42
 801c9b6:	88bb      	ldrh	r3, [r7, #4]
 801c9b8:	4413      	add	r3, r2
 801c9ba:	b29b      	uxth	r3, r3
 801c9bc:	3b08      	subs	r3, #8
 801c9be:	b29a      	uxth	r2, r3
 801c9c0:	697b      	ldr	r3, [r7, #20]
 801c9c2:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
                // done?
                log_debug("le packet pos %u, len %u", l2cap_channel->receive_sdu_pos, l2cap_channel->receive_sdu_len);
                if (l2cap_channel->receive_sdu_pos >= l2cap_channel->receive_sdu_len){
 801c9c6:	697b      	ldr	r3, [r7, #20]
 801c9c8:	f8b3 2042 	ldrh.w	r2, [r3, #66]	; 0x42
 801c9cc:	697b      	ldr	r3, [r7, #20]
 801c9ce:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801c9d2:	429a      	cmp	r2, r3
 801c9d4:	d319      	bcc.n	801ca0a <l2cap_acl_le_handler+0x21a>
                    l2cap_dispatch_to_channel(l2cap_channel, L2CAP_DATA_PACKET, l2cap_channel->receive_sdu_buffer, l2cap_channel->receive_sdu_len);
 801c9d6:	697b      	ldr	r3, [r7, #20]
 801c9d8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 801c9da:	697b      	ldr	r3, [r7, #20]
 801c9dc:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801c9e0:	2106      	movs	r1, #6
 801c9e2:	6978      	ldr	r0, [r7, #20]
 801c9e4:	f7fb ff67 	bl	80188b6 <l2cap_dispatch_to_channel>
                    l2cap_channel->receive_sdu_len = 0;
 801c9e8:	697b      	ldr	r3, [r7, #20]
 801c9ea:	2200      	movs	r2, #0
 801c9ec:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
                }
            }
#endif
            break;
 801c9f0:	e00b      	b.n	801ca0a <l2cap_acl_le_handler+0x21a>
            if ((COMPLETE_L2CAP_HEADER + 4u + len) > size) break;
 801c9f2:	bf00      	nop
 801c9f4:	e00e      	b.n	801ca14 <l2cap_acl_le_handler+0x224>
            break;
 801c9f6:	bf00      	nop
 801c9f8:	e00c      	b.n	801ca14 <l2cap_acl_le_handler+0x224>
            if (!l2cap_fixed_channel) break;
 801c9fa:	bf00      	nop
 801c9fc:	e00a      	b.n	801ca14 <l2cap_acl_le_handler+0x224>
            if (!l2cap_fixed_channel->packet_handler) break;
 801c9fe:	bf00      	nop
 801ca00:	e008      	b.n	801ca14 <l2cap_acl_le_handler+0x224>
            if (!l2cap_fixed_channel) break;
 801ca02:	bf00      	nop
 801ca04:	e006      	b.n	801ca14 <l2cap_acl_le_handler+0x224>
            if (!l2cap_fixed_channel->packet_handler) break;
 801ca06:	bf00      	nop
 801ca08:	e004      	b.n	801ca14 <l2cap_acl_le_handler+0x224>
            break;
 801ca0a:	bf00      	nop
 801ca0c:	e002      	b.n	801ca14 <l2cap_acl_le_handler+0x224>
                    if(sdu_len > l2cap_channel->local_mtu) break;   // SDU would be larger than our buffer
 801ca0e:	bf00      	nop
 801ca10:	e000      	b.n	801ca14 <l2cap_acl_le_handler+0x224>
                if (fragment_size > remaining_space) break;         // SDU would cause buffer overrun
 801ca12:	bf00      	nop
#else
    UNUSED(handle); // ok: no code
    UNUSED(packet); // ok: no code
    UNUSED(size);   // ok: no code
#endif
}
 801ca14:	bf00      	nop
 801ca16:	372c      	adds	r7, #44	; 0x2c
 801ca18:	46bd      	mov	sp, r7
 801ca1a:	bd90      	pop	{r4, r7, pc}
 801ca1c:	0802b1dc 	.word	0x0802b1dc
 801ca20:	0802c628 	.word	0x0802c628

0801ca24 <l2cap_acl_handler>:

static void l2cap_acl_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){
 801ca24:	b580      	push	{r7, lr}
 801ca26:	b086      	sub	sp, #24
 801ca28:	af00      	add	r7, sp, #0
 801ca2a:	60ba      	str	r2, [r7, #8]
 801ca2c:	461a      	mov	r2, r3
 801ca2e:	4603      	mov	r3, r0
 801ca30:	73fb      	strb	r3, [r7, #15]
 801ca32:	460b      	mov	r3, r1
 801ca34:	81bb      	strh	r3, [r7, #12]
 801ca36:	4613      	mov	r3, r2
 801ca38:	80fb      	strh	r3, [r7, #6]
    UNUSED(packet_type);    // ok: registered with hci_register_acl_packet_handler
    UNUSED(channel);        // ok: there is no channel

    // Assert full L2CAP header present
    if (size < COMPLETE_L2CAP_HEADER) return;
 801ca3a:	88fb      	ldrh	r3, [r7, #6]
 801ca3c:	2b07      	cmp	r3, #7
 801ca3e:	d923      	bls.n	801ca88 <l2cap_acl_handler+0x64>

    // Dispatch to Classic or LE handler (SCO packets are not dispatched to L2CAP)
    hci_con_handle_t handle = READ_ACL_CONNECTION_HANDLE(packet);
 801ca40:	2100      	movs	r1, #0
 801ca42:	68b8      	ldr	r0, [r7, #8]
 801ca44:	f7f2 f9cf 	bl	800ede6 <little_endian_read_16>
 801ca48:	4603      	mov	r3, r0
 801ca4a:	f3c3 030b 	ubfx	r3, r3, #0, #12
 801ca4e:	82fb      	strh	r3, [r7, #22]
    hci_connection_t *conn = hci_connection_for_handle(handle);
 801ca50:	8afb      	ldrh	r3, [r7, #22]
 801ca52:	4618      	mov	r0, r3
 801ca54:	f7f2 ff36 	bl	800f8c4 <hci_connection_for_handle>
 801ca58:	6138      	str	r0, [r7, #16]
    if (!conn) return;
 801ca5a:	693b      	ldr	r3, [r7, #16]
 801ca5c:	2b00      	cmp	r3, #0
 801ca5e:	d015      	beq.n	801ca8c <l2cap_acl_handler+0x68>
    if (conn->address_type == BD_ADDR_TYPE_ACL){
 801ca60:	693b      	ldr	r3, [r7, #16]
 801ca62:	7b1b      	ldrb	r3, [r3, #12]
 801ca64:	2bfd      	cmp	r3, #253	; 0xfd
 801ca66:	d106      	bne.n	801ca76 <l2cap_acl_handler+0x52>
        l2cap_acl_classic_handler(handle, packet, size);
 801ca68:	88fa      	ldrh	r2, [r7, #6]
 801ca6a:	8afb      	ldrh	r3, [r7, #22]
 801ca6c:	68b9      	ldr	r1, [r7, #8]
 801ca6e:	4618      	mov	r0, r3
 801ca70:	f7ff fe34 	bl	801c6dc <l2cap_acl_classic_handler>
 801ca74:	e005      	b.n	801ca82 <l2cap_acl_handler+0x5e>
    } else {
        l2cap_acl_le_handler(handle, packet, size);
 801ca76:	88fa      	ldrh	r2, [r7, #6]
 801ca78:	8afb      	ldrh	r3, [r7, #22]
 801ca7a:	68b9      	ldr	r1, [r7, #8]
 801ca7c:	4618      	mov	r0, r3
 801ca7e:	f7ff feb7 	bl	801c7f0 <l2cap_acl_le_handler>
    }

    l2cap_run();
 801ca82:	f7fd fab9 	bl	8019ff8 <l2cap_run>
 801ca86:	e002      	b.n	801ca8e <l2cap_acl_handler+0x6a>
    if (size < COMPLETE_L2CAP_HEADER) return;
 801ca88:	bf00      	nop
 801ca8a:	e000      	b.n	801ca8e <l2cap_acl_handler+0x6a>
    if (!conn) return;
 801ca8c:	bf00      	nop
}
 801ca8e:	3718      	adds	r7, #24
 801ca90:	46bd      	mov	sp, r7
 801ca92:	bd80      	pop	{r7, pc}

0801ca94 <l2cap_register_fixed_channel>:

// Bluetooth 4.0 - allows to register handler for Attribute Protocol and Security Manager Protocol
void l2cap_register_fixed_channel(btstack_packet_handler_t the_packet_handler, uint16_t channel_id) {
 801ca94:	b580      	push	{r7, lr}
 801ca96:	b084      	sub	sp, #16
 801ca98:	af00      	add	r7, sp, #0
 801ca9a:	6078      	str	r0, [r7, #4]
 801ca9c:	460b      	mov	r3, r1
 801ca9e:	807b      	strh	r3, [r7, #2]
    l2cap_fixed_channel_t * channel = l2cap_fixed_channel_for_channel_id(channel_id);
 801caa0:	887b      	ldrh	r3, [r7, #2]
 801caa2:	4618      	mov	r0, r3
 801caa4:	f7fc f8ce 	bl	8018c44 <l2cap_fixed_channel_for_channel_id>
 801caa8:	60f8      	str	r0, [r7, #12]
    if (!channel) return;
 801caaa:	68fb      	ldr	r3, [r7, #12]
 801caac:	2b00      	cmp	r3, #0
 801caae:	d003      	beq.n	801cab8 <l2cap_register_fixed_channel+0x24>
    channel->packet_handler = the_packet_handler;
 801cab0:	68fb      	ldr	r3, [r7, #12]
 801cab2:	687a      	ldr	r2, [r7, #4]
 801cab4:	609a      	str	r2, [r3, #8]
 801cab6:	e000      	b.n	801caba <l2cap_register_fixed_channel+0x26>
    if (!channel) return;
 801cab8:	bf00      	nop
}
 801caba:	3710      	adds	r7, #16
 801cabc:	46bd      	mov	sp, r7
 801cabe:	bd80      	pop	{r7, pc}

0801cac0 <l2cap_finialize_channel_close>:

#ifdef ENABLE_CLASSIC
// finalize closed channel - l2cap_handle_disconnect_request & DISCONNECTION_RESPONSE
void l2cap_finialize_channel_close(l2cap_channel_t * channel){
 801cac0:	b580      	push	{r7, lr}
 801cac2:	b082      	sub	sp, #8
 801cac4:	af00      	add	r7, sp, #0
 801cac6:	6078      	str	r0, [r7, #4]
    channel->state = L2CAP_STATE_CLOSED;
 801cac8:	687b      	ldr	r3, [r7, #4]
 801caca:	2201      	movs	r2, #1
 801cacc:	f883 2020 	strb.w	r2, [r3, #32]
    l2cap_handle_channel_closed(channel);
 801cad0:	6878      	ldr	r0, [r7, #4]
 801cad2:	f7fc f87b 	bl	8018bcc <l2cap_handle_channel_closed>
    // discard channel
    btstack_linked_list_remove(&l2cap_channels, (btstack_linked_item_t *) channel);
 801cad6:	6879      	ldr	r1, [r7, #4]
 801cad8:	4804      	ldr	r0, [pc, #16]	; (801caec <l2cap_finialize_channel_close+0x2c>)
 801cada:	f7f1 fdf0 	bl	800e6be <btstack_linked_list_remove>
    l2cap_free_channel_entry(channel);
 801cade:	6878      	ldr	r0, [r7, #4]
 801cae0:	f7fd fc06 	bl	801a2f0 <l2cap_free_channel_entry>
}
 801cae4:	bf00      	nop
 801cae6:	3708      	adds	r7, #8
 801cae8:	46bd      	mov	sp, r7
 801caea:	bd80      	pop	{r7, pc}
 801caec:	20009eac 	.word	0x20009eac

0801caf0 <l2cap_get_service_internal>:
#endif

#ifdef L2CAP_USES_CHANNELS
static l2cap_service_t * l2cap_get_service_internal(btstack_linked_list_t * services, uint16_t psm){
 801caf0:	b580      	push	{r7, lr}
 801caf2:	b086      	sub	sp, #24
 801caf4:	af00      	add	r7, sp, #0
 801caf6:	6078      	str	r0, [r7, #4]
 801caf8:	460b      	mov	r3, r1
 801cafa:	807b      	strh	r3, [r7, #2]
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, services);
 801cafc:	f107 0308 	add.w	r3, r7, #8
 801cb00:	6879      	ldr	r1, [r7, #4]
 801cb02:	4618      	mov	r0, r3
 801cb04:	f7f1 fe23 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 801cb08:	e00c      	b.n	801cb24 <l2cap_get_service_internal+0x34>
        l2cap_service_t * service = (l2cap_service_t *) btstack_linked_list_iterator_next(&it);
 801cb0a:	f107 0308 	add.w	r3, r7, #8
 801cb0e:	4618      	mov	r0, r3
 801cb10:	f7f1 fe60 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801cb14:	6178      	str	r0, [r7, #20]
        if ( service->psm == psm){
 801cb16:	697b      	ldr	r3, [r7, #20]
 801cb18:	889b      	ldrh	r3, [r3, #4]
 801cb1a:	887a      	ldrh	r2, [r7, #2]
 801cb1c:	429a      	cmp	r2, r3
 801cb1e:	d101      	bne.n	801cb24 <l2cap_get_service_internal+0x34>
            return service;
 801cb20:	697b      	ldr	r3, [r7, #20]
 801cb22:	e008      	b.n	801cb36 <l2cap_get_service_internal+0x46>
    while (btstack_linked_list_iterator_has_next(&it)){
 801cb24:	f107 0308 	add.w	r3, r7, #8
 801cb28:	4618      	mov	r0, r3
 801cb2a:	f7f1 fe25 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801cb2e:	4603      	mov	r3, r0
 801cb30:	2b00      	cmp	r3, #0
 801cb32:	d1ea      	bne.n	801cb0a <l2cap_get_service_internal+0x1a>
        };
    }
    return NULL;
 801cb34:	2300      	movs	r3, #0
}
 801cb36:	4618      	mov	r0, r3
 801cb38:	3718      	adds	r7, #24
 801cb3a:	46bd      	mov	sp, r7
 801cb3c:	bd80      	pop	{r7, pc}
	...

0801cb40 <l2cap_get_service>:
#endif

#ifdef ENABLE_CLASSIC
static inline l2cap_service_t * l2cap_get_service(uint16_t psm){
 801cb40:	b580      	push	{r7, lr}
 801cb42:	b082      	sub	sp, #8
 801cb44:	af00      	add	r7, sp, #0
 801cb46:	4603      	mov	r3, r0
 801cb48:	80fb      	strh	r3, [r7, #6]
    return l2cap_get_service_internal(&l2cap_services, psm);
 801cb4a:	88fb      	ldrh	r3, [r7, #6]
 801cb4c:	4619      	mov	r1, r3
 801cb4e:	4804      	ldr	r0, [pc, #16]	; (801cb60 <l2cap_get_service+0x20>)
 801cb50:	f7ff ffce 	bl	801caf0 <l2cap_get_service_internal>
 801cb54:	4603      	mov	r3, r0
}
 801cb56:	4618      	mov	r0, r3
 801cb58:	3708      	adds	r7, #8
 801cb5a:	46bd      	mov	sp, r7
 801cb5c:	bd80      	pop	{r7, pc}
 801cb5e:	bf00      	nop
 801cb60:	20009e98 	.word	0x20009e98

0801cb64 <l2cap_le_notify_channel_can_send>:
#endif


#ifdef ENABLE_LE_DATA_CHANNELS

static void l2cap_le_notify_channel_can_send(l2cap_channel_t *channel){
 801cb64:	b580      	push	{r7, lr}
 801cb66:	b082      	sub	sp, #8
 801cb68:	af00      	add	r7, sp, #0
 801cb6a:	6078      	str	r0, [r7, #4]
    if (!channel->waiting_for_can_send_now) return;
 801cb6c:	687b      	ldr	r3, [r7, #4]
 801cb6e:	7b1b      	ldrb	r3, [r3, #12]
 801cb70:	2b00      	cmp	r3, #0
 801cb72:	d00b      	beq.n	801cb8c <l2cap_le_notify_channel_can_send+0x28>
    if (channel->send_sdu_buffer) return;
 801cb74:	687b      	ldr	r3, [r7, #4]
 801cb76:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801cb78:	2b00      	cmp	r3, #0
 801cb7a:	d109      	bne.n	801cb90 <l2cap_le_notify_channel_can_send+0x2c>
    channel->waiting_for_can_send_now = 0;
 801cb7c:	687b      	ldr	r3, [r7, #4]
 801cb7e:	2200      	movs	r2, #0
 801cb80:	731a      	strb	r2, [r3, #12]
    log_debug("L2CAP_EVENT_CHANNEL_LE_CAN_SEND_NOW local_cid 0x%x", channel->local_cid);
    l2cap_emit_simple_event_with_cid(channel, L2CAP_EVENT_LE_CAN_SEND_NOW);
 801cb82:	217c      	movs	r1, #124	; 0x7c
 801cb84:	6878      	ldr	r0, [r7, #4]
 801cb86:	f7fb feac 	bl	80188e2 <l2cap_emit_simple_event_with_cid>
 801cb8a:	e002      	b.n	801cb92 <l2cap_le_notify_channel_can_send+0x2e>
    if (!channel->waiting_for_can_send_now) return;
 801cb8c:	bf00      	nop
 801cb8e:	e000      	b.n	801cb92 <l2cap_le_notify_channel_can_send+0x2e>
    if (channel->send_sdu_buffer) return;
 801cb90:	bf00      	nop
}
 801cb92:	3708      	adds	r7, #8
 801cb94:	46bd      	mov	sp, r7
 801cb96:	bd80      	pop	{r7, pc}

0801cb98 <l2cap_emit_le_incoming_connection>:

// 1BH2222
static void l2cap_emit_le_incoming_connection(l2cap_channel_t *channel) {
 801cb98:	b5f0      	push	{r4, r5, r6, r7, lr}
 801cb9a:	b091      	sub	sp, #68	; 0x44
 801cb9c:	af08      	add	r7, sp, #32
 801cb9e:	6078      	str	r0, [r7, #4]
    log_info("L2CAP_EVENT_LE_INCOMING_CONNECTION addr_type %u, addr %s handle 0x%x psm 0x%x local_cid 0x%x remote_cid 0x%x, remote_mtu %u",
 801cba0:	687b      	ldr	r3, [r7, #4]
 801cba2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801cba6:	461c      	mov	r4, r3
 801cba8:	687b      	ldr	r3, [r7, #4]
 801cbaa:	3326      	adds	r3, #38	; 0x26
 801cbac:	4618      	mov	r0, r3
 801cbae:	f7f2 fc2f 	bl	800f410 <bd_addr_to_str>
 801cbb2:	4602      	mov	r2, r0
 801cbb4:	687b      	ldr	r3, [r7, #4]
 801cbb6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801cbb8:	4619      	mov	r1, r3
 801cbba:	687b      	ldr	r3, [r7, #4]
 801cbbc:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 801cbbe:	4618      	mov	r0, r3
 801cbc0:	687b      	ldr	r3, [r7, #4]
 801cbc2:	88db      	ldrh	r3, [r3, #6]
 801cbc4:	461d      	mov	r5, r3
 801cbc6:	687b      	ldr	r3, [r7, #4]
 801cbc8:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801cbca:	461e      	mov	r6, r3
 801cbcc:	687b      	ldr	r3, [r7, #4]
 801cbce:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 801cbd0:	9306      	str	r3, [sp, #24]
 801cbd2:	9605      	str	r6, [sp, #20]
 801cbd4:	9504      	str	r5, [sp, #16]
 801cbd6:	9003      	str	r0, [sp, #12]
 801cbd8:	9102      	str	r1, [sp, #8]
 801cbda:	9201      	str	r2, [sp, #4]
 801cbdc:	9400      	str	r4, [sp, #0]
 801cbde:	f640 731d 	movw	r3, #3869	; 0xf1d
 801cbe2:	4a28      	ldr	r2, [pc, #160]	; (801cc84 <l2cap_emit_le_incoming_connection+0xec>)
 801cbe4:	4928      	ldr	r1, [pc, #160]	; (801cc88 <l2cap_emit_le_incoming_connection+0xf0>)
 801cbe6:	2001      	movs	r0, #1
 801cbe8:	f7fa fc2a 	bl	8017440 <hci_dump_log>
             channel->address_type, bd_addr_to_str(channel->address), channel->con_handle,  channel->psm, channel->local_cid, channel->remote_cid, channel->remote_mtu);
    uint8_t event[19];
    event[0] = L2CAP_EVENT_LE_INCOMING_CONNECTION;
 801cbec:	2379      	movs	r3, #121	; 0x79
 801cbee:	733b      	strb	r3, [r7, #12]
    event[1] = sizeof(event) - 2u;
 801cbf0:	2311      	movs	r3, #17
 801cbf2:	737b      	strb	r3, [r7, #13]
    event[2] = channel->address_type;
 801cbf4:	687b      	ldr	r3, [r7, #4]
 801cbf6:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801cbfa:	73bb      	strb	r3, [r7, #14]
    reverse_bd_addr(channel->address, &event[3]);
 801cbfc:	687b      	ldr	r3, [r7, #4]
 801cbfe:	f103 0226 	add.w	r2, r3, #38	; 0x26
 801cc02:	f107 030c 	add.w	r3, r7, #12
 801cc06:	3303      	adds	r3, #3
 801cc08:	4619      	mov	r1, r3
 801cc0a:	4610      	mov	r0, r2
 801cc0c:	f7f2 fa71 	bl	800f0f2 <reverse_bd_addr>
    little_endian_store_16(event,  9, channel->con_handle);
 801cc10:	687b      	ldr	r3, [r7, #4]
 801cc12:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 801cc14:	f107 030c 	add.w	r3, r7, #12
 801cc18:	2109      	movs	r1, #9
 801cc1a:	4618      	mov	r0, r3
 801cc1c:	f7f2 f923 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 11, channel->psm);
 801cc20:	687b      	ldr	r3, [r7, #4]
 801cc22:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 801cc24:	f107 030c 	add.w	r3, r7, #12
 801cc28:	210b      	movs	r1, #11
 801cc2a:	4618      	mov	r0, r3
 801cc2c:	f7f2 f91b 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 13, channel->local_cid);
 801cc30:	687b      	ldr	r3, [r7, #4]
 801cc32:	88da      	ldrh	r2, [r3, #6]
 801cc34:	f107 030c 	add.w	r3, r7, #12
 801cc38:	210d      	movs	r1, #13
 801cc3a:	4618      	mov	r0, r3
 801cc3c:	f7f2 f913 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 15, channel->remote_cid);
 801cc40:	687b      	ldr	r3, [r7, #4]
 801cc42:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 801cc44:	f107 030c 	add.w	r3, r7, #12
 801cc48:	210f      	movs	r1, #15
 801cc4a:	4618      	mov	r0, r3
 801cc4c:	f7f2 f90b 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 17, channel->remote_mtu);
 801cc50:	687b      	ldr	r3, [r7, #4]
 801cc52:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
 801cc54:	f107 030c 	add.w	r3, r7, #12
 801cc58:	2111      	movs	r1, #17
 801cc5a:	4618      	mov	r0, r3
 801cc5c:	f7f2 f903 	bl	800ee66 <little_endian_store_16>
    hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
 801cc60:	f107 020c 	add.w	r2, r7, #12
 801cc64:	2313      	movs	r3, #19
 801cc66:	2100      	movs	r1, #0
 801cc68:	2004      	movs	r0, #4
 801cc6a:	f7fa fb43 	bl	80172f4 <hci_dump_packet>
    l2cap_dispatch_to_channel(channel, HCI_EVENT_PACKET, event, sizeof(event));
 801cc6e:	f107 020c 	add.w	r2, r7, #12
 801cc72:	2313      	movs	r3, #19
 801cc74:	2104      	movs	r1, #4
 801cc76:	6878      	ldr	r0, [r7, #4]
 801cc78:	f7fb fe1d 	bl	80188b6 <l2cap_dispatch_to_channel>
}
 801cc7c:	bf00      	nop
 801cc7e:	3724      	adds	r7, #36	; 0x24
 801cc80:	46bd      	mov	sp, r7
 801cc82:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801cc84:	0802b1dc 	.word	0x0802b1dc
 801cc88:	0802c740 	.word	0x0802c740

0801cc8c <l2cap_emit_le_channel_opened>:
// 11BH22222
static void l2cap_emit_le_channel_opened(l2cap_channel_t *channel, uint8_t status) {
 801cc8c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801cc8e:	b095      	sub	sp, #84	; 0x54
 801cc90:	af0a      	add	r7, sp, #40	; 0x28
 801cc92:	60f8      	str	r0, [r7, #12]
 801cc94:	460b      	mov	r3, r1
 801cc96:	72fb      	strb	r3, [r7, #11]
    log_info("L2CAP_EVENT_LE_CHANNEL_OPENED status 0x%x addr_type %u addr %s handle 0x%x psm 0x%x local_cid 0x%x remote_cid 0x%x local_mtu %u, remote_mtu %u",
 801cc98:	7afc      	ldrb	r4, [r7, #11]
 801cc9a:	68fb      	ldr	r3, [r7, #12]
 801cc9c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801cca0:	461d      	mov	r5, r3
 801cca2:	68fb      	ldr	r3, [r7, #12]
 801cca4:	3326      	adds	r3, #38	; 0x26
 801cca6:	4618      	mov	r0, r3
 801cca8:	f7f2 fbb2 	bl	800f410 <bd_addr_to_str>
 801ccac:	4602      	mov	r2, r0
 801ccae:	68fb      	ldr	r3, [r7, #12]
 801ccb0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801ccb2:	4619      	mov	r1, r3
 801ccb4:	68fb      	ldr	r3, [r7, #12]
 801ccb6:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 801ccb8:	4618      	mov	r0, r3
 801ccba:	68fb      	ldr	r3, [r7, #12]
 801ccbc:	88db      	ldrh	r3, [r3, #6]
 801ccbe:	461e      	mov	r6, r3
 801ccc0:	68fb      	ldr	r3, [r7, #12]
 801ccc2:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801ccc4:	607b      	str	r3, [r7, #4]
 801ccc6:	68fb      	ldr	r3, [r7, #12]
 801ccc8:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 801ccca:	603b      	str	r3, [r7, #0]
 801cccc:	68fb      	ldr	r3, [r7, #12]
 801ccce:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 801ccd0:	9308      	str	r3, [sp, #32]
 801ccd2:	683b      	ldr	r3, [r7, #0]
 801ccd4:	9307      	str	r3, [sp, #28]
 801ccd6:	687b      	ldr	r3, [r7, #4]
 801ccd8:	9306      	str	r3, [sp, #24]
 801ccda:	9605      	str	r6, [sp, #20]
 801ccdc:	9004      	str	r0, [sp, #16]
 801ccde:	9103      	str	r1, [sp, #12]
 801cce0:	9202      	str	r2, [sp, #8]
 801cce2:	9501      	str	r5, [sp, #4]
 801cce4:	9400      	str	r4, [sp, #0]
 801cce6:	f640 732f 	movw	r3, #3887	; 0xf2f
 801ccea:	4a32      	ldr	r2, [pc, #200]	; (801cdb4 <l2cap_emit_le_channel_opened+0x128>)
 801ccec:	4932      	ldr	r1, [pc, #200]	; (801cdb8 <l2cap_emit_le_channel_opened+0x12c>)
 801ccee:	2001      	movs	r0, #1
 801ccf0:	f7fa fba6 	bl	8017440 <hci_dump_log>
             status, channel->address_type, bd_addr_to_str(channel->address), channel->con_handle, channel->psm,
             channel->local_cid, channel->remote_cid, channel->local_mtu, channel->remote_mtu);
    uint8_t event[23];
    event[0] = L2CAP_EVENT_LE_CHANNEL_OPENED;
 801ccf4:	237a      	movs	r3, #122	; 0x7a
 801ccf6:	743b      	strb	r3, [r7, #16]
    event[1] = sizeof(event) - 2u;
 801ccf8:	2315      	movs	r3, #21
 801ccfa:	747b      	strb	r3, [r7, #17]
    event[2] = status;
 801ccfc:	7afb      	ldrb	r3, [r7, #11]
 801ccfe:	74bb      	strb	r3, [r7, #18]
    event[3] = channel->address_type;
 801cd00:	68fb      	ldr	r3, [r7, #12]
 801cd02:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801cd06:	74fb      	strb	r3, [r7, #19]
    reverse_bd_addr(channel->address, &event[4]);
 801cd08:	68fb      	ldr	r3, [r7, #12]
 801cd0a:	f103 0226 	add.w	r2, r3, #38	; 0x26
 801cd0e:	f107 0310 	add.w	r3, r7, #16
 801cd12:	3304      	adds	r3, #4
 801cd14:	4619      	mov	r1, r3
 801cd16:	4610      	mov	r0, r2
 801cd18:	f7f2 f9eb 	bl	800f0f2 <reverse_bd_addr>
    little_endian_store_16(event, 10, channel->con_handle);
 801cd1c:	68fb      	ldr	r3, [r7, #12]
 801cd1e:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 801cd20:	f107 0310 	add.w	r3, r7, #16
 801cd24:	210a      	movs	r1, #10
 801cd26:	4618      	mov	r0, r3
 801cd28:	f7f2 f89d 	bl	800ee66 <little_endian_store_16>
    event[12] = (channel->state_var & L2CAP_CHANNEL_STATE_VAR_INCOMING) ? 1 : 0;
 801cd2c:	68fb      	ldr	r3, [r7, #12]
 801cd2e:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801cd30:	b21b      	sxth	r3, r3
 801cd32:	13db      	asrs	r3, r3, #15
 801cd34:	b21b      	sxth	r3, r3
 801cd36:	b2db      	uxtb	r3, r3
 801cd38:	f003 0301 	and.w	r3, r3, #1
 801cd3c:	b2db      	uxtb	r3, r3
 801cd3e:	773b      	strb	r3, [r7, #28]
    little_endian_store_16(event, 13, channel->psm);
 801cd40:	68fb      	ldr	r3, [r7, #12]
 801cd42:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 801cd44:	f107 0310 	add.w	r3, r7, #16
 801cd48:	210d      	movs	r1, #13
 801cd4a:	4618      	mov	r0, r3
 801cd4c:	f7f2 f88b 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 15, channel->local_cid);
 801cd50:	68fb      	ldr	r3, [r7, #12]
 801cd52:	88da      	ldrh	r2, [r3, #6]
 801cd54:	f107 0310 	add.w	r3, r7, #16
 801cd58:	210f      	movs	r1, #15
 801cd5a:	4618      	mov	r0, r3
 801cd5c:	f7f2 f883 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 17, channel->remote_cid);
 801cd60:	68fb      	ldr	r3, [r7, #12]
 801cd62:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 801cd64:	f107 0310 	add.w	r3, r7, #16
 801cd68:	2111      	movs	r1, #17
 801cd6a:	4618      	mov	r0, r3
 801cd6c:	f7f2 f87b 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 19, channel->local_mtu);
 801cd70:	68fb      	ldr	r3, [r7, #12]
 801cd72:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
 801cd74:	f107 0310 	add.w	r3, r7, #16
 801cd78:	2113      	movs	r1, #19
 801cd7a:	4618      	mov	r0, r3
 801cd7c:	f7f2 f873 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(event, 21, channel->remote_mtu); 
 801cd80:	68fb      	ldr	r3, [r7, #12]
 801cd82:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
 801cd84:	f107 0310 	add.w	r3, r7, #16
 801cd88:	2115      	movs	r1, #21
 801cd8a:	4618      	mov	r0, r3
 801cd8c:	f7f2 f86b 	bl	800ee66 <little_endian_store_16>
    hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
 801cd90:	f107 0210 	add.w	r2, r7, #16
 801cd94:	2317      	movs	r3, #23
 801cd96:	2100      	movs	r1, #0
 801cd98:	2004      	movs	r0, #4
 801cd9a:	f7fa faab 	bl	80172f4 <hci_dump_packet>
    l2cap_dispatch_to_channel(channel, HCI_EVENT_PACKET, event, sizeof(event));
 801cd9e:	f107 0210 	add.w	r2, r7, #16
 801cda2:	2317      	movs	r3, #23
 801cda4:	2104      	movs	r1, #4
 801cda6:	68f8      	ldr	r0, [r7, #12]
 801cda8:	f7fb fd85 	bl	80188b6 <l2cap_dispatch_to_channel>
}
 801cdac:	bf00      	nop
 801cdae:	372c      	adds	r7, #44	; 0x2c
 801cdb0:	46bd      	mov	sp, r7
 801cdb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801cdb4:	0802b1dc 	.word	0x0802b1dc
 801cdb8:	0802c7c4 	.word	0x0802c7c4

0801cdbc <l2cap_emit_le_channel_closed>:
// 2
static void l2cap_emit_le_channel_closed(l2cap_channel_t * channel){
 801cdbc:	b580      	push	{r7, lr}
 801cdbe:	b086      	sub	sp, #24
 801cdc0:	af02      	add	r7, sp, #8
 801cdc2:	6078      	str	r0, [r7, #4]
    log_info("L2CAP_EVENT_LE_CHANNEL_CLOSED local_cid 0x%x", channel->local_cid);
 801cdc4:	687b      	ldr	r3, [r7, #4]
 801cdc6:	88db      	ldrh	r3, [r3, #6]
 801cdc8:	9300      	str	r3, [sp, #0]
 801cdca:	f640 7342 	movw	r3, #3906	; 0xf42
 801cdce:	4a11      	ldr	r2, [pc, #68]	; (801ce14 <l2cap_emit_le_channel_closed+0x58>)
 801cdd0:	4911      	ldr	r1, [pc, #68]	; (801ce18 <l2cap_emit_le_channel_closed+0x5c>)
 801cdd2:	2001      	movs	r0, #1
 801cdd4:	f7fa fb34 	bl	8017440 <hci_dump_log>
    uint8_t event[4];
    event[0] = L2CAP_EVENT_LE_CHANNEL_CLOSED;
 801cdd8:	237b      	movs	r3, #123	; 0x7b
 801cdda:	733b      	strb	r3, [r7, #12]
    event[1] = sizeof(event) - 2u;
 801cddc:	2302      	movs	r3, #2
 801cdde:	737b      	strb	r3, [r7, #13]
    little_endian_store_16(event, 2, channel->local_cid);
 801cde0:	687b      	ldr	r3, [r7, #4]
 801cde2:	88da      	ldrh	r2, [r3, #6]
 801cde4:	f107 030c 	add.w	r3, r7, #12
 801cde8:	2102      	movs	r1, #2
 801cdea:	4618      	mov	r0, r3
 801cdec:	f7f2 f83b 	bl	800ee66 <little_endian_store_16>
    hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
 801cdf0:	f107 020c 	add.w	r2, r7, #12
 801cdf4:	2304      	movs	r3, #4
 801cdf6:	2100      	movs	r1, #0
 801cdf8:	2004      	movs	r0, #4
 801cdfa:	f7fa fa7b 	bl	80172f4 <hci_dump_packet>
    l2cap_dispatch_to_channel(channel, HCI_EVENT_PACKET, event, sizeof(event));
 801cdfe:	f107 020c 	add.w	r2, r7, #12
 801ce02:	2304      	movs	r3, #4
 801ce04:	2104      	movs	r1, #4
 801ce06:	6878      	ldr	r0, [r7, #4]
 801ce08:	f7fb fd55 	bl	80188b6 <l2cap_dispatch_to_channel>
}
 801ce0c:	bf00      	nop
 801ce0e:	3710      	adds	r7, #16
 801ce10:	46bd      	mov	sp, r7
 801ce12:	bd80      	pop	{r7, pc}
 801ce14:	0802b1dc 	.word	0x0802b1dc
 801ce18:	0802c85c 	.word	0x0802c85c

0801ce1c <l2cap_le_send_pdu>:

static void l2cap_le_send_pdu(l2cap_channel_t *channel){
 801ce1c:	b580      	push	{r7, lr}
 801ce1e:	b08a      	sub	sp, #40	; 0x28
 801ce20:	af04      	add	r7, sp, #16
 801ce22:	6078      	str	r0, [r7, #4]
    btstack_assert(channel != NULL);
    btstack_assert(channel->send_sdu_buffer != NULL);
    btstack_assert(channel->credits_outgoing > 0);

    // send part of SDU
    hci_reserve_packet_buffer();
 801ce24:	f7f3 f946 	bl	80100b4 <hci_reserve_packet_buffer>
    uint8_t * acl_buffer = hci_get_outgoing_packet_buffer();
 801ce28:	f7f3 fcb4 	bl	8010794 <hci_get_outgoing_packet_buffer>
 801ce2c:	6138      	str	r0, [r7, #16]
    uint8_t * l2cap_payload = acl_buffer + 8;
 801ce2e:	693b      	ldr	r3, [r7, #16]
 801ce30:	3308      	adds	r3, #8
 801ce32:	60fb      	str	r3, [r7, #12]
    uint16_t pos = 0;
 801ce34:	2300      	movs	r3, #0
 801ce36:	82fb      	strh	r3, [r7, #22]
    if (!channel->send_sdu_pos){
 801ce38:	687b      	ldr	r3, [r7, #4]
 801ce3a:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 801ce3e:	2b00      	cmp	r3, #0
 801ce40:	d112      	bne.n	801ce68 <l2cap_le_send_pdu+0x4c>
        // store SDU len
        channel->send_sdu_pos += 2u;
 801ce42:	687b      	ldr	r3, [r7, #4]
 801ce44:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 801ce48:	3302      	adds	r3, #2
 801ce4a:	b29a      	uxth	r2, r3
 801ce4c:	687b      	ldr	r3, [r7, #4]
 801ce4e:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
        little_endian_store_16(l2cap_payload, pos, channel->send_sdu_len);
 801ce52:	687b      	ldr	r3, [r7, #4]
 801ce54:	f8b3 2048 	ldrh.w	r2, [r3, #72]	; 0x48
 801ce58:	8afb      	ldrh	r3, [r7, #22]
 801ce5a:	4619      	mov	r1, r3
 801ce5c:	68f8      	ldr	r0, [r7, #12]
 801ce5e:	f7f2 f802 	bl	800ee66 <little_endian_store_16>
        pos += 2u;
 801ce62:	8afb      	ldrh	r3, [r7, #22]
 801ce64:	3302      	adds	r3, #2
 801ce66:	82fb      	strh	r3, [r7, #22]
    }
    uint16_t payload_size = btstack_min(channel->send_sdu_len + 2u - channel->send_sdu_pos, channel->remote_mps - pos);
 801ce68:	687b      	ldr	r3, [r7, #4]
 801ce6a:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 801ce6e:	461a      	mov	r2, r3
 801ce70:	687b      	ldr	r3, [r7, #4]
 801ce72:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 801ce76:	1ad3      	subs	r3, r2, r3
 801ce78:	1c9a      	adds	r2, r3, #2
 801ce7a:	687b      	ldr	r3, [r7, #4]
 801ce7c:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 801ce80:	4619      	mov	r1, r3
 801ce82:	8afb      	ldrh	r3, [r7, #22]
 801ce84:	1acb      	subs	r3, r1, r3
 801ce86:	4619      	mov	r1, r3
 801ce88:	4610      	mov	r0, r2
 801ce8a:	f7f2 f940 	bl	800f10e <btstack_min>
 801ce8e:	4603      	mov	r3, r0
 801ce90:	817b      	strh	r3, [r7, #10]
    log_info("len %u, pos %u => payload %u, credits %u", channel->send_sdu_len, channel->send_sdu_pos, payload_size, channel->credits_outgoing);
 801ce92:	687b      	ldr	r3, [r7, #4]
 801ce94:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 801ce98:	4619      	mov	r1, r3
 801ce9a:	687b      	ldr	r3, [r7, #4]
 801ce9c:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 801cea0:	4618      	mov	r0, r3
 801cea2:	897b      	ldrh	r3, [r7, #10]
 801cea4:	687a      	ldr	r2, [r7, #4]
 801cea6:	f8b2 204e 	ldrh.w	r2, [r2, #78]	; 0x4e
 801ceaa:	9203      	str	r2, [sp, #12]
 801ceac:	9302      	str	r3, [sp, #8]
 801ceae:	9001      	str	r0, [sp, #4]
 801ceb0:	9100      	str	r1, [sp, #0]
 801ceb2:	f640 735c 	movw	r3, #3932	; 0xf5c
 801ceb6:	4a28      	ldr	r2, [pc, #160]	; (801cf58 <l2cap_le_send_pdu+0x13c>)
 801ceb8:	4928      	ldr	r1, [pc, #160]	; (801cf5c <l2cap_le_send_pdu+0x140>)
 801ceba:	2001      	movs	r0, #1
 801cebc:	f7fa fac0 	bl	8017440 <hci_dump_log>
    (void)memcpy(&l2cap_payload[pos],
 801cec0:	8afb      	ldrh	r3, [r7, #22]
 801cec2:	68fa      	ldr	r2, [r7, #12]
 801cec4:	18d0      	adds	r0, r2, r3
                 &channel->send_sdu_buffer[channel->send_sdu_pos - 2u],
 801cec6:	687b      	ldr	r3, [r7, #4]
 801cec8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801ceca:	687b      	ldr	r3, [r7, #4]
 801cecc:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 801ced0:	3b02      	subs	r3, #2
 801ced2:	4413      	add	r3, r2
    (void)memcpy(&l2cap_payload[pos],
 801ced4:	897a      	ldrh	r2, [r7, #10]
 801ced6:	4619      	mov	r1, r3
 801ced8:	f00a fdcf 	bl	8027a7a <memcpy>
                 payload_size); // -2 for virtual SDU len
    pos += payload_size;
 801cedc:	8afa      	ldrh	r2, [r7, #22]
 801cede:	897b      	ldrh	r3, [r7, #10]
 801cee0:	4413      	add	r3, r2
 801cee2:	82fb      	strh	r3, [r7, #22]
    channel->send_sdu_pos += payload_size;
 801cee4:	687b      	ldr	r3, [r7, #4]
 801cee6:	f8b3 204a 	ldrh.w	r2, [r3, #74]	; 0x4a
 801ceea:	897b      	ldrh	r3, [r7, #10]
 801ceec:	4413      	add	r3, r2
 801ceee:	b29a      	uxth	r2, r3
 801cef0:	687b      	ldr	r3, [r7, #4]
 801cef2:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
    l2cap_setup_header(acl_buffer, channel->con_handle, 0, channel->remote_cid, pos);
 801cef6:	687b      	ldr	r3, [r7, #4]
 801cef8:	8c99      	ldrh	r1, [r3, #36]	; 0x24
 801cefa:	687b      	ldr	r3, [r7, #4]
 801cefc:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 801cefe:	8afb      	ldrh	r3, [r7, #22]
 801cf00:	9300      	str	r3, [sp, #0]
 801cf02:	4613      	mov	r3, r2
 801cf04:	2200      	movs	r2, #0
 801cf06:	6938      	ldr	r0, [r7, #16]
 801cf08:	f7fb fc00 	bl	801870c <l2cap_setup_header>

    channel->credits_outgoing--;
 801cf0c:	687b      	ldr	r3, [r7, #4]
 801cf0e:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 801cf12:	3b01      	subs	r3, #1
 801cf14:	b29a      	uxth	r2, r3
 801cf16:	687b      	ldr	r3, [r7, #4]
 801cf18:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e

    hci_send_acl_packet_buffer(8u + pos);
 801cf1c:	8afb      	ldrh	r3, [r7, #22]
 801cf1e:	3308      	adds	r3, #8
 801cf20:	4618      	mov	r0, r3
 801cf22:	f7f3 f9c9 	bl	80102b8 <hci_send_acl_packet_buffer>

    if (channel->send_sdu_pos >= (channel->send_sdu_len + 2u)){
 801cf26:	687b      	ldr	r3, [r7, #4]
 801cf28:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 801cf2c:	461a      	mov	r2, r3
 801cf2e:	687b      	ldr	r3, [r7, #4]
 801cf30:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 801cf34:	3302      	adds	r3, #2
 801cf36:	429a      	cmp	r2, r3
 801cf38:	d309      	bcc.n	801cf4e <l2cap_le_send_pdu+0x132>
        channel->send_sdu_buffer = NULL;
 801cf3a:	687b      	ldr	r3, [r7, #4]
 801cf3c:	2200      	movs	r2, #0
 801cf3e:	645a      	str	r2, [r3, #68]	; 0x44
        // send done event
        l2cap_emit_simple_event_with_cid(channel, L2CAP_EVENT_LE_PACKET_SENT);
 801cf40:	217d      	movs	r1, #125	; 0x7d
 801cf42:	6878      	ldr	r0, [r7, #4]
 801cf44:	f7fb fccd 	bl	80188e2 <l2cap_emit_simple_event_with_cid>
        // inform about can send now
        l2cap_le_notify_channel_can_send(channel);
 801cf48:	6878      	ldr	r0, [r7, #4]
 801cf4a:	f7ff fe0b 	bl	801cb64 <l2cap_le_notify_channel_can_send>
    }
}
 801cf4e:	bf00      	nop
 801cf50:	3718      	adds	r7, #24
 801cf52:	46bd      	mov	sp, r7
 801cf54:	bd80      	pop	{r7, pc}
 801cf56:	bf00      	nop
 801cf58:	0802b1dc 	.word	0x0802b1dc
 801cf5c:	0802c890 	.word	0x0802c890

0801cf60 <l2cap_le_finialize_channel_close>:

// finalize closed channel - l2cap_handle_disconnect_request & DISCONNECTION_RESPONSE
void l2cap_le_finialize_channel_close(l2cap_channel_t * channel){
 801cf60:	b580      	push	{r7, lr}
 801cf62:	b082      	sub	sp, #8
 801cf64:	af00      	add	r7, sp, #0
 801cf66:	6078      	str	r0, [r7, #4]
    channel->state = L2CAP_STATE_CLOSED;
 801cf68:	687b      	ldr	r3, [r7, #4]
 801cf6a:	2201      	movs	r2, #1
 801cf6c:	f883 2020 	strb.w	r2, [r3, #32]
    l2cap_emit_simple_event_with_cid(channel, L2CAP_EVENT_CHANNEL_CLOSED);
 801cf70:	2171      	movs	r1, #113	; 0x71
 801cf72:	6878      	ldr	r0, [r7, #4]
 801cf74:	f7fb fcb5 	bl	80188e2 <l2cap_emit_simple_event_with_cid>
    // discard channel
    btstack_linked_list_remove(&l2cap_channels, (btstack_linked_item_t *) channel);
 801cf78:	6879      	ldr	r1, [r7, #4]
 801cf7a:	4805      	ldr	r0, [pc, #20]	; (801cf90 <l2cap_le_finialize_channel_close+0x30>)
 801cf7c:	f7f1 fb9f 	bl	800e6be <btstack_linked_list_remove>
    l2cap_free_channel_entry(channel);
 801cf80:	6878      	ldr	r0, [r7, #4]
 801cf82:	f7fd f9b5 	bl	801a2f0 <l2cap_free_channel_entry>
}
 801cf86:	bf00      	nop
 801cf88:	3708      	adds	r7, #8
 801cf8a:	46bd      	mov	sp, r7
 801cf8c:	bd80      	pop	{r7, pc}
 801cf8e:	bf00      	nop
 801cf90:	20009eac 	.word	0x20009eac

0801cf94 <l2cap_le_get_service>:

static inline l2cap_service_t * l2cap_le_get_service(uint16_t le_psm){
 801cf94:	b580      	push	{r7, lr}
 801cf96:	b082      	sub	sp, #8
 801cf98:	af00      	add	r7, sp, #0
 801cf9a:	4603      	mov	r3, r0
 801cf9c:	80fb      	strh	r3, [r7, #6]
    return l2cap_get_service_internal(&l2cap_le_services, le_psm);
 801cf9e:	88fb      	ldrh	r3, [r7, #6]
 801cfa0:	4619      	mov	r1, r3
 801cfa2:	4804      	ldr	r0, [pc, #16]	; (801cfb4 <l2cap_le_get_service+0x20>)
 801cfa4:	f7ff fda4 	bl	801caf0 <l2cap_get_service_internal>
 801cfa8:	4603      	mov	r3, r0
}
 801cfaa:	4618      	mov	r0, r3
 801cfac:	3708      	adds	r7, #8
 801cfae:	46bd      	mov	sp, r7
 801cfb0:	bd80      	pop	{r7, pc}
 801cfb2:	bf00      	nop
 801cfb4:	20009ea8 	.word	0x20009ea8

0801cfb8 <l2cap_create_signaling_internal>:
#include "btstack_debug.h"
#include "hci.h"

#include <string.h>

static uint16_t l2cap_create_signaling_internal(uint8_t * acl_buffer, hci_con_handle_t handle, bool is_classic, uint16_t cid, L2CAP_SIGNALING_COMMANDS cmd, uint8_t identifier, va_list argptr){
 801cfb8:	b580      	push	{r7, lr}
 801cfba:	b08a      	sub	sp, #40	; 0x28
 801cfbc:	af02      	add	r7, sp, #8
 801cfbe:	60f8      	str	r0, [r7, #12]
 801cfc0:	4608      	mov	r0, r1
 801cfc2:	4611      	mov	r1, r2
 801cfc4:	461a      	mov	r2, r3
 801cfc6:	4603      	mov	r3, r0
 801cfc8:	817b      	strh	r3, [r7, #10]
 801cfca:	460b      	mov	r3, r1
 801cfcc:	727b      	strb	r3, [r7, #9]
 801cfce:	4613      	mov	r3, r2
 801cfd0:	80fb      	strh	r3, [r7, #6]
            "22",    // 0x16 le flow control credit: source cid, credits
#endif
    };
    static const unsigned int num_l2cap_commands = sizeof(l2cap_signaling_commands_format) / sizeof(const char *);

    const char *format = NULL;
 801cfd2:	2300      	movs	r3, #0
 801cfd4:	61fb      	str	r3, [r7, #28]
    if ((cmd > 0u) && (cmd <= num_l2cap_commands)) {
 801cfd6:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 801cfda:	2b00      	cmp	r3, #0
 801cfdc:	d00c      	beq.n	801cff8 <l2cap_create_signaling_internal+0x40>
 801cfde:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
 801cfe2:	4b56      	ldr	r3, [pc, #344]	; (801d13c <l2cap_create_signaling_internal+0x184>)
 801cfe4:	681b      	ldr	r3, [r3, #0]
 801cfe6:	429a      	cmp	r2, r3
 801cfe8:	d806      	bhi.n	801cff8 <l2cap_create_signaling_internal+0x40>
        format = l2cap_signaling_commands_format[cmd-1u];
 801cfea:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 801cfee:	3b01      	subs	r3, #1
 801cff0:	4a53      	ldr	r2, [pc, #332]	; (801d140 <l2cap_create_signaling_internal+0x188>)
 801cff2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801cff6:	61fb      	str	r3, [r7, #28]
    }
    if (!format){
 801cff8:	69fb      	ldr	r3, [r7, #28]
 801cffa:	2b00      	cmp	r3, #0
 801cffc:	d10a      	bne.n	801d014 <l2cap_create_signaling_internal+0x5c>
        log_error("l2cap_create_signaling_internal: invalid command id 0x%02x", cmd);
 801cffe:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 801d002:	9300      	str	r3, [sp, #0]
 801d004:	2358      	movs	r3, #88	; 0x58
 801d006:	4a4f      	ldr	r2, [pc, #316]	; (801d144 <l2cap_create_signaling_internal+0x18c>)
 801d008:	494f      	ldr	r1, [pc, #316]	; (801d148 <l2cap_create_signaling_internal+0x190>)
 801d00a:	2002      	movs	r0, #2
 801d00c:	f7fa fa18 	bl	8017440 <hci_dump_log>
        return 0;
 801d010:	2300      	movs	r3, #0
 801d012:	e08e      	b.n	801d132 <l2cap_create_signaling_internal+0x17a>
    }

    int pb = 0x00;  // First non-automatically-flushable packet of a higher layer message 
 801d014:	2300      	movs	r3, #0
 801d016:	61bb      	str	r3, [r7, #24]
#ifdef ENABLE_CLASSIC
    if (is_classic){
 801d018:	7a7b      	ldrb	r3, [r7, #9]
 801d01a:	2b00      	cmp	r3, #0
 801d01c:	d008      	beq.n	801d030 <l2cap_create_signaling_internal+0x78>
        pb = hci_non_flushable_packet_boundary_flag_supported() ? 0x00 : 0x02;
 801d01e:	f7f3 fbe5 	bl	80107ec <hci_non_flushable_packet_boundary_flag_supported>
 801d022:	4603      	mov	r3, r0
 801d024:	2b00      	cmp	r3, #0
 801d026:	d001      	beq.n	801d02c <l2cap_create_signaling_internal+0x74>
 801d028:	2300      	movs	r3, #0
 801d02a:	e000      	b.n	801d02e <l2cap_create_signaling_internal+0x76>
 801d02c:	2302      	movs	r3, #2
 801d02e:	61bb      	str	r3, [r7, #24]
#else
    UNUSED(is_classic);
#endif

    // 0 - Connection handle : PB=pb : BC=00 
    little_endian_store_16(acl_buffer, 0u, handle | (pb << 12u) | (0u << 14u));
 801d030:	69bb      	ldr	r3, [r7, #24]
 801d032:	031b      	lsls	r3, r3, #12
 801d034:	b21a      	sxth	r2, r3
 801d036:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801d03a:	4313      	orrs	r3, r2
 801d03c:	b21b      	sxth	r3, r3
 801d03e:	b29b      	uxth	r3, r3
 801d040:	461a      	mov	r2, r3
 801d042:	2100      	movs	r1, #0
 801d044:	68f8      	ldr	r0, [r7, #12]
 801d046:	f7f1 ff0e 	bl	800ee66 <little_endian_store_16>
    // 6 - L2CAP channel = 1
    little_endian_store_16(acl_buffer, 6, cid);
 801d04a:	88fb      	ldrh	r3, [r7, #6]
 801d04c:	461a      	mov	r2, r3
 801d04e:	2106      	movs	r1, #6
 801d050:	68f8      	ldr	r0, [r7, #12]
 801d052:	f7f1 ff08 	bl	800ee66 <little_endian_store_16>
    // 8 - Code
    acl_buffer[8] = cmd;
 801d056:	68fb      	ldr	r3, [r7, #12]
 801d058:	3308      	adds	r3, #8
 801d05a:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
 801d05e:	701a      	strb	r2, [r3, #0]
    // 9 - id (!= 0 sequentially)
    acl_buffer[9] = identifier;
 801d060:	68fb      	ldr	r3, [r7, #12]
 801d062:	3309      	adds	r3, #9
 801d064:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 801d068:	701a      	strb	r2, [r3, #0]
    
    // 12 - L2CAP signaling parameters
    uint16_t pos = 12;
 801d06a:	230c      	movs	r3, #12
 801d06c:	82fb      	strh	r3, [r7, #22]
    uint16_t word;
    uint8_t * ptr;
    while (*format) {
 801d06e:	e043      	b.n	801d0f8 <l2cap_create_signaling_internal+0x140>
        switch(*format) {
 801d070:	69fb      	ldr	r3, [r7, #28]
 801d072:	781b      	ldrb	r3, [r3, #0]
 801d074:	2b31      	cmp	r3, #49	; 0x31
 801d076:	db39      	blt.n	801d0ec <l2cap_create_signaling_internal+0x134>
 801d078:	2b32      	cmp	r3, #50	; 0x32
 801d07a:	dd02      	ble.n	801d082 <l2cap_create_signaling_internal+0xca>
 801d07c:	2b44      	cmp	r3, #68	; 0x44
 801d07e:	d01e      	beq.n	801d0be <l2cap_create_signaling_internal+0x106>
                ptr  = va_arg(argptr, uint8_t *);
                (void)memcpy(&acl_buffer[pos], ptr, word);
                pos += word;
                break;
            default:
                break;
 801d080:	e034      	b.n	801d0ec <l2cap_create_signaling_internal+0x134>
                word = va_arg(argptr, int);
 801d082:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d084:	1d1a      	adds	r2, r3, #4
 801d086:	633a      	str	r2, [r7, #48]	; 0x30
 801d088:	681b      	ldr	r3, [r3, #0]
 801d08a:	82bb      	strh	r3, [r7, #20]
                acl_buffer[pos++] = word & 0xffu;
 801d08c:	8afb      	ldrh	r3, [r7, #22]
 801d08e:	1c5a      	adds	r2, r3, #1
 801d090:	82fa      	strh	r2, [r7, #22]
 801d092:	461a      	mov	r2, r3
 801d094:	68fb      	ldr	r3, [r7, #12]
 801d096:	4413      	add	r3, r2
 801d098:	8aba      	ldrh	r2, [r7, #20]
 801d09a:	b2d2      	uxtb	r2, r2
 801d09c:	701a      	strb	r2, [r3, #0]
                if (*format == '2') {
 801d09e:	69fb      	ldr	r3, [r7, #28]
 801d0a0:	781b      	ldrb	r3, [r3, #0]
 801d0a2:	2b32      	cmp	r3, #50	; 0x32
 801d0a4:	d124      	bne.n	801d0f0 <l2cap_create_signaling_internal+0x138>
                    acl_buffer[pos++] = word >> 8;
 801d0a6:	8abb      	ldrh	r3, [r7, #20]
 801d0a8:	0a1b      	lsrs	r3, r3, #8
 801d0aa:	b29a      	uxth	r2, r3
 801d0ac:	8afb      	ldrh	r3, [r7, #22]
 801d0ae:	1c59      	adds	r1, r3, #1
 801d0b0:	82f9      	strh	r1, [r7, #22]
 801d0b2:	4619      	mov	r1, r3
 801d0b4:	68fb      	ldr	r3, [r7, #12]
 801d0b6:	440b      	add	r3, r1
 801d0b8:	b2d2      	uxtb	r2, r2
 801d0ba:	701a      	strb	r2, [r3, #0]
                break;
 801d0bc:	e018      	b.n	801d0f0 <l2cap_create_signaling_internal+0x138>
                word = va_arg(argptr, int);
 801d0be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d0c0:	1d1a      	adds	r2, r3, #4
 801d0c2:	633a      	str	r2, [r7, #48]	; 0x30
 801d0c4:	681b      	ldr	r3, [r3, #0]
 801d0c6:	82bb      	strh	r3, [r7, #20]
                ptr  = va_arg(argptr, uint8_t *);
 801d0c8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d0ca:	1d1a      	adds	r2, r3, #4
 801d0cc:	633a      	str	r2, [r7, #48]	; 0x30
 801d0ce:	681b      	ldr	r3, [r3, #0]
 801d0d0:	613b      	str	r3, [r7, #16]
                (void)memcpy(&acl_buffer[pos], ptr, word);
 801d0d2:	8afb      	ldrh	r3, [r7, #22]
 801d0d4:	68fa      	ldr	r2, [r7, #12]
 801d0d6:	4413      	add	r3, r2
 801d0d8:	8aba      	ldrh	r2, [r7, #20]
 801d0da:	6939      	ldr	r1, [r7, #16]
 801d0dc:	4618      	mov	r0, r3
 801d0de:	f00a fccc 	bl	8027a7a <memcpy>
                pos += word;
 801d0e2:	8afa      	ldrh	r2, [r7, #22]
 801d0e4:	8abb      	ldrh	r3, [r7, #20]
 801d0e6:	4413      	add	r3, r2
 801d0e8:	82fb      	strh	r3, [r7, #22]
                break;
 801d0ea:	e002      	b.n	801d0f2 <l2cap_create_signaling_internal+0x13a>
                break;
 801d0ec:	bf00      	nop
 801d0ee:	e000      	b.n	801d0f2 <l2cap_create_signaling_internal+0x13a>
                break;
 801d0f0:	bf00      	nop
        }
        format++;
 801d0f2:	69fb      	ldr	r3, [r7, #28]
 801d0f4:	3301      	adds	r3, #1
 801d0f6:	61fb      	str	r3, [r7, #28]
    while (*format) {
 801d0f8:	69fb      	ldr	r3, [r7, #28]
 801d0fa:	781b      	ldrb	r3, [r3, #0]
 801d0fc:	2b00      	cmp	r3, #0
 801d0fe:	d1b7      	bne.n	801d070 <l2cap_create_signaling_internal+0xb8>
    
    // Fill in various length fields: it's the number of bytes following for ACL lenght and l2cap parameter length
    // - the l2cap payload length is counted after the following channel id (only payload) 
    
    // 2 - ACL length
    little_endian_store_16(acl_buffer, 2u,  pos - 4u);
 801d100:	8afb      	ldrh	r3, [r7, #22]
 801d102:	3b04      	subs	r3, #4
 801d104:	b29b      	uxth	r3, r3
 801d106:	461a      	mov	r2, r3
 801d108:	2102      	movs	r1, #2
 801d10a:	68f8      	ldr	r0, [r7, #12]
 801d10c:	f7f1 feab 	bl	800ee66 <little_endian_store_16>
    // 4 - L2CAP packet length
    little_endian_store_16(acl_buffer, 4u,  pos - 6u - 2u);
 801d110:	8afb      	ldrh	r3, [r7, #22]
 801d112:	3b08      	subs	r3, #8
 801d114:	b29b      	uxth	r3, r3
 801d116:	461a      	mov	r2, r3
 801d118:	2104      	movs	r1, #4
 801d11a:	68f8      	ldr	r0, [r7, #12]
 801d11c:	f7f1 fea3 	bl	800ee66 <little_endian_store_16>
    // 10 - L2CAP signaling parameter length
    little_endian_store_16(acl_buffer, 10u, pos - 12u);
 801d120:	8afb      	ldrh	r3, [r7, #22]
 801d122:	3b0c      	subs	r3, #12
 801d124:	b29b      	uxth	r3, r3
 801d126:	461a      	mov	r2, r3
 801d128:	210a      	movs	r1, #10
 801d12a:	68f8      	ldr	r0, [r7, #12]
 801d12c:	f7f1 fe9b 	bl	800ee66 <little_endian_store_16>
    
    return pos;
 801d130:	8afb      	ldrh	r3, [r7, #22]
}
 801d132:	4618      	mov	r0, r3
 801d134:	3720      	adds	r7, #32
 801d136:	46bd      	mov	sp, r7
 801d138:	bd80      	pop	{r7, pc}
 801d13a:	bf00      	nop
 801d13c:	08030e80 	.word	0x08030e80
 801d140:	20000044 	.word	0x20000044
 801d144:	0802cb08 	.word	0x0802cb08
 801d148:	0802cb1c 	.word	0x0802cb1c

0801d14c <l2cap_create_signaling_classic>:

uint16_t l2cap_create_signaling_classic(uint8_t * acl_buffer, hci_con_handle_t handle, L2CAP_SIGNALING_COMMANDS cmd, uint8_t identifier, va_list argptr){
 801d14c:	b580      	push	{r7, lr}
 801d14e:	b086      	sub	sp, #24
 801d150:	af04      	add	r7, sp, #16
 801d152:	6078      	str	r0, [r7, #4]
 801d154:	4608      	mov	r0, r1
 801d156:	4611      	mov	r1, r2
 801d158:	461a      	mov	r2, r3
 801d15a:	4603      	mov	r3, r0
 801d15c:	807b      	strh	r3, [r7, #2]
 801d15e:	460b      	mov	r3, r1
 801d160:	707b      	strb	r3, [r7, #1]
 801d162:	4613      	mov	r3, r2
 801d164:	703b      	strb	r3, [r7, #0]
    return l2cap_create_signaling_internal(acl_buffer, handle, true, 1, cmd, identifier, argptr);
 801d166:	8879      	ldrh	r1, [r7, #2]
 801d168:	693b      	ldr	r3, [r7, #16]
 801d16a:	9302      	str	r3, [sp, #8]
 801d16c:	783b      	ldrb	r3, [r7, #0]
 801d16e:	9301      	str	r3, [sp, #4]
 801d170:	787b      	ldrb	r3, [r7, #1]
 801d172:	9300      	str	r3, [sp, #0]
 801d174:	2301      	movs	r3, #1
 801d176:	2201      	movs	r2, #1
 801d178:	6878      	ldr	r0, [r7, #4]
 801d17a:	f7ff ff1d 	bl	801cfb8 <l2cap_create_signaling_internal>
 801d17e:	4603      	mov	r3, r0
}
 801d180:	4618      	mov	r0, r3
 801d182:	3708      	adds	r7, #8
 801d184:	46bd      	mov	sp, r7
 801d186:	bd80      	pop	{r7, pc}

0801d188 <l2cap_create_signaling_le>:

#ifdef ENABLE_BLE
uint16_t l2cap_create_signaling_le(uint8_t * acl_buffer, hci_con_handle_t handle, L2CAP_SIGNALING_COMMANDS cmd, uint8_t identifier, va_list argptr){
 801d188:	b580      	push	{r7, lr}
 801d18a:	b086      	sub	sp, #24
 801d18c:	af04      	add	r7, sp, #16
 801d18e:	6078      	str	r0, [r7, #4]
 801d190:	4608      	mov	r0, r1
 801d192:	4611      	mov	r1, r2
 801d194:	461a      	mov	r2, r3
 801d196:	4603      	mov	r3, r0
 801d198:	807b      	strh	r3, [r7, #2]
 801d19a:	460b      	mov	r3, r1
 801d19c:	707b      	strb	r3, [r7, #1]
 801d19e:	4613      	mov	r3, r2
 801d1a0:	703b      	strb	r3, [r7, #0]
    return l2cap_create_signaling_internal(acl_buffer, handle, false, 5, cmd, identifier, argptr);
 801d1a2:	8879      	ldrh	r1, [r7, #2]
 801d1a4:	693b      	ldr	r3, [r7, #16]
 801d1a6:	9302      	str	r3, [sp, #8]
 801d1a8:	783b      	ldrb	r3, [r7, #0]
 801d1aa:	9301      	str	r3, [sp, #4]
 801d1ac:	787b      	ldrb	r3, [r7, #1]
 801d1ae:	9300      	str	r3, [sp, #0]
 801d1b0:	2305      	movs	r3, #5
 801d1b2:	2200      	movs	r2, #0
 801d1b4:	6878      	ldr	r0, [r7, #4]
 801d1b6:	f7ff feff 	bl	801cfb8 <l2cap_create_signaling_internal>
 801d1ba:	4603      	mov	r3, r0
}
 801d1bc:	4618      	mov	r0, r3
 801d1be:	3708      	adds	r7, #8
 801d1c0:	46bd      	mov	sp, r7
 801d1c2:	bd80      	pop	{r7, pc}

0801d1c4 <is_Bluetooth_Base_UUID>:
    ATT_READ,
    ATT_WRITE,
} att_operation_t;


static int is_Bluetooth_Base_UUID(uint8_t const *uuid){
 801d1c4:	b580      	push	{r7, lr}
 801d1c6:	b082      	sub	sp, #8
 801d1c8:	af00      	add	r7, sp, #0
 801d1ca:	6078      	str	r0, [r7, #4]
    // Bluetooth Base UUID 00000000-0000-1000-8000-00805F9B34FB in little endian
    static const uint8_t bluetooth_base_uuid[] = { 0xfb, 0x34, 0x9b, 0x5f, 0x80, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

    if (memcmp(&uuid[0],  &bluetooth_base_uuid[0], 12) != 0) return false;
 801d1cc:	220c      	movs	r2, #12
 801d1ce:	490d      	ldr	r1, [pc, #52]	; (801d204 <is_Bluetooth_Base_UUID+0x40>)
 801d1d0:	6878      	ldr	r0, [r7, #4]
 801d1d2:	f00a fc43 	bl	8027a5c <memcmp>
 801d1d6:	4603      	mov	r3, r0
 801d1d8:	2b00      	cmp	r3, #0
 801d1da:	d001      	beq.n	801d1e0 <is_Bluetooth_Base_UUID+0x1c>
 801d1dc:	2300      	movs	r3, #0
 801d1de:	e00c      	b.n	801d1fa <is_Bluetooth_Base_UUID+0x36>
    if (memcmp(&uuid[14], &bluetooth_base_uuid[14], 2) != 0) return false;
 801d1e0:	687b      	ldr	r3, [r7, #4]
 801d1e2:	330e      	adds	r3, #14
 801d1e4:	2202      	movs	r2, #2
 801d1e6:	4908      	ldr	r1, [pc, #32]	; (801d208 <is_Bluetooth_Base_UUID+0x44>)
 801d1e8:	4618      	mov	r0, r3
 801d1ea:	f00a fc37 	bl	8027a5c <memcmp>
 801d1ee:	4603      	mov	r3, r0
 801d1f0:	2b00      	cmp	r3, #0
 801d1f2:	d001      	beq.n	801d1f8 <is_Bluetooth_Base_UUID+0x34>
 801d1f4:	2300      	movs	r3, #0
 801d1f6:	e000      	b.n	801d1fa <is_Bluetooth_Base_UUID+0x36>
    return true;
 801d1f8:	2301      	movs	r3, #1
    
}
 801d1fa:	4618      	mov	r0, r3
 801d1fc:	3708      	adds	r7, #8
 801d1fe:	46bd      	mov	sp, r7
 801d200:	bd80      	pop	{r7, pc}
 801d202:	bf00      	nop
 801d204:	08030e84 	.word	0x08030e84
 801d208:	08030e92 	.word	0x08030e92

0801d20c <uuid16_from_uuid>:

static uint16_t uuid16_from_uuid(uint16_t uuid_len, uint8_t * uuid){
 801d20c:	b580      	push	{r7, lr}
 801d20e:	b082      	sub	sp, #8
 801d210:	af00      	add	r7, sp, #0
 801d212:	4603      	mov	r3, r0
 801d214:	6039      	str	r1, [r7, #0]
 801d216:	80fb      	strh	r3, [r7, #6]
    if (uuid_len == 2u) return little_endian_read_16(uuid, 0u);
 801d218:	88fb      	ldrh	r3, [r7, #6]
 801d21a:	2b02      	cmp	r3, #2
 801d21c:	d105      	bne.n	801d22a <uuid16_from_uuid+0x1e>
 801d21e:	2100      	movs	r1, #0
 801d220:	6838      	ldr	r0, [r7, #0]
 801d222:	f7f1 fde0 	bl	800ede6 <little_endian_read_16>
 801d226:	4603      	mov	r3, r0
 801d228:	e00c      	b.n	801d244 <uuid16_from_uuid+0x38>
    if (!is_Bluetooth_Base_UUID(uuid)) return 0;
 801d22a:	6838      	ldr	r0, [r7, #0]
 801d22c:	f7ff ffca 	bl	801d1c4 <is_Bluetooth_Base_UUID>
 801d230:	4603      	mov	r3, r0
 801d232:	2b00      	cmp	r3, #0
 801d234:	d101      	bne.n	801d23a <uuid16_from_uuid+0x2e>
 801d236:	2300      	movs	r3, #0
 801d238:	e004      	b.n	801d244 <uuid16_from_uuid+0x38>
    return little_endian_read_16(uuid, 12);
 801d23a:	210c      	movs	r1, #12
 801d23c:	6838      	ldr	r0, [r7, #0]
 801d23e:	f7f1 fdd2 	bl	800ede6 <little_endian_read_16>
 801d242:	4603      	mov	r3, r0
}
 801d244:	4618      	mov	r0, r3
 801d246:	3708      	adds	r7, #8
 801d248:	46bd      	mov	sp, r7
 801d24a:	bd80      	pop	{r7, pc}

0801d24c <att_iterator_init>:

// single cache for att_is_persistent_ccc - stores flags before write callback
static uint16_t att_persistent_ccc_handle;
static uint16_t att_persistent_ccc_uuid16;

static void att_iterator_init(att_iterator_t *it){
 801d24c:	b480      	push	{r7}
 801d24e:	b083      	sub	sp, #12
 801d250:	af00      	add	r7, sp, #0
 801d252:	6078      	str	r0, [r7, #4]
    it->att_ptr = att_db;
 801d254:	4b04      	ldr	r3, [pc, #16]	; (801d268 <att_iterator_init+0x1c>)
 801d256:	681a      	ldr	r2, [r3, #0]
 801d258:	687b      	ldr	r3, [r7, #4]
 801d25a:	601a      	str	r2, [r3, #0]
}
 801d25c:	bf00      	nop
 801d25e:	370c      	adds	r7, #12
 801d260:	46bd      	mov	sp, r7
 801d262:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d266:	4770      	bx	lr
 801d268:	20009ee0 	.word	0x20009ee0

0801d26c <att_iterator_has_next>:

static bool att_iterator_has_next(att_iterator_t *it){
 801d26c:	b480      	push	{r7}
 801d26e:	b083      	sub	sp, #12
 801d270:	af00      	add	r7, sp, #0
 801d272:	6078      	str	r0, [r7, #4]
    return it->att_ptr != NULL;
 801d274:	687b      	ldr	r3, [r7, #4]
 801d276:	681b      	ldr	r3, [r3, #0]
 801d278:	2b00      	cmp	r3, #0
 801d27a:	bf14      	ite	ne
 801d27c:	2301      	movne	r3, #1
 801d27e:	2300      	moveq	r3, #0
 801d280:	b2db      	uxtb	r3, r3
}
 801d282:	4618      	mov	r0, r3
 801d284:	370c      	adds	r7, #12
 801d286:	46bd      	mov	sp, r7
 801d288:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d28c:	4770      	bx	lr

0801d28e <att_iterator_fetch_next>:

static void att_iterator_fetch_next(att_iterator_t *it){
 801d28e:	b580      	push	{r7, lr}
 801d290:	b082      	sub	sp, #8
 801d292:	af00      	add	r7, sp, #0
 801d294:	6078      	str	r0, [r7, #4]
    it->size   = little_endian_read_16(it->att_ptr, 0);
 801d296:	687b      	ldr	r3, [r7, #4]
 801d298:	681b      	ldr	r3, [r3, #0]
 801d29a:	2100      	movs	r1, #0
 801d29c:	4618      	mov	r0, r3
 801d29e:	f7f1 fda2 	bl	800ede6 <little_endian_read_16>
 801d2a2:	4603      	mov	r3, r0
 801d2a4:	461a      	mov	r2, r3
 801d2a6:	687b      	ldr	r3, [r7, #4]
 801d2a8:	809a      	strh	r2, [r3, #4]
    if (it->size == 0u){
 801d2aa:	687b      	ldr	r3, [r7, #4]
 801d2ac:	889b      	ldrh	r3, [r3, #4]
 801d2ae:	2b00      	cmp	r3, #0
 801d2b0:	d112      	bne.n	801d2d8 <att_iterator_fetch_next+0x4a>
        it->flags = 0;
 801d2b2:	687b      	ldr	r3, [r7, #4]
 801d2b4:	2200      	movs	r2, #0
 801d2b6:	80da      	strh	r2, [r3, #6]
        it->handle = 0;
 801d2b8:	687b      	ldr	r3, [r7, #4]
 801d2ba:	2200      	movs	r2, #0
 801d2bc:	811a      	strh	r2, [r3, #8]
        it->uuid = NULL;
 801d2be:	687b      	ldr	r3, [r7, #4]
 801d2c0:	2200      	movs	r2, #0
 801d2c2:	60da      	str	r2, [r3, #12]
        it->value_len = 0;
 801d2c4:	687b      	ldr	r3, [r7, #4]
 801d2c6:	2200      	movs	r2, #0
 801d2c8:	821a      	strh	r2, [r3, #16]
        it->value = NULL;
 801d2ca:	687b      	ldr	r3, [r7, #4]
 801d2cc:	2200      	movs	r2, #0
 801d2ce:	615a      	str	r2, [r3, #20]
        it->att_ptr = NULL;
 801d2d0:	687b      	ldr	r3, [r7, #4]
 801d2d2:	2200      	movs	r2, #0
 801d2d4:	601a      	str	r2, [r3, #0]
        return;
 801d2d6:	e03e      	b.n	801d356 <att_iterator_fetch_next+0xc8>
    }
    it->flags  = little_endian_read_16(it->att_ptr, 2);
 801d2d8:	687b      	ldr	r3, [r7, #4]
 801d2da:	681b      	ldr	r3, [r3, #0]
 801d2dc:	2102      	movs	r1, #2
 801d2de:	4618      	mov	r0, r3
 801d2e0:	f7f1 fd81 	bl	800ede6 <little_endian_read_16>
 801d2e4:	4603      	mov	r3, r0
 801d2e6:	461a      	mov	r2, r3
 801d2e8:	687b      	ldr	r3, [r7, #4]
 801d2ea:	80da      	strh	r2, [r3, #6]
    it->handle = little_endian_read_16(it->att_ptr, 4);
 801d2ec:	687b      	ldr	r3, [r7, #4]
 801d2ee:	681b      	ldr	r3, [r3, #0]
 801d2f0:	2104      	movs	r1, #4
 801d2f2:	4618      	mov	r0, r3
 801d2f4:	f7f1 fd77 	bl	800ede6 <little_endian_read_16>
 801d2f8:	4603      	mov	r3, r0
 801d2fa:	461a      	mov	r2, r3
 801d2fc:	687b      	ldr	r3, [r7, #4]
 801d2fe:	811a      	strh	r2, [r3, #8]
    it->uuid   = &it->att_ptr[6];
 801d300:	687b      	ldr	r3, [r7, #4]
 801d302:	681b      	ldr	r3, [r3, #0]
 801d304:	1d9a      	adds	r2, r3, #6
 801d306:	687b      	ldr	r3, [r7, #4]
 801d308:	60da      	str	r2, [r3, #12]
    // handle 128 bit UUIDs
    if ((it->flags & ATT_PROPERTY_UUID128) != 0u){
 801d30a:	687b      	ldr	r3, [r7, #4]
 801d30c:	88db      	ldrh	r3, [r3, #6]
 801d30e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801d312:	2b00      	cmp	r3, #0
 801d314:	d00c      	beq.n	801d330 <att_iterator_fetch_next+0xa2>
        it->value_len = it->size - 22u;
 801d316:	687b      	ldr	r3, [r7, #4]
 801d318:	889b      	ldrh	r3, [r3, #4]
 801d31a:	3b16      	subs	r3, #22
 801d31c:	b29a      	uxth	r2, r3
 801d31e:	687b      	ldr	r3, [r7, #4]
 801d320:	821a      	strh	r2, [r3, #16]
        it->value  = &it->att_ptr[22];
 801d322:	687b      	ldr	r3, [r7, #4]
 801d324:	681b      	ldr	r3, [r3, #0]
 801d326:	f103 0216 	add.w	r2, r3, #22
 801d32a:	687b      	ldr	r3, [r7, #4]
 801d32c:	615a      	str	r2, [r3, #20]
 801d32e:	e00b      	b.n	801d348 <att_iterator_fetch_next+0xba>
    } else {
        it->value_len = it->size - 8u;
 801d330:	687b      	ldr	r3, [r7, #4]
 801d332:	889b      	ldrh	r3, [r3, #4]
 801d334:	3b08      	subs	r3, #8
 801d336:	b29a      	uxth	r2, r3
 801d338:	687b      	ldr	r3, [r7, #4]
 801d33a:	821a      	strh	r2, [r3, #16]
        it->value  = &it->att_ptr[8];
 801d33c:	687b      	ldr	r3, [r7, #4]
 801d33e:	681b      	ldr	r3, [r3, #0]
 801d340:	f103 0208 	add.w	r2, r3, #8
 801d344:	687b      	ldr	r3, [r7, #4]
 801d346:	615a      	str	r2, [r3, #20]
    }
    // advance AFTER setting values
    it->att_ptr += it->size;
 801d348:	687b      	ldr	r3, [r7, #4]
 801d34a:	681b      	ldr	r3, [r3, #0]
 801d34c:	687a      	ldr	r2, [r7, #4]
 801d34e:	8892      	ldrh	r2, [r2, #4]
 801d350:	441a      	add	r2, r3
 801d352:	687b      	ldr	r3, [r7, #4]
 801d354:	601a      	str	r2, [r3, #0]
}
 801d356:	3708      	adds	r7, #8
 801d358:	46bd      	mov	sp, r7
 801d35a:	bd80      	pop	{r7, pc}

0801d35c <att_iterator_match_uuid16>:

static int att_iterator_match_uuid16(att_iterator_t *it, uint16_t uuid){
 801d35c:	b580      	push	{r7, lr}
 801d35e:	b082      	sub	sp, #8
 801d360:	af00      	add	r7, sp, #0
 801d362:	6078      	str	r0, [r7, #4]
 801d364:	460b      	mov	r3, r1
 801d366:	807b      	strh	r3, [r7, #2]
    if (it->handle == 0u) return 0u;
 801d368:	687b      	ldr	r3, [r7, #4]
 801d36a:	891b      	ldrh	r3, [r3, #8]
 801d36c:	2b00      	cmp	r3, #0
 801d36e:	d101      	bne.n	801d374 <att_iterator_match_uuid16+0x18>
 801d370:	2300      	movs	r3, #0
 801d372:	e02c      	b.n	801d3ce <att_iterator_match_uuid16+0x72>
    if (it->flags & ATT_PROPERTY_UUID128){
 801d374:	687b      	ldr	r3, [r7, #4]
 801d376:	88db      	ldrh	r3, [r3, #6]
 801d378:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801d37c:	2b00      	cmp	r3, #0
 801d37e:	d018      	beq.n	801d3b2 <att_iterator_match_uuid16+0x56>
        if (!is_Bluetooth_Base_UUID(it->uuid)) return 0;
 801d380:	687b      	ldr	r3, [r7, #4]
 801d382:	68db      	ldr	r3, [r3, #12]
 801d384:	4618      	mov	r0, r3
 801d386:	f7ff ff1d 	bl	801d1c4 <is_Bluetooth_Base_UUID>
 801d38a:	4603      	mov	r3, r0
 801d38c:	2b00      	cmp	r3, #0
 801d38e:	d101      	bne.n	801d394 <att_iterator_match_uuid16+0x38>
 801d390:	2300      	movs	r3, #0
 801d392:	e01c      	b.n	801d3ce <att_iterator_match_uuid16+0x72>
        return little_endian_read_16(it->uuid, 12) == uuid;
 801d394:	687b      	ldr	r3, [r7, #4]
 801d396:	68db      	ldr	r3, [r3, #12]
 801d398:	210c      	movs	r1, #12
 801d39a:	4618      	mov	r0, r3
 801d39c:	f7f1 fd23 	bl	800ede6 <little_endian_read_16>
 801d3a0:	4603      	mov	r3, r0
 801d3a2:	461a      	mov	r2, r3
 801d3a4:	887b      	ldrh	r3, [r7, #2]
 801d3a6:	4293      	cmp	r3, r2
 801d3a8:	bf0c      	ite	eq
 801d3aa:	2301      	moveq	r3, #1
 801d3ac:	2300      	movne	r3, #0
 801d3ae:	b2db      	uxtb	r3, r3
 801d3b0:	e00d      	b.n	801d3ce <att_iterator_match_uuid16+0x72>
    }
    return little_endian_read_16(it->uuid, 0)  == uuid;
 801d3b2:	687b      	ldr	r3, [r7, #4]
 801d3b4:	68db      	ldr	r3, [r3, #12]
 801d3b6:	2100      	movs	r1, #0
 801d3b8:	4618      	mov	r0, r3
 801d3ba:	f7f1 fd14 	bl	800ede6 <little_endian_read_16>
 801d3be:	4603      	mov	r3, r0
 801d3c0:	461a      	mov	r2, r3
 801d3c2:	887b      	ldrh	r3, [r7, #2]
 801d3c4:	4293      	cmp	r3, r2
 801d3c6:	bf0c      	ite	eq
 801d3c8:	2301      	moveq	r3, #1
 801d3ca:	2300      	movne	r3, #0
 801d3cc:	b2db      	uxtb	r3, r3
}
 801d3ce:	4618      	mov	r0, r3
 801d3d0:	3708      	adds	r7, #8
 801d3d2:	46bd      	mov	sp, r7
 801d3d4:	bd80      	pop	{r7, pc}

0801d3d6 <att_iterator_match_uuid>:

static int att_iterator_match_uuid(att_iterator_t *it, uint8_t *uuid, uint16_t uuid_len){
 801d3d6:	b590      	push	{r4, r7, lr}
 801d3d8:	b085      	sub	sp, #20
 801d3da:	af00      	add	r7, sp, #0
 801d3dc:	60f8      	str	r0, [r7, #12]
 801d3de:	60b9      	str	r1, [r7, #8]
 801d3e0:	4613      	mov	r3, r2
 801d3e2:	80fb      	strh	r3, [r7, #6]
    if (it->handle == 0u) return 0u;
 801d3e4:	68fb      	ldr	r3, [r7, #12]
 801d3e6:	891b      	ldrh	r3, [r3, #8]
 801d3e8:	2b00      	cmp	r3, #0
 801d3ea:	d101      	bne.n	801d3f0 <att_iterator_match_uuid+0x1a>
 801d3ec:	2300      	movs	r3, #0
 801d3ee:	e03b      	b.n	801d468 <att_iterator_match_uuid+0x92>
    // input: UUID16
    if (uuid_len == 2u) {
 801d3f0:	88fb      	ldrh	r3, [r7, #6]
 801d3f2:	2b02      	cmp	r3, #2
 801d3f4:	d10a      	bne.n	801d40c <att_iterator_match_uuid+0x36>
        return att_iterator_match_uuid16(it, little_endian_read_16(uuid, 0));
 801d3f6:	2100      	movs	r1, #0
 801d3f8:	68b8      	ldr	r0, [r7, #8]
 801d3fa:	f7f1 fcf4 	bl	800ede6 <little_endian_read_16>
 801d3fe:	4603      	mov	r3, r0
 801d400:	4619      	mov	r1, r3
 801d402:	68f8      	ldr	r0, [r7, #12]
 801d404:	f7ff ffaa 	bl	801d35c <att_iterator_match_uuid16>
 801d408:	4603      	mov	r3, r0
 801d40a:	e02d      	b.n	801d468 <att_iterator_match_uuid+0x92>
    }
    // input and db: UUID128 
    if ((it->flags & ATT_PROPERTY_UUID128) != 0u){
 801d40c:	68fb      	ldr	r3, [r7, #12]
 801d40e:	88db      	ldrh	r3, [r3, #6]
 801d410:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801d414:	2b00      	cmp	r3, #0
 801d416:	d00d      	beq.n	801d434 <att_iterator_match_uuid+0x5e>
        return memcmp(it->uuid, uuid, 16) == 0;
 801d418:	68fb      	ldr	r3, [r7, #12]
 801d41a:	68db      	ldr	r3, [r3, #12]
 801d41c:	2210      	movs	r2, #16
 801d41e:	68b9      	ldr	r1, [r7, #8]
 801d420:	4618      	mov	r0, r3
 801d422:	f00a fb1b 	bl	8027a5c <memcmp>
 801d426:	4603      	mov	r3, r0
 801d428:	2b00      	cmp	r3, #0
 801d42a:	bf0c      	ite	eq
 801d42c:	2301      	moveq	r3, #1
 801d42e:	2300      	movne	r3, #0
 801d430:	b2db      	uxtb	r3, r3
 801d432:	e019      	b.n	801d468 <att_iterator_match_uuid+0x92>
    }
    // input: UUID128, db: UUID16
    if (!is_Bluetooth_Base_UUID(uuid)) return 0;
 801d434:	68b8      	ldr	r0, [r7, #8]
 801d436:	f7ff fec5 	bl	801d1c4 <is_Bluetooth_Base_UUID>
 801d43a:	4603      	mov	r3, r0
 801d43c:	2b00      	cmp	r3, #0
 801d43e:	d101      	bne.n	801d444 <att_iterator_match_uuid+0x6e>
 801d440:	2300      	movs	r3, #0
 801d442:	e011      	b.n	801d468 <att_iterator_match_uuid+0x92>
    return little_endian_read_16(uuid, 12) == little_endian_read_16(it->uuid, 0);
 801d444:	210c      	movs	r1, #12
 801d446:	68b8      	ldr	r0, [r7, #8]
 801d448:	f7f1 fccd 	bl	800ede6 <little_endian_read_16>
 801d44c:	4603      	mov	r3, r0
 801d44e:	461c      	mov	r4, r3
 801d450:	68fb      	ldr	r3, [r7, #12]
 801d452:	68db      	ldr	r3, [r3, #12]
 801d454:	2100      	movs	r1, #0
 801d456:	4618      	mov	r0, r3
 801d458:	f7f1 fcc5 	bl	800ede6 <little_endian_read_16>
 801d45c:	4603      	mov	r3, r0
 801d45e:	429c      	cmp	r4, r3
 801d460:	bf0c      	ite	eq
 801d462:	2301      	moveq	r3, #1
 801d464:	2300      	movne	r3, #0
 801d466:	b2db      	uxtb	r3, r3
}
 801d468:	4618      	mov	r0, r3
 801d46a:	3714      	adds	r7, #20
 801d46c:	46bd      	mov	sp, r7
 801d46e:	bd90      	pop	{r4, r7, pc}

0801d470 <att_find_handle>:


static int att_find_handle(att_iterator_t *it, uint16_t handle){
 801d470:	b580      	push	{r7, lr}
 801d472:	b082      	sub	sp, #8
 801d474:	af00      	add	r7, sp, #0
 801d476:	6078      	str	r0, [r7, #4]
 801d478:	460b      	mov	r3, r1
 801d47a:	807b      	strh	r3, [r7, #2]
    if (handle == 0u) return 0u;
 801d47c:	887b      	ldrh	r3, [r7, #2]
 801d47e:	2b00      	cmp	r3, #0
 801d480:	d101      	bne.n	801d486 <att_find_handle+0x16>
 801d482:	2300      	movs	r3, #0
 801d484:	e015      	b.n	801d4b2 <att_find_handle+0x42>
    att_iterator_init(it);
 801d486:	6878      	ldr	r0, [r7, #4]
 801d488:	f7ff fee0 	bl	801d24c <att_iterator_init>
    while (att_iterator_has_next(it)){
 801d48c:	e00a      	b.n	801d4a4 <att_find_handle+0x34>
        att_iterator_fetch_next(it);
 801d48e:	6878      	ldr	r0, [r7, #4]
 801d490:	f7ff fefd 	bl	801d28e <att_iterator_fetch_next>
        if (it->handle != handle) continue;
 801d494:	687b      	ldr	r3, [r7, #4]
 801d496:	891b      	ldrh	r3, [r3, #8]
 801d498:	887a      	ldrh	r2, [r7, #2]
 801d49a:	429a      	cmp	r2, r3
 801d49c:	d000      	beq.n	801d4a0 <att_find_handle+0x30>
 801d49e:	e001      	b.n	801d4a4 <att_find_handle+0x34>
        return 1;
 801d4a0:	2301      	movs	r3, #1
 801d4a2:	e006      	b.n	801d4b2 <att_find_handle+0x42>
    while (att_iterator_has_next(it)){
 801d4a4:	6878      	ldr	r0, [r7, #4]
 801d4a6:	f7ff fee1 	bl	801d26c <att_iterator_has_next>
 801d4aa:	4603      	mov	r3, r0
 801d4ac:	2b00      	cmp	r3, #0
 801d4ae:	d1ee      	bne.n	801d48e <att_find_handle+0x1e>
    }
    return 0;
 801d4b0:	2300      	movs	r3, #0
}
 801d4b2:	4618      	mov	r0, r3
 801d4b4:	3708      	adds	r7, #8
 801d4b6:	46bd      	mov	sp, r7
 801d4b8:	bd80      	pop	{r7, pc}
	...

0801d4bc <att_update_value_len>:
    if ((it.flags & ATT_PROPERTY_UUID128) != 0u) return 0u;
    return little_endian_read_16(it.uuid, 0);
}
// end of client API

static void att_update_value_len(att_iterator_t *it, hci_con_handle_t con_handle){
 801d4bc:	b590      	push	{r4, r7, lr}
 801d4be:	b085      	sub	sp, #20
 801d4c0:	af02      	add	r7, sp, #8
 801d4c2:	6078      	str	r0, [r7, #4]
 801d4c4:	460b      	mov	r3, r1
 801d4c6:	807b      	strh	r3, [r7, #2]
    if ((it->flags & ATT_PROPERTY_DYNAMIC) == 0u) return;
 801d4c8:	687b      	ldr	r3, [r7, #4]
 801d4ca:	88db      	ldrh	r3, [r3, #6]
 801d4cc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801d4d0:	2b00      	cmp	r3, #0
 801d4d2:	d00f      	beq.n	801d4f4 <att_update_value_len+0x38>
    it->value_len = (*att_read_callback)(con_handle, it->handle, 0, NULL, 0);
 801d4d4:	4b09      	ldr	r3, [pc, #36]	; (801d4fc <att_update_value_len+0x40>)
 801d4d6:	681c      	ldr	r4, [r3, #0]
 801d4d8:	687b      	ldr	r3, [r7, #4]
 801d4da:	8919      	ldrh	r1, [r3, #8]
 801d4dc:	8878      	ldrh	r0, [r7, #2]
 801d4de:	2300      	movs	r3, #0
 801d4e0:	9300      	str	r3, [sp, #0]
 801d4e2:	2300      	movs	r3, #0
 801d4e4:	2200      	movs	r2, #0
 801d4e6:	47a0      	blx	r4
 801d4e8:	4603      	mov	r3, r0
 801d4ea:	461a      	mov	r2, r3
 801d4ec:	687b      	ldr	r3, [r7, #4]
 801d4ee:	821a      	strh	r2, [r3, #16]
    return;
 801d4f0:	bf00      	nop
 801d4f2:	e000      	b.n	801d4f6 <att_update_value_len+0x3a>
    if ((it->flags & ATT_PROPERTY_DYNAMIC) == 0u) return;
 801d4f4:	bf00      	nop
}
 801d4f6:	370c      	adds	r7, #12
 801d4f8:	46bd      	mov	sp, r7
 801d4fa:	bd90      	pop	{r4, r7, pc}
 801d4fc:	20009ee4 	.word	0x20009ee4

0801d500 <att_copy_value>:

// copy attribute value from offset into buffer with given size
static int att_copy_value(att_iterator_t *it, uint16_t offset, uint8_t * buffer, uint16_t buffer_size, hci_con_handle_t con_handle){
 801d500:	b590      	push	{r4, r7, lr}
 801d502:	b089      	sub	sp, #36	; 0x24
 801d504:	af02      	add	r7, sp, #8
 801d506:	60f8      	str	r0, [r7, #12]
 801d508:	607a      	str	r2, [r7, #4]
 801d50a:	461a      	mov	r2, r3
 801d50c:	460b      	mov	r3, r1
 801d50e:	817b      	strh	r3, [r7, #10]
 801d510:	4613      	mov	r3, r2
 801d512:	813b      	strh	r3, [r7, #8]
    
    // DYNAMIC 
    if ((it->flags & ATT_PROPERTY_DYNAMIC) != 0u){
 801d514:	68fb      	ldr	r3, [r7, #12]
 801d516:	88db      	ldrh	r3, [r3, #6]
 801d518:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801d51c:	2b00      	cmp	r3, #0
 801d51e:	d00b      	beq.n	801d538 <att_copy_value+0x38>
        return (*att_read_callback)(con_handle, it->handle, offset, buffer, buffer_size);
 801d520:	4b12      	ldr	r3, [pc, #72]	; (801d56c <att_copy_value+0x6c>)
 801d522:	681c      	ldr	r4, [r3, #0]
 801d524:	68fb      	ldr	r3, [r7, #12]
 801d526:	8919      	ldrh	r1, [r3, #8]
 801d528:	897a      	ldrh	r2, [r7, #10]
 801d52a:	8d38      	ldrh	r0, [r7, #40]	; 0x28
 801d52c:	893b      	ldrh	r3, [r7, #8]
 801d52e:	9300      	str	r3, [sp, #0]
 801d530:	687b      	ldr	r3, [r7, #4]
 801d532:	47a0      	blx	r4
 801d534:	4603      	mov	r3, r0
 801d536:	e014      	b.n	801d562 <att_copy_value+0x62>
    }
    
    // STATIC
    uint16_t bytes_to_copy = btstack_min(it->value_len - offset, buffer_size);
 801d538:	68fb      	ldr	r3, [r7, #12]
 801d53a:	8a1b      	ldrh	r3, [r3, #16]
 801d53c:	461a      	mov	r2, r3
 801d53e:	897b      	ldrh	r3, [r7, #10]
 801d540:	1ad3      	subs	r3, r2, r3
 801d542:	461a      	mov	r2, r3
 801d544:	893b      	ldrh	r3, [r7, #8]
 801d546:	4619      	mov	r1, r3
 801d548:	4610      	mov	r0, r2
 801d54a:	f7f1 fde0 	bl	800f10e <btstack_min>
 801d54e:	4603      	mov	r3, r0
 801d550:	82fb      	strh	r3, [r7, #22]
    (void)memcpy(buffer, it->value, bytes_to_copy);
 801d552:	68fb      	ldr	r3, [r7, #12]
 801d554:	695b      	ldr	r3, [r3, #20]
 801d556:	8afa      	ldrh	r2, [r7, #22]
 801d558:	4619      	mov	r1, r3
 801d55a:	6878      	ldr	r0, [r7, #4]
 801d55c:	f00a fa8d 	bl	8027a7a <memcpy>
    return bytes_to_copy;
 801d560:	8afb      	ldrh	r3, [r7, #22]
}
 801d562:	4618      	mov	r0, r3
 801d564:	371c      	adds	r7, #28
 801d566:	46bd      	mov	sp, r7
 801d568:	bd90      	pop	{r4, r7, pc}
 801d56a:	bf00      	nop
 801d56c:	20009ee4 	.word	0x20009ee4

0801d570 <att_set_db>:

void att_set_db(uint8_t const * db){
 801d570:	b580      	push	{r7, lr}
 801d572:	b084      	sub	sp, #16
 801d574:	af02      	add	r7, sp, #8
 801d576:	6078      	str	r0, [r7, #4]
    // validate db version
    if (db == NULL) return;
 801d578:	687b      	ldr	r3, [r7, #4]
 801d57a:	2b00      	cmp	r3, #0
 801d57c:	d018      	beq.n	801d5b0 <att_set_db+0x40>
    if (*db++ != ATT_DB_VERSION){
 801d57e:	687b      	ldr	r3, [r7, #4]
 801d580:	1c5a      	adds	r2, r3, #1
 801d582:	607a      	str	r2, [r7, #4]
 801d584:	781b      	ldrb	r3, [r3, #0]
 801d586:	2b01      	cmp	r3, #1
 801d588:	d006      	beq.n	801d598 <att_set_db+0x28>
        log_error("ATT DB version differs, please regenerate .h from .gatt file or update att_db_util.c");
 801d58a:	23ce      	movs	r3, #206	; 0xce
 801d58c:	4a0a      	ldr	r2, [pc, #40]	; (801d5b8 <att_set_db+0x48>)
 801d58e:	490b      	ldr	r1, [pc, #44]	; (801d5bc <att_set_db+0x4c>)
 801d590:	2002      	movs	r0, #2
 801d592:	f7f9 ff55 	bl	8017440 <hci_dump_log>
        return;
 801d596:	e00c      	b.n	801d5b2 <att_set_db+0x42>
    }
    log_info("att_set_db %p", db);
 801d598:	687b      	ldr	r3, [r7, #4]
 801d59a:	9300      	str	r3, [sp, #0]
 801d59c:	23d1      	movs	r3, #209	; 0xd1
 801d59e:	4a06      	ldr	r2, [pc, #24]	; (801d5b8 <att_set_db+0x48>)
 801d5a0:	4907      	ldr	r1, [pc, #28]	; (801d5c0 <att_set_db+0x50>)
 801d5a2:	2001      	movs	r0, #1
 801d5a4:	f7f9 ff4c 	bl	8017440 <hci_dump_log>
    att_db = db;
 801d5a8:	4a06      	ldr	r2, [pc, #24]	; (801d5c4 <att_set_db+0x54>)
 801d5aa:	687b      	ldr	r3, [r7, #4]
 801d5ac:	6013      	str	r3, [r2, #0]
 801d5ae:	e000      	b.n	801d5b2 <att_set_db+0x42>
    if (db == NULL) return;
 801d5b0:	bf00      	nop
}
 801d5b2:	3708      	adds	r7, #8
 801d5b4:	46bd      	mov	sp, r7
 801d5b6:	bd80      	pop	{r7, pc}
 801d5b8:	0802cb8c 	.word	0x0802cb8c
 801d5bc:	0802cb98 	.word	0x0802cb98
 801d5c0:	0802cbf4 	.word	0x0802cbf4
 801d5c4:	20009ee0 	.word	0x20009ee0

0801d5c8 <att_set_read_callback>:

void att_set_read_callback(att_read_callback_t callback){
 801d5c8:	b480      	push	{r7}
 801d5ca:	b083      	sub	sp, #12
 801d5cc:	af00      	add	r7, sp, #0
 801d5ce:	6078      	str	r0, [r7, #4]
    att_read_callback = callback;
 801d5d0:	4a04      	ldr	r2, [pc, #16]	; (801d5e4 <att_set_read_callback+0x1c>)
 801d5d2:	687b      	ldr	r3, [r7, #4]
 801d5d4:	6013      	str	r3, [r2, #0]
}
 801d5d6:	bf00      	nop
 801d5d8:	370c      	adds	r7, #12
 801d5da:	46bd      	mov	sp, r7
 801d5dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d5e0:	4770      	bx	lr
 801d5e2:	bf00      	nop
 801d5e4:	20009ee4 	.word	0x20009ee4

0801d5e8 <att_set_write_callback>:

void att_set_write_callback(att_write_callback_t callback){
 801d5e8:	b480      	push	{r7}
 801d5ea:	b083      	sub	sp, #12
 801d5ec:	af00      	add	r7, sp, #0
 801d5ee:	6078      	str	r0, [r7, #4]
    att_write_callback = callback;
 801d5f0:	4a04      	ldr	r2, [pc, #16]	; (801d604 <att_set_write_callback+0x1c>)
 801d5f2:	687b      	ldr	r3, [r7, #4]
 801d5f4:	6013      	str	r3, [r2, #0]
}
 801d5f6:	bf00      	nop
 801d5f8:	370c      	adds	r7, #12
 801d5fa:	46bd      	mov	sp, r7
 801d5fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d600:	4770      	bx	lr
 801d602:	bf00      	nop
 801d604:	20009ee8 	.word	0x20009ee8

0801d608 <att_prepare_write_reset>:
        log_info(", value_len: %u, value: ", it.value_len);
        log_info_hexdump(it.value, it.value_len);
    }
}

static void att_prepare_write_reset(void){
 801d608:	b480      	push	{r7}
 801d60a:	af00      	add	r7, sp, #0
    att_prepare_write_error_code = 0;
 801d60c:	4b05      	ldr	r3, [pc, #20]	; (801d624 <att_prepare_write_reset+0x1c>)
 801d60e:	2200      	movs	r2, #0
 801d610:	601a      	str	r2, [r3, #0]
    att_prepare_write_error_handle = 0x0000;
 801d612:	4b05      	ldr	r3, [pc, #20]	; (801d628 <att_prepare_write_reset+0x20>)
 801d614:	2200      	movs	r2, #0
 801d616:	801a      	strh	r2, [r3, #0]
}
 801d618:	bf00      	nop
 801d61a:	46bd      	mov	sp, r7
 801d61c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d620:	4770      	bx	lr
 801d622:	bf00      	nop
 801d624:	20009eec 	.word	0x20009eec
 801d628:	20009ef0 	.word	0x20009ef0

0801d62c <att_prepare_write_update_errors>:

static void att_prepare_write_update_errors(uint8_t error_code, uint16_t handle){
 801d62c:	b480      	push	{r7}
 801d62e:	b083      	sub	sp, #12
 801d630:	af00      	add	r7, sp, #0
 801d632:	4603      	mov	r3, r0
 801d634:	460a      	mov	r2, r1
 801d636:	71fb      	strb	r3, [r7, #7]
 801d638:	4613      	mov	r3, r2
 801d63a:	80bb      	strh	r3, [r7, #4]
    // first ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LENGTH has highest priority
    if ((error_code == ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LENGTH) && (error_code != att_prepare_write_error_code)){
 801d63c:	79fb      	ldrb	r3, [r7, #7]
 801d63e:	2b0d      	cmp	r3, #13
 801d640:	d10b      	bne.n	801d65a <att_prepare_write_update_errors+0x2e>
 801d642:	79fa      	ldrb	r2, [r7, #7]
 801d644:	4b0e      	ldr	r3, [pc, #56]	; (801d680 <att_prepare_write_update_errors+0x54>)
 801d646:	681b      	ldr	r3, [r3, #0]
 801d648:	429a      	cmp	r2, r3
 801d64a:	d006      	beq.n	801d65a <att_prepare_write_update_errors+0x2e>
        att_prepare_write_error_code = error_code;
 801d64c:	79fb      	ldrb	r3, [r7, #7]
 801d64e:	4a0c      	ldr	r2, [pc, #48]	; (801d680 <att_prepare_write_update_errors+0x54>)
 801d650:	6013      	str	r3, [r2, #0]
        att_prepare_write_error_handle = handle;
 801d652:	4a0c      	ldr	r2, [pc, #48]	; (801d684 <att_prepare_write_update_errors+0x58>)
 801d654:	88bb      	ldrh	r3, [r7, #4]
 801d656:	8013      	strh	r3, [r2, #0]
        return;
 801d658:	e00d      	b.n	801d676 <att_prepare_write_update_errors+0x4a>
    }
    // first ATT_ERROR_INVALID_OFFSET is next
    if ((error_code == ATT_ERROR_INVALID_OFFSET) && (att_prepare_write_error_code == 0)){
 801d65a:	79fb      	ldrb	r3, [r7, #7]
 801d65c:	2b07      	cmp	r3, #7
 801d65e:	d10a      	bne.n	801d676 <att_prepare_write_update_errors+0x4a>
 801d660:	4b07      	ldr	r3, [pc, #28]	; (801d680 <att_prepare_write_update_errors+0x54>)
 801d662:	681b      	ldr	r3, [r3, #0]
 801d664:	2b00      	cmp	r3, #0
 801d666:	d106      	bne.n	801d676 <att_prepare_write_update_errors+0x4a>
        att_prepare_write_error_code = error_code;
 801d668:	79fb      	ldrb	r3, [r7, #7]
 801d66a:	4a05      	ldr	r2, [pc, #20]	; (801d680 <att_prepare_write_update_errors+0x54>)
 801d66c:	6013      	str	r3, [r2, #0]
        att_prepare_write_error_handle = handle;
 801d66e:	4a05      	ldr	r2, [pc, #20]	; (801d684 <att_prepare_write_update_errors+0x58>)
 801d670:	88bb      	ldrh	r3, [r7, #4]
 801d672:	8013      	strh	r3, [r2, #0]
        return;
 801d674:	bf00      	nop
    }
}
 801d676:	370c      	adds	r7, #12
 801d678:	46bd      	mov	sp, r7
 801d67a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d67e:	4770      	bx	lr
 801d680:	20009eec 	.word	0x20009eec
 801d684:	20009ef0 	.word	0x20009ef0

0801d688 <setup_error>:

static uint16_t setup_error(uint8_t * response_buffer, uint16_t request, uint16_t handle, uint8_t error_code){
 801d688:	b580      	push	{r7, lr}
 801d68a:	b084      	sub	sp, #16
 801d68c:	af00      	add	r7, sp, #0
 801d68e:	60f8      	str	r0, [r7, #12]
 801d690:	4608      	mov	r0, r1
 801d692:	4611      	mov	r1, r2
 801d694:	461a      	mov	r2, r3
 801d696:	4603      	mov	r3, r0
 801d698:	817b      	strh	r3, [r7, #10]
 801d69a:	460b      	mov	r3, r1
 801d69c:	813b      	strh	r3, [r7, #8]
 801d69e:	4613      	mov	r3, r2
 801d6a0:	71fb      	strb	r3, [r7, #7]
    response_buffer[0] = ATT_ERROR_RESPONSE;
 801d6a2:	68fb      	ldr	r3, [r7, #12]
 801d6a4:	2201      	movs	r2, #1
 801d6a6:	701a      	strb	r2, [r3, #0]
    response_buffer[1] = request;
 801d6a8:	68fb      	ldr	r3, [r7, #12]
 801d6aa:	3301      	adds	r3, #1
 801d6ac:	897a      	ldrh	r2, [r7, #10]
 801d6ae:	b2d2      	uxtb	r2, r2
 801d6b0:	701a      	strb	r2, [r3, #0]
    little_endian_store_16(response_buffer, 2, handle);
 801d6b2:	893b      	ldrh	r3, [r7, #8]
 801d6b4:	461a      	mov	r2, r3
 801d6b6:	2102      	movs	r1, #2
 801d6b8:	68f8      	ldr	r0, [r7, #12]
 801d6ba:	f7f1 fbd4 	bl	800ee66 <little_endian_store_16>
    response_buffer[4] = error_code;
 801d6be:	68fb      	ldr	r3, [r7, #12]
 801d6c0:	3304      	adds	r3, #4
 801d6c2:	79fa      	ldrb	r2, [r7, #7]
 801d6c4:	701a      	strb	r2, [r3, #0]
    return 5;
 801d6c6:	2305      	movs	r3, #5
}
 801d6c8:	4618      	mov	r0, r3
 801d6ca:	3710      	adds	r7, #16
 801d6cc:	46bd      	mov	sp, r7
 801d6ce:	bd80      	pop	{r7, pc}

0801d6d0 <setup_error_read_not_permitted>:

static inline uint16_t setup_error_read_not_permitted(uint8_t * response_buffer, uint16_t request, uint16_t start_handle){
 801d6d0:	b580      	push	{r7, lr}
 801d6d2:	b082      	sub	sp, #8
 801d6d4:	af00      	add	r7, sp, #0
 801d6d6:	6078      	str	r0, [r7, #4]
 801d6d8:	460b      	mov	r3, r1
 801d6da:	807b      	strh	r3, [r7, #2]
 801d6dc:	4613      	mov	r3, r2
 801d6de:	803b      	strh	r3, [r7, #0]
    return setup_error(response_buffer, request, start_handle, ATT_ERROR_READ_NOT_PERMITTED);
 801d6e0:	883a      	ldrh	r2, [r7, #0]
 801d6e2:	8879      	ldrh	r1, [r7, #2]
 801d6e4:	2302      	movs	r3, #2
 801d6e6:	6878      	ldr	r0, [r7, #4]
 801d6e8:	f7ff ffce 	bl	801d688 <setup_error>
 801d6ec:	4603      	mov	r3, r0
}
 801d6ee:	4618      	mov	r0, r3
 801d6f0:	3708      	adds	r7, #8
 801d6f2:	46bd      	mov	sp, r7
 801d6f4:	bd80      	pop	{r7, pc}

0801d6f6 <setup_error_write_not_permitted>:

static inline uint16_t setup_error_write_not_permitted(uint8_t * response_buffer, uint16_t request, uint16_t start_handle){
 801d6f6:	b580      	push	{r7, lr}
 801d6f8:	b082      	sub	sp, #8
 801d6fa:	af00      	add	r7, sp, #0
 801d6fc:	6078      	str	r0, [r7, #4]
 801d6fe:	460b      	mov	r3, r1
 801d700:	807b      	strh	r3, [r7, #2]
 801d702:	4613      	mov	r3, r2
 801d704:	803b      	strh	r3, [r7, #0]
    return setup_error(response_buffer, request, start_handle, ATT_ERROR_WRITE_NOT_PERMITTED);
 801d706:	883a      	ldrh	r2, [r7, #0]
 801d708:	8879      	ldrh	r1, [r7, #2]
 801d70a:	2303      	movs	r3, #3
 801d70c:	6878      	ldr	r0, [r7, #4]
 801d70e:	f7ff ffbb 	bl	801d688 <setup_error>
 801d712:	4603      	mov	r3, r0
}
 801d714:	4618      	mov	r0, r3
 801d716:	3708      	adds	r7, #8
 801d718:	46bd      	mov	sp, r7
 801d71a:	bd80      	pop	{r7, pc}

0801d71c <setup_error_atribute_not_found>:

static inline uint16_t setup_error_atribute_not_found(uint8_t * response_buffer, uint16_t request, uint16_t start_handle){
 801d71c:	b580      	push	{r7, lr}
 801d71e:	b082      	sub	sp, #8
 801d720:	af00      	add	r7, sp, #0
 801d722:	6078      	str	r0, [r7, #4]
 801d724:	460b      	mov	r3, r1
 801d726:	807b      	strh	r3, [r7, #2]
 801d728:	4613      	mov	r3, r2
 801d72a:	803b      	strh	r3, [r7, #0]
    return setup_error(response_buffer, request, start_handle, ATT_ERROR_ATTRIBUTE_NOT_FOUND);
 801d72c:	883a      	ldrh	r2, [r7, #0]
 801d72e:	8879      	ldrh	r1, [r7, #2]
 801d730:	230a      	movs	r3, #10
 801d732:	6878      	ldr	r0, [r7, #4]
 801d734:	f7ff ffa8 	bl	801d688 <setup_error>
 801d738:	4603      	mov	r3, r0
}
 801d73a:	4618      	mov	r0, r3
 801d73c:	3708      	adds	r7, #8
 801d73e:	46bd      	mov	sp, r7
 801d740:	bd80      	pop	{r7, pc}

0801d742 <setup_error_invalid_handle>:

static inline uint16_t setup_error_invalid_handle(uint8_t * response_buffer, uint16_t request, uint16_t handle){
 801d742:	b580      	push	{r7, lr}
 801d744:	b082      	sub	sp, #8
 801d746:	af00      	add	r7, sp, #0
 801d748:	6078      	str	r0, [r7, #4]
 801d74a:	460b      	mov	r3, r1
 801d74c:	807b      	strh	r3, [r7, #2]
 801d74e:	4613      	mov	r3, r2
 801d750:	803b      	strh	r3, [r7, #0]
    return setup_error(response_buffer, request, handle, ATT_ERROR_INVALID_HANDLE);
 801d752:	883a      	ldrh	r2, [r7, #0]
 801d754:	8879      	ldrh	r1, [r7, #2]
 801d756:	2301      	movs	r3, #1
 801d758:	6878      	ldr	r0, [r7, #4]
 801d75a:	f7ff ff95 	bl	801d688 <setup_error>
 801d75e:	4603      	mov	r3, r0
}
 801d760:	4618      	mov	r0, r3
 801d762:	3708      	adds	r7, #8
 801d764:	46bd      	mov	sp, r7
 801d766:	bd80      	pop	{r7, pc}

0801d768 <setup_error_invalid_offset>:

static inline uint16_t setup_error_invalid_offset(uint8_t * response_buffer, uint16_t request, uint16_t handle){
 801d768:	b580      	push	{r7, lr}
 801d76a:	b082      	sub	sp, #8
 801d76c:	af00      	add	r7, sp, #0
 801d76e:	6078      	str	r0, [r7, #4]
 801d770:	460b      	mov	r3, r1
 801d772:	807b      	strh	r3, [r7, #2]
 801d774:	4613      	mov	r3, r2
 801d776:	803b      	strh	r3, [r7, #0]
    return setup_error(response_buffer, request, handle, ATT_ERROR_INVALID_OFFSET);
 801d778:	883a      	ldrh	r2, [r7, #0]
 801d77a:	8879      	ldrh	r1, [r7, #2]
 801d77c:	2307      	movs	r3, #7
 801d77e:	6878      	ldr	r0, [r7, #4]
 801d780:	f7ff ff82 	bl	801d688 <setup_error>
 801d784:	4603      	mov	r3, r0
}
 801d786:	4618      	mov	r0, r3
 801d788:	3708      	adds	r7, #8
 801d78a:	46bd      	mov	sp, r7
 801d78c:	bd80      	pop	{r7, pc}

0801d78e <setup_error_invalid_pdu>:

static inline uint16_t setup_error_invalid_pdu(uint8_t *response_buffer, uint16_t request) {
 801d78e:	b580      	push	{r7, lr}
 801d790:	b082      	sub	sp, #8
 801d792:	af00      	add	r7, sp, #0
 801d794:	6078      	str	r0, [r7, #4]
 801d796:	460b      	mov	r3, r1
 801d798:	807b      	strh	r3, [r7, #2]
    return setup_error(response_buffer, request, 0, ATT_ERROR_INVALID_PDU);
 801d79a:	8879      	ldrh	r1, [r7, #2]
 801d79c:	2304      	movs	r3, #4
 801d79e:	2200      	movs	r2, #0
 801d7a0:	6878      	ldr	r0, [r7, #4]
 801d7a2:	f7ff ff71 	bl	801d688 <setup_error>
 801d7a6:	4603      	mov	r3, r0
}
 801d7a8:	4618      	mov	r0, r3
 801d7aa:	3708      	adds	r7, #8
 801d7ac:	46bd      	mov	sp, r7
 801d7ae:	bd80      	pop	{r7, pc}

0801d7b0 <att_validate_security>:

static uint8_t att_validate_security(att_connection_t * att_connection, att_operation_t operation, att_iterator_t * it){
 801d7b0:	b480      	push	{r7}
 801d7b2:	b087      	sub	sp, #28
 801d7b4:	af00      	add	r7, sp, #0
 801d7b6:	60f8      	str	r0, [r7, #12]
 801d7b8:	460b      	mov	r3, r1
 801d7ba:	607a      	str	r2, [r7, #4]
 801d7bc:	72fb      	strb	r3, [r7, #11]
    int required_security_level = 0;
 801d7be:	2300      	movs	r3, #0
 801d7c0:	617b      	str	r3, [r7, #20]
    bool requires_secure_connection = false;
 801d7c2:	2300      	movs	r3, #0
 801d7c4:	74fb      	strb	r3, [r7, #19]
    switch (operation){
 801d7c6:	7afb      	ldrb	r3, [r7, #11]
 801d7c8:	2b00      	cmp	r3, #0
 801d7ca:	d002      	beq.n	801d7d2 <att_validate_security+0x22>
 801d7cc:	2b01      	cmp	r3, #1
 801d7ce:	d01d      	beq.n	801d80c <att_validate_security+0x5c>
                requires_secure_connection = true;
            }
            break;
        default:
            btstack_assert(false);
            break;
 801d7d0:	e03c      	b.n	801d84c <att_validate_security+0x9c>
            if ((it->flags & ATT_PROPERTY_READ_PERMISSION_BIT_0) != 0u){
 801d7d2:	687b      	ldr	r3, [r7, #4]
 801d7d4:	88db      	ldrh	r3, [r3, #6]
 801d7d6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801d7da:	2b00      	cmp	r3, #0
 801d7dc:	d003      	beq.n	801d7e6 <att_validate_security+0x36>
                required_security_level |= 1;
 801d7de:	697b      	ldr	r3, [r7, #20]
 801d7e0:	f043 0301 	orr.w	r3, r3, #1
 801d7e4:	617b      	str	r3, [r7, #20]
            if ((it->flags & ATT_PROPERTY_READ_PERMISSION_BIT_1) != 0u){
 801d7e6:	687b      	ldr	r3, [r7, #4]
 801d7e8:	88db      	ldrh	r3, [r3, #6]
 801d7ea:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801d7ee:	2b00      	cmp	r3, #0
 801d7f0:	d003      	beq.n	801d7fa <att_validate_security+0x4a>
                required_security_level |= 2;
 801d7f2:	697b      	ldr	r3, [r7, #20]
 801d7f4:	f043 0302 	orr.w	r3, r3, #2
 801d7f8:	617b      	str	r3, [r7, #20]
            if ((it->flags & ATT_PROPERTY_READ_PERMISSION_SC) != 0u){
 801d7fa:	687b      	ldr	r3, [r7, #4]
 801d7fc:	88db      	ldrh	r3, [r3, #6]
 801d7fe:	f003 0320 	and.w	r3, r3, #32
 801d802:	2b00      	cmp	r3, #0
 801d804:	d01f      	beq.n	801d846 <att_validate_security+0x96>
                requires_secure_connection = true;
 801d806:	2301      	movs	r3, #1
 801d808:	74fb      	strb	r3, [r7, #19]
            break;
 801d80a:	e01c      	b.n	801d846 <att_validate_security+0x96>
            if ((it->flags & ATT_PROPERTY_WRITE_PERMISSION_BIT_0) != 0u){
 801d80c:	687b      	ldr	r3, [r7, #4]
 801d80e:	88db      	ldrh	r3, [r3, #6]
 801d810:	f003 0301 	and.w	r3, r3, #1
 801d814:	2b00      	cmp	r3, #0
 801d816:	d003      	beq.n	801d820 <att_validate_security+0x70>
                required_security_level |= 1;
 801d818:	697b      	ldr	r3, [r7, #20]
 801d81a:	f043 0301 	orr.w	r3, r3, #1
 801d81e:	617b      	str	r3, [r7, #20]
            if ((it->flags & ATT_PROPERTY_WRITE_PERMISSION_BIT_1) != 0u){
 801d820:	687b      	ldr	r3, [r7, #4]
 801d822:	88db      	ldrh	r3, [r3, #6]
 801d824:	f003 0310 	and.w	r3, r3, #16
 801d828:	2b00      	cmp	r3, #0
 801d82a:	d003      	beq.n	801d834 <att_validate_security+0x84>
                required_security_level |= 2;
 801d82c:	697b      	ldr	r3, [r7, #20]
 801d82e:	f043 0302 	orr.w	r3, r3, #2
 801d832:	617b      	str	r3, [r7, #20]
            if ((it->flags & ATT_PROPERTY_WRITE_PERMISSION_SC) != 0u){
 801d834:	687b      	ldr	r3, [r7, #4]
 801d836:	88db      	ldrh	r3, [r3, #6]
 801d838:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801d83c:	2b00      	cmp	r3, #0
 801d83e:	d004      	beq.n	801d84a <att_validate_security+0x9a>
                requires_secure_connection = true;
 801d840:	2301      	movs	r3, #1
 801d842:	74fb      	strb	r3, [r7, #19]
            break;
 801d844:	e001      	b.n	801d84a <att_validate_security+0x9a>
            break;
 801d846:	bf00      	nop
 801d848:	e000      	b.n	801d84c <att_validate_security+0x9c>
            break;
 801d84a:	bf00      	nop
    }

    uint8_t required_encryption_size = it->flags >> 12;
 801d84c:	687b      	ldr	r3, [r7, #4]
 801d84e:	88db      	ldrh	r3, [r3, #6]
 801d850:	0b1b      	lsrs	r3, r3, #12
 801d852:	b29b      	uxth	r3, r3
 801d854:	74bb      	strb	r3, [r7, #18]
    if (required_encryption_size != 0) required_encryption_size++;   // store -1 to fit into 4 bit
 801d856:	7cbb      	ldrb	r3, [r7, #18]
 801d858:	2b00      	cmp	r3, #0
 801d85a:	d002      	beq.n	801d862 <att_validate_security+0xb2>
 801d85c:	7cbb      	ldrb	r3, [r7, #18]
 801d85e:	3301      	adds	r3, #1
 801d860:	74bb      	strb	r3, [r7, #18]

    log_debug("att_validate_security. flags 0x%04x (=> security level %u, key size %u) authorized %u, authenticated %u, encryption_key_size %u, secure connection %u",
        it->flags, required_security_level, required_encryption_size, att_connection->authorized, att_connection->authenticated, att_connection->encryption_key_size, att_connection->secure_connection);

    bool sc_missing = requires_secure_connection && (att_connection->secure_connection == 0u);
 801d862:	7cfb      	ldrb	r3, [r7, #19]
 801d864:	2b00      	cmp	r3, #0
 801d866:	d005      	beq.n	801d874 <att_validate_security+0xc4>
 801d868:	68fb      	ldr	r3, [r7, #12]
 801d86a:	7a9b      	ldrb	r3, [r3, #10]
 801d86c:	2b00      	cmp	r3, #0
 801d86e:	d101      	bne.n	801d874 <att_validate_security+0xc4>
 801d870:	2301      	movs	r3, #1
 801d872:	e000      	b.n	801d876 <att_validate_security+0xc6>
 801d874:	2300      	movs	r3, #0
 801d876:	747b      	strb	r3, [r7, #17]
 801d878:	7c7b      	ldrb	r3, [r7, #17]
 801d87a:	f003 0301 	and.w	r3, r3, #1
 801d87e:	747b      	strb	r3, [r7, #17]
    switch (required_security_level){
 801d880:	697b      	ldr	r3, [r7, #20]
 801d882:	2b02      	cmp	r3, #2
 801d884:	d00d      	beq.n	801d8a2 <att_validate_security+0xf2>
 801d886:	2b03      	cmp	r3, #3
 801d888:	d002      	beq.n	801d890 <att_validate_security+0xe0>
 801d88a:	2b01      	cmp	r3, #1
 801d88c:	d012      	beq.n	801d8b4 <att_validate_security+0x104>
            if (required_encryption_size > att_connection->encryption_key_size){
                return ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE;
            }
            break;
        default:
            break;
 801d88e:	e025      	b.n	801d8dc <att_validate_security+0x12c>
            if ((att_connection->authorized == 0u) || sc_missing){
 801d890:	68fb      	ldr	r3, [r7, #12]
 801d892:	7a5b      	ldrb	r3, [r3, #9]
 801d894:	2b00      	cmp	r3, #0
 801d896:	d002      	beq.n	801d89e <att_validate_security+0xee>
 801d898:	7c7b      	ldrb	r3, [r7, #17]
 801d89a:	2b00      	cmp	r3, #0
 801d89c:	d001      	beq.n	801d8a2 <att_validate_security+0xf2>
                return ATT_ERROR_INSUFFICIENT_AUTHORIZATION;
 801d89e:	2308      	movs	r3, #8
 801d8a0:	e01d      	b.n	801d8de <att_validate_security+0x12e>
            if ((att_connection->authenticated == 0u) || sc_missing){
 801d8a2:	68fb      	ldr	r3, [r7, #12]
 801d8a4:	7a1b      	ldrb	r3, [r3, #8]
 801d8a6:	2b00      	cmp	r3, #0
 801d8a8:	d002      	beq.n	801d8b0 <att_validate_security+0x100>
 801d8aa:	7c7b      	ldrb	r3, [r7, #17]
 801d8ac:	2b00      	cmp	r3, #0
 801d8ae:	d001      	beq.n	801d8b4 <att_validate_security+0x104>
                return ATT_ERROR_INSUFFICIENT_AUTHENTICATION;
 801d8b0:	2305      	movs	r3, #5
 801d8b2:	e014      	b.n	801d8de <att_validate_security+0x12e>
            if ((required_encryption_size > 0u) && ((att_connection->encryption_key_size == 0u) || sc_missing)){
 801d8b4:	7cbb      	ldrb	r3, [r7, #18]
 801d8b6:	2b00      	cmp	r3, #0
 801d8b8:	d008      	beq.n	801d8cc <att_validate_security+0x11c>
 801d8ba:	68fb      	ldr	r3, [r7, #12]
 801d8bc:	79db      	ldrb	r3, [r3, #7]
 801d8be:	2b00      	cmp	r3, #0
 801d8c0:	d002      	beq.n	801d8c8 <att_validate_security+0x118>
 801d8c2:	7c7b      	ldrb	r3, [r7, #17]
 801d8c4:	2b00      	cmp	r3, #0
 801d8c6:	d001      	beq.n	801d8cc <att_validate_security+0x11c>
                return ATT_ERROR_INSUFFICIENT_ENCRYPTION;
 801d8c8:	230f      	movs	r3, #15
 801d8ca:	e008      	b.n	801d8de <att_validate_security+0x12e>
            if (required_encryption_size > att_connection->encryption_key_size){
 801d8cc:	68fb      	ldr	r3, [r7, #12]
 801d8ce:	79db      	ldrb	r3, [r3, #7]
 801d8d0:	7cba      	ldrb	r2, [r7, #18]
 801d8d2:	429a      	cmp	r2, r3
 801d8d4:	d901      	bls.n	801d8da <att_validate_security+0x12a>
                return ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE;
 801d8d6:	230c      	movs	r3, #12
 801d8d8:	e001      	b.n	801d8de <att_validate_security+0x12e>
            break;
 801d8da:	bf00      	nop
    }
    return ATT_ERROR_SUCCESS;
 801d8dc:	2300      	movs	r3, #0
}
 801d8de:	4618      	mov	r0, r3
 801d8e0:	371c      	adds	r7, #28
 801d8e2:	46bd      	mov	sp, r7
 801d8e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d8e8:	4770      	bx	lr

0801d8ea <handle_exchange_mtu_request>:
      
//
// MARK: ATT_EXCHANGE_MTU_REQUEST
//
static uint16_t handle_exchange_mtu_request(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len,
                                         uint8_t * response_buffer){
 801d8ea:	b580      	push	{r7, lr}
 801d8ec:	b086      	sub	sp, #24
 801d8ee:	af00      	add	r7, sp, #0
 801d8f0:	60f8      	str	r0, [r7, #12]
 801d8f2:	60b9      	str	r1, [r7, #8]
 801d8f4:	603b      	str	r3, [r7, #0]
 801d8f6:	4613      	mov	r3, r2
 801d8f8:	80fb      	strh	r3, [r7, #6]

    if (request_len != 3u) return setup_error_invalid_pdu(response_buffer, ATT_EXCHANGE_MTU_REQUEST);
 801d8fa:	88fb      	ldrh	r3, [r7, #6]
 801d8fc:	2b03      	cmp	r3, #3
 801d8fe:	d005      	beq.n	801d90c <handle_exchange_mtu_request+0x22>
 801d900:	2102      	movs	r1, #2
 801d902:	6838      	ldr	r0, [r7, #0]
 801d904:	f7ff ff43 	bl	801d78e <setup_error_invalid_pdu>
 801d908:	4603      	mov	r3, r0
 801d90a:	e026      	b.n	801d95a <handle_exchange_mtu_request+0x70>

    uint16_t client_rx_mtu = little_endian_read_16(request_buffer, 1);
 801d90c:	2101      	movs	r1, #1
 801d90e:	68b8      	ldr	r0, [r7, #8]
 801d910:	f7f1 fa69 	bl	800ede6 <little_endian_read_16>
 801d914:	4603      	mov	r3, r0
 801d916:	82fb      	strh	r3, [r7, #22]
    
    // find min(local max mtu, remote mtu) >= ATT_DEFAULT_MTU and use as mtu for this connection
    uint16_t min_mtu = btstack_min(client_rx_mtu, att_connection->max_mtu);
 801d918:	8afa      	ldrh	r2, [r7, #22]
 801d91a:	68fb      	ldr	r3, [r7, #12]
 801d91c:	889b      	ldrh	r3, [r3, #4]
 801d91e:	4619      	mov	r1, r3
 801d920:	4610      	mov	r0, r2
 801d922:	f7f1 fbf4 	bl	800f10e <btstack_min>
 801d926:	4603      	mov	r3, r0
 801d928:	82bb      	strh	r3, [r7, #20]
    uint16_t new_mtu = btstack_max(ATT_DEFAULT_MTU, min_mtu);
 801d92a:	8abb      	ldrh	r3, [r7, #20]
 801d92c:	4619      	mov	r1, r3
 801d92e:	2017      	movs	r0, #23
 801d930:	f7f1 fbfd 	bl	800f12e <btstack_max>
 801d934:	4603      	mov	r3, r0
 801d936:	827b      	strh	r3, [r7, #18]
    att_connection->mtu_exchanged = true;
 801d938:	68fb      	ldr	r3, [r7, #12]
 801d93a:	2201      	movs	r2, #1
 801d93c:	719a      	strb	r2, [r3, #6]
    att_connection->mtu = new_mtu;
 801d93e:	68fb      	ldr	r3, [r7, #12]
 801d940:	8a7a      	ldrh	r2, [r7, #18]
 801d942:	805a      	strh	r2, [r3, #2]

    response_buffer[0] = ATT_EXCHANGE_MTU_RESPONSE;
 801d944:	683b      	ldr	r3, [r7, #0]
 801d946:	2203      	movs	r2, #3
 801d948:	701a      	strb	r2, [r3, #0]
    little_endian_store_16(response_buffer, 1, att_connection->mtu);
 801d94a:	68fb      	ldr	r3, [r7, #12]
 801d94c:	885b      	ldrh	r3, [r3, #2]
 801d94e:	461a      	mov	r2, r3
 801d950:	2101      	movs	r1, #1
 801d952:	6838      	ldr	r0, [r7, #0]
 801d954:	f7f1 fa87 	bl	800ee66 <little_endian_store_16>
    return 3;
 801d958:	2303      	movs	r3, #3
}
 801d95a:	4618      	mov	r0, r3
 801d95c:	3718      	adds	r7, #24
 801d95e:	46bd      	mov	sp, r7
 801d960:	bd80      	pop	{r7, pc}
	...

0801d964 <handle_find_information_request2>:
// MARK: ATT_FIND_INFORMATION_REQUEST
//
// TODO: handle other types then GATT_PRIMARY_SERVICE_UUID and GATT_SECONDARY_SERVICE_UUID
//
static uint16_t handle_find_information_request2(att_connection_t * att_connection, uint8_t * response_buffer, uint16_t response_buffer_size,
                                           uint16_t start_handle, uint16_t end_handle){
 801d964:	b580      	push	{r7, lr}
 801d966:	b08e      	sub	sp, #56	; 0x38
 801d968:	af02      	add	r7, sp, #8
 801d96a:	60f8      	str	r0, [r7, #12]
 801d96c:	60b9      	str	r1, [r7, #8]
 801d96e:	4611      	mov	r1, r2
 801d970:	461a      	mov	r2, r3
 801d972:	460b      	mov	r3, r1
 801d974:	80fb      	strh	r3, [r7, #6]
 801d976:	4613      	mov	r3, r2
 801d978:	80bb      	strh	r3, [r7, #4]
    
    UNUSED(att_connection);

    log_info("ATT_FIND_INFORMATION_REQUEST: from %04X to %04X", start_handle, end_handle);
 801d97a:	88bb      	ldrh	r3, [r7, #4]
 801d97c:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801d97e:	9201      	str	r2, [sp, #4]
 801d980:	9300      	str	r3, [sp, #0]
 801d982:	f240 1387 	movw	r3, #391	; 0x187
 801d986:	4a4d      	ldr	r2, [pc, #308]	; (801dabc <handle_find_information_request2+0x158>)
 801d988:	494d      	ldr	r1, [pc, #308]	; (801dac0 <handle_find_information_request2+0x15c>)
 801d98a:	2001      	movs	r0, #1
 801d98c:	f7f9 fd58 	bl	8017440 <hci_dump_log>
    uint8_t request_type = ATT_FIND_INFORMATION_REQUEST;
 801d990:	2304      	movs	r3, #4
 801d992:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    
    if ((start_handle > end_handle) || (start_handle == 0u)){
 801d996:	88ba      	ldrh	r2, [r7, #4]
 801d998:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 801d99a:	429a      	cmp	r2, r3
 801d99c:	d802      	bhi.n	801d9a4 <handle_find_information_request2+0x40>
 801d99e:	88bb      	ldrh	r3, [r7, #4]
 801d9a0:	2b00      	cmp	r3, #0
 801d9a2:	d109      	bne.n	801d9b8 <handle_find_information_request2+0x54>
        return setup_error_invalid_handle(response_buffer, request_type, start_handle);
 801d9a4:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 801d9a8:	b29b      	uxth	r3, r3
 801d9aa:	88ba      	ldrh	r2, [r7, #4]
 801d9ac:	4619      	mov	r1, r3
 801d9ae:	68b8      	ldr	r0, [r7, #8]
 801d9b0:	f7ff fec7 	bl	801d742 <setup_error_invalid_handle>
 801d9b4:	4603      	mov	r3, r0
 801d9b6:	e07c      	b.n	801dab2 <handle_find_information_request2+0x14e>
    }

    uint16_t offset   = 1;
 801d9b8:	2301      	movs	r3, #1
 801d9ba:	85fb      	strh	r3, [r7, #46]	; 0x2e
    uint16_t uuid_len = 0;
 801d9bc:	2300      	movs	r3, #0
 801d9be:	85bb      	strh	r3, [r7, #44]	; 0x2c
    
    att_iterator_t it;
    att_iterator_init(&it);
 801d9c0:	f107 0310 	add.w	r3, r7, #16
 801d9c4:	4618      	mov	r0, r3
 801d9c6:	f7ff fc41 	bl	801d24c <att_iterator_init>
    while (att_iterator_has_next(&it)){
 801d9ca:	e051      	b.n	801da70 <handle_find_information_request2+0x10c>
        att_iterator_fetch_next(&it);
 801d9cc:	f107 0310 	add.w	r3, r7, #16
 801d9d0:	4618      	mov	r0, r3
 801d9d2:	f7ff fc5c 	bl	801d28e <att_iterator_fetch_next>
        if (!it.handle) break;
 801d9d6:	8b3b      	ldrh	r3, [r7, #24]
 801d9d8:	2b00      	cmp	r3, #0
 801d9da:	d052      	beq.n	801da82 <handle_find_information_request2+0x11e>
        if (it.handle > end_handle) break;
 801d9dc:	8b3b      	ldrh	r3, [r7, #24]
 801d9de:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801d9e0:	429a      	cmp	r2, r3
 801d9e2:	d350      	bcc.n	801da86 <handle_find_information_request2+0x122>
        if (it.handle < start_handle) continue;
 801d9e4:	8b3b      	ldrh	r3, [r7, #24]
 801d9e6:	88ba      	ldrh	r2, [r7, #4]
 801d9e8:	429a      	cmp	r2, r3
 801d9ea:	d900      	bls.n	801d9ee <handle_find_information_request2+0x8a>
 801d9ec:	e040      	b.n	801da70 <handle_find_information_request2+0x10c>
                
        // log_info("Handle 0x%04x", it.handle);
        
        uint16_t this_uuid_len = (it.flags & ATT_PROPERTY_UUID128) ? 16 : 2;
 801d9ee:	8afb      	ldrh	r3, [r7, #22]
 801d9f0:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801d9f4:	2b00      	cmp	r3, #0
 801d9f6:	d001      	beq.n	801d9fc <handle_find_information_request2+0x98>
 801d9f8:	2310      	movs	r3, #16
 801d9fa:	e000      	b.n	801d9fe <handle_find_information_request2+0x9a>
 801d9fc:	2302      	movs	r3, #2
 801d9fe:	853b      	strh	r3, [r7, #40]	; 0x28

        // check if value has same len as last one if not first result
        if (offset > 1u){
 801da00:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801da02:	2b01      	cmp	r3, #1
 801da04:	d903      	bls.n	801da0e <handle_find_information_request2+0xaa>
            if (this_uuid_len != uuid_len) {
 801da06:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 801da08:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801da0a:	429a      	cmp	r2, r3
 801da0c:	d13d      	bne.n	801da8a <handle_find_information_request2+0x126>
                break;
            }
        }

        // first
        if (offset == 1u) {
 801da0e:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801da10:	2b01      	cmp	r3, #1
 801da12:	d111      	bne.n	801da38 <handle_find_information_request2+0xd4>
            uuid_len = this_uuid_len;
 801da14:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801da16:	85bb      	strh	r3, [r7, #44]	; 0x2c
            // set format field
            response_buffer[offset] = (it.flags & ATT_PROPERTY_UUID128) ? 0x02 : 0x01;
 801da18:	8afb      	ldrh	r3, [r7, #22]
 801da1a:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801da1e:	2b00      	cmp	r3, #0
 801da20:	d001      	beq.n	801da26 <handle_find_information_request2+0xc2>
 801da22:	2102      	movs	r1, #2
 801da24:	e000      	b.n	801da28 <handle_find_information_request2+0xc4>
 801da26:	2101      	movs	r1, #1
 801da28:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801da2a:	68ba      	ldr	r2, [r7, #8]
 801da2c:	4413      	add	r3, r2
 801da2e:	460a      	mov	r2, r1
 801da30:	701a      	strb	r2, [r3, #0]
            offset++;
 801da32:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801da34:	3301      	adds	r3, #1
 801da36:	85fb      	strh	r3, [r7, #46]	; 0x2e
        } 
        
        // space?
        if ((offset + 2u + uuid_len) > response_buffer_size) break;
 801da38:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801da3a:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801da3c:	4413      	add	r3, r2
 801da3e:	1c9a      	adds	r2, r3, #2
 801da40:	88fb      	ldrh	r3, [r7, #6]
 801da42:	429a      	cmp	r2, r3
 801da44:	d823      	bhi.n	801da8e <handle_find_information_request2+0x12a>
        
        // store
        little_endian_store_16(response_buffer, offset, it.handle);
 801da46:	8b3a      	ldrh	r2, [r7, #24]
 801da48:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801da4a:	4619      	mov	r1, r3
 801da4c:	68b8      	ldr	r0, [r7, #8]
 801da4e:	f7f1 fa0a 	bl	800ee66 <little_endian_store_16>
        offset += 2u;
 801da52:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801da54:	3302      	adds	r3, #2
 801da56:	85fb      	strh	r3, [r7, #46]	; 0x2e

        (void)memcpy(response_buffer + offset, it.uuid, uuid_len);
 801da58:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801da5a:	68ba      	ldr	r2, [r7, #8]
 801da5c:	4413      	add	r3, r2
 801da5e:	69f9      	ldr	r1, [r7, #28]
 801da60:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 801da62:	4618      	mov	r0, r3
 801da64:	f00a f809 	bl	8027a7a <memcpy>
        offset += uuid_len;
 801da68:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801da6a:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801da6c:	4413      	add	r3, r2
 801da6e:	85fb      	strh	r3, [r7, #46]	; 0x2e
    while (att_iterator_has_next(&it)){
 801da70:	f107 0310 	add.w	r3, r7, #16
 801da74:	4618      	mov	r0, r3
 801da76:	f7ff fbf9 	bl	801d26c <att_iterator_has_next>
 801da7a:	4603      	mov	r3, r0
 801da7c:	2b00      	cmp	r3, #0
 801da7e:	d1a5      	bne.n	801d9cc <handle_find_information_request2+0x68>
 801da80:	e006      	b.n	801da90 <handle_find_information_request2+0x12c>
        if (!it.handle) break;
 801da82:	bf00      	nop
 801da84:	e004      	b.n	801da90 <handle_find_information_request2+0x12c>
        if (it.handle > end_handle) break;
 801da86:	bf00      	nop
 801da88:	e002      	b.n	801da90 <handle_find_information_request2+0x12c>
                break;
 801da8a:	bf00      	nop
 801da8c:	e000      	b.n	801da90 <handle_find_information_request2+0x12c>
        if ((offset + 2u + uuid_len) > response_buffer_size) break;
 801da8e:	bf00      	nop
    }
    
    if (offset == 1u){
 801da90:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801da92:	2b01      	cmp	r3, #1
 801da94:	d109      	bne.n	801daaa <handle_find_information_request2+0x146>
        return setup_error_atribute_not_found(response_buffer, request_type, start_handle);
 801da96:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 801da9a:	b29b      	uxth	r3, r3
 801da9c:	88ba      	ldrh	r2, [r7, #4]
 801da9e:	4619      	mov	r1, r3
 801daa0:	68b8      	ldr	r0, [r7, #8]
 801daa2:	f7ff fe3b 	bl	801d71c <setup_error_atribute_not_found>
 801daa6:	4603      	mov	r3, r0
 801daa8:	e003      	b.n	801dab2 <handle_find_information_request2+0x14e>
    }
    
    response_buffer[0] = ATT_FIND_INFORMATION_REPLY;
 801daaa:	68bb      	ldr	r3, [r7, #8]
 801daac:	2205      	movs	r2, #5
 801daae:	701a      	strb	r2, [r3, #0]
    return offset;
 801dab0:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
}
 801dab2:	4618      	mov	r0, r3
 801dab4:	3730      	adds	r7, #48	; 0x30
 801dab6:	46bd      	mov	sp, r7
 801dab8:	bd80      	pop	{r7, pc}
 801daba:	bf00      	nop
 801dabc:	0802cb8c 	.word	0x0802cb8c
 801dac0:	0802ccb0 	.word	0x0802ccb0

0801dac4 <handle_find_information_request>:

static uint16_t handle_find_information_request(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len,
                                         uint8_t * response_buffer, uint16_t response_buffer_size){
 801dac4:	b580      	push	{r7, lr}
 801dac6:	b088      	sub	sp, #32
 801dac8:	af02      	add	r7, sp, #8
 801daca:	60f8      	str	r0, [r7, #12]
 801dacc:	60b9      	str	r1, [r7, #8]
 801dace:	603b      	str	r3, [r7, #0]
 801dad0:	4613      	mov	r3, r2
 801dad2:	80fb      	strh	r3, [r7, #6]

    if (request_len != 5u) return setup_error_invalid_pdu(response_buffer, ATT_FIND_INFORMATION_REQUEST);
 801dad4:	88fb      	ldrh	r3, [r7, #6]
 801dad6:	2b05      	cmp	r3, #5
 801dad8:	d005      	beq.n	801dae6 <handle_find_information_request+0x22>
 801dada:	2104      	movs	r1, #4
 801dadc:	6838      	ldr	r0, [r7, #0]
 801dade:	f7ff fe56 	bl	801d78e <setup_error_invalid_pdu>
 801dae2:	4603      	mov	r3, r0
 801dae4:	e015      	b.n	801db12 <handle_find_information_request+0x4e>

    uint16_t start_handle = little_endian_read_16(request_buffer, 1);
 801dae6:	2101      	movs	r1, #1
 801dae8:	68b8      	ldr	r0, [r7, #8]
 801daea:	f7f1 f97c 	bl	800ede6 <little_endian_read_16>
 801daee:	4603      	mov	r3, r0
 801daf0:	82fb      	strh	r3, [r7, #22]
    uint16_t end_handle = little_endian_read_16(request_buffer, 3);
 801daf2:	2103      	movs	r1, #3
 801daf4:	68b8      	ldr	r0, [r7, #8]
 801daf6:	f7f1 f976 	bl	800ede6 <little_endian_read_16>
 801dafa:	4603      	mov	r3, r0
 801dafc:	82bb      	strh	r3, [r7, #20]
    return handle_find_information_request2(att_connection, response_buffer, response_buffer_size, start_handle, end_handle);
 801dafe:	8af9      	ldrh	r1, [r7, #22]
 801db00:	8c3a      	ldrh	r2, [r7, #32]
 801db02:	8abb      	ldrh	r3, [r7, #20]
 801db04:	9300      	str	r3, [sp, #0]
 801db06:	460b      	mov	r3, r1
 801db08:	6839      	ldr	r1, [r7, #0]
 801db0a:	68f8      	ldr	r0, [r7, #12]
 801db0c:	f7ff ff2a 	bl	801d964 <handle_find_information_request2>
 801db10:	4603      	mov	r3, r0
}
 801db12:	4618      	mov	r0, r3
 801db14:	3718      	adds	r7, #24
 801db16:	46bd      	mov	sp, r7
 801db18:	bd80      	pop	{r7, pc}
	...

0801db1c <handle_find_by_type_value_request>:
//
// NOTE: doesn't handle DYNAMIC values
// NOTE: only supports 16 bit UUIDs
//
static uint16_t handle_find_by_type_value_request(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len,
                                           uint8_t * response_buffer, uint16_t response_buffer_size){
 801db1c:	b580      	push	{r7, lr}
 801db1e:	b094      	sub	sp, #80	; 0x50
 801db20:	af04      	add	r7, sp, #16
 801db22:	60f8      	str	r0, [r7, #12]
 801db24:	60b9      	str	r1, [r7, #8]
 801db26:	603b      	str	r3, [r7, #0]
 801db28:	4613      	mov	r3, r2
 801db2a:	80fb      	strh	r3, [r7, #6]
    UNUSED(att_connection);

    if (request_len < 7u) return setup_error_invalid_pdu(response_buffer, ATT_FIND_BY_TYPE_VALUE_REQUEST);
 801db2c:	88fb      	ldrh	r3, [r7, #6]
 801db2e:	2b06      	cmp	r3, #6
 801db30:	d805      	bhi.n	801db3e <handle_find_by_type_value_request+0x22>
 801db32:	2106      	movs	r1, #6
 801db34:	6838      	ldr	r0, [r7, #0]
 801db36:	f7ff fe2a 	bl	801d78e <setup_error_invalid_pdu>
 801db3a:	4603      	mov	r3, r0
 801db3c:	e0db      	b.n	801dcf6 <handle_find_by_type_value_request+0x1da>

    // parse request
    uint16_t start_handle = little_endian_read_16(request_buffer, 1);
 801db3e:	2101      	movs	r1, #1
 801db40:	68b8      	ldr	r0, [r7, #8]
 801db42:	f7f1 f950 	bl	800ede6 <little_endian_read_16>
 801db46:	4603      	mov	r3, r0
 801db48:	873b      	strh	r3, [r7, #56]	; 0x38
    uint16_t end_handle = little_endian_read_16(request_buffer, 3);
 801db4a:	2103      	movs	r1, #3
 801db4c:	68b8      	ldr	r0, [r7, #8]
 801db4e:	f7f1 f94a 	bl	800ede6 <little_endian_read_16>
 801db52:	4603      	mov	r3, r0
 801db54:	86fb      	strh	r3, [r7, #54]	; 0x36
    uint16_t attribute_type = little_endian_read_16(request_buffer, 5);
 801db56:	2105      	movs	r1, #5
 801db58:	68b8      	ldr	r0, [r7, #8]
 801db5a:	f7f1 f944 	bl	800ede6 <little_endian_read_16>
 801db5e:	4603      	mov	r3, r0
 801db60:	86bb      	strh	r3, [r7, #52]	; 0x34
    const uint8_t *attribute_value = &request_buffer[7];
 801db62:	68bb      	ldr	r3, [r7, #8]
 801db64:	3307      	adds	r3, #7
 801db66:	633b      	str	r3, [r7, #48]	; 0x30
    uint16_t attribute_len = request_len - 7u;
 801db68:	88fb      	ldrh	r3, [r7, #6]
 801db6a:	3b07      	subs	r3, #7
 801db6c:	85fb      	strh	r3, [r7, #46]	; 0x2e

    log_info("ATT_FIND_BY_TYPE_VALUE_REQUEST: from %04X to %04X, type %04X, value: ", start_handle, end_handle, attribute_type);
 801db6e:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 801db70:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801db72:	8eb9      	ldrh	r1, [r7, #52]	; 0x34
 801db74:	9102      	str	r1, [sp, #8]
 801db76:	9201      	str	r2, [sp, #4]
 801db78:	9300      	str	r3, [sp, #0]
 801db7a:	f44f 73f1 	mov.w	r3, #482	; 0x1e2
 801db7e:	4a60      	ldr	r2, [pc, #384]	; (801dd00 <handle_find_by_type_value_request+0x1e4>)
 801db80:	4960      	ldr	r1, [pc, #384]	; (801dd04 <handle_find_by_type_value_request+0x1e8>)
 801db82:	2001      	movs	r0, #1
 801db84:	f7f9 fc5c 	bl	8017440 <hci_dump_log>
    log_info_hexdump(attribute_value, attribute_len);
 801db88:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801db8a:	4619      	mov	r1, r3
 801db8c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801db8e:	f7f1 fbe3 	bl	800f358 <log_info_hexdump>
    uint8_t request_type = ATT_FIND_BY_TYPE_VALUE_REQUEST;
 801db92:	2306      	movs	r3, #6
 801db94:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d

    if ((start_handle > end_handle) || (start_handle == 0u)){
 801db98:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801db9a:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801db9c:	429a      	cmp	r2, r3
 801db9e:	d802      	bhi.n	801dba6 <handle_find_by_type_value_request+0x8a>
 801dba0:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 801dba2:	2b00      	cmp	r3, #0
 801dba4:	d109      	bne.n	801dbba <handle_find_by_type_value_request+0x9e>
        return setup_error_invalid_handle(response_buffer, request_type, start_handle);
 801dba6:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
 801dbaa:	b29b      	uxth	r3, r3
 801dbac:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801dbae:	4619      	mov	r1, r3
 801dbb0:	6838      	ldr	r0, [r7, #0]
 801dbb2:	f7ff fdc6 	bl	801d742 <setup_error_invalid_handle>
 801dbb6:	4603      	mov	r3, r0
 801dbb8:	e09d      	b.n	801dcf6 <handle_find_by_type_value_request+0x1da>
    }

    uint16_t offset      = 1;
 801dbba:	2301      	movs	r3, #1
 801dbbc:	87fb      	strh	r3, [r7, #62]	; 0x3e
    uint16_t in_group    = 0;
 801dbbe:	2300      	movs	r3, #0
 801dbc0:	87bb      	strh	r3, [r7, #60]	; 0x3c
    uint16_t prev_handle = 0;
 801dbc2:	2300      	movs	r3, #0
 801dbc4:	877b      	strh	r3, [r7, #58]	; 0x3a

    att_iterator_t it;
    att_iterator_init(&it);
 801dbc6:	f107 0314 	add.w	r3, r7, #20
 801dbca:	4618      	mov	r0, r3
 801dbcc:	f7ff fb3e 	bl	801d24c <att_iterator_init>
    while (att_iterator_has_next(&it)){
 801dbd0:	e074      	b.n	801dcbc <handle_find_by_type_value_request+0x1a0>
        att_iterator_fetch_next(&it);
 801dbd2:	f107 0314 	add.w	r3, r7, #20
 801dbd6:	4618      	mov	r0, r3
 801dbd8:	f7ff fb59 	bl	801d28e <att_iterator_fetch_next>

        if (it.handle && (it.handle < start_handle)) continue;
 801dbdc:	8bbb      	ldrh	r3, [r7, #28]
 801dbde:	2b00      	cmp	r3, #0
 801dbe0:	d004      	beq.n	801dbec <handle_find_by_type_value_request+0xd0>
 801dbe2:	8bbb      	ldrh	r3, [r7, #28]
 801dbe4:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801dbe6:	429a      	cmp	r2, r3
 801dbe8:	d900      	bls.n	801dbec <handle_find_by_type_value_request+0xd0>
 801dbea:	e067      	b.n	801dcbc <handle_find_by_type_value_request+0x1a0>
        if (it.handle > end_handle) break;  // (1)
 801dbec:	8bbb      	ldrh	r3, [r7, #28]
 801dbee:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801dbf0:	429a      	cmp	r2, r3
 801dbf2:	d36c      	bcc.n	801dcce <handle_find_by_type_value_request+0x1b2>

        // close current tag, if within a group and a new service definition starts or we reach end of att db
        if (in_group &&
 801dbf4:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 801dbf6:	2b00      	cmp	r3, #0
 801dbf8:	d030      	beq.n	801dc5c <handle_find_by_type_value_request+0x140>
            ((it.handle == 0u) || att_iterator_match_uuid16(&it, GATT_PRIMARY_SERVICE_UUID) || att_iterator_match_uuid16(&it, GATT_SECONDARY_SERVICE_UUID))){
 801dbfa:	8bbb      	ldrh	r3, [r7, #28]
        if (in_group &&
 801dbfc:	2b00      	cmp	r3, #0
 801dbfe:	d013      	beq.n	801dc28 <handle_find_by_type_value_request+0x10c>
            ((it.handle == 0u) || att_iterator_match_uuid16(&it, GATT_PRIMARY_SERVICE_UUID) || att_iterator_match_uuid16(&it, GATT_SECONDARY_SERVICE_UUID))){
 801dc00:	f107 0314 	add.w	r3, r7, #20
 801dc04:	f44f 5120 	mov.w	r1, #10240	; 0x2800
 801dc08:	4618      	mov	r0, r3
 801dc0a:	f7ff fba7 	bl	801d35c <att_iterator_match_uuid16>
 801dc0e:	4603      	mov	r3, r0
 801dc10:	2b00      	cmp	r3, #0
 801dc12:	d109      	bne.n	801dc28 <handle_find_by_type_value_request+0x10c>
 801dc14:	f107 0314 	add.w	r3, r7, #20
 801dc18:	f642 0101 	movw	r1, #10241	; 0x2801
 801dc1c:	4618      	mov	r0, r3
 801dc1e:	f7ff fb9d 	bl	801d35c <att_iterator_match_uuid16>
 801dc22:	4603      	mov	r3, r0
 801dc24:	2b00      	cmp	r3, #0
 801dc26:	d019      	beq.n	801dc5c <handle_find_by_type_value_request+0x140>

            log_info("End of group, handle 0x%04x", prev_handle);
 801dc28:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801dc2a:	9300      	str	r3, [sp, #0]
 801dc2c:	f44f 73fd 	mov.w	r3, #506	; 0x1fa
 801dc30:	4a33      	ldr	r2, [pc, #204]	; (801dd00 <handle_find_by_type_value_request+0x1e4>)
 801dc32:	4935      	ldr	r1, [pc, #212]	; (801dd08 <handle_find_by_type_value_request+0x1ec>)
 801dc34:	2001      	movs	r0, #1
 801dc36:	f7f9 fc03 	bl	8017440 <hci_dump_log>
            little_endian_store_16(response_buffer, offset, prev_handle);
 801dc3a:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 801dc3c:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801dc3e:	4619      	mov	r1, r3
 801dc40:	6838      	ldr	r0, [r7, #0]
 801dc42:	f7f1 f910 	bl	800ee66 <little_endian_store_16>
            offset += 2u;
 801dc46:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801dc48:	3302      	adds	r3, #2
 801dc4a:	87fb      	strh	r3, [r7, #62]	; 0x3e
            in_group = 0;
 801dc4c:	2300      	movs	r3, #0
 801dc4e:	87bb      	strh	r3, [r7, #60]	; 0x3c

            // check if space for another handle pair available
            if ((offset + 4u) > response_buffer_size){
 801dc50:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801dc52:	1d1a      	adds	r2, r3, #4
 801dc54:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 801dc58:	429a      	cmp	r2, r3
 801dc5a:	d83a      	bhi.n	801dcd2 <handle_find_by_type_value_request+0x1b6>
                break;
            }
        }

        // keep track of previous handle
        prev_handle = it.handle;
 801dc5c:	8bbb      	ldrh	r3, [r7, #28]
 801dc5e:	877b      	strh	r3, [r7, #58]	; 0x3a

        // does current attribute match
        if (it.handle && att_iterator_match_uuid16(&it, attribute_type) && (attribute_len == it.value_len) && (memcmp(attribute_value, it.value, it.value_len) == 0)){
 801dc60:	8bbb      	ldrh	r3, [r7, #28]
 801dc62:	2b00      	cmp	r3, #0
 801dc64:	d02a      	beq.n	801dcbc <handle_find_by_type_value_request+0x1a0>
 801dc66:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801dc68:	f107 0314 	add.w	r3, r7, #20
 801dc6c:	4611      	mov	r1, r2
 801dc6e:	4618      	mov	r0, r3
 801dc70:	f7ff fb74 	bl	801d35c <att_iterator_match_uuid16>
 801dc74:	4603      	mov	r3, r0
 801dc76:	2b00      	cmp	r3, #0
 801dc78:	d020      	beq.n	801dcbc <handle_find_by_type_value_request+0x1a0>
 801dc7a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801dc7c:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801dc7e:	429a      	cmp	r2, r3
 801dc80:	d11c      	bne.n	801dcbc <handle_find_by_type_value_request+0x1a0>
 801dc82:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801dc84:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 801dc86:	4619      	mov	r1, r3
 801dc88:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801dc8a:	f009 fee7 	bl	8027a5c <memcmp>
 801dc8e:	4603      	mov	r3, r0
 801dc90:	2b00      	cmp	r3, #0
 801dc92:	d113      	bne.n	801dcbc <handle_find_by_type_value_request+0x1a0>
            log_info("Begin of group, handle 0x%04x", it.handle);
 801dc94:	8bbb      	ldrh	r3, [r7, #28]
 801dc96:	9300      	str	r3, [sp, #0]
 801dc98:	f240 230a 	movw	r3, #522	; 0x20a
 801dc9c:	4a18      	ldr	r2, [pc, #96]	; (801dd00 <handle_find_by_type_value_request+0x1e4>)
 801dc9e:	491b      	ldr	r1, [pc, #108]	; (801dd0c <handle_find_by_type_value_request+0x1f0>)
 801dca0:	2001      	movs	r0, #1
 801dca2:	f7f9 fbcd 	bl	8017440 <hci_dump_log>
            little_endian_store_16(response_buffer, offset, it.handle);
 801dca6:	8bba      	ldrh	r2, [r7, #28]
 801dca8:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801dcaa:	4619      	mov	r1, r3
 801dcac:	6838      	ldr	r0, [r7, #0]
 801dcae:	f7f1 f8da 	bl	800ee66 <little_endian_store_16>
            offset += 2u;
 801dcb2:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801dcb4:	3302      	adds	r3, #2
 801dcb6:	87fb      	strh	r3, [r7, #62]	; 0x3e
            in_group = 1;
 801dcb8:	2301      	movs	r3, #1
 801dcba:	87bb      	strh	r3, [r7, #60]	; 0x3c
    while (att_iterator_has_next(&it)){
 801dcbc:	f107 0314 	add.w	r3, r7, #20
 801dcc0:	4618      	mov	r0, r3
 801dcc2:	f7ff fad3 	bl	801d26c <att_iterator_has_next>
 801dcc6:	4603      	mov	r3, r0
 801dcc8:	2b00      	cmp	r3, #0
 801dcca:	d182      	bne.n	801dbd2 <handle_find_by_type_value_request+0xb6>
 801dccc:	e002      	b.n	801dcd4 <handle_find_by_type_value_request+0x1b8>
        if (it.handle > end_handle) break;  // (1)
 801dcce:	bf00      	nop
 801dcd0:	e000      	b.n	801dcd4 <handle_find_by_type_value_request+0x1b8>
                break;
 801dcd2:	bf00      	nop
        }
    }

    if (offset == 1u){
 801dcd4:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801dcd6:	2b01      	cmp	r3, #1
 801dcd8:	d109      	bne.n	801dcee <handle_find_by_type_value_request+0x1d2>
        return setup_error_atribute_not_found(response_buffer, request_type, start_handle);
 801dcda:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
 801dcde:	b29b      	uxth	r3, r3
 801dce0:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801dce2:	4619      	mov	r1, r3
 801dce4:	6838      	ldr	r0, [r7, #0]
 801dce6:	f7ff fd19 	bl	801d71c <setup_error_atribute_not_found>
 801dcea:	4603      	mov	r3, r0
 801dcec:	e003      	b.n	801dcf6 <handle_find_by_type_value_request+0x1da>
    }

    response_buffer[0] = ATT_FIND_BY_TYPE_VALUE_RESPONSE;
 801dcee:	683b      	ldr	r3, [r7, #0]
 801dcf0:	2207      	movs	r2, #7
 801dcf2:	701a      	strb	r2, [r3, #0]
    return offset;
 801dcf4:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
}
 801dcf6:	4618      	mov	r0, r3
 801dcf8:	3740      	adds	r7, #64	; 0x40
 801dcfa:	46bd      	mov	sp, r7
 801dcfc:	bd80      	pop	{r7, pc}
 801dcfe:	bf00      	nop
 801dd00:	0802cb8c 	.word	0x0802cb8c
 801dd04:	0802cce8 	.word	0x0802cce8
 801dd08:	0802cd38 	.word	0x0802cd38
 801dd0c:	0802cd5c 	.word	0x0802cd5c

0801dd10 <handle_read_by_type_request2>:
//
// MARK: ATT_READ_BY_TYPE_REQUEST
//
static uint16_t handle_read_by_type_request2(att_connection_t * att_connection, uint8_t * response_buffer, uint16_t response_buffer_size,
                                      uint16_t start_handle, uint16_t end_handle,
                                      uint16_t attribute_type_len, uint8_t * attribute_type){
 801dd10:	b580      	push	{r7, lr}
 801dd12:	b090      	sub	sp, #64	; 0x40
 801dd14:	af02      	add	r7, sp, #8
 801dd16:	60f8      	str	r0, [r7, #12]
 801dd18:	60b9      	str	r1, [r7, #8]
 801dd1a:	4611      	mov	r1, r2
 801dd1c:	461a      	mov	r2, r3
 801dd1e:	460b      	mov	r3, r1
 801dd20:	80fb      	strh	r3, [r7, #6]
 801dd22:	4613      	mov	r3, r2
 801dd24:	80bb      	strh	r3, [r7, #4]
    
    log_info("ATT_READ_BY_TYPE_REQUEST: from %04X to %04X, type: ", start_handle, end_handle); 
 801dd26:	88bb      	ldrh	r3, [r7, #4]
 801dd28:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
 801dd2c:	9201      	str	r2, [sp, #4]
 801dd2e:	9300      	str	r3, [sp, #0]
 801dd30:	f44f 7308 	mov.w	r3, #544	; 0x220
 801dd34:	4a7f      	ldr	r2, [pc, #508]	; (801df34 <handle_read_by_type_request2+0x224>)
 801dd36:	4980      	ldr	r1, [pc, #512]	; (801df38 <handle_read_by_type_request2+0x228>)
 801dd38:	2001      	movs	r0, #1
 801dd3a:	f7f9 fb81 	bl	8017440 <hci_dump_log>
    log_info_hexdump(attribute_type, attribute_type_len);
 801dd3e:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 801dd42:	4619      	mov	r1, r3
 801dd44:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 801dd46:	f7f1 fb07 	bl	800f358 <log_info_hexdump>
    uint8_t request_type = ATT_READ_BY_TYPE_REQUEST;
 801dd4a:	2308      	movs	r3, #8
 801dd4c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    if ((start_handle > end_handle) || (start_handle == 0u)){
 801dd50:	88ba      	ldrh	r2, [r7, #4]
 801dd52:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 801dd56:	429a      	cmp	r2, r3
 801dd58:	d802      	bhi.n	801dd60 <handle_read_by_type_request2+0x50>
 801dd5a:	88bb      	ldrh	r3, [r7, #4]
 801dd5c:	2b00      	cmp	r3, #0
 801dd5e:	d109      	bne.n	801dd74 <handle_read_by_type_request2+0x64>
        return setup_error_invalid_handle(response_buffer, request_type, start_handle);
 801dd60:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801dd64:	b29b      	uxth	r3, r3
 801dd66:	88ba      	ldrh	r2, [r7, #4]
 801dd68:	4619      	mov	r1, r3
 801dd6a:	68b8      	ldr	r0, [r7, #8]
 801dd6c:	f7ff fce9 	bl	801d742 <setup_error_invalid_handle>
 801dd70:	4603      	mov	r3, r0
 801dd72:	e0db      	b.n	801df2c <handle_read_by_type_request2+0x21c>
    }

    uint16_t offset   = 1;
 801dd74:	2301      	movs	r3, #1
 801dd76:	86fb      	strh	r3, [r7, #54]	; 0x36
    uint16_t pair_len = 0;
 801dd78:	2300      	movs	r3, #0
 801dd7a:	86bb      	strh	r3, [r7, #52]	; 0x34

    att_iterator_t it;
    att_iterator_init(&it);
 801dd7c:	f107 0310 	add.w	r3, r7, #16
 801dd80:	4618      	mov	r0, r3
 801dd82:	f7ff fa63 	bl	801d24c <att_iterator_init>
    uint8_t error_code = 0;
 801dd86:	2300      	movs	r3, #0
 801dd88:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    uint16_t first_matching_but_unreadable_handle = 0;
 801dd8c:	2300      	movs	r3, #0
 801dd8e:	863b      	strh	r3, [r7, #48]	; 0x30

    while (att_iterator_has_next(&it)){
 801dd90:	e090      	b.n	801deb4 <handle_read_by_type_request2+0x1a4>
        att_iterator_fetch_next(&it);
 801dd92:	f107 0310 	add.w	r3, r7, #16
 801dd96:	4618      	mov	r0, r3
 801dd98:	f7ff fa79 	bl	801d28e <att_iterator_fetch_next>
        
        if ((it.handle == 0u ) || (it.handle > end_handle)) break;
 801dd9c:	8b3b      	ldrh	r3, [r7, #24]
 801dd9e:	2b00      	cmp	r3, #0
 801dda0:	f000 8097 	beq.w	801ded2 <handle_read_by_type_request2+0x1c2>
 801dda4:	8b3b      	ldrh	r3, [r7, #24]
 801dda6:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
 801ddaa:	429a      	cmp	r2, r3
 801ddac:	f0c0 8091 	bcc.w	801ded2 <handle_read_by_type_request2+0x1c2>

        if (it.handle < start_handle) continue;
 801ddb0:	8b3b      	ldrh	r3, [r7, #24]
 801ddb2:	88ba      	ldrh	r2, [r7, #4]
 801ddb4:	429a      	cmp	r2, r3
 801ddb6:	d900      	bls.n	801ddba <handle_read_by_type_request2+0xaa>
 801ddb8:	e07c      	b.n	801deb4 <handle_read_by_type_request2+0x1a4>

        // does current attribute match
        if (!att_iterator_match_uuid(&it, attribute_type, attribute_type_len)) continue;
 801ddba:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 801ddbe:	f107 0310 	add.w	r3, r7, #16
 801ddc2:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 801ddc4:	4618      	mov	r0, r3
 801ddc6:	f7ff fb06 	bl	801d3d6 <att_iterator_match_uuid>
 801ddca:	4603      	mov	r3, r0
 801ddcc:	2b00      	cmp	r3, #0
 801ddce:	d100      	bne.n	801ddd2 <handle_read_by_type_request2+0xc2>
 801ddd0:	e070      	b.n	801deb4 <handle_read_by_type_request2+0x1a4>
        
        // skip handles that cannot be read but remember that there has been at least one
        if ((it.flags & ATT_PROPERTY_READ) == 0u) {
 801ddd2:	8afb      	ldrh	r3, [r7, #22]
 801ddd4:	f003 0302 	and.w	r3, r3, #2
 801ddd8:	2b00      	cmp	r3, #0
 801ddda:	d105      	bne.n	801dde8 <handle_read_by_type_request2+0xd8>
            if (first_matching_but_unreadable_handle == 0u) {
 801dddc:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 801ddde:	2b00      	cmp	r3, #0
 801dde0:	d168      	bne.n	801deb4 <handle_read_by_type_request2+0x1a4>
                first_matching_but_unreadable_handle = it.handle;
 801dde2:	8b3b      	ldrh	r3, [r7, #24]
 801dde4:	863b      	strh	r3, [r7, #48]	; 0x30
            }
            continue;
 801dde6:	e065      	b.n	801deb4 <handle_read_by_type_request2+0x1a4>
        }

        // check security requirements
        error_code = att_validate_security(att_connection, ATT_READ, &it);
 801dde8:	f107 0310 	add.w	r3, r7, #16
 801ddec:	461a      	mov	r2, r3
 801ddee:	2100      	movs	r1, #0
 801ddf0:	68f8      	ldr	r0, [r7, #12]
 801ddf2:	f7ff fcdd 	bl	801d7b0 <att_validate_security>
 801ddf6:	4603      	mov	r3, r0
 801ddf8:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
        if (error_code != 0u) break;
 801ddfc:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801de00:	2b00      	cmp	r3, #0
 801de02:	d161      	bne.n	801dec8 <handle_read_by_type_request2+0x1b8>

        att_update_value_len(&it, att_connection->con_handle);
 801de04:	68fb      	ldr	r3, [r7, #12]
 801de06:	881a      	ldrh	r2, [r3, #0]
 801de08:	f107 0310 	add.w	r3, r7, #16
 801de0c:	4611      	mov	r1, r2
 801de0e:	4618      	mov	r0, r3
 801de10:	f7ff fb54 	bl	801d4bc <att_update_value_len>
        
#ifdef ENABLE_ATT_DELAYED_RESPONSE
        if (it.value_len == ATT_READ_RESPONSE_PENDING){
 801de14:	8c3b      	ldrh	r3, [r7, #32]
 801de16:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801de1a:	4293      	cmp	r3, r2
 801de1c:	d102      	bne.n	801de24 <handle_read_by_type_request2+0x114>
            return ATT_READ_RESPONSE_PENDING;
 801de1e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801de22:	e083      	b.n	801df2c <handle_read_by_type_request2+0x21c>
        }
#endif

        // check if value has same len as last one
        uint16_t this_pair_len = 2u + it.value_len;
 801de24:	8c3b      	ldrh	r3, [r7, #32]
 801de26:	3302      	adds	r3, #2
 801de28:	85bb      	strh	r3, [r7, #44]	; 0x2c
        if ((offset > 1u) && (pair_len != this_pair_len)) {
 801de2a:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801de2c:	2b01      	cmp	r3, #1
 801de2e:	d903      	bls.n	801de38 <handle_read_by_type_request2+0x128>
 801de30:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801de32:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801de34:	429a      	cmp	r2, r3
 801de36:	d149      	bne.n	801decc <handle_read_by_type_request2+0x1bc>
            break;
        }
        
        // first
        if (offset == 1u) {
 801de38:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801de3a:	2b01      	cmp	r3, #1
 801de3c:	d10a      	bne.n	801de54 <handle_read_by_type_request2+0x144>
            pair_len = this_pair_len;
 801de3e:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801de40:	86bb      	strh	r3, [r7, #52]	; 0x34
            response_buffer[offset] = pair_len;
 801de42:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801de44:	68ba      	ldr	r2, [r7, #8]
 801de46:	4413      	add	r3, r2
 801de48:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801de4a:	b2d2      	uxtb	r2, r2
 801de4c:	701a      	strb	r2, [r3, #0]
            offset++;
 801de4e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801de50:	3301      	adds	r3, #1
 801de52:	86fb      	strh	r3, [r7, #54]	; 0x36
        }
        
        // space?
        if ((offset + pair_len) > response_buffer_size) {
 801de54:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801de56:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 801de58:	441a      	add	r2, r3
 801de5a:	88fb      	ldrh	r3, [r7, #6]
 801de5c:	429a      	cmp	r2, r3
 801de5e:	dd0d      	ble.n	801de7c <handle_read_by_type_request2+0x16c>
            if (offset > 2u) break;
 801de60:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801de62:	2b02      	cmp	r3, #2
 801de64:	d834      	bhi.n	801ded0 <handle_read_by_type_request2+0x1c0>
            it.value_len = response_buffer_size - 4u;
 801de66:	88fb      	ldrh	r3, [r7, #6]
 801de68:	3b04      	subs	r3, #4
 801de6a:	b29b      	uxth	r3, r3
 801de6c:	843b      	strh	r3, [r7, #32]
            response_buffer[1u] = 2u + it.value_len;
 801de6e:	8c3b      	ldrh	r3, [r7, #32]
 801de70:	b2da      	uxtb	r2, r3
 801de72:	68bb      	ldr	r3, [r7, #8]
 801de74:	3301      	adds	r3, #1
 801de76:	3202      	adds	r2, #2
 801de78:	b2d2      	uxtb	r2, r2
 801de7a:	701a      	strb	r2, [r3, #0]
        }
        
        // store
        little_endian_store_16(response_buffer, offset, it.handle);
 801de7c:	8b3a      	ldrh	r2, [r7, #24]
 801de7e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801de80:	4619      	mov	r1, r3
 801de82:	68b8      	ldr	r0, [r7, #8]
 801de84:	f7f0 ffef 	bl	800ee66 <little_endian_store_16>
        offset += 2u;
 801de88:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801de8a:	3302      	adds	r3, #2
 801de8c:	86fb      	strh	r3, [r7, #54]	; 0x36
        uint16_t bytes_copied = att_copy_value(&it, 0, response_buffer + offset, it.value_len, att_connection->con_handle);
 801de8e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801de90:	68ba      	ldr	r2, [r7, #8]
 801de92:	441a      	add	r2, r3
 801de94:	8c39      	ldrh	r1, [r7, #32]
 801de96:	68fb      	ldr	r3, [r7, #12]
 801de98:	881b      	ldrh	r3, [r3, #0]
 801de9a:	f107 0010 	add.w	r0, r7, #16
 801de9e:	9300      	str	r3, [sp, #0]
 801dea0:	460b      	mov	r3, r1
 801dea2:	2100      	movs	r1, #0
 801dea4:	f7ff fb2c 	bl	801d500 <att_copy_value>
 801dea8:	4603      	mov	r3, r0
 801deaa:	857b      	strh	r3, [r7, #42]	; 0x2a
        offset += bytes_copied;
 801deac:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801deae:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801deb0:	4413      	add	r3, r2
 801deb2:	86fb      	strh	r3, [r7, #54]	; 0x36
    while (att_iterator_has_next(&it)){
 801deb4:	f107 0310 	add.w	r3, r7, #16
 801deb8:	4618      	mov	r0, r3
 801deba:	f7ff f9d7 	bl	801d26c <att_iterator_has_next>
 801debe:	4603      	mov	r3, r0
 801dec0:	2b00      	cmp	r3, #0
 801dec2:	f47f af66 	bne.w	801dd92 <handle_read_by_type_request2+0x82>
 801dec6:	e004      	b.n	801ded2 <handle_read_by_type_request2+0x1c2>
        if (error_code != 0u) break;
 801dec8:	bf00      	nop
 801deca:	e002      	b.n	801ded2 <handle_read_by_type_request2+0x1c2>
            break;
 801decc:	bf00      	nop
 801dece:	e000      	b.n	801ded2 <handle_read_by_type_request2+0x1c2>
            if (offset > 2u) break;
 801ded0:	bf00      	nop
    }

    // at least one attribute could be read
    if (offset > 1u){
 801ded2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801ded4:	2b01      	cmp	r3, #1
 801ded6:	d904      	bls.n	801dee2 <handle_read_by_type_request2+0x1d2>
        response_buffer[0] = ATT_READ_BY_TYPE_RESPONSE;
 801ded8:	68bb      	ldr	r3, [r7, #8]
 801deda:	2209      	movs	r2, #9
 801dedc:	701a      	strb	r2, [r3, #0]
        return offset;
 801dede:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801dee0:	e024      	b.n	801df2c <handle_read_by_type_request2+0x21c>
    }

    // first attribute had an error
    if (error_code != 0u){
 801dee2:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801dee6:	2b00      	cmp	r3, #0
 801dee8:	d00a      	beq.n	801df00 <handle_read_by_type_request2+0x1f0>
        return setup_error(response_buffer, request_type, start_handle, error_code);
 801deea:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801deee:	b299      	uxth	r1, r3
 801def0:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801def4:	88ba      	ldrh	r2, [r7, #4]
 801def6:	68b8      	ldr	r0, [r7, #8]
 801def8:	f7ff fbc6 	bl	801d688 <setup_error>
 801defc:	4603      	mov	r3, r0
 801defe:	e015      	b.n	801df2c <handle_read_by_type_request2+0x21c>
    }

    // no other errors, but all found attributes had been non-readable
    if (first_matching_but_unreadable_handle != 0u){
 801df00:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 801df02:	2b00      	cmp	r3, #0
 801df04:	d009      	beq.n	801df1a <handle_read_by_type_request2+0x20a>
        return setup_error_read_not_permitted(response_buffer, request_type, first_matching_but_unreadable_handle);        
 801df06:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801df0a:	b29b      	uxth	r3, r3
 801df0c:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 801df0e:	4619      	mov	r1, r3
 801df10:	68b8      	ldr	r0, [r7, #8]
 801df12:	f7ff fbdd 	bl	801d6d0 <setup_error_read_not_permitted>
 801df16:	4603      	mov	r3, r0
 801df18:	e008      	b.n	801df2c <handle_read_by_type_request2+0x21c>
    }

    // attribute not found
    return setup_error_atribute_not_found(response_buffer, request_type, start_handle);
 801df1a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801df1e:	b29b      	uxth	r3, r3
 801df20:	88ba      	ldrh	r2, [r7, #4]
 801df22:	4619      	mov	r1, r3
 801df24:	68b8      	ldr	r0, [r7, #8]
 801df26:	f7ff fbf9 	bl	801d71c <setup_error_atribute_not_found>
 801df2a:	4603      	mov	r3, r0
}
 801df2c:	4618      	mov	r0, r3
 801df2e:	3738      	adds	r7, #56	; 0x38
 801df30:	46bd      	mov	sp, r7
 801df32:	bd80      	pop	{r7, pc}
 801df34:	0802cb8c 	.word	0x0802cb8c
 801df38:	0802cd84 	.word	0x0802cd84

0801df3c <handle_read_by_type_request>:

static uint16_t handle_read_by_type_request(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len,
                                     uint8_t * response_buffer, uint16_t response_buffer_size){
 801df3c:	b580      	push	{r7, lr}
 801df3e:	b08a      	sub	sp, #40	; 0x28
 801df40:	af04      	add	r7, sp, #16
 801df42:	60f8      	str	r0, [r7, #12]
 801df44:	60b9      	str	r1, [r7, #8]
 801df46:	603b      	str	r3, [r7, #0]
 801df48:	4613      	mov	r3, r2
 801df4a:	80fb      	strh	r3, [r7, #6]

    uint16_t attribute_type_len;
    switch (request_len){
 801df4c:	88fb      	ldrh	r3, [r7, #6]
 801df4e:	2b07      	cmp	r3, #7
 801df50:	d002      	beq.n	801df58 <handle_read_by_type_request+0x1c>
 801df52:	2b15      	cmp	r3, #21
 801df54:	d003      	beq.n	801df5e <handle_read_by_type_request+0x22>
 801df56:	e005      	b.n	801df64 <handle_read_by_type_request+0x28>
        case 7:
            attribute_type_len = 2;
 801df58:	2302      	movs	r3, #2
 801df5a:	82fb      	strh	r3, [r7, #22]
            break;
 801df5c:	e008      	b.n	801df70 <handle_read_by_type_request+0x34>
        case 21:
            attribute_type_len = 16;
 801df5e:	2310      	movs	r3, #16
 801df60:	82fb      	strh	r3, [r7, #22]
            break;
 801df62:	e005      	b.n	801df70 <handle_read_by_type_request+0x34>
        default:
            return setup_error_invalid_pdu(response_buffer, ATT_READ_BY_TYPE_REQUEST);
 801df64:	2108      	movs	r1, #8
 801df66:	6838      	ldr	r0, [r7, #0]
 801df68:	f7ff fc11 	bl	801d78e <setup_error_invalid_pdu>
 801df6c:	4603      	mov	r3, r0
 801df6e:	e01a      	b.n	801dfa6 <handle_read_by_type_request+0x6a>
    }

    uint16_t start_handle = little_endian_read_16(request_buffer, 1);
 801df70:	2101      	movs	r1, #1
 801df72:	68b8      	ldr	r0, [r7, #8]
 801df74:	f7f0 ff37 	bl	800ede6 <little_endian_read_16>
 801df78:	4603      	mov	r3, r0
 801df7a:	82bb      	strh	r3, [r7, #20]
    uint16_t end_handle = little_endian_read_16(request_buffer, 3);
 801df7c:	2103      	movs	r1, #3
 801df7e:	68b8      	ldr	r0, [r7, #8]
 801df80:	f7f0 ff31 	bl	800ede6 <little_endian_read_16>
 801df84:	4603      	mov	r3, r0
 801df86:	827b      	strh	r3, [r7, #18]
    return handle_read_by_type_request2(att_connection, response_buffer, response_buffer_size, start_handle, end_handle, attribute_type_len, &request_buffer[5]);
 801df88:	68bb      	ldr	r3, [r7, #8]
 801df8a:	3305      	adds	r3, #5
 801df8c:	8ab9      	ldrh	r1, [r7, #20]
 801df8e:	8c3a      	ldrh	r2, [r7, #32]
 801df90:	9302      	str	r3, [sp, #8]
 801df92:	8afb      	ldrh	r3, [r7, #22]
 801df94:	9301      	str	r3, [sp, #4]
 801df96:	8a7b      	ldrh	r3, [r7, #18]
 801df98:	9300      	str	r3, [sp, #0]
 801df9a:	460b      	mov	r3, r1
 801df9c:	6839      	ldr	r1, [r7, #0]
 801df9e:	68f8      	ldr	r0, [r7, #12]
 801dfa0:	f7ff feb6 	bl	801dd10 <handle_read_by_type_request2>
 801dfa4:	4603      	mov	r3, r0
}
 801dfa6:	4618      	mov	r0, r3
 801dfa8:	3718      	adds	r7, #24
 801dfaa:	46bd      	mov	sp, r7
 801dfac:	bd80      	pop	{r7, pc}
	...

0801dfb0 <handle_read_request2>:

//
// MARK: ATT_READ_BY_TYPE_REQUEST
//
static uint16_t handle_read_request2(att_connection_t * att_connection, uint8_t * response_buffer, uint16_t response_buffer_size, uint16_t handle){
 801dfb0:	b580      	push	{r7, lr}
 801dfb2:	b090      	sub	sp, #64	; 0x40
 801dfb4:	af02      	add	r7, sp, #8
 801dfb6:	60f8      	str	r0, [r7, #12]
 801dfb8:	60b9      	str	r1, [r7, #8]
 801dfba:	4611      	mov	r1, r2
 801dfbc:	461a      	mov	r2, r3
 801dfbe:	460b      	mov	r3, r1
 801dfc0:	80fb      	strh	r3, [r7, #6]
 801dfc2:	4613      	mov	r3, r2
 801dfc4:	80bb      	strh	r3, [r7, #4]
    
    log_info("ATT_READ_REQUEST: handle %04x", handle);
 801dfc6:	88bb      	ldrh	r3, [r7, #4]
 801dfc8:	9300      	str	r3, [sp, #0]
 801dfca:	f240 2396 	movw	r3, #662	; 0x296
 801dfce:	4a3b      	ldr	r2, [pc, #236]	; (801e0bc <handle_read_request2+0x10c>)
 801dfd0:	493b      	ldr	r1, [pc, #236]	; (801e0c0 <handle_read_request2+0x110>)
 801dfd2:	2001      	movs	r0, #1
 801dfd4:	f7f9 fa34 	bl	8017440 <hci_dump_log>
    uint8_t request_type = ATT_READ_REQUEST;
 801dfd8:	230a      	movs	r3, #10
 801dfda:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    
    att_iterator_t it;
    int ok = att_find_handle(&it, handle);
 801dfde:	88ba      	ldrh	r2, [r7, #4]
 801dfe0:	f107 0310 	add.w	r3, r7, #16
 801dfe4:	4611      	mov	r1, r2
 801dfe6:	4618      	mov	r0, r3
 801dfe8:	f7ff fa42 	bl	801d470 <att_find_handle>
 801dfec:	6338      	str	r0, [r7, #48]	; 0x30
    if (!ok){
 801dfee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801dff0:	2b00      	cmp	r3, #0
 801dff2:	d109      	bne.n	801e008 <handle_read_request2+0x58>
        return setup_error_invalid_handle(response_buffer, request_type, handle);
 801dff4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801dff8:	b29b      	uxth	r3, r3
 801dffa:	88ba      	ldrh	r2, [r7, #4]
 801dffc:	4619      	mov	r1, r3
 801dffe:	68b8      	ldr	r0, [r7, #8]
 801e000:	f7ff fb9f 	bl	801d742 <setup_error_invalid_handle>
 801e004:	4603      	mov	r3, r0
 801e006:	e054      	b.n	801e0b2 <handle_read_request2+0x102>
    }
    
    // check if handle can be read
    if ((it.flags & ATT_PROPERTY_READ) == 0u) {
 801e008:	8afb      	ldrh	r3, [r7, #22]
 801e00a:	f003 0302 	and.w	r3, r3, #2
 801e00e:	2b00      	cmp	r3, #0
 801e010:	d109      	bne.n	801e026 <handle_read_request2+0x76>
        return setup_error_read_not_permitted(response_buffer, request_type, handle);
 801e012:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e016:	b29b      	uxth	r3, r3
 801e018:	88ba      	ldrh	r2, [r7, #4]
 801e01a:	4619      	mov	r1, r3
 801e01c:	68b8      	ldr	r0, [r7, #8]
 801e01e:	f7ff fb57 	bl	801d6d0 <setup_error_read_not_permitted>
 801e022:	4603      	mov	r3, r0
 801e024:	e045      	b.n	801e0b2 <handle_read_request2+0x102>
    }

    // check security requirements
    uint8_t error_code = att_validate_security(att_connection, ATT_READ, &it);
 801e026:	f107 0310 	add.w	r3, r7, #16
 801e02a:	461a      	mov	r2, r3
 801e02c:	2100      	movs	r1, #0
 801e02e:	68f8      	ldr	r0, [r7, #12]
 801e030:	f7ff fbbe 	bl	801d7b0 <att_validate_security>
 801e034:	4603      	mov	r3, r0
 801e036:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    if (error_code != 0) {
 801e03a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801e03e:	2b00      	cmp	r3, #0
 801e040:	d00a      	beq.n	801e058 <handle_read_request2+0xa8>
        return setup_error(response_buffer, request_type, handle, error_code);
 801e042:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e046:	b299      	uxth	r1, r3
 801e048:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801e04c:	88ba      	ldrh	r2, [r7, #4]
 801e04e:	68b8      	ldr	r0, [r7, #8]
 801e050:	f7ff fb1a 	bl	801d688 <setup_error>
 801e054:	4603      	mov	r3, r0
 801e056:	e02c      	b.n	801e0b2 <handle_read_request2+0x102>
    }

    att_update_value_len(&it, att_connection->con_handle);
 801e058:	68fb      	ldr	r3, [r7, #12]
 801e05a:	881a      	ldrh	r2, [r3, #0]
 801e05c:	f107 0310 	add.w	r3, r7, #16
 801e060:	4611      	mov	r1, r2
 801e062:	4618      	mov	r0, r3
 801e064:	f7ff fa2a 	bl	801d4bc <att_update_value_len>

#ifdef ENABLE_ATT_DELAYED_RESPONSE
    if (it.value_len == ATT_READ_RESPONSE_PENDING) return ATT_READ_RESPONSE_PENDING;
 801e068:	8c3b      	ldrh	r3, [r7, #32]
 801e06a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801e06e:	4293      	cmp	r3, r2
 801e070:	d102      	bne.n	801e078 <handle_read_request2+0xc8>
 801e072:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801e076:	e01c      	b.n	801e0b2 <handle_read_request2+0x102>
#endif

    // store
    uint16_t offset   = 1;
 801e078:	2301      	movs	r3, #1
 801e07a:	85bb      	strh	r3, [r7, #44]	; 0x2c
    uint16_t bytes_copied = att_copy_value(&it, 0, response_buffer + offset, response_buffer_size - offset, att_connection->con_handle);
 801e07c:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801e07e:	68ba      	ldr	r2, [r7, #8]
 801e080:	18d1      	adds	r1, r2, r3
 801e082:	88fa      	ldrh	r2, [r7, #6]
 801e084:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801e086:	1ad3      	subs	r3, r2, r3
 801e088:	b29a      	uxth	r2, r3
 801e08a:	68fb      	ldr	r3, [r7, #12]
 801e08c:	881b      	ldrh	r3, [r3, #0]
 801e08e:	f107 0010 	add.w	r0, r7, #16
 801e092:	9300      	str	r3, [sp, #0]
 801e094:	4613      	mov	r3, r2
 801e096:	460a      	mov	r2, r1
 801e098:	2100      	movs	r1, #0
 801e09a:	f7ff fa31 	bl	801d500 <att_copy_value>
 801e09e:	4603      	mov	r3, r0
 801e0a0:	857b      	strh	r3, [r7, #42]	; 0x2a
    offset += bytes_copied;
 801e0a2:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 801e0a4:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801e0a6:	4413      	add	r3, r2
 801e0a8:	85bb      	strh	r3, [r7, #44]	; 0x2c
    
    response_buffer[0] = ATT_READ_RESPONSE;
 801e0aa:	68bb      	ldr	r3, [r7, #8]
 801e0ac:	220b      	movs	r2, #11
 801e0ae:	701a      	strb	r2, [r3, #0]
    return offset;
 801e0b0:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
}
 801e0b2:	4618      	mov	r0, r3
 801e0b4:	3738      	adds	r7, #56	; 0x38
 801e0b6:	46bd      	mov	sp, r7
 801e0b8:	bd80      	pop	{r7, pc}
 801e0ba:	bf00      	nop
 801e0bc:	0802cb8c 	.word	0x0802cb8c
 801e0c0:	0802cdc0 	.word	0x0802cdc0

0801e0c4 <handle_read_request>:

static uint16_t handle_read_request(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len,
                             uint8_t * response_buffer, uint16_t response_buffer_size){
 801e0c4:	b580      	push	{r7, lr}
 801e0c6:	b086      	sub	sp, #24
 801e0c8:	af00      	add	r7, sp, #0
 801e0ca:	60f8      	str	r0, [r7, #12]
 801e0cc:	60b9      	str	r1, [r7, #8]
 801e0ce:	603b      	str	r3, [r7, #0]
 801e0d0:	4613      	mov	r3, r2
 801e0d2:	80fb      	strh	r3, [r7, #6]

    if (request_len != 3u) return setup_error_invalid_pdu(response_buffer, ATT_READ_REQUEST);
 801e0d4:	88fb      	ldrh	r3, [r7, #6]
 801e0d6:	2b03      	cmp	r3, #3
 801e0d8:	d005      	beq.n	801e0e6 <handle_read_request+0x22>
 801e0da:	210a      	movs	r1, #10
 801e0dc:	6838      	ldr	r0, [r7, #0]
 801e0de:	f7ff fb56 	bl	801d78e <setup_error_invalid_pdu>
 801e0e2:	4603      	mov	r3, r0
 801e0e4:	e00c      	b.n	801e100 <handle_read_request+0x3c>

    uint16_t handle = little_endian_read_16(request_buffer, 1);
 801e0e6:	2101      	movs	r1, #1
 801e0e8:	68b8      	ldr	r0, [r7, #8]
 801e0ea:	f7f0 fe7c 	bl	800ede6 <little_endian_read_16>
 801e0ee:	4603      	mov	r3, r0
 801e0f0:	82fb      	strh	r3, [r7, #22]
    return handle_read_request2(att_connection, response_buffer, response_buffer_size, handle);
 801e0f2:	8afb      	ldrh	r3, [r7, #22]
 801e0f4:	8c3a      	ldrh	r2, [r7, #32]
 801e0f6:	6839      	ldr	r1, [r7, #0]
 801e0f8:	68f8      	ldr	r0, [r7, #12]
 801e0fa:	f7ff ff59 	bl	801dfb0 <handle_read_request2>
 801e0fe:	4603      	mov	r3, r0
}
 801e100:	4618      	mov	r0, r3
 801e102:	3718      	adds	r7, #24
 801e104:	46bd      	mov	sp, r7
 801e106:	bd80      	pop	{r7, pc}

0801e108 <handle_read_blob_request2>:

//s
// MARK: ATT_READ_BLOB_REQUEST 0x0c
//
static uint16_t handle_read_blob_request2(att_connection_t * att_connection, uint8_t * response_buffer, uint16_t response_buffer_size, uint16_t handle, uint16_t value_offset){
 801e108:	b590      	push	{r4, r7, lr}
 801e10a:	b091      	sub	sp, #68	; 0x44
 801e10c:	af02      	add	r7, sp, #8
 801e10e:	60f8      	str	r0, [r7, #12]
 801e110:	60b9      	str	r1, [r7, #8]
 801e112:	4611      	mov	r1, r2
 801e114:	461a      	mov	r2, r3
 801e116:	460b      	mov	r3, r1
 801e118:	80fb      	strh	r3, [r7, #6]
 801e11a:	4613      	mov	r3, r2
 801e11c:	80bb      	strh	r3, [r7, #4]
    log_info("ATT_READ_BLOB_REQUEST: handle %04x, offset %u", handle, value_offset);
 801e11e:	88bb      	ldrh	r3, [r7, #4]
 801e120:	f8b7 2048 	ldrh.w	r2, [r7, #72]	; 0x48
 801e124:	9201      	str	r2, [sp, #4]
 801e126:	9300      	str	r3, [sp, #0]
 801e128:	f240 23c6 	movw	r3, #710	; 0x2c6
 801e12c:	4a45      	ldr	r2, [pc, #276]	; (801e244 <handle_read_blob_request2+0x13c>)
 801e12e:	4946      	ldr	r1, [pc, #280]	; (801e248 <handle_read_blob_request2+0x140>)
 801e130:	2001      	movs	r0, #1
 801e132:	f7f9 f985 	bl	8017440 <hci_dump_log>
    uint8_t request_type = ATT_READ_BLOB_REQUEST;
 801e136:	230c      	movs	r3, #12
 801e138:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35

    att_iterator_t it;
    int ok = att_find_handle(&it, handle);
 801e13c:	88ba      	ldrh	r2, [r7, #4]
 801e13e:	f107 0314 	add.w	r3, r7, #20
 801e142:	4611      	mov	r1, r2
 801e144:	4618      	mov	r0, r3
 801e146:	f7ff f993 	bl	801d470 <att_find_handle>
 801e14a:	6338      	str	r0, [r7, #48]	; 0x30
    if (!ok){
 801e14c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e14e:	2b00      	cmp	r3, #0
 801e150:	d109      	bne.n	801e166 <handle_read_blob_request2+0x5e>
        return setup_error_invalid_handle(response_buffer, request_type, handle);
 801e152:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
 801e156:	b29b      	uxth	r3, r3
 801e158:	88ba      	ldrh	r2, [r7, #4]
 801e15a:	4619      	mov	r1, r3
 801e15c:	68b8      	ldr	r0, [r7, #8]
 801e15e:	f7ff faf0 	bl	801d742 <setup_error_invalid_handle>
 801e162:	4603      	mov	r3, r0
 801e164:	e069      	b.n	801e23a <handle_read_blob_request2+0x132>
    }
    
    // check if handle can be read
    if ((it.flags & ATT_PROPERTY_READ) == 0u) {
 801e166:	8b7b      	ldrh	r3, [r7, #26]
 801e168:	f003 0302 	and.w	r3, r3, #2
 801e16c:	2b00      	cmp	r3, #0
 801e16e:	d109      	bne.n	801e184 <handle_read_blob_request2+0x7c>
        return setup_error_read_not_permitted(response_buffer, request_type, handle);
 801e170:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
 801e174:	b29b      	uxth	r3, r3
 801e176:	88ba      	ldrh	r2, [r7, #4]
 801e178:	4619      	mov	r1, r3
 801e17a:	68b8      	ldr	r0, [r7, #8]
 801e17c:	f7ff faa8 	bl	801d6d0 <setup_error_read_not_permitted>
 801e180:	4603      	mov	r3, r0
 801e182:	e05a      	b.n	801e23a <handle_read_blob_request2+0x132>
    }

    // check security requirements
    uint8_t error_code = att_validate_security(att_connection, ATT_READ, &it);
 801e184:	f107 0314 	add.w	r3, r7, #20
 801e188:	461a      	mov	r2, r3
 801e18a:	2100      	movs	r1, #0
 801e18c:	68f8      	ldr	r0, [r7, #12]
 801e18e:	f7ff fb0f 	bl	801d7b0 <att_validate_security>
 801e192:	4603      	mov	r3, r0
 801e194:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    if (error_code != 0) {
 801e198:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801e19c:	2b00      	cmp	r3, #0
 801e19e:	d00a      	beq.n	801e1b6 <handle_read_blob_request2+0xae>
        return setup_error(response_buffer, request_type, handle, error_code);
 801e1a0:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
 801e1a4:	b299      	uxth	r1, r3
 801e1a6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801e1aa:	88ba      	ldrh	r2, [r7, #4]
 801e1ac:	68b8      	ldr	r0, [r7, #8]
 801e1ae:	f7ff fa6b 	bl	801d688 <setup_error>
 801e1b2:	4603      	mov	r3, r0
 801e1b4:	e041      	b.n	801e23a <handle_read_blob_request2+0x132>
    }

    att_update_value_len(&it, att_connection->con_handle);
 801e1b6:	68fb      	ldr	r3, [r7, #12]
 801e1b8:	881a      	ldrh	r2, [r3, #0]
 801e1ba:	f107 0314 	add.w	r3, r7, #20
 801e1be:	4611      	mov	r1, r2
 801e1c0:	4618      	mov	r0, r3
 801e1c2:	f7ff f97b 	bl	801d4bc <att_update_value_len>

#ifdef ENABLE_ATT_DELAYED_RESPONSE
    if (it.value_len == ATT_READ_RESPONSE_PENDING) return ATT_READ_RESPONSE_PENDING;
 801e1c6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801e1c8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801e1cc:	4293      	cmp	r3, r2
 801e1ce:	d102      	bne.n	801e1d6 <handle_read_blob_request2+0xce>
 801e1d0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801e1d4:	e031      	b.n	801e23a <handle_read_blob_request2+0x132>
#endif

    if (value_offset > it.value_len){
 801e1d6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801e1d8:	f8b7 2048 	ldrh.w	r2, [r7, #72]	; 0x48
 801e1dc:	429a      	cmp	r2, r3
 801e1de:	d909      	bls.n	801e1f4 <handle_read_blob_request2+0xec>
        return setup_error_invalid_offset(response_buffer, request_type, handle);
 801e1e0:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
 801e1e4:	b29b      	uxth	r3, r3
 801e1e6:	88ba      	ldrh	r2, [r7, #4]
 801e1e8:	4619      	mov	r1, r3
 801e1ea:	68b8      	ldr	r0, [r7, #8]
 801e1ec:	f7ff fabc 	bl	801d768 <setup_error_invalid_offset>
 801e1f0:	4603      	mov	r3, r0
 801e1f2:	e022      	b.n	801e23a <handle_read_blob_request2+0x132>
    }

    // prepare response
    response_buffer[0] = ATT_READ_BLOB_RESPONSE;
 801e1f4:	68bb      	ldr	r3, [r7, #8]
 801e1f6:	220d      	movs	r2, #13
 801e1f8:	701a      	strb	r2, [r3, #0]
    uint16_t offset   = 1;
 801e1fa:	2301      	movs	r3, #1
 801e1fc:	86fb      	strh	r3, [r7, #54]	; 0x36

    // fetch more data if available
    if (value_offset < it.value_len){
 801e1fe:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801e200:	f8b7 2048 	ldrh.w	r2, [r7, #72]	; 0x48
 801e204:	429a      	cmp	r2, r3
 801e206:	d217      	bcs.n	801e238 <handle_read_blob_request2+0x130>
        uint16_t bytes_copied = att_copy_value(&it, value_offset, &response_buffer[offset], response_buffer_size - offset, att_connection->con_handle);
 801e208:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801e20a:	68ba      	ldr	r2, [r7, #8]
 801e20c:	18d4      	adds	r4, r2, r3
 801e20e:	88fa      	ldrh	r2, [r7, #6]
 801e210:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801e212:	1ad3      	subs	r3, r2, r3
 801e214:	b29a      	uxth	r2, r3
 801e216:	68fb      	ldr	r3, [r7, #12]
 801e218:	881b      	ldrh	r3, [r3, #0]
 801e21a:	f8b7 1048 	ldrh.w	r1, [r7, #72]	; 0x48
 801e21e:	f107 0014 	add.w	r0, r7, #20
 801e222:	9300      	str	r3, [sp, #0]
 801e224:	4613      	mov	r3, r2
 801e226:	4622      	mov	r2, r4
 801e228:	f7ff f96a 	bl	801d500 <att_copy_value>
 801e22c:	4603      	mov	r3, r0
 801e22e:	85bb      	strh	r3, [r7, #44]	; 0x2c
        offset += bytes_copied;
 801e230:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801e232:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801e234:	4413      	add	r3, r2
 801e236:	86fb      	strh	r3, [r7, #54]	; 0x36
    }
    return offset;
 801e238:	8efb      	ldrh	r3, [r7, #54]	; 0x36
}
 801e23a:	4618      	mov	r0, r3
 801e23c:	373c      	adds	r7, #60	; 0x3c
 801e23e:	46bd      	mov	sp, r7
 801e240:	bd90      	pop	{r4, r7, pc}
 801e242:	bf00      	nop
 801e244:	0802cb8c 	.word	0x0802cb8c
 801e248:	0802cde8 	.word	0x0802cde8

0801e24c <handle_read_blob_request>:

static uint16_t handle_read_blob_request(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len,
                                  uint8_t * response_buffer, uint16_t response_buffer_size){
 801e24c:	b580      	push	{r7, lr}
 801e24e:	b088      	sub	sp, #32
 801e250:	af02      	add	r7, sp, #8
 801e252:	60f8      	str	r0, [r7, #12]
 801e254:	60b9      	str	r1, [r7, #8]
 801e256:	603b      	str	r3, [r7, #0]
 801e258:	4613      	mov	r3, r2
 801e25a:	80fb      	strh	r3, [r7, #6]

    if (request_len != 5u) return setup_error_invalid_pdu(response_buffer, ATT_READ_BLOB_REQUEST);
 801e25c:	88fb      	ldrh	r3, [r7, #6]
 801e25e:	2b05      	cmp	r3, #5
 801e260:	d005      	beq.n	801e26e <handle_read_blob_request+0x22>
 801e262:	210c      	movs	r1, #12
 801e264:	6838      	ldr	r0, [r7, #0]
 801e266:	f7ff fa92 	bl	801d78e <setup_error_invalid_pdu>
 801e26a:	4603      	mov	r3, r0
 801e26c:	e015      	b.n	801e29a <handle_read_blob_request+0x4e>

    uint16_t handle = little_endian_read_16(request_buffer, 1);
 801e26e:	2101      	movs	r1, #1
 801e270:	68b8      	ldr	r0, [r7, #8]
 801e272:	f7f0 fdb8 	bl	800ede6 <little_endian_read_16>
 801e276:	4603      	mov	r3, r0
 801e278:	82fb      	strh	r3, [r7, #22]
    uint16_t value_offset = little_endian_read_16(request_buffer, 3);
 801e27a:	2103      	movs	r1, #3
 801e27c:	68b8      	ldr	r0, [r7, #8]
 801e27e:	f7f0 fdb2 	bl	800ede6 <little_endian_read_16>
 801e282:	4603      	mov	r3, r0
 801e284:	82bb      	strh	r3, [r7, #20]
    return handle_read_blob_request2(att_connection, response_buffer, response_buffer_size, handle, value_offset);
 801e286:	8af9      	ldrh	r1, [r7, #22]
 801e288:	8c3a      	ldrh	r2, [r7, #32]
 801e28a:	8abb      	ldrh	r3, [r7, #20]
 801e28c:	9300      	str	r3, [sp, #0]
 801e28e:	460b      	mov	r3, r1
 801e290:	6839      	ldr	r1, [r7, #0]
 801e292:	68f8      	ldr	r0, [r7, #12]
 801e294:	f7ff ff38 	bl	801e108 <handle_read_blob_request2>
 801e298:	4603      	mov	r3, r0
}
 801e29a:	4618      	mov	r0, r3
 801e29c:	3718      	adds	r7, #24
 801e29e:	46bd      	mov	sp, r7
 801e2a0:	bd80      	pop	{r7, pc}
	...

0801e2a4 <handle_read_multiple_request2>:

//
// MARK: ATT_READ_MULTIPLE_REQUEST 0x0e
//
static uint16_t handle_read_multiple_request2(att_connection_t * att_connection, uint8_t * response_buffer, uint16_t response_buffer_size, uint16_t num_handles, uint8_t * handles){
 801e2a4:	b580      	push	{r7, lr}
 801e2a6:	b092      	sub	sp, #72	; 0x48
 801e2a8:	af02      	add	r7, sp, #8
 801e2aa:	60f8      	str	r0, [r7, #12]
 801e2ac:	60b9      	str	r1, [r7, #8]
 801e2ae:	4611      	mov	r1, r2
 801e2b0:	461a      	mov	r2, r3
 801e2b2:	460b      	mov	r3, r1
 801e2b4:	80fb      	strh	r3, [r7, #6]
 801e2b6:	4613      	mov	r3, r2
 801e2b8:	80bb      	strh	r3, [r7, #4]
    log_info("ATT_READ_MULTIPLE_REQUEST: num handles %u", num_handles);
 801e2ba:	88bb      	ldrh	r3, [r7, #4]
 801e2bc:	9300      	str	r3, [sp, #0]
 801e2be:	f240 23fe 	movw	r3, #766	; 0x2fe
 801e2c2:	4a51      	ldr	r2, [pc, #324]	; (801e408 <handle_read_multiple_request2+0x164>)
 801e2c4:	4951      	ldr	r1, [pc, #324]	; (801e40c <handle_read_multiple_request2+0x168>)
 801e2c6:	2001      	movs	r0, #1
 801e2c8:	f7f9 f8ba 	bl	8017440 <hci_dump_log>
    uint8_t request_type = ATT_READ_MULTIPLE_REQUEST;
 801e2cc:	230e      	movs	r3, #14
 801e2ce:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
    
    uint16_t offset   = 1;
 801e2d2:	2301      	movs	r3, #1
 801e2d4:	87fb      	strh	r3, [r7, #62]	; 0x3e

    int i;
    uint8_t error_code = 0;
 801e2d6:	2300      	movs	r3, #0
 801e2d8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    uint16_t handle = 0;
 801e2dc:	2300      	movs	r3, #0
 801e2de:	86bb      	strh	r3, [r7, #52]	; 0x34

#ifdef ENABLE_ATT_DELAYED_RESPONSE
    bool read_request_pending = false;
 801e2e0:	2300      	movs	r3, #0
 801e2e2:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
#endif

    for (i=0;i<num_handles;i++){
 801e2e6:	2300      	movs	r3, #0
 801e2e8:	63bb      	str	r3, [r7, #56]	; 0x38
 801e2ea:	e070      	b.n	801e3ce <handle_read_multiple_request2+0x12a>
        handle = little_endian_read_16(handles, i << 1);
 801e2ec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e2ee:	005b      	lsls	r3, r3, #1
 801e2f0:	4619      	mov	r1, r3
 801e2f2:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 801e2f4:	f7f0 fd77 	bl	800ede6 <little_endian_read_16>
 801e2f8:	4603      	mov	r3, r0
 801e2fa:	86bb      	strh	r3, [r7, #52]	; 0x34
        
        if (handle == 0u){
 801e2fc:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 801e2fe:	2b00      	cmp	r3, #0
 801e300:	d109      	bne.n	801e316 <handle_read_multiple_request2+0x72>
            return setup_error_invalid_handle(response_buffer, request_type, handle);
 801e302:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 801e306:	b29b      	uxth	r3, r3
 801e308:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e30a:	4619      	mov	r1, r3
 801e30c:	68b8      	ldr	r0, [r7, #8]
 801e30e:	f7ff fa18 	bl	801d742 <setup_error_invalid_handle>
 801e312:	4603      	mov	r3, r0
 801e314:	e074      	b.n	801e400 <handle_read_multiple_request2+0x15c>
        }
        
        att_iterator_t it;

        int ok = att_find_handle(&it, handle);
 801e316:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e318:	f107 0310 	add.w	r3, r7, #16
 801e31c:	4611      	mov	r1, r2
 801e31e:	4618      	mov	r0, r3
 801e320:	f7ff f8a6 	bl	801d470 <att_find_handle>
 801e324:	62f8      	str	r0, [r7, #44]	; 0x2c
        if (!ok){
 801e326:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e328:	2b00      	cmp	r3, #0
 801e32a:	d109      	bne.n	801e340 <handle_read_multiple_request2+0x9c>
            return setup_error_invalid_handle(response_buffer, request_type, handle);
 801e32c:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 801e330:	b29b      	uxth	r3, r3
 801e332:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e334:	4619      	mov	r1, r3
 801e336:	68b8      	ldr	r0, [r7, #8]
 801e338:	f7ff fa03 	bl	801d742 <setup_error_invalid_handle>
 801e33c:	4603      	mov	r3, r0
 801e33e:	e05f      	b.n	801e400 <handle_read_multiple_request2+0x15c>
        }

        // check if handle can be read
        if ((it.flags & ATT_PROPERTY_READ) == 0u) {
 801e340:	8afb      	ldrh	r3, [r7, #22]
 801e342:	f003 0302 	and.w	r3, r3, #2
 801e346:	2b00      	cmp	r3, #0
 801e348:	d103      	bne.n	801e352 <handle_read_multiple_request2+0xae>
            error_code = ATT_ERROR_READ_NOT_PERMITTED;
 801e34a:	2302      	movs	r3, #2
 801e34c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
            break;
 801e350:	e043      	b.n	801e3da <handle_read_multiple_request2+0x136>
        }

        // check security requirements
        error_code = att_validate_security(att_connection, ATT_READ, &it);
 801e352:	f107 0310 	add.w	r3, r7, #16
 801e356:	461a      	mov	r2, r3
 801e358:	2100      	movs	r1, #0
 801e35a:	68f8      	ldr	r0, [r7, #12]
 801e35c:	f7ff fa28 	bl	801d7b0 <att_validate_security>
 801e360:	4603      	mov	r3, r0
 801e362:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        if (error_code != 0) break;
 801e366:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e36a:	2b00      	cmp	r3, #0
 801e36c:	d134      	bne.n	801e3d8 <handle_read_multiple_request2+0x134>

        att_update_value_len(&it, att_connection->con_handle);
 801e36e:	68fb      	ldr	r3, [r7, #12]
 801e370:	881a      	ldrh	r2, [r3, #0]
 801e372:	f107 0310 	add.w	r3, r7, #16
 801e376:	4611      	mov	r1, r2
 801e378:	4618      	mov	r0, r3
 801e37a:	f7ff f89f 	bl	801d4bc <att_update_value_len>
        
#ifdef ENABLE_ATT_DELAYED_RESPONSE
        if (it.value_len == ATT_READ_RESPONSE_PENDING) {
 801e37e:	8c3b      	ldrh	r3, [r7, #32]
 801e380:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801e384:	4293      	cmp	r3, r2
 801e386:	d102      	bne.n	801e38e <handle_read_multiple_request2+0xea>
            read_request_pending = true;
 801e388:	2301      	movs	r3, #1
 801e38a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
        }
        if (read_request_pending) continue;
 801e38e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801e392:	2b00      	cmp	r3, #0
 801e394:	d117      	bne.n	801e3c6 <handle_read_multiple_request2+0x122>
#endif

        // store
        uint16_t bytes_copied = att_copy_value(&it, 0, response_buffer + offset, response_buffer_size - offset, att_connection->con_handle);
 801e396:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e398:	68ba      	ldr	r2, [r7, #8]
 801e39a:	18d1      	adds	r1, r2, r3
 801e39c:	88fa      	ldrh	r2, [r7, #6]
 801e39e:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e3a0:	1ad3      	subs	r3, r2, r3
 801e3a2:	b29a      	uxth	r2, r3
 801e3a4:	68fb      	ldr	r3, [r7, #12]
 801e3a6:	881b      	ldrh	r3, [r3, #0]
 801e3a8:	f107 0010 	add.w	r0, r7, #16
 801e3ac:	9300      	str	r3, [sp, #0]
 801e3ae:	4613      	mov	r3, r2
 801e3b0:	460a      	mov	r2, r1
 801e3b2:	2100      	movs	r1, #0
 801e3b4:	f7ff f8a4 	bl	801d500 <att_copy_value>
 801e3b8:	4603      	mov	r3, r0
 801e3ba:	857b      	strh	r3, [r7, #42]	; 0x2a
        offset += bytes_copied;
 801e3bc:	8ffa      	ldrh	r2, [r7, #62]	; 0x3e
 801e3be:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801e3c0:	4413      	add	r3, r2
 801e3c2:	87fb      	strh	r3, [r7, #62]	; 0x3e
 801e3c4:	e000      	b.n	801e3c8 <handle_read_multiple_request2+0x124>
        if (read_request_pending) continue;
 801e3c6:	bf00      	nop
    for (i=0;i<num_handles;i++){
 801e3c8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e3ca:	3301      	adds	r3, #1
 801e3cc:	63bb      	str	r3, [r7, #56]	; 0x38
 801e3ce:	88bb      	ldrh	r3, [r7, #4]
 801e3d0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801e3d2:	429a      	cmp	r2, r3
 801e3d4:	db8a      	blt.n	801e2ec <handle_read_multiple_request2+0x48>
 801e3d6:	e000      	b.n	801e3da <handle_read_multiple_request2+0x136>
        if (error_code != 0) break;
 801e3d8:	bf00      	nop
    }

    if (error_code != 0){
 801e3da:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e3de:	2b00      	cmp	r3, #0
 801e3e0:	d00a      	beq.n	801e3f8 <handle_read_multiple_request2+0x154>
        return setup_error(response_buffer, request_type, handle, error_code);
 801e3e2:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 801e3e6:	b299      	uxth	r1, r3
 801e3e8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e3ec:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e3ee:	68b8      	ldr	r0, [r7, #8]
 801e3f0:	f7ff f94a 	bl	801d688 <setup_error>
 801e3f4:	4603      	mov	r3, r0
 801e3f6:	e003      	b.n	801e400 <handle_read_multiple_request2+0x15c>
    }
    
    response_buffer[0] = ATT_READ_MULTIPLE_RESPONSE;
 801e3f8:	68bb      	ldr	r3, [r7, #8]
 801e3fa:	220f      	movs	r2, #15
 801e3fc:	701a      	strb	r2, [r3, #0]
    return offset;
 801e3fe:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
}
 801e400:	4618      	mov	r0, r3
 801e402:	3740      	adds	r7, #64	; 0x40
 801e404:	46bd      	mov	sp, r7
 801e406:	bd80      	pop	{r7, pc}
 801e408:	0802cb8c 	.word	0x0802cb8c
 801e40c:	0802ce20 	.word	0x0802ce20

0801e410 <handle_read_multiple_request>:
static uint16_t handle_read_multiple_request(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len,
                                      uint8_t * response_buffer, uint16_t response_buffer_size){
 801e410:	b580      	push	{r7, lr}
 801e412:	b088      	sub	sp, #32
 801e414:	af02      	add	r7, sp, #8
 801e416:	60f8      	str	r0, [r7, #12]
 801e418:	60b9      	str	r1, [r7, #8]
 801e41a:	603b      	str	r3, [r7, #0]
 801e41c:	4613      	mov	r3, r2
 801e41e:	80fb      	strh	r3, [r7, #6]

    // 1 byte opcode + two or more attribute handles (2 bytes each)
    if ( (request_len < 5u) || ((request_len & 1u) == 0u) ) return setup_error_invalid_pdu(response_buffer,
 801e420:	88fb      	ldrh	r3, [r7, #6]
 801e422:	2b04      	cmp	r3, #4
 801e424:	d904      	bls.n	801e430 <handle_read_multiple_request+0x20>
 801e426:	88fb      	ldrh	r3, [r7, #6]
 801e428:	f003 0301 	and.w	r3, r3, #1
 801e42c:	2b00      	cmp	r3, #0
 801e42e:	d105      	bne.n	801e43c <handle_read_multiple_request+0x2c>
 801e430:	210e      	movs	r1, #14
 801e432:	6838      	ldr	r0, [r7, #0]
 801e434:	f7ff f9ab 	bl	801d78e <setup_error_invalid_pdu>
 801e438:	4603      	mov	r3, r0
 801e43a:	e00f      	b.n	801e45c <handle_read_multiple_request+0x4c>
                                                                                        ATT_READ_MULTIPLE_REQUEST);

    int num_handles = (request_len - 1u) >> 1u;
 801e43c:	88fb      	ldrh	r3, [r7, #6]
 801e43e:	3b01      	subs	r3, #1
 801e440:	085b      	lsrs	r3, r3, #1
 801e442:	617b      	str	r3, [r7, #20]
    return handle_read_multiple_request2(att_connection, response_buffer, response_buffer_size, num_handles, &request_buffer[1]);
 801e444:	697b      	ldr	r3, [r7, #20]
 801e446:	b299      	uxth	r1, r3
 801e448:	68bb      	ldr	r3, [r7, #8]
 801e44a:	3301      	adds	r3, #1
 801e44c:	8c3a      	ldrh	r2, [r7, #32]
 801e44e:	9300      	str	r3, [sp, #0]
 801e450:	460b      	mov	r3, r1
 801e452:	6839      	ldr	r1, [r7, #0]
 801e454:	68f8      	ldr	r0, [r7, #12]
 801e456:	f7ff ff25 	bl	801e2a4 <handle_read_multiple_request2>
 801e45a:	4603      	mov	r3, r0
}
 801e45c:	4618      	mov	r0, r3
 801e45e:	3718      	adds	r7, #24
 801e460:	46bd      	mov	sp, r7
 801e462:	bd80      	pop	{r7, pc}

0801e464 <handle_read_by_group_type_request2>:
//  confidential information, and therefore the Service and Characteristic Discovery procedures
//  shall always be permitted. " 
//
static uint16_t handle_read_by_group_type_request2(att_connection_t * att_connection, uint8_t * response_buffer, uint16_t response_buffer_size,
                                            uint16_t start_handle, uint16_t end_handle,
                                            uint16_t attribute_type_len, uint8_t * attribute_type){
 801e464:	b580      	push	{r7, lr}
 801e466:	b094      	sub	sp, #80	; 0x50
 801e468:	af04      	add	r7, sp, #16
 801e46a:	60f8      	str	r0, [r7, #12]
 801e46c:	60b9      	str	r1, [r7, #8]
 801e46e:	4611      	mov	r1, r2
 801e470:	461a      	mov	r2, r3
 801e472:	460b      	mov	r3, r1
 801e474:	80fb      	strh	r3, [r7, #6]
 801e476:	4613      	mov	r3, r2
 801e478:	80bb      	strh	r3, [r7, #4]
    
    UNUSED(att_connection);

    log_info("ATT_READ_BY_GROUP_TYPE_REQUEST: from %04X to %04X, buffer size %u, type: ", start_handle, end_handle, response_buffer_size);
 801e47a:	88bb      	ldrh	r3, [r7, #4]
 801e47c:	f8b7 2048 	ldrh.w	r2, [r7, #72]	; 0x48
 801e480:	88f9      	ldrh	r1, [r7, #6]
 801e482:	9102      	str	r1, [sp, #8]
 801e484:	9201      	str	r2, [sp, #4]
 801e486:	9300      	str	r3, [sp, #0]
 801e488:	f240 3359 	movw	r3, #857	; 0x359
 801e48c:	4a79      	ldr	r2, [pc, #484]	; (801e674 <handle_read_by_group_type_request2+0x210>)
 801e48e:	497a      	ldr	r1, [pc, #488]	; (801e678 <handle_read_by_group_type_request2+0x214>)
 801e490:	2001      	movs	r0, #1
 801e492:	f7f8 ffd5 	bl	8017440 <hci_dump_log>
    log_info_hexdump(attribute_type, attribute_type_len);
 801e496:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 801e49a:	4619      	mov	r1, r3
 801e49c:	6d38      	ldr	r0, [r7, #80]	; 0x50
 801e49e:	f7f0 ff5b 	bl	800f358 <log_info_hexdump>
    uint8_t request_type = ATT_READ_BY_GROUP_TYPE_REQUEST;
 801e4a2:	2310      	movs	r3, #16
 801e4a4:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
    
    if ((start_handle > end_handle) || (start_handle == 0u)){
 801e4a8:	88ba      	ldrh	r2, [r7, #4]
 801e4aa:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 801e4ae:	429a      	cmp	r2, r3
 801e4b0:	d802      	bhi.n	801e4b8 <handle_read_by_group_type_request2+0x54>
 801e4b2:	88bb      	ldrh	r3, [r7, #4]
 801e4b4:	2b00      	cmp	r3, #0
 801e4b6:	d109      	bne.n	801e4cc <handle_read_by_group_type_request2+0x68>
        return setup_error_invalid_handle(response_buffer, request_type, start_handle);
 801e4b8:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 801e4bc:	b29b      	uxth	r3, r3
 801e4be:	88ba      	ldrh	r2, [r7, #4]
 801e4c0:	4619      	mov	r1, r3
 801e4c2:	68b8      	ldr	r0, [r7, #8]
 801e4c4:	f7ff f93d 	bl	801d742 <setup_error_invalid_handle>
 801e4c8:	4603      	mov	r3, r0
 801e4ca:	e0cf      	b.n	801e66c <handle_read_by_group_type_request2+0x208>
    }

    // assert UUID is primary or secondary service uuid
    uint16_t uuid16 = uuid16_from_uuid(attribute_type_len, attribute_type);
 801e4cc:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 801e4d0:	6d39      	ldr	r1, [r7, #80]	; 0x50
 801e4d2:	4618      	mov	r0, r3
 801e4d4:	f7fe fe9a 	bl	801d20c <uuid16_from_uuid>
 801e4d8:	4603      	mov	r3, r0
 801e4da:	85fb      	strh	r3, [r7, #46]	; 0x2e
    if ((uuid16 != GATT_PRIMARY_SERVICE_UUID) && (uuid16 != GATT_SECONDARY_SERVICE_UUID)){
 801e4dc:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801e4de:	f5b3 5f20 	cmp.w	r3, #10240	; 0x2800
 801e4e2:	d00e      	beq.n	801e502 <handle_read_by_group_type_request2+0x9e>
 801e4e4:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801e4e6:	f642 0201 	movw	r2, #10241	; 0x2801
 801e4ea:	4293      	cmp	r3, r2
 801e4ec:	d009      	beq.n	801e502 <handle_read_by_group_type_request2+0x9e>
        return setup_error(response_buffer, request_type, start_handle, ATT_ERROR_UNSUPPORTED_GROUP_TYPE);
 801e4ee:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 801e4f2:	b299      	uxth	r1, r3
 801e4f4:	88ba      	ldrh	r2, [r7, #4]
 801e4f6:	2310      	movs	r3, #16
 801e4f8:	68b8      	ldr	r0, [r7, #8]
 801e4fa:	f7ff f8c5 	bl	801d688 <setup_error>
 801e4fe:	4603      	mov	r3, r0
 801e500:	e0b4      	b.n	801e66c <handle_read_by_group_type_request2+0x208>
    }

    uint16_t offset   = 1;
 801e502:	2301      	movs	r3, #1
 801e504:	87fb      	strh	r3, [r7, #62]	; 0x3e
    uint16_t pair_len = 0;
 801e506:	2300      	movs	r3, #0
 801e508:	87bb      	strh	r3, [r7, #60]	; 0x3c
    uint16_t in_group = 0;
 801e50a:	2300      	movs	r3, #0
 801e50c:	877b      	strh	r3, [r7, #58]	; 0x3a
    uint16_t group_start_handle = 0;
 801e50e:	2300      	movs	r3, #0
 801e510:	873b      	strh	r3, [r7, #56]	; 0x38
    uint8_t const * group_start_value = NULL;
 801e512:	2300      	movs	r3, #0
 801e514:	637b      	str	r3, [r7, #52]	; 0x34
    uint16_t prev_handle = 0;
 801e516:	2300      	movs	r3, #0
 801e518:	867b      	strh	r3, [r7, #50]	; 0x32

    att_iterator_t it;
    att_iterator_init(&it);
 801e51a:	f107 0314 	add.w	r3, r7, #20
 801e51e:	4618      	mov	r0, r3
 801e520:	f7fe fe94 	bl	801d24c <att_iterator_init>
    while (att_iterator_has_next(&it)){
 801e524:	e082      	b.n	801e62c <handle_read_by_group_type_request2+0x1c8>
        att_iterator_fetch_next(&it);
 801e526:	f107 0314 	add.w	r3, r7, #20
 801e52a:	4618      	mov	r0, r3
 801e52c:	f7fe feaf 	bl	801d28e <att_iterator_fetch_next>
        
        if (it.handle && (it.handle < start_handle)) continue;
 801e530:	8bbb      	ldrh	r3, [r7, #28]
 801e532:	2b00      	cmp	r3, #0
 801e534:	d004      	beq.n	801e540 <handle_read_by_group_type_request2+0xdc>
 801e536:	8bbb      	ldrh	r3, [r7, #28]
 801e538:	88ba      	ldrh	r2, [r7, #4]
 801e53a:	429a      	cmp	r2, r3
 801e53c:	d900      	bls.n	801e540 <handle_read_by_group_type_request2+0xdc>
 801e53e:	e075      	b.n	801e62c <handle_read_by_group_type_request2+0x1c8>
        if (it.handle > end_handle) break;  // (1)
 801e540:	8bbb      	ldrh	r3, [r7, #28]
 801e542:	f8b7 2048 	ldrh.w	r2, [r7, #72]	; 0x48
 801e546:	429a      	cmp	r2, r3
 801e548:	d37a      	bcc.n	801e640 <handle_read_by_group_type_request2+0x1dc>

        // log_info("Handle 0x%04x", it.handle);
        
        // close current tag, if within a group and a new service definition starts or we reach end of att db
        if (in_group &&
 801e54a:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801e54c:	2b00      	cmp	r3, #0
 801e54e:	d03f      	beq.n	801e5d0 <handle_read_by_group_type_request2+0x16c>
            ((it.handle == 0u) || att_iterator_match_uuid16(&it, GATT_PRIMARY_SERVICE_UUID) || att_iterator_match_uuid16(&it, GATT_SECONDARY_SERVICE_UUID))){
 801e550:	8bbb      	ldrh	r3, [r7, #28]
        if (in_group &&
 801e552:	2b00      	cmp	r3, #0
 801e554:	d013      	beq.n	801e57e <handle_read_by_group_type_request2+0x11a>
            ((it.handle == 0u) || att_iterator_match_uuid16(&it, GATT_PRIMARY_SERVICE_UUID) || att_iterator_match_uuid16(&it, GATT_SECONDARY_SERVICE_UUID))){
 801e556:	f107 0314 	add.w	r3, r7, #20
 801e55a:	f44f 5120 	mov.w	r1, #10240	; 0x2800
 801e55e:	4618      	mov	r0, r3
 801e560:	f7fe fefc 	bl	801d35c <att_iterator_match_uuid16>
 801e564:	4603      	mov	r3, r0
 801e566:	2b00      	cmp	r3, #0
 801e568:	d109      	bne.n	801e57e <handle_read_by_group_type_request2+0x11a>
 801e56a:	f107 0314 	add.w	r3, r7, #20
 801e56e:	f642 0101 	movw	r1, #10241	; 0x2801
 801e572:	4618      	mov	r0, r3
 801e574:	f7fe fef2 	bl	801d35c <att_iterator_match_uuid16>
 801e578:	4603      	mov	r3, r0
 801e57a:	2b00      	cmp	r3, #0
 801e57c:	d028      	beq.n	801e5d0 <handle_read_by_group_type_request2+0x16c>
            // log_info("End of group, handle 0x%04x, val_len: %u", prev_handle, pair_len - 4);
            
            little_endian_store_16(response_buffer, offset, group_start_handle);
 801e57e:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801e580:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e582:	4619      	mov	r1, r3
 801e584:	68b8      	ldr	r0, [r7, #8]
 801e586:	f7f0 fc6e 	bl	800ee66 <little_endian_store_16>
            offset += 2u;
 801e58a:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e58c:	3302      	adds	r3, #2
 801e58e:	87fb      	strh	r3, [r7, #62]	; 0x3e
            little_endian_store_16(response_buffer, offset, prev_handle);
 801e590:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
 801e592:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e594:	4619      	mov	r1, r3
 801e596:	68b8      	ldr	r0, [r7, #8]
 801e598:	f7f0 fc65 	bl	800ee66 <little_endian_store_16>
            offset += 2u;
 801e59c:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e59e:	3302      	adds	r3, #2
 801e5a0:	87fb      	strh	r3, [r7, #62]	; 0x3e
            (void)memcpy(response_buffer + offset, group_start_value,
 801e5a2:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e5a4:	68ba      	ldr	r2, [r7, #8]
 801e5a6:	18d0      	adds	r0, r2, r3
 801e5a8:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 801e5aa:	3b04      	subs	r3, #4
 801e5ac:	461a      	mov	r2, r3
 801e5ae:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801e5b0:	f009 fa63 	bl	8027a7a <memcpy>
                         pair_len - 4u);
            offset += pair_len - 4u;
 801e5b4:	8ffa      	ldrh	r2, [r7, #62]	; 0x3e
 801e5b6:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 801e5b8:	4413      	add	r3, r2
 801e5ba:	b29b      	uxth	r3, r3
 801e5bc:	3b04      	subs	r3, #4
 801e5be:	87fb      	strh	r3, [r7, #62]	; 0x3e
            in_group = 0;
 801e5c0:	2300      	movs	r3, #0
 801e5c2:	877b      	strh	r3, [r7, #58]	; 0x3a
            
            // check if space for another handle pair available
            if ((offset + pair_len) > response_buffer_size){
 801e5c4:	8ffa      	ldrh	r2, [r7, #62]	; 0x3e
 801e5c6:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 801e5c8:	441a      	add	r2, r3
 801e5ca:	88fb      	ldrh	r3, [r7, #6]
 801e5cc:	429a      	cmp	r2, r3
 801e5ce:	dc39      	bgt.n	801e644 <handle_read_by_group_type_request2+0x1e0>
                break;
            }
        }
        
        // keep track of previous handle
        prev_handle = it.handle;
 801e5d0:	8bbb      	ldrh	r3, [r7, #28]
 801e5d2:	867b      	strh	r3, [r7, #50]	; 0x32
        
        // does current attribute match
        // log_info("compare: %04x == %04x", *(uint16_t*) context->attribute_type, *(uint16_t*) uuid);
        if (it.handle && att_iterator_match_uuid(&it, attribute_type, attribute_type_len)) {
 801e5d4:	8bbb      	ldrh	r3, [r7, #28]
 801e5d6:	2b00      	cmp	r3, #0
 801e5d8:	d028      	beq.n	801e62c <handle_read_by_group_type_request2+0x1c8>
 801e5da:	f8b7 204c 	ldrh.w	r2, [r7, #76]	; 0x4c
 801e5de:	f107 0314 	add.w	r3, r7, #20
 801e5e2:	6d39      	ldr	r1, [r7, #80]	; 0x50
 801e5e4:	4618      	mov	r0, r3
 801e5e6:	f7fe fef6 	bl	801d3d6 <att_iterator_match_uuid>
 801e5ea:	4603      	mov	r3, r0
 801e5ec:	2b00      	cmp	r3, #0
 801e5ee:	d01d      	beq.n	801e62c <handle_read_by_group_type_request2+0x1c8>
            
            // check if value has same len as last one
            uint16_t this_pair_len = 4u + it.value_len;
 801e5f0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801e5f2:	3304      	adds	r3, #4
 801e5f4:	85bb      	strh	r3, [r7, #44]	; 0x2c
            if (offset > 1u){
 801e5f6:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e5f8:	2b01      	cmp	r3, #1
 801e5fa:	d903      	bls.n	801e604 <handle_read_by_group_type_request2+0x1a0>
                if (this_pair_len != pair_len) {
 801e5fc:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 801e5fe:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 801e600:	429a      	cmp	r2, r3
 801e602:	d121      	bne.n	801e648 <handle_read_by_group_type_request2+0x1e4>
            }
            
            // log_info("Begin of group, handle 0x%04x", it.handle);
            
            // first
            if (offset == 1u) {
 801e604:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e606:	2b01      	cmp	r3, #1
 801e608:	d10a      	bne.n	801e620 <handle_read_by_group_type_request2+0x1bc>
                pair_len = this_pair_len;
 801e60a:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801e60c:	87bb      	strh	r3, [r7, #60]	; 0x3c
                response_buffer[offset] = this_pair_len;
 801e60e:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e610:	68ba      	ldr	r2, [r7, #8]
 801e612:	4413      	add	r3, r2
 801e614:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 801e616:	b2d2      	uxtb	r2, r2
 801e618:	701a      	strb	r2, [r3, #0]
                offset++;
 801e61a:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e61c:	3301      	adds	r3, #1
 801e61e:	87fb      	strh	r3, [r7, #62]	; 0x3e
            }
            
            group_start_handle = it.handle;
 801e620:	8bbb      	ldrh	r3, [r7, #28]
 801e622:	873b      	strh	r3, [r7, #56]	; 0x38
            group_start_value  = it.value;
 801e624:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e626:	637b      	str	r3, [r7, #52]	; 0x34
            in_group = 1;
 801e628:	2301      	movs	r3, #1
 801e62a:	877b      	strh	r3, [r7, #58]	; 0x3a
    while (att_iterator_has_next(&it)){
 801e62c:	f107 0314 	add.w	r3, r7, #20
 801e630:	4618      	mov	r0, r3
 801e632:	f7fe fe1b 	bl	801d26c <att_iterator_has_next>
 801e636:	4603      	mov	r3, r0
 801e638:	2b00      	cmp	r3, #0
 801e63a:	f47f af74 	bne.w	801e526 <handle_read_by_group_type_request2+0xc2>
 801e63e:	e004      	b.n	801e64a <handle_read_by_group_type_request2+0x1e6>
        if (it.handle > end_handle) break;  // (1)
 801e640:	bf00      	nop
 801e642:	e002      	b.n	801e64a <handle_read_by_group_type_request2+0x1e6>
                break;
 801e644:	bf00      	nop
 801e646:	e000      	b.n	801e64a <handle_read_by_group_type_request2+0x1e6>
                    break;
 801e648:	bf00      	nop
        }
    }        
    
    if (offset == 1u){
 801e64a:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801e64c:	2b01      	cmp	r3, #1
 801e64e:	d109      	bne.n	801e664 <handle_read_by_group_type_request2+0x200>
        return setup_error_atribute_not_found(response_buffer, request_type, start_handle);
 801e650:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 801e654:	b29b      	uxth	r3, r3
 801e656:	88ba      	ldrh	r2, [r7, #4]
 801e658:	4619      	mov	r1, r3
 801e65a:	68b8      	ldr	r0, [r7, #8]
 801e65c:	f7ff f85e 	bl	801d71c <setup_error_atribute_not_found>
 801e660:	4603      	mov	r3, r0
 801e662:	e003      	b.n	801e66c <handle_read_by_group_type_request2+0x208>
    }
    
    response_buffer[0] = ATT_READ_BY_GROUP_TYPE_RESPONSE;
 801e664:	68bb      	ldr	r3, [r7, #8]
 801e666:	2211      	movs	r2, #17
 801e668:	701a      	strb	r2, [r3, #0]
    return offset;
 801e66a:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
}
 801e66c:	4618      	mov	r0, r3
 801e66e:	3740      	adds	r7, #64	; 0x40
 801e670:	46bd      	mov	sp, r7
 801e672:	bd80      	pop	{r7, pc}
 801e674:	0802cb8c 	.word	0x0802cb8c
 801e678:	0802ce54 	.word	0x0802ce54

0801e67c <handle_read_by_group_type_request>:
static uint16_t handle_read_by_group_type_request(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len,
                                           uint8_t * response_buffer, uint16_t response_buffer_size){
 801e67c:	b580      	push	{r7, lr}
 801e67e:	b08a      	sub	sp, #40	; 0x28
 801e680:	af04      	add	r7, sp, #16
 801e682:	60f8      	str	r0, [r7, #12]
 801e684:	60b9      	str	r1, [r7, #8]
 801e686:	603b      	str	r3, [r7, #0]
 801e688:	4613      	mov	r3, r2
 801e68a:	80fb      	strh	r3, [r7, #6]
    uint16_t attribute_type_len;
    switch (request_len){
 801e68c:	88fb      	ldrh	r3, [r7, #6]
 801e68e:	2b07      	cmp	r3, #7
 801e690:	d002      	beq.n	801e698 <handle_read_by_group_type_request+0x1c>
 801e692:	2b15      	cmp	r3, #21
 801e694:	d003      	beq.n	801e69e <handle_read_by_group_type_request+0x22>
 801e696:	e005      	b.n	801e6a4 <handle_read_by_group_type_request+0x28>
        case 7:
            attribute_type_len = 2;
 801e698:	2302      	movs	r3, #2
 801e69a:	82fb      	strh	r3, [r7, #22]
            break;
 801e69c:	e008      	b.n	801e6b0 <handle_read_by_group_type_request+0x34>
        case 21:
            attribute_type_len = 16;
 801e69e:	2310      	movs	r3, #16
 801e6a0:	82fb      	strh	r3, [r7, #22]
            break;
 801e6a2:	e005      	b.n	801e6b0 <handle_read_by_group_type_request+0x34>
        default:
            return setup_error_invalid_pdu(response_buffer, ATT_READ_BY_GROUP_TYPE_REQUEST);
 801e6a4:	2110      	movs	r1, #16
 801e6a6:	6838      	ldr	r0, [r7, #0]
 801e6a8:	f7ff f871 	bl	801d78e <setup_error_invalid_pdu>
 801e6ac:	4603      	mov	r3, r0
 801e6ae:	e01a      	b.n	801e6e6 <handle_read_by_group_type_request+0x6a>
    }

    uint16_t start_handle = little_endian_read_16(request_buffer, 1);
 801e6b0:	2101      	movs	r1, #1
 801e6b2:	68b8      	ldr	r0, [r7, #8]
 801e6b4:	f7f0 fb97 	bl	800ede6 <little_endian_read_16>
 801e6b8:	4603      	mov	r3, r0
 801e6ba:	82bb      	strh	r3, [r7, #20]
    uint16_t end_handle = little_endian_read_16(request_buffer, 3);
 801e6bc:	2103      	movs	r1, #3
 801e6be:	68b8      	ldr	r0, [r7, #8]
 801e6c0:	f7f0 fb91 	bl	800ede6 <little_endian_read_16>
 801e6c4:	4603      	mov	r3, r0
 801e6c6:	827b      	strh	r3, [r7, #18]
    return handle_read_by_group_type_request2(att_connection, response_buffer, response_buffer_size, start_handle, end_handle, attribute_type_len, &request_buffer[5]);
 801e6c8:	68bb      	ldr	r3, [r7, #8]
 801e6ca:	3305      	adds	r3, #5
 801e6cc:	8ab9      	ldrh	r1, [r7, #20]
 801e6ce:	8c3a      	ldrh	r2, [r7, #32]
 801e6d0:	9302      	str	r3, [sp, #8]
 801e6d2:	8afb      	ldrh	r3, [r7, #22]
 801e6d4:	9301      	str	r3, [sp, #4]
 801e6d6:	8a7b      	ldrh	r3, [r7, #18]
 801e6d8:	9300      	str	r3, [sp, #0]
 801e6da:	460b      	mov	r3, r1
 801e6dc:	6839      	ldr	r1, [r7, #0]
 801e6de:	68f8      	ldr	r0, [r7, #12]
 801e6e0:	f7ff fec0 	bl	801e464 <handle_read_by_group_type_request2>
 801e6e4:	4603      	mov	r3, r0
}
 801e6e6:	4618      	mov	r0, r3
 801e6e8:	3718      	adds	r7, #24
 801e6ea:	46bd      	mov	sp, r7
 801e6ec:	bd80      	pop	{r7, pc}
	...

0801e6f0 <handle_write_request>:

//
// MARK: ATT_WRITE_REQUEST 0x12
static uint16_t handle_write_request(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len,
                              uint8_t * response_buffer, uint16_t response_buffer_size){
 801e6f0:	b590      	push	{r4, r7, lr}
 801e6f2:	b091      	sub	sp, #68	; 0x44
 801e6f4:	af02      	add	r7, sp, #8
 801e6f6:	60f8      	str	r0, [r7, #12]
 801e6f8:	60b9      	str	r1, [r7, #8]
 801e6fa:	603b      	str	r3, [r7, #0]
 801e6fc:	4613      	mov	r3, r2
 801e6fe:	80fb      	strh	r3, [r7, #6]

    UNUSED(response_buffer_size);

    if (request_len < 3u) return setup_error_invalid_pdu(response_buffer, ATT_WRITE_REQUEST);
 801e700:	88fb      	ldrh	r3, [r7, #6]
 801e702:	2b02      	cmp	r3, #2
 801e704:	d805      	bhi.n	801e712 <handle_write_request+0x22>
 801e706:	2112      	movs	r1, #18
 801e708:	6838      	ldr	r0, [r7, #0]
 801e70a:	f7ff f840 	bl	801d78e <setup_error_invalid_pdu>
 801e70e:	4603      	mov	r3, r0
 801e710:	e08e      	b.n	801e830 <handle_write_request+0x140>

    uint8_t request_type = ATT_WRITE_REQUEST;
 801e712:	2312      	movs	r3, #18
 801e714:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37

    uint16_t handle = little_endian_read_16(request_buffer, 1);
 801e718:	2101      	movs	r1, #1
 801e71a:	68b8      	ldr	r0, [r7, #8]
 801e71c:	f7f0 fb63 	bl	800ede6 <little_endian_read_16>
 801e720:	4603      	mov	r3, r0
 801e722:	86bb      	strh	r3, [r7, #52]	; 0x34
    att_iterator_t it;
    int ok = att_find_handle(&it, handle);
 801e724:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e726:	f107 0314 	add.w	r3, r7, #20
 801e72a:	4611      	mov	r1, r2
 801e72c:	4618      	mov	r0, r3
 801e72e:	f7fe fe9f 	bl	801d470 <att_find_handle>
 801e732:	6338      	str	r0, [r7, #48]	; 0x30
    if (!ok) {
 801e734:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e736:	2b00      	cmp	r3, #0
 801e738:	d109      	bne.n	801e74e <handle_write_request+0x5e>
        return setup_error_invalid_handle(response_buffer, request_type, handle);
 801e73a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e73e:	b29b      	uxth	r3, r3
 801e740:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e742:	4619      	mov	r1, r3
 801e744:	6838      	ldr	r0, [r7, #0]
 801e746:	f7fe fffc 	bl	801d742 <setup_error_invalid_handle>
 801e74a:	4603      	mov	r3, r0
 801e74c:	e070      	b.n	801e830 <handle_write_request+0x140>
    }
    if (att_write_callback == NULL) {
 801e74e:	4b3a      	ldr	r3, [pc, #232]	; (801e838 <handle_write_request+0x148>)
 801e750:	681b      	ldr	r3, [r3, #0]
 801e752:	2b00      	cmp	r3, #0
 801e754:	d109      	bne.n	801e76a <handle_write_request+0x7a>
        return setup_error_write_not_permitted(response_buffer, request_type, handle);
 801e756:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e75a:	b29b      	uxth	r3, r3
 801e75c:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e75e:	4619      	mov	r1, r3
 801e760:	6838      	ldr	r0, [r7, #0]
 801e762:	f7fe ffc8 	bl	801d6f6 <setup_error_write_not_permitted>
 801e766:	4603      	mov	r3, r0
 801e768:	e062      	b.n	801e830 <handle_write_request+0x140>
    }
    if ((it.flags & ATT_PROPERTY_WRITE) == 0u) {
 801e76a:	8b7b      	ldrh	r3, [r7, #26]
 801e76c:	f003 0308 	and.w	r3, r3, #8
 801e770:	2b00      	cmp	r3, #0
 801e772:	d109      	bne.n	801e788 <handle_write_request+0x98>
        return setup_error_write_not_permitted(response_buffer, request_type, handle);
 801e774:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e778:	b29b      	uxth	r3, r3
 801e77a:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e77c:	4619      	mov	r1, r3
 801e77e:	6838      	ldr	r0, [r7, #0]
 801e780:	f7fe ffb9 	bl	801d6f6 <setup_error_write_not_permitted>
 801e784:	4603      	mov	r3, r0
 801e786:	e053      	b.n	801e830 <handle_write_request+0x140>
    }
    if ((it.flags & ATT_PROPERTY_DYNAMIC) == 0u) {
 801e788:	8b7b      	ldrh	r3, [r7, #26]
 801e78a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801e78e:	2b00      	cmp	r3, #0
 801e790:	d109      	bne.n	801e7a6 <handle_write_request+0xb6>
        return setup_error_write_not_permitted(response_buffer, request_type, handle);
 801e792:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e796:	b29b      	uxth	r3, r3
 801e798:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e79a:	4619      	mov	r1, r3
 801e79c:	6838      	ldr	r0, [r7, #0]
 801e79e:	f7fe ffaa 	bl	801d6f6 <setup_error_write_not_permitted>
 801e7a2:	4603      	mov	r3, r0
 801e7a4:	e044      	b.n	801e830 <handle_write_request+0x140>
    }
    // check security requirements
    int error_code = att_validate_security(att_connection, ATT_WRITE, &it);
 801e7a6:	f107 0314 	add.w	r3, r7, #20
 801e7aa:	461a      	mov	r2, r3
 801e7ac:	2101      	movs	r1, #1
 801e7ae:	68f8      	ldr	r0, [r7, #12]
 801e7b0:	f7fe fffe 	bl	801d7b0 <att_validate_security>
 801e7b4:	4603      	mov	r3, r0
 801e7b6:	62fb      	str	r3, [r7, #44]	; 0x2c
    if (error_code != 0) {
 801e7b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e7ba:	2b00      	cmp	r3, #0
 801e7bc:	d00a      	beq.n	801e7d4 <handle_write_request+0xe4>
        return setup_error(response_buffer, request_type, handle, error_code);
 801e7be:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e7c2:	b299      	uxth	r1, r3
 801e7c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e7c6:	b2db      	uxtb	r3, r3
 801e7c8:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e7ca:	6838      	ldr	r0, [r7, #0]
 801e7cc:	f7fe ff5c 	bl	801d688 <setup_error>
 801e7d0:	4603      	mov	r3, r0
 801e7d2:	e02d      	b.n	801e830 <handle_write_request+0x140>
    }
    att_persistent_ccc_cache(&it);
 801e7d4:	f107 0314 	add.w	r3, r7, #20
 801e7d8:	4618      	mov	r0, r3
 801e7da:	f000 fb7d 	bl	801eed8 <att_persistent_ccc_cache>
    error_code = (*att_write_callback)(att_connection->con_handle, handle, ATT_TRANSACTION_MODE_NONE, 0u, request_buffer + 3u, request_len - 3u);
 801e7de:	4b16      	ldr	r3, [pc, #88]	; (801e838 <handle_write_request+0x148>)
 801e7e0:	681c      	ldr	r4, [r3, #0]
 801e7e2:	68fb      	ldr	r3, [r7, #12]
 801e7e4:	8818      	ldrh	r0, [r3, #0]
 801e7e6:	68bb      	ldr	r3, [r7, #8]
 801e7e8:	3303      	adds	r3, #3
 801e7ea:	88fa      	ldrh	r2, [r7, #6]
 801e7ec:	3a03      	subs	r2, #3
 801e7ee:	b292      	uxth	r2, r2
 801e7f0:	8eb9      	ldrh	r1, [r7, #52]	; 0x34
 801e7f2:	9201      	str	r2, [sp, #4]
 801e7f4:	9300      	str	r3, [sp, #0]
 801e7f6:	2300      	movs	r3, #0
 801e7f8:	2200      	movs	r2, #0
 801e7fa:	47a0      	blx	r4
 801e7fc:	62f8      	str	r0, [r7, #44]	; 0x2c

#ifdef ENABLE_ATT_DELAYED_RESPONSE
    if (error_code == ATT_ERROR_WRITE_RESPONSE_PENDING) return ATT_INTERNAL_WRITE_RESPONSE_PENDING;
 801e7fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e800:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801e804:	d102      	bne.n	801e80c <handle_write_request+0x11c>
 801e806:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 801e80a:	e011      	b.n	801e830 <handle_write_request+0x140>
#endif

    if (error_code != 0) {
 801e80c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e80e:	2b00      	cmp	r3, #0
 801e810:	d00a      	beq.n	801e828 <handle_write_request+0x138>
        return setup_error(response_buffer, request_type, handle, error_code);
 801e812:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e816:	b299      	uxth	r1, r3
 801e818:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e81a:	b2db      	uxtb	r3, r3
 801e81c:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e81e:	6838      	ldr	r0, [r7, #0]
 801e820:	f7fe ff32 	bl	801d688 <setup_error>
 801e824:	4603      	mov	r3, r0
 801e826:	e003      	b.n	801e830 <handle_write_request+0x140>
    }
    response_buffer[0] = ATT_WRITE_RESPONSE;
 801e828:	683b      	ldr	r3, [r7, #0]
 801e82a:	2213      	movs	r2, #19
 801e82c:	701a      	strb	r2, [r3, #0]
    return 1;
 801e82e:	2301      	movs	r3, #1
}
 801e830:	4618      	mov	r0, r3
 801e832:	373c      	adds	r7, #60	; 0x3c
 801e834:	46bd      	mov	sp, r7
 801e836:	bd90      	pop	{r4, r7, pc}
 801e838:	20009ee8 	.word	0x20009ee8

0801e83c <handle_prepare_write_request>:

//
// MARK: ATT_PREPARE_WRITE_REQUEST 0x16
static uint16_t handle_prepare_write_request(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len,
                                      uint8_t * response_buffer, uint16_t response_buffer_size){
 801e83c:	b5b0      	push	{r4, r5, r7, lr}
 801e83e:	b090      	sub	sp, #64	; 0x40
 801e840:	af02      	add	r7, sp, #8
 801e842:	60f8      	str	r0, [r7, #12]
 801e844:	60b9      	str	r1, [r7, #8]
 801e846:	603b      	str	r3, [r7, #0]
 801e848:	4613      	mov	r3, r2
 801e84a:	80fb      	strh	r3, [r7, #6]

    uint8_t request_type = ATT_PREPARE_WRITE_REQUEST;
 801e84c:	2316      	movs	r3, #22
 801e84e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37

    if (request_len < 5u) return setup_error_invalid_pdu(response_buffer, request_type);
 801e852:	88fb      	ldrh	r3, [r7, #6]
 801e854:	2b04      	cmp	r3, #4
 801e856:	d808      	bhi.n	801e86a <handle_prepare_write_request+0x2e>
 801e858:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e85c:	b29b      	uxth	r3, r3
 801e85e:	4619      	mov	r1, r3
 801e860:	6838      	ldr	r0, [r7, #0]
 801e862:	f7fe ff94 	bl	801d78e <setup_error_invalid_pdu>
 801e866:	4603      	mov	r3, r0
 801e868:	e0ab      	b.n	801e9c2 <handle_prepare_write_request+0x186>

    uint16_t handle = little_endian_read_16(request_buffer, 1);
 801e86a:	2101      	movs	r1, #1
 801e86c:	68b8      	ldr	r0, [r7, #8]
 801e86e:	f7f0 faba 	bl	800ede6 <little_endian_read_16>
 801e872:	4603      	mov	r3, r0
 801e874:	86bb      	strh	r3, [r7, #52]	; 0x34
    uint16_t offset = little_endian_read_16(request_buffer, 3);
 801e876:	2103      	movs	r1, #3
 801e878:	68b8      	ldr	r0, [r7, #8]
 801e87a:	f7f0 fab4 	bl	800ede6 <little_endian_read_16>
 801e87e:	4603      	mov	r3, r0
 801e880:	867b      	strh	r3, [r7, #50]	; 0x32
    if (att_write_callback == NULL) {
 801e882:	4b52      	ldr	r3, [pc, #328]	; (801e9cc <handle_prepare_write_request+0x190>)
 801e884:	681b      	ldr	r3, [r3, #0]
 801e886:	2b00      	cmp	r3, #0
 801e888:	d109      	bne.n	801e89e <handle_prepare_write_request+0x62>
        return setup_error_write_not_permitted(response_buffer, request_type, handle);
 801e88a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e88e:	b29b      	uxth	r3, r3
 801e890:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e892:	4619      	mov	r1, r3
 801e894:	6838      	ldr	r0, [r7, #0]
 801e896:	f7fe ff2e 	bl	801d6f6 <setup_error_write_not_permitted>
 801e89a:	4603      	mov	r3, r0
 801e89c:	e091      	b.n	801e9c2 <handle_prepare_write_request+0x186>
    }
    att_iterator_t it;
    if (att_find_handle(&it, handle) == 0) {
 801e89e:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e8a0:	f107 0310 	add.w	r3, r7, #16
 801e8a4:	4611      	mov	r1, r2
 801e8a6:	4618      	mov	r0, r3
 801e8a8:	f7fe fde2 	bl	801d470 <att_find_handle>
 801e8ac:	4603      	mov	r3, r0
 801e8ae:	2b00      	cmp	r3, #0
 801e8b0:	d109      	bne.n	801e8c6 <handle_prepare_write_request+0x8a>
        return setup_error_invalid_handle(response_buffer, request_type, handle);
 801e8b2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e8b6:	b29b      	uxth	r3, r3
 801e8b8:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e8ba:	4619      	mov	r1, r3
 801e8bc:	6838      	ldr	r0, [r7, #0]
 801e8be:	f7fe ff40 	bl	801d742 <setup_error_invalid_handle>
 801e8c2:	4603      	mov	r3, r0
 801e8c4:	e07d      	b.n	801e9c2 <handle_prepare_write_request+0x186>
    }
    if ((it.flags & ATT_PROPERTY_WRITE) == 0u) {
 801e8c6:	8afb      	ldrh	r3, [r7, #22]
 801e8c8:	f003 0308 	and.w	r3, r3, #8
 801e8cc:	2b00      	cmp	r3, #0
 801e8ce:	d109      	bne.n	801e8e4 <handle_prepare_write_request+0xa8>
        return setup_error_write_not_permitted(response_buffer, request_type, handle);
 801e8d0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e8d4:	b29b      	uxth	r3, r3
 801e8d6:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e8d8:	4619      	mov	r1, r3
 801e8da:	6838      	ldr	r0, [r7, #0]
 801e8dc:	f7fe ff0b 	bl	801d6f6 <setup_error_write_not_permitted>
 801e8e0:	4603      	mov	r3, r0
 801e8e2:	e06e      	b.n	801e9c2 <handle_prepare_write_request+0x186>
    }
    if ((it.flags & ATT_PROPERTY_DYNAMIC) == 0u) {
 801e8e4:	8afb      	ldrh	r3, [r7, #22]
 801e8e6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801e8ea:	2b00      	cmp	r3, #0
 801e8ec:	d109      	bne.n	801e902 <handle_prepare_write_request+0xc6>
        return setup_error_write_not_permitted(response_buffer, request_type, handle);
 801e8ee:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e8f2:	b29b      	uxth	r3, r3
 801e8f4:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e8f6:	4619      	mov	r1, r3
 801e8f8:	6838      	ldr	r0, [r7, #0]
 801e8fa:	f7fe fefc 	bl	801d6f6 <setup_error_write_not_permitted>
 801e8fe:	4603      	mov	r3, r0
 801e900:	e05f      	b.n	801e9c2 <handle_prepare_write_request+0x186>
    }
    // check security requirements
    int error_code = att_validate_security(att_connection, ATT_WRITE, &it);
 801e902:	f107 0310 	add.w	r3, r7, #16
 801e906:	461a      	mov	r2, r3
 801e908:	2101      	movs	r1, #1
 801e90a:	68f8      	ldr	r0, [r7, #12]
 801e90c:	f7fe ff50 	bl	801d7b0 <att_validate_security>
 801e910:	4603      	mov	r3, r0
 801e912:	62fb      	str	r3, [r7, #44]	; 0x2c
    if (error_code != 0) {
 801e914:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e916:	2b00      	cmp	r3, #0
 801e918:	d00a      	beq.n	801e930 <handle_prepare_write_request+0xf4>
        return setup_error(response_buffer, request_type, handle, error_code);
 801e91a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e91e:	b299      	uxth	r1, r3
 801e920:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e922:	b2db      	uxtb	r3, r3
 801e924:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e926:	6838      	ldr	r0, [r7, #0]
 801e928:	f7fe feae 	bl	801d688 <setup_error>
 801e92c:	4603      	mov	r3, r0
 801e92e:	e048      	b.n	801e9c2 <handle_prepare_write_request+0x186>
    }

    error_code = (*att_write_callback)(att_connection->con_handle, handle, ATT_TRANSACTION_MODE_ACTIVE, offset, request_buffer + 5u, request_len - 5u);
 801e930:	4b26      	ldr	r3, [pc, #152]	; (801e9cc <handle_prepare_write_request+0x190>)
 801e932:	681c      	ldr	r4, [r3, #0]
 801e934:	68fb      	ldr	r3, [r7, #12]
 801e936:	8818      	ldrh	r0, [r3, #0]
 801e938:	68bb      	ldr	r3, [r7, #8]
 801e93a:	3305      	adds	r3, #5
 801e93c:	88fa      	ldrh	r2, [r7, #6]
 801e93e:	3a05      	subs	r2, #5
 801e940:	b292      	uxth	r2, r2
 801e942:	8e7d      	ldrh	r5, [r7, #50]	; 0x32
 801e944:	8eb9      	ldrh	r1, [r7, #52]	; 0x34
 801e946:	9201      	str	r2, [sp, #4]
 801e948:	9300      	str	r3, [sp, #0]
 801e94a:	462b      	mov	r3, r5
 801e94c:	2201      	movs	r2, #1
 801e94e:	47a0      	blx	r4
 801e950:	62f8      	str	r0, [r7, #44]	; 0x2c
    switch (error_code){
 801e952:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e954:	2b07      	cmp	r3, #7
 801e956:	d00a      	beq.n	801e96e <handle_prepare_write_request+0x132>
 801e958:	2b07      	cmp	r3, #7
 801e95a:	dc02      	bgt.n	801e962 <handle_prepare_write_request+0x126>
 801e95c:	2b00      	cmp	r3, #0
 801e95e:	d01c      	beq.n	801e99a <handle_prepare_write_request+0x15e>
 801e960:	e010      	b.n	801e984 <handle_prepare_write_request+0x148>
 801e962:	2b0d      	cmp	r3, #13
 801e964:	d003      	beq.n	801e96e <handle_prepare_write_request+0x132>
 801e966:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801e96a:	d008      	beq.n	801e97e <handle_prepare_write_request+0x142>
 801e96c:	e00a      	b.n	801e984 <handle_prepare_write_request+0x148>
        case 0:
            break;
        case ATT_ERROR_INVALID_OFFSET:
        case ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LENGTH:
            // postpone to execute write request
            att_prepare_write_update_errors(error_code, handle);
 801e96e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e970:	b2db      	uxtb	r3, r3
 801e972:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e974:	4611      	mov	r1, r2
 801e976:	4618      	mov	r0, r3
 801e978:	f7fe fe58 	bl	801d62c <att_prepare_write_update_errors>
            break;
 801e97c:	e00e      	b.n	801e99c <handle_prepare_write_request+0x160>
#ifdef ENABLE_ATT_DELAYED_RESPONSE
        case ATT_ERROR_WRITE_RESPONSE_PENDING:
            return ATT_INTERNAL_WRITE_RESPONSE_PENDING;
 801e97e:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 801e982:	e01e      	b.n	801e9c2 <handle_prepare_write_request+0x186>
#endif
        default:
            return setup_error(response_buffer, request_type, handle, error_code);
 801e984:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801e988:	b299      	uxth	r1, r3
 801e98a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e98c:	b2db      	uxtb	r3, r3
 801e98e:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801e990:	6838      	ldr	r0, [r7, #0]
 801e992:	f7fe fe79 	bl	801d688 <setup_error>
 801e996:	4603      	mov	r3, r0
 801e998:	e013      	b.n	801e9c2 <handle_prepare_write_request+0x186>
            break;
 801e99a:	bf00      	nop
    }

    // response: echo request
    uint16_t bytes_to_echo = btstack_min(request_len, response_buffer_size);
 801e99c:	88fb      	ldrh	r3, [r7, #6]
 801e99e:	f8b7 2048 	ldrh.w	r2, [r7, #72]	; 0x48
 801e9a2:	4611      	mov	r1, r2
 801e9a4:	4618      	mov	r0, r3
 801e9a6:	f7f0 fbb2 	bl	800f10e <btstack_min>
 801e9aa:	4603      	mov	r3, r0
 801e9ac:	857b      	strh	r3, [r7, #42]	; 0x2a
    (void)memcpy(response_buffer, request_buffer, bytes_to_echo);
 801e9ae:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801e9b0:	461a      	mov	r2, r3
 801e9b2:	68b9      	ldr	r1, [r7, #8]
 801e9b4:	6838      	ldr	r0, [r7, #0]
 801e9b6:	f009 f860 	bl	8027a7a <memcpy>
    response_buffer[0] = ATT_PREPARE_WRITE_RESPONSE;
 801e9ba:	683b      	ldr	r3, [r7, #0]
 801e9bc:	2217      	movs	r2, #23
 801e9be:	701a      	strb	r2, [r3, #0]
    return request_len;
 801e9c0:	88fb      	ldrh	r3, [r7, #6]
}
 801e9c2:	4618      	mov	r0, r3
 801e9c4:	3738      	adds	r7, #56	; 0x38
 801e9c6:	46bd      	mov	sp, r7
 801e9c8:	bdb0      	pop	{r4, r5, r7, pc}
 801e9ca:	bf00      	nop
 801e9cc:	20009ee8 	.word	0x20009ee8

0801e9d0 <att_clear_transaction_queue>:

/*
 * @brief transcation queue of prepared writes, e.g., after disconnect
 */
void att_clear_transaction_queue(att_connection_t * att_connection){
 801e9d0:	b590      	push	{r4, r7, lr}
 801e9d2:	b085      	sub	sp, #20
 801e9d4:	af02      	add	r7, sp, #8
 801e9d6:	6078      	str	r0, [r7, #4]
    (*att_write_callback)(att_connection->con_handle, 0, ATT_TRANSACTION_MODE_CANCEL, 0, NULL, 0);
 801e9d8:	4b07      	ldr	r3, [pc, #28]	; (801e9f8 <att_clear_transaction_queue+0x28>)
 801e9da:	681c      	ldr	r4, [r3, #0]
 801e9dc:	687b      	ldr	r3, [r7, #4]
 801e9de:	8818      	ldrh	r0, [r3, #0]
 801e9e0:	2300      	movs	r3, #0
 801e9e2:	9301      	str	r3, [sp, #4]
 801e9e4:	2300      	movs	r3, #0
 801e9e6:	9300      	str	r3, [sp, #0]
 801e9e8:	2300      	movs	r3, #0
 801e9ea:	2203      	movs	r2, #3
 801e9ec:	2100      	movs	r1, #0
 801e9ee:	47a0      	blx	r4
}
 801e9f0:	bf00      	nop
 801e9f2:	370c      	adds	r7, #12
 801e9f4:	46bd      	mov	sp, r7
 801e9f6:	bd90      	pop	{r4, r7, pc}
 801e9f8:	20009ee8 	.word	0x20009ee8

0801e9fc <handle_execute_write_request>:

// MARK: ATT_EXECUTE_WRITE_REQUEST 0x18
// NOTE: security has been verified by handle_prepare_write_request
static uint16_t handle_execute_write_request(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len,
                                      uint8_t * response_buffer, uint16_t response_buffer_size){
 801e9fc:	b590      	push	{r4, r7, lr}
 801e9fe:	b089      	sub	sp, #36	; 0x24
 801ea00:	af02      	add	r7, sp, #8
 801ea02:	60f8      	str	r0, [r7, #12]
 801ea04:	60b9      	str	r1, [r7, #8]
 801ea06:	603b      	str	r3, [r7, #0]
 801ea08:	4613      	mov	r3, r2
 801ea0a:	80fb      	strh	r3, [r7, #6]

    UNUSED(response_buffer_size);

    uint8_t request_type = ATT_EXECUTE_WRITE_REQUEST;
 801ea0c:	2318      	movs	r3, #24
 801ea0e:	75fb      	strb	r3, [r7, #23]

    if (request_len < 2u) return setup_error_invalid_pdu(response_buffer, request_type);
 801ea10:	88fb      	ldrh	r3, [r7, #6]
 801ea12:	2b01      	cmp	r3, #1
 801ea14:	d807      	bhi.n	801ea26 <handle_execute_write_request+0x2a>
 801ea16:	7dfb      	ldrb	r3, [r7, #23]
 801ea18:	b29b      	uxth	r3, r3
 801ea1a:	4619      	mov	r1, r3
 801ea1c:	6838      	ldr	r0, [r7, #0]
 801ea1e:	f7fe feb6 	bl	801d78e <setup_error_invalid_pdu>
 801ea22:	4603      	mov	r3, r0
 801ea24:	e058      	b.n	801ead8 <handle_execute_write_request+0xdc>

    if (att_write_callback == NULL) {
 801ea26:	4b2e      	ldr	r3, [pc, #184]	; (801eae0 <handle_execute_write_request+0xe4>)
 801ea28:	681b      	ldr	r3, [r3, #0]
 801ea2a:	2b00      	cmp	r3, #0
 801ea2c:	d108      	bne.n	801ea40 <handle_execute_write_request+0x44>
        return setup_error_write_not_permitted(response_buffer, request_type, 0);
 801ea2e:	7dfb      	ldrb	r3, [r7, #23]
 801ea30:	b29b      	uxth	r3, r3
 801ea32:	2200      	movs	r2, #0
 801ea34:	4619      	mov	r1, r3
 801ea36:	6838      	ldr	r0, [r7, #0]
 801ea38:	f7fe fe5d 	bl	801d6f6 <setup_error_write_not_permitted>
 801ea3c:	4603      	mov	r3, r0
 801ea3e:	e04b      	b.n	801ead8 <handle_execute_write_request+0xdc>
    }

    if (request_buffer[1]) {
 801ea40:	68bb      	ldr	r3, [r7, #8]
 801ea42:	3301      	adds	r3, #1
 801ea44:	781b      	ldrb	r3, [r3, #0]
 801ea46:	2b00      	cmp	r3, #0
 801ea48:	d03f      	beq.n	801eaca <handle_execute_write_request+0xce>
        // validate queued write
        if (att_prepare_write_error_code == 0){
 801ea4a:	4b26      	ldr	r3, [pc, #152]	; (801eae4 <handle_execute_write_request+0xe8>)
 801ea4c:	681b      	ldr	r3, [r3, #0]
 801ea4e:	2b00      	cmp	r3, #0
 801ea50:	d10e      	bne.n	801ea70 <handle_execute_write_request+0x74>
            att_prepare_write_error_code = (*att_write_callback)(att_connection->con_handle, 0, ATT_TRANSACTION_MODE_VALIDATE, 0, NULL, 0);
 801ea52:	4b23      	ldr	r3, [pc, #140]	; (801eae0 <handle_execute_write_request+0xe4>)
 801ea54:	681c      	ldr	r4, [r3, #0]
 801ea56:	68fb      	ldr	r3, [r7, #12]
 801ea58:	8818      	ldrh	r0, [r3, #0]
 801ea5a:	2300      	movs	r3, #0
 801ea5c:	9301      	str	r3, [sp, #4]
 801ea5e:	2300      	movs	r3, #0
 801ea60:	9300      	str	r3, [sp, #0]
 801ea62:	2300      	movs	r3, #0
 801ea64:	2204      	movs	r2, #4
 801ea66:	2100      	movs	r1, #0
 801ea68:	47a0      	blx	r4
 801ea6a:	4602      	mov	r2, r0
 801ea6c:	4b1d      	ldr	r3, [pc, #116]	; (801eae4 <handle_execute_write_request+0xe8>)
 801ea6e:	601a      	str	r2, [r3, #0]
        }
#ifdef ENABLE_ATT_DELAYED_RESPONSE
        if (att_prepare_write_error_code == ATT_ERROR_WRITE_RESPONSE_PENDING) return ATT_INTERNAL_WRITE_RESPONSE_PENDING;
 801ea70:	4b1c      	ldr	r3, [pc, #112]	; (801eae4 <handle_execute_write_request+0xe8>)
 801ea72:	681b      	ldr	r3, [r3, #0]
 801ea74:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801ea78:	d102      	bne.n	801ea80 <handle_execute_write_request+0x84>
 801ea7a:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 801ea7e:	e02b      	b.n	801ead8 <handle_execute_write_request+0xdc>
#endif
        // deliver queued errors
        if (att_prepare_write_error_code != 0){
 801ea80:	4b18      	ldr	r3, [pc, #96]	; (801eae4 <handle_execute_write_request+0xe8>)
 801ea82:	681b      	ldr	r3, [r3, #0]
 801ea84:	2b00      	cmp	r3, #0
 801ea86:	d013      	beq.n	801eab0 <handle_execute_write_request+0xb4>
            att_clear_transaction_queue(att_connection);
 801ea88:	68f8      	ldr	r0, [r7, #12]
 801ea8a:	f7ff ffa1 	bl	801e9d0 <att_clear_transaction_queue>
            uint8_t  error_code = att_prepare_write_error_code;
 801ea8e:	4b15      	ldr	r3, [pc, #84]	; (801eae4 <handle_execute_write_request+0xe8>)
 801ea90:	681b      	ldr	r3, [r3, #0]
 801ea92:	75bb      	strb	r3, [r7, #22]
            uint16_t handle     = att_prepare_write_error_handle;
 801ea94:	4b14      	ldr	r3, [pc, #80]	; (801eae8 <handle_execute_write_request+0xec>)
 801ea96:	881b      	ldrh	r3, [r3, #0]
 801ea98:	82bb      	strh	r3, [r7, #20]
            att_prepare_write_reset();
 801ea9a:	f7fe fdb5 	bl	801d608 <att_prepare_write_reset>
            return setup_error(response_buffer, request_type, handle, error_code);
 801ea9e:	7dfb      	ldrb	r3, [r7, #23]
 801eaa0:	b299      	uxth	r1, r3
 801eaa2:	7dbb      	ldrb	r3, [r7, #22]
 801eaa4:	8aba      	ldrh	r2, [r7, #20]
 801eaa6:	6838      	ldr	r0, [r7, #0]
 801eaa8:	f7fe fdee 	bl	801d688 <setup_error>
 801eaac:	4603      	mov	r3, r0
 801eaae:	e013      	b.n	801ead8 <handle_execute_write_request+0xdc>
        }
        att_write_callback(att_connection->con_handle, 0, ATT_TRANSACTION_MODE_EXECUTE, 0, NULL, 0);
 801eab0:	4b0b      	ldr	r3, [pc, #44]	; (801eae0 <handle_execute_write_request+0xe4>)
 801eab2:	681c      	ldr	r4, [r3, #0]
 801eab4:	68fb      	ldr	r3, [r7, #12]
 801eab6:	8818      	ldrh	r0, [r3, #0]
 801eab8:	2300      	movs	r3, #0
 801eaba:	9301      	str	r3, [sp, #4]
 801eabc:	2300      	movs	r3, #0
 801eabe:	9300      	str	r3, [sp, #0]
 801eac0:	2300      	movs	r3, #0
 801eac2:	2202      	movs	r2, #2
 801eac4:	2100      	movs	r1, #0
 801eac6:	47a0      	blx	r4
 801eac8:	e002      	b.n	801ead0 <handle_execute_write_request+0xd4>
    } else {
        att_clear_transaction_queue(att_connection);
 801eaca:	68f8      	ldr	r0, [r7, #12]
 801eacc:	f7ff ff80 	bl	801e9d0 <att_clear_transaction_queue>
    }
    response_buffer[0] = ATT_EXECUTE_WRITE_RESPONSE;
 801ead0:	683b      	ldr	r3, [r7, #0]
 801ead2:	2219      	movs	r2, #25
 801ead4:	701a      	strb	r2, [r3, #0]
    return 1;
 801ead6:	2301      	movs	r3, #1
}
 801ead8:	4618      	mov	r0, r3
 801eada:	371c      	adds	r7, #28
 801eadc:	46bd      	mov	sp, r7
 801eade:	bd90      	pop	{r4, r7, pc}
 801eae0:	20009ee8 	.word	0x20009ee8
 801eae4:	20009eec 	.word	0x20009eec
 801eae8:	20009ef0 	.word	0x20009ef0

0801eaec <handle_write_command>:

// MARK: ATT_WRITE_COMMAND 0x52
// Core 4.0, vol 3, part F, 3.4.5.3
// "No Error Response or Write Response shall be sent in response to this command"
static void handle_write_command(att_connection_t * att_connection, uint8_t * request_buffer,  uint16_t request_len, uint16_t required_flags){
 801eaec:	b590      	push	{r4, r7, lr}
 801eaee:	b08f      	sub	sp, #60	; 0x3c
 801eaf0:	af02      	add	r7, sp, #8
 801eaf2:	60f8      	str	r0, [r7, #12]
 801eaf4:	60b9      	str	r1, [r7, #8]
 801eaf6:	4611      	mov	r1, r2
 801eaf8:	461a      	mov	r2, r3
 801eafa:	460b      	mov	r3, r1
 801eafc:	80fb      	strh	r3, [r7, #6]
 801eafe:	4613      	mov	r3, r2
 801eb00:	80bb      	strh	r3, [r7, #4]

    if (request_len < 3u) return;
 801eb02:	88fb      	ldrh	r3, [r7, #6]
 801eb04:	2b02      	cmp	r3, #2
 801eb06:	d93e      	bls.n	801eb86 <handle_write_command+0x9a>

    uint16_t handle = little_endian_read_16(request_buffer, 1);
 801eb08:	2101      	movs	r1, #1
 801eb0a:	68b8      	ldr	r0, [r7, #8]
 801eb0c:	f7f0 f96b 	bl	800ede6 <little_endian_read_16>
 801eb10:	4603      	mov	r3, r0
 801eb12:	85fb      	strh	r3, [r7, #46]	; 0x2e
    if (att_write_callback == NULL) return;
 801eb14:	4b23      	ldr	r3, [pc, #140]	; (801eba4 <handle_write_command+0xb8>)
 801eb16:	681b      	ldr	r3, [r3, #0]
 801eb18:	2b00      	cmp	r3, #0
 801eb1a:	d036      	beq.n	801eb8a <handle_write_command+0x9e>

    att_iterator_t it;
    int ok = att_find_handle(&it, handle);
 801eb1c:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801eb1e:	f107 0310 	add.w	r3, r7, #16
 801eb22:	4611      	mov	r1, r2
 801eb24:	4618      	mov	r0, r3
 801eb26:	f7fe fca3 	bl	801d470 <att_find_handle>
 801eb2a:	62b8      	str	r0, [r7, #40]	; 0x28
    if (!ok) return;
 801eb2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801eb2e:	2b00      	cmp	r3, #0
 801eb30:	d02d      	beq.n	801eb8e <handle_write_command+0xa2>
    if ((it.flags & ATT_PROPERTY_DYNAMIC) == 0u) return;
 801eb32:	8afb      	ldrh	r3, [r7, #22]
 801eb34:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801eb38:	2b00      	cmp	r3, #0
 801eb3a:	d02a      	beq.n	801eb92 <handle_write_command+0xa6>
    if ((it.flags & required_flags) == 0u) return;
 801eb3c:	8afa      	ldrh	r2, [r7, #22]
 801eb3e:	88bb      	ldrh	r3, [r7, #4]
 801eb40:	4013      	ands	r3, r2
 801eb42:	b29b      	uxth	r3, r3
 801eb44:	2b00      	cmp	r3, #0
 801eb46:	d026      	beq.n	801eb96 <handle_write_command+0xaa>
    if (att_validate_security(att_connection, ATT_WRITE, &it)) return;
 801eb48:	f107 0310 	add.w	r3, r7, #16
 801eb4c:	461a      	mov	r2, r3
 801eb4e:	2101      	movs	r1, #1
 801eb50:	68f8      	ldr	r0, [r7, #12]
 801eb52:	f7fe fe2d 	bl	801d7b0 <att_validate_security>
 801eb56:	4603      	mov	r3, r0
 801eb58:	2b00      	cmp	r3, #0
 801eb5a:	d11e      	bne.n	801eb9a <handle_write_command+0xae>
    att_persistent_ccc_cache(&it);
 801eb5c:	f107 0310 	add.w	r3, r7, #16
 801eb60:	4618      	mov	r0, r3
 801eb62:	f000 f9b9 	bl	801eed8 <att_persistent_ccc_cache>
    (*att_write_callback)(att_connection->con_handle, handle, ATT_TRANSACTION_MODE_NONE, 0u, request_buffer + 3u, request_len - 3u);
 801eb66:	4b0f      	ldr	r3, [pc, #60]	; (801eba4 <handle_write_command+0xb8>)
 801eb68:	681c      	ldr	r4, [r3, #0]
 801eb6a:	68fb      	ldr	r3, [r7, #12]
 801eb6c:	8818      	ldrh	r0, [r3, #0]
 801eb6e:	68bb      	ldr	r3, [r7, #8]
 801eb70:	3303      	adds	r3, #3
 801eb72:	88fa      	ldrh	r2, [r7, #6]
 801eb74:	3a03      	subs	r2, #3
 801eb76:	b292      	uxth	r2, r2
 801eb78:	8df9      	ldrh	r1, [r7, #46]	; 0x2e
 801eb7a:	9201      	str	r2, [sp, #4]
 801eb7c:	9300      	str	r3, [sp, #0]
 801eb7e:	2300      	movs	r3, #0
 801eb80:	2200      	movs	r2, #0
 801eb82:	47a0      	blx	r4
 801eb84:	e00a      	b.n	801eb9c <handle_write_command+0xb0>
    if (request_len < 3u) return;
 801eb86:	bf00      	nop
 801eb88:	e008      	b.n	801eb9c <handle_write_command+0xb0>
    if (att_write_callback == NULL) return;
 801eb8a:	bf00      	nop
 801eb8c:	e006      	b.n	801eb9c <handle_write_command+0xb0>
    if (!ok) return;
 801eb8e:	bf00      	nop
 801eb90:	e004      	b.n	801eb9c <handle_write_command+0xb0>
    if ((it.flags & ATT_PROPERTY_DYNAMIC) == 0u) return;
 801eb92:	bf00      	nop
 801eb94:	e002      	b.n	801eb9c <handle_write_command+0xb0>
    if ((it.flags & required_flags) == 0u) return;
 801eb96:	bf00      	nop
 801eb98:	e000      	b.n	801eb9c <handle_write_command+0xb0>
    if (att_validate_security(att_connection, ATT_WRITE, &it)) return;
 801eb9a:	bf00      	nop
}
 801eb9c:	3734      	adds	r7, #52	; 0x34
 801eb9e:	46bd      	mov	sp, r7
 801eba0:	bd90      	pop	{r4, r7, pc}
 801eba2:	bf00      	nop
 801eba4:	20009ee8 	.word	0x20009ee8

0801eba8 <prepare_handle_value>:
// MARK: helper for ATT_HANDLE_VALUE_NOTIFICATION and ATT_HANDLE_VALUE_INDICATION
static uint16_t prepare_handle_value(att_connection_t * att_connection,
                                     uint16_t handle,
                                     const uint8_t *value,
                                     uint16_t value_len, 
                                     uint8_t * response_buffer){
 801eba8:	b580      	push	{r7, lr}
 801ebaa:	b084      	sub	sp, #16
 801ebac:	af00      	add	r7, sp, #0
 801ebae:	60f8      	str	r0, [r7, #12]
 801ebb0:	607a      	str	r2, [r7, #4]
 801ebb2:	461a      	mov	r2, r3
 801ebb4:	460b      	mov	r3, r1
 801ebb6:	817b      	strh	r3, [r7, #10]
 801ebb8:	4613      	mov	r3, r2
 801ebba:	813b      	strh	r3, [r7, #8]
    little_endian_store_16(response_buffer, 1, handle);
 801ebbc:	897b      	ldrh	r3, [r7, #10]
 801ebbe:	461a      	mov	r2, r3
 801ebc0:	2101      	movs	r1, #1
 801ebc2:	69b8      	ldr	r0, [r7, #24]
 801ebc4:	f7f0 f94f 	bl	800ee66 <little_endian_store_16>
    if (value_len > (att_connection->mtu - 3u)){
 801ebc8:	893a      	ldrh	r2, [r7, #8]
 801ebca:	68fb      	ldr	r3, [r7, #12]
 801ebcc:	885b      	ldrh	r3, [r3, #2]
 801ebce:	3b03      	subs	r3, #3
 801ebd0:	429a      	cmp	r2, r3
 801ebd2:	d903      	bls.n	801ebdc <prepare_handle_value+0x34>
        value_len = att_connection->mtu - 3u;
 801ebd4:	68fb      	ldr	r3, [r7, #12]
 801ebd6:	885b      	ldrh	r3, [r3, #2]
 801ebd8:	3b03      	subs	r3, #3
 801ebda:	813b      	strh	r3, [r7, #8]
    }
    (void)memcpy(&response_buffer[3], value, value_len);
 801ebdc:	69bb      	ldr	r3, [r7, #24]
 801ebde:	3303      	adds	r3, #3
 801ebe0:	893a      	ldrh	r2, [r7, #8]
 801ebe2:	6879      	ldr	r1, [r7, #4]
 801ebe4:	4618      	mov	r0, r3
 801ebe6:	f008 ff48 	bl	8027a7a <memcpy>
    return value_len + 3u;
 801ebea:	893b      	ldrh	r3, [r7, #8]
 801ebec:	3303      	adds	r3, #3
 801ebee:	b29b      	uxth	r3, r3
}
 801ebf0:	4618      	mov	r0, r3
 801ebf2:	3710      	adds	r7, #16
 801ebf4:	46bd      	mov	sp, r7
 801ebf6:	bd80      	pop	{r7, pc}

0801ebf8 <att_prepare_handle_value_notification>:
// MARK: ATT_HANDLE_VALUE_NOTIFICATION 0x1b
uint16_t att_prepare_handle_value_notification(att_connection_t * att_connection,
                                               uint16_t handle,
                                               const uint8_t *value,
                                               uint16_t value_len, 
                                               uint8_t * response_buffer){
 801ebf8:	b580      	push	{r7, lr}
 801ebfa:	b086      	sub	sp, #24
 801ebfc:	af02      	add	r7, sp, #8
 801ebfe:	60f8      	str	r0, [r7, #12]
 801ec00:	607a      	str	r2, [r7, #4]
 801ec02:	461a      	mov	r2, r3
 801ec04:	460b      	mov	r3, r1
 801ec06:	817b      	strh	r3, [r7, #10]
 801ec08:	4613      	mov	r3, r2
 801ec0a:	813b      	strh	r3, [r7, #8]

    response_buffer[0] = ATT_HANDLE_VALUE_NOTIFICATION;
 801ec0c:	69bb      	ldr	r3, [r7, #24]
 801ec0e:	221b      	movs	r2, #27
 801ec10:	701a      	strb	r2, [r3, #0]
    return prepare_handle_value(att_connection, handle, value, value_len, response_buffer);
 801ec12:	893a      	ldrh	r2, [r7, #8]
 801ec14:	8979      	ldrh	r1, [r7, #10]
 801ec16:	69bb      	ldr	r3, [r7, #24]
 801ec18:	9300      	str	r3, [sp, #0]
 801ec1a:	4613      	mov	r3, r2
 801ec1c:	687a      	ldr	r2, [r7, #4]
 801ec1e:	68f8      	ldr	r0, [r7, #12]
 801ec20:	f7ff ffc2 	bl	801eba8 <prepare_handle_value>
 801ec24:	4603      	mov	r3, r0
}
 801ec26:	4618      	mov	r0, r3
 801ec28:	3710      	adds	r7, #16
 801ec2a:	46bd      	mov	sp, r7
 801ec2c:	bd80      	pop	{r7, pc}
	...

0801ec30 <att_handle_request>:
    
// MARK: Dispatcher
uint16_t att_handle_request(att_connection_t * att_connection,
                            uint8_t * request_buffer,
                            uint16_t request_len,
                            uint8_t * response_buffer){
 801ec30:	b580      	push	{r7, lr}
 801ec32:	b088      	sub	sp, #32
 801ec34:	af02      	add	r7, sp, #8
 801ec36:	60f8      	str	r0, [r7, #12]
 801ec38:	60b9      	str	r1, [r7, #8]
 801ec3a:	603b      	str	r3, [r7, #0]
 801ec3c:	4613      	mov	r3, r2
 801ec3e:	80fb      	strh	r3, [r7, #6]
    uint16_t response_len = 0;
 801ec40:	2300      	movs	r3, #0
 801ec42:	82fb      	strh	r3, [r7, #22]
    uint16_t response_buffer_size = att_connection->mtu;
 801ec44:	68fb      	ldr	r3, [r7, #12]
 801ec46:	885b      	ldrh	r3, [r3, #2]
 801ec48:	82bb      	strh	r3, [r7, #20]
    
    switch (request_buffer[0]){
 801ec4a:	68bb      	ldr	r3, [r7, #8]
 801ec4c:	781b      	ldrb	r3, [r3, #0]
 801ec4e:	3b02      	subs	r3, #2
 801ec50:	2b50      	cmp	r3, #80	; 0x50
 801ec52:	f200 8123 	bhi.w	801ee9c <att_handle_request+0x26c>
 801ec56:	a201      	add	r2, pc, #4	; (adr r2, 801ec5c <att_handle_request+0x2c>)
 801ec58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801ec5c:	0801eda1 	.word	0x0801eda1
 801ec60:	0801ee9d 	.word	0x0801ee9d
 801ec64:	0801edb3 	.word	0x0801edb3
 801ec68:	0801ee9d 	.word	0x0801ee9d
 801ec6c:	0801edc9 	.word	0x0801edc9
 801ec70:	0801ee9d 	.word	0x0801ee9d
 801ec74:	0801eddf 	.word	0x0801eddf
 801ec78:	0801ee9d 	.word	0x0801ee9d
 801ec7c:	0801edf5 	.word	0x0801edf5
 801ec80:	0801ee9d 	.word	0x0801ee9d
 801ec84:	0801ee0b 	.word	0x0801ee0b
 801ec88:	0801ee9d 	.word	0x0801ee9d
 801ec8c:	0801ee21 	.word	0x0801ee21
 801ec90:	0801ee9d 	.word	0x0801ee9d
 801ec94:	0801ee37 	.word	0x0801ee37
 801ec98:	0801ee9d 	.word	0x0801ee9d
 801ec9c:	0801ee4d 	.word	0x0801ee4d
 801eca0:	0801ee9d 	.word	0x0801ee9d
 801eca4:	0801ee9d 	.word	0x0801ee9d
 801eca8:	0801ee9d 	.word	0x0801ee9d
 801ecac:	0801ee63 	.word	0x0801ee63
 801ecb0:	0801ee9d 	.word	0x0801ee9d
 801ecb4:	0801ee79 	.word	0x0801ee79
 801ecb8:	0801ee9d 	.word	0x0801ee9d
 801ecbc:	0801ee9d 	.word	0x0801ee9d
 801ecc0:	0801ee9d 	.word	0x0801ee9d
 801ecc4:	0801ee9d 	.word	0x0801ee9d
 801ecc8:	0801ee9d 	.word	0x0801ee9d
 801eccc:	0801ee9d 	.word	0x0801ee9d
 801ecd0:	0801ee9d 	.word	0x0801ee9d
 801ecd4:	0801ee9d 	.word	0x0801ee9d
 801ecd8:	0801ee9d 	.word	0x0801ee9d
 801ecdc:	0801ee9d 	.word	0x0801ee9d
 801ece0:	0801ee9d 	.word	0x0801ee9d
 801ece4:	0801ee9d 	.word	0x0801ee9d
 801ece8:	0801ee9d 	.word	0x0801ee9d
 801ecec:	0801ee9d 	.word	0x0801ee9d
 801ecf0:	0801ee9d 	.word	0x0801ee9d
 801ecf4:	0801ee9d 	.word	0x0801ee9d
 801ecf8:	0801ee9d 	.word	0x0801ee9d
 801ecfc:	0801ee9d 	.word	0x0801ee9d
 801ed00:	0801ee9d 	.word	0x0801ee9d
 801ed04:	0801ee9d 	.word	0x0801ee9d
 801ed08:	0801ee9d 	.word	0x0801ee9d
 801ed0c:	0801ee9d 	.word	0x0801ee9d
 801ed10:	0801ee9d 	.word	0x0801ee9d
 801ed14:	0801ee9d 	.word	0x0801ee9d
 801ed18:	0801ee9d 	.word	0x0801ee9d
 801ed1c:	0801ee9d 	.word	0x0801ee9d
 801ed20:	0801ee9d 	.word	0x0801ee9d
 801ed24:	0801ee9d 	.word	0x0801ee9d
 801ed28:	0801ee9d 	.word	0x0801ee9d
 801ed2c:	0801ee9d 	.word	0x0801ee9d
 801ed30:	0801ee9d 	.word	0x0801ee9d
 801ed34:	0801ee9d 	.word	0x0801ee9d
 801ed38:	0801ee9d 	.word	0x0801ee9d
 801ed3c:	0801ee9d 	.word	0x0801ee9d
 801ed40:	0801ee9d 	.word	0x0801ee9d
 801ed44:	0801ee9d 	.word	0x0801ee9d
 801ed48:	0801ee9d 	.word	0x0801ee9d
 801ed4c:	0801ee9d 	.word	0x0801ee9d
 801ed50:	0801ee9d 	.word	0x0801ee9d
 801ed54:	0801ee9d 	.word	0x0801ee9d
 801ed58:	0801ee9d 	.word	0x0801ee9d
 801ed5c:	0801ee9d 	.word	0x0801ee9d
 801ed60:	0801ee9d 	.word	0x0801ee9d
 801ed64:	0801ee9d 	.word	0x0801ee9d
 801ed68:	0801ee9d 	.word	0x0801ee9d
 801ed6c:	0801ee9d 	.word	0x0801ee9d
 801ed70:	0801ee9d 	.word	0x0801ee9d
 801ed74:	0801ee9d 	.word	0x0801ee9d
 801ed78:	0801ee9d 	.word	0x0801ee9d
 801ed7c:	0801ee9d 	.word	0x0801ee9d
 801ed80:	0801ee9d 	.word	0x0801ee9d
 801ed84:	0801ee9d 	.word	0x0801ee9d
 801ed88:	0801ee9d 	.word	0x0801ee9d
 801ed8c:	0801ee9d 	.word	0x0801ee9d
 801ed90:	0801ee9d 	.word	0x0801ee9d
 801ed94:	0801ee9d 	.word	0x0801ee9d
 801ed98:	0801ee9d 	.word	0x0801ee9d
 801ed9c:	0801ee8f 	.word	0x0801ee8f
        case ATT_EXCHANGE_MTU_REQUEST:
            response_len = handle_exchange_mtu_request(att_connection, request_buffer, request_len, response_buffer);
 801eda0:	88fa      	ldrh	r2, [r7, #6]
 801eda2:	683b      	ldr	r3, [r7, #0]
 801eda4:	68b9      	ldr	r1, [r7, #8]
 801eda6:	68f8      	ldr	r0, [r7, #12]
 801eda8:	f7fe fd9f 	bl	801d8ea <handle_exchange_mtu_request>
 801edac:	4603      	mov	r3, r0
 801edae:	82fb      	strh	r3, [r7, #22]
            break;
 801edb0:	e088      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_FIND_INFORMATION_REQUEST:
            response_len = handle_find_information_request(att_connection, request_buffer, request_len,response_buffer, response_buffer_size);
 801edb2:	88fa      	ldrh	r2, [r7, #6]
 801edb4:	8abb      	ldrh	r3, [r7, #20]
 801edb6:	9300      	str	r3, [sp, #0]
 801edb8:	683b      	ldr	r3, [r7, #0]
 801edba:	68b9      	ldr	r1, [r7, #8]
 801edbc:	68f8      	ldr	r0, [r7, #12]
 801edbe:	f7fe fe81 	bl	801dac4 <handle_find_information_request>
 801edc2:	4603      	mov	r3, r0
 801edc4:	82fb      	strh	r3, [r7, #22]
            break;
 801edc6:	e07d      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_FIND_BY_TYPE_VALUE_REQUEST:
            response_len = handle_find_by_type_value_request(att_connection, request_buffer, request_len, response_buffer, response_buffer_size);
 801edc8:	88fa      	ldrh	r2, [r7, #6]
 801edca:	8abb      	ldrh	r3, [r7, #20]
 801edcc:	9300      	str	r3, [sp, #0]
 801edce:	683b      	ldr	r3, [r7, #0]
 801edd0:	68b9      	ldr	r1, [r7, #8]
 801edd2:	68f8      	ldr	r0, [r7, #12]
 801edd4:	f7fe fea2 	bl	801db1c <handle_find_by_type_value_request>
 801edd8:	4603      	mov	r3, r0
 801edda:	82fb      	strh	r3, [r7, #22]
            break;
 801eddc:	e072      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_READ_BY_TYPE_REQUEST:  
            response_len = handle_read_by_type_request(att_connection, request_buffer, request_len, response_buffer, response_buffer_size);
 801edde:	88fa      	ldrh	r2, [r7, #6]
 801ede0:	8abb      	ldrh	r3, [r7, #20]
 801ede2:	9300      	str	r3, [sp, #0]
 801ede4:	683b      	ldr	r3, [r7, #0]
 801ede6:	68b9      	ldr	r1, [r7, #8]
 801ede8:	68f8      	ldr	r0, [r7, #12]
 801edea:	f7ff f8a7 	bl	801df3c <handle_read_by_type_request>
 801edee:	4603      	mov	r3, r0
 801edf0:	82fb      	strh	r3, [r7, #22]
            break;
 801edf2:	e067      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_READ_REQUEST:  
            response_len = handle_read_request(att_connection, request_buffer, request_len, response_buffer, response_buffer_size);
 801edf4:	88fa      	ldrh	r2, [r7, #6]
 801edf6:	8abb      	ldrh	r3, [r7, #20]
 801edf8:	9300      	str	r3, [sp, #0]
 801edfa:	683b      	ldr	r3, [r7, #0]
 801edfc:	68b9      	ldr	r1, [r7, #8]
 801edfe:	68f8      	ldr	r0, [r7, #12]
 801ee00:	f7ff f960 	bl	801e0c4 <handle_read_request>
 801ee04:	4603      	mov	r3, r0
 801ee06:	82fb      	strh	r3, [r7, #22]
            break;
 801ee08:	e05c      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_READ_BLOB_REQUEST:  
            response_len = handle_read_blob_request(att_connection, request_buffer, request_len, response_buffer, response_buffer_size);
 801ee0a:	88fa      	ldrh	r2, [r7, #6]
 801ee0c:	8abb      	ldrh	r3, [r7, #20]
 801ee0e:	9300      	str	r3, [sp, #0]
 801ee10:	683b      	ldr	r3, [r7, #0]
 801ee12:	68b9      	ldr	r1, [r7, #8]
 801ee14:	68f8      	ldr	r0, [r7, #12]
 801ee16:	f7ff fa19 	bl	801e24c <handle_read_blob_request>
 801ee1a:	4603      	mov	r3, r0
 801ee1c:	82fb      	strh	r3, [r7, #22]
            break;
 801ee1e:	e051      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_READ_MULTIPLE_REQUEST:  
            response_len = handle_read_multiple_request(att_connection, request_buffer, request_len, response_buffer, response_buffer_size);
 801ee20:	88fa      	ldrh	r2, [r7, #6]
 801ee22:	8abb      	ldrh	r3, [r7, #20]
 801ee24:	9300      	str	r3, [sp, #0]
 801ee26:	683b      	ldr	r3, [r7, #0]
 801ee28:	68b9      	ldr	r1, [r7, #8]
 801ee2a:	68f8      	ldr	r0, [r7, #12]
 801ee2c:	f7ff faf0 	bl	801e410 <handle_read_multiple_request>
 801ee30:	4603      	mov	r3, r0
 801ee32:	82fb      	strh	r3, [r7, #22]
            break;
 801ee34:	e046      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_READ_BY_GROUP_TYPE_REQUEST:  
            response_len = handle_read_by_group_type_request(att_connection, request_buffer, request_len, response_buffer, response_buffer_size);
 801ee36:	88fa      	ldrh	r2, [r7, #6]
 801ee38:	8abb      	ldrh	r3, [r7, #20]
 801ee3a:	9300      	str	r3, [sp, #0]
 801ee3c:	683b      	ldr	r3, [r7, #0]
 801ee3e:	68b9      	ldr	r1, [r7, #8]
 801ee40:	68f8      	ldr	r0, [r7, #12]
 801ee42:	f7ff fc1b 	bl	801e67c <handle_read_by_group_type_request>
 801ee46:	4603      	mov	r3, r0
 801ee48:	82fb      	strh	r3, [r7, #22]
            break;
 801ee4a:	e03b      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_WRITE_REQUEST:
            response_len = handle_write_request(att_connection, request_buffer, request_len, response_buffer, response_buffer_size);
 801ee4c:	88fa      	ldrh	r2, [r7, #6]
 801ee4e:	8abb      	ldrh	r3, [r7, #20]
 801ee50:	9300      	str	r3, [sp, #0]
 801ee52:	683b      	ldr	r3, [r7, #0]
 801ee54:	68b9      	ldr	r1, [r7, #8]
 801ee56:	68f8      	ldr	r0, [r7, #12]
 801ee58:	f7ff fc4a 	bl	801e6f0 <handle_write_request>
 801ee5c:	4603      	mov	r3, r0
 801ee5e:	82fb      	strh	r3, [r7, #22]
            break;
 801ee60:	e030      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_PREPARE_WRITE_REQUEST:
            response_len = handle_prepare_write_request(att_connection, request_buffer, request_len, response_buffer, response_buffer_size);
 801ee62:	88fa      	ldrh	r2, [r7, #6]
 801ee64:	8abb      	ldrh	r3, [r7, #20]
 801ee66:	9300      	str	r3, [sp, #0]
 801ee68:	683b      	ldr	r3, [r7, #0]
 801ee6a:	68b9      	ldr	r1, [r7, #8]
 801ee6c:	68f8      	ldr	r0, [r7, #12]
 801ee6e:	f7ff fce5 	bl	801e83c <handle_prepare_write_request>
 801ee72:	4603      	mov	r3, r0
 801ee74:	82fb      	strh	r3, [r7, #22]
            break;
 801ee76:	e025      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_EXECUTE_WRITE_REQUEST:
            response_len = handle_execute_write_request(att_connection, request_buffer, request_len, response_buffer, response_buffer_size);
 801ee78:	88fa      	ldrh	r2, [r7, #6]
 801ee7a:	8abb      	ldrh	r3, [r7, #20]
 801ee7c:	9300      	str	r3, [sp, #0]
 801ee7e:	683b      	ldr	r3, [r7, #0]
 801ee80:	68b9      	ldr	r1, [r7, #8]
 801ee82:	68f8      	ldr	r0, [r7, #12]
 801ee84:	f7ff fdba 	bl	801e9fc <handle_execute_write_request>
 801ee88:	4603      	mov	r3, r0
 801ee8a:	82fb      	strh	r3, [r7, #22]
            break;
 801ee8c:	e01a      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_WRITE_COMMAND:
            handle_write_command(att_connection, request_buffer, request_len, ATT_PROPERTY_WRITE_WITHOUT_RESPONSE);
 801ee8e:	88fa      	ldrh	r2, [r7, #6]
 801ee90:	2304      	movs	r3, #4
 801ee92:	68b9      	ldr	r1, [r7, #8]
 801ee94:	68f8      	ldr	r0, [r7, #12]
 801ee96:	f7ff fe29 	bl	801eaec <handle_write_command>
            break;
 801ee9a:	e013      	b.n	801eec4 <att_handle_request+0x294>
        case ATT_SIGNED_WRITE_COMMAND:
            handle_write_command(att_connection, request_buffer, request_len, ATT_PROPERTY_AUTHENTICATED_SIGNED_WRITE);
            break;
#endif
        default:
            log_info("Unhandled ATT Command: %02X, DATA: ", request_buffer[0]);
 801ee9c:	68bb      	ldr	r3, [r7, #8]
 801ee9e:	781b      	ldrb	r3, [r3, #0]
 801eea0:	9300      	str	r3, [sp, #0]
 801eea2:	f44f 6398 	mov.w	r3, #1216	; 0x4c0
 801eea6:	4a0a      	ldr	r2, [pc, #40]	; (801eed0 <att_handle_request+0x2a0>)
 801eea8:	490a      	ldr	r1, [pc, #40]	; (801eed4 <att_handle_request+0x2a4>)
 801eeaa:	2001      	movs	r0, #1
 801eeac:	f7f8 fac8 	bl	8017440 <hci_dump_log>
            log_info_hexdump(&request_buffer[9u], request_len-9u);
 801eeb0:	68bb      	ldr	r3, [r7, #8]
 801eeb2:	f103 0209 	add.w	r2, r3, #9
 801eeb6:	88fb      	ldrh	r3, [r7, #6]
 801eeb8:	3b09      	subs	r3, #9
 801eeba:	4619      	mov	r1, r3
 801eebc:	4610      	mov	r0, r2
 801eebe:	f7f0 fa4b 	bl	800f358 <log_info_hexdump>
            break;
 801eec2:	bf00      	nop
    }
    return response_len;
 801eec4:	8afb      	ldrh	r3, [r7, #22]
}
 801eec6:	4618      	mov	r0, r3
 801eec8:	3718      	adds	r7, #24
 801eeca:	46bd      	mov	sp, r7
 801eecc:	bd80      	pop	{r7, pc}
 801eece:	bf00      	nop
 801eed0:	0802cb8c 	.word	0x0802cb8c
 801eed4:	0802cea8 	.word	0x0802cea8

0801eed8 <att_persistent_ccc_cache>:
    return 0;
}


// 1-item cache to optimize query during write_callback
static void att_persistent_ccc_cache(att_iterator_t * it){
 801eed8:	b580      	push	{r7, lr}
 801eeda:	b082      	sub	sp, #8
 801eedc:	af00      	add	r7, sp, #0
 801eede:	6078      	str	r0, [r7, #4]
    att_persistent_ccc_handle = it->handle;
 801eee0:	687b      	ldr	r3, [r7, #4]
 801eee2:	891a      	ldrh	r2, [r3, #8]
 801eee4:	4b0c      	ldr	r3, [pc, #48]	; (801ef18 <att_persistent_ccc_cache+0x40>)
 801eee6:	801a      	strh	r2, [r3, #0]
    if (it->flags & ATT_PROPERTY_UUID128){
 801eee8:	687b      	ldr	r3, [r7, #4]
 801eeea:	88db      	ldrh	r3, [r3, #6]
 801eeec:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801eef0:	2b00      	cmp	r3, #0
 801eef2:	d003      	beq.n	801eefc <att_persistent_ccc_cache+0x24>
        att_persistent_ccc_uuid16 = 0;
 801eef4:	4b09      	ldr	r3, [pc, #36]	; (801ef1c <att_persistent_ccc_cache+0x44>)
 801eef6:	2200      	movs	r2, #0
 801eef8:	801a      	strh	r2, [r3, #0]
    } else {
        att_persistent_ccc_uuid16 = little_endian_read_16(it->uuid, 0);
    }
}
 801eefa:	e009      	b.n	801ef10 <att_persistent_ccc_cache+0x38>
        att_persistent_ccc_uuid16 = little_endian_read_16(it->uuid, 0);
 801eefc:	687b      	ldr	r3, [r7, #4]
 801eefe:	68db      	ldr	r3, [r3, #12]
 801ef00:	2100      	movs	r1, #0
 801ef02:	4618      	mov	r0, r3
 801ef04:	f7ef ff6f 	bl	800ede6 <little_endian_read_16>
 801ef08:	4603      	mov	r3, r0
 801ef0a:	461a      	mov	r2, r3
 801ef0c:	4b03      	ldr	r3, [pc, #12]	; (801ef1c <att_persistent_ccc_cache+0x44>)
 801ef0e:	801a      	strh	r2, [r3, #0]
}
 801ef10:	bf00      	nop
 801ef12:	3708      	adds	r7, #8
 801ef14:	46bd      	mov	sp, r7
 801ef16:	bd80      	pop	{r7, pc}
 801ef18:	20009ef2 	.word	0x20009ef2
 801ef1c:	20009ef4 	.word	0x20009ef4

0801ef20 <att_is_persistent_ccc>:

bool att_is_persistent_ccc(uint16_t handle){
 801ef20:	b580      	push	{r7, lr}
 801ef22:	b08a      	sub	sp, #40	; 0x28
 801ef24:	af00      	add	r7, sp, #0
 801ef26:	4603      	mov	r3, r0
 801ef28:	80fb      	strh	r3, [r7, #6]
    if (handle != att_persistent_ccc_handle){
 801ef2a:	4b12      	ldr	r3, [pc, #72]	; (801ef74 <att_is_persistent_ccc+0x54>)
 801ef2c:	881b      	ldrh	r3, [r3, #0]
 801ef2e:	88fa      	ldrh	r2, [r7, #6]
 801ef30:	429a      	cmp	r2, r3
 801ef32:	d011      	beq.n	801ef58 <att_is_persistent_ccc+0x38>
        att_iterator_t it;
        int ok = att_find_handle(&it, handle);
 801ef34:	88fa      	ldrh	r2, [r7, #6]
 801ef36:	f107 030c 	add.w	r3, r7, #12
 801ef3a:	4611      	mov	r1, r2
 801ef3c:	4618      	mov	r0, r3
 801ef3e:	f7fe fa97 	bl	801d470 <att_find_handle>
 801ef42:	6278      	str	r0, [r7, #36]	; 0x24
        if (!ok) return false;
 801ef44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ef46:	2b00      	cmp	r3, #0
 801ef48:	d101      	bne.n	801ef4e <att_is_persistent_ccc+0x2e>
 801ef4a:	2300      	movs	r3, #0
 801ef4c:	e00d      	b.n	801ef6a <att_is_persistent_ccc+0x4a>
        att_persistent_ccc_cache(&it);
 801ef4e:	f107 030c 	add.w	r3, r7, #12
 801ef52:	4618      	mov	r0, r3
 801ef54:	f7ff ffc0 	bl	801eed8 <att_persistent_ccc_cache>
    }
    return att_persistent_ccc_uuid16 == GATT_CLIENT_CHARACTERISTICS_CONFIGURATION;
 801ef58:	4b07      	ldr	r3, [pc, #28]	; (801ef78 <att_is_persistent_ccc+0x58>)
 801ef5a:	881b      	ldrh	r3, [r3, #0]
 801ef5c:	f642 1202 	movw	r2, #10498	; 0x2902
 801ef60:	4293      	cmp	r3, r2
 801ef62:	bf0c      	ite	eq
 801ef64:	2301      	moveq	r3, #1
 801ef66:	2300      	movne	r3, #0
 801ef68:	b2db      	uxtb	r3, r3
}
 801ef6a:	4618      	mov	r0, r3
 801ef6c:	3728      	adds	r7, #40	; 0x28
 801ef6e:	46bd      	mov	sp, r7
 801ef70:	bd80      	pop	{r7, pc}
 801ef72:	bf00      	nop
 801ef74:	20009ef2 	.word	0x20009ef2
 801ef78:	20009ef4 	.word	0x20009ef4

0801ef7c <att_packet_handler>:
static uint8_t att_round_robin;

// track can send now requests
static uint8_t can_send_now_pending;

static void att_packet_handler(uint8_t packet_type, uint16_t handle, uint8_t *packet, uint16_t size){
 801ef7c:	b590      	push	{r4, r7, lr}
 801ef7e:	b087      	sub	sp, #28
 801ef80:	af00      	add	r7, sp, #0
 801ef82:	60ba      	str	r2, [r7, #8]
 801ef84:	461a      	mov	r2, r3
 801ef86:	4603      	mov	r3, r0
 801ef88:	73fb      	strb	r3, [r7, #15]
 801ef8a:	460b      	mov	r3, r1
 801ef8c:	81bb      	strh	r3, [r7, #12]
 801ef8e:	4613      	mov	r3, r2
 801ef90:	80fb      	strh	r3, [r7, #6]
    uint8_t index;
    uint8_t i;
    switch (packet_type){
 801ef92:	7bfb      	ldrb	r3, [r7, #15]
 801ef94:	2b04      	cmp	r3, #4
 801ef96:	d017      	beq.n	801efc8 <att_packet_handler+0x4c>
 801ef98:	2b08      	cmp	r3, #8
 801ef9a:	d000      	beq.n	801ef9e <att_packet_handler+0x22>
                    }
                }
            }
            break;
        default:
            break;
 801ef9c:	e080      	b.n	801f0a0 <att_packet_handler+0x124>
            index = packet[0u] & 1u;
 801ef9e:	68bb      	ldr	r3, [r7, #8]
 801efa0:	781b      	ldrb	r3, [r3, #0]
 801efa2:	f003 0301 	and.w	r3, r3, #1
 801efa6:	75bb      	strb	r3, [r7, #22]
            if (!subscriptions[index].packet_handler) return;
 801efa8:	7dbb      	ldrb	r3, [r7, #22]
 801efaa:	4a3f      	ldr	r2, [pc, #252]	; (801f0a8 <att_packet_handler+0x12c>)
 801efac:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 801efb0:	2b00      	cmp	r3, #0
 801efb2:	d070      	beq.n	801f096 <att_packet_handler+0x11a>
            subscriptions[index].packet_handler(packet_type, handle, packet, size);
 801efb4:	7dbb      	ldrb	r3, [r7, #22]
 801efb6:	4a3c      	ldr	r2, [pc, #240]	; (801f0a8 <att_packet_handler+0x12c>)
 801efb8:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
 801efbc:	88fb      	ldrh	r3, [r7, #6]
 801efbe:	89b9      	ldrh	r1, [r7, #12]
 801efc0:	7bf8      	ldrb	r0, [r7, #15]
 801efc2:	68ba      	ldr	r2, [r7, #8]
 801efc4:	47a0      	blx	r4
            break;
 801efc6:	e06b      	b.n	801f0a0 <att_packet_handler+0x124>
            if (packet[0] != L2CAP_EVENT_CAN_SEND_NOW) break;
 801efc8:	68bb      	ldr	r3, [r7, #8]
 801efca:	781b      	ldrb	r3, [r3, #0]
 801efcc:	2b78      	cmp	r3, #120	; 0x78
 801efce:	d164      	bne.n	801f09a <att_packet_handler+0x11e>
            can_send_now_pending = 0;
 801efd0:	4b36      	ldr	r3, [pc, #216]	; (801f0ac <att_packet_handler+0x130>)
 801efd2:	2200      	movs	r2, #0
 801efd4:	701a      	strb	r2, [r3, #0]
            for (i = 0; i < ATT_MAX; i++){
 801efd6:	2300      	movs	r3, #0
 801efd8:	75fb      	strb	r3, [r7, #23]
 801efda:	e033      	b.n	801f044 <att_packet_handler+0xc8>
                index = (att_round_robin + i) & 1u;
 801efdc:	4b34      	ldr	r3, [pc, #208]	; (801f0b0 <att_packet_handler+0x134>)
 801efde:	781a      	ldrb	r2, [r3, #0]
 801efe0:	7dfb      	ldrb	r3, [r7, #23]
 801efe2:	4413      	add	r3, r2
 801efe4:	b2db      	uxtb	r3, r3
 801efe6:	f003 0301 	and.w	r3, r3, #1
 801efea:	75bb      	strb	r3, [r7, #22]
                if (subscriptions[index].packet_handler && subscriptions[index].waiting_for_can_send){
 801efec:	7dbb      	ldrb	r3, [r7, #22]
 801efee:	4a2e      	ldr	r2, [pc, #184]	; (801f0a8 <att_packet_handler+0x12c>)
 801eff0:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 801eff4:	2b00      	cmp	r3, #0
 801eff6:	d022      	beq.n	801f03e <att_packet_handler+0xc2>
 801eff8:	7dbb      	ldrb	r3, [r7, #22]
 801effa:	4a2b      	ldr	r2, [pc, #172]	; (801f0a8 <att_packet_handler+0x12c>)
 801effc:	00db      	lsls	r3, r3, #3
 801effe:	4413      	add	r3, r2
 801f000:	791b      	ldrb	r3, [r3, #4]
 801f002:	2b00      	cmp	r3, #0
 801f004:	d01b      	beq.n	801f03e <att_packet_handler+0xc2>
                    subscriptions[index].waiting_for_can_send = 0;
 801f006:	7dbb      	ldrb	r3, [r7, #22]
 801f008:	4a27      	ldr	r2, [pc, #156]	; (801f0a8 <att_packet_handler+0x12c>)
 801f00a:	00db      	lsls	r3, r3, #3
 801f00c:	4413      	add	r3, r2
 801f00e:	2200      	movs	r2, #0
 801f010:	711a      	strb	r2, [r3, #4]
                    subscriptions[index].packet_handler(packet_type, handle, packet, size);
 801f012:	7dbb      	ldrb	r3, [r7, #22]
 801f014:	4a24      	ldr	r2, [pc, #144]	; (801f0a8 <att_packet_handler+0x12c>)
 801f016:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
 801f01a:	88fb      	ldrh	r3, [r7, #6]
 801f01c:	89b9      	ldrh	r1, [r7, #12]
 801f01e:	7bf8      	ldrb	r0, [r7, #15]
 801f020:	68ba      	ldr	r2, [r7, #8]
 801f022:	47a0      	blx	r4
                    att_round_robin = (index + 1u) % ATT_MAX;
 801f024:	7dbb      	ldrb	r3, [r7, #22]
 801f026:	3301      	adds	r3, #1
 801f028:	b2db      	uxtb	r3, r3
 801f02a:	f003 0301 	and.w	r3, r3, #1
 801f02e:	b2da      	uxtb	r2, r3
 801f030:	4b1f      	ldr	r3, [pc, #124]	; (801f0b0 <att_packet_handler+0x134>)
 801f032:	701a      	strb	r2, [r3, #0]
                    if (!hci_can_send_acl_le_packet_now()) break;
 801f034:	f7f0 ffa6 	bl	800ff84 <hci_can_send_acl_le_packet_now>
 801f038:	4603      	mov	r3, r0
 801f03a:	2b00      	cmp	r3, #0
 801f03c:	d006      	beq.n	801f04c <att_packet_handler+0xd0>
            for (i = 0; i < ATT_MAX; i++){
 801f03e:	7dfb      	ldrb	r3, [r7, #23]
 801f040:	3301      	adds	r3, #1
 801f042:	75fb      	strb	r3, [r7, #23]
 801f044:	7dfb      	ldrb	r3, [r7, #23]
 801f046:	2b01      	cmp	r3, #1
 801f048:	d9c8      	bls.n	801efdc <att_packet_handler+0x60>
 801f04a:	e000      	b.n	801f04e <att_packet_handler+0xd2>
                    if (!hci_can_send_acl_le_packet_now()) break;
 801f04c:	bf00      	nop
            if (!can_send_now_pending){
 801f04e:	4b17      	ldr	r3, [pc, #92]	; (801f0ac <att_packet_handler+0x130>)
 801f050:	781b      	ldrb	r3, [r3, #0]
 801f052:	2b00      	cmp	r3, #0
 801f054:	d123      	bne.n	801f09e <att_packet_handler+0x122>
                for (i = 0; i < ATT_MAX; i++){
 801f056:	2300      	movs	r3, #0
 801f058:	75fb      	strb	r3, [r7, #23]
 801f05a:	e018      	b.n	801f08e <att_packet_handler+0x112>
                    if (subscriptions[i].packet_handler && subscriptions[i].waiting_for_can_send){
 801f05c:	7dfb      	ldrb	r3, [r7, #23]
 801f05e:	4a12      	ldr	r2, [pc, #72]	; (801f0a8 <att_packet_handler+0x12c>)
 801f060:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 801f064:	2b00      	cmp	r3, #0
 801f066:	d00f      	beq.n	801f088 <att_packet_handler+0x10c>
 801f068:	7dfb      	ldrb	r3, [r7, #23]
 801f06a:	4a0f      	ldr	r2, [pc, #60]	; (801f0a8 <att_packet_handler+0x12c>)
 801f06c:	00db      	lsls	r3, r3, #3
 801f06e:	4413      	add	r3, r2
 801f070:	791b      	ldrb	r3, [r3, #4]
 801f072:	2b00      	cmp	r3, #0
 801f074:	d008      	beq.n	801f088 <att_packet_handler+0x10c>
                        can_send_now_pending = 1;        
 801f076:	4b0d      	ldr	r3, [pc, #52]	; (801f0ac <att_packet_handler+0x130>)
 801f078:	2201      	movs	r2, #1
 801f07a:	701a      	strb	r2, [r3, #0]
                        l2cap_request_can_send_fix_channel_now_event(0, L2CAP_CID_ATTRIBUTE_PROTOCOL);
 801f07c:	2104      	movs	r1, #4
 801f07e:	2000      	movs	r0, #0
 801f080:	f7f9 fb04 	bl	801868c <l2cap_request_can_send_fix_channel_now_event>
                        break;
 801f084:	bf00      	nop
            break;
 801f086:	e00a      	b.n	801f09e <att_packet_handler+0x122>
                for (i = 0; i < ATT_MAX; i++){
 801f088:	7dfb      	ldrb	r3, [r7, #23]
 801f08a:	3301      	adds	r3, #1
 801f08c:	75fb      	strb	r3, [r7, #23]
 801f08e:	7dfb      	ldrb	r3, [r7, #23]
 801f090:	2b01      	cmp	r3, #1
 801f092:	d9e3      	bls.n	801f05c <att_packet_handler+0xe0>
            break;
 801f094:	e003      	b.n	801f09e <att_packet_handler+0x122>
            if (!subscriptions[index].packet_handler) return;
 801f096:	bf00      	nop
 801f098:	e002      	b.n	801f0a0 <att_packet_handler+0x124>
            if (packet[0] != L2CAP_EVENT_CAN_SEND_NOW) break;
 801f09a:	bf00      	nop
 801f09c:	e000      	b.n	801f0a0 <att_packet_handler+0x124>
            break;
 801f09e:	bf00      	nop
    }
}
 801f0a0:	371c      	adds	r7, #28
 801f0a2:	46bd      	mov	sp, r7
 801f0a4:	bd90      	pop	{r4, r7, pc}
 801f0a6:	bf00      	nop
 801f0a8:	2000a6f4 	.word	0x2000a6f4
 801f0ac:	20009ef7 	.word	0x20009ef7
 801f0b0:	20009ef6 	.word	0x20009ef6

0801f0b4 <att_dispatch_register_server>:

/**
 * @brief reset att dispatchter
 * @param packet_hander for ATT server packets
 */
void att_dispatch_register_server(btstack_packet_handler_t packet_handler){
 801f0b4:	b580      	push	{r7, lr}
 801f0b6:	b082      	sub	sp, #8
 801f0b8:	af00      	add	r7, sp, #0
 801f0ba:	6078      	str	r0, [r7, #4]
    subscriptions[ATT_SERVER].packet_handler = packet_handler;
 801f0bc:	4a05      	ldr	r2, [pc, #20]	; (801f0d4 <att_dispatch_register_server+0x20>)
 801f0be:	687b      	ldr	r3, [r7, #4]
 801f0c0:	6013      	str	r3, [r2, #0]
    l2cap_register_fixed_channel(att_packet_handler, L2CAP_CID_ATTRIBUTE_PROTOCOL);
 801f0c2:	2104      	movs	r1, #4
 801f0c4:	4804      	ldr	r0, [pc, #16]	; (801f0d8 <att_dispatch_register_server+0x24>)
 801f0c6:	f7fd fce5 	bl	801ca94 <l2cap_register_fixed_channel>
}
 801f0ca:	bf00      	nop
 801f0cc:	3708      	adds	r7, #8
 801f0ce:	46bd      	mov	sp, r7
 801f0d0:	bd80      	pop	{r7, pc}
 801f0d2:	bf00      	nop
 801f0d4:	2000a6f4 	.word	0x2000a6f4
 801f0d8:	0801ef7d 	.word	0x0801ef7d

0801f0dc <att_dispatch_server_can_send_now>:

/**
 * @brief can send packet for server
 * @param handle
 */
int att_dispatch_server_can_send_now(hci_con_handle_t con_handle){
 801f0dc:	b580      	push	{r7, lr}
 801f0de:	b082      	sub	sp, #8
 801f0e0:	af00      	add	r7, sp, #0
 801f0e2:	4603      	mov	r3, r0
 801f0e4:	80fb      	strh	r3, [r7, #6]
    return l2cap_can_send_fixed_channel_packet_now(con_handle, L2CAP_CID_ATTRIBUTE_PROTOCOL);
 801f0e6:	88fb      	ldrh	r3, [r7, #6]
 801f0e8:	2104      	movs	r1, #4
 801f0ea:	4618      	mov	r0, r3
 801f0ec:	f7f9 fae8 	bl	80186c0 <l2cap_can_send_fixed_channel_packet_now>
 801f0f0:	4603      	mov	r3, r0
}
 801f0f2:	4618      	mov	r0, r3
 801f0f4:	3708      	adds	r7, #8
 801f0f6:	46bd      	mov	sp, r7
 801f0f8:	bd80      	pop	{r7, pc}
	...

0801f0fc <att_dispatch_server_request_can_send_now_event>:
 * @brief Request emission of L2CAP_EVENT_CAN_SEND_NOW as soon as possible for server
 * @note L2CAP_EVENT_CAN_SEND_NOW might be emitted during call to this function
 *       so packet handler should be ready to handle it
 * @param con_handle
 */
void att_dispatch_server_request_can_send_now_event(hci_con_handle_t con_handle){
 801f0fc:	b580      	push	{r7, lr}
 801f0fe:	b082      	sub	sp, #8
 801f100:	af00      	add	r7, sp, #0
 801f102:	4603      	mov	r3, r0
 801f104:	80fb      	strh	r3, [r7, #6]
    subscriptions[ATT_SERVER].waiting_for_can_send = 1;
 801f106:	4b09      	ldr	r3, [pc, #36]	; (801f12c <att_dispatch_server_request_can_send_now_event+0x30>)
 801f108:	2201      	movs	r2, #1
 801f10a:	711a      	strb	r2, [r3, #4]
    if (!can_send_now_pending){
 801f10c:	4b08      	ldr	r3, [pc, #32]	; (801f130 <att_dispatch_server_request_can_send_now_event+0x34>)
 801f10e:	781b      	ldrb	r3, [r3, #0]
 801f110:	2b00      	cmp	r3, #0
 801f112:	d107      	bne.n	801f124 <att_dispatch_server_request_can_send_now_event+0x28>
        can_send_now_pending = 1;        
 801f114:	4b06      	ldr	r3, [pc, #24]	; (801f130 <att_dispatch_server_request_can_send_now_event+0x34>)
 801f116:	2201      	movs	r2, #1
 801f118:	701a      	strb	r2, [r3, #0]
        l2cap_request_can_send_fix_channel_now_event(con_handle, L2CAP_CID_ATTRIBUTE_PROTOCOL);
 801f11a:	88fb      	ldrh	r3, [r7, #6]
 801f11c:	2104      	movs	r1, #4
 801f11e:	4618      	mov	r0, r3
 801f120:	f7f9 fab4 	bl	801868c <l2cap_request_can_send_fix_channel_now_event>
    }
}
 801f124:	bf00      	nop
 801f126:	3708      	adds	r7, #8
 801f128:	46bd      	mov	sp, r7
 801f12a:	bd80      	pop	{r7, pc}
 801f12c:	2000a6f4 	.word	0x2000a6f4
 801f130:	20009ef7 	.word	0x20009ef7

0801f134 <emit_mtu_exchange_complete>:

static void emit_mtu_exchange_complete(btstack_packet_handler_t packet_handler, hci_con_handle_t con_handle, uint16_t new_mtu){
 801f134:	b590      	push	{r4, r7, lr}
 801f136:	b085      	sub	sp, #20
 801f138:	af00      	add	r7, sp, #0
 801f13a:	6078      	str	r0, [r7, #4]
 801f13c:	460b      	mov	r3, r1
 801f13e:	807b      	strh	r3, [r7, #2]
 801f140:	4613      	mov	r3, r2
 801f142:	803b      	strh	r3, [r7, #0]
    if (!packet_handler) return;
 801f144:	687b      	ldr	r3, [r7, #4]
 801f146:	2b00      	cmp	r3, #0
 801f148:	d019      	beq.n	801f17e <emit_mtu_exchange_complete+0x4a>
    uint8_t packet[6];
    packet[0] = ATT_EVENT_MTU_EXCHANGE_COMPLETE;
 801f14a:	23b5      	movs	r3, #181	; 0xb5
 801f14c:	723b      	strb	r3, [r7, #8]
    packet[1] = sizeof(packet) - 2u;
 801f14e:	2304      	movs	r3, #4
 801f150:	727b      	strb	r3, [r7, #9]
    little_endian_store_16(packet, 2, con_handle);
 801f152:	887a      	ldrh	r2, [r7, #2]
 801f154:	f107 0308 	add.w	r3, r7, #8
 801f158:	2102      	movs	r1, #2
 801f15a:	4618      	mov	r0, r3
 801f15c:	f7ef fe83 	bl	800ee66 <little_endian_store_16>
    little_endian_store_16(packet, 4, new_mtu);
 801f160:	883a      	ldrh	r2, [r7, #0]
 801f162:	f107 0308 	add.w	r3, r7, #8
 801f166:	2104      	movs	r1, #4
 801f168:	4618      	mov	r0, r3
 801f16a:	f7ef fe7c 	bl	800ee66 <little_endian_store_16>
    packet_handler(HCI_EVENT_PACKET, con_handle, packet, 6);
 801f16e:	f107 0208 	add.w	r2, r7, #8
 801f172:	8879      	ldrh	r1, [r7, #2]
 801f174:	687c      	ldr	r4, [r7, #4]
 801f176:	2306      	movs	r3, #6
 801f178:	2004      	movs	r0, #4
 801f17a:	47a0      	blx	r4
 801f17c:	e000      	b.n	801f180 <emit_mtu_exchange_complete+0x4c>
    if (!packet_handler) return;
 801f17e:	bf00      	nop
}
 801f180:	3714      	adds	r7, #20
 801f182:	46bd      	mov	sp, r7
 801f184:	bd90      	pop	{r4, r7, pc}
	...

0801f188 <att_dispatch_server_mtu_exchanged>:

void att_dispatch_server_mtu_exchanged(hci_con_handle_t con_handle, uint16_t new_mtu){
 801f188:	b580      	push	{r7, lr}
 801f18a:	b082      	sub	sp, #8
 801f18c:	af00      	add	r7, sp, #0
 801f18e:	4603      	mov	r3, r0
 801f190:	460a      	mov	r2, r1
 801f192:	80fb      	strh	r3, [r7, #6]
 801f194:	4613      	mov	r3, r2
 801f196:	80bb      	strh	r3, [r7, #4]
    emit_mtu_exchange_complete(subscriptions[ATT_CLIENT].packet_handler, con_handle, new_mtu);
 801f198:	4b05      	ldr	r3, [pc, #20]	; (801f1b0 <att_dispatch_server_mtu_exchanged+0x28>)
 801f19a:	689b      	ldr	r3, [r3, #8]
 801f19c:	88ba      	ldrh	r2, [r7, #4]
 801f19e:	88f9      	ldrh	r1, [r7, #6]
 801f1a0:	4618      	mov	r0, r3
 801f1a2:	f7ff ffc7 	bl	801f134 <emit_mtu_exchange_complete>
}
 801f1a6:	bf00      	nop
 801f1a8:	3708      	adds	r7, #8
 801f1aa:	46bd      	mov	sp, r7
 801f1ac:	bd80      	pop	{r7, pc}
 801f1ae:	bf00      	nop
 801f1b0:	2000a6f4 	.word	0x2000a6f4

0801f1b4 <hci_event_packet_get_type>:
static inline uint8_t hci_event_packet_get_type(const uint8_t * event){
 801f1b4:	b480      	push	{r7}
 801f1b6:	b083      	sub	sp, #12
 801f1b8:	af00      	add	r7, sp, #0
 801f1ba:	6078      	str	r0, [r7, #4]
    return event[0];
 801f1bc:	687b      	ldr	r3, [r7, #4]
 801f1be:	781b      	ldrb	r3, [r3, #0]
}
 801f1c0:	4618      	mov	r0, r3
 801f1c2:	370c      	adds	r7, #12
 801f1c4:	46bd      	mov	sp, r7
 801f1c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f1ca:	4770      	bx	lr

0801f1cc <hci_event_disconnection_complete_get_connection_handle>:
static inline uint16_t hci_event_disconnection_complete_get_connection_handle(const uint8_t * event){
 801f1cc:	b580      	push	{r7, lr}
 801f1ce:	b082      	sub	sp, #8
 801f1d0:	af00      	add	r7, sp, #0
 801f1d2:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 3);
 801f1d4:	2103      	movs	r1, #3
 801f1d6:	6878      	ldr	r0, [r7, #4]
 801f1d8:	f7ef fe05 	bl	800ede6 <little_endian_read_16>
 801f1dc:	4603      	mov	r3, r0
}
 801f1de:	4618      	mov	r0, r3
 801f1e0:	3708      	adds	r7, #8
 801f1e2:	46bd      	mov	sp, r7
 801f1e4:	bd80      	pop	{r7, pc}

0801f1e6 <hci_event_encryption_change_get_encryption_enabled>:
static inline uint8_t hci_event_encryption_change_get_encryption_enabled(const uint8_t * event){
 801f1e6:	b480      	push	{r7}
 801f1e8:	b083      	sub	sp, #12
 801f1ea:	af00      	add	r7, sp, #0
 801f1ec:	6078      	str	r0, [r7, #4]
    return event[5];
 801f1ee:	687b      	ldr	r3, [r7, #4]
 801f1f0:	3305      	adds	r3, #5
 801f1f2:	781b      	ldrb	r3, [r3, #0]
}
 801f1f4:	4618      	mov	r0, r3
 801f1f6:	370c      	adds	r7, #12
 801f1f8:	46bd      	mov	sp, r7
 801f1fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f1fe:	4770      	bx	lr

0801f200 <sm_event_just_works_request_get_handle>:
static inline hci_con_handle_t sm_event_just_works_request_get_handle(const uint8_t * event){
 801f200:	b580      	push	{r7, lr}
 801f202:	b082      	sub	sp, #8
 801f204:	af00      	add	r7, sp, #0
 801f206:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 2);
 801f208:	2102      	movs	r1, #2
 801f20a:	6878      	ldr	r0, [r7, #4]
 801f20c:	f7ef fdeb 	bl	800ede6 <little_endian_read_16>
 801f210:	4603      	mov	r3, r0
}
 801f212:	4618      	mov	r0, r3
 801f214:	3708      	adds	r7, #8
 801f216:	46bd      	mov	sp, r7
 801f218:	bd80      	pop	{r7, pc}

0801f21a <sm_event_identity_resolving_started_get_handle>:
static inline hci_con_handle_t sm_event_identity_resolving_started_get_handle(const uint8_t * event){
 801f21a:	b580      	push	{r7, lr}
 801f21c:	b082      	sub	sp, #8
 801f21e:	af00      	add	r7, sp, #0
 801f220:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 2);
 801f222:	2102      	movs	r1, #2
 801f224:	6878      	ldr	r0, [r7, #4]
 801f226:	f7ef fdde 	bl	800ede6 <little_endian_read_16>
 801f22a:	4603      	mov	r3, r0
}
 801f22c:	4618      	mov	r0, r3
 801f22e:	3708      	adds	r7, #8
 801f230:	46bd      	mov	sp, r7
 801f232:	bd80      	pop	{r7, pc}

0801f234 <sm_event_identity_resolving_failed_get_handle>:
static inline hci_con_handle_t sm_event_identity_resolving_failed_get_handle(const uint8_t * event){
 801f234:	b580      	push	{r7, lr}
 801f236:	b082      	sub	sp, #8
 801f238:	af00      	add	r7, sp, #0
 801f23a:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 2);
 801f23c:	2102      	movs	r1, #2
 801f23e:	6878      	ldr	r0, [r7, #4]
 801f240:	f7ef fdd1 	bl	800ede6 <little_endian_read_16>
 801f244:	4603      	mov	r3, r0
}
 801f246:	4618      	mov	r0, r3
 801f248:	3708      	adds	r7, #8
 801f24a:	46bd      	mov	sp, r7
 801f24c:	bd80      	pop	{r7, pc}

0801f24e <sm_event_identity_resolving_succeeded_get_index>:
static inline uint16_t sm_event_identity_resolving_succeeded_get_index(const uint8_t * event){
 801f24e:	b580      	push	{r7, lr}
 801f250:	b082      	sub	sp, #8
 801f252:	af00      	add	r7, sp, #0
 801f254:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 18);
 801f256:	2112      	movs	r1, #18
 801f258:	6878      	ldr	r0, [r7, #4]
 801f25a:	f7ef fdc4 	bl	800ede6 <little_endian_read_16>
 801f25e:	4603      	mov	r3, r0
}
 801f260:	4618      	mov	r0, r3
 801f262:	3708      	adds	r7, #8
 801f264:	46bd      	mov	sp, r7
 801f266:	bd80      	pop	{r7, pc}

0801f268 <sm_event_authorization_result_get_handle>:
static inline hci_con_handle_t sm_event_authorization_result_get_handle(const uint8_t * event){
 801f268:	b580      	push	{r7, lr}
 801f26a:	b082      	sub	sp, #8
 801f26c:	af00      	add	r7, sp, #0
 801f26e:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 2);
 801f270:	2102      	movs	r1, #2
 801f272:	6878      	ldr	r0, [r7, #4]
 801f274:	f7ef fdb7 	bl	800ede6 <little_endian_read_16>
 801f278:	4603      	mov	r3, r0
}
 801f27a:	4618      	mov	r0, r3
 801f27c:	3708      	adds	r7, #8
 801f27e:	46bd      	mov	sp, r7
 801f280:	bd80      	pop	{r7, pc}

0801f282 <sm_event_authorization_result_get_authorization_result>:
static inline uint8_t sm_event_authorization_result_get_authorization_result(const uint8_t * event){
 801f282:	b480      	push	{r7}
 801f284:	b083      	sub	sp, #12
 801f286:	af00      	add	r7, sp, #0
 801f288:	6078      	str	r0, [r7, #4]
    return event[11];
 801f28a:	687b      	ldr	r3, [r7, #4]
 801f28c:	330b      	adds	r3, #11
 801f28e:	781b      	ldrb	r3, [r3, #0]
}
 801f290:	4618      	mov	r0, r3
 801f292:	370c      	adds	r7, #12
 801f294:	46bd      	mov	sp, r7
 801f296:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f29a:	4770      	bx	lr

0801f29c <sm_event_identity_created_get_handle>:
static inline hci_con_handle_t sm_event_identity_created_get_handle(const uint8_t * event){
 801f29c:	b580      	push	{r7, lr}
 801f29e:	b082      	sub	sp, #8
 801f2a0:	af00      	add	r7, sp, #0
 801f2a2:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 2);
 801f2a4:	2102      	movs	r1, #2
 801f2a6:	6878      	ldr	r0, [r7, #4]
 801f2a8:	f7ef fd9d 	bl	800ede6 <little_endian_read_16>
 801f2ac:	4603      	mov	r3, r0
}
 801f2ae:	4618      	mov	r0, r3
 801f2b0:	3708      	adds	r7, #8
 801f2b2:	46bd      	mov	sp, r7
 801f2b4:	bd80      	pop	{r7, pc}

0801f2b6 <sm_event_identity_created_get_index>:
static inline uint16_t sm_event_identity_created_get_index(const uint8_t * event){
 801f2b6:	b580      	push	{r7, lr}
 801f2b8:	b082      	sub	sp, #8
 801f2ba:	af00      	add	r7, sp, #0
 801f2bc:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 18);
 801f2be:	2112      	movs	r1, #18
 801f2c0:	6878      	ldr	r0, [r7, #4]
 801f2c2:	f7ef fd90 	bl	800ede6 <little_endian_read_16>
 801f2c6:	4603      	mov	r3, r0
}
 801f2c8:	4618      	mov	r0, r3
 801f2ca:	3708      	adds	r7, #8
 801f2cc:	46bd      	mov	sp, r7
 801f2ce:	bd80      	pop	{r7, pc}

0801f2d0 <sm_event_pairing_complete_get_handle>:
static inline hci_con_handle_t sm_event_pairing_complete_get_handle(const uint8_t * event){
 801f2d0:	b580      	push	{r7, lr}
 801f2d2:	b082      	sub	sp, #8
 801f2d4:	af00      	add	r7, sp, #0
 801f2d6:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 2);
 801f2d8:	2102      	movs	r1, #2
 801f2da:	6878      	ldr	r0, [r7, #4]
 801f2dc:	f7ef fd83 	bl	800ede6 <little_endian_read_16>
 801f2e0:	4603      	mov	r3, r0
}
 801f2e2:	4618      	mov	r0, r3
 801f2e4:	3708      	adds	r7, #8
 801f2e6:	46bd      	mov	sp, r7
 801f2e8:	bd80      	pop	{r7, pc}

0801f2ea <att_server_request_can_send_now>:
    }
    return NULL;
}
#endif

static void att_server_request_can_send_now(hci_connection_t * hci_connection){
 801f2ea:	b580      	push	{r7, lr}
 801f2ec:	b084      	sub	sp, #16
 801f2ee:	af00      	add	r7, sp, #0
 801f2f0:	6078      	str	r0, [r7, #4]
    if (att_server->l2cap_cid != 0){
        l2cap_request_can_send_now_event(att_server->l2cap_cid);
        return;
    }
#endif
    att_connection_t * att_connection = &hci_connection->att_connection;
 801f2f2:	687b      	ldr	r3, [r7, #4]
 801f2f4:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801f2f8:	60fb      	str	r3, [r7, #12]
    att_dispatch_server_request_can_send_now_event(att_connection->con_handle);
 801f2fa:	68fb      	ldr	r3, [r7, #12]
 801f2fc:	881b      	ldrh	r3, [r3, #0]
 801f2fe:	4618      	mov	r0, r3
 801f300:	f7ff fefc 	bl	801f0fc <att_dispatch_server_request_can_send_now_event>
}
 801f304:	bf00      	nop
 801f306:	3710      	adds	r7, #16
 801f308:	46bd      	mov	sp, r7
 801f30a:	bd80      	pop	{r7, pc}

0801f30c <att_server_can_send_packet>:

static bool att_server_can_send_packet(hci_connection_t * hci_connection){
 801f30c:	b580      	push	{r7, lr}
 801f30e:	b084      	sub	sp, #16
 801f310:	af00      	add	r7, sp, #0
 801f312:	6078      	str	r0, [r7, #4]
    att_server_t * att_server = &hci_connection->att_server;
    if (att_server->l2cap_cid != 0){
        return l2cap_can_send_packet_now(att_server->l2cap_cid) != 0;
    }
#endif
    att_connection_t * att_connection = &hci_connection->att_connection;
 801f314:	687b      	ldr	r3, [r7, #4]
 801f316:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801f31a:	60fb      	str	r3, [r7, #12]
    return att_dispatch_server_can_send_now(att_connection->con_handle) != 0;
 801f31c:	68fb      	ldr	r3, [r7, #12]
 801f31e:	881b      	ldrh	r3, [r3, #0]
 801f320:	4618      	mov	r0, r3
 801f322:	f7ff fedb 	bl	801f0dc <att_dispatch_server_can_send_now>
 801f326:	4603      	mov	r3, r0
 801f328:	2b00      	cmp	r3, #0
 801f32a:	bf14      	ite	ne
 801f32c:	2301      	movne	r3, #1
 801f32e:	2300      	moveq	r3, #0
 801f330:	b2db      	uxtb	r3, r3
}
 801f332:	4618      	mov	r0, r3
 801f334:	3710      	adds	r7, #16
 801f336:	46bd      	mov	sp, r7
 801f338:	bd80      	pop	{r7, pc}

0801f33a <att_handle_value_indication_notify_client>:

static void att_handle_value_indication_notify_client(uint8_t status, uint16_t client_handle, uint16_t attribute_handle){
 801f33a:	b590      	push	{r4, r7, lr}
 801f33c:	b087      	sub	sp, #28
 801f33e:	af00      	add	r7, sp, #0
 801f340:	4603      	mov	r3, r0
 801f342:	71fb      	strb	r3, [r7, #7]
 801f344:	460b      	mov	r3, r1
 801f346:	80bb      	strh	r3, [r7, #4]
 801f348:	4613      	mov	r3, r2
 801f34a:	807b      	strh	r3, [r7, #2]
    btstack_packet_handler_t packet_handler = att_server_packet_handler_for_handle(attribute_handle);
 801f34c:	887b      	ldrh	r3, [r7, #2]
 801f34e:	4618      	mov	r0, r3
 801f350:	f001 f8c6 	bl	80204e0 <att_server_packet_handler_for_handle>
 801f354:	6178      	str	r0, [r7, #20]
    if (!packet_handler) return;
 801f356:	697b      	ldr	r3, [r7, #20]
 801f358:	2b00      	cmp	r3, #0
 801f35a:	d037      	beq.n	801f3cc <att_handle_value_indication_notify_client+0x92>
    
    uint8_t event[7];
    int pos = 0;
 801f35c:	2300      	movs	r3, #0
 801f35e:	613b      	str	r3, [r7, #16]
    event[pos++] = ATT_EVENT_HANDLE_VALUE_INDICATION_COMPLETE;
 801f360:	693b      	ldr	r3, [r7, #16]
 801f362:	1c5a      	adds	r2, r3, #1
 801f364:	613a      	str	r2, [r7, #16]
 801f366:	f107 0218 	add.w	r2, r7, #24
 801f36a:	4413      	add	r3, r2
 801f36c:	22b6      	movs	r2, #182	; 0xb6
 801f36e:	f803 2c10 	strb.w	r2, [r3, #-16]
    event[pos++] = sizeof(event) - 2u;
 801f372:	693b      	ldr	r3, [r7, #16]
 801f374:	1c5a      	adds	r2, r3, #1
 801f376:	613a      	str	r2, [r7, #16]
 801f378:	f107 0218 	add.w	r2, r7, #24
 801f37c:	4413      	add	r3, r2
 801f37e:	2205      	movs	r2, #5
 801f380:	f803 2c10 	strb.w	r2, [r3, #-16]
    event[pos++] = status;
 801f384:	693b      	ldr	r3, [r7, #16]
 801f386:	1c5a      	adds	r2, r3, #1
 801f388:	613a      	str	r2, [r7, #16]
 801f38a:	f107 0218 	add.w	r2, r7, #24
 801f38e:	4413      	add	r3, r2
 801f390:	79fa      	ldrb	r2, [r7, #7]
 801f392:	f803 2c10 	strb.w	r2, [r3, #-16]
    little_endian_store_16(event, pos, client_handle);
 801f396:	693b      	ldr	r3, [r7, #16]
 801f398:	b299      	uxth	r1, r3
 801f39a:	88ba      	ldrh	r2, [r7, #4]
 801f39c:	f107 0308 	add.w	r3, r7, #8
 801f3a0:	4618      	mov	r0, r3
 801f3a2:	f7ef fd60 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 801f3a6:	693b      	ldr	r3, [r7, #16]
 801f3a8:	3302      	adds	r3, #2
 801f3aa:	613b      	str	r3, [r7, #16]
    little_endian_store_16(event, pos, attribute_handle);
 801f3ac:	693b      	ldr	r3, [r7, #16]
 801f3ae:	b299      	uxth	r1, r3
 801f3b0:	887a      	ldrh	r2, [r7, #2]
 801f3b2:	f107 0308 	add.w	r3, r7, #8
 801f3b6:	4618      	mov	r0, r3
 801f3b8:	f7ef fd55 	bl	800ee66 <little_endian_store_16>
    (*packet_handler)(HCI_EVENT_PACKET, 0, &event[0], sizeof(event));
 801f3bc:	f107 0208 	add.w	r2, r7, #8
 801f3c0:	697c      	ldr	r4, [r7, #20]
 801f3c2:	2307      	movs	r3, #7
 801f3c4:	2100      	movs	r1, #0
 801f3c6:	2004      	movs	r0, #4
 801f3c8:	47a0      	blx	r4
 801f3ca:	e000      	b.n	801f3ce <att_handle_value_indication_notify_client+0x94>
    if (!packet_handler) return;
 801f3cc:	bf00      	nop
}
 801f3ce:	371c      	adds	r7, #28
 801f3d0:	46bd      	mov	sp, r7
 801f3d2:	bd90      	pop	{r4, r7, pc}

0801f3d4 <att_emit_event_to_all>:

static void att_emit_event_to_all(const uint8_t * event, uint16_t size){
 801f3d4:	b590      	push	{r4, r7, lr}
 801f3d6:	b087      	sub	sp, #28
 801f3d8:	af00      	add	r7, sp, #0
 801f3da:	6078      	str	r0, [r7, #4]
 801f3dc:	460b      	mov	r3, r1
 801f3de:	807b      	strh	r3, [r7, #2]
    // dispatch to app level handler
    if (att_client_packet_handler != NULL){
 801f3e0:	4b17      	ldr	r3, [pc, #92]	; (801f440 <att_emit_event_to_all+0x6c>)
 801f3e2:	681b      	ldr	r3, [r3, #0]
 801f3e4:	2b00      	cmp	r3, #0
 801f3e6:	d006      	beq.n	801f3f6 <att_emit_event_to_all+0x22>
        (*att_client_packet_handler)(HCI_EVENT_PACKET, 0, (uint8_t*) event, size);
 801f3e8:	4b15      	ldr	r3, [pc, #84]	; (801f440 <att_emit_event_to_all+0x6c>)
 801f3ea:	681c      	ldr	r4, [r3, #0]
 801f3ec:	887b      	ldrh	r3, [r7, #2]
 801f3ee:	687a      	ldr	r2, [r7, #4]
 801f3f0:	2100      	movs	r1, #0
 801f3f2:	2004      	movs	r0, #4
 801f3f4:	47a0      	blx	r4
    }

    // dispatch to service handlers
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &service_handlers);
 801f3f6:	f107 0308 	add.w	r3, r7, #8
 801f3fa:	4912      	ldr	r1, [pc, #72]	; (801f444 <att_emit_event_to_all+0x70>)
 801f3fc:	4618      	mov	r0, r3
 801f3fe:	f7ef f9a6 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 801f402:	e011      	b.n	801f428 <att_emit_event_to_all+0x54>
        att_service_handler_t * handler = (att_service_handler_t*) btstack_linked_list_iterator_next(&it);
 801f404:	f107 0308 	add.w	r3, r7, #8
 801f408:	4618      	mov	r0, r3
 801f40a:	f7ef f9e3 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801f40e:	6178      	str	r0, [r7, #20]
        if (!handler->packet_handler) continue;
 801f410:	697b      	ldr	r3, [r7, #20]
 801f412:	691b      	ldr	r3, [r3, #16]
 801f414:	2b00      	cmp	r3, #0
 801f416:	d100      	bne.n	801f41a <att_emit_event_to_all+0x46>
 801f418:	e006      	b.n	801f428 <att_emit_event_to_all+0x54>
        (*handler->packet_handler)(HCI_EVENT_PACKET, 0, (uint8_t*) event, size);
 801f41a:	697b      	ldr	r3, [r7, #20]
 801f41c:	691c      	ldr	r4, [r3, #16]
 801f41e:	887b      	ldrh	r3, [r7, #2]
 801f420:	687a      	ldr	r2, [r7, #4]
 801f422:	2100      	movs	r1, #0
 801f424:	2004      	movs	r0, #4
 801f426:	47a0      	blx	r4
    while (btstack_linked_list_iterator_has_next(&it)){
 801f428:	f107 0308 	add.w	r3, r7, #8
 801f42c:	4618      	mov	r0, r3
 801f42e:	f7ef f9a3 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801f432:	4603      	mov	r3, r0
 801f434:	2b00      	cmp	r3, #0
 801f436:	d1e5      	bne.n	801f404 <att_emit_event_to_all+0x30>
    }
}
 801f438:	bf00      	nop
 801f43a:	371c      	adds	r7, #28
 801f43c:	46bd      	mov	sp, r7
 801f43e:	bd90      	pop	{r4, r7, pc}
 801f440:	20009f08 	.word	0x20009f08
 801f444:	20009f0c 	.word	0x20009f0c

0801f448 <att_emit_mtu_event>:

static void att_emit_mtu_event(hci_con_handle_t con_handle, uint16_t mtu){
 801f448:	b580      	push	{r7, lr}
 801f44a:	b086      	sub	sp, #24
 801f44c:	af00      	add	r7, sp, #0
 801f44e:	4603      	mov	r3, r0
 801f450:	460a      	mov	r2, r1
 801f452:	80fb      	strh	r3, [r7, #6]
 801f454:	4613      	mov	r3, r2
 801f456:	80bb      	strh	r3, [r7, #4]
    uint8_t event[6];
    int pos = 0;
 801f458:	2300      	movs	r3, #0
 801f45a:	617b      	str	r3, [r7, #20]
    event[pos++] = ATT_EVENT_MTU_EXCHANGE_COMPLETE;
 801f45c:	697b      	ldr	r3, [r7, #20]
 801f45e:	1c5a      	adds	r2, r3, #1
 801f460:	617a      	str	r2, [r7, #20]
 801f462:	f107 0218 	add.w	r2, r7, #24
 801f466:	4413      	add	r3, r2
 801f468:	22b5      	movs	r2, #181	; 0xb5
 801f46a:	f803 2c0c 	strb.w	r2, [r3, #-12]
    event[pos++] = sizeof(event) - 2u;
 801f46e:	697b      	ldr	r3, [r7, #20]
 801f470:	1c5a      	adds	r2, r3, #1
 801f472:	617a      	str	r2, [r7, #20]
 801f474:	f107 0218 	add.w	r2, r7, #24
 801f478:	4413      	add	r3, r2
 801f47a:	2204      	movs	r2, #4
 801f47c:	f803 2c0c 	strb.w	r2, [r3, #-12]
    little_endian_store_16(event, pos, con_handle);
 801f480:	697b      	ldr	r3, [r7, #20]
 801f482:	b299      	uxth	r1, r3
 801f484:	88fa      	ldrh	r2, [r7, #6]
 801f486:	f107 030c 	add.w	r3, r7, #12
 801f48a:	4618      	mov	r0, r3
 801f48c:	f7ef fceb 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 801f490:	697b      	ldr	r3, [r7, #20]
 801f492:	3302      	adds	r3, #2
 801f494:	617b      	str	r3, [r7, #20]
    little_endian_store_16(event, pos, mtu);
 801f496:	697b      	ldr	r3, [r7, #20]
 801f498:	b299      	uxth	r1, r3
 801f49a:	88ba      	ldrh	r2, [r7, #4]
 801f49c:	f107 030c 	add.w	r3, r7, #12
 801f4a0:	4618      	mov	r0, r3
 801f4a2:	f7ef fce0 	bl	800ee66 <little_endian_store_16>

    // also dispatch to GATT Clients
    att_dispatch_server_mtu_exchanged(con_handle, mtu);
 801f4a6:	88ba      	ldrh	r2, [r7, #4]
 801f4a8:	88fb      	ldrh	r3, [r7, #6]
 801f4aa:	4611      	mov	r1, r2
 801f4ac:	4618      	mov	r0, r3
 801f4ae:	f7ff fe6b 	bl	801f188 <att_dispatch_server_mtu_exchanged>

    // dispatch to app level handler and service handlers
    att_emit_event_to_all(&event[0], sizeof(event));
 801f4b2:	f107 030c 	add.w	r3, r7, #12
 801f4b6:	2106      	movs	r1, #6
 801f4b8:	4618      	mov	r0, r3
 801f4ba:	f7ff ff8b 	bl	801f3d4 <att_emit_event_to_all>
}
 801f4be:	bf00      	nop
 801f4c0:	3718      	adds	r7, #24
 801f4c2:	46bd      	mov	sp, r7
 801f4c4:	bd80      	pop	{r7, pc}
	...

0801f4c8 <att_emit_can_send_now_event>:

static void att_emit_can_send_now_event(void * context){
 801f4c8:	b590      	push	{r4, r7, lr}
 801f4ca:	b085      	sub	sp, #20
 801f4cc:	af00      	add	r7, sp, #0
 801f4ce:	6078      	str	r0, [r7, #4]
    UNUSED(context);
    if (!att_client_packet_handler) return;
 801f4d0:	4b0a      	ldr	r3, [pc, #40]	; (801f4fc <att_emit_can_send_now_event+0x34>)
 801f4d2:	681b      	ldr	r3, [r3, #0]
 801f4d4:	2b00      	cmp	r3, #0
 801f4d6:	d00c      	beq.n	801f4f2 <att_emit_can_send_now_event+0x2a>

    uint8_t event[] = { ATT_EVENT_CAN_SEND_NOW, 0};
 801f4d8:	23b7      	movs	r3, #183	; 0xb7
 801f4da:	733b      	strb	r3, [r7, #12]
 801f4dc:	2300      	movs	r3, #0
 801f4de:	737b      	strb	r3, [r7, #13]
    (*att_client_packet_handler)(HCI_EVENT_PACKET, 0, &event[0], sizeof(event));
 801f4e0:	4b06      	ldr	r3, [pc, #24]	; (801f4fc <att_emit_can_send_now_event+0x34>)
 801f4e2:	681c      	ldr	r4, [r3, #0]
 801f4e4:	f107 020c 	add.w	r2, r7, #12
 801f4e8:	2302      	movs	r3, #2
 801f4ea:	2100      	movs	r1, #0
 801f4ec:	2004      	movs	r0, #4
 801f4ee:	47a0      	blx	r4
 801f4f0:	e000      	b.n	801f4f4 <att_emit_can_send_now_event+0x2c>
    if (!att_client_packet_handler) return;
 801f4f2:	bf00      	nop
}
 801f4f4:	3714      	adds	r7, #20
 801f4f6:	46bd      	mov	sp, r7
 801f4f8:	bd90      	pop	{r4, r7, pc}
 801f4fa:	bf00      	nop
 801f4fc:	20009f08 	.word	0x20009f08

0801f500 <att_emit_connected_event>:

static void att_emit_connected_event(hci_connection_t * hci_connection){
 801f500:	b580      	push	{r7, lr}
 801f502:	b088      	sub	sp, #32
 801f504:	af00      	add	r7, sp, #0
 801f506:	6078      	str	r0, [r7, #4]
    att_server_t * att_server = &hci_connection->att_server;
 801f508:	687b      	ldr	r3, [r7, #4]
 801f50a:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801f50e:	61fb      	str	r3, [r7, #28]
    att_connection_t * att_connection = &hci_connection->att_connection;
 801f510:	687b      	ldr	r3, [r7, #4]
 801f512:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801f516:	61bb      	str	r3, [r7, #24]
    uint8_t event[11];
    int pos = 0;
 801f518:	2300      	movs	r3, #0
 801f51a:	617b      	str	r3, [r7, #20]
    event[pos++] = ATT_EVENT_CONNECTED;
 801f51c:	697b      	ldr	r3, [r7, #20]
 801f51e:	1c5a      	adds	r2, r3, #1
 801f520:	617a      	str	r2, [r7, #20]
 801f522:	f107 0220 	add.w	r2, r7, #32
 801f526:	4413      	add	r3, r2
 801f528:	22b3      	movs	r2, #179	; 0xb3
 801f52a:	f803 2c18 	strb.w	r2, [r3, #-24]
    event[pos++] = sizeof(event) - 2u;
 801f52e:	697b      	ldr	r3, [r7, #20]
 801f530:	1c5a      	adds	r2, r3, #1
 801f532:	617a      	str	r2, [r7, #20]
 801f534:	f107 0220 	add.w	r2, r7, #32
 801f538:	4413      	add	r3, r2
 801f53a:	2209      	movs	r2, #9
 801f53c:	f803 2c18 	strb.w	r2, [r3, #-24]
    event[pos++] = att_server->peer_addr_type;
 801f540:	697b      	ldr	r3, [r7, #20]
 801f542:	1c5a      	adds	r2, r3, #1
 801f544:	617a      	str	r2, [r7, #20]
 801f546:	69fa      	ldr	r2, [r7, #28]
 801f548:	7852      	ldrb	r2, [r2, #1]
 801f54a:	f107 0120 	add.w	r1, r7, #32
 801f54e:	440b      	add	r3, r1
 801f550:	f803 2c18 	strb.w	r2, [r3, #-24]
    reverse_bd_addr(att_server->peer_address, &event[pos]);
 801f554:	69fb      	ldr	r3, [r7, #28]
 801f556:	1c98      	adds	r0, r3, #2
 801f558:	f107 0208 	add.w	r2, r7, #8
 801f55c:	697b      	ldr	r3, [r7, #20]
 801f55e:	4413      	add	r3, r2
 801f560:	4619      	mov	r1, r3
 801f562:	f7ef fdc6 	bl	800f0f2 <reverse_bd_addr>
    pos += 6;
 801f566:	697b      	ldr	r3, [r7, #20]
 801f568:	3306      	adds	r3, #6
 801f56a:	617b      	str	r3, [r7, #20]
    little_endian_store_16(event, pos, att_connection->con_handle);
 801f56c:	697b      	ldr	r3, [r7, #20]
 801f56e:	b299      	uxth	r1, r3
 801f570:	69bb      	ldr	r3, [r7, #24]
 801f572:	881a      	ldrh	r2, [r3, #0]
 801f574:	f107 0308 	add.w	r3, r7, #8
 801f578:	4618      	mov	r0, r3
 801f57a:	f7ef fc74 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 801f57e:	697b      	ldr	r3, [r7, #20]
 801f580:	3302      	adds	r3, #2
 801f582:	617b      	str	r3, [r7, #20]

    // dispatch to app level handler and service handlers
    att_emit_event_to_all(&event[0], sizeof(event));
 801f584:	f107 0308 	add.w	r3, r7, #8
 801f588:	210b      	movs	r1, #11
 801f58a:	4618      	mov	r0, r3
 801f58c:	f7ff ff22 	bl	801f3d4 <att_emit_event_to_all>
}
 801f590:	bf00      	nop
 801f592:	3720      	adds	r7, #32
 801f594:	46bd      	mov	sp, r7
 801f596:	bd80      	pop	{r7, pc}

0801f598 <att_emit_disconnected_event>:


static void att_emit_disconnected_event(uint16_t con_handle){
 801f598:	b580      	push	{r7, lr}
 801f59a:	b084      	sub	sp, #16
 801f59c:	af00      	add	r7, sp, #0
 801f59e:	4603      	mov	r3, r0
 801f5a0:	80fb      	strh	r3, [r7, #6]
    uint8_t event[4];
    int pos = 0;
 801f5a2:	2300      	movs	r3, #0
 801f5a4:	60fb      	str	r3, [r7, #12]
    event[pos++] = ATT_EVENT_DISCONNECTED;
 801f5a6:	68fb      	ldr	r3, [r7, #12]
 801f5a8:	1c5a      	adds	r2, r3, #1
 801f5aa:	60fa      	str	r2, [r7, #12]
 801f5ac:	f107 0210 	add.w	r2, r7, #16
 801f5b0:	4413      	add	r3, r2
 801f5b2:	22b4      	movs	r2, #180	; 0xb4
 801f5b4:	f803 2c08 	strb.w	r2, [r3, #-8]
    event[pos++] = sizeof(event) - 2u;
 801f5b8:	68fb      	ldr	r3, [r7, #12]
 801f5ba:	1c5a      	adds	r2, r3, #1
 801f5bc:	60fa      	str	r2, [r7, #12]
 801f5be:	f107 0210 	add.w	r2, r7, #16
 801f5c2:	4413      	add	r3, r2
 801f5c4:	2202      	movs	r2, #2
 801f5c6:	f803 2c08 	strb.w	r2, [r3, #-8]
    little_endian_store_16(event, pos, con_handle);
 801f5ca:	68fb      	ldr	r3, [r7, #12]
 801f5cc:	b299      	uxth	r1, r3
 801f5ce:	88fa      	ldrh	r2, [r7, #6]
 801f5d0:	f107 0308 	add.w	r3, r7, #8
 801f5d4:	4618      	mov	r0, r3
 801f5d6:	f7ef fc46 	bl	800ee66 <little_endian_store_16>
    pos += 2;
 801f5da:	68fb      	ldr	r3, [r7, #12]
 801f5dc:	3302      	adds	r3, #2
 801f5de:	60fb      	str	r3, [r7, #12]

    // dispatch to app level handler and service handlers
    att_emit_event_to_all(&event[0], sizeof(event));
 801f5e0:	f107 0308 	add.w	r3, r7, #8
 801f5e4:	2104      	movs	r1, #4
 801f5e6:	4618      	mov	r0, r3
 801f5e8:	f7ff fef4 	bl	801f3d4 <att_emit_event_to_all>
}
 801f5ec:	bf00      	nop
 801f5ee:	3710      	adds	r7, #16
 801f5f0:	46bd      	mov	sp, r7
 801f5f2:	bd80      	pop	{r7, pc}

0801f5f4 <att_event_packet_handler>:
    uint16_t att_handle = att_server->value_indication_handle;
    att_connection_t * att_connection = &hci_connection->att_connection;
    att_handle_value_indication_notify_client(ATT_HANDLE_VALUE_INDICATION_TIMEOUT, att_connection->con_handle, att_handle);
}

static void att_event_packet_handler (uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){
 801f5f4:	b580      	push	{r7, lr}
 801f5f6:	b08e      	sub	sp, #56	; 0x38
 801f5f8:	af04      	add	r7, sp, #16
 801f5fa:	60ba      	str	r2, [r7, #8]
 801f5fc:	461a      	mov	r2, r3
 801f5fe:	4603      	mov	r3, r0
 801f600:	73fb      	strb	r3, [r7, #15]
 801f602:	460b      	mov	r3, r1
 801f604:	81bb      	strh	r3, [r7, #12]
 801f606:	4613      	mov	r3, r2
 801f608:	80fb      	strh	r3, [r7, #6]
#ifdef ENABLE_GATT_OVER_CLASSIC
    bd_addr_t address;
    btstack_linked_list_iterator_t it;
#endif

    switch (packet_type) {
 801f60a:	7bfb      	ldrb	r3, [r7, #15]
 801f60c:	2b04      	cmp	r3, #4
 801f60e:	d000      	beq.n	801f612 <att_event_packet_handler+0x1e>
            }
            break;
#endif

        default:
            break;
 801f610:	e231      	b.n	801fa76 <att_event_packet_handler+0x482>
            switch (hci_event_packet_get_type(packet)) {
 801f612:	68b8      	ldr	r0, [r7, #8]
 801f614:	f7ff fdce 	bl	801f1b4 <hci_event_packet_get_type>
 801f618:	4603      	mov	r3, r0
 801f61a:	2bd4      	cmp	r3, #212	; 0xd4
 801f61c:	dc18      	bgt.n	801f650 <att_event_packet_handler+0x5c>
 801f61e:	2bd3      	cmp	r3, #211	; 0xd3
 801f620:	f280 8194 	bge.w	801f94c <att_event_packet_handler+0x358>
 801f624:	2b30      	cmp	r3, #48	; 0x30
 801f626:	f000 808b 	beq.w	801f740 <att_event_packet_handler+0x14c>
 801f62a:	2b30      	cmp	r3, #48	; 0x30
 801f62c:	dc06      	bgt.n	801f63c <att_event_packet_handler+0x48>
 801f62e:	2b05      	cmp	r3, #5
 801f630:	f000 80e2 	beq.w	801f7f8 <att_event_packet_handler+0x204>
 801f634:	2b08      	cmp	r3, #8
 801f636:	f000 8083 	beq.w	801f740 <att_event_packet_handler+0x14c>
                    break;
 801f63a:	e205      	b.n	801fa48 <att_event_packet_handler+0x454>
            switch (hci_event_packet_get_type(packet)) {
 801f63c:	2b3e      	cmp	r3, #62	; 0x3e
 801f63e:	d01d      	beq.n	801f67c <att_event_packet_handler+0x88>
 801f640:	2b3e      	cmp	r3, #62	; 0x3e
 801f642:	f2c0 8201 	blt.w	801fa48 <att_event_packet_handler+0x454>
 801f646:	3bd0      	subs	r3, #208	; 0xd0
 801f648:	2b01      	cmp	r3, #1
 801f64a:	f200 81fd 	bhi.w	801fa48 <att_event_packet_handler+0x454>
 801f64e:	e17d      	b.n	801f94c <att_event_packet_handler+0x358>
 801f650:	2bd7      	cmp	r3, #215	; 0xd7
 801f652:	f000 8130 	beq.w	801f8b6 <att_event_packet_handler+0x2c2>
 801f656:	2bd7      	cmp	r3, #215	; 0xd7
 801f658:	dc06      	bgt.n	801f668 <att_event_packet_handler+0x74>
 801f65a:	2bd5      	cmp	r3, #213	; 0xd5
 801f65c:	f000 810e 	beq.w	801f87c <att_event_packet_handler+0x288>
 801f660:	2bd6      	cmp	r3, #214	; 0xd6
 801f662:	f000 814f 	beq.w	801f904 <att_event_packet_handler+0x310>
                    break;
 801f666:	e1ef      	b.n	801fa48 <att_event_packet_handler+0x454>
            switch (hci_event_packet_get_type(packet)) {
 801f668:	2bdb      	cmp	r3, #219	; 0xdb
 801f66a:	f000 8196 	beq.w	801f99a <att_event_packet_handler+0x3a6>
 801f66e:	2bdd      	cmp	r3, #221	; 0xdd
 801f670:	f000 81b2 	beq.w	801f9d8 <att_event_packet_handler+0x3e4>
 801f674:	2bd9      	cmp	r3, #217	; 0xd9
 801f676:	f000 81c7 	beq.w	801fa08 <att_event_packet_handler+0x414>
                    break;
 801f67a:	e1e5      	b.n	801fa48 <att_event_packet_handler+0x454>
                    switch (packet[2]) {
 801f67c:	68bb      	ldr	r3, [r7, #8]
 801f67e:	3302      	adds	r3, #2
 801f680:	781b      	ldrb	r3, [r3, #0]
 801f682:	2b01      	cmp	r3, #1
 801f684:	d000      	beq.n	801f688 <att_event_packet_handler+0x94>
                            break;
 801f686:	e05a      	b.n	801f73e <att_event_packet_handler+0x14a>
                            con_handle = little_endian_read_16(packet, 4);
 801f688:	2104      	movs	r1, #4
 801f68a:	68b8      	ldr	r0, [r7, #8]
 801f68c:	f7ef fbab 	bl	800ede6 <little_endian_read_16>
 801f690:	4603      	mov	r3, r0
 801f692:	84fb      	strh	r3, [r7, #38]	; 0x26
                            hci_connection = hci_connection_for_handle(con_handle);
 801f694:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f696:	4618      	mov	r0, r3
 801f698:	f7f0 f914 	bl	800f8c4 <hci_connection_for_handle>
 801f69c:	6238      	str	r0, [r7, #32]
                            if (!hci_connection) break;
 801f69e:	6a3b      	ldr	r3, [r7, #32]
 801f6a0:	2b00      	cmp	r3, #0
 801f6a2:	d04b      	beq.n	801f73c <att_event_packet_handler+0x148>
                            att_server = &hci_connection->att_server;
 801f6a4:	6a3b      	ldr	r3, [r7, #32]
 801f6a6:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801f6aa:	61fb      	str	r3, [r7, #28]
                        	att_server->peer_addr_type = packet[7];
 801f6ac:	68bb      	ldr	r3, [r7, #8]
 801f6ae:	79da      	ldrb	r2, [r3, #7]
 801f6b0:	69fb      	ldr	r3, [r7, #28]
 801f6b2:	705a      	strb	r2, [r3, #1]
                            reverse_bd_addr(&packet[8], att_server->peer_address);
 801f6b4:	68bb      	ldr	r3, [r7, #8]
 801f6b6:	f103 0208 	add.w	r2, r3, #8
 801f6ba:	69fb      	ldr	r3, [r7, #28]
 801f6bc:	3302      	adds	r3, #2
 801f6be:	4619      	mov	r1, r3
 801f6c0:	4610      	mov	r0, r2
 801f6c2:	f7ef fd16 	bl	800f0f2 <reverse_bd_addr>
                            att_connection = &hci_connection->att_connection;
 801f6c6:	6a3b      	ldr	r3, [r7, #32]
 801f6c8:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801f6cc:	61bb      	str	r3, [r7, #24]
                            att_connection->con_handle = con_handle;
 801f6ce:	69bb      	ldr	r3, [r7, #24]
 801f6d0:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801f6d2:	801a      	strh	r2, [r3, #0]
                            att_server->state = ATT_SERVER_IDLE;
 801f6d4:	69fb      	ldr	r3, [r7, #28]
 801f6d6:	2200      	movs	r2, #0
 801f6d8:	701a      	strb	r2, [r3, #0]
                            att_connection->mtu = ATT_DEFAULT_MTU;
 801f6da:	69bb      	ldr	r3, [r7, #24]
 801f6dc:	2217      	movs	r2, #23
 801f6de:	805a      	strh	r2, [r3, #2]
                            att_connection->max_mtu = l2cap_max_le_mtu();
 801f6e0:	f7f9 fd2e 	bl	8019140 <l2cap_max_le_mtu>
 801f6e4:	4603      	mov	r3, r0
 801f6e6:	461a      	mov	r2, r3
 801f6e8:	69bb      	ldr	r3, [r7, #24]
 801f6ea:	809a      	strh	r2, [r3, #4]
                            if (att_connection->max_mtu > ATT_REQUEST_BUFFER_SIZE){
 801f6ec:	69bb      	ldr	r3, [r7, #24]
 801f6ee:	889b      	ldrh	r3, [r3, #4]
 801f6f0:	f5b3 6fd4 	cmp.w	r3, #1696	; 0x6a0
 801f6f4:	d303      	bcc.n	801f6fe <att_event_packet_handler+0x10a>
                                att_connection->max_mtu = ATT_REQUEST_BUFFER_SIZE;
 801f6f6:	69bb      	ldr	r3, [r7, #24]
 801f6f8:	f240 629f 	movw	r2, #1695	; 0x69f
 801f6fc:	809a      	strh	r2, [r3, #4]
                            att_connection->encryption_key_size = 0;
 801f6fe:	69bb      	ldr	r3, [r7, #24]
 801f700:	2200      	movs	r2, #0
 801f702:	71da      	strb	r2, [r3, #7]
                            att_connection->authenticated = 0;
 801f704:	69bb      	ldr	r3, [r7, #24]
 801f706:	2200      	movs	r2, #0
 801f708:	721a      	strb	r2, [r3, #8]
		                	att_connection->authorized = 0;
 801f70a:	69bb      	ldr	r3, [r7, #24]
 801f70c:	2200      	movs	r2, #0
 801f70e:	725a      	strb	r2, [r3, #9]
                            att_server->ir_le_device_db_index = sm_le_device_index(con_handle);
 801f710:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f712:	4618      	mov	r0, r3
 801f714:	f007 fe2e 	bl	8027374 <sm_le_device_index>
 801f718:	4602      	mov	r2, r0
 801f71a:	69fb      	ldr	r3, [r7, #28]
 801f71c:	609a      	str	r2, [r3, #8]
                            att_server->ir_lookup_active = 0;
 801f71e:	69fb      	ldr	r3, [r7, #28]
 801f720:	2200      	movs	r2, #0
 801f722:	731a      	strb	r2, [r3, #12]
                            att_server->pairing_active = 0;
 801f724:	69fb      	ldr	r3, [r7, #28]
 801f726:	2200      	movs	r2, #0
 801f728:	735a      	strb	r2, [r3, #13]
                            att_emit_event_to_all(packet, size);
 801f72a:	88fb      	ldrh	r3, [r7, #6]
 801f72c:	4619      	mov	r1, r3
 801f72e:	68b8      	ldr	r0, [r7, #8]
 801f730:	f7ff fe50 	bl	801f3d4 <att_emit_event_to_all>
                            att_emit_connected_event(hci_connection);
 801f734:	6a38      	ldr	r0, [r7, #32]
 801f736:	f7ff fee3 	bl	801f500 <att_emit_connected_event>
                            break;
 801f73a:	e000      	b.n	801f73e <att_event_packet_handler+0x14a>
                            if (!hci_connection) break;
 801f73c:	bf00      	nop
                    break;
 801f73e:	e194      	b.n	801fa6a <att_event_packet_handler+0x476>
                    con_handle = little_endian_read_16(packet, 3);
 801f740:	2103      	movs	r1, #3
 801f742:	68b8      	ldr	r0, [r7, #8]
 801f744:	f7ef fb4f 	bl	800ede6 <little_endian_read_16>
 801f748:	4603      	mov	r3, r0
 801f74a:	84fb      	strh	r3, [r7, #38]	; 0x26
                    hci_connection = hci_connection_for_handle(con_handle);
 801f74c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f74e:	4618      	mov	r0, r3
 801f750:	f7f0 f8b8 	bl	800f8c4 <hci_connection_for_handle>
 801f754:	6238      	str	r0, [r7, #32]
                    if (!hci_connection) break;
 801f756:	6a3b      	ldr	r3, [r7, #32]
 801f758:	2b00      	cmp	r3, #0
 801f75a:	f000 8177 	beq.w	801fa4c <att_event_packet_handler+0x458>
                    if (gap_get_connection_type(con_handle) != GAP_CONNECTION_LE) break;
 801f75e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f760:	4618      	mov	r0, r3
 801f762:	f7f7 f9a7 	bl	8016ab4 <gap_get_connection_type>
 801f766:	4603      	mov	r3, r0
 801f768:	2b03      	cmp	r3, #3
 801f76a:	f040 8171 	bne.w	801fa50 <att_event_packet_handler+0x45c>
                    att_server = &hci_connection->att_server;
 801f76e:	6a3b      	ldr	r3, [r7, #32]
 801f770:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801f774:	61fb      	str	r3, [r7, #28]
                    att_connection = &hci_connection->att_connection;
 801f776:	6a3b      	ldr	r3, [r7, #32]
 801f778:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801f77c:	61bb      	str	r3, [r7, #24]
                    att_connection->encryption_key_size = gap_encryption_key_size(con_handle);
 801f77e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f780:	4618      	mov	r0, r3
 801f782:	f7f7 fa0b 	bl	8016b9c <gap_encryption_key_size>
 801f786:	4603      	mov	r3, r0
 801f788:	b2da      	uxtb	r2, r3
 801f78a:	69bb      	ldr	r3, [r7, #24]
 801f78c:	71da      	strb	r2, [r3, #7]
                    att_connection->authenticated = gap_authenticated(con_handle);
 801f78e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f790:	4618      	mov	r0, r3
 801f792:	f7f7 fa31 	bl	8016bf8 <gap_authenticated>
 801f796:	4603      	mov	r3, r0
 801f798:	b2da      	uxtb	r2, r3
 801f79a:	69bb      	ldr	r3, [r7, #24]
 801f79c:	721a      	strb	r2, [r3, #8]
                    att_connection->secure_connection = gap_secure_connection(con_handle);
 801f79e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f7a0:	4618      	mov	r0, r3
 801f7a2:	f7f7 fa59 	bl	8016c58 <gap_secure_connection>
 801f7a6:	4603      	mov	r3, r0
 801f7a8:	b2da      	uxtb	r2, r3
 801f7aa:	69bb      	ldr	r3, [r7, #24]
 801f7ac:	729a      	strb	r2, [r3, #10]
                    log_info("encrypted key size %u, authenticated %u, secure connection %u",
 801f7ae:	69bb      	ldr	r3, [r7, #24]
 801f7b0:	79db      	ldrb	r3, [r3, #7]
 801f7b2:	461a      	mov	r2, r3
 801f7b4:	69bb      	ldr	r3, [r7, #24]
 801f7b6:	7a1b      	ldrb	r3, [r3, #8]
 801f7b8:	4619      	mov	r1, r3
 801f7ba:	69bb      	ldr	r3, [r7, #24]
 801f7bc:	7a9b      	ldrb	r3, [r3, #10]
 801f7be:	9302      	str	r3, [sp, #8]
 801f7c0:	9101      	str	r1, [sp, #4]
 801f7c2:	9200      	str	r2, [sp, #0]
 801f7c4:	f44f 73b5 	mov.w	r3, #362	; 0x16a
 801f7c8:	4aac      	ldr	r2, [pc, #688]	; (801fa7c <att_event_packet_handler+0x488>)
 801f7ca:	49ad      	ldr	r1, [pc, #692]	; (801fa80 <att_event_packet_handler+0x48c>)
 801f7cc:	2001      	movs	r0, #1
 801f7ce:	f7f7 fe37 	bl	8017440 <hci_dump_log>
                    if (hci_event_packet_get_type(packet) == HCI_EVENT_ENCRYPTION_CHANGE){
 801f7d2:	68b8      	ldr	r0, [r7, #8]
 801f7d4:	f7ff fcee 	bl	801f1b4 <hci_event_packet_get_type>
 801f7d8:	4603      	mov	r3, r0
 801f7da:	2b08      	cmp	r3, #8
 801f7dc:	d108      	bne.n	801f7f0 <att_event_packet_handler+0x1fc>
                        if (hci_event_encryption_change_get_encryption_enabled(packet)){
 801f7de:	68b8      	ldr	r0, [r7, #8]
 801f7e0:	f7ff fd01 	bl	801f1e6 <hci_event_encryption_change_get_encryption_enabled>
 801f7e4:	4603      	mov	r3, r0
 801f7e6:	2b00      	cmp	r3, #0
 801f7e8:	d002      	beq.n	801f7f0 <att_event_packet_handler+0x1fc>
                            att_server_persistent_ccc_restore(hci_connection);
 801f7ea:	6a38      	ldr	r0, [r7, #32]
 801f7ec:	f000 fd86 	bl	80202fc <att_server_persistent_ccc_restore>
                    att_run_for_context(hci_connection);
 801f7f0:	6a38      	ldr	r0, [r7, #32]
 801f7f2:	f000 f9d9 	bl	801fba8 <att_run_for_context>
                    break;
 801f7f6:	e138      	b.n	801fa6a <att_event_packet_handler+0x476>
                    con_handle = hci_event_disconnection_complete_get_connection_handle(packet);
 801f7f8:	68b8      	ldr	r0, [r7, #8]
 801f7fa:	f7ff fce7 	bl	801f1cc <hci_event_disconnection_complete_get_connection_handle>
 801f7fe:	4603      	mov	r3, r0
 801f800:	84fb      	strh	r3, [r7, #38]	; 0x26
                    hci_connection = hci_connection_for_handle(con_handle);
 801f802:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f804:	4618      	mov	r0, r3
 801f806:	f7f0 f85d 	bl	800f8c4 <hci_connection_for_handle>
 801f80a:	6238      	str	r0, [r7, #32]
                    if (!hci_connection) break;
 801f80c:	6a3b      	ldr	r3, [r7, #32]
 801f80e:	2b00      	cmp	r3, #0
 801f810:	f000 8120 	beq.w	801fa54 <att_event_packet_handler+0x460>
                    att_server = &hci_connection->att_server;
 801f814:	6a3b      	ldr	r3, [r7, #32]
 801f816:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801f81a:	61fb      	str	r3, [r7, #28]
                    att_connection = &hci_connection->att_connection;
 801f81c:	6a3b      	ldr	r3, [r7, #32]
 801f81e:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801f822:	61bb      	str	r3, [r7, #24]
                    att_clear_transaction_queue(att_connection);
 801f824:	69b8      	ldr	r0, [r7, #24]
 801f826:	f7ff f8d3 	bl	801e9d0 <att_clear_transaction_queue>
                    att_connection->con_handle = 0;
 801f82a:	69bb      	ldr	r3, [r7, #24]
 801f82c:	2200      	movs	r2, #0
 801f82e:	801a      	strh	r2, [r3, #0]
                    att_server->pairing_active = 0;
 801f830:	69fb      	ldr	r3, [r7, #28]
 801f832:	2200      	movs	r2, #0
 801f834:	735a      	strb	r2, [r3, #13]
                    att_server->state = ATT_SERVER_IDLE;
 801f836:	69fb      	ldr	r3, [r7, #28]
 801f838:	2200      	movs	r2, #0
 801f83a:	701a      	strb	r2, [r3, #0]
                    if (att_server->value_indication_handle){
 801f83c:	69fb      	ldr	r3, [r7, #28]
 801f83e:	691b      	ldr	r3, [r3, #16]
 801f840:	2b00      	cmp	r3, #0
 801f842:	d011      	beq.n	801f868 <att_event_packet_handler+0x274>
                        btstack_run_loop_remove_timer(&att_server->value_indication_timer);
 801f844:	69fb      	ldr	r3, [r7, #28]
 801f846:	3314      	adds	r3, #20
 801f848:	4618      	mov	r0, r3
 801f84a:	f7ef fa3f 	bl	800eccc <btstack_run_loop_remove_timer>
                        uint16_t att_handle = att_server->value_indication_handle;
 801f84e:	69fb      	ldr	r3, [r7, #28]
 801f850:	691b      	ldr	r3, [r3, #16]
 801f852:	82fb      	strh	r3, [r7, #22]
                        att_server->value_indication_handle = 0; // reset error state
 801f854:	69fb      	ldr	r3, [r7, #28]
 801f856:	2200      	movs	r2, #0
 801f858:	611a      	str	r2, [r3, #16]
                        att_handle_value_indication_notify_client(ATT_HANDLE_VALUE_INDICATION_DISCONNECT, att_connection->con_handle, att_handle);
 801f85a:	69bb      	ldr	r3, [r7, #24]
 801f85c:	881b      	ldrh	r3, [r3, #0]
 801f85e:	8afa      	ldrh	r2, [r7, #22]
 801f860:	4619      	mov	r1, r3
 801f862:	2092      	movs	r0, #146	; 0x92
 801f864:	f7ff fd69 	bl	801f33a <att_handle_value_indication_notify_client>
                    att_emit_disconnected_event(con_handle);
 801f868:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f86a:	4618      	mov	r0, r3
 801f86c:	f7ff fe94 	bl	801f598 <att_emit_disconnected_event>
                    att_emit_event_to_all(packet, size);
 801f870:	88fb      	ldrh	r3, [r7, #6]
 801f872:	4619      	mov	r1, r3
 801f874:	68b8      	ldr	r0, [r7, #8]
 801f876:	f7ff fdad 	bl	801f3d4 <att_emit_event_to_all>
                    break;
 801f87a:	e0f6      	b.n	801fa6a <att_event_packet_handler+0x476>
                    con_handle = sm_event_identity_resolving_started_get_handle(packet);
 801f87c:	68b8      	ldr	r0, [r7, #8]
 801f87e:	f7ff fccc 	bl	801f21a <sm_event_identity_resolving_started_get_handle>
 801f882:	4603      	mov	r3, r0
 801f884:	84fb      	strh	r3, [r7, #38]	; 0x26
                    hci_connection = hci_connection_for_handle(con_handle);
 801f886:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f888:	4618      	mov	r0, r3
 801f88a:	f7f0 f81b 	bl	800f8c4 <hci_connection_for_handle>
 801f88e:	6238      	str	r0, [r7, #32]
                    if (!hci_connection) break;
 801f890:	6a3b      	ldr	r3, [r7, #32]
 801f892:	2b00      	cmp	r3, #0
 801f894:	f000 80e0 	beq.w	801fa58 <att_event_packet_handler+0x464>
                    att_server = &hci_connection->att_server;
 801f898:	6a3b      	ldr	r3, [r7, #32]
 801f89a:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801f89e:	61fb      	str	r3, [r7, #28]
                    log_info("SM_EVENT_IDENTITY_RESOLVING_STARTED");
 801f8a0:	f240 1391 	movw	r3, #401	; 0x191
 801f8a4:	4a75      	ldr	r2, [pc, #468]	; (801fa7c <att_event_packet_handler+0x488>)
 801f8a6:	4977      	ldr	r1, [pc, #476]	; (801fa84 <att_event_packet_handler+0x490>)
 801f8a8:	2001      	movs	r0, #1
 801f8aa:	f7f7 fdc9 	bl	8017440 <hci_dump_log>
                    att_server->ir_lookup_active = 1;
 801f8ae:	69fb      	ldr	r3, [r7, #28]
 801f8b0:	2201      	movs	r2, #1
 801f8b2:	731a      	strb	r2, [r3, #12]
                    break;
 801f8b4:	e0d9      	b.n	801fa6a <att_event_packet_handler+0x476>
                    con_handle = sm_event_identity_created_get_handle(packet);
 801f8b6:	68b8      	ldr	r0, [r7, #8]
 801f8b8:	f7ff fcf0 	bl	801f29c <sm_event_identity_created_get_handle>
 801f8bc:	4603      	mov	r3, r0
 801f8be:	84fb      	strh	r3, [r7, #38]	; 0x26
                    hci_connection = hci_connection_for_handle(con_handle);
 801f8c0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f8c2:	4618      	mov	r0, r3
 801f8c4:	f7ef fffe 	bl	800f8c4 <hci_connection_for_handle>
 801f8c8:	6238      	str	r0, [r7, #32]
                    if (!hci_connection) return;
 801f8ca:	6a3b      	ldr	r3, [r7, #32]
 801f8cc:	2b00      	cmp	r3, #0
 801f8ce:	f000 80cd 	beq.w	801fa6c <att_event_packet_handler+0x478>
                    att_server = &hci_connection->att_server;
 801f8d2:	6a3b      	ldr	r3, [r7, #32]
 801f8d4:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801f8d8:	61fb      	str	r3, [r7, #28]
                    att_server->ir_lookup_active = 0;
 801f8da:	69fb      	ldr	r3, [r7, #28]
 801f8dc:	2200      	movs	r2, #0
 801f8de:	731a      	strb	r2, [r3, #12]
                    att_server->ir_le_device_db_index = sm_event_identity_resolving_succeeded_get_index(packet);
 801f8e0:	68b8      	ldr	r0, [r7, #8]
 801f8e2:	f7ff fcb4 	bl	801f24e <sm_event_identity_resolving_succeeded_get_index>
 801f8e6:	4603      	mov	r3, r0
 801f8e8:	461a      	mov	r2, r3
 801f8ea:	69fb      	ldr	r3, [r7, #28]
 801f8ec:	609a      	str	r2, [r3, #8]
                    log_info("SM_EVENT_IDENTITY_RESOLVING_SUCCEEDED");
 801f8ee:	f240 139b 	movw	r3, #411	; 0x19b
 801f8f2:	4a62      	ldr	r2, [pc, #392]	; (801fa7c <att_event_packet_handler+0x488>)
 801f8f4:	4964      	ldr	r1, [pc, #400]	; (801fa88 <att_event_packet_handler+0x494>)
 801f8f6:	2001      	movs	r0, #1
 801f8f8:	f7f7 fda2 	bl	8017440 <hci_dump_log>
                    att_run_for_context(hci_connection);
 801f8fc:	6a38      	ldr	r0, [r7, #32]
 801f8fe:	f000 f953 	bl	801fba8 <att_run_for_context>
                    break;
 801f902:	e0b2      	b.n	801fa6a <att_event_packet_handler+0x476>
                    con_handle = sm_event_identity_resolving_failed_get_handle(packet);
 801f904:	68b8      	ldr	r0, [r7, #8]
 801f906:	f7ff fc95 	bl	801f234 <sm_event_identity_resolving_failed_get_handle>
 801f90a:	4603      	mov	r3, r0
 801f90c:	84fb      	strh	r3, [r7, #38]	; 0x26
                    hci_connection = hci_connection_for_handle(con_handle);
 801f90e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f910:	4618      	mov	r0, r3
 801f912:	f7ef ffd7 	bl	800f8c4 <hci_connection_for_handle>
 801f916:	6238      	str	r0, [r7, #32]
                    if (!hci_connection) break;
 801f918:	6a3b      	ldr	r3, [r7, #32]
 801f91a:	2b00      	cmp	r3, #0
 801f91c:	f000 809e 	beq.w	801fa5c <att_event_packet_handler+0x468>
                    att_server = &hci_connection->att_server;
 801f920:	6a3b      	ldr	r3, [r7, #32]
 801f922:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801f926:	61fb      	str	r3, [r7, #28]
                    log_info("SM_EVENT_IDENTITY_RESOLVING_FAILED");
 801f928:	f240 13a3 	movw	r3, #419	; 0x1a3
 801f92c:	4a53      	ldr	r2, [pc, #332]	; (801fa7c <att_event_packet_handler+0x488>)
 801f92e:	4957      	ldr	r1, [pc, #348]	; (801fa8c <att_event_packet_handler+0x498>)
 801f930:	2001      	movs	r0, #1
 801f932:	f7f7 fd85 	bl	8017440 <hci_dump_log>
                    att_server->ir_lookup_active = 0;
 801f936:	69fb      	ldr	r3, [r7, #28]
 801f938:	2200      	movs	r2, #0
 801f93a:	731a      	strb	r2, [r3, #12]
                    att_server->ir_le_device_db_index = -1;
 801f93c:	69fb      	ldr	r3, [r7, #28]
 801f93e:	f04f 32ff 	mov.w	r2, #4294967295
 801f942:	609a      	str	r2, [r3, #8]
                    att_run_for_context(hci_connection);
 801f944:	6a38      	ldr	r0, [r7, #32]
 801f946:	f000 f92f 	bl	801fba8 <att_run_for_context>
                    break;
 801f94a:	e08e      	b.n	801fa6a <att_event_packet_handler+0x476>
                    con_handle = sm_event_just_works_request_get_handle(packet);
 801f94c:	68b8      	ldr	r0, [r7, #8]
 801f94e:	f7ff fc57 	bl	801f200 <sm_event_just_works_request_get_handle>
 801f952:	4603      	mov	r3, r0
 801f954:	84fb      	strh	r3, [r7, #38]	; 0x26
                    hci_connection = hci_connection_for_handle(con_handle);
 801f956:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f958:	4618      	mov	r0, r3
 801f95a:	f7ef ffb3 	bl	800f8c4 <hci_connection_for_handle>
 801f95e:	6238      	str	r0, [r7, #32]
                    if (!hci_connection) break;
 801f960:	6a3b      	ldr	r3, [r7, #32]
 801f962:	2b00      	cmp	r3, #0
 801f964:	d07c      	beq.n	801fa60 <att_event_packet_handler+0x46c>
                    att_server = &hci_connection->att_server;
 801f966:	6a3b      	ldr	r3, [r7, #32]
 801f968:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801f96c:	61fb      	str	r3, [r7, #28]
                    att_server->pairing_active = 1;
 801f96e:	69fb      	ldr	r3, [r7, #28]
 801f970:	2201      	movs	r2, #1
 801f972:	735a      	strb	r2, [r3, #13]
                    log_info("SM Pairing started");
 801f974:	f240 13b5 	movw	r3, #437	; 0x1b5
 801f978:	4a40      	ldr	r2, [pc, #256]	; (801fa7c <att_event_packet_handler+0x488>)
 801f97a:	4945      	ldr	r1, [pc, #276]	; (801fa90 <att_event_packet_handler+0x49c>)
 801f97c:	2001      	movs	r0, #1
 801f97e:	f7f7 fd5f 	bl	8017440 <hci_dump_log>
                    if (att_server->ir_le_device_db_index < 0) break;
 801f982:	69fb      	ldr	r3, [r7, #28]
 801f984:	689b      	ldr	r3, [r3, #8]
 801f986:	2b00      	cmp	r3, #0
 801f988:	db6c      	blt.n	801fa64 <att_event_packet_handler+0x470>
                    att_server_persistent_ccc_clear(hci_connection);
 801f98a:	6a38      	ldr	r0, [r7, #32]
 801f98c:	f000 fc46 	bl	802021c <att_server_persistent_ccc_clear>
                    att_server->ir_le_device_db_index = -1;
 801f990:	69fb      	ldr	r3, [r7, #28]
 801f992:	f04f 32ff 	mov.w	r2, #4294967295
 801f996:	609a      	str	r2, [r3, #8]
                    break;
 801f998:	e067      	b.n	801fa6a <att_event_packet_handler+0x476>
                    con_handle = sm_event_identity_created_get_handle(packet);
 801f99a:	68b8      	ldr	r0, [r7, #8]
 801f99c:	f7ff fc7e 	bl	801f29c <sm_event_identity_created_get_handle>
 801f9a0:	4603      	mov	r3, r0
 801f9a2:	84fb      	strh	r3, [r7, #38]	; 0x26
                    hci_connection = hci_connection_for_handle(con_handle);
 801f9a4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f9a6:	4618      	mov	r0, r3
 801f9a8:	f7ef ff8c 	bl	800f8c4 <hci_connection_for_handle>
 801f9ac:	6238      	str	r0, [r7, #32]
                    if (!hci_connection) return;
 801f9ae:	6a3b      	ldr	r3, [r7, #32]
 801f9b0:	2b00      	cmp	r3, #0
 801f9b2:	d05d      	beq.n	801fa70 <att_event_packet_handler+0x47c>
                    att_server = &hci_connection->att_server;
 801f9b4:	6a3b      	ldr	r3, [r7, #32]
 801f9b6:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801f9ba:	61fb      	str	r3, [r7, #28]
                    att_server->pairing_active = 0;
 801f9bc:	69fb      	ldr	r3, [r7, #28]
 801f9be:	2200      	movs	r2, #0
 801f9c0:	735a      	strb	r2, [r3, #13]
                    att_server->ir_le_device_db_index = sm_event_identity_created_get_index(packet);
 801f9c2:	68b8      	ldr	r0, [r7, #8]
 801f9c4:	f7ff fc77 	bl	801f2b6 <sm_event_identity_created_get_index>
 801f9c8:	4603      	mov	r3, r0
 801f9ca:	461a      	mov	r2, r3
 801f9cc:	69fb      	ldr	r3, [r7, #28]
 801f9ce:	609a      	str	r2, [r3, #8]
                    att_run_for_context(hci_connection);
 801f9d0:	6a38      	ldr	r0, [r7, #32]
 801f9d2:	f000 f8e9 	bl	801fba8 <att_run_for_context>
                    break;
 801f9d6:	e048      	b.n	801fa6a <att_event_packet_handler+0x476>
                    con_handle = sm_event_pairing_complete_get_handle(packet);
 801f9d8:	68b8      	ldr	r0, [r7, #8]
 801f9da:	f7ff fc79 	bl	801f2d0 <sm_event_pairing_complete_get_handle>
 801f9de:	4603      	mov	r3, r0
 801f9e0:	84fb      	strh	r3, [r7, #38]	; 0x26
                    hci_connection = hci_connection_for_handle(con_handle);
 801f9e2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f9e4:	4618      	mov	r0, r3
 801f9e6:	f7ef ff6d 	bl	800f8c4 <hci_connection_for_handle>
 801f9ea:	6238      	str	r0, [r7, #32]
                    if (!hci_connection) return;
 801f9ec:	6a3b      	ldr	r3, [r7, #32]
 801f9ee:	2b00      	cmp	r3, #0
 801f9f0:	d040      	beq.n	801fa74 <att_event_packet_handler+0x480>
                    att_server = &hci_connection->att_server;
 801f9f2:	6a3b      	ldr	r3, [r7, #32]
 801f9f4:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801f9f8:	61fb      	str	r3, [r7, #28]
                    att_server->pairing_active = 0;
 801f9fa:	69fb      	ldr	r3, [r7, #28]
 801f9fc:	2200      	movs	r2, #0
 801f9fe:	735a      	strb	r2, [r3, #13]
                    att_run_for_context(hci_connection);
 801fa00:	6a38      	ldr	r0, [r7, #32]
 801fa02:	f000 f8d1 	bl	801fba8 <att_run_for_context>
                    break;
 801fa06:	e030      	b.n	801fa6a <att_event_packet_handler+0x476>
                    con_handle = sm_event_authorization_result_get_handle(packet);
 801fa08:	68b8      	ldr	r0, [r7, #8]
 801fa0a:	f7ff fc2d 	bl	801f268 <sm_event_authorization_result_get_handle>
 801fa0e:	4603      	mov	r3, r0
 801fa10:	84fb      	strh	r3, [r7, #38]	; 0x26
                    hci_connection = hci_connection_for_handle(con_handle);
 801fa12:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801fa14:	4618      	mov	r0, r3
 801fa16:	f7ef ff55 	bl	800f8c4 <hci_connection_for_handle>
 801fa1a:	6238      	str	r0, [r7, #32]
                    if (!hci_connection) break;
 801fa1c:	6a3b      	ldr	r3, [r7, #32]
 801fa1e:	2b00      	cmp	r3, #0
 801fa20:	d022      	beq.n	801fa68 <att_event_packet_handler+0x474>
                    att_server = &hci_connection->att_server;
 801fa22:	6a3b      	ldr	r3, [r7, #32]
 801fa24:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801fa28:	61fb      	str	r3, [r7, #28]
                    att_connection = &hci_connection->att_connection;
 801fa2a:	6a3b      	ldr	r3, [r7, #32]
 801fa2c:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801fa30:	61bb      	str	r3, [r7, #24]
                    att_connection->authorized = sm_event_authorization_result_get_authorization_result(packet);
 801fa32:	68b8      	ldr	r0, [r7, #8]
 801fa34:	f7ff fc25 	bl	801f282 <sm_event_authorization_result_get_authorization_result>
 801fa38:	4603      	mov	r3, r0
 801fa3a:	461a      	mov	r2, r3
 801fa3c:	69bb      	ldr	r3, [r7, #24]
 801fa3e:	725a      	strb	r2, [r3, #9]
                    att_server_request_can_send_now(hci_connection);
 801fa40:	6a38      	ldr	r0, [r7, #32]
 801fa42:	f7ff fc52 	bl	801f2ea <att_server_request_can_send_now>
                	break;
 801fa46:	e010      	b.n	801fa6a <att_event_packet_handler+0x476>
                    break;
 801fa48:	bf00      	nop
 801fa4a:	e014      	b.n	801fa76 <att_event_packet_handler+0x482>
                    if (!hci_connection) break;
 801fa4c:	bf00      	nop
 801fa4e:	e012      	b.n	801fa76 <att_event_packet_handler+0x482>
                    if (gap_get_connection_type(con_handle) != GAP_CONNECTION_LE) break;
 801fa50:	bf00      	nop
 801fa52:	e010      	b.n	801fa76 <att_event_packet_handler+0x482>
                    if (!hci_connection) break;
 801fa54:	bf00      	nop
 801fa56:	e00e      	b.n	801fa76 <att_event_packet_handler+0x482>
                    if (!hci_connection) break;
 801fa58:	bf00      	nop
 801fa5a:	e00c      	b.n	801fa76 <att_event_packet_handler+0x482>
                    if (!hci_connection) break;
 801fa5c:	bf00      	nop
 801fa5e:	e00a      	b.n	801fa76 <att_event_packet_handler+0x482>
                    if (!hci_connection) break;
 801fa60:	bf00      	nop
 801fa62:	e008      	b.n	801fa76 <att_event_packet_handler+0x482>
                    if (att_server->ir_le_device_db_index < 0) break;
 801fa64:	bf00      	nop
 801fa66:	e006      	b.n	801fa76 <att_event_packet_handler+0x482>
                    if (!hci_connection) break;
 801fa68:	bf00      	nop
            break;
 801fa6a:	e004      	b.n	801fa76 <att_event_packet_handler+0x482>
                    if (!hci_connection) return;
 801fa6c:	bf00      	nop
 801fa6e:	e002      	b.n	801fa76 <att_event_packet_handler+0x482>
                    if (!hci_connection) return;
 801fa70:	bf00      	nop
 801fa72:	e000      	b.n	801fa76 <att_event_packet_handler+0x482>
                    if (!hci_connection) return;
 801fa74:	bf00      	nop
    }
}
 801fa76:	3728      	adds	r7, #40	; 0x28
 801fa78:	46bd      	mov	sp, r7
 801fa7a:	bd80      	pop	{r7, pc}
 801fa7c:	0802ced4 	.word	0x0802ced4
 801fa80:	0802cee4 	.word	0x0802cee4
 801fa84:	0802cf2c 	.word	0x0802cf2c
 801fa88:	0802cf58 	.word	0x0802cf58
 801fa8c:	0802cf88 	.word	0x0802cf88
 801fa90:	0802cfb4 	.word	0x0802cfb4

0801fa94 <att_server_process_validated_request>:
#endif

// pre: att_server->state == ATT_SERVER_REQUEST_RECEIVED_AND_VALIDATED
// pre: can send now
// returns: 1 if packet was sent
static int att_server_process_validated_request(hci_connection_t * hci_connection){
 801fa94:	b590      	push	{r4, r7, lr}
 801fa96:	b089      	sub	sp, #36	; 0x24
 801fa98:	af02      	add	r7, sp, #8
 801fa9a:	6078      	str	r0, [r7, #4]
    att_server_t * att_server = & hci_connection->att_server;
 801fa9c:	687b      	ldr	r3, [r7, #4]
 801fa9e:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801faa2:	617b      	str	r3, [r7, #20]
    att_connection_t * att_connection = &hci_connection->att_connection;
 801faa4:	687b      	ldr	r3, [r7, #4]
 801faa6:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801faaa:	613b      	str	r3, [r7, #16]

    l2cap_reserve_packet_buffer();
 801faac:	f7f8 fe21 	bl	80186f2 <l2cap_reserve_packet_buffer>
    uint8_t * att_response_buffer = l2cap_get_outgoing_buffer();
 801fab0:	f7f8 fe17 	bl	80186e2 <l2cap_get_outgoing_buffer>
 801fab4:	60f8      	str	r0, [r7, #12]
    uint16_t  att_response_size   = att_handle_request(att_connection, att_server->request_buffer, att_server->request_size, att_response_buffer);
 801fab6:	697b      	ldr	r3, [r7, #20]
 801fab8:	f103 012e 	add.w	r1, r3, #46	; 0x2e
 801fabc:	697b      	ldr	r3, [r7, #20]
 801fabe:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 801fac0:	68fb      	ldr	r3, [r7, #12]
 801fac2:	6938      	ldr	r0, [r7, #16]
 801fac4:	f7ff f8b4 	bl	801ec30 <att_handle_request>
 801fac8:	4603      	mov	r3, r0
 801faca:	817b      	strh	r3, [r7, #10]

#ifdef ENABLE_ATT_DELAYED_RESPONSE
    if ((att_response_size == ATT_READ_RESPONSE_PENDING) || (att_response_size == ATT_INTERNAL_WRITE_RESPONSE_PENDING)){
 801facc:	897b      	ldrh	r3, [r7, #10]
 801face:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801fad2:	4293      	cmp	r3, r2
 801fad4:	d004      	beq.n	801fae0 <att_server_process_validated_request+0x4c>
 801fad6:	897b      	ldrh	r3, [r7, #10]
 801fad8:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 801fadc:	4293      	cmp	r3, r2
 801fade:	d116      	bne.n	801fb0e <att_server_process_validated_request+0x7a>
        // update state
        att_server->state = ATT_SERVER_RESPONSE_PENDING;
 801fae0:	697b      	ldr	r3, [r7, #20]
 801fae2:	2204      	movs	r2, #4
 801fae4:	701a      	strb	r2, [r3, #0]

        // callback with handle ATT_READ_RESPONSE_PENDING for reads
        if (att_response_size == ATT_READ_RESPONSE_PENDING){
 801fae6:	897b      	ldrh	r3, [r7, #10]
 801fae8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801faec:	4293      	cmp	r3, r2
 801faee:	d10a      	bne.n	801fb06 <att_server_process_validated_request+0x72>
            att_server_client_read_callback(att_connection->con_handle, ATT_READ_RESPONSE_PENDING, 0, NULL, 0);
 801faf0:	4b2c      	ldr	r3, [pc, #176]	; (801fba4 <att_server_process_validated_request+0x110>)
 801faf2:	681c      	ldr	r4, [r3, #0]
 801faf4:	693b      	ldr	r3, [r7, #16]
 801faf6:	8818      	ldrh	r0, [r3, #0]
 801faf8:	2300      	movs	r3, #0
 801fafa:	9300      	str	r3, [sp, #0]
 801fafc:	2300      	movs	r3, #0
 801fafe:	2200      	movs	r2, #0
 801fb00:	f64f 71ff 	movw	r1, #65535	; 0xffff
 801fb04:	47a0      	blx	r4
        }

        // free reserved buffer
        l2cap_release_packet_buffer();
 801fb06:	f7f8 fdfb 	bl	8018700 <l2cap_release_packet_buffer>
        return 0;
 801fb0a:	2300      	movs	r3, #0
 801fb0c:	e046      	b.n	801fb9c <att_server_process_validated_request+0x108>
    }
#endif

    // intercept "insufficient authorization" for authenticated connections to allow for user authorization
    if ((att_response_size     >= 4u)
 801fb0e:	897b      	ldrh	r3, [r7, #10]
 801fb10:	2b03      	cmp	r3, #3
 801fb12:	d924      	bls.n	801fb5e <att_server_process_validated_request+0xca>
    && (att_response_buffer[0] == ATT_ERROR_RESPONSE)
 801fb14:	68fb      	ldr	r3, [r7, #12]
 801fb16:	781b      	ldrb	r3, [r3, #0]
 801fb18:	2b01      	cmp	r3, #1
 801fb1a:	d120      	bne.n	801fb5e <att_server_process_validated_request+0xca>
    && (att_response_buffer[4] == ATT_ERROR_INSUFFICIENT_AUTHORIZATION)
 801fb1c:	68fb      	ldr	r3, [r7, #12]
 801fb1e:	3304      	adds	r3, #4
 801fb20:	781b      	ldrb	r3, [r3, #0]
 801fb22:	2b08      	cmp	r3, #8
 801fb24:	d11b      	bne.n	801fb5e <att_server_process_validated_request+0xca>
    && (att_connection->authenticated)){
 801fb26:	693b      	ldr	r3, [r7, #16]
 801fb28:	7a1b      	ldrb	r3, [r3, #8]
 801fb2a:	2b00      	cmp	r3, #0
 801fb2c:	d017      	beq.n	801fb5e <att_server_process_validated_request+0xca>

        switch (gap_authorization_state(att_connection->con_handle)){
 801fb2e:	693b      	ldr	r3, [r7, #16]
 801fb30:	881b      	ldrh	r3, [r3, #0]
 801fb32:	4618      	mov	r0, r3
 801fb34:	f7f7 f8c0 	bl	8016cb8 <gap_authorization_state>
 801fb38:	4603      	mov	r3, r0
 801fb3a:	2b00      	cmp	r3, #0
 801fb3c:	d002      	beq.n	801fb44 <att_server_process_validated_request+0xb0>
 801fb3e:	2b01      	cmp	r3, #1
 801fb40:	d009      	beq.n	801fb56 <att_server_process_validated_request+0xc2>
                return 0;
            case AUTHORIZATION_PENDING:
                l2cap_release_packet_buffer();
                return 0;
            default:
                break;
 801fb42:	e00d      	b.n	801fb60 <att_server_process_validated_request+0xcc>
                l2cap_release_packet_buffer();
 801fb44:	f7f8 fddc 	bl	8018700 <l2cap_release_packet_buffer>
                sm_request_pairing(att_connection->con_handle);
 801fb48:	693b      	ldr	r3, [r7, #16]
 801fb4a:	881b      	ldrh	r3, [r3, #0]
 801fb4c:	4618      	mov	r0, r3
 801fb4e:	f007 fb25 	bl	802719c <sm_request_pairing>
                return 0;
 801fb52:	2300      	movs	r3, #0
 801fb54:	e022      	b.n	801fb9c <att_server_process_validated_request+0x108>
                l2cap_release_packet_buffer();
 801fb56:	f7f8 fdd3 	bl	8018700 <l2cap_release_packet_buffer>
                return 0;
 801fb5a:	2300      	movs	r3, #0
 801fb5c:	e01e      	b.n	801fb9c <att_server_process_validated_request+0x108>
        }
    }
 801fb5e:	bf00      	nop

    att_server->state = ATT_SERVER_IDLE;
 801fb60:	697b      	ldr	r3, [r7, #20]
 801fb62:	2200      	movs	r2, #0
 801fb64:	701a      	strb	r2, [r3, #0]
    if (att_response_size == 0u) {
 801fb66:	897b      	ldrh	r3, [r7, #10]
 801fb68:	2b00      	cmp	r3, #0
 801fb6a:	d103      	bne.n	801fb74 <att_server_process_validated_request+0xe0>
        l2cap_release_packet_buffer();
 801fb6c:	f7f8 fdc8 	bl	8018700 <l2cap_release_packet_buffer>
        return 0;
 801fb70:	2300      	movs	r3, #0
 801fb72:	e013      	b.n	801fb9c <att_server_process_validated_request+0x108>
    if (att_server->l2cap_cid != 0){
        l2cap_send_prepared(att_server->l2cap_cid, att_response_size);
    } else
#endif
    {
        l2cap_send_prepared_connectionless(att_connection->con_handle, L2CAP_CID_ATTRIBUTE_PROTOCOL, att_response_size);
 801fb74:	693b      	ldr	r3, [r7, #16]
 801fb76:	881b      	ldrh	r3, [r3, #0]
 801fb78:	897a      	ldrh	r2, [r7, #10]
 801fb7a:	2104      	movs	r1, #4
 801fb7c:	4618      	mov	r0, r3
 801fb7e:	f7f8 fdf7 	bl	8018770 <l2cap_send_prepared_connectionless>
    }

    // notify client about MTU exchange result
    if (att_response_buffer[0] == ATT_EXCHANGE_MTU_RESPONSE){
 801fb82:	68fb      	ldr	r3, [r7, #12]
 801fb84:	781b      	ldrb	r3, [r3, #0]
 801fb86:	2b03      	cmp	r3, #3
 801fb88:	d107      	bne.n	801fb9a <att_server_process_validated_request+0x106>
        att_emit_mtu_event(att_connection->con_handle, att_connection->mtu);
 801fb8a:	693b      	ldr	r3, [r7, #16]
 801fb8c:	881a      	ldrh	r2, [r3, #0]
 801fb8e:	693b      	ldr	r3, [r7, #16]
 801fb90:	885b      	ldrh	r3, [r3, #2]
 801fb92:	4619      	mov	r1, r3
 801fb94:	4610      	mov	r0, r2
 801fb96:	f7ff fc57 	bl	801f448 <att_emit_mtu_event>
    }
    return 1;
 801fb9a:	2301      	movs	r3, #1
}
 801fb9c:	4618      	mov	r0, r3
 801fb9e:	371c      	adds	r7, #28
 801fba0:	46bd      	mov	sp, r7
 801fba2:	bd90      	pop	{r4, r7, pc}
 801fba4:	20009f1c 	.word	0x20009f1c

0801fba8 <att_run_for_context>:
    att_server_request_can_send_now(hci_connection);
    return ERROR_CODE_SUCCESS;
}
#endif

static void att_run_for_context(hci_connection_t * hci_connection){
 801fba8:	b580      	push	{r7, lr}
 801fbaa:	b084      	sub	sp, #16
 801fbac:	af00      	add	r7, sp, #0
 801fbae:	6078      	str	r0, [r7, #4]
    att_server_t * att_server = &hci_connection->att_server;
 801fbb0:	687b      	ldr	r3, [r7, #4]
 801fbb2:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801fbb6:	60fb      	str	r3, [r7, #12]
    att_connection_t * att_connection = &hci_connection->att_connection;
 801fbb8:	687b      	ldr	r3, [r7, #4]
 801fbba:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801fbbe:	60bb      	str	r3, [r7, #8]
    switch (att_server->state){
 801fbc0:	68fb      	ldr	r3, [r7, #12]
 801fbc2:	781b      	ldrb	r3, [r3, #0]
 801fbc4:	2b01      	cmp	r3, #1
 801fbc6:	d000      	beq.n	801fbca <att_run_for_context+0x22>
            att_server->state = ATT_SERVER_REQUEST_RECEIVED_AND_VALIDATED;
            att_server_request_can_send_now(hci_connection);
            break;

        default:
            break;
 801fbc8:	e015      	b.n	801fbf6 <att_run_for_context+0x4e>
                if (gap_reconnect_security_setup_active(att_connection->con_handle)) break;
 801fbca:	68bb      	ldr	r3, [r7, #8]
 801fbcc:	881b      	ldrh	r3, [r3, #0]
 801fbce:	4618      	mov	r0, r3
 801fbd0:	f007 fc55 	bl	802747e <gap_reconnect_security_setup_active>
 801fbd4:	4603      	mov	r3, r0
 801fbd6:	2b00      	cmp	r3, #0
 801fbd8:	d10a      	bne.n	801fbf0 <att_run_for_context+0x48>
            if (att_server->pairing_active) break;
 801fbda:	68fb      	ldr	r3, [r7, #12]
 801fbdc:	7b5b      	ldrb	r3, [r3, #13]
 801fbde:	2b00      	cmp	r3, #0
 801fbe0:	d108      	bne.n	801fbf4 <att_run_for_context+0x4c>
            att_server->state = ATT_SERVER_REQUEST_RECEIVED_AND_VALIDATED;
 801fbe2:	68fb      	ldr	r3, [r7, #12]
 801fbe4:	2203      	movs	r2, #3
 801fbe6:	701a      	strb	r2, [r3, #0]
            att_server_request_can_send_now(hci_connection);
 801fbe8:	6878      	ldr	r0, [r7, #4]
 801fbea:	f7ff fb7e 	bl	801f2ea <att_server_request_can_send_now>
            break;
 801fbee:	e002      	b.n	801fbf6 <att_run_for_context+0x4e>
                if (gap_reconnect_security_setup_active(att_connection->con_handle)) break;
 801fbf0:	bf00      	nop
 801fbf2:	e000      	b.n	801fbf6 <att_run_for_context+0x4e>
            if (att_server->pairing_active) break;
 801fbf4:	bf00      	nop
    }   
}
 801fbf6:	bf00      	nop
 801fbf8:	3710      	adds	r7, #16
 801fbfa:	46bd      	mov	sp, r7
 801fbfc:	bd80      	pop	{r7, pc}

0801fbfe <att_server_data_ready_for_phase>:

static bool att_server_data_ready_for_phase(att_server_t * att_server,  att_server_run_phase_t phase){
 801fbfe:	b580      	push	{r7, lr}
 801fc00:	b082      	sub	sp, #8
 801fc02:	af00      	add	r7, sp, #0
 801fc04:	6078      	str	r0, [r7, #4]
 801fc06:	460b      	mov	r3, r1
 801fc08:	70fb      	strb	r3, [r7, #3]
    switch (phase){
 801fc0a:	78fb      	ldrb	r3, [r7, #3]
 801fc0c:	2b01      	cmp	r3, #1
 801fc0e:	d00b      	beq.n	801fc28 <att_server_data_ready_for_phase+0x2a>
 801fc10:	2b02      	cmp	r3, #2
 801fc12:	d01f      	beq.n	801fc54 <att_server_data_ready_for_phase+0x56>
 801fc14:	2b00      	cmp	r3, #0
 801fc16:	d12f      	bne.n	801fc78 <att_server_data_ready_for_phase+0x7a>
        case ATT_SERVER_RUN_PHASE_1_REQUESTS:
            return att_server->state == ATT_SERVER_REQUEST_RECEIVED_AND_VALIDATED;
 801fc18:	687b      	ldr	r3, [r7, #4]
 801fc1a:	781b      	ldrb	r3, [r3, #0]
 801fc1c:	2b03      	cmp	r3, #3
 801fc1e:	bf0c      	ite	eq
 801fc20:	2301      	moveq	r3, #1
 801fc22:	2300      	movne	r3, #0
 801fc24:	b2db      	uxtb	r3, r3
 801fc26:	e028      	b.n	801fc7a <att_server_data_ready_for_phase+0x7c>
        case ATT_SERVER_RUN_PHASE_2_INDICATIONS:
             return (!btstack_linked_list_empty(&att_server->indication_requests) && (att_server->value_indication_handle == 0));
 801fc28:	687b      	ldr	r3, [r7, #4]
 801fc2a:	3328      	adds	r3, #40	; 0x28
 801fc2c:	4618      	mov	r0, r3
 801fc2e:	f7ee fcef 	bl	800e610 <btstack_linked_list_empty>
 801fc32:	4603      	mov	r3, r0
 801fc34:	f083 0301 	eor.w	r3, r3, #1
 801fc38:	b2db      	uxtb	r3, r3
 801fc3a:	2b00      	cmp	r3, #0
 801fc3c:	d005      	beq.n	801fc4a <att_server_data_ready_for_phase+0x4c>
 801fc3e:	687b      	ldr	r3, [r7, #4]
 801fc40:	691b      	ldr	r3, [r3, #16]
 801fc42:	2b00      	cmp	r3, #0
 801fc44:	d101      	bne.n	801fc4a <att_server_data_ready_for_phase+0x4c>
 801fc46:	2301      	movs	r3, #1
 801fc48:	e000      	b.n	801fc4c <att_server_data_ready_for_phase+0x4e>
 801fc4a:	2300      	movs	r3, #0
 801fc4c:	f003 0301 	and.w	r3, r3, #1
 801fc50:	b2db      	uxtb	r3, r3
 801fc52:	e012      	b.n	801fc7a <att_server_data_ready_for_phase+0x7c>
        case ATT_SERVER_RUN_PHASE_3_NOTIFICATIONS:
            return (!btstack_linked_list_empty(&att_server->notification_requests));
 801fc54:	687b      	ldr	r3, [r7, #4]
 801fc56:	3324      	adds	r3, #36	; 0x24
 801fc58:	4618      	mov	r0, r3
 801fc5a:	f7ee fcd9 	bl	800e610 <btstack_linked_list_empty>
 801fc5e:	4603      	mov	r3, r0
 801fc60:	2b00      	cmp	r3, #0
 801fc62:	bf14      	ite	ne
 801fc64:	2301      	movne	r3, #1
 801fc66:	2300      	moveq	r3, #0
 801fc68:	b2db      	uxtb	r3, r3
 801fc6a:	f083 0301 	eor.w	r3, r3, #1
 801fc6e:	b2db      	uxtb	r3, r3
 801fc70:	f003 0301 	and.w	r3, r3, #1
 801fc74:	b2db      	uxtb	r3, r3
 801fc76:	e000      	b.n	801fc7a <att_server_data_ready_for_phase+0x7c>
        default:
            btstack_assert(false);
            return false;
 801fc78:	2300      	movs	r3, #0
    }
}
 801fc7a:	4618      	mov	r0, r3
 801fc7c:	3708      	adds	r7, #8
 801fc7e:	46bd      	mov	sp, r7
 801fc80:	bd80      	pop	{r7, pc}

0801fc82 <att_server_trigger_send_for_phase>:

static void att_server_trigger_send_for_phase(hci_connection_t * hci_connection,  att_server_run_phase_t phase){
 801fc82:	b580      	push	{r7, lr}
 801fc84:	b084      	sub	sp, #16
 801fc86:	af00      	add	r7, sp, #0
 801fc88:	6078      	str	r0, [r7, #4]
 801fc8a:	460b      	mov	r3, r1
 801fc8c:	70fb      	strb	r3, [r7, #3]
    btstack_context_callback_registration_t * client;
    att_server_t * att_server = &hci_connection->att_server;
 801fc8e:	687b      	ldr	r3, [r7, #4]
 801fc90:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801fc94:	60fb      	str	r3, [r7, #12]
    switch (phase){
 801fc96:	78fb      	ldrb	r3, [r7, #3]
 801fc98:	2b01      	cmp	r3, #1
 801fc9a:	d008      	beq.n	801fcae <att_server_trigger_send_for_phase+0x2c>
 801fc9c:	2b02      	cmp	r3, #2
 801fc9e:	d016      	beq.n	801fcce <att_server_trigger_send_for_phase+0x4c>
 801fca0:	2b00      	cmp	r3, #0
 801fca2:	d000      	beq.n	801fca6 <att_server_trigger_send_for_phase+0x24>
            btstack_linked_list_remove(&att_server->notification_requests, (btstack_linked_item_t *) client);
            client->callback(client->context);
            break;
        default:
            btstack_assert(false);
            break;
 801fca4:	e023      	b.n	801fcee <att_server_trigger_send_for_phase+0x6c>
            att_server_process_validated_request(hci_connection);
 801fca6:	6878      	ldr	r0, [r7, #4]
 801fca8:	f7ff fef4 	bl	801fa94 <att_server_process_validated_request>
            break;
 801fcac:	e01f      	b.n	801fcee <att_server_trigger_send_for_phase+0x6c>
            client = (btstack_context_callback_registration_t*) att_server->indication_requests;
 801fcae:	68fb      	ldr	r3, [r7, #12]
 801fcb0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801fcb2:	60bb      	str	r3, [r7, #8]
            btstack_linked_list_remove(&att_server->indication_requests, (btstack_linked_item_t *) client);
 801fcb4:	68fb      	ldr	r3, [r7, #12]
 801fcb6:	3328      	adds	r3, #40	; 0x28
 801fcb8:	68b9      	ldr	r1, [r7, #8]
 801fcba:	4618      	mov	r0, r3
 801fcbc:	f7ee fcff 	bl	800e6be <btstack_linked_list_remove>
            client->callback(client->context);
 801fcc0:	68bb      	ldr	r3, [r7, #8]
 801fcc2:	685b      	ldr	r3, [r3, #4]
 801fcc4:	68ba      	ldr	r2, [r7, #8]
 801fcc6:	6892      	ldr	r2, [r2, #8]
 801fcc8:	4610      	mov	r0, r2
 801fcca:	4798      	blx	r3
            break;
 801fccc:	e00f      	b.n	801fcee <att_server_trigger_send_for_phase+0x6c>
            client = (btstack_context_callback_registration_t*) att_server->notification_requests;
 801fcce:	68fb      	ldr	r3, [r7, #12]
 801fcd0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801fcd2:	60bb      	str	r3, [r7, #8]
            btstack_linked_list_remove(&att_server->notification_requests, (btstack_linked_item_t *) client);
 801fcd4:	68fb      	ldr	r3, [r7, #12]
 801fcd6:	3324      	adds	r3, #36	; 0x24
 801fcd8:	68b9      	ldr	r1, [r7, #8]
 801fcda:	4618      	mov	r0, r3
 801fcdc:	f7ee fcef 	bl	800e6be <btstack_linked_list_remove>
            client->callback(client->context);
 801fce0:	68bb      	ldr	r3, [r7, #8]
 801fce2:	685b      	ldr	r3, [r3, #4]
 801fce4:	68ba      	ldr	r2, [r7, #8]
 801fce6:	6892      	ldr	r2, [r2, #8]
 801fce8:	4610      	mov	r0, r2
 801fcea:	4798      	blx	r3
            break;
 801fcec:	bf00      	nop
    }
}
 801fcee:	bf00      	nop
 801fcf0:	3710      	adds	r7, #16
 801fcf2:	46bd      	mov	sp, r7
 801fcf4:	bd80      	pop	{r7, pc}
	...

0801fcf8 <att_server_handle_can_send_now>:

static void att_server_handle_can_send_now(void){
 801fcf8:	b580      	push	{r7, lr}
 801fcfa:	b08c      	sub	sp, #48	; 0x30
 801fcfc:	af00      	add	r7, sp, #0

    hci_con_handle_t last_send_con_handle = HCI_CON_HANDLE_INVALID;
 801fcfe:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801fd02:	85fb      	strh	r3, [r7, #46]	; 0x2e
    hci_connection_t * request_hci_connection   = NULL;
 801fd04:	2300      	movs	r3, #0
 801fd06:	62bb      	str	r3, [r7, #40]	; 0x28
    bool can_send_now = true;
 801fd08:	2301      	movs	r3, #1
 801fd0a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    int phase_index;

    for (phase_index = ATT_SERVER_RUN_PHASE_1_REQUESTS; phase_index <= ATT_SERVER_RUN_PHASE_3_NOTIFICATIONS; phase_index++){
 801fd0e:	2300      	movs	r3, #0
 801fd10:	623b      	str	r3, [r7, #32]
 801fd12:	e080      	b.n	801fe16 <att_server_handle_can_send_now+0x11e>
        att_server_run_phase_t phase = (att_server_run_phase_t) phase_index;
 801fd14:	6a3b      	ldr	r3, [r7, #32]
 801fd16:	777b      	strb	r3, [r7, #29]
        hci_con_handle_t skip_connections_until = att_server_last_can_send_now;
 801fd18:	4b46      	ldr	r3, [pc, #280]	; (801fe34 <att_server_handle_can_send_now+0x13c>)
 801fd1a:	881b      	ldrh	r3, [r3, #0]
 801fd1c:	83fb      	strh	r3, [r7, #30]
        while (true){
            btstack_linked_list_iterator_t it;
            hci_connections_get_iterator(&it);
 801fd1e:	463b      	mov	r3, r7
 801fd20:	4618      	mov	r0, r3
 801fd22:	f7ef fdbd 	bl	800f8a0 <hci_connections_get_iterator>
            while(btstack_linked_list_iterator_has_next(&it)){
 801fd26:	e051      	b.n	801fdcc <att_server_handle_can_send_now+0xd4>
                hci_connection_t * connection = (hci_connection_t *) btstack_linked_list_iterator_next(&it);
 801fd28:	463b      	mov	r3, r7
 801fd2a:	4618      	mov	r0, r3
 801fd2c:	f7ee fd52 	bl	800e7d4 <btstack_linked_list_iterator_next>
 801fd30:	61b8      	str	r0, [r7, #24]
                att_server_t * att_server = &connection->att_server;
 801fd32:	69bb      	ldr	r3, [r7, #24]
 801fd34:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801fd38:	617b      	str	r3, [r7, #20]
                att_connection_t * att_connection = &connection->att_connection;
 801fd3a:	69bb      	ldr	r3, [r7, #24]
 801fd3c:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801fd40:	613b      	str	r3, [r7, #16]

                bool data_ready = att_server_data_ready_for_phase(att_server, phase);
 801fd42:	7f7b      	ldrb	r3, [r7, #29]
 801fd44:	4619      	mov	r1, r3
 801fd46:	6978      	ldr	r0, [r7, #20]
 801fd48:	f7ff ff59 	bl	801fbfe <att_server_data_ready_for_phase>
 801fd4c:	4603      	mov	r3, r0
 801fd4e:	73fb      	strb	r3, [r7, #15]

                // log_debug("phase %u, handle 0x%04x, skip until 0x%04x, data ready %u", phase, att_connection->con_handle, skip_connections_until, data_ready);

                // skip until last sender found (which is also skipped)
                if (skip_connections_until != HCI_CON_HANDLE_INVALID){
 801fd50:	8bfb      	ldrh	r3, [r7, #30]
 801fd52:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801fd56:	4293      	cmp	r3, r2
 801fd58:	d010      	beq.n	801fd7c <att_server_handle_can_send_now+0x84>
                    if (data_ready && (request_hci_connection == NULL)){
 801fd5a:	7bfb      	ldrb	r3, [r7, #15]
 801fd5c:	2b00      	cmp	r3, #0
 801fd5e:	d004      	beq.n	801fd6a <att_server_handle_can_send_now+0x72>
 801fd60:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801fd62:	2b00      	cmp	r3, #0
 801fd64:	d101      	bne.n	801fd6a <att_server_handle_can_send_now+0x72>
                        request_hci_connection = connection;
 801fd66:	69bb      	ldr	r3, [r7, #24]
 801fd68:	62bb      	str	r3, [r7, #40]	; 0x28
                    }
                    if (skip_connections_until == att_connection->con_handle){
 801fd6a:	693b      	ldr	r3, [r7, #16]
 801fd6c:	881b      	ldrh	r3, [r3, #0]
 801fd6e:	8bfa      	ldrh	r2, [r7, #30]
 801fd70:	429a      	cmp	r2, r3
 801fd72:	d12b      	bne.n	801fdcc <att_server_handle_can_send_now+0xd4>
                        skip_connections_until = HCI_CON_HANDLE_INVALID;
 801fd74:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801fd78:	83fb      	strh	r3, [r7, #30]
                    }
                    continue;
 801fd7a:	e027      	b.n	801fdcc <att_server_handle_can_send_now+0xd4>
                };

                if (data_ready){
 801fd7c:	7bfb      	ldrb	r3, [r7, #15]
 801fd7e:	2b00      	cmp	r3, #0
 801fd80:	d024      	beq.n	801fdcc <att_server_handle_can_send_now+0xd4>
                    if (can_send_now){
 801fd82:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801fd86:	2b00      	cmp	r3, #0
 801fd88:	d01d      	beq.n	801fdc6 <att_server_handle_can_send_now+0xce>
                        att_server_trigger_send_for_phase(connection, phase);
 801fd8a:	7f7b      	ldrb	r3, [r7, #29]
 801fd8c:	4619      	mov	r1, r3
 801fd8e:	69b8      	ldr	r0, [r7, #24]
 801fd90:	f7ff ff77 	bl	801fc82 <att_server_trigger_send_for_phase>
                        last_send_con_handle = att_connection->con_handle;
 801fd94:	693b      	ldr	r3, [r7, #16]
 801fd96:	881b      	ldrh	r3, [r3, #0]
 801fd98:	85fb      	strh	r3, [r7, #46]	; 0x2e
                        can_send_now = att_server_can_send_packet(connection);
 801fd9a:	69b8      	ldr	r0, [r7, #24]
 801fd9c:	f7ff fab6 	bl	801f30c <att_server_can_send_packet>
 801fda0:	4603      	mov	r3, r0
 801fda2:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                        data_ready = att_server_data_ready_for_phase(att_server, phase);
 801fda6:	7f7b      	ldrb	r3, [r7, #29]
 801fda8:	4619      	mov	r1, r3
 801fdaa:	6978      	ldr	r0, [r7, #20]
 801fdac:	f7ff ff27 	bl	801fbfe <att_server_data_ready_for_phase>
 801fdb0:	4603      	mov	r3, r0
 801fdb2:	73fb      	strb	r3, [r7, #15]
                        if (data_ready && (request_hci_connection == NULL)){
 801fdb4:	7bfb      	ldrb	r3, [r7, #15]
 801fdb6:	2b00      	cmp	r3, #0
 801fdb8:	d008      	beq.n	801fdcc <att_server_handle_can_send_now+0xd4>
 801fdba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801fdbc:	2b00      	cmp	r3, #0
 801fdbe:	d105      	bne.n	801fdcc <att_server_handle_can_send_now+0xd4>
                            request_hci_connection = connection;
 801fdc0:	69bb      	ldr	r3, [r7, #24]
 801fdc2:	62bb      	str	r3, [r7, #40]	; 0x28
 801fdc4:	e002      	b.n	801fdcc <att_server_handle_can_send_now+0xd4>
                        }
                    } else {
                        request_hci_connection = connection;
 801fdc6:	69bb      	ldr	r3, [r7, #24]
 801fdc8:	62bb      	str	r3, [r7, #40]	; 0x28
                        break;
 801fdca:	e006      	b.n	801fdda <att_server_handle_can_send_now+0xe2>
            while(btstack_linked_list_iterator_has_next(&it)){
 801fdcc:	463b      	mov	r3, r7
 801fdce:	4618      	mov	r0, r3
 801fdd0:	f7ee fcd2 	bl	800e778 <btstack_linked_list_iterator_has_next>
 801fdd4:	4603      	mov	r3, r0
 801fdd6:	2b00      	cmp	r3, #0
 801fdd8:	d1a6      	bne.n	801fd28 <att_server_handle_can_send_now+0x30>
                    }
                }
            }

            // stop skipping (handles disconnect by last send connection)
            skip_connections_until = HCI_CON_HANDLE_INVALID;
 801fdda:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801fdde:	83fb      	strh	r3, [r7, #30]

            // Exit loop, if we cannot send
            if (!can_send_now) break;
 801fde0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801fde4:	f083 0301 	eor.w	r3, r3, #1
 801fde8:	b2db      	uxtb	r3, r3
 801fdea:	2b00      	cmp	r3, #0
 801fdec:	d105      	bne.n	801fdfa <att_server_handle_can_send_now+0x102>

            // Exit loop, if we can send but there are also no further request
            if (request_hci_connection == NULL) break;
 801fdee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801fdf0:	2b00      	cmp	r3, #0
 801fdf2:	d004      	beq.n	801fdfe <att_server_handle_can_send_now+0x106>

            // Finally, if we still can send and there are requests, just try again
            request_hci_connection = NULL;
 801fdf4:	2300      	movs	r3, #0
 801fdf6:	62bb      	str	r3, [r7, #40]	; 0x28
        while (true){
 801fdf8:	e791      	b.n	801fd1e <att_server_handle_can_send_now+0x26>
            if (!can_send_now) break;
 801fdfa:	bf00      	nop
 801fdfc:	e000      	b.n	801fe00 <att_server_handle_can_send_now+0x108>
            if (request_hci_connection == NULL) break;
 801fdfe:	bf00      	nop
        }
        // update last send con handle for round robin
        if (last_send_con_handle != HCI_CON_HANDLE_INVALID){
 801fe00:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801fe02:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801fe06:	4293      	cmp	r3, r2
 801fe08:	d002      	beq.n	801fe10 <att_server_handle_can_send_now+0x118>
            att_server_last_can_send_now = last_send_con_handle;
 801fe0a:	4a0a      	ldr	r2, [pc, #40]	; (801fe34 <att_server_handle_can_send_now+0x13c>)
 801fe0c:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801fe0e:	8013      	strh	r3, [r2, #0]
    for (phase_index = ATT_SERVER_RUN_PHASE_1_REQUESTS; phase_index <= ATT_SERVER_RUN_PHASE_3_NOTIFICATIONS; phase_index++){
 801fe10:	6a3b      	ldr	r3, [r7, #32]
 801fe12:	3301      	adds	r3, #1
 801fe14:	623b      	str	r3, [r7, #32]
 801fe16:	6a3b      	ldr	r3, [r7, #32]
 801fe18:	2b02      	cmp	r3, #2
 801fe1a:	f77f af7b 	ble.w	801fd14 <att_server_handle_can_send_now+0x1c>
        }
    }

    if (request_hci_connection == NULL) return;
 801fe1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801fe20:	2b00      	cmp	r3, #0
 801fe22:	d003      	beq.n	801fe2c <att_server_handle_can_send_now+0x134>
    att_server_request_can_send_now(request_hci_connection);
 801fe24:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801fe26:	f7ff fa60 	bl	801f2ea <att_server_request_can_send_now>
 801fe2a:	e000      	b.n	801fe2e <att_server_handle_can_send_now+0x136>
    if (request_hci_connection == NULL) return;
 801fe2c:	bf00      	nop
}
 801fe2e:	3730      	adds	r7, #48	; 0x30
 801fe30:	46bd      	mov	sp, r7
 801fe32:	bd80      	pop	{r7, pc}
 801fe34:	2000009c 	.word	0x2000009c

0801fe38 <att_server_handle_att_pdu>:

static void att_server_handle_att_pdu(hci_connection_t * hci_connection, uint8_t * packet, uint16_t size){
 801fe38:	b580      	push	{r7, lr}
 801fe3a:	b08c      	sub	sp, #48	; 0x30
 801fe3c:	af04      	add	r7, sp, #16
 801fe3e:	60f8      	str	r0, [r7, #12]
 801fe40:	60b9      	str	r1, [r7, #8]
 801fe42:	4613      	mov	r3, r2
 801fe44:	80fb      	strh	r3, [r7, #6]
    att_server_t * att_server = &hci_connection->att_server;
 801fe46:	68fb      	ldr	r3, [r7, #12]
 801fe48:	f203 7354 	addw	r3, r3, #1876	; 0x754
 801fe4c:	61fb      	str	r3, [r7, #28]
    att_connection_t * att_connection = &hci_connection->att_connection;
 801fe4e:	68fb      	ldr	r3, [r7, #12]
 801fe50:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801fe54:	61bb      	str	r3, [r7, #24]

    // handle value indication confirms
    if ((packet[0] == ATT_HANDLE_VALUE_CONFIRMATION) && att_server->value_indication_handle){
 801fe56:	68bb      	ldr	r3, [r7, #8]
 801fe58:	781b      	ldrb	r3, [r3, #0]
 801fe5a:	2b1e      	cmp	r3, #30
 801fe5c:	d119      	bne.n	801fe92 <att_server_handle_att_pdu+0x5a>
 801fe5e:	69fb      	ldr	r3, [r7, #28]
 801fe60:	691b      	ldr	r3, [r3, #16]
 801fe62:	2b00      	cmp	r3, #0
 801fe64:	d015      	beq.n	801fe92 <att_server_handle_att_pdu+0x5a>
        btstack_run_loop_remove_timer(&att_server->value_indication_timer);
 801fe66:	69fb      	ldr	r3, [r7, #28]
 801fe68:	3314      	adds	r3, #20
 801fe6a:	4618      	mov	r0, r3
 801fe6c:	f7ee ff2e 	bl	800eccc <btstack_run_loop_remove_timer>
        uint16_t att_handle = att_server->value_indication_handle;
 801fe70:	69fb      	ldr	r3, [r7, #28]
 801fe72:	691b      	ldr	r3, [r3, #16]
 801fe74:	82fb      	strh	r3, [r7, #22]
        att_server->value_indication_handle = 0;    
 801fe76:	69fb      	ldr	r3, [r7, #28]
 801fe78:	2200      	movs	r2, #0
 801fe7a:	611a      	str	r2, [r3, #16]
        att_handle_value_indication_notify_client(0, att_connection->con_handle, att_handle);
 801fe7c:	69bb      	ldr	r3, [r7, #24]
 801fe7e:	881b      	ldrh	r3, [r3, #0]
 801fe80:	8afa      	ldrh	r2, [r7, #22]
 801fe82:	4619      	mov	r1, r3
 801fe84:	2000      	movs	r0, #0
 801fe86:	f7ff fa58 	bl	801f33a <att_handle_value_indication_notify_client>
        att_server_request_can_send_now(hci_connection);
 801fe8a:	68f8      	ldr	r0, [r7, #12]
 801fe8c:	f7ff fa2d 	bl	801f2ea <att_server_request_can_send_now>
        return;
 801fe90:	e042      	b.n	801ff18 <att_server_handle_att_pdu+0xe0>
    }

    // directly process command
    // note: signed write cannot be handled directly as authentication needs to be verified
    if (packet[0] == ATT_WRITE_COMMAND){
 801fe92:	68bb      	ldr	r3, [r7, #8]
 801fe94:	781b      	ldrb	r3, [r3, #0]
 801fe96:	2b52      	cmp	r3, #82	; 0x52
 801fe98:	d106      	bne.n	801fea8 <att_server_handle_att_pdu+0x70>
        att_handle_request(att_connection, packet, size, NULL);
 801fe9a:	88fa      	ldrh	r2, [r7, #6]
 801fe9c:	2300      	movs	r3, #0
 801fe9e:	68b9      	ldr	r1, [r7, #8]
 801fea0:	69b8      	ldr	r0, [r7, #24]
 801fea2:	f7fe fec5 	bl	801ec30 <att_handle_request>
        return;
 801fea6:	e037      	b.n	801ff18 <att_server_handle_att_pdu+0xe0>
    }

    // check size
    if (size > sizeof(att_server->request_buffer)) {
 801fea8:	88fb      	ldrh	r3, [r7, #6]
 801feaa:	f5b3 6fd4 	cmp.w	r3, #1696	; 0x6a0
 801feae:	d310      	bcc.n	801fed2 <att_server_handle_att_pdu+0x9a>
        log_info("drop att pdu 0x%02x as size %u > att_server->request_buffer %u", packet[0], size, (int) sizeof(att_server->request_buffer));
 801feb0:	68bb      	ldr	r3, [r7, #8]
 801feb2:	781b      	ldrb	r3, [r3, #0]
 801feb4:	4619      	mov	r1, r3
 801feb6:	88fb      	ldrh	r3, [r7, #6]
 801feb8:	f240 629f 	movw	r2, #1695	; 0x69f
 801febc:	9202      	str	r2, [sp, #8]
 801febe:	9301      	str	r3, [sp, #4]
 801fec0:	9100      	str	r1, [sp, #0]
 801fec2:	f44f 734a 	mov.w	r3, #808	; 0x328
 801fec6:	4a16      	ldr	r2, [pc, #88]	; (801ff20 <att_server_handle_att_pdu+0xe8>)
 801fec8:	4916      	ldr	r1, [pc, #88]	; (801ff24 <att_server_handle_att_pdu+0xec>)
 801feca:	2001      	movs	r0, #1
 801fecc:	f7f7 fab8 	bl	8017440 <hci_dump_log>
        return;
 801fed0:	e022      	b.n	801ff18 <att_server_handle_att_pdu+0xe0>
            att_server->state = ATT_SERVER_IDLE;
        }
    }
#endif
    // last request still in processing?
    if (att_server->state != ATT_SERVER_IDLE){
 801fed2:	69fb      	ldr	r3, [r7, #28]
 801fed4:	781b      	ldrb	r3, [r3, #0]
 801fed6:	2b00      	cmp	r3, #0
 801fed8:	d00e      	beq.n	801fef8 <att_server_handle_att_pdu+0xc0>
        log_info("skip att pdu 0x%02x as server not idle (state %u)", packet[0], att_server->state);
 801feda:	68bb      	ldr	r3, [r7, #8]
 801fedc:	781b      	ldrb	r3, [r3, #0]
 801fede:	461a      	mov	r2, r3
 801fee0:	69fb      	ldr	r3, [r7, #28]
 801fee2:	781b      	ldrb	r3, [r3, #0]
 801fee4:	9301      	str	r3, [sp, #4]
 801fee6:	9200      	str	r2, [sp, #0]
 801fee8:	f240 333a 	movw	r3, #826	; 0x33a
 801feec:	4a0c      	ldr	r2, [pc, #48]	; (801ff20 <att_server_handle_att_pdu+0xe8>)
 801feee:	490e      	ldr	r1, [pc, #56]	; (801ff28 <att_server_handle_att_pdu+0xf0>)
 801fef0:	2001      	movs	r0, #1
 801fef2:	f7f7 faa5 	bl	8017440 <hci_dump_log>
        return;
 801fef6:	e00f      	b.n	801ff18 <att_server_handle_att_pdu+0xe0>
    }

    // store request
    att_server->state = ATT_SERVER_REQUEST_RECEIVED;
 801fef8:	69fb      	ldr	r3, [r7, #28]
 801fefa:	2201      	movs	r2, #1
 801fefc:	701a      	strb	r2, [r3, #0]
    att_server->request_size = size;
 801fefe:	69fb      	ldr	r3, [r7, #28]
 801ff00:	88fa      	ldrh	r2, [r7, #6]
 801ff02:	859a      	strh	r2, [r3, #44]	; 0x2c
    (void)memcpy(att_server->request_buffer, packet, size);
 801ff04:	69fb      	ldr	r3, [r7, #28]
 801ff06:	332e      	adds	r3, #46	; 0x2e
 801ff08:	88fa      	ldrh	r2, [r7, #6]
 801ff0a:	68b9      	ldr	r1, [r7, #8]
 801ff0c:	4618      	mov	r0, r3
 801ff0e:	f007 fdb4 	bl	8027a7a <memcpy>

    att_run_for_context(hci_connection);
 801ff12:	68f8      	ldr	r0, [r7, #12]
 801ff14:	f7ff fe48 	bl	801fba8 <att_run_for_context>
}
 801ff18:	3720      	adds	r7, #32
 801ff1a:	46bd      	mov	sp, r7
 801ff1c:	bd80      	pop	{r7, pc}
 801ff1e:	bf00      	nop
 801ff20:	0802ced4 	.word	0x0802ced4
 801ff24:	0802cfd0 	.word	0x0802cfd0
 801ff28:	0802d018 	.word	0x0802d018

0801ff2c <att_packet_handler>:

static void att_packet_handler(uint8_t packet_type, uint16_t handle, uint8_t *packet, uint16_t size){
 801ff2c:	b580      	push	{r7, lr}
 801ff2e:	b086      	sub	sp, #24
 801ff30:	af00      	add	r7, sp, #0
 801ff32:	60ba      	str	r2, [r7, #8]
 801ff34:	461a      	mov	r2, r3
 801ff36:	4603      	mov	r3, r0
 801ff38:	73fb      	strb	r3, [r7, #15]
 801ff3a:	460b      	mov	r3, r1
 801ff3c:	81bb      	strh	r3, [r7, #12]
 801ff3e:	4613      	mov	r3, r2
 801ff40:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * hci_connection;
    att_connection_t * att_connection;

    switch (packet_type){
 801ff42:	7bfb      	ldrb	r3, [r7, #15]
 801ff44:	2b04      	cmp	r3, #4
 801ff46:	d002      	beq.n	801ff4e <att_packet_handler+0x22>
 801ff48:	2b08      	cmp	r3, #8
 801ff4a:	d021      	beq.n	801ff90 <att_packet_handler+0x64>

            att_server_handle_att_pdu(hci_connection, packet, size);
            break;
            
        default:
            break;
 801ff4c:	e030      	b.n	801ffb0 <att_packet_handler+0x84>
            switch (packet[0]){
 801ff4e:	68bb      	ldr	r3, [r7, #8]
 801ff50:	781b      	ldrb	r3, [r3, #0]
 801ff52:	2b78      	cmp	r3, #120	; 0x78
 801ff54:	d002      	beq.n	801ff5c <att_packet_handler+0x30>
 801ff56:	2bb5      	cmp	r3, #181	; 0xb5
 801ff58:	d003      	beq.n	801ff62 <att_packet_handler+0x36>
                    break;
 801ff5a:	e018      	b.n	801ff8e <att_packet_handler+0x62>
                    att_server_handle_can_send_now();
 801ff5c:	f7ff fecc 	bl	801fcf8 <att_server_handle_can_send_now>
                    break;
 801ff60:	e015      	b.n	801ff8e <att_packet_handler+0x62>
                    hci_connection = hci_connection_for_handle(handle);
 801ff62:	89bb      	ldrh	r3, [r7, #12]
 801ff64:	4618      	mov	r0, r3
 801ff66:	f7ef fcad 	bl	800f8c4 <hci_connection_for_handle>
 801ff6a:	6178      	str	r0, [r7, #20]
                    if (!hci_connection) break;
 801ff6c:	697b      	ldr	r3, [r7, #20]
 801ff6e:	2b00      	cmp	r3, #0
 801ff70:	d00c      	beq.n	801ff8c <att_packet_handler+0x60>
                    att_connection = &hci_connection->att_connection;
 801ff72:	697b      	ldr	r3, [r7, #20]
 801ff74:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 801ff78:	613b      	str	r3, [r7, #16]
                    att_connection->mtu = little_endian_read_16(packet, 4);
 801ff7a:	2104      	movs	r1, #4
 801ff7c:	68b8      	ldr	r0, [r7, #8]
 801ff7e:	f7ee ff32 	bl	800ede6 <little_endian_read_16>
 801ff82:	4603      	mov	r3, r0
 801ff84:	461a      	mov	r2, r3
 801ff86:	693b      	ldr	r3, [r7, #16]
 801ff88:	805a      	strh	r2, [r3, #2]
                    break;
 801ff8a:	e000      	b.n	801ff8e <att_packet_handler+0x62>
                    if (!hci_connection) break;
 801ff8c:	bf00      	nop
            break;
 801ff8e:	e00f      	b.n	801ffb0 <att_packet_handler+0x84>
            hci_connection = hci_connection_for_handle(handle);
 801ff90:	89bb      	ldrh	r3, [r7, #12]
 801ff92:	4618      	mov	r0, r3
 801ff94:	f7ef fc96 	bl	800f8c4 <hci_connection_for_handle>
 801ff98:	6178      	str	r0, [r7, #20]
            if (!hci_connection) break;
 801ff9a:	697b      	ldr	r3, [r7, #20]
 801ff9c:	2b00      	cmp	r3, #0
 801ff9e:	d006      	beq.n	801ffae <att_packet_handler+0x82>
            att_server_handle_att_pdu(hci_connection, packet, size);
 801ffa0:	88fb      	ldrh	r3, [r7, #6]
 801ffa2:	461a      	mov	r2, r3
 801ffa4:	68b9      	ldr	r1, [r7, #8]
 801ffa6:	6978      	ldr	r0, [r7, #20]
 801ffa8:	f7ff ff46 	bl	801fe38 <att_server_handle_att_pdu>
            break;
 801ffac:	e000      	b.n	801ffb0 <att_packet_handler+0x84>
            if (!hci_connection) break;
 801ffae:	bf00      	nop
    }
}
 801ffb0:	bf00      	nop
 801ffb2:	3718      	adds	r7, #24
 801ffb4:	46bd      	mov	sp, r7
 801ffb6:	bd80      	pop	{r7, pc}

0801ffb8 <att_server_persistent_ccc_tag_for_index>:

// ---------------------
// persistent CCC writes
static uint32_t att_server_persistent_ccc_tag_for_index(uint8_t index){
 801ffb8:	b480      	push	{r7}
 801ffba:	b083      	sub	sp, #12
 801ffbc:	af00      	add	r7, sp, #0
 801ffbe:	4603      	mov	r3, r0
 801ffc0:	71fb      	strb	r3, [r7, #7]
    return ('B' << 24u) | ('T' << 16u) | ('C' << 8u) | index;
 801ffc2:	79fa      	ldrb	r2, [r7, #7]
 801ffc4:	4b03      	ldr	r3, [pc, #12]	; (801ffd4 <att_server_persistent_ccc_tag_for_index+0x1c>)
 801ffc6:	4313      	orrs	r3, r2
}
 801ffc8:	4618      	mov	r0, r3
 801ffca:	370c      	adds	r7, #12
 801ffcc:	46bd      	mov	sp, r7
 801ffce:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ffd2:	4770      	bx	lr
 801ffd4:	42544300 	.word	0x42544300

0801ffd8 <att_server_persistent_ccc_write>:

static void att_server_persistent_ccc_write(hci_con_handle_t con_handle, uint16_t att_handle, uint16_t value){
 801ffd8:	b5b0      	push	{r4, r5, r7, lr}
 801ffda:	b098      	sub	sp, #96	; 0x60
 801ffdc:	af04      	add	r7, sp, #16
 801ffde:	4603      	mov	r3, r0
 801ffe0:	80fb      	strh	r3, [r7, #6]
 801ffe2:	460b      	mov	r3, r1
 801ffe4:	80bb      	strh	r3, [r7, #4]
 801ffe6:	4613      	mov	r3, r2
 801ffe8:	807b      	strh	r3, [r7, #2]
    // lookup att_server instance
    hci_connection_t * hci_connection = hci_connection_for_handle(con_handle);
 801ffea:	88fb      	ldrh	r3, [r7, #6]
 801ffec:	4618      	mov	r0, r3
 801ffee:	f7ef fc69 	bl	800f8c4 <hci_connection_for_handle>
 801fff2:	6378      	str	r0, [r7, #52]	; 0x34
    if (!hci_connection) return;
 801fff4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801fff6:	2b00      	cmp	r3, #0
 801fff8:	f000 80f3 	beq.w	80201e2 <att_server_persistent_ccc_write+0x20a>
    att_server_t * att_server = &hci_connection->att_server;
 801fffc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801fffe:	f203 7354 	addw	r3, r3, #1876	; 0x754
 8020002:	633b      	str	r3, [r7, #48]	; 0x30
    int le_device_index = att_server->ir_le_device_db_index;
 8020004:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020006:	689b      	ldr	r3, [r3, #8]
 8020008:	62fb      	str	r3, [r7, #44]	; 0x2c
    log_info("Store CCC value 0x%04x for handle 0x%04x of remote %s, le device id %d", value, att_handle, bd_addr_to_str(att_server->peer_address), le_device_index);
 802000a:	887c      	ldrh	r4, [r7, #2]
 802000c:	88bd      	ldrh	r5, [r7, #4]
 802000e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020010:	3302      	adds	r3, #2
 8020012:	4618      	mov	r0, r3
 8020014:	f7ef f9fc 	bl	800f410 <bd_addr_to_str>
 8020018:	4602      	mov	r2, r0
 802001a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802001c:	9303      	str	r3, [sp, #12]
 802001e:	9202      	str	r2, [sp, #8]
 8020020:	9501      	str	r5, [sp, #4]
 8020022:	9400      	str	r4, [sp, #0]
 8020024:	f240 3375 	movw	r3, #885	; 0x375
 8020028:	4a75      	ldr	r2, [pc, #468]	; (8020200 <att_server_persistent_ccc_write+0x228>)
 802002a:	4976      	ldr	r1, [pc, #472]	; (8020204 <att_server_persistent_ccc_write+0x22c>)
 802002c:	2001      	movs	r0, #1
 802002e:	f7f7 fa07 	bl	8017440 <hci_dump_log>

    // check if bonded
    if (le_device_index < 0) return;
 8020032:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020034:	2b00      	cmp	r3, #0
 8020036:	f2c0 80d6 	blt.w	80201e6 <att_server_persistent_ccc_write+0x20e>

    // get btstack_tlv
    const btstack_tlv_t * tlv_impl = NULL;
 802003a:	2300      	movs	r3, #0
 802003c:	61bb      	str	r3, [r7, #24]
    void * tlv_context;
    btstack_tlv_get_instance(&tlv_impl, &tlv_context);
 802003e:	f107 0214 	add.w	r2, r7, #20
 8020042:	f107 0318 	add.w	r3, r7, #24
 8020046:	4611      	mov	r1, r2
 8020048:	4618      	mov	r0, r3
 802004a:	f7ee fe97 	bl	800ed7c <btstack_tlv_get_instance>
    if (!tlv_impl) return;
 802004e:	69bb      	ldr	r3, [r7, #24]
 8020050:	2b00      	cmp	r3, #0
 8020052:	f000 80ca 	beq.w	80201ea <att_server_persistent_ccc_write+0x212>

    // update ccc tag
    int index;
    uint32_t highest_seq_nr = 0;
 8020056:	2300      	movs	r3, #0
 8020058:	64bb      	str	r3, [r7, #72]	; 0x48
    uint32_t lowest_seq_nr = 0;
 802005a:	2300      	movs	r3, #0
 802005c:	647b      	str	r3, [r7, #68]	; 0x44
    uint32_t tag_for_lowest_seq_nr = 0;
 802005e:	2300      	movs	r3, #0
 8020060:	643b      	str	r3, [r7, #64]	; 0x40
    uint32_t tag_for_empty = 0;
 8020062:	2300      	movs	r3, #0
 8020064:	63fb      	str	r3, [r7, #60]	; 0x3c
    persistent_ccc_entry_t entry;
    for (index=0;index<NVN_NUM_GATT_SERVER_CCC;index++){
 8020066:	2300      	movs	r3, #0
 8020068:	64fb      	str	r3, [r7, #76]	; 0x4c
 802006a:	e07b      	b.n	8020164 <att_server_persistent_ccc_write+0x18c>
        uint32_t tag = att_server_persistent_ccc_tag_for_index(index);
 802006c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802006e:	b2db      	uxtb	r3, r3
 8020070:	4618      	mov	r0, r3
 8020072:	f7ff ffa1 	bl	801ffb8 <att_server_persistent_ccc_tag_for_index>
 8020076:	6278      	str	r0, [r7, #36]	; 0x24
        int len = tlv_impl->get_tag(tlv_context, tag, (uint8_t *) &entry, sizeof(persistent_ccc_entry_t));
 8020078:	69bb      	ldr	r3, [r7, #24]
 802007a:	681c      	ldr	r4, [r3, #0]
 802007c:	6978      	ldr	r0, [r7, #20]
 802007e:	f107 020c 	add.w	r2, r7, #12
 8020082:	2308      	movs	r3, #8
 8020084:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8020086:	47a0      	blx	r4
 8020088:	6238      	str	r0, [r7, #32]

        // empty/invalid tag
        if (len != sizeof(persistent_ccc_entry_t)){
 802008a:	6a3b      	ldr	r3, [r7, #32]
 802008c:	2b08      	cmp	r3, #8
 802008e:	d002      	beq.n	8020096 <att_server_persistent_ccc_write+0xbe>
            tag_for_empty = tag;
 8020090:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8020092:	63fb      	str	r3, [r7, #60]	; 0x3c
            continue;
 8020094:	e063      	b.n	802015e <att_server_persistent_ccc_write+0x186>
        }
        // update highest seq nr
        if (entry.seq_nr > highest_seq_nr){
 8020096:	68fb      	ldr	r3, [r7, #12]
 8020098:	6cba      	ldr	r2, [r7, #72]	; 0x48
 802009a:	429a      	cmp	r2, r3
 802009c:	d201      	bcs.n	80200a2 <att_server_persistent_ccc_write+0xca>
            highest_seq_nr = entry.seq_nr;
 802009e:	68fb      	ldr	r3, [r7, #12]
 80200a0:	64bb      	str	r3, [r7, #72]	; 0x48
        }
        // find entry with lowest seq nr
        if ((tag_for_lowest_seq_nr == 0u) || (entry.seq_nr < lowest_seq_nr)){
 80200a2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80200a4:	2b00      	cmp	r3, #0
 80200a6:	d003      	beq.n	80200b0 <att_server_persistent_ccc_write+0xd8>
 80200a8:	68fb      	ldr	r3, [r7, #12]
 80200aa:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80200ac:	429a      	cmp	r2, r3
 80200ae:	d903      	bls.n	80200b8 <att_server_persistent_ccc_write+0xe0>
            tag_for_lowest_seq_nr = tag;
 80200b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80200b2:	643b      	str	r3, [r7, #64]	; 0x40
            lowest_seq_nr = entry.seq_nr;
 80200b4:	68fb      	ldr	r3, [r7, #12]
 80200b6:	647b      	str	r3, [r7, #68]	; 0x44
        }

        if (entry.device_index != le_device_index) continue;
 80200b8:	7cfb      	ldrb	r3, [r7, #19]
 80200ba:	461a      	mov	r2, r3
 80200bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80200be:	4293      	cmp	r3, r2
 80200c0:	d14a      	bne.n	8020158 <att_server_persistent_ccc_write+0x180>
        if (entry.att_handle   != att_handle)      continue;
 80200c2:	8a3b      	ldrh	r3, [r7, #16]
 80200c4:	88ba      	ldrh	r2, [r7, #4]
 80200c6:	429a      	cmp	r2, r3
 80200c8:	d148      	bne.n	802015c <att_server_persistent_ccc_write+0x184>

        // found matching entry
        if (value != 0){
 80200ca:	887b      	ldrh	r3, [r7, #2]
 80200cc:	2b00      	cmp	r3, #0
 80200ce:	d033      	beq.n	8020138 <att_server_persistent_ccc_write+0x160>
            // update
            if (entry.value == value) {
 80200d0:	7cbb      	ldrb	r3, [r7, #18]
 80200d2:	b29b      	uxth	r3, r3
 80200d4:	887a      	ldrh	r2, [r7, #2]
 80200d6:	429a      	cmp	r2, r3
 80200d8:	d109      	bne.n	80200ee <att_server_persistent_ccc_write+0x116>
                log_info("CCC Index %u: Up-to-date", index);
 80200da:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80200dc:	9300      	str	r3, [sp, #0]
 80200de:	f240 33a1 	movw	r3, #929	; 0x3a1
 80200e2:	4a47      	ldr	r2, [pc, #284]	; (8020200 <att_server_persistent_ccc_write+0x228>)
 80200e4:	4948      	ldr	r1, [pc, #288]	; (8020208 <att_server_persistent_ccc_write+0x230>)
 80200e6:	2001      	movs	r0, #1
 80200e8:	f7f7 f9aa 	bl	8017440 <hci_dump_log>
                return;
 80200ec:	e084      	b.n	80201f8 <att_server_persistent_ccc_write+0x220>
            }
            entry.value = value;
 80200ee:	887b      	ldrh	r3, [r7, #2]
 80200f0:	b2db      	uxtb	r3, r3
 80200f2:	74bb      	strb	r3, [r7, #18]
            entry.seq_nr = highest_seq_nr + 1u;
 80200f4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80200f6:	3301      	adds	r3, #1
 80200f8:	60fb      	str	r3, [r7, #12]
            log_info("CCC Index %u: Store", index);
 80200fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80200fc:	9300      	str	r3, [sp, #0]
 80200fe:	f240 33a6 	movw	r3, #934	; 0x3a6
 8020102:	4a3f      	ldr	r2, [pc, #252]	; (8020200 <att_server_persistent_ccc_write+0x228>)
 8020104:	4941      	ldr	r1, [pc, #260]	; (802020c <att_server_persistent_ccc_write+0x234>)
 8020106:	2001      	movs	r0, #1
 8020108:	f7f7 f99a 	bl	8017440 <hci_dump_log>
            int result = tlv_impl->store_tag(tlv_context, tag, (const uint8_t *) &entry, sizeof(persistent_ccc_entry_t));
 802010c:	69bb      	ldr	r3, [r7, #24]
 802010e:	685c      	ldr	r4, [r3, #4]
 8020110:	6978      	ldr	r0, [r7, #20]
 8020112:	f107 020c 	add.w	r2, r7, #12
 8020116:	2308      	movs	r3, #8
 8020118:	6a79      	ldr	r1, [r7, #36]	; 0x24
 802011a:	47a0      	blx	r4
 802011c:	61f8      	str	r0, [r7, #28]
            if (result != 0){
 802011e:	69fb      	ldr	r3, [r7, #28]
 8020120:	2b00      	cmp	r3, #0
 8020122:	d064      	beq.n	80201ee <att_server_persistent_ccc_write+0x216>
                log_error("Store tag index %u failed", index);
 8020124:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020126:	9300      	str	r3, [sp, #0]
 8020128:	f240 33a9 	movw	r3, #937	; 0x3a9
 802012c:	4a34      	ldr	r2, [pc, #208]	; (8020200 <att_server_persistent_ccc_write+0x228>)
 802012e:	4938      	ldr	r1, [pc, #224]	; (8020210 <att_server_persistent_ccc_write+0x238>)
 8020130:	2002      	movs	r0, #2
 8020132:	f7f7 f985 	bl	8017440 <hci_dump_log>
        } else {
            // delete
            log_info("CCC Index %u: Delete", index);
            tlv_impl->delete_tag(tlv_context, tag);
        }
        return;
 8020136:	e05a      	b.n	80201ee <att_server_persistent_ccc_write+0x216>
            log_info("CCC Index %u: Delete", index);
 8020138:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802013a:	9300      	str	r3, [sp, #0]
 802013c:	f240 33ad 	movw	r3, #941	; 0x3ad
 8020140:	4a2f      	ldr	r2, [pc, #188]	; (8020200 <att_server_persistent_ccc_write+0x228>)
 8020142:	4934      	ldr	r1, [pc, #208]	; (8020214 <att_server_persistent_ccc_write+0x23c>)
 8020144:	2001      	movs	r0, #1
 8020146:	f7f7 f97b 	bl	8017440 <hci_dump_log>
            tlv_impl->delete_tag(tlv_context, tag);
 802014a:	69bb      	ldr	r3, [r7, #24]
 802014c:	689b      	ldr	r3, [r3, #8]
 802014e:	697a      	ldr	r2, [r7, #20]
 8020150:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8020152:	4610      	mov	r0, r2
 8020154:	4798      	blx	r3
        return;
 8020156:	e04a      	b.n	80201ee <att_server_persistent_ccc_write+0x216>
        if (entry.device_index != le_device_index) continue;
 8020158:	bf00      	nop
 802015a:	e000      	b.n	802015e <att_server_persistent_ccc_write+0x186>
        if (entry.att_handle   != att_handle)      continue;
 802015c:	bf00      	nop
    for (index=0;index<NVN_NUM_GATT_SERVER_CCC;index++){
 802015e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020160:	3301      	adds	r3, #1
 8020162:	64fb      	str	r3, [r7, #76]	; 0x4c
 8020164:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020166:	2b13      	cmp	r3, #19
 8020168:	dd80      	ble.n	802006c <att_server_persistent_ccc_write+0x94>
    }

    log_info("tag_for_empty %"PRIx32", tag_for_lowest_seq_nr %"PRIx32, tag_for_empty, tag_for_lowest_seq_nr);
 802016a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802016c:	9301      	str	r3, [sp, #4]
 802016e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020170:	9300      	str	r3, [sp, #0]
 8020172:	f240 33b3 	movw	r3, #947	; 0x3b3
 8020176:	4a22      	ldr	r2, [pc, #136]	; (8020200 <att_server_persistent_ccc_write+0x228>)
 8020178:	4927      	ldr	r1, [pc, #156]	; (8020218 <att_server_persistent_ccc_write+0x240>)
 802017a:	2001      	movs	r0, #1
 802017c:	f7f7 f960 	bl	8017440 <hci_dump_log>

    if (value == 0u){
 8020180:	887b      	ldrh	r3, [r7, #2]
 8020182:	2b00      	cmp	r3, #0
 8020184:	d035      	beq.n	80201f2 <att_server_persistent_ccc_write+0x21a>
        // done
        return;
    }

    uint32_t tag_to_use = 0;
 8020186:	2300      	movs	r3, #0
 8020188:	63bb      	str	r3, [r7, #56]	; 0x38
    if (tag_for_empty != 0){
 802018a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802018c:	2b00      	cmp	r3, #0
 802018e:	d002      	beq.n	8020196 <att_server_persistent_ccc_write+0x1be>
        tag_to_use = tag_for_empty;
 8020190:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020192:	63bb      	str	r3, [r7, #56]	; 0x38
 8020194:	e004      	b.n	80201a0 <att_server_persistent_ccc_write+0x1c8>
    } else if (tag_for_lowest_seq_nr){
 8020196:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8020198:	2b00      	cmp	r3, #0
 802019a:	d02c      	beq.n	80201f6 <att_server_persistent_ccc_write+0x21e>
        tag_to_use = tag_for_lowest_seq_nr;
 802019c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802019e:	63bb      	str	r3, [r7, #56]	; 0x38
    } else {
        // should not happen
        return;
    }
    // store ccc tag
    entry.seq_nr       = highest_seq_nr + 1u;
 80201a0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80201a2:	3301      	adds	r3, #1
 80201a4:	60fb      	str	r3, [r7, #12]
    entry.device_index = le_device_index;
 80201a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80201a8:	b2db      	uxtb	r3, r3
 80201aa:	74fb      	strb	r3, [r7, #19]
    entry.att_handle   = att_handle;
 80201ac:	88bb      	ldrh	r3, [r7, #4]
 80201ae:	823b      	strh	r3, [r7, #16]
    entry.value        = value;
 80201b0:	887b      	ldrh	r3, [r7, #2]
 80201b2:	b2db      	uxtb	r3, r3
 80201b4:	74bb      	strb	r3, [r7, #18]
    int result = tlv_impl->store_tag(tlv_context, tag_to_use, (uint8_t *) &entry, sizeof(persistent_ccc_entry_t));
 80201b6:	69bb      	ldr	r3, [r7, #24]
 80201b8:	685c      	ldr	r4, [r3, #4]
 80201ba:	6978      	ldr	r0, [r7, #20]
 80201bc:	f107 020c 	add.w	r2, r7, #12
 80201c0:	2308      	movs	r3, #8
 80201c2:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80201c4:	47a0      	blx	r4
 80201c6:	62b8      	str	r0, [r7, #40]	; 0x28
    if (result != 0){
 80201c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80201ca:	2b00      	cmp	r3, #0
 80201cc:	d014      	beq.n	80201f8 <att_server_persistent_ccc_write+0x220>
        log_error("Store tag index %u failed", index);
 80201ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80201d0:	9300      	str	r3, [sp, #0]
 80201d2:	f240 33ca 	movw	r3, #970	; 0x3ca
 80201d6:	4a0a      	ldr	r2, [pc, #40]	; (8020200 <att_server_persistent_ccc_write+0x228>)
 80201d8:	490d      	ldr	r1, [pc, #52]	; (8020210 <att_server_persistent_ccc_write+0x238>)
 80201da:	2002      	movs	r0, #2
 80201dc:	f7f7 f930 	bl	8017440 <hci_dump_log>
 80201e0:	e00a      	b.n	80201f8 <att_server_persistent_ccc_write+0x220>
    if (!hci_connection) return;
 80201e2:	bf00      	nop
 80201e4:	e008      	b.n	80201f8 <att_server_persistent_ccc_write+0x220>
    if (le_device_index < 0) return;
 80201e6:	bf00      	nop
 80201e8:	e006      	b.n	80201f8 <att_server_persistent_ccc_write+0x220>
    if (!tlv_impl) return;
 80201ea:	bf00      	nop
 80201ec:	e004      	b.n	80201f8 <att_server_persistent_ccc_write+0x220>
        return;
 80201ee:	bf00      	nop
 80201f0:	e002      	b.n	80201f8 <att_server_persistent_ccc_write+0x220>
        return;
 80201f2:	bf00      	nop
 80201f4:	e000      	b.n	80201f8 <att_server_persistent_ccc_write+0x220>
        return;
 80201f6:	bf00      	nop
    }
}
 80201f8:	3750      	adds	r7, #80	; 0x50
 80201fa:	46bd      	mov	sp, r7
 80201fc:	bdb0      	pop	{r4, r5, r7, pc}
 80201fe:	bf00      	nop
 8020200:	0802ced4 	.word	0x0802ced4
 8020204:	0802d054 	.word	0x0802d054
 8020208:	0802d0a4 	.word	0x0802d0a4
 802020c:	0802d0c4 	.word	0x0802d0c4
 8020210:	0802d0e0 	.word	0x0802d0e0
 8020214:	0802d104 	.word	0x0802d104
 8020218:	0802d120 	.word	0x0802d120

0802021c <att_server_persistent_ccc_clear>:

static void att_server_persistent_ccc_clear(hci_connection_t * hci_connection){
 802021c:	b590      	push	{r4, r7, lr}
 802021e:	b08f      	sub	sp, #60	; 0x3c
 8020220:	af02      	add	r7, sp, #8
 8020222:	6078      	str	r0, [r7, #4]
    if (!hci_connection) return;
 8020224:	687b      	ldr	r3, [r7, #4]
 8020226:	2b00      	cmp	r3, #0
 8020228:	d05a      	beq.n	80202e0 <att_server_persistent_ccc_clear+0xc4>
    att_server_t * att_server = &hci_connection->att_server;
 802022a:	687b      	ldr	r3, [r7, #4]
 802022c:	f203 7354 	addw	r3, r3, #1876	; 0x754
 8020230:	62bb      	str	r3, [r7, #40]	; 0x28

    int le_device_index = att_server->ir_le_device_db_index;
 8020232:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020234:	689b      	ldr	r3, [r3, #8]
 8020236:	627b      	str	r3, [r7, #36]	; 0x24
    log_info("Clear CCC values of remote %s, le device id %d", bd_addr_to_str(att_server->peer_address), le_device_index);
 8020238:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802023a:	3302      	adds	r3, #2
 802023c:	4618      	mov	r0, r3
 802023e:	f7ef f8e7 	bl	800f410 <bd_addr_to_str>
 8020242:	4602      	mov	r2, r0
 8020244:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8020246:	9301      	str	r3, [sp, #4]
 8020248:	9200      	str	r2, [sp, #0]
 802024a:	f240 33d3 	movw	r3, #979	; 0x3d3
 802024e:	4a28      	ldr	r2, [pc, #160]	; (80202f0 <att_server_persistent_ccc_clear+0xd4>)
 8020250:	4928      	ldr	r1, [pc, #160]	; (80202f4 <att_server_persistent_ccc_clear+0xd8>)
 8020252:	2001      	movs	r0, #1
 8020254:	f7f7 f8f4 	bl	8017440 <hci_dump_log>
    // check if bonded
    if (le_device_index < 0) return;
 8020258:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802025a:	2b00      	cmp	r3, #0
 802025c:	db42      	blt.n	80202e4 <att_server_persistent_ccc_clear+0xc8>
    // get btstack_tlv
    const btstack_tlv_t * tlv_impl = NULL;
 802025e:	2300      	movs	r3, #0
 8020260:	61bb      	str	r3, [r7, #24]
    void * tlv_context;
    btstack_tlv_get_instance(&tlv_impl, &tlv_context);
 8020262:	f107 0214 	add.w	r2, r7, #20
 8020266:	f107 0318 	add.w	r3, r7, #24
 802026a:	4611      	mov	r1, r2
 802026c:	4618      	mov	r0, r3
 802026e:	f7ee fd85 	bl	800ed7c <btstack_tlv_get_instance>
    if (!tlv_impl) return;
 8020272:	69bb      	ldr	r3, [r7, #24]
 8020274:	2b00      	cmp	r3, #0
 8020276:	d037      	beq.n	80202e8 <att_server_persistent_ccc_clear+0xcc>
    // get all ccc tag
    int index;
    persistent_ccc_entry_t entry;
    for (index=0;index<NVN_NUM_GATT_SERVER_CCC;index++){
 8020278:	2300      	movs	r3, #0
 802027a:	62fb      	str	r3, [r7, #44]	; 0x2c
 802027c:	e02c      	b.n	80202d8 <att_server_persistent_ccc_clear+0xbc>
        uint32_t tag = att_server_persistent_ccc_tag_for_index(index);
 802027e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020280:	b2db      	uxtb	r3, r3
 8020282:	4618      	mov	r0, r3
 8020284:	f7ff fe98 	bl	801ffb8 <att_server_persistent_ccc_tag_for_index>
 8020288:	6238      	str	r0, [r7, #32]
        int len = tlv_impl->get_tag(tlv_context, tag, (uint8_t *) &entry, sizeof(persistent_ccc_entry_t));
 802028a:	69bb      	ldr	r3, [r7, #24]
 802028c:	681c      	ldr	r4, [r3, #0]
 802028e:	6978      	ldr	r0, [r7, #20]
 8020290:	f107 020c 	add.w	r2, r7, #12
 8020294:	2308      	movs	r3, #8
 8020296:	6a39      	ldr	r1, [r7, #32]
 8020298:	47a0      	blx	r4
 802029a:	61f8      	str	r0, [r7, #28]
        if (len != sizeof(persistent_ccc_entry_t)) continue;
 802029c:	69fb      	ldr	r3, [r7, #28]
 802029e:	2b08      	cmp	r3, #8
 80202a0:	d114      	bne.n	80202cc <att_server_persistent_ccc_clear+0xb0>
        if (entry.device_index != le_device_index) continue;
 80202a2:	7cfb      	ldrb	r3, [r7, #19]
 80202a4:	461a      	mov	r2, r3
 80202a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80202a8:	4293      	cmp	r3, r2
 80202aa:	d111      	bne.n	80202d0 <att_server_persistent_ccc_clear+0xb4>
        // delete entry
        log_info("CCC Index %u: Delete", index);
 80202ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80202ae:	9300      	str	r3, [sp, #0]
 80202b0:	f44f 7379 	mov.w	r3, #996	; 0x3e4
 80202b4:	4a0e      	ldr	r2, [pc, #56]	; (80202f0 <att_server_persistent_ccc_clear+0xd4>)
 80202b6:	4910      	ldr	r1, [pc, #64]	; (80202f8 <att_server_persistent_ccc_clear+0xdc>)
 80202b8:	2001      	movs	r0, #1
 80202ba:	f7f7 f8c1 	bl	8017440 <hci_dump_log>
        tlv_impl->delete_tag(tlv_context, tag);
 80202be:	69bb      	ldr	r3, [r7, #24]
 80202c0:	689b      	ldr	r3, [r3, #8]
 80202c2:	697a      	ldr	r2, [r7, #20]
 80202c4:	6a39      	ldr	r1, [r7, #32]
 80202c6:	4610      	mov	r0, r2
 80202c8:	4798      	blx	r3
 80202ca:	e002      	b.n	80202d2 <att_server_persistent_ccc_clear+0xb6>
        if (len != sizeof(persistent_ccc_entry_t)) continue;
 80202cc:	bf00      	nop
 80202ce:	e000      	b.n	80202d2 <att_server_persistent_ccc_clear+0xb6>
        if (entry.device_index != le_device_index) continue;
 80202d0:	bf00      	nop
    for (index=0;index<NVN_NUM_GATT_SERVER_CCC;index++){
 80202d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80202d4:	3301      	adds	r3, #1
 80202d6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80202d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80202da:	2b13      	cmp	r3, #19
 80202dc:	ddcf      	ble.n	802027e <att_server_persistent_ccc_clear+0x62>
 80202de:	e004      	b.n	80202ea <att_server_persistent_ccc_clear+0xce>
    if (!hci_connection) return;
 80202e0:	bf00      	nop
 80202e2:	e002      	b.n	80202ea <att_server_persistent_ccc_clear+0xce>
    if (le_device_index < 0) return;
 80202e4:	bf00      	nop
 80202e6:	e000      	b.n	80202ea <att_server_persistent_ccc_clear+0xce>
    if (!tlv_impl) return;
 80202e8:	bf00      	nop
    }  
}
 80202ea:	3734      	adds	r7, #52	; 0x34
 80202ec:	46bd      	mov	sp, r7
 80202ee:	bd90      	pop	{r4, r7, pc}
 80202f0:	0802ced4 	.word	0x0802ced4
 80202f4:	0802d158 	.word	0x0802d158
 80202f8:	0802d104 	.word	0x0802d104

080202fc <att_server_persistent_ccc_restore>:

static void att_server_persistent_ccc_restore(hci_connection_t * hci_connection){
 80202fc:	b590      	push	{r4, r7, lr}
 80202fe:	b095      	sub	sp, #84	; 0x54
 8020300:	af04      	add	r7, sp, #16
 8020302:	6078      	str	r0, [r7, #4]
    if (!hci_connection) return;
 8020304:	687b      	ldr	r3, [r7, #4]
 8020306:	2b00      	cmp	r3, #0
 8020308:	d07c      	beq.n	8020404 <att_server_persistent_ccc_restore+0x108>
    att_server_t * att_server = &hci_connection->att_server;
 802030a:	687b      	ldr	r3, [r7, #4]
 802030c:	f203 7354 	addw	r3, r3, #1876	; 0x754
 8020310:	63bb      	str	r3, [r7, #56]	; 0x38
    att_connection_t * att_connection = &hci_connection->att_connection;
 8020312:	687b      	ldr	r3, [r7, #4]
 8020314:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 8020318:	637b      	str	r3, [r7, #52]	; 0x34

    int le_device_index = att_server->ir_le_device_db_index;
 802031a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802031c:	689b      	ldr	r3, [r3, #8]
 802031e:	633b      	str	r3, [r7, #48]	; 0x30
    log_info("Restore CCC values of remote %s, le device id %d", bd_addr_to_str(att_server->peer_address), le_device_index);
 8020320:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8020322:	3302      	adds	r3, #2
 8020324:	4618      	mov	r0, r3
 8020326:	f7ef f873 	bl	800f410 <bd_addr_to_str>
 802032a:	4602      	mov	r2, r0
 802032c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802032e:	9301      	str	r3, [sp, #4]
 8020330:	9200      	str	r2, [sp, #0]
 8020332:	f240 33ef 	movw	r3, #1007	; 0x3ef
 8020336:	4a37      	ldr	r2, [pc, #220]	; (8020414 <att_server_persistent_ccc_restore+0x118>)
 8020338:	4937      	ldr	r1, [pc, #220]	; (8020418 <att_server_persistent_ccc_restore+0x11c>)
 802033a:	2001      	movs	r0, #1
 802033c:	f7f7 f880 	bl	8017440 <hci_dump_log>
    // check if bonded
    if (le_device_index < 0) return;
 8020340:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020342:	2b00      	cmp	r3, #0
 8020344:	db60      	blt.n	8020408 <att_server_persistent_ccc_restore+0x10c>
    // get btstack_tlv
    const btstack_tlv_t * tlv_impl = NULL;
 8020346:	2300      	movs	r3, #0
 8020348:	61fb      	str	r3, [r7, #28]
    void * tlv_context;
    btstack_tlv_get_instance(&tlv_impl, &tlv_context);
 802034a:	f107 0218 	add.w	r2, r7, #24
 802034e:	f107 031c 	add.w	r3, r7, #28
 8020352:	4611      	mov	r1, r2
 8020354:	4618      	mov	r0, r3
 8020356:	f7ee fd11 	bl	800ed7c <btstack_tlv_get_instance>
    if (!tlv_impl) return;
 802035a:	69fb      	ldr	r3, [r7, #28]
 802035c:	2b00      	cmp	r3, #0
 802035e:	d055      	beq.n	802040c <att_server_persistent_ccc_restore+0x110>
    // get all ccc tag
    int index;
    persistent_ccc_entry_t entry;
    for (index=0;index<NVN_NUM_GATT_SERVER_CCC;index++){
 8020360:	2300      	movs	r3, #0
 8020362:	63fb      	str	r3, [r7, #60]	; 0x3c
 8020364:	e04a      	b.n	80203fc <att_server_persistent_ccc_restore+0x100>
        uint32_t tag = att_server_persistent_ccc_tag_for_index(index);
 8020366:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020368:	b2db      	uxtb	r3, r3
 802036a:	4618      	mov	r0, r3
 802036c:	f7ff fe24 	bl	801ffb8 <att_server_persistent_ccc_tag_for_index>
 8020370:	62f8      	str	r0, [r7, #44]	; 0x2c
        int len = tlv_impl->get_tag(tlv_context, tag, (uint8_t *) &entry, sizeof(persistent_ccc_entry_t));
 8020372:	69fb      	ldr	r3, [r7, #28]
 8020374:	681c      	ldr	r4, [r3, #0]
 8020376:	69b8      	ldr	r0, [r7, #24]
 8020378:	f107 0210 	add.w	r2, r7, #16
 802037c:	2308      	movs	r3, #8
 802037e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8020380:	47a0      	blx	r4
 8020382:	62b8      	str	r0, [r7, #40]	; 0x28
        if (len != sizeof(persistent_ccc_entry_t)) continue;
 8020384:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020386:	2b08      	cmp	r3, #8
 8020388:	d130      	bne.n	80203ec <att_server_persistent_ccc_restore+0xf0>
        if (entry.device_index != le_device_index) continue;
 802038a:	7dfb      	ldrb	r3, [r7, #23]
 802038c:	461a      	mov	r2, r3
 802038e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020390:	4293      	cmp	r3, r2
 8020392:	d12d      	bne.n	80203f0 <att_server_persistent_ccc_restore+0xf4>
        // simulate write callback
        uint16_t attribute_handle = entry.att_handle;
 8020394:	8abb      	ldrh	r3, [r7, #20]
 8020396:	84fb      	strh	r3, [r7, #38]	; 0x26
        uint8_t  value[2];
        little_endian_store_16(value, 0, entry.value);
 8020398:	7dbb      	ldrb	r3, [r7, #22]
 802039a:	b29a      	uxth	r2, r3
 802039c:	f107 030c 	add.w	r3, r7, #12
 80203a0:	2100      	movs	r1, #0
 80203a2:	4618      	mov	r0, r3
 80203a4:	f7ee fd5f 	bl	800ee66 <little_endian_store_16>
        att_write_callback_t callback = att_server_write_callback_for_handle(attribute_handle);
 80203a8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80203aa:	4618      	mov	r0, r3
 80203ac:	f000 f880 	bl	80204b0 <att_server_write_callback_for_handle>
 80203b0:	6238      	str	r0, [r7, #32]
        if (!callback) continue;
 80203b2:	6a3b      	ldr	r3, [r7, #32]
 80203b4:	2b00      	cmp	r3, #0
 80203b6:	d01d      	beq.n	80203f4 <att_server_persistent_ccc_restore+0xf8>
        log_info("CCC Index %u: Set Attribute handle 0x%04x to value 0x%04x", index, attribute_handle, entry.value );
 80203b8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80203ba:	7dba      	ldrb	r2, [r7, #22]
 80203bc:	9202      	str	r2, [sp, #8]
 80203be:	9301      	str	r3, [sp, #4]
 80203c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80203c2:	9300      	str	r3, [sp, #0]
 80203c4:	f240 4305 	movw	r3, #1029	; 0x405
 80203c8:	4a12      	ldr	r2, [pc, #72]	; (8020414 <att_server_persistent_ccc_restore+0x118>)
 80203ca:	4914      	ldr	r1, [pc, #80]	; (802041c <att_server_persistent_ccc_restore+0x120>)
 80203cc:	2001      	movs	r0, #1
 80203ce:	f7f7 f837 	bl	8017440 <hci_dump_log>
        (*callback)(att_connection->con_handle, attribute_handle, ATT_TRANSACTION_MODE_NONE, 0, value, sizeof(value));
 80203d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80203d4:	8818      	ldrh	r0, [r3, #0]
 80203d6:	8cf9      	ldrh	r1, [r7, #38]	; 0x26
 80203d8:	2302      	movs	r3, #2
 80203da:	9301      	str	r3, [sp, #4]
 80203dc:	f107 030c 	add.w	r3, r7, #12
 80203e0:	9300      	str	r3, [sp, #0]
 80203e2:	6a3c      	ldr	r4, [r7, #32]
 80203e4:	2300      	movs	r3, #0
 80203e6:	2200      	movs	r2, #0
 80203e8:	47a0      	blx	r4
 80203ea:	e004      	b.n	80203f6 <att_server_persistent_ccc_restore+0xfa>
        if (len != sizeof(persistent_ccc_entry_t)) continue;
 80203ec:	bf00      	nop
 80203ee:	e002      	b.n	80203f6 <att_server_persistent_ccc_restore+0xfa>
        if (entry.device_index != le_device_index) continue;
 80203f0:	bf00      	nop
 80203f2:	e000      	b.n	80203f6 <att_server_persistent_ccc_restore+0xfa>
        if (!callback) continue;
 80203f4:	bf00      	nop
    for (index=0;index<NVN_NUM_GATT_SERVER_CCC;index++){
 80203f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80203f8:	3301      	adds	r3, #1
 80203fa:	63fb      	str	r3, [r7, #60]	; 0x3c
 80203fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80203fe:	2b13      	cmp	r3, #19
 8020400:	ddb1      	ble.n	8020366 <att_server_persistent_ccc_restore+0x6a>
 8020402:	e004      	b.n	802040e <att_server_persistent_ccc_restore+0x112>
    if (!hci_connection) return;
 8020404:	bf00      	nop
 8020406:	e002      	b.n	802040e <att_server_persistent_ccc_restore+0x112>
    if (le_device_index < 0) return;
 8020408:	bf00      	nop
 802040a:	e000      	b.n	802040e <att_server_persistent_ccc_restore+0x112>
    if (!tlv_impl) return;
 802040c:	bf00      	nop
    }
}
 802040e:	3744      	adds	r7, #68	; 0x44
 8020410:	46bd      	mov	sp, r7
 8020412:	bd90      	pop	{r4, r7, pc}
 8020414:	0802ced4 	.word	0x0802ced4
 8020418:	0802d190 	.word	0x0802d190
 802041c:	0802d1c8 	.word	0x0802d1c8

08020420 <att_service_handler_for_handle>:

// persistent CCC writes
// ---------------------

// gatt service management
static att_service_handler_t * att_service_handler_for_handle(uint16_t handle){
 8020420:	b580      	push	{r7, lr}
 8020422:	b086      	sub	sp, #24
 8020424:	af00      	add	r7, sp, #0
 8020426:	4603      	mov	r3, r0
 8020428:	80fb      	strh	r3, [r7, #6]
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &service_handlers);
 802042a:	f107 0308 	add.w	r3, r7, #8
 802042e:	4913      	ldr	r1, [pc, #76]	; (802047c <att_service_handler_for_handle+0x5c>)
 8020430:	4618      	mov	r0, r3
 8020432:	f7ee f98c 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 8020436:	e013      	b.n	8020460 <att_service_handler_for_handle+0x40>
        att_service_handler_t * handler = (att_service_handler_t*) btstack_linked_list_iterator_next(&it);
 8020438:	f107 0308 	add.w	r3, r7, #8
 802043c:	4618      	mov	r0, r3
 802043e:	f7ee f9c9 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8020442:	6178      	str	r0, [r7, #20]
        if (handler->start_handle > handle) continue;
 8020444:	697b      	ldr	r3, [r7, #20]
 8020446:	889b      	ldrh	r3, [r3, #4]
 8020448:	88fa      	ldrh	r2, [r7, #6]
 802044a:	429a      	cmp	r2, r3
 802044c:	d200      	bcs.n	8020450 <att_service_handler_for_handle+0x30>
 802044e:	e007      	b.n	8020460 <att_service_handler_for_handle+0x40>
        if (handler->end_handle   < handle) continue;
 8020450:	697b      	ldr	r3, [r7, #20]
 8020452:	88db      	ldrh	r3, [r3, #6]
 8020454:	88fa      	ldrh	r2, [r7, #6]
 8020456:	429a      	cmp	r2, r3
 8020458:	d900      	bls.n	802045c <att_service_handler_for_handle+0x3c>
 802045a:	e001      	b.n	8020460 <att_service_handler_for_handle+0x40>
        return handler;
 802045c:	697b      	ldr	r3, [r7, #20]
 802045e:	e008      	b.n	8020472 <att_service_handler_for_handle+0x52>
    while (btstack_linked_list_iterator_has_next(&it)){
 8020460:	f107 0308 	add.w	r3, r7, #8
 8020464:	4618      	mov	r0, r3
 8020466:	f7ee f987 	bl	800e778 <btstack_linked_list_iterator_has_next>
 802046a:	4603      	mov	r3, r0
 802046c:	2b00      	cmp	r3, #0
 802046e:	d1e3      	bne.n	8020438 <att_service_handler_for_handle+0x18>
    }
    return NULL;
 8020470:	2300      	movs	r3, #0
}
 8020472:	4618      	mov	r0, r3
 8020474:	3718      	adds	r7, #24
 8020476:	46bd      	mov	sp, r7
 8020478:	bd80      	pop	{r7, pc}
 802047a:	bf00      	nop
 802047c:	20009f0c 	.word	0x20009f0c

08020480 <att_server_read_callback_for_handle>:
static att_read_callback_t att_server_read_callback_for_handle(uint16_t handle){
 8020480:	b580      	push	{r7, lr}
 8020482:	b084      	sub	sp, #16
 8020484:	af00      	add	r7, sp, #0
 8020486:	4603      	mov	r3, r0
 8020488:	80fb      	strh	r3, [r7, #6]
    att_service_handler_t * handler = att_service_handler_for_handle(handle);
 802048a:	88fb      	ldrh	r3, [r7, #6]
 802048c:	4618      	mov	r0, r3
 802048e:	f7ff ffc7 	bl	8020420 <att_service_handler_for_handle>
 8020492:	60f8      	str	r0, [r7, #12]
    if (handler != NULL) return handler->read_callback;
 8020494:	68fb      	ldr	r3, [r7, #12]
 8020496:	2b00      	cmp	r3, #0
 8020498:	d002      	beq.n	80204a0 <att_server_read_callback_for_handle+0x20>
 802049a:	68fb      	ldr	r3, [r7, #12]
 802049c:	689b      	ldr	r3, [r3, #8]
 802049e:	e001      	b.n	80204a4 <att_server_read_callback_for_handle+0x24>
    return att_server_client_read_callback;
 80204a0:	4b02      	ldr	r3, [pc, #8]	; (80204ac <att_server_read_callback_for_handle+0x2c>)
 80204a2:	681b      	ldr	r3, [r3, #0]
}
 80204a4:	4618      	mov	r0, r3
 80204a6:	3710      	adds	r7, #16
 80204a8:	46bd      	mov	sp, r7
 80204aa:	bd80      	pop	{r7, pc}
 80204ac:	20009f1c 	.word	0x20009f1c

080204b0 <att_server_write_callback_for_handle>:

static att_write_callback_t att_server_write_callback_for_handle(uint16_t handle){
 80204b0:	b580      	push	{r7, lr}
 80204b2:	b084      	sub	sp, #16
 80204b4:	af00      	add	r7, sp, #0
 80204b6:	4603      	mov	r3, r0
 80204b8:	80fb      	strh	r3, [r7, #6]
    att_service_handler_t * handler = att_service_handler_for_handle(handle);
 80204ba:	88fb      	ldrh	r3, [r7, #6]
 80204bc:	4618      	mov	r0, r3
 80204be:	f7ff ffaf 	bl	8020420 <att_service_handler_for_handle>
 80204c2:	60f8      	str	r0, [r7, #12]
    if (handler != NULL) return handler->write_callback;
 80204c4:	68fb      	ldr	r3, [r7, #12]
 80204c6:	2b00      	cmp	r3, #0
 80204c8:	d002      	beq.n	80204d0 <att_server_write_callback_for_handle+0x20>
 80204ca:	68fb      	ldr	r3, [r7, #12]
 80204cc:	68db      	ldr	r3, [r3, #12]
 80204ce:	e001      	b.n	80204d4 <att_server_write_callback_for_handle+0x24>
    return att_server_client_write_callback;
 80204d0:	4b02      	ldr	r3, [pc, #8]	; (80204dc <att_server_write_callback_for_handle+0x2c>)
 80204d2:	681b      	ldr	r3, [r3, #0]
}
 80204d4:	4618      	mov	r0, r3
 80204d6:	3710      	adds	r7, #16
 80204d8:	46bd      	mov	sp, r7
 80204da:	bd80      	pop	{r7, pc}
 80204dc:	20009f20 	.word	0x20009f20

080204e0 <att_server_packet_handler_for_handle>:

static btstack_packet_handler_t att_server_packet_handler_for_handle(uint16_t handle){
 80204e0:	b580      	push	{r7, lr}
 80204e2:	b084      	sub	sp, #16
 80204e4:	af00      	add	r7, sp, #0
 80204e6:	4603      	mov	r3, r0
 80204e8:	80fb      	strh	r3, [r7, #6]
    att_service_handler_t * handler = att_service_handler_for_handle(handle);
 80204ea:	88fb      	ldrh	r3, [r7, #6]
 80204ec:	4618      	mov	r0, r3
 80204ee:	f7ff ff97 	bl	8020420 <att_service_handler_for_handle>
 80204f2:	60f8      	str	r0, [r7, #12]
    if (handler != NULL) return handler->packet_handler;
 80204f4:	68fb      	ldr	r3, [r7, #12]
 80204f6:	2b00      	cmp	r3, #0
 80204f8:	d002      	beq.n	8020500 <att_server_packet_handler_for_handle+0x20>
 80204fa:	68fb      	ldr	r3, [r7, #12]
 80204fc:	691b      	ldr	r3, [r3, #16]
 80204fe:	e001      	b.n	8020504 <att_server_packet_handler_for_handle+0x24>
    return att_client_packet_handler;
 8020500:	4b02      	ldr	r3, [pc, #8]	; (802050c <att_server_packet_handler_for_handle+0x2c>)
 8020502:	681b      	ldr	r3, [r3, #0]
}
 8020504:	4618      	mov	r0, r3
 8020506:	3710      	adds	r7, #16
 8020508:	46bd      	mov	sp, r7
 802050a:	bd80      	pop	{r7, pc}
 802050c:	20009f08 	.word	0x20009f08

08020510 <att_notify_write_callbacks>:

static void att_notify_write_callbacks(hci_con_handle_t con_handle, uint16_t transaction_mode){
 8020510:	b590      	push	{r4, r7, lr}
 8020512:	b089      	sub	sp, #36	; 0x24
 8020514:	af02      	add	r7, sp, #8
 8020516:	4603      	mov	r3, r0
 8020518:	460a      	mov	r2, r1
 802051a:	80fb      	strh	r3, [r7, #6]
 802051c:	4613      	mov	r3, r2
 802051e:	80bb      	strh	r3, [r7, #4]
    // notify all callbacks
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &service_handlers);
 8020520:	f107 0308 	add.w	r3, r7, #8
 8020524:	491b      	ldr	r1, [pc, #108]	; (8020594 <att_notify_write_callbacks+0x84>)
 8020526:	4618      	mov	r0, r3
 8020528:	f7ee f911 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 802052c:	e015      	b.n	802055a <att_notify_write_callbacks+0x4a>
        att_service_handler_t * handler = (att_service_handler_t*) btstack_linked_list_iterator_next(&it);
 802052e:	f107 0308 	add.w	r3, r7, #8
 8020532:	4618      	mov	r0, r3
 8020534:	f7ee f94e 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8020538:	6178      	str	r0, [r7, #20]
        if (!handler->write_callback) continue;
 802053a:	697b      	ldr	r3, [r7, #20]
 802053c:	68db      	ldr	r3, [r3, #12]
 802053e:	2b00      	cmp	r3, #0
 8020540:	d100      	bne.n	8020544 <att_notify_write_callbacks+0x34>
 8020542:	e00a      	b.n	802055a <att_notify_write_callbacks+0x4a>
        (*handler->write_callback)(con_handle, 0, transaction_mode, 0, NULL, 0);
 8020544:	697b      	ldr	r3, [r7, #20]
 8020546:	68dc      	ldr	r4, [r3, #12]
 8020548:	88ba      	ldrh	r2, [r7, #4]
 802054a:	88f8      	ldrh	r0, [r7, #6]
 802054c:	2300      	movs	r3, #0
 802054e:	9301      	str	r3, [sp, #4]
 8020550:	2300      	movs	r3, #0
 8020552:	9300      	str	r3, [sp, #0]
 8020554:	2300      	movs	r3, #0
 8020556:	2100      	movs	r1, #0
 8020558:	47a0      	blx	r4
    while (btstack_linked_list_iterator_has_next(&it)){
 802055a:	f107 0308 	add.w	r3, r7, #8
 802055e:	4618      	mov	r0, r3
 8020560:	f7ee f90a 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8020564:	4603      	mov	r3, r0
 8020566:	2b00      	cmp	r3, #0
 8020568:	d1e1      	bne.n	802052e <att_notify_write_callbacks+0x1e>
    }
    if (!att_server_client_write_callback) return;
 802056a:	4b0b      	ldr	r3, [pc, #44]	; (8020598 <att_notify_write_callbacks+0x88>)
 802056c:	681b      	ldr	r3, [r3, #0]
 802056e:	2b00      	cmp	r3, #0
 8020570:	d00b      	beq.n	802058a <att_notify_write_callbacks+0x7a>
    (*att_server_client_write_callback)(con_handle, 0, transaction_mode, 0, NULL, 0);
 8020572:	4b09      	ldr	r3, [pc, #36]	; (8020598 <att_notify_write_callbacks+0x88>)
 8020574:	681c      	ldr	r4, [r3, #0]
 8020576:	88ba      	ldrh	r2, [r7, #4]
 8020578:	88f8      	ldrh	r0, [r7, #6]
 802057a:	2300      	movs	r3, #0
 802057c:	9301      	str	r3, [sp, #4]
 802057e:	2300      	movs	r3, #0
 8020580:	9300      	str	r3, [sp, #0]
 8020582:	2300      	movs	r3, #0
 8020584:	2100      	movs	r1, #0
 8020586:	47a0      	blx	r4
 8020588:	e000      	b.n	802058c <att_notify_write_callbacks+0x7c>
    if (!att_server_client_write_callback) return;
 802058a:	bf00      	nop
}
 802058c:	371c      	adds	r7, #28
 802058e:	46bd      	mov	sp, r7
 8020590:	bd90      	pop	{r4, r7, pc}
 8020592:	bf00      	nop
 8020594:	20009f0c 	.word	0x20009f0c
 8020598:	20009f20 	.word	0x20009f20

0802059c <att_validate_prepared_write>:

// returns first reported error or 0
static uint8_t att_validate_prepared_write(hci_con_handle_t con_handle){
 802059c:	b590      	push	{r4, r7, lr}
 802059e:	b08b      	sub	sp, #44	; 0x2c
 80205a0:	af02      	add	r7, sp, #8
 80205a2:	4603      	mov	r3, r0
 80205a4:	80fb      	strh	r3, [r7, #6]
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &service_handlers);
 80205a6:	f107 030c 	add.w	r3, r7, #12
 80205aa:	4920      	ldr	r1, [pc, #128]	; (802062c <att_validate_prepared_write+0x90>)
 80205ac:	4618      	mov	r0, r3
 80205ae:	f7ee f8ce 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 80205b2:	e01c      	b.n	80205ee <att_validate_prepared_write+0x52>
        att_service_handler_t * handler = (att_service_handler_t*) btstack_linked_list_iterator_next(&it);
 80205b4:	f107 030c 	add.w	r3, r7, #12
 80205b8:	4618      	mov	r0, r3
 80205ba:	f7ee f90b 	bl	800e7d4 <btstack_linked_list_iterator_next>
 80205be:	61f8      	str	r0, [r7, #28]
        if (!handler->write_callback) continue;
 80205c0:	69fb      	ldr	r3, [r7, #28]
 80205c2:	68db      	ldr	r3, [r3, #12]
 80205c4:	2b00      	cmp	r3, #0
 80205c6:	d100      	bne.n	80205ca <att_validate_prepared_write+0x2e>
 80205c8:	e011      	b.n	80205ee <att_validate_prepared_write+0x52>
        uint8_t error_code = (*handler->write_callback)(con_handle, 0, ATT_TRANSACTION_MODE_VALIDATE, 0, NULL, 0);
 80205ca:	69fb      	ldr	r3, [r7, #28]
 80205cc:	68dc      	ldr	r4, [r3, #12]
 80205ce:	88f8      	ldrh	r0, [r7, #6]
 80205d0:	2300      	movs	r3, #0
 80205d2:	9301      	str	r3, [sp, #4]
 80205d4:	2300      	movs	r3, #0
 80205d6:	9300      	str	r3, [sp, #0]
 80205d8:	2300      	movs	r3, #0
 80205da:	2204      	movs	r2, #4
 80205dc:	2100      	movs	r1, #0
 80205de:	47a0      	blx	r4
 80205e0:	4603      	mov	r3, r0
 80205e2:	76fb      	strb	r3, [r7, #27]
        if (error_code != 0) return error_code;
 80205e4:	7efb      	ldrb	r3, [r7, #27]
 80205e6:	2b00      	cmp	r3, #0
 80205e8:	d001      	beq.n	80205ee <att_validate_prepared_write+0x52>
 80205ea:	7efb      	ldrb	r3, [r7, #27]
 80205ec:	e01a      	b.n	8020624 <att_validate_prepared_write+0x88>
    while (btstack_linked_list_iterator_has_next(&it)){
 80205ee:	f107 030c 	add.w	r3, r7, #12
 80205f2:	4618      	mov	r0, r3
 80205f4:	f7ee f8c0 	bl	800e778 <btstack_linked_list_iterator_has_next>
 80205f8:	4603      	mov	r3, r0
 80205fa:	2b00      	cmp	r3, #0
 80205fc:	d1da      	bne.n	80205b4 <att_validate_prepared_write+0x18>
    }
    if (!att_server_client_write_callback) return 0;
 80205fe:	4b0c      	ldr	r3, [pc, #48]	; (8020630 <att_validate_prepared_write+0x94>)
 8020600:	681b      	ldr	r3, [r3, #0]
 8020602:	2b00      	cmp	r3, #0
 8020604:	d101      	bne.n	802060a <att_validate_prepared_write+0x6e>
 8020606:	2300      	movs	r3, #0
 8020608:	e00c      	b.n	8020624 <att_validate_prepared_write+0x88>
    return (*att_server_client_write_callback)(con_handle, 0, ATT_TRANSACTION_MODE_VALIDATE, 0, NULL, 0);
 802060a:	4b09      	ldr	r3, [pc, #36]	; (8020630 <att_validate_prepared_write+0x94>)
 802060c:	681c      	ldr	r4, [r3, #0]
 802060e:	88f8      	ldrh	r0, [r7, #6]
 8020610:	2300      	movs	r3, #0
 8020612:	9301      	str	r3, [sp, #4]
 8020614:	2300      	movs	r3, #0
 8020616:	9300      	str	r3, [sp, #0]
 8020618:	2300      	movs	r3, #0
 802061a:	2204      	movs	r2, #4
 802061c:	2100      	movs	r1, #0
 802061e:	47a0      	blx	r4
 8020620:	4603      	mov	r3, r0
 8020622:	b2db      	uxtb	r3, r3
}
 8020624:	4618      	mov	r0, r3
 8020626:	3724      	adds	r7, #36	; 0x24
 8020628:	46bd      	mov	sp, r7
 802062a:	bd90      	pop	{r4, r7, pc}
 802062c:	20009f0c 	.word	0x20009f0c
 8020630:	20009f20 	.word	0x20009f20

08020634 <att_server_read_callback>:

static uint16_t att_server_read_callback(hci_con_handle_t con_handle, uint16_t attribute_handle, uint16_t offset, uint8_t * buffer, uint16_t buffer_size){
 8020634:	b590      	push	{r4, r7, lr}
 8020636:	b089      	sub	sp, #36	; 0x24
 8020638:	af02      	add	r7, sp, #8
 802063a:	607b      	str	r3, [r7, #4]
 802063c:	4603      	mov	r3, r0
 802063e:	81fb      	strh	r3, [r7, #14]
 8020640:	460b      	mov	r3, r1
 8020642:	81bb      	strh	r3, [r7, #12]
 8020644:	4613      	mov	r3, r2
 8020646:	817b      	strh	r3, [r7, #10]
    att_read_callback_t callback = att_server_read_callback_for_handle(attribute_handle);
 8020648:	89bb      	ldrh	r3, [r7, #12]
 802064a:	4618      	mov	r0, r3
 802064c:	f7ff ff18 	bl	8020480 <att_server_read_callback_for_handle>
 8020650:	6178      	str	r0, [r7, #20]
    if (!callback) return 0;
 8020652:	697b      	ldr	r3, [r7, #20]
 8020654:	2b00      	cmp	r3, #0
 8020656:	d101      	bne.n	802065c <att_server_read_callback+0x28>
 8020658:	2300      	movs	r3, #0
 802065a:	e008      	b.n	802066e <att_server_read_callback+0x3a>
    return (*callback)(con_handle, attribute_handle, offset, buffer, buffer_size);
 802065c:	897a      	ldrh	r2, [r7, #10]
 802065e:	89b9      	ldrh	r1, [r7, #12]
 8020660:	89f8      	ldrh	r0, [r7, #14]
 8020662:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8020664:	9300      	str	r3, [sp, #0]
 8020666:	697c      	ldr	r4, [r7, #20]
 8020668:	687b      	ldr	r3, [r7, #4]
 802066a:	47a0      	blx	r4
 802066c:	4603      	mov	r3, r0
}
 802066e:	4618      	mov	r0, r3
 8020670:	371c      	adds	r7, #28
 8020672:	46bd      	mov	sp, r7
 8020674:	bd90      	pop	{r4, r7, pc}

08020676 <att_server_write_callback>:

static int att_server_write_callback(hci_con_handle_t con_handle, uint16_t attribute_handle, uint16_t transaction_mode, uint16_t offset, uint8_t *buffer, uint16_t buffer_size){
 8020676:	b5b0      	push	{r4, r5, r7, lr}
 8020678:	b086      	sub	sp, #24
 802067a:	af02      	add	r7, sp, #8
 802067c:	4604      	mov	r4, r0
 802067e:	4608      	mov	r0, r1
 8020680:	4611      	mov	r1, r2
 8020682:	461a      	mov	r2, r3
 8020684:	4623      	mov	r3, r4
 8020686:	80fb      	strh	r3, [r7, #6]
 8020688:	4603      	mov	r3, r0
 802068a:	80bb      	strh	r3, [r7, #4]
 802068c:	460b      	mov	r3, r1
 802068e:	807b      	strh	r3, [r7, #2]
 8020690:	4613      	mov	r3, r2
 8020692:	803b      	strh	r3, [r7, #0]
    switch (transaction_mode){
 8020694:	887b      	ldrh	r3, [r7, #2]
 8020696:	2b02      	cmp	r3, #2
 8020698:	db12      	blt.n	80206c0 <att_server_write_callback+0x4a>
 802069a:	2b03      	cmp	r3, #3
 802069c:	dd08      	ble.n	80206b0 <att_server_write_callback+0x3a>
 802069e:	2b04      	cmp	r3, #4
 80206a0:	d000      	beq.n	80206a4 <att_server_write_callback+0x2e>
        case ATT_TRANSACTION_MODE_EXECUTE:
        case ATT_TRANSACTION_MODE_CANCEL:
            att_notify_write_callbacks(con_handle, transaction_mode);
            return 0;
        default:
            break;
 80206a2:	e00d      	b.n	80206c0 <att_server_write_callback+0x4a>
            return att_validate_prepared_write(con_handle);
 80206a4:	88fb      	ldrh	r3, [r7, #6]
 80206a6:	4618      	mov	r0, r3
 80206a8:	f7ff ff78 	bl	802059c <att_validate_prepared_write>
 80206ac:	4603      	mov	r3, r0
 80206ae:	e036      	b.n	802071e <att_server_write_callback+0xa8>
            att_notify_write_callbacks(con_handle, transaction_mode);
 80206b0:	887a      	ldrh	r2, [r7, #2]
 80206b2:	88fb      	ldrh	r3, [r7, #6]
 80206b4:	4611      	mov	r1, r2
 80206b6:	4618      	mov	r0, r3
 80206b8:	f7ff ff2a 	bl	8020510 <att_notify_write_callbacks>
            return 0;
 80206bc:	2300      	movs	r3, #0
 80206be:	e02e      	b.n	802071e <att_server_write_callback+0xa8>
            break;
 80206c0:	bf00      	nop
    }

    // track CCC writes
    if (att_is_persistent_ccc(attribute_handle) && (offset == 0u) && (buffer_size == 2u)){
 80206c2:	88bb      	ldrh	r3, [r7, #4]
 80206c4:	4618      	mov	r0, r3
 80206c6:	f7fe fc2b 	bl	801ef20 <att_is_persistent_ccc>
 80206ca:	4603      	mov	r3, r0
 80206cc:	2b00      	cmp	r3, #0
 80206ce:	d010      	beq.n	80206f2 <att_server_write_callback+0x7c>
 80206d0:	883b      	ldrh	r3, [r7, #0]
 80206d2:	2b00      	cmp	r3, #0
 80206d4:	d10d      	bne.n	80206f2 <att_server_write_callback+0x7c>
 80206d6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80206d8:	2b02      	cmp	r3, #2
 80206da:	d10a      	bne.n	80206f2 <att_server_write_callback+0x7c>
        att_server_persistent_ccc_write(con_handle, attribute_handle, little_endian_read_16(buffer, 0));
 80206dc:	2100      	movs	r1, #0
 80206de:	6a38      	ldr	r0, [r7, #32]
 80206e0:	f7ee fb81 	bl	800ede6 <little_endian_read_16>
 80206e4:	4603      	mov	r3, r0
 80206e6:	461a      	mov	r2, r3
 80206e8:	88b9      	ldrh	r1, [r7, #4]
 80206ea:	88fb      	ldrh	r3, [r7, #6]
 80206ec:	4618      	mov	r0, r3
 80206ee:	f7ff fc73 	bl	801ffd8 <att_server_persistent_ccc_write>
    }

    att_write_callback_t callback = att_server_write_callback_for_handle(attribute_handle);
 80206f2:	88bb      	ldrh	r3, [r7, #4]
 80206f4:	4618      	mov	r0, r3
 80206f6:	f7ff fedb 	bl	80204b0 <att_server_write_callback_for_handle>
 80206fa:	60f8      	str	r0, [r7, #12]
    if (!callback) return 0;
 80206fc:	68fb      	ldr	r3, [r7, #12]
 80206fe:	2b00      	cmp	r3, #0
 8020700:	d101      	bne.n	8020706 <att_server_write_callback+0x90>
 8020702:	2300      	movs	r3, #0
 8020704:	e00b      	b.n	802071e <att_server_write_callback+0xa8>
    return (*callback)(con_handle, attribute_handle, transaction_mode, offset, buffer, buffer_size);
 8020706:	883d      	ldrh	r5, [r7, #0]
 8020708:	887a      	ldrh	r2, [r7, #2]
 802070a:	88b9      	ldrh	r1, [r7, #4]
 802070c:	88f8      	ldrh	r0, [r7, #6]
 802070e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8020710:	9301      	str	r3, [sp, #4]
 8020712:	6a3b      	ldr	r3, [r7, #32]
 8020714:	9300      	str	r3, [sp, #0]
 8020716:	68fc      	ldr	r4, [r7, #12]
 8020718:	462b      	mov	r3, r5
 802071a:	47a0      	blx	r4
 802071c:	4603      	mov	r3, r0
}
 802071e:	4618      	mov	r0, r3
 8020720:	3710      	adds	r7, #16
 8020722:	46bd      	mov	sp, r7
 8020724:	bdb0      	pop	{r4, r5, r7, pc}
	...

08020728 <att_server_init>:
        return;
    }
    btstack_linked_list_add(&service_handlers, (btstack_linked_item_t*) handler);
}

void att_server_init(uint8_t const * db, att_read_callback_t read_callback, att_write_callback_t write_callback){
 8020728:	b580      	push	{r7, lr}
 802072a:	b084      	sub	sp, #16
 802072c:	af00      	add	r7, sp, #0
 802072e:	60f8      	str	r0, [r7, #12]
 8020730:	60b9      	str	r1, [r7, #8]
 8020732:	607a      	str	r2, [r7, #4]

    // store callbacks
    att_server_client_read_callback  = read_callback;
 8020734:	4a10      	ldr	r2, [pc, #64]	; (8020778 <att_server_init+0x50>)
 8020736:	68bb      	ldr	r3, [r7, #8]
 8020738:	6013      	str	r3, [r2, #0]
    att_server_client_write_callback = write_callback;
 802073a:	4a10      	ldr	r2, [pc, #64]	; (802077c <att_server_init+0x54>)
 802073c:	687b      	ldr	r3, [r7, #4]
 802073e:	6013      	str	r3, [r2, #0]

    // register for HCI Events
    hci_event_callback_registration.callback = &att_event_packet_handler;
 8020740:	4b0f      	ldr	r3, [pc, #60]	; (8020780 <att_server_init+0x58>)
 8020742:	4a10      	ldr	r2, [pc, #64]	; (8020784 <att_server_init+0x5c>)
 8020744:	605a      	str	r2, [r3, #4]
    hci_add_event_handler(&hci_event_callback_registration);
 8020746:	480e      	ldr	r0, [pc, #56]	; (8020780 <att_server_init+0x58>)
 8020748:	f7f3 fbd4 	bl	8013ef4 <hci_add_event_handler>

    // register for SM events
    sm_event_callback_registration.callback = &att_event_packet_handler;
 802074c:	4b0e      	ldr	r3, [pc, #56]	; (8020788 <att_server_init+0x60>)
 802074e:	4a0d      	ldr	r2, [pc, #52]	; (8020784 <att_server_init+0x5c>)
 8020750:	605a      	str	r2, [r3, #4]
    sm_add_event_handler(&sm_event_callback_registration);
 8020752:	480d      	ldr	r0, [pc, #52]	; (8020788 <att_server_init+0x60>)
 8020754:	f006 fc4a 	bl	8026fec <sm_add_event_handler>

    // and L2CAP ATT Server PDUs
    att_dispatch_register_server(att_packet_handler);
 8020758:	480c      	ldr	r0, [pc, #48]	; (802078c <att_server_init+0x64>)
 802075a:	f7fe fcab 	bl	801f0b4 <att_dispatch_register_server>
#ifdef ENABLE_GATT_OVER_CLASSIC
    // setup l2cap service
    l2cap_register_service(&att_event_packet_handler, PSM_ATT, 0xffff, LEVEL_2);
#endif

    att_set_db(db);
 802075e:	68f8      	ldr	r0, [r7, #12]
 8020760:	f7fc ff06 	bl	801d570 <att_set_db>
    att_set_read_callback(att_server_read_callback);
 8020764:	480a      	ldr	r0, [pc, #40]	; (8020790 <att_server_init+0x68>)
 8020766:	f7fc ff2f 	bl	801d5c8 <att_set_read_callback>
    att_set_write_callback(att_server_write_callback);
 802076a:	480a      	ldr	r0, [pc, #40]	; (8020794 <att_server_init+0x6c>)
 802076c:	f7fc ff3c 	bl	801d5e8 <att_set_write_callback>
}
 8020770:	bf00      	nop
 8020772:	3710      	adds	r7, #16
 8020774:	46bd      	mov	sp, r7
 8020776:	bd80      	pop	{r7, pc}
 8020778:	20009f1c 	.word	0x20009f1c
 802077c:	20009f20 	.word	0x20009f20
 8020780:	20009ef8 	.word	0x20009ef8
 8020784:	0801f5f5 	.word	0x0801f5f5
 8020788:	20009f00 	.word	0x20009f00
 802078c:	0801ff2d 	.word	0x0801ff2d
 8020790:	08020635 	.word	0x08020635
 8020794:	08020677 	.word	0x08020677

08020798 <att_server_register_packet_handler>:

void att_server_register_packet_handler(btstack_packet_handler_t handler){
 8020798:	b480      	push	{r7}
 802079a:	b083      	sub	sp, #12
 802079c:	af00      	add	r7, sp, #0
 802079e:	6078      	str	r0, [r7, #4]
    att_client_packet_handler = handler;    
 80207a0:	4a04      	ldr	r2, [pc, #16]	; (80207b4 <att_server_register_packet_handler+0x1c>)
 80207a2:	687b      	ldr	r3, [r7, #4]
 80207a4:	6013      	str	r3, [r2, #0]
}
 80207a6:	bf00      	nop
 80207a8:	370c      	adds	r7, #12
 80207aa:	46bd      	mov	sp, r7
 80207ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80207b0:	4770      	bx	lr
 80207b2:	bf00      	nop
 80207b4:	20009f08 	.word	0x20009f08

080207b8 <att_server_request_can_send_now_event>:

int att_server_register_can_send_now_callback(btstack_context_callback_registration_t * callback_registration, hci_con_handle_t con_handle){
    return att_server_request_to_send_notification(callback_registration, con_handle);
}

void att_server_request_can_send_now_event(hci_con_handle_t con_handle){
 80207b8:	b580      	push	{r7, lr}
 80207ba:	b082      	sub	sp, #8
 80207bc:	af00      	add	r7, sp, #0
 80207be:	4603      	mov	r3, r0
 80207c0:	80fb      	strh	r3, [r7, #6]
    att_client_waiting_for_can_send_registration.callback = &att_emit_can_send_now_event;
 80207c2:	4b06      	ldr	r3, [pc, #24]	; (80207dc <att_server_request_can_send_now_event+0x24>)
 80207c4:	4a06      	ldr	r2, [pc, #24]	; (80207e0 <att_server_request_can_send_now_event+0x28>)
 80207c6:	605a      	str	r2, [r3, #4]
    att_server_request_to_send_notification(&att_client_waiting_for_can_send_registration, con_handle);
 80207c8:	88fb      	ldrh	r3, [r7, #6]
 80207ca:	4619      	mov	r1, r3
 80207cc:	4803      	ldr	r0, [pc, #12]	; (80207dc <att_server_request_can_send_now_event+0x24>)
 80207ce:	f000 f809 	bl	80207e4 <att_server_request_to_send_notification>
}
 80207d2:	bf00      	nop
 80207d4:	3708      	adds	r7, #8
 80207d6:	46bd      	mov	sp, r7
 80207d8:	bd80      	pop	{r7, pc}
 80207da:	bf00      	nop
 80207dc:	20009f10 	.word	0x20009f10
 80207e0:	0801f4c9 	.word	0x0801f4c9

080207e4 <att_server_request_to_send_notification>:
// end of deprecated

int att_server_request_to_send_notification(btstack_context_callback_registration_t * callback_registration, hci_con_handle_t con_handle){
 80207e4:	b580      	push	{r7, lr}
 80207e6:	b086      	sub	sp, #24
 80207e8:	af00      	add	r7, sp, #0
 80207ea:	6078      	str	r0, [r7, #4]
 80207ec:	460b      	mov	r3, r1
 80207ee:	807b      	strh	r3, [r7, #2]
    hci_connection_t * hci_connection = hci_connection_for_handle(con_handle);
 80207f0:	887b      	ldrh	r3, [r7, #2]
 80207f2:	4618      	mov	r0, r3
 80207f4:	f7ef f866 	bl	800f8c4 <hci_connection_for_handle>
 80207f8:	6178      	str	r0, [r7, #20]
    if (!hci_connection) return ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER;
 80207fa:	697b      	ldr	r3, [r7, #20]
 80207fc:	2b00      	cmp	r3, #0
 80207fe:	d101      	bne.n	8020804 <att_server_request_to_send_notification+0x20>
 8020800:	2302      	movs	r3, #2
 8020802:	e014      	b.n	802082e <att_server_request_to_send_notification+0x4a>
    att_server_t * att_server = &hci_connection->att_server;
 8020804:	697b      	ldr	r3, [r7, #20]
 8020806:	f203 7354 	addw	r3, r3, #1876	; 0x754
 802080a:	613b      	str	r3, [r7, #16]
    bool added = btstack_linked_list_add_tail(&att_server->notification_requests, (btstack_linked_item_t*) callback_registration);
 802080c:	693b      	ldr	r3, [r7, #16]
 802080e:	3324      	adds	r3, #36	; 0x24
 8020810:	6879      	ldr	r1, [r7, #4]
 8020812:	4618      	mov	r0, r3
 8020814:	f7ed ff30 	bl	800e678 <btstack_linked_list_add_tail>
 8020818:	4603      	mov	r3, r0
 802081a:	73fb      	strb	r3, [r7, #15]
    att_server_request_can_send_now(hci_connection);
 802081c:	6978      	ldr	r0, [r7, #20]
 802081e:	f7fe fd64 	bl	801f2ea <att_server_request_can_send_now>
    if (added){
 8020822:	7bfb      	ldrb	r3, [r7, #15]
 8020824:	2b00      	cmp	r3, #0
 8020826:	d001      	beq.n	802082c <att_server_request_to_send_notification+0x48>
        return ERROR_CODE_SUCCESS;
 8020828:	2300      	movs	r3, #0
 802082a:	e000      	b.n	802082e <att_server_request_to_send_notification+0x4a>
    } else {
        return ERROR_CODE_COMMAND_DISALLOWED;
 802082c:	230c      	movs	r3, #12
    }
}
 802082e:	4618      	mov	r0, r3
 8020830:	3718      	adds	r7, #24
 8020832:	46bd      	mov	sp, r7
 8020834:	bd80      	pop	{r7, pc}

08020836 <att_server_notify>:
    } else {
        return ERROR_CODE_COMMAND_DISALLOWED;
    }
}

int att_server_notify(hci_con_handle_t con_handle, uint16_t attribute_handle, const uint8_t *value, uint16_t value_len){
 8020836:	b580      	push	{r7, lr}
 8020838:	b08a      	sub	sp, #40	; 0x28
 802083a:	af02      	add	r7, sp, #8
 802083c:	60ba      	str	r2, [r7, #8]
 802083e:	461a      	mov	r2, r3
 8020840:	4603      	mov	r3, r0
 8020842:	81fb      	strh	r3, [r7, #14]
 8020844:	460b      	mov	r3, r1
 8020846:	81bb      	strh	r3, [r7, #12]
 8020848:	4613      	mov	r3, r2
 802084a:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * hci_connection = hci_connection_for_handle(con_handle);
 802084c:	89fb      	ldrh	r3, [r7, #14]
 802084e:	4618      	mov	r0, r3
 8020850:	f7ef f838 	bl	800f8c4 <hci_connection_for_handle>
 8020854:	61f8      	str	r0, [r7, #28]
    if (!hci_connection) return ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER;
 8020856:	69fb      	ldr	r3, [r7, #28]
 8020858:	2b00      	cmp	r3, #0
 802085a:	d101      	bne.n	8020860 <att_server_notify+0x2a>
 802085c:	2302      	movs	r3, #2
 802085e:	e026      	b.n	80208ae <att_server_notify+0x78>
    att_connection_t * att_connection = &hci_connection->att_connection;
 8020860:	69fb      	ldr	r3, [r7, #28]
 8020862:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 8020866:	61bb      	str	r3, [r7, #24]

    if (!att_server_can_send_packet(hci_connection)) return BTSTACK_ACL_BUFFERS_FULL;
 8020868:	69f8      	ldr	r0, [r7, #28]
 802086a:	f7fe fd4f 	bl	801f30c <att_server_can_send_packet>
 802086e:	4603      	mov	r3, r0
 8020870:	f083 0301 	eor.w	r3, r3, #1
 8020874:	b2db      	uxtb	r3, r3
 8020876:	2b00      	cmp	r3, #0
 8020878:	d001      	beq.n	802087e <att_server_notify+0x48>
 802087a:	2357      	movs	r3, #87	; 0x57
 802087c:	e017      	b.n	80208ae <att_server_notify+0x78>

    l2cap_reserve_packet_buffer();
 802087e:	f7f7 ff38 	bl	80186f2 <l2cap_reserve_packet_buffer>
    uint8_t * packet_buffer = l2cap_get_outgoing_buffer();
 8020882:	f7f7 ff2e 	bl	80186e2 <l2cap_get_outgoing_buffer>
 8020886:	6178      	str	r0, [r7, #20]
    uint16_t size = att_prepare_handle_value_notification(att_connection, attribute_handle, value, value_len, packet_buffer);
 8020888:	88fa      	ldrh	r2, [r7, #6]
 802088a:	89b9      	ldrh	r1, [r7, #12]
 802088c:	697b      	ldr	r3, [r7, #20]
 802088e:	9300      	str	r3, [sp, #0]
 8020890:	4613      	mov	r3, r2
 8020892:	68ba      	ldr	r2, [r7, #8]
 8020894:	69b8      	ldr	r0, [r7, #24]
 8020896:	f7fe f9af 	bl	801ebf8 <att_prepare_handle_value_notification>
 802089a:	4603      	mov	r3, r0
 802089c:	827b      	strh	r3, [r7, #18]
	return l2cap_send_prepared_connectionless(att_connection->con_handle, L2CAP_CID_ATTRIBUTE_PROTOCOL, size);
 802089e:	69bb      	ldr	r3, [r7, #24]
 80208a0:	881b      	ldrh	r3, [r3, #0]
 80208a2:	8a7a      	ldrh	r2, [r7, #18]
 80208a4:	2104      	movs	r1, #4
 80208a6:	4618      	mov	r0, r3
 80208a8:	f7f7 ff62 	bl	8018770 <l2cap_send_prepared_connectionless>
 80208ac:	4603      	mov	r3, r0
}
 80208ae:	4618      	mov	r0, r3
 80208b0:	3720      	adds	r7, #32
 80208b2:	46bd      	mov	sp, r7
 80208b4:	bd80      	pop	{r7, pc}

080208b6 <att_server_get_mtu>:
    uint16_t size = att_prepare_handle_value_indication(att_connection, attribute_handle, value, value_len, packet_buffer);
	l2cap_send_prepared_connectionless(att_connection->con_handle, L2CAP_CID_ATTRIBUTE_PROTOCOL, size);
    return 0;
}

uint16_t att_server_get_mtu(hci_con_handle_t con_handle){
 80208b6:	b580      	push	{r7, lr}
 80208b8:	b084      	sub	sp, #16
 80208ba:	af00      	add	r7, sp, #0
 80208bc:	4603      	mov	r3, r0
 80208be:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * hci_connection = hci_connection_for_handle(con_handle);
 80208c0:	88fb      	ldrh	r3, [r7, #6]
 80208c2:	4618      	mov	r0, r3
 80208c4:	f7ee fffe 	bl	800f8c4 <hci_connection_for_handle>
 80208c8:	60f8      	str	r0, [r7, #12]
    if (!hci_connection) return 0;
 80208ca:	68fb      	ldr	r3, [r7, #12]
 80208cc:	2b00      	cmp	r3, #0
 80208ce:	d101      	bne.n	80208d4 <att_server_get_mtu+0x1e>
 80208d0:	2300      	movs	r3, #0
 80208d2:	e005      	b.n	80208e0 <att_server_get_mtu+0x2a>
    att_connection_t * att_connection = &hci_connection->att_connection;
 80208d4:	68fb      	ldr	r3, [r7, #12]
 80208d6:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 80208da:	60bb      	str	r3, [r7, #8]
    return att_connection->mtu;
 80208dc:	68bb      	ldr	r3, [r7, #8]
 80208de:	885b      	ldrh	r3, [r3, #2]
}
 80208e0:	4618      	mov	r0, r3
 80208e2:	3710      	adds	r7, #16
 80208e4:	46bd      	mov	sp, r7
 80208e6:	bd80      	pop	{r7, pc}

080208e8 <le_device_db_tlv_tag_for_index>:

static const btstack_tlv_t * le_device_db_tlv_btstack_tlv_impl;
static       void *          le_device_db_tlv_btstack_tlv_context;


static uint32_t le_device_db_tlv_tag_for_index(uint8_t index){
 80208e8:	b480      	push	{r7}
 80208ea:	b083      	sub	sp, #12
 80208ec:	af00      	add	r7, sp, #0
 80208ee:	4603      	mov	r3, r0
 80208f0:	71fb      	strb	r3, [r7, #7]
    static const char tag_0 = 'B';
    static const char tag_1 = 'T';
    static const char tag_2 = 'D';

    return (tag_0 << 24u) | (tag_1 << 16u) | (tag_2 << 8u) | index;
 80208f2:	4b09      	ldr	r3, [pc, #36]	; (8020918 <le_device_db_tlv_tag_for_index+0x30>)
 80208f4:	781b      	ldrb	r3, [r3, #0]
 80208f6:	061a      	lsls	r2, r3, #24
 80208f8:	4b08      	ldr	r3, [pc, #32]	; (802091c <le_device_db_tlv_tag_for_index+0x34>)
 80208fa:	781b      	ldrb	r3, [r3, #0]
 80208fc:	041b      	lsls	r3, r3, #16
 80208fe:	431a      	orrs	r2, r3
 8020900:	4b07      	ldr	r3, [pc, #28]	; (8020920 <le_device_db_tlv_tag_for_index+0x38>)
 8020902:	781b      	ldrb	r3, [r3, #0]
 8020904:	021b      	lsls	r3, r3, #8
 8020906:	431a      	orrs	r2, r3
 8020908:	79fb      	ldrb	r3, [r7, #7]
 802090a:	4313      	orrs	r3, r2
}
 802090c:	4618      	mov	r0, r3
 802090e:	370c      	adds	r7, #12
 8020910:	46bd      	mov	sp, r7
 8020912:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020916:	4770      	bx	lr
 8020918:	08030e94 	.word	0x08030e94
 802091c:	08030e95 	.word	0x08030e95
 8020920:	08030e96 	.word	0x08030e96

08020924 <le_device_db_tlv_fetch>:

// @returns success
// @param index = entry_pos
static bool le_device_db_tlv_fetch(int index, le_device_db_entry_t * entry){
 8020924:	b590      	push	{r4, r7, lr}
 8020926:	b085      	sub	sp, #20
 8020928:	af00      	add	r7, sp, #0
 802092a:	6078      	str	r0, [r7, #4]
 802092c:	6039      	str	r1, [r7, #0]
    btstack_assert(le_device_db_tlv_btstack_tlv_impl != NULL);
    btstack_assert(index >= 0);
    btstack_assert(index < NVM_NUM_DEVICE_DB_ENTRIES);

    uint32_t tag = le_device_db_tlv_tag_for_index(index);
 802092e:	687b      	ldr	r3, [r7, #4]
 8020930:	b2db      	uxtb	r3, r3
 8020932:	4618      	mov	r0, r3
 8020934:	f7ff ffd8 	bl	80208e8 <le_device_db_tlv_tag_for_index>
 8020938:	60f8      	str	r0, [r7, #12]
    int size = le_device_db_tlv_btstack_tlv_impl->get_tag(le_device_db_tlv_btstack_tlv_context, tag, (uint8_t*) entry, sizeof(le_device_db_entry_t));
 802093a:	4b0a      	ldr	r3, [pc, #40]	; (8020964 <le_device_db_tlv_fetch+0x40>)
 802093c:	681b      	ldr	r3, [r3, #0]
 802093e:	681c      	ldr	r4, [r3, #0]
 8020940:	4b09      	ldr	r3, [pc, #36]	; (8020968 <le_device_db_tlv_fetch+0x44>)
 8020942:	6818      	ldr	r0, [r3, #0]
 8020944:	233c      	movs	r3, #60	; 0x3c
 8020946:	683a      	ldr	r2, [r7, #0]
 8020948:	68f9      	ldr	r1, [r7, #12]
 802094a:	47a0      	blx	r4
 802094c:	60b8      	str	r0, [r7, #8]
	return size == sizeof(le_device_db_entry_t);
 802094e:	68bb      	ldr	r3, [r7, #8]
 8020950:	2b3c      	cmp	r3, #60	; 0x3c
 8020952:	bf0c      	ite	eq
 8020954:	2301      	moveq	r3, #1
 8020956:	2300      	movne	r3, #0
 8020958:	b2db      	uxtb	r3, r3
}
 802095a:	4618      	mov	r0, r3
 802095c:	3714      	adds	r7, #20
 802095e:	46bd      	mov	sp, r7
 8020960:	bd90      	pop	{r4, r7, pc}
 8020962:	bf00      	nop
 8020964:	20009f38 	.word	0x20009f38
 8020968:	20009f3c 	.word	0x20009f3c

0802096c <le_device_db_tlv_store>:

// @returns success
// @param index = entry_pos
static bool le_device_db_tlv_store(int index, le_device_db_entry_t * entry){
 802096c:	b590      	push	{r4, r7, lr}
 802096e:	b085      	sub	sp, #20
 8020970:	af00      	add	r7, sp, #0
 8020972:	6078      	str	r0, [r7, #4]
 8020974:	6039      	str	r1, [r7, #0]
    btstack_assert(le_device_db_tlv_btstack_tlv_impl != NULL);
    btstack_assert(index >= 0);
    btstack_assert(index < NVM_NUM_DEVICE_DB_ENTRIES);

    uint32_t tag = le_device_db_tlv_tag_for_index(index);
 8020976:	687b      	ldr	r3, [r7, #4]
 8020978:	b2db      	uxtb	r3, r3
 802097a:	4618      	mov	r0, r3
 802097c:	f7ff ffb4 	bl	80208e8 <le_device_db_tlv_tag_for_index>
 8020980:	60f8      	str	r0, [r7, #12]
    int result = le_device_db_tlv_btstack_tlv_impl->store_tag(le_device_db_tlv_btstack_tlv_context, tag, (uint8_t*) entry, sizeof(le_device_db_entry_t));
 8020982:	4b0a      	ldr	r3, [pc, #40]	; (80209ac <le_device_db_tlv_store+0x40>)
 8020984:	681b      	ldr	r3, [r3, #0]
 8020986:	685c      	ldr	r4, [r3, #4]
 8020988:	4b09      	ldr	r3, [pc, #36]	; (80209b0 <le_device_db_tlv_store+0x44>)
 802098a:	6818      	ldr	r0, [r3, #0]
 802098c:	233c      	movs	r3, #60	; 0x3c
 802098e:	683a      	ldr	r2, [r7, #0]
 8020990:	68f9      	ldr	r1, [r7, #12]
 8020992:	47a0      	blx	r4
 8020994:	60b8      	str	r0, [r7, #8]
    return result == 0;
 8020996:	68bb      	ldr	r3, [r7, #8]
 8020998:	2b00      	cmp	r3, #0
 802099a:	bf0c      	ite	eq
 802099c:	2301      	moveq	r3, #1
 802099e:	2300      	movne	r3, #0
 80209a0:	b2db      	uxtb	r3, r3
}
 80209a2:	4618      	mov	r0, r3
 80209a4:	3714      	adds	r7, #20
 80209a6:	46bd      	mov	sp, r7
 80209a8:	bd90      	pop	{r4, r7, pc}
 80209aa:	bf00      	nop
 80209ac:	20009f38 	.word	0x20009f38
 80209b0:	20009f3c 	.word	0x20009f3c

080209b4 <le_device_db_tlv_scan>:
    uint32_t tag = le_device_db_tlv_tag_for_index(index);
    le_device_db_tlv_btstack_tlv_impl->delete_tag(le_device_db_tlv_btstack_tlv_context, tag);
	return true;
}

static void le_device_db_tlv_scan(void){
 80209b4:	b580      	push	{r7, lr}
 80209b6:	b092      	sub	sp, #72	; 0x48
 80209b8:	af02      	add	r7, sp, #8
    int i;
    num_valid_entries = 0;
 80209ba:	4b1a      	ldr	r3, [pc, #104]	; (8020a24 <le_device_db_tlv_scan+0x70>)
 80209bc:	2200      	movs	r2, #0
 80209be:	601a      	str	r2, [r3, #0]
    memset(entry_map, 0, sizeof(entry_map));
 80209c0:	2210      	movs	r2, #16
 80209c2:	2100      	movs	r1, #0
 80209c4:	4818      	ldr	r0, [pc, #96]	; (8020a28 <le_device_db_tlv_scan+0x74>)
 80209c6:	f007 f87c 	bl	8027ac2 <memset>
    for (i=0;i<NVM_NUM_DEVICE_DB_ENTRIES;i++){
 80209ca:	2300      	movs	r3, #0
 80209cc:	63fb      	str	r3, [r7, #60]	; 0x3c
 80209ce:	e019      	b.n	8020a04 <le_device_db_tlv_scan+0x50>
        // lookup entry
        le_device_db_entry_t entry;
        if (!le_device_db_tlv_fetch(i, &entry)) continue;
 80209d0:	463b      	mov	r3, r7
 80209d2:	4619      	mov	r1, r3
 80209d4:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80209d6:	f7ff ffa5 	bl	8020924 <le_device_db_tlv_fetch>
 80209da:	4603      	mov	r3, r0
 80209dc:	f083 0301 	eor.w	r3, r3, #1
 80209e0:	b2db      	uxtb	r3, r3
 80209e2:	2b00      	cmp	r3, #0
 80209e4:	d10a      	bne.n	80209fc <le_device_db_tlv_scan+0x48>

        entry_map[i] = 1;
 80209e6:	4a10      	ldr	r2, [pc, #64]	; (8020a28 <le_device_db_tlv_scan+0x74>)
 80209e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80209ea:	4413      	add	r3, r2
 80209ec:	2201      	movs	r2, #1
 80209ee:	701a      	strb	r2, [r3, #0]
        num_valid_entries++;
 80209f0:	4b0c      	ldr	r3, [pc, #48]	; (8020a24 <le_device_db_tlv_scan+0x70>)
 80209f2:	681b      	ldr	r3, [r3, #0]
 80209f4:	3301      	adds	r3, #1
 80209f6:	4a0b      	ldr	r2, [pc, #44]	; (8020a24 <le_device_db_tlv_scan+0x70>)
 80209f8:	6013      	str	r3, [r2, #0]
 80209fa:	e000      	b.n	80209fe <le_device_db_tlv_scan+0x4a>
        if (!le_device_db_tlv_fetch(i, &entry)) continue;
 80209fc:	bf00      	nop
    for (i=0;i<NVM_NUM_DEVICE_DB_ENTRIES;i++){
 80209fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020a00:	3301      	adds	r3, #1
 8020a02:	63fb      	str	r3, [r7, #60]	; 0x3c
 8020a04:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020a06:	2b0f      	cmp	r3, #15
 8020a08:	dde2      	ble.n	80209d0 <le_device_db_tlv_scan+0x1c>
    }
    log_info("num valid le device entries %u", (unsigned int) num_valid_entries);
 8020a0a:	4b06      	ldr	r3, [pc, #24]	; (8020a24 <le_device_db_tlv_scan+0x70>)
 8020a0c:	681b      	ldr	r3, [r3, #0]
 8020a0e:	9300      	str	r3, [sp, #0]
 8020a10:	239f      	movs	r3, #159	; 0x9f
 8020a12:	4a06      	ldr	r2, [pc, #24]	; (8020a2c <le_device_db_tlv_scan+0x78>)
 8020a14:	4906      	ldr	r1, [pc, #24]	; (8020a30 <le_device_db_tlv_scan+0x7c>)
 8020a16:	2001      	movs	r0, #1
 8020a18:	f7f6 fd12 	bl	8017440 <hci_dump_log>
}
 8020a1c:	bf00      	nop
 8020a1e:	3740      	adds	r7, #64	; 0x40
 8020a20:	46bd      	mov	sp, r7
 8020a22:	bd80      	pop	{r7, pc}
 8020a24:	20009f34 	.word	0x20009f34
 8020a28:	20009f24 	.word	0x20009f24
 8020a2c:	0802d248 	.word	0x0802d248
 8020a30:	0802d25c 	.word	0x0802d25c

08020a34 <le_device_db_init>:

void le_device_db_init(void){
 8020a34:	b580      	push	{r7, lr}
 8020a36:	af00      	add	r7, sp, #0
    if (!le_device_db_tlv_btstack_tlv_impl) {
 8020a38:	4b05      	ldr	r3, [pc, #20]	; (8020a50 <le_device_db_init+0x1c>)
 8020a3a:	681b      	ldr	r3, [r3, #0]
 8020a3c:	2b00      	cmp	r3, #0
 8020a3e:	d105      	bne.n	8020a4c <le_device_db_init+0x18>
        log_error("btstack_tlv not initialized");
 8020a40:	23a4      	movs	r3, #164	; 0xa4
 8020a42:	4a04      	ldr	r2, [pc, #16]	; (8020a54 <le_device_db_init+0x20>)
 8020a44:	4904      	ldr	r1, [pc, #16]	; (8020a58 <le_device_db_init+0x24>)
 8020a46:	2002      	movs	r0, #2
 8020a48:	f7f6 fcfa 	bl	8017440 <hci_dump_log>
    }
}
 8020a4c:	bf00      	nop
 8020a4e:	bd80      	pop	{r7, pc}
 8020a50:	20009f38 	.word	0x20009f38
 8020a54:	0802d248 	.word	0x0802d248
 8020a58:	0802d284 	.word	0x0802d284

08020a5c <le_device_db_set_local_bd_addr>:

// not used
void le_device_db_set_local_bd_addr(bd_addr_t bd_addr){
 8020a5c:	b480      	push	{r7}
 8020a5e:	b083      	sub	sp, #12
 8020a60:	af00      	add	r7, sp, #0
 8020a62:	6078      	str	r0, [r7, #4]
    (void)bd_addr;
}
 8020a64:	bf00      	nop
 8020a66:	370c      	adds	r7, #12
 8020a68:	46bd      	mov	sp, r7
 8020a6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020a6e:	4770      	bx	lr

08020a70 <le_device_db_max_count>:
// @returns number of device in db
int le_device_db_count(void){
	return num_valid_entries;
}

int le_device_db_max_count(void){
 8020a70:	b480      	push	{r7}
 8020a72:	af00      	add	r7, sp, #0
    return NVM_NUM_DEVICE_DB_ENTRIES;
 8020a74:	2310      	movs	r3, #16
}
 8020a76:	4618      	mov	r0, r3
 8020a78:	46bd      	mov	sp, r7
 8020a7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020a7e:	4770      	bx	lr

08020a80 <le_device_db_add>:

    // keep track
    num_valid_entries--;
}

int le_device_db_add(int addr_type, bd_addr_t addr, sm_key_t irk){
 8020a80:	b590      	push	{r4, r7, lr}
 8020a82:	b0af      	sub	sp, #188	; 0xbc
 8020a84:	af04      	add	r7, sp, #16
 8020a86:	60f8      	str	r0, [r7, #12]
 8020a88:	60b9      	str	r1, [r7, #8]
 8020a8a:	607a      	str	r2, [r7, #4]

    uint32_t highest_seq_nr = 0;
 8020a8c:	2300      	movs	r3, #0
 8020a8e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    uint32_t lowest_seq_nr  = 0xFFFFFFFF;
 8020a92:	f04f 33ff 	mov.w	r3, #4294967295
 8020a96:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
    int index_for_lowest_seq_nr = -1;
 8020a9a:	f04f 33ff 	mov.w	r3, #4294967295
 8020a9e:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    int index_for_addr  = -1;
 8020aa2:	f04f 33ff 	mov.w	r3, #4294967295
 8020aa6:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    int index_for_empty = -1;
 8020aaa:	f04f 33ff 	mov.w	r3, #4294967295
 8020aae:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

	// find unused entry in the used list
    int i;
    for (i=0;i<NVM_NUM_DEVICE_DB_ENTRIES;i++){
 8020ab2:	2300      	movs	r3, #0
 8020ab4:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8020ab8:	e043      	b.n	8020b42 <le_device_db_add+0xc2>
         if (entry_map[i]) {
 8020aba:	4a71      	ldr	r2, [pc, #452]	; (8020c80 <le_device_db_add+0x200>)
 8020abc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8020ac0:	4413      	add	r3, r2
 8020ac2:	781b      	ldrb	r3, [r3, #0]
 8020ac4:	2b00      	cmp	r3, #0
 8020ac6:	d033      	beq.n	8020b30 <le_device_db_add+0xb0>
            le_device_db_entry_t entry;
            le_device_db_tlv_fetch(i, &entry);
 8020ac8:	f107 0310 	add.w	r3, r7, #16
 8020acc:	4619      	mov	r1, r3
 8020ace:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 8020ad2:	f7ff ff27 	bl	8020924 <le_device_db_tlv_fetch>
            // found addr?
            if ((memcmp(addr, entry.addr, 6) == 0) && (addr_type == entry.addr_type)){
 8020ad6:	f107 0310 	add.w	r3, r7, #16
 8020ada:	3308      	adds	r3, #8
 8020adc:	2206      	movs	r2, #6
 8020ade:	4619      	mov	r1, r3
 8020ae0:	68b8      	ldr	r0, [r7, #8]
 8020ae2:	f006 ffbb 	bl	8027a5c <memcmp>
 8020ae6:	4603      	mov	r3, r0
 8020ae8:	2b00      	cmp	r3, #0
 8020aea:	d107      	bne.n	8020afc <le_device_db_add+0x7c>
 8020aec:	697b      	ldr	r3, [r7, #20]
 8020aee:	68fa      	ldr	r2, [r7, #12]
 8020af0:	429a      	cmp	r2, r3
 8020af2:	d103      	bne.n	8020afc <le_device_db_add+0x7c>
                index_for_addr = i;
 8020af4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8020af8:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
            }
            // update highest seq nr
            if (entry.seq_nr > highest_seq_nr){
 8020afc:	693b      	ldr	r3, [r7, #16]
 8020afe:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8020b02:	429a      	cmp	r2, r3
 8020b04:	d202      	bcs.n	8020b0c <le_device_db_add+0x8c>
                highest_seq_nr = entry.seq_nr;
 8020b06:	693b      	ldr	r3, [r7, #16]
 8020b08:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
            }
            // find entry with lowest seq nr
            if ((index_for_lowest_seq_nr == -1) || (entry.seq_nr < lowest_seq_nr)){
 8020b0c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8020b10:	f1b3 3fff 	cmp.w	r3, #4294967295
 8020b14:	d004      	beq.n	8020b20 <le_device_db_add+0xa0>
 8020b16:	693b      	ldr	r3, [r7, #16]
 8020b18:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8020b1c:	429a      	cmp	r2, r3
 8020b1e:	d90b      	bls.n	8020b38 <le_device_db_add+0xb8>
                index_for_lowest_seq_nr = i;
 8020b20:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8020b24:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
                lowest_seq_nr = entry.seq_nr;
 8020b28:	693b      	ldr	r3, [r7, #16]
 8020b2a:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8020b2e:	e003      	b.n	8020b38 <le_device_db_add+0xb8>
            }
        } else {
            index_for_empty = i;
 8020b30:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8020b34:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    for (i=0;i<NVM_NUM_DEVICE_DB_ENTRIES;i++){
 8020b38:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8020b3c:	3301      	adds	r3, #1
 8020b3e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8020b42:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8020b46:	2b0f      	cmp	r3, #15
 8020b48:	ddb7      	ble.n	8020aba <le_device_db_add+0x3a>
        }
    }

    log_info("index_for_addr %x, index_for_empy %x, index_for_lowest_seq_nr %x", index_for_addr, index_for_empty, index_for_lowest_seq_nr);
 8020b4a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8020b4e:	9302      	str	r3, [sp, #8]
 8020b50:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8020b54:	9301      	str	r3, [sp, #4]
 8020b56:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8020b5a:	9300      	str	r3, [sp, #0]
 8020b5c:	23e7      	movs	r3, #231	; 0xe7
 8020b5e:	4a49      	ldr	r2, [pc, #292]	; (8020c84 <le_device_db_add+0x204>)
 8020b60:	4949      	ldr	r1, [pc, #292]	; (8020c88 <le_device_db_add+0x208>)
 8020b62:	2001      	movs	r0, #1
 8020b64:	f7f6 fc6c 	bl	8017440 <hci_dump_log>

    uint32_t index_to_use = 0;
 8020b68:	2300      	movs	r3, #0
 8020b6a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    if (index_for_addr >= 0){
 8020b6e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8020b72:	2b00      	cmp	r3, #0
 8020b74:	db04      	blt.n	8020b80 <le_device_db_add+0x100>
        index_to_use = index_for_addr;
 8020b76:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8020b7a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 8020b7e:	e014      	b.n	8020baa <le_device_db_add+0x12a>
    } else if (index_for_empty >= 0){
 8020b80:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8020b84:	2b00      	cmp	r3, #0
 8020b86:	db04      	blt.n	8020b92 <le_device_db_add+0x112>
        index_to_use = index_for_empty;
 8020b88:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8020b8c:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 8020b90:	e00b      	b.n	8020baa <le_device_db_add+0x12a>
    } else if (index_for_lowest_seq_nr >= 0){
 8020b92:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8020b96:	2b00      	cmp	r3, #0
 8020b98:	db04      	blt.n	8020ba4 <le_device_db_add+0x124>
        index_to_use = index_for_lowest_seq_nr;
 8020b9a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8020b9e:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 8020ba2:	e002      	b.n	8020baa <le_device_db_add+0x12a>
    } else {
        // should not happen
        return -1;
 8020ba4:	f04f 33ff 	mov.w	r3, #4294967295
 8020ba8:	e065      	b.n	8020c76 <le_device_db_add+0x1f6>
    }

    log_info("new entry for index %u", (unsigned int) index_to_use);
 8020baa:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8020bae:	9300      	str	r3, [sp, #0]
 8020bb0:	23f5      	movs	r3, #245	; 0xf5
 8020bb2:	4a34      	ldr	r2, [pc, #208]	; (8020c84 <le_device_db_add+0x204>)
 8020bb4:	4935      	ldr	r1, [pc, #212]	; (8020c8c <le_device_db_add+0x20c>)
 8020bb6:	2001      	movs	r0, #1
 8020bb8:	f7f6 fc42 	bl	8017440 <hci_dump_log>

    // store entry at index
	le_device_db_entry_t entry;
    log_info("LE Device DB adding type %u - %s", addr_type, bd_addr_to_str(addr));
 8020bbc:	68b8      	ldr	r0, [r7, #8]
 8020bbe:	f7ee fc27 	bl	800f410 <bd_addr_to_str>
 8020bc2:	4603      	mov	r3, r0
 8020bc4:	9301      	str	r3, [sp, #4]
 8020bc6:	68fb      	ldr	r3, [r7, #12]
 8020bc8:	9300      	str	r3, [sp, #0]
 8020bca:	23f9      	movs	r3, #249	; 0xf9
 8020bcc:	4a2d      	ldr	r2, [pc, #180]	; (8020c84 <le_device_db_add+0x204>)
 8020bce:	4930      	ldr	r1, [pc, #192]	; (8020c90 <le_device_db_add+0x210>)
 8020bd0:	2001      	movs	r0, #1
 8020bd2:	f7f6 fc35 	bl	8017440 <hci_dump_log>
    log_info_key("irk", irk);
 8020bd6:	6879      	ldr	r1, [r7, #4]
 8020bd8:	482e      	ldr	r0, [pc, #184]	; (8020c94 <le_device_db_add+0x214>)
 8020bda:	f7ee fbcb 	bl	800f374 <log_info_key>

    memset(&entry, 0, sizeof(le_device_db_entry_t));
 8020bde:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8020be2:	223c      	movs	r2, #60	; 0x3c
 8020be4:	2100      	movs	r1, #0
 8020be6:	4618      	mov	r0, r3
 8020be8:	f006 ff6b 	bl	8027ac2 <memset>

    entry.addr_type = addr_type;
 8020bec:	68fb      	ldr	r3, [r7, #12]
 8020bee:	653b      	str	r3, [r7, #80]	; 0x50
    (void)memcpy(entry.addr, addr, 6);
 8020bf0:	68ba      	ldr	r2, [r7, #8]
 8020bf2:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8020bf6:	6810      	ldr	r0, [r2, #0]
 8020bf8:	6018      	str	r0, [r3, #0]
 8020bfa:	8892      	ldrh	r2, [r2, #4]
 8020bfc:	809a      	strh	r2, [r3, #4]
    (void)memcpy(entry.irk, irk, 16);
 8020bfe:	687a      	ldr	r2, [r7, #4]
 8020c00:	f107 035a 	add.w	r3, r7, #90	; 0x5a
 8020c04:	6814      	ldr	r4, [r2, #0]
 8020c06:	6850      	ldr	r0, [r2, #4]
 8020c08:	6891      	ldr	r1, [r2, #8]
 8020c0a:	68d2      	ldr	r2, [r2, #12]
 8020c0c:	601c      	str	r4, [r3, #0]
 8020c0e:	6058      	str	r0, [r3, #4]
 8020c10:	6099      	str	r1, [r3, #8]
 8020c12:	60da      	str	r2, [r3, #12]
    entry.seq_nr = highest_seq_nr + 1u;
 8020c14:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8020c18:	3301      	adds	r3, #1
 8020c1a:	64fb      	str	r3, [r7, #76]	; 0x4c
 #ifdef ENABLE_LE_SIGNED_WRITE
    entry.remote_counter = 0; 
#endif

    // store
    bool ok = le_device_db_tlv_store(index_to_use, &entry);
 8020c1c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8020c20:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 8020c24:	4611      	mov	r1, r2
 8020c26:	4618      	mov	r0, r3
 8020c28:	f7ff fea0 	bl	802096c <le_device_db_tlv_store>
 8020c2c:	4603      	mov	r3, r0
 8020c2e:	f887 308b 	strb.w	r3, [r7, #139]	; 0x8b
    if (!ok){
 8020c32:	f897 308b 	ldrb.w	r3, [r7, #139]	; 0x8b
 8020c36:	f083 0301 	eor.w	r3, r3, #1
 8020c3a:	b2db      	uxtb	r3, r3
 8020c3c:	2b00      	cmp	r3, #0
 8020c3e:	d009      	beq.n	8020c54 <le_device_db_add+0x1d4>
        log_error("tag store failed");
 8020c40:	f240 1309 	movw	r3, #265	; 0x109
 8020c44:	4a0f      	ldr	r2, [pc, #60]	; (8020c84 <le_device_db_add+0x204>)
 8020c46:	4914      	ldr	r1, [pc, #80]	; (8020c98 <le_device_db_add+0x218>)
 8020c48:	2002      	movs	r0, #2
 8020c4a:	f7f6 fbf9 	bl	8017440 <hci_dump_log>
        return -1;
 8020c4e:	f04f 33ff 	mov.w	r3, #4294967295
 8020c52:	e010      	b.n	8020c76 <le_device_db_add+0x1f6>
    }
    // set in entry_mape
    entry_map[index_to_use] = 1;
 8020c54:	4a0a      	ldr	r2, [pc, #40]	; (8020c80 <le_device_db_add+0x200>)
 8020c56:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8020c5a:	4413      	add	r3, r2
 8020c5c:	2201      	movs	r2, #1
 8020c5e:	701a      	strb	r2, [r3, #0]

    // keep track - don't increase if old entry found
    if (index_for_addr < 0){
 8020c60:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8020c64:	2b00      	cmp	r3, #0
 8020c66:	da04      	bge.n	8020c72 <le_device_db_add+0x1f2>
        num_valid_entries++;
 8020c68:	4b0c      	ldr	r3, [pc, #48]	; (8020c9c <le_device_db_add+0x21c>)
 8020c6a:	681b      	ldr	r3, [r3, #0]
 8020c6c:	3301      	adds	r3, #1
 8020c6e:	4a0b      	ldr	r2, [pc, #44]	; (8020c9c <le_device_db_add+0x21c>)
 8020c70:	6013      	str	r3, [r2, #0]
    }

    return index_to_use;
 8020c72:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
}
 8020c76:	4618      	mov	r0, r3
 8020c78:	37ac      	adds	r7, #172	; 0xac
 8020c7a:	46bd      	mov	sp, r7
 8020c7c:	bd90      	pop	{r4, r7, pc}
 8020c7e:	bf00      	nop
 8020c80:	20009f24 	.word	0x20009f24
 8020c84:	0802d248 	.word	0x0802d248
 8020c88:	0802d2a8 	.word	0x0802d2a8
 8020c8c:	0802d2f0 	.word	0x0802d2f0
 8020c90:	0802d310 	.word	0x0802d310
 8020c94:	0802d338 	.word	0x0802d338
 8020c98:	0802d33c 	.word	0x0802d33c
 8020c9c:	20009f34 	.word	0x20009f34

08020ca0 <le_device_db_info>:


// get device information: addr type and address
void le_device_db_info(int index, int * addr_type, bd_addr_t addr, sm_key_t irk){
 8020ca0:	b590      	push	{r4, r7, lr}
 8020ca2:	b095      	sub	sp, #84	; 0x54
 8020ca4:	af00      	add	r7, sp, #0
 8020ca6:	60f8      	str	r0, [r7, #12]
 8020ca8:	60b9      	str	r1, [r7, #8]
 8020caa:	607a      	str	r2, [r7, #4]
 8020cac:	603b      	str	r3, [r7, #0]

	// fetch entry
    le_device_db_entry_t entry;
    int ok = le_device_db_tlv_fetch(index, &entry);
 8020cae:	f107 0310 	add.w	r3, r7, #16
 8020cb2:	4619      	mov	r1, r3
 8020cb4:	68f8      	ldr	r0, [r7, #12]
 8020cb6:	f7ff fe35 	bl	8020924 <le_device_db_tlv_fetch>
 8020cba:	4603      	mov	r3, r0
 8020cbc:	64fb      	str	r3, [r7, #76]	; 0x4c

    // set defaults if not found
    if (!ok) {
 8020cbe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020cc0:	2b00      	cmp	r3, #0
 8020cc2:	d108      	bne.n	8020cd6 <le_device_db_info+0x36>
        memset(&entry, 0, sizeof(le_device_db_entry_t));
 8020cc4:	f107 0310 	add.w	r3, r7, #16
 8020cc8:	223c      	movs	r2, #60	; 0x3c
 8020cca:	2100      	movs	r1, #0
 8020ccc:	4618      	mov	r0, r3
 8020cce:	f006 fef8 	bl	8027ac2 <memset>
        entry.addr_type = BD_ADDR_TYPE_UNKNOWN;
 8020cd2:	23fe      	movs	r3, #254	; 0xfe
 8020cd4:	617b      	str	r3, [r7, #20]
    }

    // setup return values
    if (addr_type != NULL) *addr_type = entry.addr_type;
 8020cd6:	68bb      	ldr	r3, [r7, #8]
 8020cd8:	2b00      	cmp	r3, #0
 8020cda:	d002      	beq.n	8020ce2 <le_device_db_info+0x42>
 8020cdc:	697a      	ldr	r2, [r7, #20]
 8020cde:	68bb      	ldr	r3, [r7, #8]
 8020ce0:	601a      	str	r2, [r3, #0]
    if (addr != NULL) (void)memcpy(addr, entry.addr, 6);
 8020ce2:	687b      	ldr	r3, [r7, #4]
 8020ce4:	2b00      	cmp	r3, #0
 8020ce6:	d007      	beq.n	8020cf8 <le_device_db_info+0x58>
 8020ce8:	687b      	ldr	r3, [r7, #4]
 8020cea:	461a      	mov	r2, r3
 8020cec:	f107 0318 	add.w	r3, r7, #24
 8020cf0:	6818      	ldr	r0, [r3, #0]
 8020cf2:	6010      	str	r0, [r2, #0]
 8020cf4:	889b      	ldrh	r3, [r3, #4]
 8020cf6:	8093      	strh	r3, [r2, #4]
    if (irk != NULL) (void)memcpy(irk, entry.irk, 16);
 8020cf8:	683b      	ldr	r3, [r7, #0]
 8020cfa:	2b00      	cmp	r3, #0
 8020cfc:	d00b      	beq.n	8020d16 <le_device_db_info+0x76>
 8020cfe:	683b      	ldr	r3, [r7, #0]
 8020d00:	461a      	mov	r2, r3
 8020d02:	f107 031e 	add.w	r3, r7, #30
 8020d06:	681c      	ldr	r4, [r3, #0]
 8020d08:	6858      	ldr	r0, [r3, #4]
 8020d0a:	6899      	ldr	r1, [r3, #8]
 8020d0c:	68db      	ldr	r3, [r3, #12]
 8020d0e:	6014      	str	r4, [r2, #0]
 8020d10:	6050      	str	r0, [r2, #4]
 8020d12:	6091      	str	r1, [r2, #8]
 8020d14:	60d3      	str	r3, [r2, #12]
}
 8020d16:	bf00      	nop
 8020d18:	3754      	adds	r7, #84	; 0x54
 8020d1a:	46bd      	mov	sp, r7
 8020d1c:	bd90      	pop	{r4, r7, pc}
	...

08020d20 <le_device_db_encryption_set>:

void le_device_db_encryption_set(int index, uint16_t ediv, uint8_t rand[8], sm_key_t ltk, int key_size, int authenticated, int authorized, int secure_connection){
 8020d20:	b590      	push	{r4, r7, lr}
 8020d22:	b09b      	sub	sp, #108	; 0x6c
 8020d24:	af06      	add	r7, sp, #24
 8020d26:	60f8      	str	r0, [r7, #12]
 8020d28:	607a      	str	r2, [r7, #4]
 8020d2a:	603b      	str	r3, [r7, #0]
 8020d2c:	460b      	mov	r3, r1
 8020d2e:	817b      	strh	r3, [r7, #10]

	// fetch entry
	le_device_db_entry_t entry;
	int ok = le_device_db_tlv_fetch(index, &entry);
 8020d30:	f107 0310 	add.w	r3, r7, #16
 8020d34:	4619      	mov	r1, r3
 8020d36:	68f8      	ldr	r0, [r7, #12]
 8020d38:	f7ff fdf4 	bl	8020924 <le_device_db_tlv_fetch>
 8020d3c:	4603      	mov	r3, r0
 8020d3e:	64fb      	str	r3, [r7, #76]	; 0x4c
	if (!ok) return;
 8020d40:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020d42:	2b00      	cmp	r3, #0
 8020d44:	d04e      	beq.n	8020de4 <le_device_db_encryption_set+0xc4>

	// update
    log_info("LE Device DB set encryption for %u, ediv x%04x, key size %u, authenticated %u, authorized %u, secure connection %u",
 8020d46:	897b      	ldrh	r3, [r7, #10]
 8020d48:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8020d4a:	9205      	str	r2, [sp, #20]
 8020d4c:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8020d4e:	9204      	str	r2, [sp, #16]
 8020d50:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8020d52:	9203      	str	r2, [sp, #12]
 8020d54:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8020d56:	9202      	str	r2, [sp, #8]
 8020d58:	9301      	str	r3, [sp, #4]
 8020d5a:	68fb      	ldr	r3, [r7, #12]
 8020d5c:	9300      	str	r3, [sp, #0]
 8020d5e:	f44f 739a 	mov.w	r3, #308	; 0x134
 8020d62:	4a22      	ldr	r2, [pc, #136]	; (8020dec <le_device_db_encryption_set+0xcc>)
 8020d64:	4922      	ldr	r1, [pc, #136]	; (8020df0 <le_device_db_encryption_set+0xd0>)
 8020d66:	2001      	movs	r0, #1
 8020d68:	f7f6 fb6a 	bl	8017440 <hci_dump_log>
        index, ediv, key_size, authenticated, authorized, secure_connection);
    entry.ediv = ediv;
 8020d6c:	897b      	ldrh	r3, [r7, #10]
 8020d6e:	87fb      	strh	r3, [r7, #62]	; 0x3e
    if (rand != 0) (void)memcpy(entry.rand, rand, 8);
 8020d70:	687b      	ldr	r3, [r7, #4]
 8020d72:	2b00      	cmp	r3, #0
 8020d74:	d005      	beq.n	8020d82 <le_device_db_encryption_set+0x62>
 8020d76:	687a      	ldr	r2, [r7, #4]
 8020d78:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8020d7c:	6810      	ldr	r0, [r2, #0]
 8020d7e:	6851      	ldr	r1, [r2, #4]
 8020d80:	c303      	stmia	r3!, {r0, r1}
    if (ltk != 0) (void)memcpy(entry.ltk, ltk, 16);
 8020d82:	683b      	ldr	r3, [r7, #0]
 8020d84:	2b00      	cmp	r3, #0
 8020d86:	d00a      	beq.n	8020d9e <le_device_db_encryption_set+0x7e>
 8020d88:	683a      	ldr	r2, [r7, #0]
 8020d8a:	f107 032e 	add.w	r3, r7, #46	; 0x2e
 8020d8e:	6814      	ldr	r4, [r2, #0]
 8020d90:	6850      	ldr	r0, [r2, #4]
 8020d92:	6891      	ldr	r1, [r2, #8]
 8020d94:	68d2      	ldr	r2, [r2, #12]
 8020d96:	601c      	str	r4, [r3, #0]
 8020d98:	6058      	str	r0, [r3, #4]
 8020d9a:	6099      	str	r1, [r3, #8]
 8020d9c:	60da      	str	r2, [r3, #12]
    entry.key_size = key_size;
 8020d9e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8020da0:	b2db      	uxtb	r3, r3
 8020da2:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
    entry.authenticated = authenticated;
 8020da6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8020da8:	b2db      	uxtb	r3, r3
 8020daa:	f887 3049 	strb.w	r3, [r7, #73]	; 0x49
    entry.authorized = authorized;
 8020dae:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8020db0:	b2db      	uxtb	r3, r3
 8020db2:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
    entry.secure_connection = secure_connection;
 8020db6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8020db8:	b2db      	uxtb	r3, r3
 8020dba:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b

    // store
    ok = le_device_db_tlv_store(index, &entry);
 8020dbe:	f107 0310 	add.w	r3, r7, #16
 8020dc2:	4619      	mov	r1, r3
 8020dc4:	68f8      	ldr	r0, [r7, #12]
 8020dc6:	f7ff fdd1 	bl	802096c <le_device_db_tlv_store>
 8020dca:	4603      	mov	r3, r0
 8020dcc:	64fb      	str	r3, [r7, #76]	; 0x4c
    if (!ok){
 8020dce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020dd0:	2b00      	cmp	r3, #0
 8020dd2:	d108      	bne.n	8020de6 <le_device_db_encryption_set+0xc6>
        log_error("Set encryption data failed");
 8020dd4:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8020dd8:	4a04      	ldr	r2, [pc, #16]	; (8020dec <le_device_db_encryption_set+0xcc>)
 8020dda:	4906      	ldr	r1, [pc, #24]	; (8020df4 <le_device_db_encryption_set+0xd4>)
 8020ddc:	2002      	movs	r0, #2
 8020dde:	f7f6 fb2f 	bl	8017440 <hci_dump_log>
 8020de2:	e000      	b.n	8020de6 <le_device_db_encryption_set+0xc6>
	if (!ok) return;
 8020de4:	bf00      	nop
    }
}
 8020de6:	3754      	adds	r7, #84	; 0x54
 8020de8:	46bd      	mov	sp, r7
 8020dea:	bd90      	pop	{r4, r7, pc}
 8020dec:	0802d248 	.word	0x0802d248
 8020df0:	0802d354 	.word	0x0802d354
 8020df4:	0802d3d0 	.word	0x0802d3d0

08020df8 <le_device_db_encryption_get>:

void le_device_db_encryption_get(int index, uint16_t * ediv, uint8_t rand[8], sm_key_t ltk, int * key_size, int * authenticated, int * authorized, int * secure_connection){
 8020df8:	b590      	push	{r4, r7, lr}
 8020dfa:	b09b      	sub	sp, #108	; 0x6c
 8020dfc:	af06      	add	r7, sp, #24
 8020dfe:	60f8      	str	r0, [r7, #12]
 8020e00:	60b9      	str	r1, [r7, #8]
 8020e02:	607a      	str	r2, [r7, #4]
 8020e04:	603b      	str	r3, [r7, #0]

	// fetch entry
	le_device_db_entry_t entry;
	int ok = le_device_db_tlv_fetch(index, &entry);
 8020e06:	f107 0310 	add.w	r3, r7, #16
 8020e0a:	4619      	mov	r1, r3
 8020e0c:	68f8      	ldr	r0, [r7, #12]
 8020e0e:	f7ff fd89 	bl	8020924 <le_device_db_tlv_fetch>
 8020e12:	4603      	mov	r3, r0
 8020e14:	64fb      	str	r3, [r7, #76]	; 0x4c
	if (!ok) return;
 8020e16:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020e18:	2b00      	cmp	r3, #0
 8020e1a:	d056      	beq.n	8020eca <le_device_db_encryption_get+0xd2>

	// update user fields
    log_info("LE Device DB encryption for %u, ediv x%04x, keysize %u, authenticated %u, authorized %u, secure connection %u",
 8020e1c:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8020e1e:	f897 2048 	ldrb.w	r2, [r7, #72]	; 0x48
 8020e22:	f897 1049 	ldrb.w	r1, [r7, #73]	; 0x49
 8020e26:	f897 004a 	ldrb.w	r0, [r7, #74]	; 0x4a
 8020e2a:	f897 404b 	ldrb.w	r4, [r7, #75]	; 0x4b
 8020e2e:	9405      	str	r4, [sp, #20]
 8020e30:	9004      	str	r0, [sp, #16]
 8020e32:	9103      	str	r1, [sp, #12]
 8020e34:	9202      	str	r2, [sp, #8]
 8020e36:	9301      	str	r3, [sp, #4]
 8020e38:	68fb      	ldr	r3, [r7, #12]
 8020e3a:	9300      	str	r3, [sp, #0]
 8020e3c:	f240 134d 	movw	r3, #333	; 0x14d
 8020e40:	4a24      	ldr	r2, [pc, #144]	; (8020ed4 <le_device_db_encryption_get+0xdc>)
 8020e42:	4925      	ldr	r1, [pc, #148]	; (8020ed8 <le_device_db_encryption_get+0xe0>)
 8020e44:	2001      	movs	r0, #1
 8020e46:	f7f6 fafb 	bl	8017440 <hci_dump_log>
        index, entry.ediv, entry.key_size, entry.authenticated, entry.authorized, entry.secure_connection);
    if (ediv != NULL) *ediv = entry.ediv;
 8020e4a:	68bb      	ldr	r3, [r7, #8]
 8020e4c:	2b00      	cmp	r3, #0
 8020e4e:	d002      	beq.n	8020e56 <le_device_db_encryption_get+0x5e>
 8020e50:	8ffa      	ldrh	r2, [r7, #62]	; 0x3e
 8020e52:	68bb      	ldr	r3, [r7, #8]
 8020e54:	801a      	strh	r2, [r3, #0]
    if (rand != NULL) (void)memcpy(rand, entry.rand, 8);
 8020e56:	687b      	ldr	r3, [r7, #4]
 8020e58:	2b00      	cmp	r3, #0
 8020e5a:	d006      	beq.n	8020e6a <le_device_db_encryption_get+0x72>
 8020e5c:	687b      	ldr	r3, [r7, #4]
 8020e5e:	461a      	mov	r2, r3
 8020e60:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8020e64:	cb03      	ldmia	r3!, {r0, r1}
 8020e66:	6010      	str	r0, [r2, #0]
 8020e68:	6051      	str	r1, [r2, #4]
    if (ltk != NULL)  (void)memcpy(ltk, entry.ltk, 16);
 8020e6a:	683b      	ldr	r3, [r7, #0]
 8020e6c:	2b00      	cmp	r3, #0
 8020e6e:	d00b      	beq.n	8020e88 <le_device_db_encryption_get+0x90>
 8020e70:	683b      	ldr	r3, [r7, #0]
 8020e72:	461a      	mov	r2, r3
 8020e74:	f107 032e 	add.w	r3, r7, #46	; 0x2e
 8020e78:	681c      	ldr	r4, [r3, #0]
 8020e7a:	6858      	ldr	r0, [r3, #4]
 8020e7c:	6899      	ldr	r1, [r3, #8]
 8020e7e:	68db      	ldr	r3, [r3, #12]
 8020e80:	6014      	str	r4, [r2, #0]
 8020e82:	6050      	str	r0, [r2, #4]
 8020e84:	6091      	str	r1, [r2, #8]
 8020e86:	60d3      	str	r3, [r2, #12]
    if (key_size != NULL) *key_size = entry.key_size;
 8020e88:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8020e8a:	2b00      	cmp	r3, #0
 8020e8c:	d004      	beq.n	8020e98 <le_device_db_encryption_get+0xa0>
 8020e8e:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 8020e92:	461a      	mov	r2, r3
 8020e94:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8020e96:	601a      	str	r2, [r3, #0]
    if (authenticated != NULL) *authenticated = entry.authenticated;
 8020e98:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8020e9a:	2b00      	cmp	r3, #0
 8020e9c:	d004      	beq.n	8020ea8 <le_device_db_encryption_get+0xb0>
 8020e9e:	f897 3049 	ldrb.w	r3, [r7, #73]	; 0x49
 8020ea2:	461a      	mov	r2, r3
 8020ea4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8020ea6:	601a      	str	r2, [r3, #0]
    if (authorized != NULL) *authorized = entry.authorized;
 8020ea8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8020eaa:	2b00      	cmp	r3, #0
 8020eac:	d004      	beq.n	8020eb8 <le_device_db_encryption_get+0xc0>
 8020eae:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
 8020eb2:	461a      	mov	r2, r3
 8020eb4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8020eb6:	601a      	str	r2, [r3, #0]
    if (secure_connection != NULL) *secure_connection = entry.secure_connection;
 8020eb8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8020eba:	2b00      	cmp	r3, #0
 8020ebc:	d006      	beq.n	8020ecc <le_device_db_encryption_get+0xd4>
 8020ebe:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8020ec2:	461a      	mov	r2, r3
 8020ec4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8020ec6:	601a      	str	r2, [r3, #0]
 8020ec8:	e000      	b.n	8020ecc <le_device_db_encryption_get+0xd4>
	if (!ok) return;
 8020eca:	bf00      	nop
}
 8020ecc:	3754      	adds	r7, #84	; 0x54
 8020ece:	46bd      	mov	sp, r7
 8020ed0:	bd90      	pop	{r4, r7, pc}
 8020ed2:	bf00      	nop
 8020ed4:	0802d248 	.word	0x0802d248
 8020ed8:	0802d3f4 	.word	0x0802d3f4

08020edc <le_device_db_tlv_configure>:
        log_info_key("remote csrk", entry.remote_csrk);
#endif
    }
}

void le_device_db_tlv_configure(const btstack_tlv_t * btstack_tlv_impl, void * btstack_tlv_context){
 8020edc:	b580      	push	{r7, lr}
 8020ede:	b082      	sub	sp, #8
 8020ee0:	af00      	add	r7, sp, #0
 8020ee2:	6078      	str	r0, [r7, #4]
 8020ee4:	6039      	str	r1, [r7, #0]
	le_device_db_tlv_btstack_tlv_impl = btstack_tlv_impl;
 8020ee6:	4a06      	ldr	r2, [pc, #24]	; (8020f00 <le_device_db_tlv_configure+0x24>)
 8020ee8:	687b      	ldr	r3, [r7, #4]
 8020eea:	6013      	str	r3, [r2, #0]
	le_device_db_tlv_btstack_tlv_context = btstack_tlv_context;
 8020eec:	4a05      	ldr	r2, [pc, #20]	; (8020f04 <le_device_db_tlv_configure+0x28>)
 8020eee:	683b      	ldr	r3, [r7, #0]
 8020ef0:	6013      	str	r3, [r2, #0]
    le_device_db_tlv_scan();
 8020ef2:	f7ff fd5f 	bl	80209b4 <le_device_db_tlv_scan>
}
 8020ef6:	bf00      	nop
 8020ef8:	3708      	adds	r7, #8
 8020efa:	46bd      	mov	sp, r7
 8020efc:	bd80      	pop	{r7, pc}
 8020efe:	bf00      	nop
 8020f00:	20009f38 	.word	0x20009f38
 8020f04:	20009f3c 	.word	0x20009f3c

08020f08 <hci_event_packet_get_type>:
static inline uint8_t hci_event_packet_get_type(const uint8_t * event){
 8020f08:	b480      	push	{r7}
 8020f0a:	b083      	sub	sp, #12
 8020f0c:	af00      	add	r7, sp, #0
 8020f0e:	6078      	str	r0, [r7, #4]
    return event[0];
 8020f10:	687b      	ldr	r3, [r7, #4]
 8020f12:	781b      	ldrb	r3, [r3, #0]
}
 8020f14:	4618      	mov	r0, r3
 8020f16:	370c      	adds	r7, #12
 8020f18:	46bd      	mov	sp, r7
 8020f1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020f1e:	4770      	bx	lr

08020f20 <hci_event_encryption_change_get_status>:
static inline uint8_t hci_event_encryption_change_get_status(const uint8_t * event){
 8020f20:	b480      	push	{r7}
 8020f22:	b083      	sub	sp, #12
 8020f24:	af00      	add	r7, sp, #0
 8020f26:	6078      	str	r0, [r7, #4]
    return event[2];
 8020f28:	687b      	ldr	r3, [r7, #4]
 8020f2a:	3302      	adds	r3, #2
 8020f2c:	781b      	ldrb	r3, [r3, #0]
}
 8020f2e:	4618      	mov	r0, r3
 8020f30:	370c      	adds	r7, #12
 8020f32:	46bd      	mov	sp, r7
 8020f34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020f38:	4770      	bx	lr

08020f3a <hci_event_encryption_change_get_connection_handle>:
static inline uint16_t hci_event_encryption_change_get_connection_handle(const uint8_t * event){
 8020f3a:	b580      	push	{r7, lr}
 8020f3c:	b082      	sub	sp, #8
 8020f3e:	af00      	add	r7, sp, #0
 8020f40:	6078      	str	r0, [r7, #4]
    return little_endian_read_16(event, 3);
 8020f42:	2103      	movs	r1, #3
 8020f44:	6878      	ldr	r0, [r7, #4]
 8020f46:	f7ed ff4e 	bl	800ede6 <little_endian_read_16>
 8020f4a:	4603      	mov	r3, r0
}
 8020f4c:	4618      	mov	r0, r3
 8020f4e:	3708      	adds	r7, #8
 8020f50:	46bd      	mov	sp, r7
 8020f52:	bd80      	pop	{r7, pc}

08020f54 <hci_event_encryption_change_get_encryption_enabled>:
static inline uint8_t hci_event_encryption_change_get_encryption_enabled(const uint8_t * event){
 8020f54:	b480      	push	{r7}
 8020f56:	b083      	sub	sp, #12
 8020f58:	af00      	add	r7, sp, #0
 8020f5a:	6078      	str	r0, [r7, #4]
    return event[5];
 8020f5c:	687b      	ldr	r3, [r7, #4]
 8020f5e:	3305      	adds	r3, #5
 8020f60:	781b      	ldrb	r3, [r3, #0]
}
 8020f62:	4618      	mov	r0, r3
 8020f64:	370c      	adds	r7, #12
 8020f66:	46bd      	mov	sp, r7
 8020f68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020f6c:	4770      	bx	lr

08020f6e <btstack_event_state_get_state>:
static inline uint8_t btstack_event_state_get_state(const uint8_t * event){
 8020f6e:	b480      	push	{r7}
 8020f70:	b083      	sub	sp, #12
 8020f72:	af00      	add	r7, sp, #0
 8020f74:	6078      	str	r0, [r7, #4]
    return event[2];
 8020f76:	687b      	ldr	r3, [r7, #4]
 8020f78:	3302      	adds	r3, #2
 8020f7a:	781b      	ldrb	r3, [r3, #0]
}
 8020f7c:	4618      	mov	r0, r3
 8020f7e:	370c      	adds	r7, #12
 8020f80:	46bd      	mov	sp, r7
 8020f82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020f86:	4770      	bx	lr

08020f88 <log_info_hex16>:
static void sm_handle_random_result_sc_next_send_pairing_random(void * arg);
static int sm_passkey_entry(stk_generation_method_t method);
#endif
static void sm_pairing_complete(sm_connection_t * sm_conn, uint8_t status, uint8_t reason);

static void log_info_hex16(const char * name, uint16_t value){
 8020f88:	b580      	push	{r7, lr}
 8020f8a:	b084      	sub	sp, #16
 8020f8c:	af02      	add	r7, sp, #8
 8020f8e:	6078      	str	r0, [r7, #4]
 8020f90:	460b      	mov	r3, r1
 8020f92:	807b      	strh	r3, [r7, #2]
    log_info("%-6s 0x%04x", name, value);
 8020f94:	887b      	ldrh	r3, [r7, #2]
 8020f96:	9301      	str	r3, [sp, #4]
 8020f98:	687b      	ldr	r3, [r7, #4]
 8020f9a:	9300      	str	r3, [sp, #0]
 8020f9c:	f44f 73d3 	mov.w	r3, #422	; 0x1a6
 8020fa0:	4a04      	ldr	r2, [pc, #16]	; (8020fb4 <log_info_hex16+0x2c>)
 8020fa2:	4905      	ldr	r1, [pc, #20]	; (8020fb8 <log_info_hex16+0x30>)
 8020fa4:	2001      	movs	r0, #1
 8020fa6:	f7f6 fa4b 	bl	8017440 <hci_dump_log>
}
 8020faa:	bf00      	nop
 8020fac:	3708      	adds	r7, #8
 8020fae:	46bd      	mov	sp, r7
 8020fb0:	bd80      	pop	{r7, pc}
 8020fb2:	bf00      	nop
 8020fb4:	0802d4a8 	.word	0x0802d4a8
 8020fb8:	0802d4b0 	.word	0x0802d4b0

08020fbc <sm_pairing_packet_get_io_capability>:

// static inline uint8_t sm_pairing_packet_get_code(sm_pairing_packet_t packet){
//     return packet[0];
// }
static inline uint8_t sm_pairing_packet_get_io_capability(sm_pairing_packet_t packet){
 8020fbc:	b480      	push	{r7}
 8020fbe:	b083      	sub	sp, #12
 8020fc0:	af00      	add	r7, sp, #0
 8020fc2:	6078      	str	r0, [r7, #4]
    return packet[1];
 8020fc4:	687b      	ldr	r3, [r7, #4]
 8020fc6:	785b      	ldrb	r3, [r3, #1]
}
 8020fc8:	4618      	mov	r0, r3
 8020fca:	370c      	adds	r7, #12
 8020fcc:	46bd      	mov	sp, r7
 8020fce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020fd2:	4770      	bx	lr

08020fd4 <sm_pairing_packet_get_oob_data_flag>:
static inline uint8_t sm_pairing_packet_get_oob_data_flag(sm_pairing_packet_t packet){
 8020fd4:	b480      	push	{r7}
 8020fd6:	b083      	sub	sp, #12
 8020fd8:	af00      	add	r7, sp, #0
 8020fda:	6078      	str	r0, [r7, #4]
    return packet[2];
 8020fdc:	687b      	ldr	r3, [r7, #4]
 8020fde:	789b      	ldrb	r3, [r3, #2]
}
 8020fe0:	4618      	mov	r0, r3
 8020fe2:	370c      	adds	r7, #12
 8020fe4:	46bd      	mov	sp, r7
 8020fe6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020fea:	4770      	bx	lr

08020fec <sm_pairing_packet_get_auth_req>:
static inline uint8_t sm_pairing_packet_get_auth_req(sm_pairing_packet_t packet){
 8020fec:	b480      	push	{r7}
 8020fee:	b083      	sub	sp, #12
 8020ff0:	af00      	add	r7, sp, #0
 8020ff2:	6078      	str	r0, [r7, #4]
    return packet[3];
 8020ff4:	687b      	ldr	r3, [r7, #4]
 8020ff6:	78db      	ldrb	r3, [r3, #3]
}
 8020ff8:	4618      	mov	r0, r3
 8020ffa:	370c      	adds	r7, #12
 8020ffc:	46bd      	mov	sp, r7
 8020ffe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021002:	4770      	bx	lr

08021004 <sm_pairing_packet_get_max_encryption_key_size>:
static inline uint8_t sm_pairing_packet_get_max_encryption_key_size(sm_pairing_packet_t packet){
 8021004:	b480      	push	{r7}
 8021006:	b083      	sub	sp, #12
 8021008:	af00      	add	r7, sp, #0
 802100a:	6078      	str	r0, [r7, #4]
    return packet[4];
 802100c:	687b      	ldr	r3, [r7, #4]
 802100e:	791b      	ldrb	r3, [r3, #4]
}
 8021010:	4618      	mov	r0, r3
 8021012:	370c      	adds	r7, #12
 8021014:	46bd      	mov	sp, r7
 8021016:	f85d 7b04 	ldr.w	r7, [sp], #4
 802101a:	4770      	bx	lr

0802101c <sm_pairing_packet_get_initiator_key_distribution>:
static inline uint8_t sm_pairing_packet_get_initiator_key_distribution(sm_pairing_packet_t packet){
 802101c:	b480      	push	{r7}
 802101e:	b083      	sub	sp, #12
 8021020:	af00      	add	r7, sp, #0
 8021022:	6078      	str	r0, [r7, #4]
    return packet[5];
 8021024:	687b      	ldr	r3, [r7, #4]
 8021026:	795b      	ldrb	r3, [r3, #5]
}
 8021028:	4618      	mov	r0, r3
 802102a:	370c      	adds	r7, #12
 802102c:	46bd      	mov	sp, r7
 802102e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021032:	4770      	bx	lr

08021034 <sm_pairing_packet_get_responder_key_distribution>:
static inline uint8_t sm_pairing_packet_get_responder_key_distribution(sm_pairing_packet_t packet){
 8021034:	b480      	push	{r7}
 8021036:	b083      	sub	sp, #12
 8021038:	af00      	add	r7, sp, #0
 802103a:	6078      	str	r0, [r7, #4]
    return packet[6];
 802103c:	687b      	ldr	r3, [r7, #4]
 802103e:	799b      	ldrb	r3, [r3, #6]
}
 8021040:	4618      	mov	r0, r3
 8021042:	370c      	adds	r7, #12
 8021044:	46bd      	mov	sp, r7
 8021046:	f85d 7b04 	ldr.w	r7, [sp], #4
 802104a:	4770      	bx	lr

0802104c <sm_pairing_packet_set_code>:

static inline void sm_pairing_packet_set_code(sm_pairing_packet_t packet, uint8_t code){
 802104c:	b480      	push	{r7}
 802104e:	b083      	sub	sp, #12
 8021050:	af00      	add	r7, sp, #0
 8021052:	6078      	str	r0, [r7, #4]
 8021054:	460b      	mov	r3, r1
 8021056:	70fb      	strb	r3, [r7, #3]
    packet[0] = code;
 8021058:	687b      	ldr	r3, [r7, #4]
 802105a:	78fa      	ldrb	r2, [r7, #3]
 802105c:	701a      	strb	r2, [r3, #0]
}
 802105e:	bf00      	nop
 8021060:	370c      	adds	r7, #12
 8021062:	46bd      	mov	sp, r7
 8021064:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021068:	4770      	bx	lr

0802106a <sm_pairing_packet_set_io_capability>:
static inline void sm_pairing_packet_set_io_capability(sm_pairing_packet_t packet, uint8_t io_capability){
 802106a:	b480      	push	{r7}
 802106c:	b083      	sub	sp, #12
 802106e:	af00      	add	r7, sp, #0
 8021070:	6078      	str	r0, [r7, #4]
 8021072:	460b      	mov	r3, r1
 8021074:	70fb      	strb	r3, [r7, #3]
    packet[1] = io_capability;
 8021076:	687b      	ldr	r3, [r7, #4]
 8021078:	3301      	adds	r3, #1
 802107a:	78fa      	ldrb	r2, [r7, #3]
 802107c:	701a      	strb	r2, [r3, #0]
}
 802107e:	bf00      	nop
 8021080:	370c      	adds	r7, #12
 8021082:	46bd      	mov	sp, r7
 8021084:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021088:	4770      	bx	lr

0802108a <sm_pairing_packet_set_oob_data_flag>:
static inline void sm_pairing_packet_set_oob_data_flag(sm_pairing_packet_t packet, uint8_t oob_data_flag){
 802108a:	b480      	push	{r7}
 802108c:	b083      	sub	sp, #12
 802108e:	af00      	add	r7, sp, #0
 8021090:	6078      	str	r0, [r7, #4]
 8021092:	460b      	mov	r3, r1
 8021094:	70fb      	strb	r3, [r7, #3]
    packet[2] = oob_data_flag;
 8021096:	687b      	ldr	r3, [r7, #4]
 8021098:	3302      	adds	r3, #2
 802109a:	78fa      	ldrb	r2, [r7, #3]
 802109c:	701a      	strb	r2, [r3, #0]
}
 802109e:	bf00      	nop
 80210a0:	370c      	adds	r7, #12
 80210a2:	46bd      	mov	sp, r7
 80210a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80210a8:	4770      	bx	lr

080210aa <sm_pairing_packet_set_auth_req>:
static inline void sm_pairing_packet_set_auth_req(sm_pairing_packet_t packet, uint8_t auth_req){
 80210aa:	b480      	push	{r7}
 80210ac:	b083      	sub	sp, #12
 80210ae:	af00      	add	r7, sp, #0
 80210b0:	6078      	str	r0, [r7, #4]
 80210b2:	460b      	mov	r3, r1
 80210b4:	70fb      	strb	r3, [r7, #3]
    packet[3] = auth_req;
 80210b6:	687b      	ldr	r3, [r7, #4]
 80210b8:	3303      	adds	r3, #3
 80210ba:	78fa      	ldrb	r2, [r7, #3]
 80210bc:	701a      	strb	r2, [r3, #0]
}
 80210be:	bf00      	nop
 80210c0:	370c      	adds	r7, #12
 80210c2:	46bd      	mov	sp, r7
 80210c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80210c8:	4770      	bx	lr

080210ca <sm_pairing_packet_set_max_encryption_key_size>:
static inline void sm_pairing_packet_set_max_encryption_key_size(sm_pairing_packet_t packet, uint8_t max_encryption_key_size){
 80210ca:	b480      	push	{r7}
 80210cc:	b083      	sub	sp, #12
 80210ce:	af00      	add	r7, sp, #0
 80210d0:	6078      	str	r0, [r7, #4]
 80210d2:	460b      	mov	r3, r1
 80210d4:	70fb      	strb	r3, [r7, #3]
    packet[4] = max_encryption_key_size;
 80210d6:	687b      	ldr	r3, [r7, #4]
 80210d8:	3304      	adds	r3, #4
 80210da:	78fa      	ldrb	r2, [r7, #3]
 80210dc:	701a      	strb	r2, [r3, #0]
}
 80210de:	bf00      	nop
 80210e0:	370c      	adds	r7, #12
 80210e2:	46bd      	mov	sp, r7
 80210e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80210e8:	4770      	bx	lr

080210ea <sm_pairing_packet_set_initiator_key_distribution>:
static inline void sm_pairing_packet_set_initiator_key_distribution(sm_pairing_packet_t packet, uint8_t initiator_key_distribution){
 80210ea:	b480      	push	{r7}
 80210ec:	b083      	sub	sp, #12
 80210ee:	af00      	add	r7, sp, #0
 80210f0:	6078      	str	r0, [r7, #4]
 80210f2:	460b      	mov	r3, r1
 80210f4:	70fb      	strb	r3, [r7, #3]
    packet[5] = initiator_key_distribution;
 80210f6:	687b      	ldr	r3, [r7, #4]
 80210f8:	3305      	adds	r3, #5
 80210fa:	78fa      	ldrb	r2, [r7, #3]
 80210fc:	701a      	strb	r2, [r3, #0]
}
 80210fe:	bf00      	nop
 8021100:	370c      	adds	r7, #12
 8021102:	46bd      	mov	sp, r7
 8021104:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021108:	4770      	bx	lr

0802110a <sm_pairing_packet_set_responder_key_distribution>:
static inline void sm_pairing_packet_set_responder_key_distribution(sm_pairing_packet_t packet, uint8_t responder_key_distribution){
 802110a:	b480      	push	{r7}
 802110c:	b083      	sub	sp, #12
 802110e:	af00      	add	r7, sp, #0
 8021110:	6078      	str	r0, [r7, #4]
 8021112:	460b      	mov	r3, r1
 8021114:	70fb      	strb	r3, [r7, #3]
    packet[6] = responder_key_distribution;
 8021116:	687b      	ldr	r3, [r7, #4]
 8021118:	3306      	adds	r3, #6
 802111a:	78fa      	ldrb	r2, [r7, #3]
 802111c:	701a      	strb	r2, [r3, #0]
}
 802111e:	bf00      	nop
 8021120:	370c      	adds	r7, #12
 8021122:	46bd      	mov	sp, r7
 8021124:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021128:	4770      	bx	lr

0802112a <sm_is_null>:

// @returns 1 if all bytes are 0
static bool sm_is_null(uint8_t * data, int size){
 802112a:	b480      	push	{r7}
 802112c:	b085      	sub	sp, #20
 802112e:	af00      	add	r7, sp, #0
 8021130:	6078      	str	r0, [r7, #4]
 8021132:	6039      	str	r1, [r7, #0]
    int i;
    for (i=0; i < size ; i++){
 8021134:	2300      	movs	r3, #0
 8021136:	60fb      	str	r3, [r7, #12]
 8021138:	e00a      	b.n	8021150 <sm_is_null+0x26>
        if (data[i] != 0) {
 802113a:	68fb      	ldr	r3, [r7, #12]
 802113c:	687a      	ldr	r2, [r7, #4]
 802113e:	4413      	add	r3, r2
 8021140:	781b      	ldrb	r3, [r3, #0]
 8021142:	2b00      	cmp	r3, #0
 8021144:	d001      	beq.n	802114a <sm_is_null+0x20>
            return false;
 8021146:	2300      	movs	r3, #0
 8021148:	e007      	b.n	802115a <sm_is_null+0x30>
    for (i=0; i < size ; i++){
 802114a:	68fb      	ldr	r3, [r7, #12]
 802114c:	3301      	adds	r3, #1
 802114e:	60fb      	str	r3, [r7, #12]
 8021150:	68fa      	ldr	r2, [r7, #12]
 8021152:	683b      	ldr	r3, [r7, #0]
 8021154:	429a      	cmp	r2, r3
 8021156:	dbf0      	blt.n	802113a <sm_is_null+0x10>
        }
    }
    return true;
 8021158:	2301      	movs	r3, #1
}
 802115a:	4618      	mov	r0, r3
 802115c:	3714      	adds	r7, #20
 802115e:	46bd      	mov	sp, r7
 8021160:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021164:	4770      	bx	lr

08021166 <sm_is_null_random>:

static bool sm_is_null_random(uint8_t random[8]){
 8021166:	b580      	push	{r7, lr}
 8021168:	b082      	sub	sp, #8
 802116a:	af00      	add	r7, sp, #0
 802116c:	6078      	str	r0, [r7, #4]
    return sm_is_null(random, 8);
 802116e:	2108      	movs	r1, #8
 8021170:	6878      	ldr	r0, [r7, #4]
 8021172:	f7ff ffda 	bl	802112a <sm_is_null>
 8021176:	4603      	mov	r3, r0
}
 8021178:	4618      	mov	r0, r3
 802117a:	3708      	adds	r7, #8
 802117c:	46bd      	mov	sp, r7
 802117e:	bd80      	pop	{r7, pc}

08021180 <sm_is_null_key>:

static bool sm_is_null_key(uint8_t * key){
 8021180:	b580      	push	{r7, lr}
 8021182:	b082      	sub	sp, #8
 8021184:	af00      	add	r7, sp, #0
 8021186:	6078      	str	r0, [r7, #4]
    return sm_is_null(key, 16);
 8021188:	2110      	movs	r1, #16
 802118a:	6878      	ldr	r0, [r7, #4]
 802118c:	f7ff ffcd 	bl	802112a <sm_is_null>
 8021190:	4603      	mov	r3, r0
}
 8021192:	4618      	mov	r0, r3
 8021194:	3708      	adds	r7, #8
 8021196:	46bd      	mov	sp, r7
 8021198:	bd80      	pop	{r7, pc}

0802119a <sm_run_timer_handler>:

// sm_trigger_run allows to schedule callback from main run loop // reduces stack depth
static void sm_run_timer_handler(btstack_timer_source_t * ts){
 802119a:	b580      	push	{r7, lr}
 802119c:	b082      	sub	sp, #8
 802119e:	af00      	add	r7, sp, #0
 80211a0:	6078      	str	r0, [r7, #4]
	UNUSED(ts);
	sm_run();
 80211a2:	f003 f825 	bl	80241f0 <sm_run>
}
 80211a6:	bf00      	nop
 80211a8:	3708      	adds	r7, #8
 80211aa:	46bd      	mov	sp, r7
 80211ac:	bd80      	pop	{r7, pc}
	...

080211b0 <sm_trigger_run>:
static void sm_trigger_run(void){
 80211b0:	b580      	push	{r7, lr}
 80211b2:	af00      	add	r7, sp, #0
    if (!sm_initialized) return;
 80211b4:	4b09      	ldr	r3, [pc, #36]	; (80211dc <sm_trigger_run+0x2c>)
 80211b6:	781b      	ldrb	r3, [r3, #0]
 80211b8:	f083 0301 	eor.w	r3, r3, #1
 80211bc:	b2db      	uxtb	r3, r3
 80211be:	2b00      	cmp	r3, #0
 80211c0:	d10a      	bne.n	80211d8 <sm_trigger_run+0x28>
	(void)btstack_run_loop_remove_timer(&sm_run_timer);
 80211c2:	4807      	ldr	r0, [pc, #28]	; (80211e0 <sm_trigger_run+0x30>)
 80211c4:	f7ed fd82 	bl	800eccc <btstack_run_loop_remove_timer>
	btstack_run_loop_set_timer(&sm_run_timer, 0);
 80211c8:	2100      	movs	r1, #0
 80211ca:	4805      	ldr	r0, [pc, #20]	; (80211e0 <sm_trigger_run+0x30>)
 80211cc:	f7ed fd42 	bl	800ec54 <btstack_run_loop_set_timer>
	btstack_run_loop_add_timer(&sm_run_timer);
 80211d0:	4803      	ldr	r0, [pc, #12]	; (80211e0 <sm_trigger_run+0x30>)
 80211d2:	f7ed fd6b 	bl	800ecac <btstack_run_loop_add_timer>
 80211d6:	e000      	b.n	80211da <sm_trigger_run+0x2a>
    if (!sm_initialized) return;
 80211d8:	bf00      	nop
}
 80211da:	bd80      	pop	{r7, pc}
 80211dc:	20009f40 	.word	0x20009f40
 80211e0:	2000a0fc 	.word	0x2000a0fc

080211e4 <sm_reset_tk>:

// Key utils
static void sm_reset_tk(void){
 80211e4:	b480      	push	{r7}
 80211e6:	b083      	sub	sp, #12
 80211e8:	af00      	add	r7, sp, #0
    int i;
    for (i=0;i<16;i++){
 80211ea:	2300      	movs	r3, #0
 80211ec:	607b      	str	r3, [r7, #4]
 80211ee:	e009      	b.n	8021204 <sm_reset_tk+0x20>
        setup->sm_tk[i] = 0;
 80211f0:	4b09      	ldr	r3, [pc, #36]	; (8021218 <sm_reset_tk+0x34>)
 80211f2:	681a      	ldr	r2, [r3, #0]
 80211f4:	687b      	ldr	r3, [r7, #4]
 80211f6:	4413      	add	r3, r2
 80211f8:	3317      	adds	r3, #23
 80211fa:	2200      	movs	r2, #0
 80211fc:	701a      	strb	r2, [r3, #0]
    for (i=0;i<16;i++){
 80211fe:	687b      	ldr	r3, [r7, #4]
 8021200:	3301      	adds	r3, #1
 8021202:	607b      	str	r3, [r7, #4]
 8021204:	687b      	ldr	r3, [r7, #4]
 8021206:	2b0f      	cmp	r3, #15
 8021208:	ddf2      	ble.n	80211f0 <sm_reset_tk+0xc>
    }
}
 802120a:	bf00      	nop
 802120c:	370c      	adds	r7, #12
 802120e:	46bd      	mov	sp, r7
 8021210:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021214:	4770      	bx	lr
 8021216:	bf00      	nop
 8021218:	200000a0 	.word	0x200000a0

0802121c <sm_truncate_key>:

// "For example, if a 128-bit encryption key is 0x123456789ABCDEF0123456789ABCDEF0
// and it is reduced to 7 octets (56 bits), then the resulting key is 0x0000000000000000003456789ABCDEF0.""
static void sm_truncate_key(sm_key_t key, int max_encryption_size){
 802121c:	b480      	push	{r7}
 802121e:	b085      	sub	sp, #20
 8021220:	af00      	add	r7, sp, #0
 8021222:	6078      	str	r0, [r7, #4]
 8021224:	6039      	str	r1, [r7, #0]
    int i;
    for (i = max_encryption_size ; i < 16 ; i++){
 8021226:	683b      	ldr	r3, [r7, #0]
 8021228:	60fb      	str	r3, [r7, #12]
 802122a:	e00a      	b.n	8021242 <sm_truncate_key+0x26>
        key[15-i] = 0;
 802122c:	68fb      	ldr	r3, [r7, #12]
 802122e:	f1c3 030f 	rsb	r3, r3, #15
 8021232:	461a      	mov	r2, r3
 8021234:	687b      	ldr	r3, [r7, #4]
 8021236:	4413      	add	r3, r2
 8021238:	2200      	movs	r2, #0
 802123a:	701a      	strb	r2, [r3, #0]
    for (i = max_encryption_size ; i < 16 ; i++){
 802123c:	68fb      	ldr	r3, [r7, #12]
 802123e:	3301      	adds	r3, #1
 8021240:	60fb      	str	r3, [r7, #12]
 8021242:	68fb      	ldr	r3, [r7, #12]
 8021244:	2b0f      	cmp	r3, #15
 8021246:	ddf1      	ble.n	802122c <sm_truncate_key+0x10>
    }
}
 8021248:	bf00      	nop
 802124a:	3714      	adds	r7, #20
 802124c:	46bd      	mov	sp, r7
 802124e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021252:	4770      	bx	lr

08021254 <sm_er_ir_set_default>:

// ER / IR checks
static void sm_er_ir_set_default(void){
 8021254:	b480      	push	{r7}
 8021256:	b083      	sub	sp, #12
 8021258:	af00      	add	r7, sp, #0
    int i;
    for (i=0;i<16;i++){
 802125a:	2300      	movs	r3, #0
 802125c:	607b      	str	r3, [r7, #4]
 802125e:	e014      	b.n	802128a <sm_er_ir_set_default+0x36>
        sm_persistent_er[i] = 0x30 + i;
 8021260:	687b      	ldr	r3, [r7, #4]
 8021262:	b2db      	uxtb	r3, r3
 8021264:	3330      	adds	r3, #48	; 0x30
 8021266:	b2d9      	uxtb	r1, r3
 8021268:	4a0c      	ldr	r2, [pc, #48]	; (802129c <sm_er_ir_set_default+0x48>)
 802126a:	687b      	ldr	r3, [r7, #4]
 802126c:	4413      	add	r3, r2
 802126e:	460a      	mov	r2, r1
 8021270:	701a      	strb	r2, [r3, #0]
        sm_persistent_ir[i] = 0x90 + i;
 8021272:	687b      	ldr	r3, [r7, #4]
 8021274:	b2db      	uxtb	r3, r3
 8021276:	3b70      	subs	r3, #112	; 0x70
 8021278:	b2d9      	uxtb	r1, r3
 802127a:	4a09      	ldr	r2, [pc, #36]	; (80212a0 <sm_er_ir_set_default+0x4c>)
 802127c:	687b      	ldr	r3, [r7, #4]
 802127e:	4413      	add	r3, r2
 8021280:	460a      	mov	r2, r1
 8021282:	701a      	strb	r2, [r3, #0]
    for (i=0;i<16;i++){
 8021284:	687b      	ldr	r3, [r7, #4]
 8021286:	3301      	adds	r3, #1
 8021288:	607b      	str	r3, [r7, #4]
 802128a:	687b      	ldr	r3, [r7, #4]
 802128c:	2b0f      	cmp	r3, #15
 802128e:	dde7      	ble.n	8021260 <sm_er_ir_set_default+0xc>
    }
}
 8021290:	bf00      	nop
 8021292:	370c      	adds	r7, #12
 8021294:	46bd      	mov	sp, r7
 8021296:	f85d 7b04 	ldr.w	r7, [sp], #4
 802129a:	4770      	bx	lr
 802129c:	20009f70 	.word	0x20009f70
 80212a0:	20009f80 	.word	0x20009f80

080212a4 <sm_er_is_default>:

static int sm_er_is_default(void){
 80212a4:	b480      	push	{r7}
 80212a6:	b083      	sub	sp, #12
 80212a8:	af00      	add	r7, sp, #0
    int i;
    for (i=0;i<16;i++){
 80212aa:	2300      	movs	r3, #0
 80212ac:	607b      	str	r3, [r7, #4]
 80212ae:	e00d      	b.n	80212cc <sm_er_is_default+0x28>
        if (sm_persistent_er[i] != (0x30+i)) return 0;
 80212b0:	4a0b      	ldr	r2, [pc, #44]	; (80212e0 <sm_er_is_default+0x3c>)
 80212b2:	687b      	ldr	r3, [r7, #4]
 80212b4:	4413      	add	r3, r2
 80212b6:	781b      	ldrb	r3, [r3, #0]
 80212b8:	461a      	mov	r2, r3
 80212ba:	687b      	ldr	r3, [r7, #4]
 80212bc:	3330      	adds	r3, #48	; 0x30
 80212be:	429a      	cmp	r2, r3
 80212c0:	d001      	beq.n	80212c6 <sm_er_is_default+0x22>
 80212c2:	2300      	movs	r3, #0
 80212c4:	e006      	b.n	80212d4 <sm_er_is_default+0x30>
    for (i=0;i<16;i++){
 80212c6:	687b      	ldr	r3, [r7, #4]
 80212c8:	3301      	adds	r3, #1
 80212ca:	607b      	str	r3, [r7, #4]
 80212cc:	687b      	ldr	r3, [r7, #4]
 80212ce:	2b0f      	cmp	r3, #15
 80212d0:	ddee      	ble.n	80212b0 <sm_er_is_default+0xc>
    }
    return 1;
 80212d2:	2301      	movs	r3, #1
}
 80212d4:	4618      	mov	r0, r3
 80212d6:	370c      	adds	r7, #12
 80212d8:	46bd      	mov	sp, r7
 80212da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80212de:	4770      	bx	lr
 80212e0:	20009f70 	.word	0x20009f70

080212e4 <sm_ir_is_default>:

static int sm_ir_is_default(void){
 80212e4:	b480      	push	{r7}
 80212e6:	b083      	sub	sp, #12
 80212e8:	af00      	add	r7, sp, #0
    int i;
    for (i=0;i<16;i++){
 80212ea:	2300      	movs	r3, #0
 80212ec:	607b      	str	r3, [r7, #4]
 80212ee:	e00d      	b.n	802130c <sm_ir_is_default+0x28>
        if (sm_persistent_ir[i] != (0x90+i)) return 0;
 80212f0:	4a0b      	ldr	r2, [pc, #44]	; (8021320 <sm_ir_is_default+0x3c>)
 80212f2:	687b      	ldr	r3, [r7, #4]
 80212f4:	4413      	add	r3, r2
 80212f6:	781b      	ldrb	r3, [r3, #0]
 80212f8:	461a      	mov	r2, r3
 80212fa:	687b      	ldr	r3, [r7, #4]
 80212fc:	3390      	adds	r3, #144	; 0x90
 80212fe:	429a      	cmp	r2, r3
 8021300:	d001      	beq.n	8021306 <sm_ir_is_default+0x22>
 8021302:	2300      	movs	r3, #0
 8021304:	e006      	b.n	8021314 <sm_ir_is_default+0x30>
    for (i=0;i<16;i++){
 8021306:	687b      	ldr	r3, [r7, #4]
 8021308:	3301      	adds	r3, #1
 802130a:	607b      	str	r3, [r7, #4]
 802130c:	687b      	ldr	r3, [r7, #4]
 802130e:	2b0f      	cmp	r3, #15
 8021310:	ddee      	ble.n	80212f0 <sm_ir_is_default+0xc>
    }
    return 1;
 8021312:	2301      	movs	r3, #1
}
 8021314:	4618      	mov	r0, r3
 8021316:	370c      	adds	r7, #12
 8021318:	46bd      	mov	sp, r7
 802131a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802131e:	4770      	bx	lr
 8021320:	20009f80 	.word	0x20009f80

08021324 <sm_dispatch_event>:

static void sm_dispatch_event(uint8_t packet_type, uint16_t channel, uint8_t * packet, uint16_t size){
 8021324:	b590      	push	{r4, r7, lr}
 8021326:	b089      	sub	sp, #36	; 0x24
 8021328:	af00      	add	r7, sp, #0
 802132a:	60ba      	str	r2, [r7, #8]
 802132c:	461a      	mov	r2, r3
 802132e:	4603      	mov	r3, r0
 8021330:	73fb      	strb	r3, [r7, #15]
 8021332:	460b      	mov	r3, r1
 8021334:	81bb      	strh	r3, [r7, #12]
 8021336:	4613      	mov	r3, r2
 8021338:	80fb      	strh	r3, [r7, #6]
    UNUSED(channel);

    // log event
    hci_dump_packet(packet_type, 1, packet, size);
 802133a:	88fb      	ldrh	r3, [r7, #6]
 802133c:	7bf8      	ldrb	r0, [r7, #15]
 802133e:	68ba      	ldr	r2, [r7, #8]
 8021340:	2101      	movs	r1, #1
 8021342:	f7f5 ffd7 	bl	80172f4 <hci_dump_packet>
    // dispatch to all event handlers
    btstack_linked_list_iterator_t it;
    btstack_linked_list_iterator_init(&it, &sm_event_handlers);
 8021346:	f107 0310 	add.w	r3, r7, #16
 802134a:	490f      	ldr	r1, [pc, #60]	; (8021388 <sm_dispatch_event+0x64>)
 802134c:	4618      	mov	r0, r3
 802134e:	f7ed f9fe 	bl	800e74e <btstack_linked_list_iterator_init>
    while (btstack_linked_list_iterator_has_next(&it)){
 8021352:	e00c      	b.n	802136e <sm_dispatch_event+0x4a>
        btstack_packet_callback_registration_t * entry = (btstack_packet_callback_registration_t*) btstack_linked_list_iterator_next(&it);
 8021354:	f107 0310 	add.w	r3, r7, #16
 8021358:	4618      	mov	r0, r3
 802135a:	f7ed fa3b 	bl	800e7d4 <btstack_linked_list_iterator_next>
 802135e:	61f8      	str	r0, [r7, #28]
        entry->callback(packet_type, 0, packet, size);
 8021360:	69fb      	ldr	r3, [r7, #28]
 8021362:	685c      	ldr	r4, [r3, #4]
 8021364:	88fb      	ldrh	r3, [r7, #6]
 8021366:	7bf8      	ldrb	r0, [r7, #15]
 8021368:	68ba      	ldr	r2, [r7, #8]
 802136a:	2100      	movs	r1, #0
 802136c:	47a0      	blx	r4
    while (btstack_linked_list_iterator_has_next(&it)){
 802136e:	f107 0310 	add.w	r3, r7, #16
 8021372:	4618      	mov	r0, r3
 8021374:	f7ed fa00 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8021378:	4603      	mov	r3, r0
 802137a:	2b00      	cmp	r3, #0
 802137c:	d1ea      	bne.n	8021354 <sm_dispatch_event+0x30>
    }
}
 802137e:	bf00      	nop
 8021380:	3724      	adds	r7, #36	; 0x24
 8021382:	46bd      	mov	sp, r7
 8021384:	bd90      	pop	{r4, r7, pc}
 8021386:	bf00      	nop
 8021388:	2000a0f8 	.word	0x2000a0f8

0802138c <sm_setup_event_base>:

static void sm_setup_event_base(uint8_t * event, int event_size, uint8_t type, hci_con_handle_t con_handle, uint8_t addr_type, bd_addr_t address){
 802138c:	b580      	push	{r7, lr}
 802138e:	b084      	sub	sp, #16
 8021390:	af00      	add	r7, sp, #0
 8021392:	60f8      	str	r0, [r7, #12]
 8021394:	60b9      	str	r1, [r7, #8]
 8021396:	4611      	mov	r1, r2
 8021398:	461a      	mov	r2, r3
 802139a:	460b      	mov	r3, r1
 802139c:	71fb      	strb	r3, [r7, #7]
 802139e:	4613      	mov	r3, r2
 80213a0:	80bb      	strh	r3, [r7, #4]
    event[0] = type;
 80213a2:	68fb      	ldr	r3, [r7, #12]
 80213a4:	79fa      	ldrb	r2, [r7, #7]
 80213a6:	701a      	strb	r2, [r3, #0]
    event[1] = event_size - 2;
 80213a8:	68bb      	ldr	r3, [r7, #8]
 80213aa:	b2da      	uxtb	r2, r3
 80213ac:	68fb      	ldr	r3, [r7, #12]
 80213ae:	3301      	adds	r3, #1
 80213b0:	3a02      	subs	r2, #2
 80213b2:	b2d2      	uxtb	r2, r2
 80213b4:	701a      	strb	r2, [r3, #0]
    little_endian_store_16(event, 2, con_handle);
 80213b6:	88bb      	ldrh	r3, [r7, #4]
 80213b8:	461a      	mov	r2, r3
 80213ba:	2102      	movs	r1, #2
 80213bc:	68f8      	ldr	r0, [r7, #12]
 80213be:	f7ed fd52 	bl	800ee66 <little_endian_store_16>
    event[4] = addr_type;
 80213c2:	68fb      	ldr	r3, [r7, #12]
 80213c4:	3304      	adds	r3, #4
 80213c6:	7e3a      	ldrb	r2, [r7, #24]
 80213c8:	701a      	strb	r2, [r3, #0]
    reverse_bd_addr(address, &event[5]);
 80213ca:	68fb      	ldr	r3, [r7, #12]
 80213cc:	3305      	adds	r3, #5
 80213ce:	4619      	mov	r1, r3
 80213d0:	69f8      	ldr	r0, [r7, #28]
 80213d2:	f7ed fe8e 	bl	800f0f2 <reverse_bd_addr>
}
 80213d6:	bf00      	nop
 80213d8:	3710      	adds	r7, #16
 80213da:	46bd      	mov	sp, r7
 80213dc:	bd80      	pop	{r7, pc}

080213de <sm_notify_client_base>:

static void sm_notify_client_base(uint8_t type, hci_con_handle_t con_handle, uint8_t addr_type, bd_addr_t address){
 80213de:	b580      	push	{r7, lr}
 80213e0:	b088      	sub	sp, #32
 80213e2:	af02      	add	r7, sp, #8
 80213e4:	603b      	str	r3, [r7, #0]
 80213e6:	4603      	mov	r3, r0
 80213e8:	71fb      	strb	r3, [r7, #7]
 80213ea:	460b      	mov	r3, r1
 80213ec:	80bb      	strh	r3, [r7, #4]
 80213ee:	4613      	mov	r3, r2
 80213f0:	71bb      	strb	r3, [r7, #6]
    uint8_t event[11];
    sm_setup_event_base(event, sizeof(event), type, con_handle, addr_type, address);
 80213f2:	88b9      	ldrh	r1, [r7, #4]
 80213f4:	79fa      	ldrb	r2, [r7, #7]
 80213f6:	f107 000c 	add.w	r0, r7, #12
 80213fa:	683b      	ldr	r3, [r7, #0]
 80213fc:	9301      	str	r3, [sp, #4]
 80213fe:	79bb      	ldrb	r3, [r7, #6]
 8021400:	9300      	str	r3, [sp, #0]
 8021402:	460b      	mov	r3, r1
 8021404:	210b      	movs	r1, #11
 8021406:	f7ff ffc1 	bl	802138c <sm_setup_event_base>
    sm_dispatch_event(HCI_EVENT_PACKET, 0, event, sizeof(event));
 802140a:	f107 020c 	add.w	r2, r7, #12
 802140e:	230b      	movs	r3, #11
 8021410:	2100      	movs	r1, #0
 8021412:	2004      	movs	r0, #4
 8021414:	f7ff ff86 	bl	8021324 <sm_dispatch_event>
}
 8021418:	bf00      	nop
 802141a:	3718      	adds	r7, #24
 802141c:	46bd      	mov	sp, r7
 802141e:	bd80      	pop	{r7, pc}

08021420 <sm_notify_client_passkey>:

static void sm_notify_client_passkey(uint8_t type, hci_con_handle_t con_handle, uint8_t addr_type, bd_addr_t address, uint32_t passkey){
 8021420:	b580      	push	{r7, lr}
 8021422:	b088      	sub	sp, #32
 8021424:	af02      	add	r7, sp, #8
 8021426:	603b      	str	r3, [r7, #0]
 8021428:	4603      	mov	r3, r0
 802142a:	71fb      	strb	r3, [r7, #7]
 802142c:	460b      	mov	r3, r1
 802142e:	80bb      	strh	r3, [r7, #4]
 8021430:	4613      	mov	r3, r2
 8021432:	71bb      	strb	r3, [r7, #6]
    uint8_t event[15];
    sm_setup_event_base(event, sizeof(event), type, con_handle, addr_type, address);
 8021434:	88b9      	ldrh	r1, [r7, #4]
 8021436:	79fa      	ldrb	r2, [r7, #7]
 8021438:	f107 0008 	add.w	r0, r7, #8
 802143c:	683b      	ldr	r3, [r7, #0]
 802143e:	9301      	str	r3, [sp, #4]
 8021440:	79bb      	ldrb	r3, [r7, #6]
 8021442:	9300      	str	r3, [sp, #0]
 8021444:	460b      	mov	r3, r1
 8021446:	210f      	movs	r1, #15
 8021448:	f7ff ffa0 	bl	802138c <sm_setup_event_base>
    little_endian_store_32(event, 11, passkey);
 802144c:	f107 0308 	add.w	r3, r7, #8
 8021450:	6a3a      	ldr	r2, [r7, #32]
 8021452:	210b      	movs	r1, #11
 8021454:	4618      	mov	r0, r3
 8021456:	f7ed fd28 	bl	800eeaa <little_endian_store_32>
    sm_dispatch_event(HCI_EVENT_PACKET, 0, event, sizeof(event));
 802145a:	f107 0208 	add.w	r2, r7, #8
 802145e:	230f      	movs	r3, #15
 8021460:	2100      	movs	r1, #0
 8021462:	2004      	movs	r0, #4
 8021464:	f7ff ff5e 	bl	8021324 <sm_dispatch_event>
}
 8021468:	bf00      	nop
 802146a:	3718      	adds	r7, #24
 802146c:	46bd      	mov	sp, r7
 802146e:	bd80      	pop	{r7, pc}

08021470 <sm_notify_client_index>:

static void sm_notify_client_index(uint8_t type, hci_con_handle_t con_handle, uint8_t addr_type, bd_addr_t address, uint16_t index){
 8021470:	b580      	push	{r7, lr}
 8021472:	b08c      	sub	sp, #48	; 0x30
 8021474:	af02      	add	r7, sp, #8
 8021476:	603b      	str	r3, [r7, #0]
 8021478:	4603      	mov	r3, r0
 802147a:	71fb      	strb	r3, [r7, #7]
 802147c:	460b      	mov	r3, r1
 802147e:	80bb      	strh	r3, [r7, #4]
 8021480:	4613      	mov	r3, r2
 8021482:	71bb      	strb	r3, [r7, #6]
    // fetch addr and addr type from db, only called for valid entries
    bd_addr_t identity_address;
    int identity_address_type;
    le_device_db_info(index, &identity_address_type, identity_address, NULL);
 8021484:	8e38      	ldrh	r0, [r7, #48]	; 0x30
 8021486:	f107 0220 	add.w	r2, r7, #32
 802148a:	f107 011c 	add.w	r1, r7, #28
 802148e:	2300      	movs	r3, #0
 8021490:	f7ff fc06 	bl	8020ca0 <le_device_db_info>

    uint8_t event[20];
    sm_setup_event_base(event, sizeof(event), type, con_handle, addr_type, address);
 8021494:	88b9      	ldrh	r1, [r7, #4]
 8021496:	79fa      	ldrb	r2, [r7, #7]
 8021498:	f107 0008 	add.w	r0, r7, #8
 802149c:	683b      	ldr	r3, [r7, #0]
 802149e:	9301      	str	r3, [sp, #4]
 80214a0:	79bb      	ldrb	r3, [r7, #6]
 80214a2:	9300      	str	r3, [sp, #0]
 80214a4:	460b      	mov	r3, r1
 80214a6:	2114      	movs	r1, #20
 80214a8:	f7ff ff70 	bl	802138c <sm_setup_event_base>
    event[11] = identity_address_type;
 80214ac:	69fb      	ldr	r3, [r7, #28]
 80214ae:	b2db      	uxtb	r3, r3
 80214b0:	74fb      	strb	r3, [r7, #19]
    reverse_bd_addr(identity_address, &event[12]);
 80214b2:	f107 0308 	add.w	r3, r7, #8
 80214b6:	f103 020c 	add.w	r2, r3, #12
 80214ba:	f107 0320 	add.w	r3, r7, #32
 80214be:	4611      	mov	r1, r2
 80214c0:	4618      	mov	r0, r3
 80214c2:	f7ed fe16 	bl	800f0f2 <reverse_bd_addr>
    little_endian_store_16(event, 18, index);
 80214c6:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 80214c8:	f107 0308 	add.w	r3, r7, #8
 80214cc:	2112      	movs	r1, #18
 80214ce:	4618      	mov	r0, r3
 80214d0:	f7ed fcc9 	bl	800ee66 <little_endian_store_16>
    sm_dispatch_event(HCI_EVENT_PACKET, 0, event, sizeof(event));
 80214d4:	f107 0208 	add.w	r2, r7, #8
 80214d8:	2314      	movs	r3, #20
 80214da:	2100      	movs	r1, #0
 80214dc:	2004      	movs	r0, #4
 80214de:	f7ff ff21 	bl	8021324 <sm_dispatch_event>
}
 80214e2:	bf00      	nop
 80214e4:	3728      	adds	r7, #40	; 0x28
 80214e6:	46bd      	mov	sp, r7
 80214e8:	bd80      	pop	{r7, pc}

080214ea <sm_notify_client_status>:

static void sm_notify_client_status(uint8_t type, hci_con_handle_t con_handle, uint8_t addr_type, bd_addr_t address, uint8_t status){
 80214ea:	b580      	push	{r7, lr}
 80214ec:	b088      	sub	sp, #32
 80214ee:	af02      	add	r7, sp, #8
 80214f0:	603b      	str	r3, [r7, #0]
 80214f2:	4603      	mov	r3, r0
 80214f4:	71fb      	strb	r3, [r7, #7]
 80214f6:	460b      	mov	r3, r1
 80214f8:	80bb      	strh	r3, [r7, #4]
 80214fa:	4613      	mov	r3, r2
 80214fc:	71bb      	strb	r3, [r7, #6]
    uint8_t event[12];
    sm_setup_event_base(event, sizeof(event), type, con_handle, addr_type, address);
 80214fe:	88b9      	ldrh	r1, [r7, #4]
 8021500:	79fa      	ldrb	r2, [r7, #7]
 8021502:	f107 000c 	add.w	r0, r7, #12
 8021506:	683b      	ldr	r3, [r7, #0]
 8021508:	9301      	str	r3, [sp, #4]
 802150a:	79bb      	ldrb	r3, [r7, #6]
 802150c:	9300      	str	r3, [sp, #0]
 802150e:	460b      	mov	r3, r1
 8021510:	210c      	movs	r1, #12
 8021512:	f7ff ff3b 	bl	802138c <sm_setup_event_base>
    event[11] = status;
 8021516:	f897 3020 	ldrb.w	r3, [r7, #32]
 802151a:	75fb      	strb	r3, [r7, #23]
    sm_dispatch_event(HCI_EVENT_PACKET, 0, (uint8_t*) &event, sizeof(event));
 802151c:	f107 020c 	add.w	r2, r7, #12
 8021520:	230c      	movs	r3, #12
 8021522:	2100      	movs	r1, #0
 8021524:	2004      	movs	r0, #4
 8021526:	f7ff fefd 	bl	8021324 <sm_dispatch_event>
}
 802152a:	bf00      	nop
 802152c:	3718      	adds	r7, #24
 802152e:	46bd      	mov	sp, r7
 8021530:	bd80      	pop	{r7, pc}

08021532 <sm_reencryption_started>:


static void sm_reencryption_started(sm_connection_t * sm_conn){
 8021532:	b580      	push	{r7, lr}
 8021534:	b086      	sub	sp, #24
 8021536:	af00      	add	r7, sp, #0
 8021538:	6078      	str	r0, [r7, #4]

    if (sm_conn->sm_reencryption_active) return;
 802153a:	687b      	ldr	r3, [r7, #4]
 802153c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8021540:	2b00      	cmp	r3, #0
 8021542:	d126      	bne.n	8021592 <sm_reencryption_started+0x60>

    sm_conn->sm_reencryption_active = true;
 8021544:	687b      	ldr	r3, [r7, #4]
 8021546:	2201      	movs	r2, #1
 8021548:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29

    int       identity_addr_type;
    bd_addr_t identity_addr;
    if (sm_conn->sm_le_db_index >= 0){
 802154c:	687b      	ldr	r3, [r7, #4]
 802154e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8021550:	2b00      	cmp	r3, #0
 8021552:	db09      	blt.n	8021568 <sm_reencryption_started+0x36>
        // fetch addr and addr type from db, only called for valid entries
        le_device_db_info(sm_conn->sm_le_db_index, &identity_addr_type, identity_addr, NULL);
 8021554:	687b      	ldr	r3, [r7, #4]
 8021556:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8021558:	f107 020c 	add.w	r2, r7, #12
 802155c:	f107 0114 	add.w	r1, r7, #20
 8021560:	2300      	movs	r3, #0
 8021562:	f7ff fb9d 	bl	8020ca0 <le_device_db_info>
 8021566:	e00a      	b.n	802157e <sm_reencryption_started+0x4c>
    } else {
        // for legacy pairing with LTK re-construction, use current peer addr
        identity_addr_type = sm_conn->sm_peer_addr_type;
 8021568:	687b      	ldr	r3, [r7, #4]
 802156a:	795b      	ldrb	r3, [r3, #5]
 802156c:	617b      	str	r3, [r7, #20]
        memcpy(identity_addr, sm_conn->sm_peer_address, 6);
 802156e:	687b      	ldr	r3, [r7, #4]
 8021570:	1d9a      	adds	r2, r3, #6
 8021572:	f107 030c 	add.w	r3, r7, #12
 8021576:	6810      	ldr	r0, [r2, #0]
 8021578:	6018      	str	r0, [r3, #0]
 802157a:	8892      	ldrh	r2, [r2, #4]
 802157c:	809a      	strh	r2, [r3, #4]
    }

    sm_notify_client_base(SM_EVENT_REENCRYPTION_STARTED, sm_conn->sm_handle, identity_addr_type, identity_addr);
 802157e:	687b      	ldr	r3, [r7, #4]
 8021580:	8819      	ldrh	r1, [r3, #0]
 8021582:	697b      	ldr	r3, [r7, #20]
 8021584:	b2da      	uxtb	r2, r3
 8021586:	f107 030c 	add.w	r3, r7, #12
 802158a:	20de      	movs	r0, #222	; 0xde
 802158c:	f7ff ff27 	bl	80213de <sm_notify_client_base>
 8021590:	e000      	b.n	8021594 <sm_reencryption_started+0x62>
    if (sm_conn->sm_reencryption_active) return;
 8021592:	bf00      	nop
}
 8021594:	3718      	adds	r7, #24
 8021596:	46bd      	mov	sp, r7
 8021598:	bd80      	pop	{r7, pc}

0802159a <sm_reencryption_complete>:

static void sm_reencryption_complete(sm_connection_t * sm_conn, uint8_t status){
 802159a:	b580      	push	{r7, lr}
 802159c:	b088      	sub	sp, #32
 802159e:	af02      	add	r7, sp, #8
 80215a0:	6078      	str	r0, [r7, #4]
 80215a2:	460b      	mov	r3, r1
 80215a4:	70fb      	strb	r3, [r7, #3]

    if (!sm_conn->sm_reencryption_active) return;
 80215a6:	687b      	ldr	r3, [r7, #4]
 80215a8:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 80215ac:	f083 0301 	eor.w	r3, r3, #1
 80215b0:	b2db      	uxtb	r3, r3
 80215b2:	2b00      	cmp	r3, #0
 80215b4:	d129      	bne.n	802160a <sm_reencryption_complete+0x70>

    sm_conn->sm_reencryption_active = false;
 80215b6:	687b      	ldr	r3, [r7, #4]
 80215b8:	2200      	movs	r2, #0
 80215ba:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29

    int       identity_addr_type;
    bd_addr_t identity_addr;
    if (sm_conn->sm_le_db_index >= 0){
 80215be:	687b      	ldr	r3, [r7, #4]
 80215c0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80215c2:	2b00      	cmp	r3, #0
 80215c4:	db09      	blt.n	80215da <sm_reencryption_complete+0x40>
        // fetch addr and addr type from db, only called for valid entries
        le_device_db_info(sm_conn->sm_le_db_index, &identity_addr_type, identity_addr, NULL);
 80215c6:	687b      	ldr	r3, [r7, #4]
 80215c8:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80215ca:	f107 020c 	add.w	r2, r7, #12
 80215ce:	f107 0114 	add.w	r1, r7, #20
 80215d2:	2300      	movs	r3, #0
 80215d4:	f7ff fb64 	bl	8020ca0 <le_device_db_info>
 80215d8:	e00a      	b.n	80215f0 <sm_reencryption_complete+0x56>
    } else {
        // for legacy pairing with LTK re-construction, use current peer addr
        identity_addr_type = sm_conn->sm_peer_addr_type;
 80215da:	687b      	ldr	r3, [r7, #4]
 80215dc:	795b      	ldrb	r3, [r3, #5]
 80215de:	617b      	str	r3, [r7, #20]
        memcpy(identity_addr, sm_conn->sm_peer_address, 6);
 80215e0:	687b      	ldr	r3, [r7, #4]
 80215e2:	1d9a      	adds	r2, r3, #6
 80215e4:	f107 030c 	add.w	r3, r7, #12
 80215e8:	6810      	ldr	r0, [r2, #0]
 80215ea:	6018      	str	r0, [r3, #0]
 80215ec:	8892      	ldrh	r2, [r2, #4]
 80215ee:	809a      	strh	r2, [r3, #4]
    }

    sm_notify_client_status(SM_EVENT_REENCRYPTION_COMPLETE, sm_conn->sm_handle, identity_addr_type, identity_addr, status);
 80215f0:	687b      	ldr	r3, [r7, #4]
 80215f2:	8819      	ldrh	r1, [r3, #0]
 80215f4:	697b      	ldr	r3, [r7, #20]
 80215f6:	b2da      	uxtb	r2, r3
 80215f8:	f107 000c 	add.w	r0, r7, #12
 80215fc:	78fb      	ldrb	r3, [r7, #3]
 80215fe:	9300      	str	r3, [sp, #0]
 8021600:	4603      	mov	r3, r0
 8021602:	20df      	movs	r0, #223	; 0xdf
 8021604:	f7ff ff71 	bl	80214ea <sm_notify_client_status>
 8021608:	e000      	b.n	802160c <sm_reencryption_complete+0x72>
    if (!sm_conn->sm_reencryption_active) return;
 802160a:	bf00      	nop
}
 802160c:	3718      	adds	r7, #24
 802160e:	46bd      	mov	sp, r7
 8021610:	bd80      	pop	{r7, pc}
	...

08021614 <sm_pairing_started>:

static void sm_pairing_started(sm_connection_t * sm_conn){
 8021614:	b580      	push	{r7, lr}
 8021616:	b088      	sub	sp, #32
 8021618:	af02      	add	r7, sp, #8
 802161a:	6078      	str	r0, [r7, #4]

    if (sm_conn->sm_pairing_active) return;
 802161c:	687b      	ldr	r3, [r7, #4]
 802161e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8021622:	2b00      	cmp	r3, #0
 8021624:	d11e      	bne.n	8021664 <sm_pairing_started+0x50>

    sm_conn->sm_pairing_active = true;
 8021626:	687b      	ldr	r3, [r7, #4]
 8021628:	2201      	movs	r2, #1
 802162a:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28

    uint8_t event[11];
    sm_setup_event_base(event, sizeof(event), SM_EVENT_PAIRING_STARTED, sm_conn->sm_handle, setup->sm_peer_addr_type, setup->sm_peer_address);
 802162e:	687b      	ldr	r3, [r7, #4]
 8021630:	8819      	ldrh	r1, [r3, #0]
 8021632:	4b0e      	ldr	r3, [pc, #56]	; (802166c <sm_pairing_started+0x58>)
 8021634:	681b      	ldr	r3, [r3, #0]
 8021636:	f893 3204 	ldrb.w	r3, [r3, #516]	; 0x204
 802163a:	4a0c      	ldr	r2, [pc, #48]	; (802166c <sm_pairing_started+0x58>)
 802163c:	6812      	ldr	r2, [r2, #0]
 802163e:	f202 2205 	addw	r2, r2, #517	; 0x205
 8021642:	f107 000c 	add.w	r0, r7, #12
 8021646:	9201      	str	r2, [sp, #4]
 8021648:	9300      	str	r3, [sp, #0]
 802164a:	460b      	mov	r3, r1
 802164c:	22dc      	movs	r2, #220	; 0xdc
 802164e:	210b      	movs	r1, #11
 8021650:	f7ff fe9c 	bl	802138c <sm_setup_event_base>
    sm_dispatch_event(HCI_EVENT_PACKET, 0, (uint8_t*) &event, sizeof(event));
 8021654:	f107 020c 	add.w	r2, r7, #12
 8021658:	230b      	movs	r3, #11
 802165a:	2100      	movs	r1, #0
 802165c:	2004      	movs	r0, #4
 802165e:	f7ff fe61 	bl	8021324 <sm_dispatch_event>
 8021662:	e000      	b.n	8021666 <sm_pairing_started+0x52>
    if (sm_conn->sm_pairing_active) return;
 8021664:	bf00      	nop
}
 8021666:	3718      	adds	r7, #24
 8021668:	46bd      	mov	sp, r7
 802166a:	bd80      	pop	{r7, pc}
 802166c:	200000a0 	.word	0x200000a0

08021670 <sm_pairing_complete>:

static void sm_pairing_complete(sm_connection_t * sm_conn, uint8_t status, uint8_t reason){
 8021670:	b580      	push	{r7, lr}
 8021672:	b088      	sub	sp, #32
 8021674:	af02      	add	r7, sp, #8
 8021676:	6078      	str	r0, [r7, #4]
 8021678:	460b      	mov	r3, r1
 802167a:	70fb      	strb	r3, [r7, #3]
 802167c:	4613      	mov	r3, r2
 802167e:	70bb      	strb	r3, [r7, #2]

    if (!sm_conn->sm_pairing_active) return;
 8021680:	687b      	ldr	r3, [r7, #4]
 8021682:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8021686:	f083 0301 	eor.w	r3, r3, #1
 802168a:	b2db      	uxtb	r3, r3
 802168c:	2b00      	cmp	r3, #0
 802168e:	d11e      	bne.n	80216ce <sm_pairing_complete+0x5e>

    uint8_t event[13];
    sm_setup_event_base(event, sizeof(event), SM_EVENT_PAIRING_COMPLETE, sm_conn->sm_handle, setup->sm_peer_addr_type, setup->sm_peer_address);
 8021690:	687b      	ldr	r3, [r7, #4]
 8021692:	8819      	ldrh	r1, [r3, #0]
 8021694:	4b10      	ldr	r3, [pc, #64]	; (80216d8 <sm_pairing_complete+0x68>)
 8021696:	681b      	ldr	r3, [r3, #0]
 8021698:	f893 3204 	ldrb.w	r3, [r3, #516]	; 0x204
 802169c:	4a0e      	ldr	r2, [pc, #56]	; (80216d8 <sm_pairing_complete+0x68>)
 802169e:	6812      	ldr	r2, [r2, #0]
 80216a0:	f202 2205 	addw	r2, r2, #517	; 0x205
 80216a4:	f107 0008 	add.w	r0, r7, #8
 80216a8:	9201      	str	r2, [sp, #4]
 80216aa:	9300      	str	r3, [sp, #0]
 80216ac:	460b      	mov	r3, r1
 80216ae:	22dd      	movs	r2, #221	; 0xdd
 80216b0:	210d      	movs	r1, #13
 80216b2:	f7ff fe6b 	bl	802138c <sm_setup_event_base>
    event[11] = status;
 80216b6:	78fb      	ldrb	r3, [r7, #3]
 80216b8:	74fb      	strb	r3, [r7, #19]
    event[12] = reason;
 80216ba:	78bb      	ldrb	r3, [r7, #2]
 80216bc:	753b      	strb	r3, [r7, #20]
    sm_dispatch_event(HCI_EVENT_PACKET, 0, (uint8_t*) &event, sizeof(event));
 80216be:	f107 0208 	add.w	r2, r7, #8
 80216c2:	230d      	movs	r3, #13
 80216c4:	2100      	movs	r1, #0
 80216c6:	2004      	movs	r0, #4
 80216c8:	f7ff fe2c 	bl	8021324 <sm_dispatch_event>
 80216cc:	e000      	b.n	80216d0 <sm_pairing_complete+0x60>
    if (!sm_conn->sm_pairing_active) return;
 80216ce:	bf00      	nop
}
 80216d0:	3718      	adds	r7, #24
 80216d2:	46bd      	mov	sp, r7
 80216d4:	bd80      	pop	{r7, pc}
 80216d6:	bf00      	nop
 80216d8:	200000a0 	.word	0x200000a0

080216dc <sm_timeout_handler>:
// If the Security Manager Timer reaches 30 seconds, the procedure shall be considered to have failed,
// and the local higher layer shall be notified. No further SMP commands shall be sent over the L2CAP
// Security Manager Channel. A new SM procedure shall only be performed when a new physical link has been
// established.

static void sm_timeout_handler(btstack_timer_source_t * timer){
 80216dc:	b580      	push	{r7, lr}
 80216de:	b084      	sub	sp, #16
 80216e0:	af00      	add	r7, sp, #0
 80216e2:	6078      	str	r0, [r7, #4]
    log_info("SM timeout");
 80216e4:	f240 23a2 	movw	r3, #674	; 0x2a2
 80216e8:	4a0f      	ldr	r2, [pc, #60]	; (8021728 <sm_timeout_handler+0x4c>)
 80216ea:	4910      	ldr	r1, [pc, #64]	; (802172c <sm_timeout_handler+0x50>)
 80216ec:	2001      	movs	r0, #1
 80216ee:	f7f5 fea7 	bl	8017440 <hci_dump_log>
    sm_connection_t * sm_conn = (sm_connection_t*) btstack_run_loop_get_timer_context(timer);
 80216f2:	6878      	ldr	r0, [r7, #4]
 80216f4:	f7ed face 	bl	800ec94 <btstack_run_loop_get_timer_context>
 80216f8:	60f8      	str	r0, [r7, #12]
    sm_conn->sm_engine_state = SM_GENERAL_TIMEOUT;
 80216fa:	68fb      	ldr	r3, [r7, #12]
 80216fc:	2202      	movs	r2, #2
 80216fe:	731a      	strb	r2, [r3, #12]
    sm_reencryption_complete(sm_conn, ERROR_CODE_CONNECTION_TIMEOUT);
 8021700:	2108      	movs	r1, #8
 8021702:	68f8      	ldr	r0, [r7, #12]
 8021704:	f7ff ff49 	bl	802159a <sm_reencryption_complete>
    sm_pairing_complete(sm_conn, ERROR_CODE_CONNECTION_TIMEOUT, 0);
 8021708:	2200      	movs	r2, #0
 802170a:	2108      	movs	r1, #8
 802170c:	68f8      	ldr	r0, [r7, #12]
 802170e:	f7ff ffaf 	bl	8021670 <sm_pairing_complete>
    sm_done_for_handle(sm_conn->sm_handle);
 8021712:	68fb      	ldr	r3, [r7, #12]
 8021714:	881b      	ldrh	r3, [r3, #0]
 8021716:	4618      	mov	r0, r3
 8021718:	f000 fc6c 	bl	8021ff4 <sm_done_for_handle>

    // trigger handling of next ready connection
    sm_run();
 802171c:	f002 fd68 	bl	80241f0 <sm_run>
}
 8021720:	bf00      	nop
 8021722:	3710      	adds	r7, #16
 8021724:	46bd      	mov	sp, r7
 8021726:	bd80      	pop	{r7, pc}
 8021728:	0802d4a8 	.word	0x0802d4a8
 802172c:	0802d4c4 	.word	0x0802d4c4

08021730 <sm_timeout_start>:
static void sm_timeout_start(sm_connection_t * sm_conn){
 8021730:	b580      	push	{r7, lr}
 8021732:	b082      	sub	sp, #8
 8021734:	af00      	add	r7, sp, #0
 8021736:	6078      	str	r0, [r7, #4]
    btstack_run_loop_remove_timer(&setup->sm_timeout);
 8021738:	4b10      	ldr	r3, [pc, #64]	; (802177c <sm_timeout_start+0x4c>)
 802173a:	681b      	ldr	r3, [r3, #0]
 802173c:	4618      	mov	r0, r3
 802173e:	f7ed fac5 	bl	800eccc <btstack_run_loop_remove_timer>
    btstack_run_loop_set_timer_context(&setup->sm_timeout, sm_conn);
 8021742:	4b0e      	ldr	r3, [pc, #56]	; (802177c <sm_timeout_start+0x4c>)
 8021744:	681b      	ldr	r3, [r3, #0]
 8021746:	6879      	ldr	r1, [r7, #4]
 8021748:	4618      	mov	r0, r3
 802174a:	f7ed fa95 	bl	800ec78 <btstack_run_loop_set_timer_context>
    btstack_run_loop_set_timer_handler(&setup->sm_timeout, sm_timeout_handler);
 802174e:	4b0b      	ldr	r3, [pc, #44]	; (802177c <sm_timeout_start+0x4c>)
 8021750:	681b      	ldr	r3, [r3, #0]
 8021752:	490b      	ldr	r1, [pc, #44]	; (8021780 <sm_timeout_start+0x50>)
 8021754:	4618      	mov	r0, r3
 8021756:	f7ed fa19 	bl	800eb8c <btstack_run_loop_set_timer_handler>
    btstack_run_loop_set_timer(&setup->sm_timeout, 30000); // 30 seconds sm timeout
 802175a:	4b08      	ldr	r3, [pc, #32]	; (802177c <sm_timeout_start+0x4c>)
 802175c:	681b      	ldr	r3, [r3, #0]
 802175e:	f247 5130 	movw	r1, #30000	; 0x7530
 8021762:	4618      	mov	r0, r3
 8021764:	f7ed fa76 	bl	800ec54 <btstack_run_loop_set_timer>
    btstack_run_loop_add_timer(&setup->sm_timeout);
 8021768:	4b04      	ldr	r3, [pc, #16]	; (802177c <sm_timeout_start+0x4c>)
 802176a:	681b      	ldr	r3, [r3, #0]
 802176c:	4618      	mov	r0, r3
 802176e:	f7ed fa9d 	bl	800ecac <btstack_run_loop_add_timer>
}
 8021772:	bf00      	nop
 8021774:	3708      	adds	r7, #8
 8021776:	46bd      	mov	sp, r7
 8021778:	bd80      	pop	{r7, pc}
 802177a:	bf00      	nop
 802177c:	200000a0 	.word	0x200000a0
 8021780:	080216dd 	.word	0x080216dd

08021784 <sm_timeout_stop>:
static void sm_timeout_stop(void){
 8021784:	b580      	push	{r7, lr}
 8021786:	af00      	add	r7, sp, #0
    btstack_run_loop_remove_timer(&setup->sm_timeout);
 8021788:	4b03      	ldr	r3, [pc, #12]	; (8021798 <sm_timeout_stop+0x14>)
 802178a:	681b      	ldr	r3, [r3, #0]
 802178c:	4618      	mov	r0, r3
 802178e:	f7ed fa9d 	bl	800eccc <btstack_run_loop_remove_timer>
}
 8021792:	bf00      	nop
 8021794:	bd80      	pop	{r7, pc}
 8021796:	bf00      	nop
 8021798:	200000a0 	.word	0x200000a0

0802179c <sm_timeout_reset>:
static void sm_timeout_reset(sm_connection_t * sm_conn){
 802179c:	b580      	push	{r7, lr}
 802179e:	b082      	sub	sp, #8
 80217a0:	af00      	add	r7, sp, #0
 80217a2:	6078      	str	r0, [r7, #4]
    sm_timeout_stop();
 80217a4:	f7ff ffee 	bl	8021784 <sm_timeout_stop>
    sm_timeout_start(sm_conn);
 80217a8:	6878      	ldr	r0, [r7, #4]
 80217aa:	f7ff ffc1 	bl	8021730 <sm_timeout_start>
}
 80217ae:	bf00      	nop
 80217b0:	3708      	adds	r7, #8
 80217b2:	46bd      	mov	sp, r7
 80217b4:	bd80      	pop	{r7, pc}
	...

080217b8 <gap_random_address_trigger>:
// GAP Random Address updates
static gap_random_address_type_t gap_random_adress_type;
static btstack_timer_source_t gap_random_address_update_timer;
static uint32_t gap_random_adress_update_period;

static void gap_random_address_trigger(void){
 80217b8:	b580      	push	{r7, lr}
 80217ba:	b082      	sub	sp, #8
 80217bc:	af02      	add	r7, sp, #8
    log_info("gap_random_address_trigger, state %u", rau_state);
 80217be:	4b0b      	ldr	r3, [pc, #44]	; (80217ec <gap_random_address_trigger+0x34>)
 80217c0:	781b      	ldrb	r3, [r3, #0]
 80217c2:	9300      	str	r3, [sp, #0]
 80217c4:	f240 23c3 	movw	r3, #707	; 0x2c3
 80217c8:	4a09      	ldr	r2, [pc, #36]	; (80217f0 <gap_random_address_trigger+0x38>)
 80217ca:	490a      	ldr	r1, [pc, #40]	; (80217f4 <gap_random_address_trigger+0x3c>)
 80217cc:	2001      	movs	r0, #1
 80217ce:	f7f5 fe37 	bl	8017440 <hci_dump_log>
    if (rau_state != RAU_IDLE) return;
 80217d2:	4b06      	ldr	r3, [pc, #24]	; (80217ec <gap_random_address_trigger+0x34>)
 80217d4:	781b      	ldrb	r3, [r3, #0]
 80217d6:	2b00      	cmp	r3, #0
 80217d8:	d105      	bne.n	80217e6 <gap_random_address_trigger+0x2e>
    rau_state = RAU_GET_RANDOM;
 80217da:	4b04      	ldr	r3, [pc, #16]	; (80217ec <gap_random_address_trigger+0x34>)
 80217dc:	2201      	movs	r2, #1
 80217de:	701a      	strb	r2, [r3, #0]
    sm_trigger_run();
 80217e0:	f7ff fce6 	bl	80211b0 <sm_trigger_run>
 80217e4:	e000      	b.n	80217e8 <gap_random_address_trigger+0x30>
    if (rau_state != RAU_IDLE) return;
 80217e6:	bf00      	nop
}
 80217e8:	46bd      	mov	sp, r7
 80217ea:	bd80      	pop	{r7, pc}
 80217ec:	20009fb1 	.word	0x20009fb1
 80217f0:	0802d4a8 	.word	0x0802d4a8
 80217f4:	0802d4d8 	.word	0x0802d4d8

080217f8 <gap_random_address_update_handler>:

static void gap_random_address_update_handler(btstack_timer_source_t * timer){
 80217f8:	b580      	push	{r7, lr}
 80217fa:	b082      	sub	sp, #8
 80217fc:	af00      	add	r7, sp, #0
 80217fe:	6078      	str	r0, [r7, #4]
    UNUSED(timer);

    log_info("GAP Random Address Update due");
 8021800:	f44f 7333 	mov.w	r3, #716	; 0x2cc
 8021804:	4a09      	ldr	r2, [pc, #36]	; (802182c <gap_random_address_update_handler+0x34>)
 8021806:	490a      	ldr	r1, [pc, #40]	; (8021830 <gap_random_address_update_handler+0x38>)
 8021808:	2001      	movs	r0, #1
 802180a:	f7f5 fe19 	bl	8017440 <hci_dump_log>
    btstack_run_loop_set_timer(&gap_random_address_update_timer, gap_random_adress_update_period);
 802180e:	4b09      	ldr	r3, [pc, #36]	; (8021834 <gap_random_address_update_handler+0x3c>)
 8021810:	681b      	ldr	r3, [r3, #0]
 8021812:	4619      	mov	r1, r3
 8021814:	4808      	ldr	r0, [pc, #32]	; (8021838 <gap_random_address_update_handler+0x40>)
 8021816:	f7ed fa1d 	bl	800ec54 <btstack_run_loop_set_timer>
    btstack_run_loop_add_timer(&gap_random_address_update_timer);
 802181a:	4807      	ldr	r0, [pc, #28]	; (8021838 <gap_random_address_update_handler+0x40>)
 802181c:	f7ed fa46 	bl	800ecac <btstack_run_loop_add_timer>
    gap_random_address_trigger();
 8021820:	f7ff ffca 	bl	80217b8 <gap_random_address_trigger>
}
 8021824:	bf00      	nop
 8021826:	3708      	adds	r7, #8
 8021828:	46bd      	mov	sp, r7
 802182a:	bd80      	pop	{r7, pc}
 802182c:	0802d4a8 	.word	0x0802d4a8
 8021830:	0802d504 	.word	0x0802d504
 8021834:	2000a378 	.word	0x2000a378
 8021838:	2000a368 	.word	0x2000a368

0802183c <gap_random_address_update_start>:

static void gap_random_address_update_start(void){
 802183c:	b580      	push	{r7, lr}
 802183e:	af00      	add	r7, sp, #0
    btstack_run_loop_set_timer_handler(&gap_random_address_update_timer, gap_random_address_update_handler);
 8021840:	4907      	ldr	r1, [pc, #28]	; (8021860 <gap_random_address_update_start+0x24>)
 8021842:	4808      	ldr	r0, [pc, #32]	; (8021864 <gap_random_address_update_start+0x28>)
 8021844:	f7ed f9a2 	bl	800eb8c <btstack_run_loop_set_timer_handler>
    btstack_run_loop_set_timer(&gap_random_address_update_timer, gap_random_adress_update_period);
 8021848:	4b07      	ldr	r3, [pc, #28]	; (8021868 <gap_random_address_update_start+0x2c>)
 802184a:	681b      	ldr	r3, [r3, #0]
 802184c:	4619      	mov	r1, r3
 802184e:	4805      	ldr	r0, [pc, #20]	; (8021864 <gap_random_address_update_start+0x28>)
 8021850:	f7ed fa00 	bl	800ec54 <btstack_run_loop_set_timer>
    btstack_run_loop_add_timer(&gap_random_address_update_timer);
 8021854:	4803      	ldr	r0, [pc, #12]	; (8021864 <gap_random_address_update_start+0x28>)
 8021856:	f7ed fa29 	bl	800ecac <btstack_run_loop_add_timer>
}
 802185a:	bf00      	nop
 802185c:	bd80      	pop	{r7, pc}
 802185e:	bf00      	nop
 8021860:	080217f9 	.word	0x080217f9
 8021864:	2000a368 	.word	0x2000a368
 8021868:	2000a378 	.word	0x2000a378

0802186c <gap_random_address_update_stop>:

static void gap_random_address_update_stop(void){
 802186c:	b580      	push	{r7, lr}
 802186e:	af00      	add	r7, sp, #0
    btstack_run_loop_remove_timer(&gap_random_address_update_timer);
 8021870:	4802      	ldr	r0, [pc, #8]	; (802187c <gap_random_address_update_stop+0x10>)
 8021872:	f7ed fa2b 	bl	800eccc <btstack_run_loop_remove_timer>
}
 8021876:	bf00      	nop
 8021878:	bd80      	pop	{r7, pc}
 802187a:	bf00      	nop
 802187c:	2000a368 	.word	0x2000a368

08021880 <sm_ah_r_prime>:

// ah(k,r) helper
// r = padding || r
// r - 24 bit value
static void sm_ah_r_prime(uint8_t r[3], uint8_t * r_prime){
 8021880:	b580      	push	{r7, lr}
 8021882:	b082      	sub	sp, #8
 8021884:	af00      	add	r7, sp, #0
 8021886:	6078      	str	r0, [r7, #4]
 8021888:	6039      	str	r1, [r7, #0]
    // r'= padding || r
    memset(r_prime, 0, 16);
 802188a:	2210      	movs	r2, #16
 802188c:	2100      	movs	r1, #0
 802188e:	6838      	ldr	r0, [r7, #0]
 8021890:	f006 f917 	bl	8027ac2 <memset>
    (void)memcpy(&r_prime[13], r, 3);
 8021894:	683b      	ldr	r3, [r7, #0]
 8021896:	330d      	adds	r3, #13
 8021898:	2203      	movs	r2, #3
 802189a:	6879      	ldr	r1, [r7, #4]
 802189c:	4618      	mov	r0, r3
 802189e:	f006 f8ec 	bl	8027a7a <memcpy>
}
 80218a2:	bf00      	nop
 80218a4:	3708      	adds	r7, #8
 80218a6:	46bd      	mov	sp, r7
 80218a8:	bd80      	pop	{r7, pc}

080218aa <sm_d1_d_prime>:

// d1 helper
// d' = padding || r || d
// d,r - 16 bit values
static void sm_d1_d_prime(uint16_t d, uint16_t r, uint8_t * d1_prime){
 80218aa:	b580      	push	{r7, lr}
 80218ac:	b082      	sub	sp, #8
 80218ae:	af00      	add	r7, sp, #0
 80218b0:	4603      	mov	r3, r0
 80218b2:	603a      	str	r2, [r7, #0]
 80218b4:	80fb      	strh	r3, [r7, #6]
 80218b6:	460b      	mov	r3, r1
 80218b8:	80bb      	strh	r3, [r7, #4]
    // d'= padding || r || d
    memset(d1_prime, 0, 16);
 80218ba:	2210      	movs	r2, #16
 80218bc:	2100      	movs	r1, #0
 80218be:	6838      	ldr	r0, [r7, #0]
 80218c0:	f006 f8ff 	bl	8027ac2 <memset>
    big_endian_store_16(d1_prime, 12, r);
 80218c4:	88bb      	ldrh	r3, [r7, #4]
 80218c6:	461a      	mov	r2, r3
 80218c8:	210c      	movs	r1, #12
 80218ca:	6838      	ldr	r0, [r7, #0]
 80218cc:	f7ed fb61 	bl	800ef92 <big_endian_store_16>
    big_endian_store_16(d1_prime, 14, d);
 80218d0:	88fb      	ldrh	r3, [r7, #6]
 80218d2:	461a      	mov	r2, r3
 80218d4:	210e      	movs	r1, #14
 80218d6:	6838      	ldr	r0, [r7, #0]
 80218d8:	f7ed fb5b 	bl	800ef92 <big_endian_store_16>
}
 80218dc:	bf00      	nop
 80218de:	3708      	adds	r7, #8
 80218e0:	46bd      	mov	sp, r7
 80218e2:	bd80      	pop	{r7, pc}

080218e4 <sm_c1_t1>:

// calculate arguments for first AES128 operation in C1 function
static void sm_c1_t1(sm_key_t r, uint8_t preq[7], uint8_t pres[7], uint8_t iat, uint8_t rat, uint8_t * t1){
 80218e4:	b580      	push	{r7, lr}
 80218e6:	b08a      	sub	sp, #40	; 0x28
 80218e8:	af00      	add	r7, sp, #0
 80218ea:	60f8      	str	r0, [r7, #12]
 80218ec:	60b9      	str	r1, [r7, #8]
 80218ee:	607a      	str	r2, [r7, #4]
 80218f0:	70fb      	strb	r3, [r7, #3]
    // For example, if the 8-bit iat’ is 0x01, the 8-bit rat’ is 0x00, the 56-bit preq
    // is 0x07071000000101 and the 56 bit pres is 0x05000800000302 then
    // p1 is 0x05000800000302070710000001010001."

    sm_key_t p1;
    reverse_56(pres, &p1[0]);
 80218f2:	f107 0314 	add.w	r3, r7, #20
 80218f6:	4619      	mov	r1, r3
 80218f8:	6878      	ldr	r0, [r7, #4]
 80218fa:	f7ed fbc2 	bl	800f082 <reverse_56>
    reverse_56(preq, &p1[7]);
 80218fe:	f107 0314 	add.w	r3, r7, #20
 8021902:	3307      	adds	r3, #7
 8021904:	4619      	mov	r1, r3
 8021906:	68b8      	ldr	r0, [r7, #8]
 8021908:	f7ed fbbb 	bl	800f082 <reverse_56>
    p1[14] = rat;
 802190c:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8021910:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    p1[15] = iat;
 8021914:	78fb      	ldrb	r3, [r7, #3]
 8021916:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    log_info_key("p1", p1);
 802191a:	f107 0314 	add.w	r3, r7, #20
 802191e:	4619      	mov	r1, r3
 8021920:	4813      	ldr	r0, [pc, #76]	; (8021970 <sm_c1_t1+0x8c>)
 8021922:	f7ed fd27 	bl	800f374 <log_info_key>
    log_info_key("r", r);
 8021926:	68f9      	ldr	r1, [r7, #12]
 8021928:	4812      	ldr	r0, [pc, #72]	; (8021974 <sm_c1_t1+0x90>)
 802192a:	f7ed fd23 	bl	800f374 <log_info_key>

    // t1 = r xor p1
    int i;
    for (i=0;i<16;i++){
 802192e:	2300      	movs	r3, #0
 8021930:	627b      	str	r3, [r7, #36]	; 0x24
 8021932:	e011      	b.n	8021958 <sm_c1_t1+0x74>
        t1[i] = r[i] ^ p1[i];
 8021934:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021936:	68fa      	ldr	r2, [r7, #12]
 8021938:	4413      	add	r3, r2
 802193a:	7819      	ldrb	r1, [r3, #0]
 802193c:	f107 0214 	add.w	r2, r7, #20
 8021940:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021942:	4413      	add	r3, r2
 8021944:	781a      	ldrb	r2, [r3, #0]
 8021946:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021948:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802194a:	4403      	add	r3, r0
 802194c:	404a      	eors	r2, r1
 802194e:	b2d2      	uxtb	r2, r2
 8021950:	701a      	strb	r2, [r3, #0]
    for (i=0;i<16;i++){
 8021952:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021954:	3301      	adds	r3, #1
 8021956:	627b      	str	r3, [r7, #36]	; 0x24
 8021958:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802195a:	2b0f      	cmp	r3, #15
 802195c:	ddea      	ble.n	8021934 <sm_c1_t1+0x50>
    }
    log_info_key("t1", t1);
 802195e:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8021960:	4805      	ldr	r0, [pc, #20]	; (8021978 <sm_c1_t1+0x94>)
 8021962:	f7ed fd07 	bl	800f374 <log_info_key>
}
 8021966:	bf00      	nop
 8021968:	3728      	adds	r7, #40	; 0x28
 802196a:	46bd      	mov	sp, r7
 802196c:	bd80      	pop	{r7, pc}
 802196e:	bf00      	nop
 8021970:	0802d52c 	.word	0x0802d52c
 8021974:	0802d530 	.word	0x0802d530
 8021978:	0802d534 	.word	0x0802d534

0802197c <sm_c1_t3>:

// calculate arguments for second AES128 operation in C1 function
static void sm_c1_t3(sm_key_t t2, bd_addr_t ia, bd_addr_t ra, uint8_t * t3){
 802197c:	b580      	push	{r7, lr}
 802197e:	b08a      	sub	sp, #40	; 0x28
 8021980:	af00      	add	r7, sp, #0
 8021982:	60f8      	str	r0, [r7, #12]
 8021984:	60b9      	str	r1, [r7, #8]
 8021986:	607a      	str	r2, [r7, #4]
 8021988:	603b      	str	r3, [r7, #0]
    // the most significant octet of padding becomes the most significant octet of p2.
    // For example, if 48-bit ia is 0xA1A2A3A4A5A6 and the 48-bit ra is
    // 0xB1B2B3B4B5B6 then p2 is 0x00000000A1A2A3A4A5A6B1B2B3B4B5B6.

    sm_key_t p2;
    memset(p2, 0, 16);
 802198a:	f107 0314 	add.w	r3, r7, #20
 802198e:	2210      	movs	r2, #16
 8021990:	2100      	movs	r1, #0
 8021992:	4618      	mov	r0, r3
 8021994:	f006 f895 	bl	8027ac2 <memset>
    (void)memcpy(&p2[4], ia, 6);
 8021998:	f107 0314 	add.w	r3, r7, #20
 802199c:	3304      	adds	r3, #4
 802199e:	2206      	movs	r2, #6
 80219a0:	68b9      	ldr	r1, [r7, #8]
 80219a2:	4618      	mov	r0, r3
 80219a4:	f006 f869 	bl	8027a7a <memcpy>
    (void)memcpy(&p2[10], ra, 6);
 80219a8:	f107 0314 	add.w	r3, r7, #20
 80219ac:	330a      	adds	r3, #10
 80219ae:	2206      	movs	r2, #6
 80219b0:	6879      	ldr	r1, [r7, #4]
 80219b2:	4618      	mov	r0, r3
 80219b4:	f006 f861 	bl	8027a7a <memcpy>
    log_info_key("p2", p2);
 80219b8:	f107 0314 	add.w	r3, r7, #20
 80219bc:	4619      	mov	r1, r3
 80219be:	4811      	ldr	r0, [pc, #68]	; (8021a04 <sm_c1_t3+0x88>)
 80219c0:	f7ed fcd8 	bl	800f374 <log_info_key>

    // c1 = e(k, t2_xor_p2)
    int i;
    for (i=0;i<16;i++){
 80219c4:	2300      	movs	r3, #0
 80219c6:	627b      	str	r3, [r7, #36]	; 0x24
 80219c8:	e011      	b.n	80219ee <sm_c1_t3+0x72>
        t3[i] = t2[i] ^ p2[i];
 80219ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80219cc:	68fa      	ldr	r2, [r7, #12]
 80219ce:	4413      	add	r3, r2
 80219d0:	7819      	ldrb	r1, [r3, #0]
 80219d2:	f107 0214 	add.w	r2, r7, #20
 80219d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80219d8:	4413      	add	r3, r2
 80219da:	781a      	ldrb	r2, [r3, #0]
 80219dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80219de:	6838      	ldr	r0, [r7, #0]
 80219e0:	4403      	add	r3, r0
 80219e2:	404a      	eors	r2, r1
 80219e4:	b2d2      	uxtb	r2, r2
 80219e6:	701a      	strb	r2, [r3, #0]
    for (i=0;i<16;i++){
 80219e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80219ea:	3301      	adds	r3, #1
 80219ec:	627b      	str	r3, [r7, #36]	; 0x24
 80219ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80219f0:	2b0f      	cmp	r3, #15
 80219f2:	ddea      	ble.n	80219ca <sm_c1_t3+0x4e>
    }
    log_info_key("t3", t3);
 80219f4:	6839      	ldr	r1, [r7, #0]
 80219f6:	4804      	ldr	r0, [pc, #16]	; (8021a08 <sm_c1_t3+0x8c>)
 80219f8:	f7ed fcbc 	bl	800f374 <log_info_key>
}
 80219fc:	bf00      	nop
 80219fe:	3728      	adds	r7, #40	; 0x28
 8021a00:	46bd      	mov	sp, r7
 8021a02:	bd80      	pop	{r7, pc}
 8021a04:	0802d538 	.word	0x0802d538
 8021a08:	0802d53c 	.word	0x0802d53c

08021a0c <sm_s1_r_prime>:

static void sm_s1_r_prime(sm_key_t r1, sm_key_t r2, uint8_t * r_prime){
 8021a0c:	b580      	push	{r7, lr}
 8021a0e:	b084      	sub	sp, #16
 8021a10:	af00      	add	r7, sp, #0
 8021a12:	60f8      	str	r0, [r7, #12]
 8021a14:	60b9      	str	r1, [r7, #8]
 8021a16:	607a      	str	r2, [r7, #4]
    log_info_key("r1", r1);
 8021a18:	68f9      	ldr	r1, [r7, #12]
 8021a1a:	480d      	ldr	r0, [pc, #52]	; (8021a50 <sm_s1_r_prime+0x44>)
 8021a1c:	f7ed fcaa 	bl	800f374 <log_info_key>
    log_info_key("r2", r2);
 8021a20:	68b9      	ldr	r1, [r7, #8]
 8021a22:	480c      	ldr	r0, [pc, #48]	; (8021a54 <sm_s1_r_prime+0x48>)
 8021a24:	f7ed fca6 	bl	800f374 <log_info_key>
    (void)memcpy(&r_prime[8], &r2[8], 8);
 8021a28:	687b      	ldr	r3, [r7, #4]
 8021a2a:	f103 0008 	add.w	r0, r3, #8
 8021a2e:	68bb      	ldr	r3, [r7, #8]
 8021a30:	3308      	adds	r3, #8
 8021a32:	2208      	movs	r2, #8
 8021a34:	4619      	mov	r1, r3
 8021a36:	f006 f820 	bl	8027a7a <memcpy>
    (void)memcpy(&r_prime[0], &r1[8], 8);
 8021a3a:	68fb      	ldr	r3, [r7, #12]
 8021a3c:	3308      	adds	r3, #8
 8021a3e:	2208      	movs	r2, #8
 8021a40:	4619      	mov	r1, r3
 8021a42:	6878      	ldr	r0, [r7, #4]
 8021a44:	f006 f819 	bl	8027a7a <memcpy>
}
 8021a48:	bf00      	nop
 8021a4a:	3710      	adds	r7, #16
 8021a4c:	46bd      	mov	sp, r7
 8021a4e:	bd80      	pop	{r7, pc}
 8021a50:	0802d540 	.word	0x0802d540
 8021a54:	0802d544 	.word	0x0802d544

08021a58 <sm_setup_tk>:

// decide on stk generation based on
// - pairing request
// - io capabilities
// - OOB data availability
static void sm_setup_tk(void){
 8021a58:	b590      	push	{r4, r7, lr}
 8021a5a:	b087      	sub	sp, #28
 8021a5c:	af04      	add	r7, sp, #16
            { PK_RESP_INPUT,   NUMERIC_COMPARISON, PK_INIT_INPUT,   JUST_WORKS,    NUMERIC_COMPARISON },
    };
#endif

    // default: just works
    setup->sm_stk_generation_method = JUST_WORKS;
 8021a5e:	4b76      	ldr	r3, [pc, #472]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021a60:	681b      	ldr	r3, [r3, #0]
 8021a62:	2200      	movs	r2, #0
 8021a64:	759a      	strb	r2, [r3, #22]

#ifdef ENABLE_LE_SECURE_CONNECTIONS
    setup->sm_use_secure_connections = ( sm_pairing_packet_get_auth_req(setup->sm_m_preq)
 8021a66:	4b74      	ldr	r3, [pc, #464]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021a68:	681b      	ldr	r3, [r3, #0]
 8021a6a:	3339      	adds	r3, #57	; 0x39
 8021a6c:	4618      	mov	r0, r3
 8021a6e:	f7ff fabd 	bl	8020fec <sm_pairing_packet_get_auth_req>
 8021a72:	4603      	mov	r3, r0
 8021a74:	461c      	mov	r4, r3
                                       & sm_pairing_packet_get_auth_req(setup->sm_s_pres)
 8021a76:	4b70      	ldr	r3, [pc, #448]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021a78:	681b      	ldr	r3, [r3, #0]
 8021a7a:	3340      	adds	r3, #64	; 0x40
 8021a7c:	4618      	mov	r0, r3
 8021a7e:	f7ff fab5 	bl	8020fec <sm_pairing_packet_get_auth_req>
 8021a82:	4603      	mov	r3, r0
                                       & SM_AUTHREQ_SECURE_CONNECTION ) != 0u;
 8021a84:	4023      	ands	r3, r4
 8021a86:	b2db      	uxtb	r3, r3
 8021a88:	f003 0308 	and.w	r3, r3, #8
 8021a8c:	2b00      	cmp	r3, #0
 8021a8e:	bf14      	ite	ne
 8021a90:	2301      	movne	r3, #1
 8021a92:	2300      	moveq	r3, #0
 8021a94:	b2da      	uxtb	r2, r3
    setup->sm_use_secure_connections = ( sm_pairing_packet_get_auth_req(setup->sm_m_preq)
 8021a96:	4b68      	ldr	r3, [pc, #416]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021a98:	681b      	ldr	r3, [r3, #0]
 8021a9a:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
#else
    setup->sm_use_secure_connections = 0;
#endif
    log_info("Secure pairing: %u", setup->sm_use_secure_connections);
 8021a9e:	4b66      	ldr	r3, [pc, #408]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021aa0:	681b      	ldr	r3, [r3, #0]
 8021aa2:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8021aa6:	9300      	str	r3, [sp, #0]
 8021aa8:	f44f 7353 	mov.w	r3, #844	; 0x34c
 8021aac:	4a63      	ldr	r2, [pc, #396]	; (8021c3c <sm_setup_tk+0x1e4>)
 8021aae:	4964      	ldr	r1, [pc, #400]	; (8021c40 <sm_setup_tk+0x1e8>)
 8021ab0:	2001      	movs	r0, #1
 8021ab2:	f7f5 fcc5 	bl	8017440 <hci_dump_log>


    // decide if OOB will be used based on SC vs. Legacy and oob flags
    bool use_oob;
    if (setup->sm_use_secure_connections){
 8021ab6:	4b60      	ldr	r3, [pc, #384]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021ab8:	681b      	ldr	r3, [r3, #0]
 8021aba:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8021abe:	2b00      	cmp	r3, #0
 8021ac0:	d016      	beq.n	8021af0 <sm_setup_tk+0x98>
        // In LE Secure Connections pairing, the out of band method is used if at least
        // one device has the peer device's out of band authentication data available.
        use_oob = (sm_pairing_packet_get_oob_data_flag(setup->sm_m_preq) | sm_pairing_packet_get_oob_data_flag(setup->sm_s_pres)) != 0;
 8021ac2:	4b5d      	ldr	r3, [pc, #372]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021ac4:	681b      	ldr	r3, [r3, #0]
 8021ac6:	3339      	adds	r3, #57	; 0x39
 8021ac8:	4618      	mov	r0, r3
 8021aca:	f7ff fa83 	bl	8020fd4 <sm_pairing_packet_get_oob_data_flag>
 8021ace:	4603      	mov	r3, r0
 8021ad0:	461c      	mov	r4, r3
 8021ad2:	4b59      	ldr	r3, [pc, #356]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021ad4:	681b      	ldr	r3, [r3, #0]
 8021ad6:	3340      	adds	r3, #64	; 0x40
 8021ad8:	4618      	mov	r0, r3
 8021ada:	f7ff fa7b 	bl	8020fd4 <sm_pairing_packet_get_oob_data_flag>
 8021ade:	4603      	mov	r3, r0
 8021ae0:	4323      	orrs	r3, r4
 8021ae2:	b2db      	uxtb	r3, r3
 8021ae4:	2b00      	cmp	r3, #0
 8021ae6:	bf14      	ite	ne
 8021ae8:	2301      	movne	r3, #1
 8021aea:	2300      	moveq	r3, #0
 8021aec:	71fb      	strb	r3, [r7, #7]
 8021aee:	e015      	b.n	8021b1c <sm_setup_tk+0xc4>
    } else {
        // In LE legacy pairing, the out of band method is used if both the devices have
        // the other device's out of band authentication data available. 
        use_oob = (sm_pairing_packet_get_oob_data_flag(setup->sm_m_preq) & sm_pairing_packet_get_oob_data_flag(setup->sm_s_pres)) != 0;
 8021af0:	4b51      	ldr	r3, [pc, #324]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021af2:	681b      	ldr	r3, [r3, #0]
 8021af4:	3339      	adds	r3, #57	; 0x39
 8021af6:	4618      	mov	r0, r3
 8021af8:	f7ff fa6c 	bl	8020fd4 <sm_pairing_packet_get_oob_data_flag>
 8021afc:	4603      	mov	r3, r0
 8021afe:	461c      	mov	r4, r3
 8021b00:	4b4d      	ldr	r3, [pc, #308]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021b02:	681b      	ldr	r3, [r3, #0]
 8021b04:	3340      	adds	r3, #64	; 0x40
 8021b06:	4618      	mov	r0, r3
 8021b08:	f7ff fa64 	bl	8020fd4 <sm_pairing_packet_get_oob_data_flag>
 8021b0c:	4603      	mov	r3, r0
 8021b0e:	4023      	ands	r3, r4
 8021b10:	b2db      	uxtb	r3, r3
 8021b12:	2b00      	cmp	r3, #0
 8021b14:	bf14      	ite	ne
 8021b16:	2301      	movne	r3, #1
 8021b18:	2300      	moveq	r3, #0
 8021b1a:	71fb      	strb	r3, [r7, #7]
    }
    if (use_oob){
 8021b1c:	79fb      	ldrb	r3, [r7, #7]
 8021b1e:	2b00      	cmp	r3, #0
 8021b20:	d012      	beq.n	8021b48 <sm_setup_tk+0xf0>
        log_info("SM: have OOB data");
 8021b22:	f240 335b 	movw	r3, #859	; 0x35b
 8021b26:	4a45      	ldr	r2, [pc, #276]	; (8021c3c <sm_setup_tk+0x1e4>)
 8021b28:	4946      	ldr	r1, [pc, #280]	; (8021c44 <sm_setup_tk+0x1ec>)
 8021b2a:	2001      	movs	r0, #1
 8021b2c:	f7f5 fc88 	bl	8017440 <hci_dump_log>
        log_info_key("OOB", setup->sm_tk);
 8021b30:	4b41      	ldr	r3, [pc, #260]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021b32:	681b      	ldr	r3, [r3, #0]
 8021b34:	3317      	adds	r3, #23
 8021b36:	4619      	mov	r1, r3
 8021b38:	4843      	ldr	r0, [pc, #268]	; (8021c48 <sm_setup_tk+0x1f0>)
 8021b3a:	f7ed fc1b 	bl	800f374 <log_info_key>
        setup->sm_stk_generation_method = OOB;
 8021b3e:	4b3e      	ldr	r3, [pc, #248]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021b40:	681b      	ldr	r3, [r3, #0]
 8021b42:	2205      	movs	r2, #5
 8021b44:	759a      	strb	r2, [r3, #22]
        return;
 8021b46:	e073      	b.n	8021c30 <sm_setup_tk+0x1d8>
    }

    // If both devices have not set the MITM option in the Authentication Requirements
    // Flags, then the IO capabilities shall be ignored and the Just Works association
    // model shall be used.
    if (((sm_pairing_packet_get_auth_req(setup->sm_m_preq) & SM_AUTHREQ_MITM_PROTECTION) == 0u)
 8021b48:	4b3b      	ldr	r3, [pc, #236]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021b4a:	681b      	ldr	r3, [r3, #0]
 8021b4c:	3339      	adds	r3, #57	; 0x39
 8021b4e:	4618      	mov	r0, r3
 8021b50:	f7ff fa4c 	bl	8020fec <sm_pairing_packet_get_auth_req>
 8021b54:	4603      	mov	r3, r0
 8021b56:	f003 0304 	and.w	r3, r3, #4
 8021b5a:	2b00      	cmp	r3, #0
 8021b5c:	d112      	bne.n	8021b84 <sm_setup_tk+0x12c>
        &&  ((sm_pairing_packet_get_auth_req(setup->sm_s_pres) & SM_AUTHREQ_MITM_PROTECTION) == 0u)){
 8021b5e:	4b36      	ldr	r3, [pc, #216]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021b60:	681b      	ldr	r3, [r3, #0]
 8021b62:	3340      	adds	r3, #64	; 0x40
 8021b64:	4618      	mov	r0, r3
 8021b66:	f7ff fa41 	bl	8020fec <sm_pairing_packet_get_auth_req>
 8021b6a:	4603      	mov	r3, r0
 8021b6c:	f003 0304 	and.w	r3, r3, #4
 8021b70:	2b00      	cmp	r3, #0
 8021b72:	d107      	bne.n	8021b84 <sm_setup_tk+0x12c>
        log_info("SM: MITM not required by both -> JUST WORKS");
 8021b74:	f240 3366 	movw	r3, #870	; 0x366
 8021b78:	4a30      	ldr	r2, [pc, #192]	; (8021c3c <sm_setup_tk+0x1e4>)
 8021b7a:	4934      	ldr	r1, [pc, #208]	; (8021c4c <sm_setup_tk+0x1f4>)
 8021b7c:	2001      	movs	r0, #1
 8021b7e:	f7f5 fc5f 	bl	8017440 <hci_dump_log>
        return;
 8021b82:	e055      	b.n	8021c30 <sm_setup_tk+0x1d8>
    }

    // Reset TK as it has been setup in sm_init_setup
    sm_reset_tk();
 8021b84:	f7ff fb2e 	bl	80211e4 <sm_reset_tk>

    // Also use just works if unknown io capabilites
    if ((sm_pairing_packet_get_io_capability(setup->sm_m_preq) > IO_CAPABILITY_KEYBOARD_DISPLAY) || (sm_pairing_packet_get_io_capability(setup->sm_s_pres) > IO_CAPABILITY_KEYBOARD_DISPLAY)){
 8021b88:	4b2b      	ldr	r3, [pc, #172]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021b8a:	681b      	ldr	r3, [r3, #0]
 8021b8c:	3339      	adds	r3, #57	; 0x39
 8021b8e:	4618      	mov	r0, r3
 8021b90:	f7ff fa14 	bl	8020fbc <sm_pairing_packet_get_io_capability>
 8021b94:	4603      	mov	r3, r0
 8021b96:	2b04      	cmp	r3, #4
 8021b98:	d849      	bhi.n	8021c2e <sm_setup_tk+0x1d6>
 8021b9a:	4b27      	ldr	r3, [pc, #156]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021b9c:	681b      	ldr	r3, [r3, #0]
 8021b9e:	3340      	adds	r3, #64	; 0x40
 8021ba0:	4618      	mov	r0, r3
 8021ba2:	f7ff fa0b 	bl	8020fbc <sm_pairing_packet_get_io_capability>
 8021ba6:	4603      	mov	r3, r0
 8021ba8:	2b04      	cmp	r3, #4
 8021baa:	d840      	bhi.n	8021c2e <sm_setup_tk+0x1d6>
    }

    // Otherwise the IO capabilities of the devices shall be used to determine the
    // pairing method as defined in Table 2.4.
    // see http://stackoverflow.com/a/1052837/393697 for how to specify pointer to 2-dimensional array
    const stk_generation_method_t (*generation_method)[5] = stk_generation_method;
 8021bac:	4b28      	ldr	r3, [pc, #160]	; (8021c50 <sm_setup_tk+0x1f8>)
 8021bae:	603b      	str	r3, [r7, #0]

#ifdef ENABLE_LE_SECURE_CONNECTIONS
    // table not define by default
    if (setup->sm_use_secure_connections){
 8021bb0:	4b21      	ldr	r3, [pc, #132]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021bb2:	681b      	ldr	r3, [r3, #0]
 8021bb4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8021bb8:	2b00      	cmp	r3, #0
 8021bba:	d001      	beq.n	8021bc0 <sm_setup_tk+0x168>
        generation_method = stk_generation_method_with_secure_connection;
 8021bbc:	4b25      	ldr	r3, [pc, #148]	; (8021c54 <sm_setup_tk+0x1fc>)
 8021bbe:	603b      	str	r3, [r7, #0]
    }
#endif
    setup->sm_stk_generation_method = generation_method[sm_pairing_packet_get_io_capability(setup->sm_s_pres)][sm_pairing_packet_get_io_capability(setup->sm_m_preq)];
 8021bc0:	4b1d      	ldr	r3, [pc, #116]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021bc2:	681b      	ldr	r3, [r3, #0]
 8021bc4:	3340      	adds	r3, #64	; 0x40
 8021bc6:	4618      	mov	r0, r3
 8021bc8:	f7ff f9f8 	bl	8020fbc <sm_pairing_packet_get_io_capability>
 8021bcc:	4603      	mov	r3, r0
 8021bce:	461a      	mov	r2, r3
 8021bd0:	4613      	mov	r3, r2
 8021bd2:	009b      	lsls	r3, r3, #2
 8021bd4:	4413      	add	r3, r2
 8021bd6:	683a      	ldr	r2, [r7, #0]
 8021bd8:	18d4      	adds	r4, r2, r3
 8021bda:	4b17      	ldr	r3, [pc, #92]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021bdc:	681b      	ldr	r3, [r3, #0]
 8021bde:	3339      	adds	r3, #57	; 0x39
 8021be0:	4618      	mov	r0, r3
 8021be2:	f7ff f9eb 	bl	8020fbc <sm_pairing_packet_get_io_capability>
 8021be6:	4603      	mov	r3, r0
 8021be8:	461a      	mov	r2, r3
 8021bea:	4b13      	ldr	r3, [pc, #76]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021bec:	681b      	ldr	r3, [r3, #0]
 8021bee:	5ca2      	ldrb	r2, [r4, r2]
 8021bf0:	759a      	strb	r2, [r3, #22]

    log_info("sm_setup_tk: master io cap: %u, slave io cap: %u -> method %u",
 8021bf2:	4b11      	ldr	r3, [pc, #68]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021bf4:	681b      	ldr	r3, [r3, #0]
 8021bf6:	3339      	adds	r3, #57	; 0x39
 8021bf8:	4618      	mov	r0, r3
 8021bfa:	f7ff f9df 	bl	8020fbc <sm_pairing_packet_get_io_capability>
 8021bfe:	4603      	mov	r3, r0
 8021c00:	461c      	mov	r4, r3
 8021c02:	4b0d      	ldr	r3, [pc, #52]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021c04:	681b      	ldr	r3, [r3, #0]
 8021c06:	3340      	adds	r3, #64	; 0x40
 8021c08:	4618      	mov	r0, r3
 8021c0a:	f7ff f9d7 	bl	8020fbc <sm_pairing_packet_get_io_capability>
 8021c0e:	4603      	mov	r3, r0
 8021c10:	461a      	mov	r2, r3
 8021c12:	4b09      	ldr	r3, [pc, #36]	; (8021c38 <sm_setup_tk+0x1e0>)
 8021c14:	681b      	ldr	r3, [r3, #0]
 8021c16:	7d9b      	ldrb	r3, [r3, #22]
 8021c18:	9302      	str	r3, [sp, #8]
 8021c1a:	9201      	str	r2, [sp, #4]
 8021c1c:	9400      	str	r4, [sp, #0]
 8021c1e:	f44f 7360 	mov.w	r3, #896	; 0x380
 8021c22:	4a06      	ldr	r2, [pc, #24]	; (8021c3c <sm_setup_tk+0x1e4>)
 8021c24:	490c      	ldr	r1, [pc, #48]	; (8021c58 <sm_setup_tk+0x200>)
 8021c26:	2001      	movs	r0, #1
 8021c28:	f7f5 fc0a 	bl	8017440 <hci_dump_log>
 8021c2c:	e000      	b.n	8021c30 <sm_setup_tk+0x1d8>
        return;
 8021c2e:	bf00      	nop
        sm_pairing_packet_get_io_capability(setup->sm_m_preq), sm_pairing_packet_get_io_capability(setup->sm_s_pres), setup->sm_stk_generation_method);
}
 8021c30:	370c      	adds	r7, #12
 8021c32:	46bd      	mov	sp, r7
 8021c34:	bd90      	pop	{r4, r7, pc}
 8021c36:	bf00      	nop
 8021c38:	200000a0 	.word	0x200000a0
 8021c3c:	0802d4a8 	.word	0x0802d4a8
 8021c40:	0802d548 	.word	0x0802d548
 8021c44:	0802d564 	.word	0x0802d564
 8021c48:	0802d580 	.word	0x0802d580
 8021c4c:	0802d584 	.word	0x0802d584
 8021c50:	08030ea0 	.word	0x08030ea0
 8021c54:	08030ebc 	.word	0x08030ebc
 8021c58:	0802d5b8 	.word	0x0802d5b8

08021c5c <sm_key_distribution_flags_for_set>:

static int sm_key_distribution_flags_for_set(uint8_t key_set){
 8021c5c:	b480      	push	{r7}
 8021c5e:	b085      	sub	sp, #20
 8021c60:	af00      	add	r7, sp, #0
 8021c62:	4603      	mov	r3, r0
 8021c64:	71fb      	strb	r3, [r7, #7]
    int flags = 0;
 8021c66:	2300      	movs	r3, #0
 8021c68:	60fb      	str	r3, [r7, #12]
    if (key_set & SM_KEYDIST_ENC_KEY){
 8021c6a:	79fb      	ldrb	r3, [r7, #7]
 8021c6c:	f003 0301 	and.w	r3, r3, #1
 8021c70:	2b00      	cmp	r3, #0
 8021c72:	d007      	beq.n	8021c84 <sm_key_distribution_flags_for_set+0x28>
        flags |= SM_KEYDIST_FLAG_ENCRYPTION_INFORMATION;
 8021c74:	68fb      	ldr	r3, [r7, #12]
 8021c76:	f043 0301 	orr.w	r3, r3, #1
 8021c7a:	60fb      	str	r3, [r7, #12]
        flags |= SM_KEYDIST_FLAG_MASTER_IDENTIFICATION;
 8021c7c:	68fb      	ldr	r3, [r7, #12]
 8021c7e:	f043 0302 	orr.w	r3, r3, #2
 8021c82:	60fb      	str	r3, [r7, #12]
    }
    if (key_set & SM_KEYDIST_ID_KEY){
 8021c84:	79fb      	ldrb	r3, [r7, #7]
 8021c86:	f003 0302 	and.w	r3, r3, #2
 8021c8a:	2b00      	cmp	r3, #0
 8021c8c:	d007      	beq.n	8021c9e <sm_key_distribution_flags_for_set+0x42>
        flags |= SM_KEYDIST_FLAG_IDENTITY_INFORMATION;
 8021c8e:	68fb      	ldr	r3, [r7, #12]
 8021c90:	f043 0304 	orr.w	r3, r3, #4
 8021c94:	60fb      	str	r3, [r7, #12]
        flags |= SM_KEYDIST_FLAG_IDENTITY_ADDRESS_INFORMATION;
 8021c96:	68fb      	ldr	r3, [r7, #12]
 8021c98:	f043 0308 	orr.w	r3, r3, #8
 8021c9c:	60fb      	str	r3, [r7, #12]
    }
    if (key_set & SM_KEYDIST_SIGN){
 8021c9e:	79fb      	ldrb	r3, [r7, #7]
 8021ca0:	f003 0304 	and.w	r3, r3, #4
 8021ca4:	2b00      	cmp	r3, #0
 8021ca6:	d003      	beq.n	8021cb0 <sm_key_distribution_flags_for_set+0x54>
        flags |= SM_KEYDIST_FLAG_SIGNING_IDENTIFICATION;
 8021ca8:	68fb      	ldr	r3, [r7, #12]
 8021caa:	f043 0310 	orr.w	r3, r3, #16
 8021cae:	60fb      	str	r3, [r7, #12]
    }
    return flags;
 8021cb0:	68fb      	ldr	r3, [r7, #12]
}
 8021cb2:	4618      	mov	r0, r3
 8021cb4:	3714      	adds	r7, #20
 8021cb6:	46bd      	mov	sp, r7
 8021cb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021cbc:	4770      	bx	lr
	...

08021cc0 <sm_setup_key_distribution>:

static void sm_setup_key_distribution(uint8_t key_set){
 8021cc0:	b580      	push	{r7, lr}
 8021cc2:	b082      	sub	sp, #8
 8021cc4:	af00      	add	r7, sp, #0
 8021cc6:	4603      	mov	r3, r0
 8021cc8:	71fb      	strb	r3, [r7, #7]
    setup->sm_key_distribution_received_set = 0;
 8021cca:	4b0a      	ldr	r3, [pc, #40]	; (8021cf4 <sm_setup_key_distribution+0x34>)
 8021ccc:	681b      	ldr	r3, [r3, #0]
 8021cce:	2200      	movs	r2, #0
 8021cd0:	755a      	strb	r2, [r3, #21]
    setup->sm_key_distribution_send_set = sm_key_distribution_flags_for_set(key_set);
 8021cd2:	79fb      	ldrb	r3, [r7, #7]
 8021cd4:	4618      	mov	r0, r3
 8021cd6:	f7ff ffc1 	bl	8021c5c <sm_key_distribution_flags_for_set>
 8021cda:	4602      	mov	r2, r0
 8021cdc:	4b05      	ldr	r3, [pc, #20]	; (8021cf4 <sm_setup_key_distribution+0x34>)
 8021cde:	681b      	ldr	r3, [r3, #0]
 8021ce0:	b2d2      	uxtb	r2, r2
 8021ce2:	74da      	strb	r2, [r3, #19]
    setup->sm_key_distribution_sent_set = 0;
 8021ce4:	4b03      	ldr	r3, [pc, #12]	; (8021cf4 <sm_setup_key_distribution+0x34>)
 8021ce6:	681b      	ldr	r3, [r3, #0]
 8021ce8:	2200      	movs	r2, #0
 8021cea:	751a      	strb	r2, [r3, #20]
#ifdef ENABLE_LE_SIGNED_WRITE
    setup->sm_le_device_index = -1;
#endif
}
 8021cec:	bf00      	nop
 8021cee:	3708      	adds	r7, #8
 8021cf0:	46bd      	mov	sp, r7
 8021cf2:	bd80      	pop	{r7, pc}
 8021cf4:	200000a0 	.word	0x200000a0

08021cf8 <sm_address_resolution_idle>:

// CSRK Key Lookup


static int sm_address_resolution_idle(void){
 8021cf8:	b480      	push	{r7}
 8021cfa:	af00      	add	r7, sp, #0
    return sm_address_resolution_mode == ADDRESS_RESOLUTION_IDLE;
 8021cfc:	4b05      	ldr	r3, [pc, #20]	; (8021d14 <sm_address_resolution_idle+0x1c>)
 8021cfe:	781b      	ldrb	r3, [r3, #0]
 8021d00:	2b00      	cmp	r3, #0
 8021d02:	bf0c      	ite	eq
 8021d04:	2301      	moveq	r3, #1
 8021d06:	2300      	movne	r3, #0
 8021d08:	b2db      	uxtb	r3, r3
}
 8021d0a:	4618      	mov	r0, r3
 8021d0c:	46bd      	mov	sp, r7
 8021d0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d12:	4770      	bx	lr
 8021d14:	2000a060 	.word	0x2000a060

08021d18 <sm_address_resolution_start_lookup>:

static void sm_address_resolution_start_lookup(uint8_t addr_type, hci_con_handle_t con_handle, bd_addr_t addr, address_resolution_mode_t mode, void * context){
 8021d18:	b580      	push	{r7, lr}
 8021d1a:	b082      	sub	sp, #8
 8021d1c:	af00      	add	r7, sp, #0
 8021d1e:	603a      	str	r2, [r7, #0]
 8021d20:	461a      	mov	r2, r3
 8021d22:	4603      	mov	r3, r0
 8021d24:	71fb      	strb	r3, [r7, #7]
 8021d26:	460b      	mov	r3, r1
 8021d28:	80bb      	strh	r3, [r7, #4]
 8021d2a:	4613      	mov	r3, r2
 8021d2c:	71bb      	strb	r3, [r7, #6]
    (void)memcpy(sm_address_resolution_address, addr, 6);
 8021d2e:	4b0e      	ldr	r3, [pc, #56]	; (8021d68 <sm_address_resolution_start_lookup+0x50>)
 8021d30:	683a      	ldr	r2, [r7, #0]
 8021d32:	6810      	ldr	r0, [r2, #0]
 8021d34:	6018      	str	r0, [r3, #0]
 8021d36:	8892      	ldrh	r2, [r2, #4]
 8021d38:	809a      	strh	r2, [r3, #4]
    sm_address_resolution_addr_type = addr_type;
 8021d3a:	4a0c      	ldr	r2, [pc, #48]	; (8021d6c <sm_address_resolution_start_lookup+0x54>)
 8021d3c:	79fb      	ldrb	r3, [r7, #7]
 8021d3e:	7013      	strb	r3, [r2, #0]
    sm_address_resolution_test = 0;
 8021d40:	4b0b      	ldr	r3, [pc, #44]	; (8021d70 <sm_address_resolution_start_lookup+0x58>)
 8021d42:	2200      	movs	r2, #0
 8021d44:	601a      	str	r2, [r3, #0]
    sm_address_resolution_mode = mode;
 8021d46:	4a0b      	ldr	r2, [pc, #44]	; (8021d74 <sm_address_resolution_start_lookup+0x5c>)
 8021d48:	79bb      	ldrb	r3, [r7, #6]
 8021d4a:	7013      	strb	r3, [r2, #0]
    sm_address_resolution_context = context;
 8021d4c:	4a0a      	ldr	r2, [pc, #40]	; (8021d78 <sm_address_resolution_start_lookup+0x60>)
 8021d4e:	693b      	ldr	r3, [r7, #16]
 8021d50:	6013      	str	r3, [r2, #0]
    sm_notify_client_base(SM_EVENT_IDENTITY_RESOLVING_STARTED, con_handle, addr_type, addr);
 8021d52:	79fa      	ldrb	r2, [r7, #7]
 8021d54:	88b9      	ldrh	r1, [r7, #4]
 8021d56:	683b      	ldr	r3, [r7, #0]
 8021d58:	20d5      	movs	r0, #213	; 0xd5
 8021d5a:	f7ff fb40 	bl	80213de <sm_notify_client_base>
}
 8021d5e:	bf00      	nop
 8021d60:	3708      	adds	r7, #8
 8021d62:	46bd      	mov	sp, r7
 8021d64:	bd80      	pop	{r7, pc}
 8021d66:	bf00      	nop
 8021d68:	2000a054 	.word	0x2000a054
 8021d6c:	2000a050 	.word	0x2000a050
 8021d70:	2000a048 	.word	0x2000a048
 8021d74:	2000a060 	.word	0x2000a060
 8021d78:	2000a05c 	.word	0x2000a05c

08021d7c <sm_cmac_done_trampoline>:
}

// CMAC calculation using AES Engineq
#ifdef USE_CMAC_ENGINE

static void sm_cmac_done_trampoline(void * arg){
 8021d7c:	b580      	push	{r7, lr}
 8021d7e:	b082      	sub	sp, #8
 8021d80:	af00      	add	r7, sp, #0
 8021d82:	6078      	str	r0, [r7, #4]
    UNUSED(arg);
    sm_cmac_active = 0;
 8021d84:	4b06      	ldr	r3, [pc, #24]	; (8021da0 <sm_cmac_done_trampoline+0x24>)
 8021d86:	2200      	movs	r2, #0
 8021d88:	701a      	strb	r2, [r3, #0]
    (*sm_cmac_done_callback)(sm_cmac_hash);
 8021d8a:	4b06      	ldr	r3, [pc, #24]	; (8021da4 <sm_cmac_done_trampoline+0x28>)
 8021d8c:	681b      	ldr	r3, [r3, #0]
 8021d8e:	4806      	ldr	r0, [pc, #24]	; (8021da8 <sm_cmac_done_trampoline+0x2c>)
 8021d90:	4798      	blx	r3
    sm_trigger_run();
 8021d92:	f7ff fa0d 	bl	80211b0 <sm_trigger_run>
}
 8021d96:	bf00      	nop
 8021d98:	3708      	adds	r7, #8
 8021d9a:	46bd      	mov	sp, r7
 8021d9c:	bd80      	pop	{r7, pc}
 8021d9e:	bf00      	nop
 8021da0:	20009fe0 	.word	0x20009fe0
 8021da4:	20009fdc 	.word	0x20009fdc
 8021da8:	20009fe4 	.word	0x20009fe4

08021dac <sm_cmac_ready>:

int sm_cmac_ready(void){
 8021dac:	b480      	push	{r7}
 8021dae:	af00      	add	r7, sp, #0
    return sm_cmac_active == 0u;
 8021db0:	4b05      	ldr	r3, [pc, #20]	; (8021dc8 <sm_cmac_ready+0x1c>)
 8021db2:	781b      	ldrb	r3, [r3, #0]
 8021db4:	2b00      	cmp	r3, #0
 8021db6:	bf0c      	ite	eq
 8021db8:	2301      	moveq	r3, #1
 8021dba:	2300      	movne	r3, #0
 8021dbc:	b2db      	uxtb	r3, r3
}
 8021dbe:	4618      	mov	r0, r3
 8021dc0:	46bd      	mov	sp, r7
 8021dc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021dc6:	4770      	bx	lr
 8021dc8:	20009fe0 	.word	0x20009fe0

08021dcc <sm_cmac_message_start>:
#endif

#ifdef ENABLE_LE_SECURE_CONNECTIONS
// generic cmac calculation
static void sm_cmac_message_start(const sm_key_t key, uint16_t message_len, const uint8_t * message, void (*done_callback)(uint8_t * hash)){
 8021dcc:	b580      	push	{r7, lr}
 8021dce:	b088      	sub	sp, #32
 8021dd0:	af04      	add	r7, sp, #16
 8021dd2:	60f8      	str	r0, [r7, #12]
 8021dd4:	607a      	str	r2, [r7, #4]
 8021dd6:	603b      	str	r3, [r7, #0]
 8021dd8:	460b      	mov	r3, r1
 8021dda:	817b      	strh	r3, [r7, #10]
    sm_cmac_active = 1;
 8021ddc:	4b0a      	ldr	r3, [pc, #40]	; (8021e08 <sm_cmac_message_start+0x3c>)
 8021dde:	2201      	movs	r2, #1
 8021de0:	701a      	strb	r2, [r3, #0]
    sm_cmac_done_callback = done_callback;
 8021de2:	4a0a      	ldr	r2, [pc, #40]	; (8021e0c <sm_cmac_message_start+0x40>)
 8021de4:	683b      	ldr	r3, [r7, #0]
 8021de6:	6013      	str	r3, [r2, #0]
    btstack_crypto_aes128_cmac_message(&sm_cmac_request, key, message_len, message, sm_cmac_hash, sm_cmac_done_trampoline, NULL);
 8021de8:	897a      	ldrh	r2, [r7, #10]
 8021dea:	2300      	movs	r3, #0
 8021dec:	9302      	str	r3, [sp, #8]
 8021dee:	4b08      	ldr	r3, [pc, #32]	; (8021e10 <sm_cmac_message_start+0x44>)
 8021df0:	9301      	str	r3, [sp, #4]
 8021df2:	4b08      	ldr	r3, [pc, #32]	; (8021e14 <sm_cmac_message_start+0x48>)
 8021df4:	9300      	str	r3, [sp, #0]
 8021df6:	687b      	ldr	r3, [r7, #4]
 8021df8:	68f9      	ldr	r1, [r7, #12]
 8021dfa:	4807      	ldr	r0, [pc, #28]	; (8021e18 <sm_cmac_message_start+0x4c>)
 8021dfc:	f7ec fb68 	bl	800e4d0 <btstack_crypto_aes128_cmac_message>
}
 8021e00:	bf00      	nop
 8021e02:	3710      	adds	r7, #16
 8021e04:	46bd      	mov	sp, r7
 8021e06:	bd80      	pop	{r7, pc}
 8021e08:	20009fe0 	.word	0x20009fe0
 8021e0c:	20009fdc 	.word	0x20009fdc
 8021e10:	08021d7d 	.word	0x08021d7d
 8021e14:	20009fe4 	.word	0x20009fe4
 8021e18:	20009fbc 	.word	0x20009fbc

08021e1c <sm_trigger_user_response>:
    sm_cmac_signed_write_message_len = total_message_len;
    sm_cmac_generator_start(k, total_message_len, &sm_cmac_signed_write_message_get_byte, done_handler);
}
#endif

static void sm_trigger_user_response(sm_connection_t * sm_conn){
 8021e1c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8021e1e:	b085      	sub	sp, #20
 8021e20:	af02      	add	r7, sp, #8
 8021e22:	6078      	str	r0, [r7, #4]
    // notify client for: JUST WORKS confirm, Numeric comparison confirm, PASSKEY display or input
    setup->sm_user_response = SM_USER_RESPONSE_IDLE;
 8021e24:	4b54      	ldr	r3, [pc, #336]	; (8021f78 <sm_trigger_user_response+0x15c>)
 8021e26:	681b      	ldr	r3, [r3, #0]
 8021e28:	2200      	movs	r2, #0
 8021e2a:	745a      	strb	r2, [r3, #17]
    sm_conn->sm_pairing_active = true;
 8021e2c:	687b      	ldr	r3, [r7, #4]
 8021e2e:	2201      	movs	r2, #1
 8021e30:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    switch (setup->sm_stk_generation_method){
 8021e34:	4b50      	ldr	r3, [pc, #320]	; (8021f78 <sm_trigger_user_response+0x15c>)
 8021e36:	681b      	ldr	r3, [r3, #0]
 8021e38:	7d9b      	ldrb	r3, [r3, #22]
 8021e3a:	2b05      	cmp	r3, #5
 8021e3c:	f200 8096 	bhi.w	8021f6c <sm_trigger_user_response+0x150>
 8021e40:	a201      	add	r2, pc, #4	; (adr r2, 8021e48 <sm_trigger_user_response+0x2c>)
 8021e42:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8021e46:	bf00      	nop
 8021e48:	08021f51 	.word	0x08021f51
 8021e4c:	08021e61 	.word	0x08021e61
 8021e50:	08021eb1 	.word	0x08021eb1
 8021e54:	08021f01 	.word	0x08021f01
 8021e58:	08021f1d 	.word	0x08021f1d
 8021e5c:	08021f6d 	.word	0x08021f6d
        case PK_RESP_INPUT:
            if (IS_RESPONDER(sm_conn->sm_role)){
 8021e60:	687b      	ldr	r3, [r7, #4]
 8021e62:	789b      	ldrb	r3, [r3, #2]
 8021e64:	2b00      	cmp	r3, #0
 8021e66:	d00d      	beq.n	8021e84 <sm_trigger_user_response+0x68>
                setup->sm_user_response = SM_USER_RESPONSE_PENDING;
 8021e68:	4b43      	ldr	r3, [pc, #268]	; (8021f78 <sm_trigger_user_response+0x15c>)
 8021e6a:	681b      	ldr	r3, [r3, #0]
 8021e6c:	2201      	movs	r2, #1
 8021e6e:	745a      	strb	r2, [r3, #17]
                sm_notify_client_base(SM_EVENT_PASSKEY_INPUT_NUMBER, sm_conn->sm_handle, sm_conn->sm_peer_addr_type, sm_conn->sm_peer_address);
 8021e70:	687b      	ldr	r3, [r7, #4]
 8021e72:	8819      	ldrh	r1, [r3, #0]
 8021e74:	687b      	ldr	r3, [r7, #4]
 8021e76:	795a      	ldrb	r2, [r3, #5]
 8021e78:	687b      	ldr	r3, [r7, #4]
 8021e7a:	3306      	adds	r3, #6
 8021e7c:	20d3      	movs	r0, #211	; 0xd3
 8021e7e:	f7ff faae 	bl	80213de <sm_notify_client_base>
            } else {
                sm_notify_client_passkey(SM_EVENT_PASSKEY_DISPLAY_NUMBER, sm_conn->sm_handle, sm_conn->sm_peer_addr_type, sm_conn->sm_peer_address, big_endian_read_32(setup->sm_tk, 12));
            }
            break;
 8021e82:	e074      	b.n	8021f6e <sm_trigger_user_response+0x152>
                sm_notify_client_passkey(SM_EVENT_PASSKEY_DISPLAY_NUMBER, sm_conn->sm_handle, sm_conn->sm_peer_addr_type, sm_conn->sm_peer_address, big_endian_read_32(setup->sm_tk, 12));
 8021e84:	687b      	ldr	r3, [r7, #4]
 8021e86:	881c      	ldrh	r4, [r3, #0]
 8021e88:	687b      	ldr	r3, [r7, #4]
 8021e8a:	795d      	ldrb	r5, [r3, #5]
 8021e8c:	687b      	ldr	r3, [r7, #4]
 8021e8e:	1d9e      	adds	r6, r3, #6
 8021e90:	4b39      	ldr	r3, [pc, #228]	; (8021f78 <sm_trigger_user_response+0x15c>)
 8021e92:	681b      	ldr	r3, [r3, #0]
 8021e94:	3317      	adds	r3, #23
 8021e96:	210c      	movs	r1, #12
 8021e98:	4618      	mov	r0, r3
 8021e9a:	f7ed f854 	bl	800ef46 <big_endian_read_32>
 8021e9e:	4603      	mov	r3, r0
 8021ea0:	9300      	str	r3, [sp, #0]
 8021ea2:	4633      	mov	r3, r6
 8021ea4:	462a      	mov	r2, r5
 8021ea6:	4621      	mov	r1, r4
 8021ea8:	20d1      	movs	r0, #209	; 0xd1
 8021eaa:	f7ff fab9 	bl	8021420 <sm_notify_client_passkey>
            break;
 8021eae:	e05e      	b.n	8021f6e <sm_trigger_user_response+0x152>
        case PK_INIT_INPUT:
            if (IS_RESPONDER(sm_conn->sm_role)){
 8021eb0:	687b      	ldr	r3, [r7, #4]
 8021eb2:	789b      	ldrb	r3, [r3, #2]
 8021eb4:	2b00      	cmp	r3, #0
 8021eb6:	d015      	beq.n	8021ee4 <sm_trigger_user_response+0xc8>
                sm_notify_client_passkey(SM_EVENT_PASSKEY_DISPLAY_NUMBER, sm_conn->sm_handle, sm_conn->sm_peer_addr_type, sm_conn->sm_peer_address, big_endian_read_32(setup->sm_tk, 12));
 8021eb8:	687b      	ldr	r3, [r7, #4]
 8021eba:	881c      	ldrh	r4, [r3, #0]
 8021ebc:	687b      	ldr	r3, [r7, #4]
 8021ebe:	795d      	ldrb	r5, [r3, #5]
 8021ec0:	687b      	ldr	r3, [r7, #4]
 8021ec2:	1d9e      	adds	r6, r3, #6
 8021ec4:	4b2c      	ldr	r3, [pc, #176]	; (8021f78 <sm_trigger_user_response+0x15c>)
 8021ec6:	681b      	ldr	r3, [r3, #0]
 8021ec8:	3317      	adds	r3, #23
 8021eca:	210c      	movs	r1, #12
 8021ecc:	4618      	mov	r0, r3
 8021ece:	f7ed f83a 	bl	800ef46 <big_endian_read_32>
 8021ed2:	4603      	mov	r3, r0
 8021ed4:	9300      	str	r3, [sp, #0]
 8021ed6:	4633      	mov	r3, r6
 8021ed8:	462a      	mov	r2, r5
 8021eda:	4621      	mov	r1, r4
 8021edc:	20d1      	movs	r0, #209	; 0xd1
 8021ede:	f7ff fa9f 	bl	8021420 <sm_notify_client_passkey>
            } else {
                setup->sm_user_response = SM_USER_RESPONSE_PENDING;
                sm_notify_client_base(SM_EVENT_PASSKEY_INPUT_NUMBER, sm_conn->sm_handle, sm_conn->sm_peer_addr_type, sm_conn->sm_peer_address);
            }
            break;
 8021ee2:	e044      	b.n	8021f6e <sm_trigger_user_response+0x152>
                setup->sm_user_response = SM_USER_RESPONSE_PENDING;
 8021ee4:	4b24      	ldr	r3, [pc, #144]	; (8021f78 <sm_trigger_user_response+0x15c>)
 8021ee6:	681b      	ldr	r3, [r3, #0]
 8021ee8:	2201      	movs	r2, #1
 8021eea:	745a      	strb	r2, [r3, #17]
                sm_notify_client_base(SM_EVENT_PASSKEY_INPUT_NUMBER, sm_conn->sm_handle, sm_conn->sm_peer_addr_type, sm_conn->sm_peer_address);
 8021eec:	687b      	ldr	r3, [r7, #4]
 8021eee:	8819      	ldrh	r1, [r3, #0]
 8021ef0:	687b      	ldr	r3, [r7, #4]
 8021ef2:	795a      	ldrb	r2, [r3, #5]
 8021ef4:	687b      	ldr	r3, [r7, #4]
 8021ef6:	3306      	adds	r3, #6
 8021ef8:	20d3      	movs	r0, #211	; 0xd3
 8021efa:	f7ff fa70 	bl	80213de <sm_notify_client_base>
            break;
 8021efe:	e036      	b.n	8021f6e <sm_trigger_user_response+0x152>
        case PK_BOTH_INPUT:
            setup->sm_user_response = SM_USER_RESPONSE_PENDING;
 8021f00:	4b1d      	ldr	r3, [pc, #116]	; (8021f78 <sm_trigger_user_response+0x15c>)
 8021f02:	681b      	ldr	r3, [r3, #0]
 8021f04:	2201      	movs	r2, #1
 8021f06:	745a      	strb	r2, [r3, #17]
            sm_notify_client_base(SM_EVENT_PASSKEY_INPUT_NUMBER, sm_conn->sm_handle, sm_conn->sm_peer_addr_type, sm_conn->sm_peer_address);
 8021f08:	687b      	ldr	r3, [r7, #4]
 8021f0a:	8819      	ldrh	r1, [r3, #0]
 8021f0c:	687b      	ldr	r3, [r7, #4]
 8021f0e:	795a      	ldrb	r2, [r3, #5]
 8021f10:	687b      	ldr	r3, [r7, #4]
 8021f12:	3306      	adds	r3, #6
 8021f14:	20d3      	movs	r0, #211	; 0xd3
 8021f16:	f7ff fa62 	bl	80213de <sm_notify_client_base>
            break;
 8021f1a:	e028      	b.n	8021f6e <sm_trigger_user_response+0x152>
        case NUMERIC_COMPARISON:
            setup->sm_user_response = SM_USER_RESPONSE_PENDING;
 8021f1c:	4b16      	ldr	r3, [pc, #88]	; (8021f78 <sm_trigger_user_response+0x15c>)
 8021f1e:	681b      	ldr	r3, [r3, #0]
 8021f20:	2201      	movs	r2, #1
 8021f22:	745a      	strb	r2, [r3, #17]
            sm_notify_client_passkey(SM_EVENT_NUMERIC_COMPARISON_REQUEST, sm_conn->sm_handle, sm_conn->sm_peer_addr_type, sm_conn->sm_peer_address, big_endian_read_32(setup->sm_tk, 12));
 8021f24:	687b      	ldr	r3, [r7, #4]
 8021f26:	881c      	ldrh	r4, [r3, #0]
 8021f28:	687b      	ldr	r3, [r7, #4]
 8021f2a:	795d      	ldrb	r5, [r3, #5]
 8021f2c:	687b      	ldr	r3, [r7, #4]
 8021f2e:	1d9e      	adds	r6, r3, #6
 8021f30:	4b11      	ldr	r3, [pc, #68]	; (8021f78 <sm_trigger_user_response+0x15c>)
 8021f32:	681b      	ldr	r3, [r3, #0]
 8021f34:	3317      	adds	r3, #23
 8021f36:	210c      	movs	r1, #12
 8021f38:	4618      	mov	r0, r3
 8021f3a:	f7ed f804 	bl	800ef46 <big_endian_read_32>
 8021f3e:	4603      	mov	r3, r0
 8021f40:	9300      	str	r3, [sp, #0]
 8021f42:	4633      	mov	r3, r6
 8021f44:	462a      	mov	r2, r5
 8021f46:	4621      	mov	r1, r4
 8021f48:	20d4      	movs	r0, #212	; 0xd4
 8021f4a:	f7ff fa69 	bl	8021420 <sm_notify_client_passkey>
            break;
 8021f4e:	e00e      	b.n	8021f6e <sm_trigger_user_response+0x152>
        case JUST_WORKS:
            setup->sm_user_response = SM_USER_RESPONSE_PENDING;
 8021f50:	4b09      	ldr	r3, [pc, #36]	; (8021f78 <sm_trigger_user_response+0x15c>)
 8021f52:	681b      	ldr	r3, [r3, #0]
 8021f54:	2201      	movs	r2, #1
 8021f56:	745a      	strb	r2, [r3, #17]
            sm_notify_client_base(SM_EVENT_JUST_WORKS_REQUEST, sm_conn->sm_handle, sm_conn->sm_peer_addr_type, sm_conn->sm_peer_address);
 8021f58:	687b      	ldr	r3, [r7, #4]
 8021f5a:	8819      	ldrh	r1, [r3, #0]
 8021f5c:	687b      	ldr	r3, [r7, #4]
 8021f5e:	795a      	ldrb	r2, [r3, #5]
 8021f60:	687b      	ldr	r3, [r7, #4]
 8021f62:	3306      	adds	r3, #6
 8021f64:	20d0      	movs	r0, #208	; 0xd0
 8021f66:	f7ff fa3a 	bl	80213de <sm_notify_client_base>
            break;
 8021f6a:	e000      	b.n	8021f6e <sm_trigger_user_response+0x152>
        case OOB:
            // client already provided OOB data, let's skip notification.
            break;
        default:
            btstack_assert(false);
            break;
 8021f6c:	bf00      	nop
    }
}
 8021f6e:	bf00      	nop
 8021f70:	370c      	adds	r7, #12
 8021f72:	46bd      	mov	sp, r7
 8021f74:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021f76:	bf00      	nop
 8021f78:	200000a0 	.word	0x200000a0

08021f7c <sm_key_distribution_all_received>:

static int sm_key_distribution_all_received(sm_connection_t * sm_conn){
 8021f7c:	b580      	push	{r7, lr}
 8021f7e:	b084      	sub	sp, #16
 8021f80:	af00      	add	r7, sp, #0
 8021f82:	6078      	str	r0, [r7, #4]
    int recv_flags;
    if (IS_RESPONDER(sm_conn->sm_role)){
 8021f84:	687b      	ldr	r3, [r7, #4]
 8021f86:	789b      	ldrb	r3, [r3, #2]
 8021f88:	2b00      	cmp	r3, #0
 8021f8a:	d00b      	beq.n	8021fa4 <sm_key_distribution_all_received+0x28>
        // slave / responder
        recv_flags = sm_key_distribution_flags_for_set(sm_pairing_packet_get_initiator_key_distribution(setup->sm_s_pres));
 8021f8c:	4b18      	ldr	r3, [pc, #96]	; (8021ff0 <sm_key_distribution_all_received+0x74>)
 8021f8e:	681b      	ldr	r3, [r3, #0]
 8021f90:	3340      	adds	r3, #64	; 0x40
 8021f92:	4618      	mov	r0, r3
 8021f94:	f7ff f842 	bl	802101c <sm_pairing_packet_get_initiator_key_distribution>
 8021f98:	4603      	mov	r3, r0
 8021f9a:	4618      	mov	r0, r3
 8021f9c:	f7ff fe5e 	bl	8021c5c <sm_key_distribution_flags_for_set>
 8021fa0:	60f8      	str	r0, [r7, #12]
 8021fa2:	e00a      	b.n	8021fba <sm_key_distribution_all_received+0x3e>
    } else {
        // master / initiator
        recv_flags = sm_key_distribution_flags_for_set(sm_pairing_packet_get_responder_key_distribution(setup->sm_s_pres));
 8021fa4:	4b12      	ldr	r3, [pc, #72]	; (8021ff0 <sm_key_distribution_all_received+0x74>)
 8021fa6:	681b      	ldr	r3, [r3, #0]
 8021fa8:	3340      	adds	r3, #64	; 0x40
 8021faa:	4618      	mov	r0, r3
 8021fac:	f7ff f842 	bl	8021034 <sm_pairing_packet_get_responder_key_distribution>
 8021fb0:	4603      	mov	r3, r0
 8021fb2:	4618      	mov	r0, r3
 8021fb4:	f7ff fe52 	bl	8021c5c <sm_key_distribution_flags_for_set>
 8021fb8:	60f8      	str	r0, [r7, #12]
    }

#ifdef ENABLE_LE_SECURE_CONNECTIONS
    // LTK (= encyrption information & master identification) only used exchanged for LE Legacy Connection
    if (setup->sm_use_secure_connections){
 8021fba:	4b0d      	ldr	r3, [pc, #52]	; (8021ff0 <sm_key_distribution_all_received+0x74>)
 8021fbc:	681b      	ldr	r3, [r3, #0]
 8021fbe:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8021fc2:	2b00      	cmp	r3, #0
 8021fc4:	d003      	beq.n	8021fce <sm_key_distribution_all_received+0x52>
        recv_flags &= ~(SM_KEYDIST_FLAG_ENCRYPTION_INFORMATION | SM_KEYDIST_FLAG_MASTER_IDENTIFICATION);
 8021fc6:	68fb      	ldr	r3, [r7, #12]
 8021fc8:	f023 0303 	bic.w	r3, r3, #3
 8021fcc:	60fb      	str	r3, [r7, #12]
    }
#endif

    log_debug("sm_key_distribution_all_received: received 0x%02x, expecting 0x%02x", setup->sm_key_distribution_received_set, recv_flags);
    return (setup->sm_key_distribution_received_set & recv_flags) == recv_flags;
 8021fce:	4b08      	ldr	r3, [pc, #32]	; (8021ff0 <sm_key_distribution_all_received+0x74>)
 8021fd0:	681b      	ldr	r3, [r3, #0]
 8021fd2:	7d5b      	ldrb	r3, [r3, #21]
 8021fd4:	461a      	mov	r2, r3
 8021fd6:	68fb      	ldr	r3, [r7, #12]
 8021fd8:	4013      	ands	r3, r2
 8021fda:	68fa      	ldr	r2, [r7, #12]
 8021fdc:	429a      	cmp	r2, r3
 8021fde:	bf0c      	ite	eq
 8021fe0:	2301      	moveq	r3, #1
 8021fe2:	2300      	movne	r3, #0
 8021fe4:	b2db      	uxtb	r3, r3
}
 8021fe6:	4618      	mov	r0, r3
 8021fe8:	3710      	adds	r7, #16
 8021fea:	46bd      	mov	sp, r7
 8021fec:	bd80      	pop	{r7, pc}
 8021fee:	bf00      	nop
 8021ff0:	200000a0 	.word	0x200000a0

08021ff4 <sm_done_for_handle>:

static void sm_done_for_handle(hci_con_handle_t con_handle){
 8021ff4:	b580      	push	{r7, lr}
 8021ff6:	b084      	sub	sp, #16
 8021ff8:	af02      	add	r7, sp, #8
 8021ffa:	4603      	mov	r3, r0
 8021ffc:	80fb      	strh	r3, [r7, #6]
    if (sm_active_connection_handle == con_handle){
 8021ffe:	4b10      	ldr	r3, [pc, #64]	; (8022040 <sm_done_for_handle+0x4c>)
 8022000:	881b      	ldrh	r3, [r3, #0]
 8022002:	88fa      	ldrh	r2, [r7, #6]
 8022004:	429a      	cmp	r2, r3
 8022006:	d116      	bne.n	8022036 <sm_done_for_handle+0x42>
        sm_timeout_stop();
 8022008:	f7ff fbbc 	bl	8021784 <sm_timeout_stop>
        sm_active_connection_handle = HCI_CON_HANDLE_INVALID;
 802200c:	4b0c      	ldr	r3, [pc, #48]	; (8022040 <sm_done_for_handle+0x4c>)
 802200e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8022012:	801a      	strh	r2, [r3, #0]
        log_info("sm: connection 0x%x released setup context", con_handle);
 8022014:	88fb      	ldrh	r3, [r7, #6]
 8022016:	9300      	str	r3, [sp, #0]
 8022018:	f240 4344 	movw	r3, #1092	; 0x444
 802201c:	4a09      	ldr	r2, [pc, #36]	; (8022044 <sm_done_for_handle+0x50>)
 802201e:	490a      	ldr	r1, [pc, #40]	; (8022048 <sm_done_for_handle+0x54>)
 8022020:	2001      	movs	r0, #1
 8022022:	f7f5 fa0d 	bl	8017440 <hci_dump_log>

#ifdef ENABLE_LE_SECURE_CONNECTIONS
        // generate new ec key after each pairing (that used it)
        if (setup->sm_use_secure_connections){
 8022026:	4b09      	ldr	r3, [pc, #36]	; (802204c <sm_done_for_handle+0x58>)
 8022028:	681b      	ldr	r3, [r3, #0]
 802202a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 802202e:	2b00      	cmp	r3, #0
 8022030:	d001      	beq.n	8022036 <sm_done_for_handle+0x42>
            sm_ec_generate_new_key();
 8022032:	f004 fff9 	bl	8027028 <sm_ec_generate_new_key>
        }
#endif
    }
}
 8022036:	bf00      	nop
 8022038:	3708      	adds	r7, #8
 802203a:	46bd      	mov	sp, r7
 802203c:	bd80      	pop	{r7, pc}
 802203e:	bf00      	nop
 8022040:	200000a4 	.word	0x200000a4
 8022044:	0802d4a8 	.word	0x0802d4a8
 8022048:	0802d600 	.word	0x0802d600
 802204c:	200000a0 	.word	0x200000a0

08022050 <sm_master_pairing_success>:

static void sm_master_pairing_success(sm_connection_t *connection) {// master -> all done
 8022050:	b580      	push	{r7, lr}
 8022052:	b082      	sub	sp, #8
 8022054:	af00      	add	r7, sp, #0
 8022056:	6078      	str	r0, [r7, #4]
    connection->sm_engine_state = SM_INITIATOR_CONNECTED;
 8022058:	687b      	ldr	r3, [r7, #4]
 802205a:	2229      	movs	r2, #41	; 0x29
 802205c:	731a      	strb	r2, [r3, #12]
    sm_pairing_complete(connection, ERROR_CODE_SUCCESS, 0);
 802205e:	2200      	movs	r2, #0
 8022060:	2100      	movs	r1, #0
 8022062:	6878      	ldr	r0, [r7, #4]
 8022064:	f7ff fb04 	bl	8021670 <sm_pairing_complete>
    sm_done_for_handle(connection->sm_handle);
 8022068:	687b      	ldr	r3, [r7, #4]
 802206a:	881b      	ldrh	r3, [r3, #0]
 802206c:	4618      	mov	r0, r3
 802206e:	f7ff ffc1 	bl	8021ff4 <sm_done_for_handle>
}
 8022072:	bf00      	nop
 8022074:	3708      	adds	r7, #8
 8022076:	46bd      	mov	sp, r7
 8022078:	bd80      	pop	{r7, pc}
	...

0802207c <sm_key_distribution_flags_for_auth_req>:

static int sm_key_distribution_flags_for_auth_req(void){
 802207c:	b480      	push	{r7}
 802207e:	b083      	sub	sp, #12
 8022080:	af00      	add	r7, sp, #0

    int flags = SM_KEYDIST_ID_KEY;
 8022082:	2302      	movs	r3, #2
 8022084:	607b      	str	r3, [r7, #4]
    if (sm_auth_req & SM_AUTHREQ_BONDING){
 8022086:	4b08      	ldr	r3, [pc, #32]	; (80220a8 <sm_key_distribution_flags_for_auth_req+0x2c>)
 8022088:	781b      	ldrb	r3, [r3, #0]
 802208a:	f003 0301 	and.w	r3, r3, #1
 802208e:	2b00      	cmp	r3, #0
 8022090:	d003      	beq.n	802209a <sm_key_distribution_flags_for_auth_req+0x1e>
        // encryption and signing information only if bonding requested
        flags |= SM_KEYDIST_ENC_KEY;
 8022092:	687b      	ldr	r3, [r7, #4]
 8022094:	f043 0301 	orr.w	r3, r3, #1
 8022098:	607b      	str	r3, [r7, #4]
        if (sm_auth_req & SM_AUTHREQ_SECURE_CONNECTION){
        	flags |= SM_KEYDIST_LINK_KEY;
        }
#endif
    }
    return flags;
 802209a:	687b      	ldr	r3, [r7, #4]
}
 802209c:	4618      	mov	r0, r3
 802209e:	370c      	adds	r7, #12
 80220a0:	46bd      	mov	sp, r7
 80220a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80220a6:	4770      	bx	lr
 80220a8:	20009f46 	.word	0x20009f46

080220ac <sm_reset_setup>:

static void sm_reset_setup(void){
 80220ac:	b580      	push	{r7, lr}
 80220ae:	af00      	add	r7, sp, #0
    // fill in sm setup
    setup->sm_state_vars = 0;
 80220b0:	4b06      	ldr	r3, [pc, #24]	; (80220cc <sm_reset_setup+0x20>)
 80220b2:	681b      	ldr	r3, [r3, #0]
 80220b4:	2200      	movs	r2, #0
 80220b6:	f883 20a5 	strb.w	r2, [r3, #165]	; 0xa5
    setup->sm_keypress_notification = 0;
 80220ba:	4b04      	ldr	r3, [pc, #16]	; (80220cc <sm_reset_setup+0x20>)
 80220bc:	681b      	ldr	r3, [r3, #0]
 80220be:	2200      	movs	r2, #0
 80220c0:	749a      	strb	r2, [r3, #18]
    sm_reset_tk();
 80220c2:	f7ff f88f 	bl	80211e4 <sm_reset_tk>
}
 80220c6:	bf00      	nop
 80220c8:	bd80      	pop	{r7, pc}
 80220ca:	bf00      	nop
 80220cc:	200000a0 	.word	0x200000a0

080220d0 <sm_init_setup>:

static void sm_init_setup(sm_connection_t * sm_conn){
 80220d0:	b590      	push	{r4, r7, lr}
 80220d2:	b087      	sub	sp, #28
 80220d4:	af00      	add	r7, sp, #0
 80220d6:	6078      	str	r0, [r7, #4]

    // fill in sm setup
    setup->sm_peer_addr_type = sm_conn->sm_peer_addr_type;
 80220d8:	4b7c      	ldr	r3, [pc, #496]	; (80222cc <sm_init_setup+0x1fc>)
 80220da:	681b      	ldr	r3, [r3, #0]
 80220dc:	687a      	ldr	r2, [r7, #4]
 80220de:	7952      	ldrb	r2, [r2, #5]
 80220e0:	f883 2204 	strb.w	r2, [r3, #516]	; 0x204
    (void)memcpy(setup->sm_peer_address, sm_conn->sm_peer_address, 6);
 80220e4:	4b79      	ldr	r3, [pc, #484]	; (80222cc <sm_init_setup+0x1fc>)
 80220e6:	681b      	ldr	r3, [r3, #0]
 80220e8:	f203 2005 	addw	r0, r3, #517	; 0x205
 80220ec:	687b      	ldr	r3, [r7, #4]
 80220ee:	3306      	adds	r3, #6
 80220f0:	2206      	movs	r2, #6
 80220f2:	4619      	mov	r1, r3
 80220f4:	f005 fcc1 	bl	8027a7a <memcpy>

    // query client for Legacy Pairing OOB data
    setup->sm_have_oob_data = 0;
 80220f8:	4b74      	ldr	r3, [pc, #464]	; (80222cc <sm_init_setup+0x1fc>)
 80220fa:	681b      	ldr	r3, [r3, #0]
 80220fc:	2200      	movs	r2, #0
 80220fe:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
    if (sm_get_oob_data != NULL) {
 8022102:	4b73      	ldr	r3, [pc, #460]	; (80222d0 <sm_init_setup+0x200>)
 8022104:	681b      	ldr	r3, [r3, #0]
 8022106:	2b00      	cmp	r3, #0
 8022108:	d00f      	beq.n	802212a <sm_init_setup+0x5a>
        setup->sm_have_oob_data = (*sm_get_oob_data)(sm_conn->sm_peer_addr_type, sm_conn->sm_peer_address, setup->sm_tk);
 802210a:	4b71      	ldr	r3, [pc, #452]	; (80222d0 <sm_init_setup+0x200>)
 802210c:	681b      	ldr	r3, [r3, #0]
 802210e:	687a      	ldr	r2, [r7, #4]
 8022110:	7950      	ldrb	r0, [r2, #5]
 8022112:	687a      	ldr	r2, [r7, #4]
 8022114:	1d91      	adds	r1, r2, #6
 8022116:	4a6d      	ldr	r2, [pc, #436]	; (80222cc <sm_init_setup+0x1fc>)
 8022118:	6812      	ldr	r2, [r2, #0]
 802211a:	3217      	adds	r2, #23
 802211c:	4798      	blx	r3
 802211e:	4602      	mov	r2, r0
 8022120:	4b6a      	ldr	r3, [pc, #424]	; (80222cc <sm_init_setup+0x1fc>)
 8022122:	681b      	ldr	r3, [r3, #0]
 8022124:	b2d2      	uxtb	r2, r2
 8022126:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
    }

    // if available and SC supported, also ask for SC OOB Data
#ifdef ENABLE_LE_SECURE_CONNECTIONS
    memset(setup->sm_ra, 0, 16);
 802212a:	4b68      	ldr	r3, [pc, #416]	; (80222cc <sm_init_setup+0x1fc>)
 802212c:	681b      	ldr	r3, [r3, #0]
 802212e:	f503 73a3 	add.w	r3, r3, #326	; 0x146
 8022132:	2210      	movs	r2, #16
 8022134:	2100      	movs	r1, #0
 8022136:	4618      	mov	r0, r3
 8022138:	f005 fcc3 	bl	8027ac2 <memset>
    memset(setup->sm_rb, 0, 16);
 802213c:	4b63      	ldr	r3, [pc, #396]	; (80222cc <sm_init_setup+0x1fc>)
 802213e:	681b      	ldr	r3, [r3, #0]
 8022140:	f503 73ab 	add.w	r3, r3, #342	; 0x156
 8022144:	2210      	movs	r2, #16
 8022146:	2100      	movs	r1, #0
 8022148:	4618      	mov	r0, r3
 802214a:	f005 fcba 	bl	8027ac2 <memset>
    if (setup->sm_have_oob_data && (sm_auth_req & SM_AUTHREQ_SECURE_CONNECTION)){
 802214e:	4b5f      	ldr	r3, [pc, #380]	; (80222cc <sm_init_setup+0x1fc>)
 8022150:	681b      	ldr	r3, [r3, #0]
 8022152:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8022156:	2b00      	cmp	r3, #0
 8022158:	d03e      	beq.n	80221d8 <sm_init_setup+0x108>
 802215a:	4b5e      	ldr	r3, [pc, #376]	; (80222d4 <sm_init_setup+0x204>)
 802215c:	781b      	ldrb	r3, [r3, #0]
 802215e:	f003 0308 	and.w	r3, r3, #8
 8022162:	2b00      	cmp	r3, #0
 8022164:	d038      	beq.n	80221d8 <sm_init_setup+0x108>
        if (sm_get_sc_oob_data != NULL){
 8022166:	4b5c      	ldr	r3, [pc, #368]	; (80222d8 <sm_init_setup+0x208>)
 8022168:	681b      	ldr	r3, [r3, #0]
 802216a:	2b00      	cmp	r3, #0
 802216c:	d02f      	beq.n	80221ce <sm_init_setup+0xfe>
            if (IS_RESPONDER(sm_conn->sm_role)){
 802216e:	687b      	ldr	r3, [r7, #4]
 8022170:	789b      	ldrb	r3, [r3, #2]
 8022172:	2b00      	cmp	r3, #0
 8022174:	d015      	beq.n	80221a2 <sm_init_setup+0xd2>
                setup->sm_have_oob_data = (*sm_get_sc_oob_data)(
 8022176:	4b58      	ldr	r3, [pc, #352]	; (80222d8 <sm_init_setup+0x208>)
 8022178:	681c      	ldr	r4, [r3, #0]
 802217a:	687b      	ldr	r3, [r7, #4]
 802217c:	7958      	ldrb	r0, [r3, #5]
                    sm_conn->sm_peer_addr_type,
                    sm_conn->sm_peer_address,
 802217e:	687b      	ldr	r3, [r7, #4]
 8022180:	1d99      	adds	r1, r3, #6
                    setup->sm_peer_confirm,
 8022182:	4b52      	ldr	r3, [pc, #328]	; (80222cc <sm_init_setup+0x1fc>)
 8022184:	681b      	ldr	r3, [r3, #0]
 8022186:	f103 0277 	add.w	r2, r3, #119	; 0x77
                    setup->sm_ra);
 802218a:	4b50      	ldr	r3, [pc, #320]	; (80222cc <sm_init_setup+0x1fc>)
 802218c:	681b      	ldr	r3, [r3, #0]
 802218e:	f503 73a3 	add.w	r3, r3, #326	; 0x146
                setup->sm_have_oob_data = (*sm_get_sc_oob_data)(
 8022192:	47a0      	blx	r4
 8022194:	4602      	mov	r2, r0
 8022196:	4b4d      	ldr	r3, [pc, #308]	; (80222cc <sm_init_setup+0x1fc>)
 8022198:	681b      	ldr	r3, [r3, #0]
 802219a:	b2d2      	uxtb	r2, r2
 802219c:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
 80221a0:	e01a      	b.n	80221d8 <sm_init_setup+0x108>
            } else {
                setup->sm_have_oob_data = (*sm_get_sc_oob_data)(
 80221a2:	4b4d      	ldr	r3, [pc, #308]	; (80222d8 <sm_init_setup+0x208>)
 80221a4:	681c      	ldr	r4, [r3, #0]
 80221a6:	687b      	ldr	r3, [r7, #4]
 80221a8:	7958      	ldrb	r0, [r3, #5]
                    sm_conn->sm_peer_addr_type,
                    sm_conn->sm_peer_address,
 80221aa:	687b      	ldr	r3, [r7, #4]
 80221ac:	1d99      	adds	r1, r3, #6
                    setup->sm_peer_confirm,
 80221ae:	4b47      	ldr	r3, [pc, #284]	; (80222cc <sm_init_setup+0x1fc>)
 80221b0:	681b      	ldr	r3, [r3, #0]
 80221b2:	f103 0277 	add.w	r2, r3, #119	; 0x77
                    setup->sm_rb);
 80221b6:	4b45      	ldr	r3, [pc, #276]	; (80222cc <sm_init_setup+0x1fc>)
 80221b8:	681b      	ldr	r3, [r3, #0]
 80221ba:	f503 73ab 	add.w	r3, r3, #342	; 0x156
                setup->sm_have_oob_data = (*sm_get_sc_oob_data)(
 80221be:	47a0      	blx	r4
 80221c0:	4602      	mov	r2, r0
 80221c2:	4b42      	ldr	r3, [pc, #264]	; (80222cc <sm_init_setup+0x1fc>)
 80221c4:	681b      	ldr	r3, [r3, #0]
 80221c6:	b2d2      	uxtb	r2, r2
 80221c8:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
 80221cc:	e004      	b.n	80221d8 <sm_init_setup+0x108>
            }
        } else {
            setup->sm_have_oob_data = 0;
 80221ce:	4b3f      	ldr	r3, [pc, #252]	; (80222cc <sm_init_setup+0x1fc>)
 80221d0:	681b      	ldr	r3, [r3, #0]
 80221d2:	2200      	movs	r2, #0
 80221d4:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
        }
    }
#endif

    sm_pairing_packet_t * local_packet;
    if (IS_RESPONDER(sm_conn->sm_role)){
 80221d8:	687b      	ldr	r3, [r7, #4]
 80221da:	789b      	ldrb	r3, [r3, #2]
 80221dc:	2b00      	cmp	r3, #0
 80221de:	d01f      	beq.n	8022220 <sm_init_setup+0x150>
        // slave
        local_packet = &setup->sm_s_pres;
 80221e0:	4b3a      	ldr	r3, [pc, #232]	; (80222cc <sm_init_setup+0x1fc>)
 80221e2:	681b      	ldr	r3, [r3, #0]
 80221e4:	3340      	adds	r3, #64	; 0x40
 80221e6:	617b      	str	r3, [r7, #20]
        gap_le_get_own_address(&setup->sm_s_addr_type, setup->sm_s_address);
 80221e8:	4b38      	ldr	r3, [pc, #224]	; (80222cc <sm_init_setup+0x1fc>)
 80221ea:	681b      	ldr	r3, [r3, #0]
 80221ec:	f103 0288 	add.w	r2, r3, #136	; 0x88
 80221f0:	4b36      	ldr	r3, [pc, #216]	; (80222cc <sm_init_setup+0x1fc>)
 80221f2:	681b      	ldr	r3, [r3, #0]
 80221f4:	338f      	adds	r3, #143	; 0x8f
 80221f6:	4619      	mov	r1, r3
 80221f8:	4610      	mov	r0, r2
 80221fa:	f7ee fb47 	bl	801088c <gap_le_get_own_address>
        setup->sm_m_addr_type = sm_conn->sm_peer_addr_type;
 80221fe:	4b33      	ldr	r3, [pc, #204]	; (80222cc <sm_init_setup+0x1fc>)
 8022200:	681b      	ldr	r3, [r3, #0]
 8022202:	687a      	ldr	r2, [r7, #4]
 8022204:	7952      	ldrb	r2, [r2, #5]
 8022206:	f883 2087 	strb.w	r2, [r3, #135]	; 0x87
        (void)memcpy(setup->sm_m_address, sm_conn->sm_peer_address, 6);
 802220a:	4b30      	ldr	r3, [pc, #192]	; (80222cc <sm_init_setup+0x1fc>)
 802220c:	681b      	ldr	r3, [r3, #0]
 802220e:	f103 0089 	add.w	r0, r3, #137	; 0x89
 8022212:	687b      	ldr	r3, [r7, #4]
 8022214:	3306      	adds	r3, #6
 8022216:	2206      	movs	r2, #6
 8022218:	4619      	mov	r1, r3
 802221a:	f005 fc2e 	bl	8027a7a <memcpy>
 802221e:	e033      	b.n	8022288 <sm_init_setup+0x1b8>
    } else {
        // master
        local_packet = &setup->sm_m_preq;
 8022220:	4b2a      	ldr	r3, [pc, #168]	; (80222cc <sm_init_setup+0x1fc>)
 8022222:	681b      	ldr	r3, [r3, #0]
 8022224:	3339      	adds	r3, #57	; 0x39
 8022226:	617b      	str	r3, [r7, #20]
        gap_le_get_own_address(&setup->sm_m_addr_type, setup->sm_m_address);
 8022228:	4b28      	ldr	r3, [pc, #160]	; (80222cc <sm_init_setup+0x1fc>)
 802222a:	681b      	ldr	r3, [r3, #0]
 802222c:	f103 0287 	add.w	r2, r3, #135	; 0x87
 8022230:	4b26      	ldr	r3, [pc, #152]	; (80222cc <sm_init_setup+0x1fc>)
 8022232:	681b      	ldr	r3, [r3, #0]
 8022234:	3389      	adds	r3, #137	; 0x89
 8022236:	4619      	mov	r1, r3
 8022238:	4610      	mov	r0, r2
 802223a:	f7ee fb27 	bl	801088c <gap_le_get_own_address>
        setup->sm_s_addr_type = sm_conn->sm_peer_addr_type;
 802223e:	4b23      	ldr	r3, [pc, #140]	; (80222cc <sm_init_setup+0x1fc>)
 8022240:	681b      	ldr	r3, [r3, #0]
 8022242:	687a      	ldr	r2, [r7, #4]
 8022244:	7952      	ldrb	r2, [r2, #5]
 8022246:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
        (void)memcpy(setup->sm_s_address, sm_conn->sm_peer_address, 6);
 802224a:	4b20      	ldr	r3, [pc, #128]	; (80222cc <sm_init_setup+0x1fc>)
 802224c:	681b      	ldr	r3, [r3, #0]
 802224e:	f103 008f 	add.w	r0, r3, #143	; 0x8f
 8022252:	687b      	ldr	r3, [r7, #4]
 8022254:	3306      	adds	r3, #6
 8022256:	2206      	movs	r2, #6
 8022258:	4619      	mov	r1, r3
 802225a:	f005 fc0e 	bl	8027a7a <memcpy>

        int key_distribution_flags = sm_key_distribution_flags_for_auth_req();
 802225e:	f7ff ff0d 	bl	802207c <sm_key_distribution_flags_for_auth_req>
 8022262:	6138      	str	r0, [r7, #16]
        sm_pairing_packet_set_initiator_key_distribution(setup->sm_m_preq, key_distribution_flags);
 8022264:	4b19      	ldr	r3, [pc, #100]	; (80222cc <sm_init_setup+0x1fc>)
 8022266:	681b      	ldr	r3, [r3, #0]
 8022268:	3339      	adds	r3, #57	; 0x39
 802226a:	693a      	ldr	r2, [r7, #16]
 802226c:	b2d2      	uxtb	r2, r2
 802226e:	4611      	mov	r1, r2
 8022270:	4618      	mov	r0, r3
 8022272:	f7fe ff3a 	bl	80210ea <sm_pairing_packet_set_initiator_key_distribution>
        sm_pairing_packet_set_responder_key_distribution(setup->sm_m_preq, key_distribution_flags);
 8022276:	4b15      	ldr	r3, [pc, #84]	; (80222cc <sm_init_setup+0x1fc>)
 8022278:	681b      	ldr	r3, [r3, #0]
 802227a:	3339      	adds	r3, #57	; 0x39
 802227c:	693a      	ldr	r2, [r7, #16]
 802227e:	b2d2      	uxtb	r2, r2
 8022280:	4611      	mov	r1, r2
 8022282:	4618      	mov	r0, r3
 8022284:	f7fe ff41 	bl	802110a <sm_pairing_packet_set_responder_key_distribution>
    }

    uint8_t auth_req = sm_auth_req & ~SM_AUTHREQ_CT2;
 8022288:	4b12      	ldr	r3, [pc, #72]	; (80222d4 <sm_init_setup+0x204>)
 802228a:	781b      	ldrb	r3, [r3, #0]
 802228c:	f023 0320 	bic.w	r3, r3, #32
 8022290:	73fb      	strb	r3, [r7, #15]
	const uint8_t auth_req_for_ct2 = SM_AUTHREQ_SECURE_CONNECTION | SM_AUTHREQ_BONDING;
	if ((auth_req & auth_req_for_ct2) == auth_req_for_ct2){
		auth_req |= SM_AUTHREQ_CT2;
	}
#endif
    sm_pairing_packet_set_io_capability(*local_packet, sm_io_capabilities);
 8022292:	4b12      	ldr	r3, [pc, #72]	; (80222dc <sm_init_setup+0x20c>)
 8022294:	781b      	ldrb	r3, [r3, #0]
 8022296:	4619      	mov	r1, r3
 8022298:	6978      	ldr	r0, [r7, #20]
 802229a:	f7fe fee6 	bl	802106a <sm_pairing_packet_set_io_capability>
    sm_pairing_packet_set_oob_data_flag(*local_packet, setup->sm_have_oob_data);
 802229e:	4b0b      	ldr	r3, [pc, #44]	; (80222cc <sm_init_setup+0x1fc>)
 80222a0:	681b      	ldr	r3, [r3, #0]
 80222a2:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 80222a6:	4619      	mov	r1, r3
 80222a8:	6978      	ldr	r0, [r7, #20]
 80222aa:	f7fe feee 	bl	802108a <sm_pairing_packet_set_oob_data_flag>
    sm_pairing_packet_set_auth_req(*local_packet, auth_req);
 80222ae:	7bfb      	ldrb	r3, [r7, #15]
 80222b0:	4619      	mov	r1, r3
 80222b2:	6978      	ldr	r0, [r7, #20]
 80222b4:	f7fe fef9 	bl	80210aa <sm_pairing_packet_set_auth_req>
    sm_pairing_packet_set_max_encryption_key_size(*local_packet, sm_max_encryption_key_size);
 80222b8:	4b09      	ldr	r3, [pc, #36]	; (80222e0 <sm_init_setup+0x210>)
 80222ba:	781b      	ldrb	r3, [r3, #0]
 80222bc:	4619      	mov	r1, r3
 80222be:	6978      	ldr	r0, [r7, #20]
 80222c0:	f7fe ff03 	bl	80210ca <sm_pairing_packet_set_max_encryption_key_size>
}
 80222c4:	bf00      	nop
 80222c6:	371c      	adds	r7, #28
 80222c8:	46bd      	mov	sp, r7
 80222ca:	bd90      	pop	{r4, r7, pc}
 80222cc:	200000a0 	.word	0x200000a0
 80222d0:	2000a35c 	.word	0x2000a35c
 80222d4:	20009f46 	.word	0x20009f46
 80222d8:	2000a360 	.word	0x2000a360
 80222dc:	2000009e 	.word	0x2000009e
 80222e0:	20009f44 	.word	0x20009f44

080222e4 <sm_stk_generation_init>:

static int sm_stk_generation_init(sm_connection_t * sm_conn){
 80222e4:	b580      	push	{r7, lr}
 80222e6:	b086      	sub	sp, #24
 80222e8:	af02      	add	r7, sp, #8
 80222ea:	6078      	str	r0, [r7, #4]

    sm_pairing_packet_t * remote_packet;
    int                   remote_key_request;
    if (IS_RESPONDER(sm_conn->sm_role)){
 80222ec:	687b      	ldr	r3, [r7, #4]
 80222ee:	789b      	ldrb	r3, [r3, #2]
 80222f0:	2b00      	cmp	r3, #0
 80222f2:	d00c      	beq.n	802230e <sm_stk_generation_init+0x2a>
        // slave / responder
        remote_packet      = &setup->sm_m_preq;
 80222f4:	4b37      	ldr	r3, [pc, #220]	; (80223d4 <sm_stk_generation_init+0xf0>)
 80222f6:	681b      	ldr	r3, [r3, #0]
 80222f8:	3339      	adds	r3, #57	; 0x39
 80222fa:	60fb      	str	r3, [r7, #12]
        remote_key_request = sm_pairing_packet_get_responder_key_distribution(setup->sm_m_preq);
 80222fc:	4b35      	ldr	r3, [pc, #212]	; (80223d4 <sm_stk_generation_init+0xf0>)
 80222fe:	681b      	ldr	r3, [r3, #0]
 8022300:	3339      	adds	r3, #57	; 0x39
 8022302:	4618      	mov	r0, r3
 8022304:	f7fe fe96 	bl	8021034 <sm_pairing_packet_get_responder_key_distribution>
 8022308:	4603      	mov	r3, r0
 802230a:	60bb      	str	r3, [r7, #8]
 802230c:	e00b      	b.n	8022326 <sm_stk_generation_init+0x42>
    } else {
        // master / initiator
        remote_packet      = &setup->sm_s_pres;
 802230e:	4b31      	ldr	r3, [pc, #196]	; (80223d4 <sm_stk_generation_init+0xf0>)
 8022310:	681b      	ldr	r3, [r3, #0]
 8022312:	3340      	adds	r3, #64	; 0x40
 8022314:	60fb      	str	r3, [r7, #12]
        remote_key_request = sm_pairing_packet_get_initiator_key_distribution(setup->sm_s_pres);
 8022316:	4b2f      	ldr	r3, [pc, #188]	; (80223d4 <sm_stk_generation_init+0xf0>)
 8022318:	681b      	ldr	r3, [r3, #0]
 802231a:	3340      	adds	r3, #64	; 0x40
 802231c:	4618      	mov	r0, r3
 802231e:	f7fe fe7d 	bl	802101c <sm_pairing_packet_get_initiator_key_distribution>
 8022322:	4603      	mov	r3, r0
 8022324:	60bb      	str	r3, [r7, #8]
    }

    // check key size
    sm_conn->sm_actual_encryption_key_size = sm_calc_actual_encryption_key_size(sm_pairing_packet_get_max_encryption_key_size(*remote_packet));
 8022326:	68f8      	ldr	r0, [r7, #12]
 8022328:	f7fe fe6c 	bl	8021004 <sm_pairing_packet_get_max_encryption_key_size>
 802232c:	4603      	mov	r3, r0
 802232e:	4618      	mov	r0, r3
 8022330:	f004 f80a 	bl	8026348 <sm_calc_actual_encryption_key_size>
 8022334:	4603      	mov	r3, r0
 8022336:	b2da      	uxtb	r2, r3
 8022338:	687b      	ldr	r3, [r7, #4]
 802233a:	745a      	strb	r2, [r3, #17]
    if (sm_conn->sm_actual_encryption_key_size == 0u) return SM_REASON_ENCRYPTION_KEY_SIZE;
 802233c:	687b      	ldr	r3, [r7, #4]
 802233e:	7c5b      	ldrb	r3, [r3, #17]
 8022340:	2b00      	cmp	r3, #0
 8022342:	d101      	bne.n	8022348 <sm_stk_generation_init+0x64>
 8022344:	2306      	movs	r3, #6
 8022346:	e041      	b.n	80223cc <sm_stk_generation_init+0xe8>

    // decide on STK generation method / SC
    sm_setup_tk();
 8022348:	f7ff fb86 	bl	8021a58 <sm_setup_tk>
    log_info("SMP: generation method %u", setup->sm_stk_generation_method);
 802234c:	4b21      	ldr	r3, [pc, #132]	; (80223d4 <sm_stk_generation_init+0xf0>)
 802234e:	681b      	ldr	r3, [r3, #0]
 8022350:	7d9b      	ldrb	r3, [r3, #22]
 8022352:	9300      	str	r3, [sp, #0]
 8022354:	f240 43c9 	movw	r3, #1225	; 0x4c9
 8022358:	4a1f      	ldr	r2, [pc, #124]	; (80223d8 <sm_stk_generation_init+0xf4>)
 802235a:	4920      	ldr	r1, [pc, #128]	; (80223dc <sm_stk_generation_init+0xf8>)
 802235c:	2001      	movs	r0, #1
 802235e:	f7f5 f86f 	bl	8017440 <hci_dump_log>

    // check if STK generation method is acceptable by client
    if (!sm_validate_stk_generation_method()) return SM_REASON_AUTHENTHICATION_REQUIREMENTS;
 8022362:	f004 f847 	bl	80263f4 <sm_validate_stk_generation_method>
 8022366:	4603      	mov	r3, r0
 8022368:	2b00      	cmp	r3, #0
 802236a:	d101      	bne.n	8022370 <sm_stk_generation_init+0x8c>
 802236c:	2303      	movs	r3, #3
 802236e:	e02d      	b.n	80223cc <sm_stk_generation_init+0xe8>

#ifdef ENABLE_LE_SECURE_CONNECTIONS
    // check LE SC Only mode
    if (sm_sc_only_mode && (setup->sm_use_secure_connections == false)){
 8022370:	4b1b      	ldr	r3, [pc, #108]	; (80223e0 <sm_stk_generation_init+0xfc>)
 8022372:	781b      	ldrb	r3, [r3, #0]
 8022374:	2b00      	cmp	r3, #0
 8022376:	d00e      	beq.n	8022396 <sm_stk_generation_init+0xb2>
 8022378:	4b16      	ldr	r3, [pc, #88]	; (80223d4 <sm_stk_generation_init+0xf0>)
 802237a:	681b      	ldr	r3, [r3, #0]
 802237c:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8022380:	2b00      	cmp	r3, #0
 8022382:	d108      	bne.n	8022396 <sm_stk_generation_init+0xb2>
        log_info("SC Only mode active but SC not possible");
 8022384:	f240 43d1 	movw	r3, #1233	; 0x4d1
 8022388:	4a13      	ldr	r2, [pc, #76]	; (80223d8 <sm_stk_generation_init+0xf4>)
 802238a:	4916      	ldr	r1, [pc, #88]	; (80223e4 <sm_stk_generation_init+0x100>)
 802238c:	2001      	movs	r0, #1
 802238e:	f7f5 f857 	bl	8017440 <hci_dump_log>
        return SM_REASON_AUTHENTHICATION_REQUIREMENTS;
 8022392:	2303      	movs	r3, #3
 8022394:	e01a      	b.n	80223cc <sm_stk_generation_init+0xe8>
    }

    // LTK (= encyrption information & master identification) only used exchanged for LE Legacy Connection
    if (setup->sm_use_secure_connections){
 8022396:	4b0f      	ldr	r3, [pc, #60]	; (80223d4 <sm_stk_generation_init+0xf0>)
 8022398:	681b      	ldr	r3, [r3, #0]
 802239a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 802239e:	2b00      	cmp	r3, #0
 80223a0:	d003      	beq.n	80223aa <sm_stk_generation_init+0xc6>
        remote_key_request &= ~SM_KEYDIST_ENC_KEY;
 80223a2:	68bb      	ldr	r3, [r7, #8]
 80223a4:	f023 0301 	bic.w	r3, r3, #1
 80223a8:	60bb      	str	r3, [r7, #8]
    }
#endif

    // identical to responder
    sm_setup_key_distribution(remote_key_request);
 80223aa:	68bb      	ldr	r3, [r7, #8]
 80223ac:	b2db      	uxtb	r3, r3
 80223ae:	4618      	mov	r0, r3
 80223b0:	f7ff fc86 	bl	8021cc0 <sm_setup_key_distribution>

    // JUST WORKS doens't provide authentication
    sm_conn->sm_connection_authenticated = (setup->sm_stk_generation_method == JUST_WORKS) ? 0 : 1;
 80223b4:	4b07      	ldr	r3, [pc, #28]	; (80223d4 <sm_stk_generation_init+0xf0>)
 80223b6:	681b      	ldr	r3, [r3, #0]
 80223b8:	7d9b      	ldrb	r3, [r3, #22]
 80223ba:	2b00      	cmp	r3, #0
 80223bc:	bf14      	ite	ne
 80223be:	2301      	movne	r3, #1
 80223c0:	2300      	moveq	r3, #0
 80223c2:	b2db      	uxtb	r3, r3
 80223c4:	461a      	mov	r2, r3
 80223c6:	687b      	ldr	r3, [r7, #4]
 80223c8:	73da      	strb	r2, [r3, #15]

    return 0;
 80223ca:	2300      	movs	r3, #0
}
 80223cc:	4618      	mov	r0, r3
 80223ce:	3710      	adds	r7, #16
 80223d0:	46bd      	mov	sp, r7
 80223d2:	bd80      	pop	{r7, pc}
 80223d4:	200000a0 	.word	0x200000a0
 80223d8:	0802d4a8 	.word	0x0802d4a8
 80223dc:	0802d634 	.word	0x0802d634
 80223e0:	20009f4d 	.word	0x20009f4d
 80223e4:	0802d658 	.word	0x0802d658

080223e8 <sm_address_resolution_handle_event>:

static void sm_address_resolution_handle_event(address_resolution_event_t event){
 80223e8:	b580      	push	{r7, lr}
 80223ea:	b090      	sub	sp, #64	; 0x40
 80223ec:	af04      	add	r7, sp, #16
 80223ee:	4603      	mov	r3, r0
 80223f0:	71fb      	strb	r3, [r7, #7]

    // cache and reset context
    int matched_device_id = sm_address_resolution_test;
 80223f2:	4ba8      	ldr	r3, [pc, #672]	; (8022694 <sm_address_resolution_handle_event+0x2ac>)
 80223f4:	681b      	ldr	r3, [r3, #0]
 80223f6:	62bb      	str	r3, [r7, #40]	; 0x28
    address_resolution_mode_t mode = sm_address_resolution_mode;
 80223f8:	4ba7      	ldr	r3, [pc, #668]	; (8022698 <sm_address_resolution_handle_event+0x2b0>)
 80223fa:	781b      	ldrb	r3, [r3, #0]
 80223fc:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    void * context = sm_address_resolution_context;
 8022400:	4ba6      	ldr	r3, [pc, #664]	; (802269c <sm_address_resolution_handle_event+0x2b4>)
 8022402:	681b      	ldr	r3, [r3, #0]
 8022404:	623b      	str	r3, [r7, #32]

    // reset context
    sm_address_resolution_mode = ADDRESS_RESOLUTION_IDLE;
 8022406:	4ba4      	ldr	r3, [pc, #656]	; (8022698 <sm_address_resolution_handle_event+0x2b0>)
 8022408:	2200      	movs	r2, #0
 802240a:	701a      	strb	r2, [r3, #0]
    sm_address_resolution_context = NULL;
 802240c:	4ba3      	ldr	r3, [pc, #652]	; (802269c <sm_address_resolution_handle_event+0x2b4>)
 802240e:	2200      	movs	r2, #0
 8022410:	601a      	str	r2, [r3, #0]
    sm_address_resolution_test = -1;
 8022412:	4ba0      	ldr	r3, [pc, #640]	; (8022694 <sm_address_resolution_handle_event+0x2ac>)
 8022414:	f04f 32ff 	mov.w	r2, #4294967295
 8022418:	601a      	str	r2, [r3, #0]
    hci_con_handle_t con_handle = 0;
 802241a:	2300      	movs	r3, #0
 802241c:	85fb      	strh	r3, [r7, #46]	; 0x2e
    sm_key_t ltk;
    bool have_ltk;
#ifdef ENABLE_LE_CENTRAL
    bool trigger_pairing;
#endif
    switch (mode){
 802241e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8022422:	2b01      	cmp	r3, #1
 8022424:	f000 8123 	beq.w	802266e <sm_address_resolution_handle_event+0x286>
 8022428:	2b02      	cmp	r3, #2
 802242a:	d000      	beq.n	802242e <sm_address_resolution_handle_event+0x46>
                    btstack_assert(false);
                    break;
            }
            break;
        default:
            break;
 802242c:	e120      	b.n	8022670 <sm_address_resolution_handle_event+0x288>
            sm_connection = (sm_connection_t *) context;
 802242e:	6a3b      	ldr	r3, [r7, #32]
 8022430:	61fb      	str	r3, [r7, #28]
            con_handle = sm_connection->sm_handle;
 8022432:	69fb      	ldr	r3, [r7, #28]
 8022434:	881b      	ldrh	r3, [r3, #0]
 8022436:	85fb      	strh	r3, [r7, #46]	; 0x2e
            switch (event){
 8022438:	79fb      	ldrb	r3, [r7, #7]
 802243a:	2b00      	cmp	r3, #0
 802243c:	d003      	beq.n	8022446 <sm_address_resolution_handle_event+0x5e>
 802243e:	2b01      	cmp	r3, #1
 8022440:	f000 80d2 	beq.w	80225e8 <sm_address_resolution_handle_event+0x200>
                    break;
 8022444:	e112      	b.n	802266c <sm_address_resolution_handle_event+0x284>
                    sm_connection->sm_irk_lookup_state = IRK_LOOKUP_SUCCEEDED;
 8022446:	69fb      	ldr	r3, [r7, #28]
 8022448:	2203      	movs	r2, #3
 802244a:	735a      	strb	r2, [r3, #13]
                    sm_connection->sm_le_db_index = matched_device_id;
 802244c:	69fb      	ldr	r3, [r7, #28]
 802244e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8022450:	625a      	str	r2, [r3, #36]	; 0x24
                    log_info("ADDRESS_RESOLUTION_SUCCEEDED, index %d", sm_connection->sm_le_db_index);
 8022452:	69fb      	ldr	r3, [r7, #28]
 8022454:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022456:	9300      	str	r3, [sp, #0]
 8022458:	f240 5307 	movw	r3, #1287	; 0x507
 802245c:	4a90      	ldr	r2, [pc, #576]	; (80226a0 <sm_address_resolution_handle_event+0x2b8>)
 802245e:	4991      	ldr	r1, [pc, #580]	; (80226a4 <sm_address_resolution_handle_event+0x2bc>)
 8022460:	2001      	movs	r0, #1
 8022462:	f7f4 ffed 	bl	8017440 <hci_dump_log>
                    le_device_db_encryption_get(sm_connection->sm_le_db_index, NULL, NULL, ltk, NULL, NULL, NULL, NULL);
 8022466:	69fb      	ldr	r3, [r7, #28]
 8022468:	6a58      	ldr	r0, [r3, #36]	; 0x24
 802246a:	f107 0208 	add.w	r2, r7, #8
 802246e:	2300      	movs	r3, #0
 8022470:	9303      	str	r3, [sp, #12]
 8022472:	2300      	movs	r3, #0
 8022474:	9302      	str	r3, [sp, #8]
 8022476:	2300      	movs	r3, #0
 8022478:	9301      	str	r3, [sp, #4]
 802247a:	2300      	movs	r3, #0
 802247c:	9300      	str	r3, [sp, #0]
 802247e:	4613      	mov	r3, r2
 8022480:	2200      	movs	r2, #0
 8022482:	2100      	movs	r1, #0
 8022484:	f7fe fcb8 	bl	8020df8 <le_device_db_encryption_get>
                    have_ltk = !sm_is_null_key(ltk);
 8022488:	f107 0308 	add.w	r3, r7, #8
 802248c:	4618      	mov	r0, r3
 802248e:	f7fe fe77 	bl	8021180 <sm_is_null_key>
 8022492:	4603      	mov	r3, r0
 8022494:	2b00      	cmp	r3, #0
 8022496:	bf14      	ite	ne
 8022498:	2301      	movne	r3, #1
 802249a:	2300      	moveq	r3, #0
 802249c:	b2db      	uxtb	r3, r3
 802249e:	f083 0301 	eor.w	r3, r3, #1
 80224a2:	b2db      	uxtb	r3, r3
 80224a4:	76bb      	strb	r3, [r7, #26]
 80224a6:	7ebb      	ldrb	r3, [r7, #26]
 80224a8:	f003 0301 	and.w	r3, r3, #1
 80224ac:	76bb      	strb	r3, [r7, #26]
                    if (sm_connection->sm_role) {
 80224ae:	69fb      	ldr	r3, [r7, #28]
 80224b0:	789b      	ldrb	r3, [r3, #2]
 80224b2:	2b00      	cmp	r3, #0
 80224b4:	d045      	beq.n	8022542 <sm_address_resolution_handle_event+0x15a>
                        if (sm_connection->sm_engine_state == SM_RESPONDER_PH0_RECEIVED_LTK_W4_IRK){
 80224b6:	69fb      	ldr	r3, [r7, #28]
 80224b8:	7b1b      	ldrb	r3, [r3, #12]
 80224ba:	2b1d      	cmp	r3, #29
 80224bc:	d103      	bne.n	80224c6 <sm_address_resolution_handle_event+0xde>
                            sm_connection->sm_engine_state = SM_RESPONDER_PH0_RECEIVED_LTK_REQUEST;
 80224be:	69fb      	ldr	r3, [r7, #28]
 80224c0:	221c      	movs	r2, #28
 80224c2:	731a      	strb	r2, [r3, #12]
                            break;
 80224c4:	e0d2      	b.n	802266c <sm_address_resolution_handle_event+0x284>
                        if (sm_connection->sm_engine_state == SM_RESPONDER_PH1_PAIRING_REQUEST_RECEIVED_W4_IRK){
 80224c6:	69fb      	ldr	r3, [r7, #28]
 80224c8:	7b1b      	ldrb	r3, [r3, #12]
 80224ca:	2b21      	cmp	r3, #33	; 0x21
 80224cc:	d103      	bne.n	80224d6 <sm_address_resolution_handle_event+0xee>
                            sm_connection->sm_engine_state = SM_RESPONDER_PH1_PAIRING_REQUEST_RECEIVED;
 80224ce:	69fb      	ldr	r3, [r7, #28]
 80224d0:	2220      	movs	r2, #32
 80224d2:	731a      	strb	r2, [r3, #12]
                            break;
 80224d4:	e0ca      	b.n	802266c <sm_address_resolution_handle_event+0x284>
                        bool trigger_security_request = (sm_connection->sm_pairing_requested != 0) || (sm_slave_request_security != 0);
 80224d6:	69fb      	ldr	r3, [r7, #28]
 80224d8:	791b      	ldrb	r3, [r3, #4]
 80224da:	2b00      	cmp	r3, #0
 80224dc:	d103      	bne.n	80224e6 <sm_address_resolution_handle_event+0xfe>
 80224de:	4b72      	ldr	r3, [pc, #456]	; (80226a8 <sm_address_resolution_handle_event+0x2c0>)
 80224e0:	781b      	ldrb	r3, [r3, #0]
 80224e2:	2b00      	cmp	r3, #0
 80224e4:	d001      	beq.n	80224ea <sm_address_resolution_handle_event+0x102>
 80224e6:	2301      	movs	r3, #1
 80224e8:	e000      	b.n	80224ec <sm_address_resolution_handle_event+0x104>
 80224ea:	2300      	movs	r3, #0
 80224ec:	763b      	strb	r3, [r7, #24]
 80224ee:	7e3b      	ldrb	r3, [r7, #24]
 80224f0:	f003 0301 	and.w	r3, r3, #1
 80224f4:	763b      	strb	r3, [r7, #24]
                        sm_connection->sm_pairing_requested = 0;
 80224f6:	69fb      	ldr	r3, [r7, #28]
 80224f8:	2200      	movs	r2, #0
 80224fa:	711a      	strb	r2, [r3, #4]
                        log_info("peripheral: pairing request local %u, have_ltk %u => trigger_security_request %u",
 80224fc:	69fb      	ldr	r3, [r7, #28]
 80224fe:	791b      	ldrb	r3, [r3, #4]
 8022500:	4619      	mov	r1, r3
 8022502:	7ebb      	ldrb	r3, [r7, #26]
 8022504:	7e3a      	ldrb	r2, [r7, #24]
 8022506:	9202      	str	r2, [sp, #8]
 8022508:	9301      	str	r3, [sp, #4]
 802250a:	9100      	str	r1, [sp, #0]
 802250c:	f240 531f 	movw	r3, #1311	; 0x51f
 8022510:	4a63      	ldr	r2, [pc, #396]	; (80226a0 <sm_address_resolution_handle_event+0x2b8>)
 8022512:	4966      	ldr	r1, [pc, #408]	; (80226ac <sm_address_resolution_handle_event+0x2c4>)
 8022514:	2001      	movs	r0, #1
 8022516:	f7f4 ff93 	bl	8017440 <hci_dump_log>
                        if (trigger_security_request){
 802251a:	7e3b      	ldrb	r3, [r7, #24]
 802251c:	2b00      	cmp	r3, #0
 802251e:	f000 80a0 	beq.w	8022662 <sm_address_resolution_handle_event+0x27a>
                            sm_connection->sm_engine_state = SM_RESPONDER_SEND_SECURITY_REQUEST;
 8022522:	69fb      	ldr	r3, [r7, #28]
 8022524:	221b      	movs	r2, #27
 8022526:	731a      	strb	r2, [r3, #12]
                            if (have_ltk){
 8022528:	7ebb      	ldrb	r3, [r7, #26]
 802252a:	2b00      	cmp	r3, #0
 802252c:	d003      	beq.n	8022536 <sm_address_resolution_handle_event+0x14e>
                                sm_reencryption_started(sm_connection);
 802252e:	69f8      	ldr	r0, [r7, #28]
 8022530:	f7fe ffff 	bl	8021532 <sm_reencryption_started>
 8022534:	e002      	b.n	802253c <sm_address_resolution_handle_event+0x154>
                                sm_pairing_started(sm_connection);
 8022536:	69f8      	ldr	r0, [r7, #28]
 8022538:	f7ff f86c 	bl	8021614 <sm_pairing_started>
                            sm_trigger_run();
 802253c:	f7fe fe38 	bl	80211b0 <sm_trigger_run>
                    break;
 8022540:	e08f      	b.n	8022662 <sm_address_resolution_handle_event+0x27a>
                        trigger_pairing = sm_connection->sm_pairing_requested || sm_connection->sm_security_request_received;
 8022542:	69fb      	ldr	r3, [r7, #28]
 8022544:	791b      	ldrb	r3, [r3, #4]
 8022546:	2b00      	cmp	r3, #0
 8022548:	d103      	bne.n	8022552 <sm_address_resolution_handle_event+0x16a>
 802254a:	69fb      	ldr	r3, [r7, #28]
 802254c:	78db      	ldrb	r3, [r3, #3]
 802254e:	2b00      	cmp	r3, #0
 8022550:	d001      	beq.n	8022556 <sm_address_resolution_handle_event+0x16e>
 8022552:	2301      	movs	r3, #1
 8022554:	e000      	b.n	8022558 <sm_address_resolution_handle_event+0x170>
 8022556:	2300      	movs	r3, #0
 8022558:	767b      	strb	r3, [r7, #25]
 802255a:	7e7b      	ldrb	r3, [r7, #25]
 802255c:	f003 0301 	and.w	r3, r3, #1
 8022560:	767b      	strb	r3, [r7, #25]
                        log_info("central: pairing request local %u, remote %u => trigger_pairing %u. have_ltk %u",
 8022562:	69fb      	ldr	r3, [r7, #28]
 8022564:	791b      	ldrb	r3, [r3, #4]
 8022566:	4619      	mov	r1, r3
 8022568:	69fb      	ldr	r3, [r7, #28]
 802256a:	78db      	ldrb	r3, [r3, #3]
 802256c:	4618      	mov	r0, r3
 802256e:	7e7b      	ldrb	r3, [r7, #25]
 8022570:	7eba      	ldrb	r2, [r7, #26]
 8022572:	9203      	str	r2, [sp, #12]
 8022574:	9302      	str	r3, [sp, #8]
 8022576:	9001      	str	r0, [sp, #4]
 8022578:	9100      	str	r1, [sp, #0]
 802257a:	f240 5331 	movw	r3, #1329	; 0x531
 802257e:	4a48      	ldr	r2, [pc, #288]	; (80226a0 <sm_address_resolution_handle_event+0x2b8>)
 8022580:	494b      	ldr	r1, [pc, #300]	; (80226b0 <sm_address_resolution_handle_event+0x2c8>)
 8022582:	2001      	movs	r0, #1
 8022584:	f7f4 ff5c 	bl	8017440 <hci_dump_log>
                        sm_connection->sm_security_request_received = 0;
 8022588:	69fb      	ldr	r3, [r7, #28]
 802258a:	2200      	movs	r2, #0
 802258c:	70da      	strb	r2, [r3, #3]
                        sm_connection->sm_pairing_requested = 0;
 802258e:	69fb      	ldr	r3, [r7, #28]
 8022590:	2200      	movs	r2, #0
 8022592:	711a      	strb	r2, [r3, #4]
                        bool trigger_reencryption = false;
 8022594:	2300      	movs	r3, #0
 8022596:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
                        if (have_ltk){
 802259a:	7ebb      	ldrb	r3, [r7, #26]
 802259c:	2b00      	cmp	r3, #0
 802259e:	d00d      	beq.n	80225bc <sm_address_resolution_handle_event+0x1d4>
                            if (trigger_pairing){
 80225a0:	7e7b      	ldrb	r3, [r7, #25]
 80225a2:	2b00      	cmp	r3, #0
 80225a4:	d003      	beq.n	80225ae <sm_address_resolution_handle_event+0x1c6>
                                trigger_reencryption = true;
 80225a6:	2301      	movs	r3, #1
 80225a8:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
 80225ac:	e006      	b.n	80225bc <sm_address_resolution_handle_event+0x1d4>
                                log_info("central: defer enabling encryption for bonded device");
 80225ae:	f240 533d 	movw	r3, #1341	; 0x53d
 80225b2:	4a3b      	ldr	r2, [pc, #236]	; (80226a0 <sm_address_resolution_handle_event+0x2b8>)
 80225b4:	493f      	ldr	r1, [pc, #252]	; (80226b4 <sm_address_resolution_handle_event+0x2cc>)
 80225b6:	2001      	movs	r0, #1
 80225b8:	f7f4 ff42 	bl	8017440 <hci_dump_log>
                        if (trigger_reencryption){
 80225bc:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
 80225c0:	2b00      	cmp	r3, #0
 80225c2:	d00a      	beq.n	80225da <sm_address_resolution_handle_event+0x1f2>
                            log_info("central: enable encryption for bonded device");
 80225c4:	f240 5343 	movw	r3, #1347	; 0x543
 80225c8:	4a35      	ldr	r2, [pc, #212]	; (80226a0 <sm_address_resolution_handle_event+0x2b8>)
 80225ca:	493b      	ldr	r1, [pc, #236]	; (80226b8 <sm_address_resolution_handle_event+0x2d0>)
 80225cc:	2001      	movs	r0, #1
 80225ce:	f7f4 ff37 	bl	8017440 <hci_dump_log>
                            sm_connection->sm_engine_state = SM_INITIATOR_PH4_HAS_LTK;
 80225d2:	69fb      	ldr	r3, [r7, #28]
 80225d4:	222f      	movs	r2, #47	; 0x2f
 80225d6:	731a      	strb	r2, [r3, #12]
                            break;
 80225d8:	e048      	b.n	802266c <sm_address_resolution_handle_event+0x284>
                        if (trigger_pairing){
 80225da:	7e7b      	ldrb	r3, [r7, #25]
 80225dc:	2b00      	cmp	r3, #0
 80225de:	d040      	beq.n	8022662 <sm_address_resolution_handle_event+0x27a>
                            sm_connection->sm_engine_state = SM_INITIATOR_PH1_W2_SEND_PAIRING_REQUEST;
 80225e0:	69fb      	ldr	r3, [r7, #28]
 80225e2:	222a      	movs	r2, #42	; 0x2a
 80225e4:	731a      	strb	r2, [r3, #12]
                            break;
 80225e6:	e041      	b.n	802266c <sm_address_resolution_handle_event+0x284>
                    sm_connection->sm_irk_lookup_state = IRK_LOOKUP_FAILED;
 80225e8:	69fb      	ldr	r3, [r7, #28]
 80225ea:	2204      	movs	r2, #4
 80225ec:	735a      	strb	r2, [r3, #13]
                    if (sm_connection->sm_role) {
 80225ee:	69fb      	ldr	r3, [r7, #28]
 80225f0:	789b      	ldrb	r3, [r3, #2]
 80225f2:	2b00      	cmp	r3, #0
 80225f4:	d023      	beq.n	802263e <sm_address_resolution_handle_event+0x256>
                        if (sm_connection->sm_engine_state == SM_RESPONDER_PH0_RECEIVED_LTK_W4_IRK){
 80225f6:	69fb      	ldr	r3, [r7, #28]
 80225f8:	7b1b      	ldrb	r3, [r3, #12]
 80225fa:	2b1d      	cmp	r3, #29
 80225fc:	d102      	bne.n	8022604 <sm_address_resolution_handle_event+0x21c>
                            sm_connection->sm_engine_state = SM_RESPONDER_PH0_SEND_LTK_REQUESTED_NEGATIVE_REPLY;
 80225fe:	69fb      	ldr	r3, [r7, #28]
 8022600:	221e      	movs	r2, #30
 8022602:	731a      	strb	r2, [r3, #12]
                        bool trigger_security_request = (sm_connection->sm_pairing_requested != 0) || (sm_slave_request_security != 0);
 8022604:	69fb      	ldr	r3, [r7, #28]
 8022606:	791b      	ldrb	r3, [r3, #4]
 8022608:	2b00      	cmp	r3, #0
 802260a:	d103      	bne.n	8022614 <sm_address_resolution_handle_event+0x22c>
 802260c:	4b26      	ldr	r3, [pc, #152]	; (80226a8 <sm_address_resolution_handle_event+0x2c0>)
 802260e:	781b      	ldrb	r3, [r3, #0]
 8022610:	2b00      	cmp	r3, #0
 8022612:	d001      	beq.n	8022618 <sm_address_resolution_handle_event+0x230>
 8022614:	2301      	movs	r3, #1
 8022616:	e000      	b.n	802261a <sm_address_resolution_handle_event+0x232>
 8022618:	2300      	movs	r3, #0
 802261a:	76fb      	strb	r3, [r7, #27]
 802261c:	7efb      	ldrb	r3, [r7, #27]
 802261e:	f003 0301 	and.w	r3, r3, #1
 8022622:	76fb      	strb	r3, [r7, #27]
                        sm_connection->sm_pairing_requested = 0;
 8022624:	69fb      	ldr	r3, [r7, #28]
 8022626:	2200      	movs	r2, #0
 8022628:	711a      	strb	r2, [r3, #4]
                        if (trigger_security_request){
 802262a:	7efb      	ldrb	r3, [r7, #27]
 802262c:	2b00      	cmp	r3, #0
 802262e:	d01a      	beq.n	8022666 <sm_address_resolution_handle_event+0x27e>
                            sm_connection->sm_engine_state = SM_RESPONDER_SEND_SECURITY_REQUEST;
 8022630:	69fb      	ldr	r3, [r7, #28]
 8022632:	221b      	movs	r2, #27
 8022634:	731a      	strb	r2, [r3, #12]
                            sm_pairing_started(sm_connection);
 8022636:	69f8      	ldr	r0, [r7, #28]
 8022638:	f7fe ffec 	bl	8021614 <sm_pairing_started>
                        break;
 802263c:	e013      	b.n	8022666 <sm_address_resolution_handle_event+0x27e>
                    if (!sm_connection->sm_pairing_requested && !sm_connection->sm_security_request_received) break;
 802263e:	69fb      	ldr	r3, [r7, #28]
 8022640:	791b      	ldrb	r3, [r3, #4]
 8022642:	2b00      	cmp	r3, #0
 8022644:	d103      	bne.n	802264e <sm_address_resolution_handle_event+0x266>
 8022646:	69fb      	ldr	r3, [r7, #28]
 8022648:	78db      	ldrb	r3, [r3, #3]
 802264a:	2b00      	cmp	r3, #0
 802264c:	d00d      	beq.n	802266a <sm_address_resolution_handle_event+0x282>
                    sm_connection->sm_security_request_received = 0;
 802264e:	69fb      	ldr	r3, [r7, #28]
 8022650:	2200      	movs	r2, #0
 8022652:	70da      	strb	r2, [r3, #3]
                    sm_connection->sm_pairing_requested = 0;
 8022654:	69fb      	ldr	r3, [r7, #28]
 8022656:	2200      	movs	r2, #0
 8022658:	711a      	strb	r2, [r3, #4]
                    sm_connection->sm_engine_state = SM_INITIATOR_PH1_W2_SEND_PAIRING_REQUEST;
 802265a:	69fb      	ldr	r3, [r7, #28]
 802265c:	222a      	movs	r2, #42	; 0x2a
 802265e:	731a      	strb	r2, [r3, #12]
                    break;
 8022660:	e004      	b.n	802266c <sm_address_resolution_handle_event+0x284>
                    break;
 8022662:	bf00      	nop
 8022664:	e004      	b.n	8022670 <sm_address_resolution_handle_event+0x288>
                        break;
 8022666:	bf00      	nop
 8022668:	e002      	b.n	8022670 <sm_address_resolution_handle_event+0x288>
                    if (!sm_connection->sm_pairing_requested && !sm_connection->sm_security_request_received) break;
 802266a:	bf00      	nop
            break;
 802266c:	e000      	b.n	8022670 <sm_address_resolution_handle_event+0x288>
            break;
 802266e:	bf00      	nop
    }

    switch (event){
 8022670:	79fb      	ldrb	r3, [r7, #7]
 8022672:	2b00      	cmp	r3, #0
 8022674:	d002      	beq.n	802267c <sm_address_resolution_handle_event+0x294>
 8022676:	2b01      	cmp	r3, #1
 8022678:	d024      	beq.n	80226c4 <sm_address_resolution_handle_event+0x2dc>
        case ADDRESS_RESOLUTION_FAILED:
            sm_notify_client_base(SM_EVENT_IDENTITY_RESOLVING_FAILED, con_handle, sm_address_resolution_addr_type, sm_address_resolution_address);
            break;
        default:
            btstack_assert(false);
            break;
 802267a:	e02b      	b.n	80226d4 <sm_address_resolution_handle_event+0x2ec>
            sm_notify_client_index(SM_EVENT_IDENTITY_RESOLVING_SUCCEEDED, con_handle, sm_address_resolution_addr_type, sm_address_resolution_address, matched_device_id);
 802267c:	4b0f      	ldr	r3, [pc, #60]	; (80226bc <sm_address_resolution_handle_event+0x2d4>)
 802267e:	781a      	ldrb	r2, [r3, #0]
 8022680:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8022682:	b29b      	uxth	r3, r3
 8022684:	8df9      	ldrh	r1, [r7, #46]	; 0x2e
 8022686:	9300      	str	r3, [sp, #0]
 8022688:	4b0d      	ldr	r3, [pc, #52]	; (80226c0 <sm_address_resolution_handle_event+0x2d8>)
 802268a:	20d7      	movs	r0, #215	; 0xd7
 802268c:	f7fe fef0 	bl	8021470 <sm_notify_client_index>
            break;
 8022690:	e020      	b.n	80226d4 <sm_address_resolution_handle_event+0x2ec>
 8022692:	bf00      	nop
 8022694:	2000a048 	.word	0x2000a048
 8022698:	2000a060 	.word	0x2000a060
 802269c:	2000a05c 	.word	0x2000a05c
 80226a0:	0802d4a8 	.word	0x0802d4a8
 80226a4:	0802d688 	.word	0x0802d688
 80226a8:	20009f47 	.word	0x20009f47
 80226ac:	0802d6b8 	.word	0x0802d6b8
 80226b0:	0802d710 	.word	0x0802d710
 80226b4:	0802d768 	.word	0x0802d768
 80226b8:	0802d7a4 	.word	0x0802d7a4
 80226bc:	2000a050 	.word	0x2000a050
 80226c0:	2000a054 	.word	0x2000a054
            sm_notify_client_base(SM_EVENT_IDENTITY_RESOLVING_FAILED, con_handle, sm_address_resolution_addr_type, sm_address_resolution_address);
 80226c4:	4b05      	ldr	r3, [pc, #20]	; (80226dc <sm_address_resolution_handle_event+0x2f4>)
 80226c6:	781a      	ldrb	r2, [r3, #0]
 80226c8:	8df9      	ldrh	r1, [r7, #46]	; 0x2e
 80226ca:	4b05      	ldr	r3, [pc, #20]	; (80226e0 <sm_address_resolution_handle_event+0x2f8>)
 80226cc:	20d6      	movs	r0, #214	; 0xd6
 80226ce:	f7fe fe86 	bl	80213de <sm_notify_client_base>
            break;
 80226d2:	bf00      	nop
    }
}
 80226d4:	bf00      	nop
 80226d6:	3730      	adds	r7, #48	; 0x30
 80226d8:	46bd      	mov	sp, r7
 80226da:	bd80      	pop	{r7, pc}
 80226dc:	2000a050 	.word	0x2000a050
 80226e0:	2000a054 	.word	0x2000a054

080226e4 <sm_key_distribution_handle_all_received>:

static void sm_key_distribution_handle_all_received(sm_connection_t * sm_conn){
 80226e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80226e6:	b097      	sub	sp, #92	; 0x5c
 80226e8:	af04      	add	r7, sp, #16
 80226ea:	6078      	str	r0, [r7, #4]

    int le_db_index = -1;
 80226ec:	f04f 33ff 	mov.w	r3, #4294967295
 80226f0:	647b      	str	r3, [r7, #68]	; 0x44

    // only store pairing information if both sides are bondable, i.e., the bonadble flag is set
    bool bonding_enabed = ( sm_pairing_packet_get_auth_req(setup->sm_m_preq)
 80226f2:	4b9a      	ldr	r3, [pc, #616]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 80226f4:	681b      	ldr	r3, [r3, #0]
 80226f6:	3339      	adds	r3, #57	; 0x39
 80226f8:	4618      	mov	r0, r3
 80226fa:	f7fe fc77 	bl	8020fec <sm_pairing_packet_get_auth_req>
 80226fe:	4603      	mov	r3, r0
 8022700:	461c      	mov	r4, r3
                         & sm_pairing_packet_get_auth_req(setup->sm_s_pres)
 8022702:	4b96      	ldr	r3, [pc, #600]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 8022704:	681b      	ldr	r3, [r3, #0]
 8022706:	3340      	adds	r3, #64	; 0x40
 8022708:	4618      	mov	r0, r3
 802270a:	f7fe fc6f 	bl	8020fec <sm_pairing_packet_get_auth_req>
 802270e:	4603      	mov	r3, r0
                         & SM_AUTHREQ_BONDING ) != 0u;
 8022710:	4023      	ands	r3, r4
 8022712:	b2db      	uxtb	r3, r3
 8022714:	f003 0301 	and.w	r3, r3, #1
    bool bonding_enabed = ( sm_pairing_packet_get_auth_req(setup->sm_m_preq)
 8022718:	2b00      	cmp	r3, #0
 802271a:	bf14      	ite	ne
 802271c:	2301      	movne	r3, #1
 802271e:	2300      	moveq	r3, #0
 8022720:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b

    if (bonding_enabed){
 8022724:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8022728:	2b00      	cmp	r3, #0
 802272a:	f000 8165 	beq.w	80229f8 <sm_key_distribution_handle_all_received+0x314>

        // lookup device based on IRK
        if (setup->sm_key_distribution_received_set & SM_KEYDIST_FLAG_IDENTITY_INFORMATION){
 802272e:	4b8b      	ldr	r3, [pc, #556]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 8022730:	681b      	ldr	r3, [r3, #0]
 8022732:	7d5b      	ldrb	r3, [r3, #21]
 8022734:	f003 0304 	and.w	r3, r3, #4
 8022738:	2b00      	cmp	r3, #0
 802273a:	d034      	beq.n	80227a6 <sm_key_distribution_handle_all_received+0xc2>
            int i;
            for (i=0; i < le_device_db_max_count(); i++){
 802273c:	2300      	movs	r3, #0
 802273e:	643b      	str	r3, [r7, #64]	; 0x40
 8022740:	e02a      	b.n	8022798 <sm_key_distribution_handle_all_received+0xb4>
                sm_key_t irk;
                bd_addr_t address;
                int address_type = BD_ADDR_TYPE_UNKNOWN;
 8022742:	23fe      	movs	r3, #254	; 0xfe
 8022744:	61fb      	str	r3, [r7, #28]
                le_device_db_info(i, &address_type, address, irk);
 8022746:	f107 0328 	add.w	r3, r7, #40	; 0x28
 802274a:	f107 0220 	add.w	r2, r7, #32
 802274e:	f107 011c 	add.w	r1, r7, #28
 8022752:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8022754:	f7fe faa4 	bl	8020ca0 <le_device_db_info>
                // skip unused entries
                if (address_type == BD_ADDR_TYPE_UNKNOWN) continue;
 8022758:	69fb      	ldr	r3, [r7, #28]
 802275a:	2bfe      	cmp	r3, #254	; 0xfe
 802275c:	d016      	beq.n	802278c <sm_key_distribution_handle_all_received+0xa8>
                // compare IRK
                if (memcmp(irk, setup->sm_peer_irk, 16) != 0) continue;
 802275e:	4b7f      	ldr	r3, [pc, #508]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 8022760:	681b      	ldr	r3, [r3, #0]
 8022762:	f503 71f2 	add.w	r1, r3, #484	; 0x1e4
 8022766:	f107 0328 	add.w	r3, r7, #40	; 0x28
 802276a:	2210      	movs	r2, #16
 802276c:	4618      	mov	r0, r3
 802276e:	f005 f975 	bl	8027a5c <memcmp>
 8022772:	4603      	mov	r3, r0
 8022774:	2b00      	cmp	r3, #0
 8022776:	d10b      	bne.n	8022790 <sm_key_distribution_handle_all_received+0xac>

                log_info("sm: device found for IRK, updating");
 8022778:	f44f 63b3 	mov.w	r3, #1432	; 0x598
 802277c:	4a78      	ldr	r2, [pc, #480]	; (8022960 <sm_key_distribution_handle_all_received+0x27c>)
 802277e:	4979      	ldr	r1, [pc, #484]	; (8022964 <sm_key_distribution_handle_all_received+0x280>)
 8022780:	2001      	movs	r0, #1
 8022782:	f7f4 fe5d 	bl	8017440 <hci_dump_log>
                le_db_index = i;
 8022786:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8022788:	647b      	str	r3, [r7, #68]	; 0x44
 802278a:	e015      	b.n	80227b8 <sm_key_distribution_handle_all_received+0xd4>
                if (address_type == BD_ADDR_TYPE_UNKNOWN) continue;
 802278c:	bf00      	nop
 802278e:	e000      	b.n	8022792 <sm_key_distribution_handle_all_received+0xae>
                if (memcmp(irk, setup->sm_peer_irk, 16) != 0) continue;
 8022790:	bf00      	nop
            for (i=0; i < le_device_db_max_count(); i++){
 8022792:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8022794:	3301      	adds	r3, #1
 8022796:	643b      	str	r3, [r7, #64]	; 0x40
 8022798:	f7fe f96a 	bl	8020a70 <le_device_db_max_count>
 802279c:	4602      	mov	r2, r0
 802279e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80227a0:	4293      	cmp	r3, r2
 80227a2:	dbce      	blt.n	8022742 <sm_key_distribution_handle_all_received+0x5e>
 80227a4:	e008      	b.n	80227b8 <sm_key_distribution_handle_all_received+0xd4>
                break;
            }
        } else {
            // assert IRK is set to zero
            memset(setup->sm_peer_irk, 0, 16);
 80227a6:	4b6d      	ldr	r3, [pc, #436]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 80227a8:	681b      	ldr	r3, [r3, #0]
 80227aa:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 80227ae:	2210      	movs	r2, #16
 80227b0:	2100      	movs	r1, #0
 80227b2:	4618      	mov	r0, r3
 80227b4:	f005 f985 	bl	8027ac2 <memset>
        }

        // if not found, lookup via public address if possible
        log_info("sm peer addr type %u, peer addres %s", setup->sm_peer_addr_type, bd_addr_to_str(setup->sm_peer_address));
 80227b8:	4b68      	ldr	r3, [pc, #416]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 80227ba:	681b      	ldr	r3, [r3, #0]
 80227bc:	f893 3204 	ldrb.w	r3, [r3, #516]	; 0x204
 80227c0:	461c      	mov	r4, r3
 80227c2:	4b66      	ldr	r3, [pc, #408]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 80227c4:	681b      	ldr	r3, [r3, #0]
 80227c6:	f203 2305 	addw	r3, r3, #517	; 0x205
 80227ca:	4618      	mov	r0, r3
 80227cc:	f7ec fe20 	bl	800f410 <bd_addr_to_str>
 80227d0:	4603      	mov	r3, r0
 80227d2:	9301      	str	r3, [sp, #4]
 80227d4:	9400      	str	r4, [sp, #0]
 80227d6:	f240 53a2 	movw	r3, #1442	; 0x5a2
 80227da:	4a61      	ldr	r2, [pc, #388]	; (8022960 <sm_key_distribution_handle_all_received+0x27c>)
 80227dc:	4962      	ldr	r1, [pc, #392]	; (8022968 <sm_key_distribution_handle_all_received+0x284>)
 80227de:	2001      	movs	r0, #1
 80227e0:	f7f4 fe2e 	bl	8017440 <hci_dump_log>
        if ((le_db_index < 0) && (setup->sm_peer_addr_type == BD_ADDR_TYPE_LE_PUBLIC)){
 80227e4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80227e6:	2b00      	cmp	r3, #0
 80227e8:	da4b      	bge.n	8022882 <sm_key_distribution_handle_all_received+0x19e>
 80227ea:	4b5c      	ldr	r3, [pc, #368]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 80227ec:	681b      	ldr	r3, [r3, #0]
 80227ee:	f893 3204 	ldrb.w	r3, [r3, #516]	; 0x204
 80227f2:	2b00      	cmp	r3, #0
 80227f4:	d145      	bne.n	8022882 <sm_key_distribution_handle_all_received+0x19e>
            int i;
            for (i=0; i < le_device_db_max_count(); i++){
 80227f6:	2300      	movs	r3, #0
 80227f8:	63fb      	str	r3, [r7, #60]	; 0x3c
 80227fa:	e03c      	b.n	8022876 <sm_key_distribution_handle_all_received+0x192>
                bd_addr_t address;
                int address_type = BD_ADDR_TYPE_UNKNOWN;
 80227fc:	23fe      	movs	r3, #254	; 0xfe
 80227fe:	613b      	str	r3, [r7, #16]
                le_device_db_info(i, &address_type, address, NULL);
 8022800:	f107 0214 	add.w	r2, r7, #20
 8022804:	f107 0110 	add.w	r1, r7, #16
 8022808:	2300      	movs	r3, #0
 802280a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 802280c:	f7fe fa48 	bl	8020ca0 <le_device_db_info>
                // skip unused entries
                if (address_type == BD_ADDR_TYPE_UNKNOWN) continue;
 8022810:	693b      	ldr	r3, [r7, #16]
 8022812:	2bfe      	cmp	r3, #254	; 0xfe
 8022814:	d02b      	beq.n	802286e <sm_key_distribution_handle_all_received+0x18a>
                log_info("device %u, sm peer addr type %u, peer addres %s", i, address_type, bd_addr_to_str(address));
 8022816:	693c      	ldr	r4, [r7, #16]
 8022818:	f107 0314 	add.w	r3, r7, #20
 802281c:	4618      	mov	r0, r3
 802281e:	f7ec fdf7 	bl	800f410 <bd_addr_to_str>
 8022822:	4603      	mov	r3, r0
 8022824:	9302      	str	r3, [sp, #8]
 8022826:	9401      	str	r4, [sp, #4]
 8022828:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802282a:	9300      	str	r3, [sp, #0]
 802282c:	f240 53ab 	movw	r3, #1451	; 0x5ab
 8022830:	4a4b      	ldr	r2, [pc, #300]	; (8022960 <sm_key_distribution_handle_all_received+0x27c>)
 8022832:	494e      	ldr	r1, [pc, #312]	; (802296c <sm_key_distribution_handle_all_received+0x288>)
 8022834:	2001      	movs	r0, #1
 8022836:	f7f4 fe03 	bl	8017440 <hci_dump_log>
                if ((address_type == BD_ADDR_TYPE_LE_PUBLIC) && (memcmp(address, setup->sm_peer_address, 6) == 0)){
 802283a:	693b      	ldr	r3, [r7, #16]
 802283c:	2b00      	cmp	r3, #0
 802283e:	d117      	bne.n	8022870 <sm_key_distribution_handle_all_received+0x18c>
 8022840:	4b46      	ldr	r3, [pc, #280]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 8022842:	681b      	ldr	r3, [r3, #0]
 8022844:	f203 2105 	addw	r1, r3, #517	; 0x205
 8022848:	f107 0314 	add.w	r3, r7, #20
 802284c:	2206      	movs	r2, #6
 802284e:	4618      	mov	r0, r3
 8022850:	f005 f904 	bl	8027a5c <memcmp>
 8022854:	4603      	mov	r3, r0
 8022856:	2b00      	cmp	r3, #0
 8022858:	d10a      	bne.n	8022870 <sm_key_distribution_handle_all_received+0x18c>
                    log_info("sm: device found for public address, updating");
 802285a:	f240 53ad 	movw	r3, #1453	; 0x5ad
 802285e:	4a40      	ldr	r2, [pc, #256]	; (8022960 <sm_key_distribution_handle_all_received+0x27c>)
 8022860:	4943      	ldr	r1, [pc, #268]	; (8022970 <sm_key_distribution_handle_all_received+0x28c>)
 8022862:	2001      	movs	r0, #1
 8022864:	f7f4 fdec 	bl	8017440 <hci_dump_log>
                    le_db_index = i;
 8022868:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802286a:	647b      	str	r3, [r7, #68]	; 0x44
 802286c:	e009      	b.n	8022882 <sm_key_distribution_handle_all_received+0x19e>
                if (address_type == BD_ADDR_TYPE_UNKNOWN) continue;
 802286e:	bf00      	nop
            for (i=0; i < le_device_db_max_count(); i++){
 8022870:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8022872:	3301      	adds	r3, #1
 8022874:	63fb      	str	r3, [r7, #60]	; 0x3c
 8022876:	f7fe f8fb 	bl	8020a70 <le_device_db_max_count>
 802287a:	4602      	mov	r2, r0
 802287c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802287e:	4293      	cmp	r3, r2
 8022880:	dbbc      	blt.n	80227fc <sm_key_distribution_handle_all_received+0x118>
                }
            }
        }

        // if not found, add to db
        bool new_to_le_device_db = false;
 8022882:	2300      	movs	r3, #0
 8022884:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a
        if (le_db_index < 0) {
 8022888:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802288a:	2b00      	cmp	r3, #0
 802288c:	da13      	bge.n	80228b6 <sm_key_distribution_handle_all_received+0x1d2>
            le_db_index = le_device_db_add(setup->sm_peer_addr_type, setup->sm_peer_address, setup->sm_peer_irk);
 802288e:	4b33      	ldr	r3, [pc, #204]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 8022890:	681b      	ldr	r3, [r3, #0]
 8022892:	f893 3204 	ldrb.w	r3, [r3, #516]	; 0x204
 8022896:	4618      	mov	r0, r3
 8022898:	4b30      	ldr	r3, [pc, #192]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 802289a:	681b      	ldr	r3, [r3, #0]
 802289c:	f203 2105 	addw	r1, r3, #517	; 0x205
 80228a0:	4b2e      	ldr	r3, [pc, #184]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 80228a2:	681b      	ldr	r3, [r3, #0]
 80228a4:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 80228a8:	461a      	mov	r2, r3
 80228aa:	f7fe f8e9 	bl	8020a80 <le_device_db_add>
 80228ae:	6478      	str	r0, [r7, #68]	; 0x44
			new_to_le_device_db = true;
 80228b0:	2301      	movs	r3, #1
 80228b2:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a
        }

        if (le_db_index >= 0){
 80228b6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80228b8:	2b00      	cmp	r3, #0
 80228ba:	f2c0 80a4 	blt.w	8022a06 <sm_key_distribution_handle_all_received+0x322>
			hci_load_le_device_db_entry_into_resolving_list(le_db_index);
#else
			UNUSED(new_to_le_device_db);
#endif

            sm_notify_client_index(SM_EVENT_IDENTITY_CREATED, sm_conn->sm_handle, setup->sm_peer_addr_type, setup->sm_peer_address, le_db_index);
 80228be:	687b      	ldr	r3, [r7, #4]
 80228c0:	8819      	ldrh	r1, [r3, #0]
 80228c2:	4b26      	ldr	r3, [pc, #152]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 80228c4:	681b      	ldr	r3, [r3, #0]
 80228c6:	f893 2204 	ldrb.w	r2, [r3, #516]	; 0x204
 80228ca:	4b24      	ldr	r3, [pc, #144]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 80228cc:	681b      	ldr	r3, [r3, #0]
 80228ce:	f203 2005 	addw	r0, r3, #517	; 0x205
 80228d2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80228d4:	b29b      	uxth	r3, r3
 80228d6:	9300      	str	r3, [sp, #0]
 80228d8:	4603      	mov	r3, r0
 80228da:	20db      	movs	r0, #219	; 0xdb
 80228dc:	f7fe fdc8 	bl	8021470 <sm_notify_client_index>
            sm_conn->sm_irk_lookup_state = IRK_LOOKUP_SUCCEEDED;
 80228e0:	687b      	ldr	r3, [r7, #4]
 80228e2:	2203      	movs	r2, #3
 80228e4:	735a      	strb	r2, [r3, #13]
                le_device_db_remote_csrk_set(le_db_index, setup->sm_peer_csrk);
                le_device_db_remote_counter_set(le_db_index, 0);
            }
#endif
            // store encryption information for secure connections: LTK generated by ECDH
            if (setup->sm_use_secure_connections){
 80228e6:	4b1d      	ldr	r3, [pc, #116]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 80228e8:	681b      	ldr	r3, [r3, #0]
 80228ea:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80228ee:	2b00      	cmp	r3, #0
 80228f0:	d042      	beq.n	8022978 <sm_key_distribution_handle_all_received+0x294>
                log_info("sm: store SC LTK (key size %u, authenticated %u)", sm_conn->sm_actual_encryption_key_size, sm_conn->sm_connection_authenticated);
 80228f2:	687b      	ldr	r3, [r7, #4]
 80228f4:	7c5b      	ldrb	r3, [r3, #17]
 80228f6:	461a      	mov	r2, r3
 80228f8:	687b      	ldr	r3, [r7, #4]
 80228fa:	7bdb      	ldrb	r3, [r3, #15]
 80228fc:	9301      	str	r3, [sp, #4]
 80228fe:	9200      	str	r2, [sp, #0]
 8022900:	f240 53db 	movw	r3, #1499	; 0x5db
 8022904:	4a16      	ldr	r2, [pc, #88]	; (8022960 <sm_key_distribution_handle_all_received+0x27c>)
 8022906:	491b      	ldr	r1, [pc, #108]	; (8022974 <sm_key_distribution_handle_all_received+0x290>)
 8022908:	2001      	movs	r0, #1
 802290a:	f7f4 fd99 	bl	8017440 <hci_dump_log>
                uint8_t zero_rand[8];
                memset(zero_rand, 0, 8);
 802290e:	f107 0308 	add.w	r3, r7, #8
 8022912:	2208      	movs	r2, #8
 8022914:	2100      	movs	r1, #0
 8022916:	4618      	mov	r0, r3
 8022918:	f005 f8d3 	bl	8027ac2 <memset>
                le_device_db_encryption_set(le_db_index, 0, zero_rand, setup->sm_ltk, sm_conn->sm_actual_encryption_key_size,
 802291c:	4b0f      	ldr	r3, [pc, #60]	; (802295c <sm_key_distribution_handle_all_received+0x278>)
 802291e:	681b      	ldr	r3, [r3, #0]
 8022920:	f103 0195 	add.w	r1, r3, #149	; 0x95
 8022924:	687b      	ldr	r3, [r7, #4]
 8022926:	7c5b      	ldrb	r3, [r3, #17]
 8022928:	4618      	mov	r0, r3
                    sm_conn->sm_connection_authenticated, sm_conn->sm_connection_authorization_state == AUTHORIZATION_GRANTED, 1);
 802292a:	687b      	ldr	r3, [r7, #4]
 802292c:	7bdb      	ldrb	r3, [r3, #15]
                le_device_db_encryption_set(le_db_index, 0, zero_rand, setup->sm_ltk, sm_conn->sm_actual_encryption_key_size,
 802292e:	461c      	mov	r4, r3
                    sm_conn->sm_connection_authenticated, sm_conn->sm_connection_authorization_state == AUTHORIZATION_GRANTED, 1);
 8022930:	687b      	ldr	r3, [r7, #4]
 8022932:	7e5b      	ldrb	r3, [r3, #25]
                le_device_db_encryption_set(le_db_index, 0, zero_rand, setup->sm_ltk, sm_conn->sm_actual_encryption_key_size,
 8022934:	2b03      	cmp	r3, #3
 8022936:	bf0c      	ite	eq
 8022938:	2301      	moveq	r3, #1
 802293a:	2300      	movne	r3, #0
 802293c:	b2db      	uxtb	r3, r3
 802293e:	461d      	mov	r5, r3
 8022940:	f107 0208 	add.w	r2, r7, #8
 8022944:	2301      	movs	r3, #1
 8022946:	9303      	str	r3, [sp, #12]
 8022948:	9502      	str	r5, [sp, #8]
 802294a:	9401      	str	r4, [sp, #4]
 802294c:	9000      	str	r0, [sp, #0]
 802294e:	460b      	mov	r3, r1
 8022950:	2100      	movs	r1, #0
 8022952:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8022954:	f7fe f9e4 	bl	8020d20 <le_device_db_encryption_set>
 8022958:	e055      	b.n	8022a06 <sm_key_distribution_handle_all_received+0x322>
 802295a:	bf00      	nop
 802295c:	200000a0 	.word	0x200000a0
 8022960:	0802d4a8 	.word	0x0802d4a8
 8022964:	0802d7d8 	.word	0x0802d7d8
 8022968:	0802d804 	.word	0x0802d804
 802296c:	0802d830 	.word	0x0802d830
 8022970:	0802d868 	.word	0x0802d868
 8022974:	0802d8a0 	.word	0x0802d8a0
            }

            // store encryption information for legacy pairing: peer LTK, EDIV, RAND
            else if ( (setup->sm_key_distribution_received_set & SM_KEYDIST_FLAG_ENCRYPTION_INFORMATION)
 8022978:	4b26      	ldr	r3, [pc, #152]	; (8022a14 <sm_key_distribution_handle_all_received+0x330>)
 802297a:	681b      	ldr	r3, [r3, #0]
 802297c:	7d5b      	ldrb	r3, [r3, #21]
 802297e:	f003 0301 	and.w	r3, r3, #1
 8022982:	2b00      	cmp	r3, #0
 8022984:	d03f      	beq.n	8022a06 <sm_key_distribution_handle_all_received+0x322>
                   && (setup->sm_key_distribution_received_set & SM_KEYDIST_FLAG_MASTER_IDENTIFICATION )){
 8022986:	4b23      	ldr	r3, [pc, #140]	; (8022a14 <sm_key_distribution_handle_all_received+0x330>)
 8022988:	681b      	ldr	r3, [r3, #0]
 802298a:	7d5b      	ldrb	r3, [r3, #21]
 802298c:	f003 0302 	and.w	r3, r3, #2
 8022990:	2b00      	cmp	r3, #0
 8022992:	d038      	beq.n	8022a06 <sm_key_distribution_handle_all_received+0x322>
                log_info("sm: set encryption information (key size %u, authenticated %u)", sm_conn->sm_actual_encryption_key_size, sm_conn->sm_connection_authenticated);
 8022994:	687b      	ldr	r3, [r7, #4]
 8022996:	7c5b      	ldrb	r3, [r3, #17]
 8022998:	461a      	mov	r2, r3
 802299a:	687b      	ldr	r3, [r7, #4]
 802299c:	7bdb      	ldrb	r3, [r3, #15]
 802299e:	9301      	str	r3, [sp, #4]
 80229a0:	9200      	str	r2, [sp, #0]
 80229a2:	f240 53e5 	movw	r3, #1509	; 0x5e5
 80229a6:	4a1c      	ldr	r2, [pc, #112]	; (8022a18 <sm_key_distribution_handle_all_received+0x334>)
 80229a8:	491c      	ldr	r1, [pc, #112]	; (8022a1c <sm_key_distribution_handle_all_received+0x338>)
 80229aa:	2001      	movs	r0, #1
 80229ac:	f7f4 fd48 	bl	8017440 <hci_dump_log>
                le_device_db_encryption_set(le_db_index, setup->sm_peer_ediv, setup->sm_peer_rand, setup->sm_peer_ltk,
 80229b0:	4b18      	ldr	r3, [pc, #96]	; (8022a14 <sm_key_distribution_handle_all_received+0x330>)
 80229b2:	681b      	ldr	r3, [r3, #0]
 80229b4:	f8b3 11ca 	ldrh.w	r1, [r3, #458]	; 0x1ca
 80229b8:	4b16      	ldr	r3, [pc, #88]	; (8022a14 <sm_key_distribution_handle_all_received+0x330>)
 80229ba:	681b      	ldr	r3, [r3, #0]
 80229bc:	f503 72e6 	add.w	r2, r3, #460	; 0x1cc
 80229c0:	4b14      	ldr	r3, [pc, #80]	; (8022a14 <sm_key_distribution_handle_all_received+0x330>)
 80229c2:	681b      	ldr	r3, [r3, #0]
 80229c4:	f503 70ea 	add.w	r0, r3, #468	; 0x1d4
                    sm_conn->sm_actual_encryption_key_size, sm_conn->sm_connection_authenticated, sm_conn->sm_connection_authorization_state == AUTHORIZATION_GRANTED, 0);
 80229c8:	687b      	ldr	r3, [r7, #4]
 80229ca:	7c5b      	ldrb	r3, [r3, #17]
                le_device_db_encryption_set(le_db_index, setup->sm_peer_ediv, setup->sm_peer_rand, setup->sm_peer_ltk,
 80229cc:	461c      	mov	r4, r3
                    sm_conn->sm_actual_encryption_key_size, sm_conn->sm_connection_authenticated, sm_conn->sm_connection_authorization_state == AUTHORIZATION_GRANTED, 0);
 80229ce:	687b      	ldr	r3, [r7, #4]
 80229d0:	7bdb      	ldrb	r3, [r3, #15]
                le_device_db_encryption_set(le_db_index, setup->sm_peer_ediv, setup->sm_peer_rand, setup->sm_peer_ltk,
 80229d2:	461d      	mov	r5, r3
                    sm_conn->sm_actual_encryption_key_size, sm_conn->sm_connection_authenticated, sm_conn->sm_connection_authorization_state == AUTHORIZATION_GRANTED, 0);
 80229d4:	687b      	ldr	r3, [r7, #4]
 80229d6:	7e5b      	ldrb	r3, [r3, #25]
                le_device_db_encryption_set(le_db_index, setup->sm_peer_ediv, setup->sm_peer_rand, setup->sm_peer_ltk,
 80229d8:	2b03      	cmp	r3, #3
 80229da:	bf0c      	ite	eq
 80229dc:	2301      	moveq	r3, #1
 80229de:	2300      	movne	r3, #0
 80229e0:	b2db      	uxtb	r3, r3
 80229e2:	461e      	mov	r6, r3
 80229e4:	2300      	movs	r3, #0
 80229e6:	9303      	str	r3, [sp, #12]
 80229e8:	9602      	str	r6, [sp, #8]
 80229ea:	9501      	str	r5, [sp, #4]
 80229ec:	9400      	str	r4, [sp, #0]
 80229ee:	4603      	mov	r3, r0
 80229f0:	6c78      	ldr	r0, [r7, #68]	; 0x44
 80229f2:	f7fe f995 	bl	8020d20 <le_device_db_encryption_set>
 80229f6:	e006      	b.n	8022a06 <sm_key_distribution_handle_all_received+0x322>

            }
        }
    } else {
        log_info("Ignoring received keys, bonding not enabled");
 80229f8:	f240 53ec 	movw	r3, #1516	; 0x5ec
 80229fc:	4a06      	ldr	r2, [pc, #24]	; (8022a18 <sm_key_distribution_handle_all_received+0x334>)
 80229fe:	4908      	ldr	r1, [pc, #32]	; (8022a20 <sm_key_distribution_handle_all_received+0x33c>)
 8022a00:	2001      	movs	r0, #1
 8022a02:	f7f4 fd1d 	bl	8017440 <hci_dump_log>
    }

    // keep le_db_index
    sm_conn->sm_le_db_index = le_db_index;
 8022a06:	687b      	ldr	r3, [r7, #4]
 8022a08:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8022a0a:	625a      	str	r2, [r3, #36]	; 0x24
}
 8022a0c:	bf00      	nop
 8022a0e:	374c      	adds	r7, #76	; 0x4c
 8022a10:	46bd      	mov	sp, r7
 8022a12:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8022a14:	200000a0 	.word	0x200000a0
 8022a18:	0802d4a8 	.word	0x0802d4a8
 8022a1c:	0802d8d8 	.word	0x0802d8d8
 8022a20:	0802d920 	.word	0x0802d920

08022a24 <sm_pairing_error>:

static void sm_pairing_error(sm_connection_t * sm_conn, uint8_t reason){
 8022a24:	b480      	push	{r7}
 8022a26:	b083      	sub	sp, #12
 8022a28:	af00      	add	r7, sp, #0
 8022a2a:	6078      	str	r0, [r7, #4]
 8022a2c:	460b      	mov	r3, r1
 8022a2e:	70fb      	strb	r3, [r7, #3]
    setup->sm_pairing_failed_reason = reason;
 8022a30:	4b06      	ldr	r3, [pc, #24]	; (8022a4c <sm_pairing_error+0x28>)
 8022a32:	681b      	ldr	r3, [r3, #0]
 8022a34:	78fa      	ldrb	r2, [r7, #3]
 8022a36:	741a      	strb	r2, [r3, #16]
    sm_conn->sm_engine_state = SM_GENERAL_SEND_PAIRING_FAILED;
 8022a38:	687b      	ldr	r3, [r7, #4]
 8022a3a:	2201      	movs	r2, #1
 8022a3c:	731a      	strb	r2, [r3, #12]
}
 8022a3e:	bf00      	nop
 8022a40:	370c      	adds	r7, #12
 8022a42:	46bd      	mov	sp, r7
 8022a44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022a48:	4770      	bx	lr
 8022a4a:	bf00      	nop
 8022a4c:	200000a0 	.word	0x200000a0

08022a50 <sm_pdu_received_in_wrong_state>:

static inline void sm_pdu_received_in_wrong_state(sm_connection_t * sm_conn){
 8022a50:	b580      	push	{r7, lr}
 8022a52:	b082      	sub	sp, #8
 8022a54:	af00      	add	r7, sp, #0
 8022a56:	6078      	str	r0, [r7, #4]
    sm_pairing_error(sm_conn, SM_REASON_UNSPECIFIED_REASON);
 8022a58:	2108      	movs	r1, #8
 8022a5a:	6878      	ldr	r0, [r7, #4]
 8022a5c:	f7ff ffe2 	bl	8022a24 <sm_pairing_error>
}
 8022a60:	bf00      	nop
 8022a62:	3708      	adds	r7, #8
 8022a64:	46bd      	mov	sp, r7
 8022a66:	bd80      	pop	{r7, pc}

08022a68 <sm_sc_start_calculating_local_confirm>:

static void sm_sc_prepare_dhkey_check(sm_connection_t * sm_conn);
static int sm_passkey_used(stk_generation_method_t method);
static int sm_just_works_or_numeric_comparison(stk_generation_method_t method);

static void sm_sc_start_calculating_local_confirm(sm_connection_t * sm_conn){
 8022a68:	b580      	push	{r7, lr}
 8022a6a:	b084      	sub	sp, #16
 8022a6c:	af02      	add	r7, sp, #8
 8022a6e:	6078      	str	r0, [r7, #4]
    if (setup->sm_stk_generation_method == OOB){
 8022a70:	4b0c      	ldr	r3, [pc, #48]	; (8022aa4 <sm_sc_start_calculating_local_confirm+0x3c>)
 8022a72:	681b      	ldr	r3, [r3, #0]
 8022a74:	7d9b      	ldrb	r3, [r3, #22]
 8022a76:	2b05      	cmp	r3, #5
 8022a78:	d103      	bne.n	8022a82 <sm_sc_start_calculating_local_confirm+0x1a>
        sm_conn->sm_engine_state = SM_SC_W2_CMAC_FOR_CONFIRMATION;
 8022a7a:	687b      	ldr	r3, [r7, #4]
 8022a7c:	2234      	movs	r2, #52	; 0x34
 8022a7e:	731a      	strb	r2, [r3, #12]
    } else {
        btstack_crypto_random_generate(&sm_crypto_random_request, setup->sm_local_nonce, 16, &sm_handle_random_result_sc_next_w2_cmac_for_confirmation, (void *)(uintptr_t) sm_conn->sm_handle);
    }
}
 8022a80:	e00b      	b.n	8022a9a <sm_sc_start_calculating_local_confirm+0x32>
        btstack_crypto_random_generate(&sm_crypto_random_request, setup->sm_local_nonce, 16, &sm_handle_random_result_sc_next_w2_cmac_for_confirmation, (void *)(uintptr_t) sm_conn->sm_handle);
 8022a82:	4b08      	ldr	r3, [pc, #32]	; (8022aa4 <sm_sc_start_calculating_local_confirm+0x3c>)
 8022a84:	681b      	ldr	r3, [r3, #0]
 8022a86:	f103 01f6 	add.w	r1, r3, #246	; 0xf6
 8022a8a:	687b      	ldr	r3, [r7, #4]
 8022a8c:	881b      	ldrh	r3, [r3, #0]
 8022a8e:	9300      	str	r3, [sp, #0]
 8022a90:	4b05      	ldr	r3, [pc, #20]	; (8022aa8 <sm_sc_start_calculating_local_confirm+0x40>)
 8022a92:	2210      	movs	r2, #16
 8022a94:	4805      	ldr	r0, [pc, #20]	; (8022aac <sm_sc_start_calculating_local_confirm+0x44>)
 8022a96:	f7eb fcd1 	bl	800e43c <btstack_crypto_random_generate>
}
 8022a9a:	bf00      	nop
 8022a9c:	3708      	adds	r7, #8
 8022a9e:	46bd      	mov	sp, r7
 8022aa0:	bd80      	pop	{r7, pc}
 8022aa2:	bf00      	nop
 8022aa4:	200000a0 	.word	0x200000a0
 8022aa8:	08025985 	.word	0x08025985
 8022aac:	2000a06c 	.word	0x2000a06c

08022ab0 <sm_sc_state_after_receiving_random>:

static void sm_sc_state_after_receiving_random(sm_connection_t * sm_conn){
 8022ab0:	b580      	push	{r7, lr}
 8022ab2:	b084      	sub	sp, #16
 8022ab4:	af02      	add	r7, sp, #8
 8022ab6:	6078      	str	r0, [r7, #4]
    if (IS_RESPONDER(sm_conn->sm_role)){
 8022ab8:	687b      	ldr	r3, [r7, #4]
 8022aba:	789b      	ldrb	r3, [r3, #2]
 8022abc:	2b00      	cmp	r3, #0
 8022abe:	d01c      	beq.n	8022afa <sm_sc_state_after_receiving_random+0x4a>
        // Responder
        if (setup->sm_stk_generation_method == OOB){
 8022ac0:	4b28      	ldr	r3, [pc, #160]	; (8022b64 <sm_sc_state_after_receiving_random+0xb4>)
 8022ac2:	681b      	ldr	r3, [r3, #0]
 8022ac4:	7d9b      	ldrb	r3, [r3, #22]
 8022ac6:	2b05      	cmp	r3, #5
 8022ac8:	d113      	bne.n	8022af2 <sm_sc_state_after_receiving_random+0x42>
            // generate Nb
            log_info("Generate Nb");
 8022aca:	f240 630f 	movw	r3, #1551	; 0x60f
 8022ace:	4a26      	ldr	r2, [pc, #152]	; (8022b68 <sm_sc_state_after_receiving_random+0xb8>)
 8022ad0:	4926      	ldr	r1, [pc, #152]	; (8022b6c <sm_sc_state_after_receiving_random+0xbc>)
 8022ad2:	2001      	movs	r0, #1
 8022ad4:	f7f4 fcb4 	bl	8017440 <hci_dump_log>
            btstack_crypto_random_generate(&sm_crypto_random_request, setup->sm_local_nonce, 16, &sm_handle_random_result_sc_next_send_pairing_random, (void *)(uintptr_t) sm_conn->sm_handle);
 8022ad8:	4b22      	ldr	r3, [pc, #136]	; (8022b64 <sm_sc_state_after_receiving_random+0xb4>)
 8022ada:	681b      	ldr	r3, [r3, #0]
 8022adc:	f103 01f6 	add.w	r1, r3, #246	; 0xf6
 8022ae0:	687b      	ldr	r3, [r7, #4]
 8022ae2:	881b      	ldrh	r3, [r3, #0]
 8022ae4:	9300      	str	r3, [sp, #0]
 8022ae6:	4b22      	ldr	r3, [pc, #136]	; (8022b70 <sm_sc_state_after_receiving_random+0xc0>)
 8022ae8:	2210      	movs	r2, #16
 8022aea:	4822      	ldr	r0, [pc, #136]	; (8022b74 <sm_sc_state_after_receiving_random+0xc4>)
 8022aec:	f7eb fca6 	bl	800e43c <btstack_crypto_random_generate>
            default:
                btstack_assert(false);
                break;
        }
    }
}
 8022af0:	e033      	b.n	8022b5a <sm_sc_state_after_receiving_random+0xaa>
            sm_conn->sm_engine_state = SM_SC_SEND_PAIRING_RANDOM;
 8022af2:	687b      	ldr	r3, [r7, #4]
 8022af4:	223a      	movs	r2, #58	; 0x3a
 8022af6:	731a      	strb	r2, [r3, #12]
}
 8022af8:	e02f      	b.n	8022b5a <sm_sc_state_after_receiving_random+0xaa>
        switch (setup->sm_stk_generation_method){
 8022afa:	4b1a      	ldr	r3, [pc, #104]	; (8022b64 <sm_sc_state_after_receiving_random+0xb4>)
 8022afc:	681b      	ldr	r3, [r3, #0]
 8022afe:	7d9b      	ldrb	r3, [r3, #22]
 8022b00:	2b05      	cmp	r3, #5
 8022b02:	d829      	bhi.n	8022b58 <sm_sc_state_after_receiving_random+0xa8>
 8022b04:	a201      	add	r2, pc, #4	; (adr r2, 8022b0c <sm_sc_state_after_receiving_random+0x5c>)
 8022b06:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8022b0a:	bf00      	nop
 8022b0c:	08022b25 	.word	0x08022b25
 8022b10:	08022b35 	.word	0x08022b35
 8022b14:	08022b35 	.word	0x08022b35
 8022b18:	08022b35 	.word	0x08022b35
 8022b1c:	08022b2d 	.word	0x08022b2d
 8022b20:	08022b51 	.word	0x08022b51
                sm_sc_prepare_dhkey_check(sm_conn);
 8022b24:	6878      	ldr	r0, [r7, #4]
 8022b26:	f000 fc89 	bl	802343c <sm_sc_prepare_dhkey_check>
                break;
 8022b2a:	e016      	b.n	8022b5a <sm_sc_state_after_receiving_random+0xaa>
                sm_conn->sm_engine_state = SM_SC_W2_CALCULATE_G2;
 8022b2c:	687b      	ldr	r3, [r7, #4]
 8022b2e:	223c      	movs	r2, #60	; 0x3c
 8022b30:	731a      	strb	r2, [r3, #12]
                break;
 8022b32:	e012      	b.n	8022b5a <sm_sc_state_after_receiving_random+0xaa>
                if (setup->sm_passkey_bit < 20u) {
 8022b34:	4b0b      	ldr	r3, [pc, #44]	; (8022b64 <sm_sc_state_after_receiving_random+0xb4>)
 8022b36:	681b      	ldr	r3, [r3, #0]
 8022b38:	f893 3186 	ldrb.w	r3, [r3, #390]	; 0x186
 8022b3c:	2b13      	cmp	r3, #19
 8022b3e:	d803      	bhi.n	8022b48 <sm_sc_state_after_receiving_random+0x98>
                    sm_sc_start_calculating_local_confirm(sm_conn);
 8022b40:	6878      	ldr	r0, [r7, #4]
 8022b42:	f7ff ff91 	bl	8022a68 <sm_sc_start_calculating_local_confirm>
                break;
 8022b46:	e008      	b.n	8022b5a <sm_sc_state_after_receiving_random+0xaa>
                    sm_sc_prepare_dhkey_check(sm_conn);
 8022b48:	6878      	ldr	r0, [r7, #4]
 8022b4a:	f000 fc77 	bl	802343c <sm_sc_prepare_dhkey_check>
                break;
 8022b4e:	e004      	b.n	8022b5a <sm_sc_state_after_receiving_random+0xaa>
                sm_sc_prepare_dhkey_check(sm_conn);
 8022b50:	6878      	ldr	r0, [r7, #4]
 8022b52:	f000 fc73 	bl	802343c <sm_sc_prepare_dhkey_check>
                break;
 8022b56:	e000      	b.n	8022b5a <sm_sc_state_after_receiving_random+0xaa>
                break;
 8022b58:	bf00      	nop
}
 8022b5a:	bf00      	nop
 8022b5c:	3708      	adds	r7, #8
 8022b5e:	46bd      	mov	sp, r7
 8022b60:	bd80      	pop	{r7, pc}
 8022b62:	bf00      	nop
 8022b64:	200000a0 	.word	0x200000a0
 8022b68:	0802d4a8 	.word	0x0802d4a8
 8022b6c:	0802d954 	.word	0x0802d954
 8022b70:	08025955 	.word	0x08025955
 8022b74:	2000a06c 	.word	0x2000a06c

08022b78 <sm_sc_cmac_done>:

static void sm_sc_cmac_done(uint8_t * hash){
 8022b78:	b580      	push	{r7, lr}
 8022b7a:	b086      	sub	sp, #24
 8022b7c:	af02      	add	r7, sp, #8
 8022b7e:	6078      	str	r0, [r7, #4]
    log_info("sm_sc_cmac_done: ");
 8022b80:	f240 6332 	movw	r3, #1586	; 0x632
 8022b84:	4a88      	ldr	r2, [pc, #544]	; (8022da8 <sm_sc_cmac_done+0x230>)
 8022b86:	4989      	ldr	r1, [pc, #548]	; (8022dac <sm_sc_cmac_done+0x234>)
 8022b88:	2001      	movs	r0, #1
 8022b8a:	f7f4 fc59 	bl	8017440 <hci_dump_log>
    log_info_hexdump(hash, 16);
 8022b8e:	2110      	movs	r1, #16
 8022b90:	6878      	ldr	r0, [r7, #4]
 8022b92:	f7ec fbe1 	bl	800f358 <log_info_hexdump>

    if (sm_sc_oob_state == SM_SC_OOB_W4_CONFIRM){
 8022b96:	4b86      	ldr	r3, [pc, #536]	; (8022db0 <sm_sc_cmac_done+0x238>)
 8022b98:	781b      	ldrb	r3, [r3, #0]
 8022b9a:	2b03      	cmp	r3, #3
 8022b9c:	d108      	bne.n	8022bb0 <sm_sc_cmac_done+0x38>
        sm_sc_oob_state = SM_SC_OOB_IDLE;
 8022b9e:	4b84      	ldr	r3, [pc, #528]	; (8022db0 <sm_sc_cmac_done+0x238>)
 8022ba0:	2200      	movs	r2, #0
 8022ba2:	701a      	strb	r2, [r3, #0]
        (*sm_sc_oob_callback)(hash, sm_sc_oob_random);
 8022ba4:	4b83      	ldr	r3, [pc, #524]	; (8022db4 <sm_sc_cmac_done+0x23c>)
 8022ba6:	681b      	ldr	r3, [r3, #0]
 8022ba8:	4983      	ldr	r1, [pc, #524]	; (8022db8 <sm_sc_cmac_done+0x240>)
 8022baa:	6878      	ldr	r0, [r7, #4]
 8022bac:	4798      	blx	r3
        return;
 8022bae:	e0f8      	b.n	8022da2 <sm_sc_cmac_done+0x22a>
    }

    sm_connection_t * sm_conn = sm_cmac_connection;
 8022bb0:	4b82      	ldr	r3, [pc, #520]	; (8022dbc <sm_sc_cmac_done+0x244>)
 8022bb2:	681b      	ldr	r3, [r3, #0]
 8022bb4:	60fb      	str	r3, [r7, #12]
    sm_cmac_connection = NULL;
 8022bb6:	4b81      	ldr	r3, [pc, #516]	; (8022dbc <sm_sc_cmac_done+0x244>)
 8022bb8:	2200      	movs	r2, #0
 8022bba:	601a      	str	r2, [r3, #0]
#ifdef ENABLE_CROSS_TRANSPORT_KEY_DERIVATION
    link_key_type_t link_key_type;
#endif

    switch (sm_conn->sm_engine_state){
 8022bbc:	68fb      	ldr	r3, [r7, #12]
 8022bbe:	7b1b      	ldrb	r3, [r3, #12]
 8022bc0:	3b35      	subs	r3, #53	; 0x35
 8022bc2:	2b13      	cmp	r3, #19
 8022bc4:	f200 80e0 	bhi.w	8022d88 <sm_sc_cmac_done+0x210>
 8022bc8:	a201      	add	r2, pc, #4	; (adr r2, 8022bd0 <sm_sc_cmac_done+0x58>)
 8022bca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8022bce:	bf00      	nop
 8022bd0:	08022c21 	.word	0x08022c21
 8022bd4:	08022d89 	.word	0x08022d89
 8022bd8:	08022d89 	.word	0x08022d89
 8022bdc:	08022c39 	.word	0x08022c39
 8022be0:	08022d89 	.word	0x08022d89
 8022be4:	08022d89 	.word	0x08022d89
 8022be8:	08022d89 	.word	0x08022d89
 8022bec:	08022d89 	.word	0x08022d89
 8022bf0:	08022c61 	.word	0x08022c61
 8022bf4:	08022d89 	.word	0x08022d89
 8022bf8:	08022d89 	.word	0x08022d89
 8022bfc:	08022c9b 	.word	0x08022c9b
 8022c00:	08022d89 	.word	0x08022d89
 8022c04:	08022cb5 	.word	0x08022cb5
 8022c08:	08022d89 	.word	0x08022d89
 8022c0c:	08022ccf 	.word	0x08022ccf
 8022c10:	08022d89 	.word	0x08022d89
 8022c14:	08022d0d 	.word	0x08022d0d
 8022c18:	08022d89 	.word	0x08022d89
 8022c1c:	08022d4f 	.word	0x08022d4f
        case SM_SC_W4_CMAC_FOR_CONFIRMATION:
            (void)memcpy(setup->sm_local_confirm, hash, 16);
 8022c20:	4b67      	ldr	r3, [pc, #412]	; (8022dc0 <sm_sc_cmac_done+0x248>)
 8022c22:	681b      	ldr	r3, [r3, #0]
 8022c24:	3357      	adds	r3, #87	; 0x57
 8022c26:	2210      	movs	r2, #16
 8022c28:	6879      	ldr	r1, [r7, #4]
 8022c2a:	4618      	mov	r0, r3
 8022c2c:	f004 ff25 	bl	8027a7a <memcpy>
            sm_conn->sm_engine_state = SM_SC_SEND_CONFIRMATION;
 8022c30:	68fb      	ldr	r3, [r7, #12]
 8022c32:	2236      	movs	r2, #54	; 0x36
 8022c34:	731a      	strb	r2, [r3, #12]
            break;
 8022c36:	e0b2      	b.n	8022d9e <sm_sc_cmac_done+0x226>
        case SM_SC_W4_CMAC_FOR_CHECK_CONFIRMATION:
            // check
            if (0 != memcmp(hash, setup->sm_peer_confirm, 16)){
 8022c38:	4b61      	ldr	r3, [pc, #388]	; (8022dc0 <sm_sc_cmac_done+0x248>)
 8022c3a:	681b      	ldr	r3, [r3, #0]
 8022c3c:	3377      	adds	r3, #119	; 0x77
 8022c3e:	2210      	movs	r2, #16
 8022c40:	4619      	mov	r1, r3
 8022c42:	6878      	ldr	r0, [r7, #4]
 8022c44:	f004 ff0a 	bl	8027a5c <memcmp>
 8022c48:	4603      	mov	r3, r0
 8022c4a:	2b00      	cmp	r3, #0
 8022c4c:	d004      	beq.n	8022c58 <sm_sc_cmac_done+0xe0>
                sm_pairing_error(sm_conn, SM_REASON_CONFIRM_VALUE_FAILED);
 8022c4e:	2104      	movs	r1, #4
 8022c50:	68f8      	ldr	r0, [r7, #12]
 8022c52:	f7ff fee7 	bl	8022a24 <sm_pairing_error>
                break;
 8022c56:	e0a2      	b.n	8022d9e <sm_sc_cmac_done+0x226>
            }
            sm_sc_state_after_receiving_random(sm_conn);
 8022c58:	68f8      	ldr	r0, [r7, #12]
 8022c5a:	f7ff ff29 	bl	8022ab0 <sm_sc_state_after_receiving_random>
            break;
 8022c5e:	e09e      	b.n	8022d9e <sm_sc_cmac_done+0x226>
        case SM_SC_W4_CALCULATE_G2: {
            uint32_t vab = big_endian_read_32(hash, 12) % 1000000;
 8022c60:	210c      	movs	r1, #12
 8022c62:	6878      	ldr	r0, [r7, #4]
 8022c64:	f7ec f96f 	bl	800ef46 <big_endian_read_32>
 8022c68:	4603      	mov	r3, r0
 8022c6a:	4a56      	ldr	r2, [pc, #344]	; (8022dc4 <sm_sc_cmac_done+0x24c>)
 8022c6c:	fba2 1203 	umull	r1, r2, r2, r3
 8022c70:	0c92      	lsrs	r2, r2, #18
 8022c72:	4955      	ldr	r1, [pc, #340]	; (8022dc8 <sm_sc_cmac_done+0x250>)
 8022c74:	fb01 f202 	mul.w	r2, r1, r2
 8022c78:	1a9b      	subs	r3, r3, r2
 8022c7a:	60bb      	str	r3, [r7, #8]
            big_endian_store_32(setup->sm_tk, 12, vab);
 8022c7c:	4b50      	ldr	r3, [pc, #320]	; (8022dc0 <sm_sc_cmac_done+0x248>)
 8022c7e:	681b      	ldr	r3, [r3, #0]
 8022c80:	3317      	adds	r3, #23
 8022c82:	68ba      	ldr	r2, [r7, #8]
 8022c84:	210c      	movs	r1, #12
 8022c86:	4618      	mov	r0, r3
 8022c88:	f7ec f9a5 	bl	800efd6 <big_endian_store_32>
            sm_conn->sm_engine_state = SM_SC_W4_USER_RESPONSE;
 8022c8c:	68fb      	ldr	r3, [r7, #12]
 8022c8e:	2249      	movs	r2, #73	; 0x49
 8022c90:	731a      	strb	r2, [r3, #12]
            sm_trigger_user_response(sm_conn);
 8022c92:	68f8      	ldr	r0, [r7, #12]
 8022c94:	f7ff f8c2 	bl	8021e1c <sm_trigger_user_response>
            break;
 8022c98:	e081      	b.n	8022d9e <sm_sc_cmac_done+0x226>
        }
        case SM_SC_W4_CALCULATE_F5_SALT:
            (void)memcpy(setup->sm_t, hash, 16);
 8022c9a:	4b49      	ldr	r3, [pc, #292]	; (8022dc0 <sm_sc_cmac_done+0x248>)
 8022c9c:	681b      	ldr	r3, [r3, #0]
 8022c9e:	f503 73b3 	add.w	r3, r3, #358	; 0x166
 8022ca2:	2210      	movs	r2, #16
 8022ca4:	6879      	ldr	r1, [r7, #4]
 8022ca6:	4618      	mov	r0, r3
 8022ca8:	f004 fee7 	bl	8027a7a <memcpy>
            sm_conn->sm_engine_state = SM_SC_W2_CALCULATE_F5_MACKEY;
 8022cac:	68fb      	ldr	r3, [r7, #12]
 8022cae:	2241      	movs	r2, #65	; 0x41
 8022cb0:	731a      	strb	r2, [r3, #12]
            break;
 8022cb2:	e074      	b.n	8022d9e <sm_sc_cmac_done+0x226>
        case SM_SC_W4_CALCULATE_F5_MACKEY:
            (void)memcpy(setup->sm_mackey, hash, 16);
 8022cb4:	4b42      	ldr	r3, [pc, #264]	; (8022dc0 <sm_sc_cmac_done+0x248>)
 8022cb6:	681b      	ldr	r3, [r3, #0]
 8022cb8:	f503 73bb 	add.w	r3, r3, #374	; 0x176
 8022cbc:	2210      	movs	r2, #16
 8022cbe:	6879      	ldr	r1, [r7, #4]
 8022cc0:	4618      	mov	r0, r3
 8022cc2:	f004 feda 	bl	8027a7a <memcpy>
            sm_conn->sm_engine_state = SM_SC_W2_CALCULATE_F5_LTK;
 8022cc6:	68fb      	ldr	r3, [r7, #12]
 8022cc8:	2243      	movs	r2, #67	; 0x43
 8022cca:	731a      	strb	r2, [r3, #12]
            break;
 8022ccc:	e067      	b.n	8022d9e <sm_sc_cmac_done+0x226>
        case SM_SC_W4_CALCULATE_F5_LTK:
            // truncate sm_ltk, but keep full LTK for cross-transport key derivation in sm_local_ltk
            // Errata Service Release to the Bluetooth Specification: ESR09
            //   E6405 – Cross transport key derivation from a key of size less than 128 bits
            //   Note: When the BR/EDR link key is being derived from the LTK, the derivation is done before the LTK gets masked."
            (void)memcpy(setup->sm_ltk, hash, 16);
 8022cce:	4b3c      	ldr	r3, [pc, #240]	; (8022dc0 <sm_sc_cmac_done+0x248>)
 8022cd0:	681b      	ldr	r3, [r3, #0]
 8022cd2:	3395      	adds	r3, #149	; 0x95
 8022cd4:	2210      	movs	r2, #16
 8022cd6:	6879      	ldr	r1, [r7, #4]
 8022cd8:	4618      	mov	r0, r3
 8022cda:	f004 fece 	bl	8027a7a <memcpy>
            (void)memcpy(setup->sm_local_ltk, hash, 16);
 8022cde:	4b38      	ldr	r3, [pc, #224]	; (8022dc0 <sm_sc_cmac_done+0x248>)
 8022ce0:	681b      	ldr	r3, [r3, #0]
 8022ce2:	f503 73cb 	add.w	r3, r3, #406	; 0x196
 8022ce6:	2210      	movs	r2, #16
 8022ce8:	6879      	ldr	r1, [r7, #4]
 8022cea:	4618      	mov	r0, r3
 8022cec:	f004 fec5 	bl	8027a7a <memcpy>
            sm_truncate_key(setup->sm_ltk, sm_conn->sm_actual_encryption_key_size);
 8022cf0:	4b33      	ldr	r3, [pc, #204]	; (8022dc0 <sm_sc_cmac_done+0x248>)
 8022cf2:	681b      	ldr	r3, [r3, #0]
 8022cf4:	f103 0295 	add.w	r2, r3, #149	; 0x95
 8022cf8:	68fb      	ldr	r3, [r7, #12]
 8022cfa:	7c5b      	ldrb	r3, [r3, #17]
 8022cfc:	4619      	mov	r1, r3
 8022cfe:	4610      	mov	r0, r2
 8022d00:	f7fe fa8c 	bl	802121c <sm_truncate_key>
            sm_conn->sm_engine_state = SM_SC_W2_CALCULATE_F6_FOR_DHKEY_CHECK;
 8022d04:	68fb      	ldr	r3, [r7, #12]
 8022d06:	2245      	movs	r2, #69	; 0x45
 8022d08:	731a      	strb	r2, [r3, #12]
            break;
 8022d0a:	e048      	b.n	8022d9e <sm_sc_cmac_done+0x226>
        case SM_SC_W4_CALCULATE_F6_FOR_DHKEY_CHECK:
            (void)memcpy(setup->sm_local_dhkey_check, hash, 16);
 8022d0c:	4b2c      	ldr	r3, [pc, #176]	; (8022dc0 <sm_sc_cmac_done+0x248>)
 8022d0e:	681b      	ldr	r3, [r3, #0]
 8022d10:	f503 739b 	add.w	r3, r3, #310	; 0x136
 8022d14:	2210      	movs	r2, #16
 8022d16:	6879      	ldr	r1, [r7, #4]
 8022d18:	4618      	mov	r0, r3
 8022d1a:	f004 feae 	bl	8027a7a <memcpy>
            if (IS_RESPONDER(sm_conn->sm_role)){
 8022d1e:	68fb      	ldr	r3, [r7, #12]
 8022d20:	789b      	ldrb	r3, [r3, #2]
 8022d22:	2b00      	cmp	r3, #0
 8022d24:	d00f      	beq.n	8022d46 <sm_sc_cmac_done+0x1ce>
                // responder
                if (setup->sm_state_vars & SM_STATE_VAR_DHKEY_COMMAND_RECEIVED){
 8022d26:	4b26      	ldr	r3, [pc, #152]	; (8022dc0 <sm_sc_cmac_done+0x248>)
 8022d28:	681b      	ldr	r3, [r3, #0]
 8022d2a:	f893 30a5 	ldrb.w	r3, [r3, #165]	; 0xa5
 8022d2e:	f003 0304 	and.w	r3, r3, #4
 8022d32:	2b00      	cmp	r3, #0
 8022d34:	d003      	beq.n	8022d3e <sm_sc_cmac_done+0x1c6>
                    sm_conn->sm_engine_state = SM_SC_W2_CALCULATE_F6_TO_VERIFY_DHKEY_CHECK;
 8022d36:	68fb      	ldr	r3, [r7, #12]
 8022d38:	2247      	movs	r2, #71	; 0x47
 8022d3a:	731a      	strb	r2, [r3, #12]
                    sm_conn->sm_engine_state = SM_SC_W4_DHKEY_CHECK_COMMAND;
                }
            } else {
                sm_conn->sm_engine_state = SM_SC_SEND_DHKEY_CHECK_COMMAND;
            }
            break;
 8022d3c:	e02f      	b.n	8022d9e <sm_sc_cmac_done+0x226>
                    sm_conn->sm_engine_state = SM_SC_W4_DHKEY_CHECK_COMMAND;
 8022d3e:	68fb      	ldr	r3, [r7, #12]
 8022d40:	224b      	movs	r2, #75	; 0x4b
 8022d42:	731a      	strb	r2, [r3, #12]
            break;
 8022d44:	e02b      	b.n	8022d9e <sm_sc_cmac_done+0x226>
                sm_conn->sm_engine_state = SM_SC_SEND_DHKEY_CHECK_COMMAND;
 8022d46:	68fb      	ldr	r3, [r7, #12]
 8022d48:	224a      	movs	r2, #74	; 0x4a
 8022d4a:	731a      	strb	r2, [r3, #12]
            break;
 8022d4c:	e027      	b.n	8022d9e <sm_sc_cmac_done+0x226>
        case SM_SC_W4_CALCULATE_F6_TO_VERIFY_DHKEY_CHECK:
            if (0 != memcmp(hash, setup->sm_peer_dhkey_check, 16) ){
 8022d4e:	4b1c      	ldr	r3, [pc, #112]	; (8022dc0 <sm_sc_cmac_done+0x248>)
 8022d50:	681b      	ldr	r3, [r3, #0]
 8022d52:	f503 7393 	add.w	r3, r3, #294	; 0x126
 8022d56:	2210      	movs	r2, #16
 8022d58:	4619      	mov	r1, r3
 8022d5a:	6878      	ldr	r0, [r7, #4]
 8022d5c:	f004 fe7e 	bl	8027a5c <memcmp>
 8022d60:	4603      	mov	r3, r0
 8022d62:	2b00      	cmp	r3, #0
 8022d64:	d004      	beq.n	8022d70 <sm_sc_cmac_done+0x1f8>
                sm_pairing_error(sm_conn, SM_REASON_DHKEY_CHECK_FAILED);
 8022d66:	210b      	movs	r1, #11
 8022d68:	68f8      	ldr	r0, [r7, #12]
 8022d6a:	f7ff fe5b 	bl	8022a24 <sm_pairing_error>
                break;
 8022d6e:	e016      	b.n	8022d9e <sm_sc_cmac_done+0x226>
            }
            if (IS_RESPONDER(sm_conn->sm_role)){
 8022d70:	68fb      	ldr	r3, [r7, #12]
 8022d72:	789b      	ldrb	r3, [r3, #2]
 8022d74:	2b00      	cmp	r3, #0
 8022d76:	d003      	beq.n	8022d80 <sm_sc_cmac_done+0x208>
                // responder
                sm_conn->sm_engine_state = SM_SC_SEND_DHKEY_CHECK_COMMAND;
 8022d78:	68fb      	ldr	r3, [r7, #12]
 8022d7a:	224a      	movs	r2, #74	; 0x4a
 8022d7c:	731a      	strb	r2, [r3, #12]
            } else {
                // initiator
                sm_conn->sm_engine_state = SM_INITIATOR_PH3_SEND_START_ENCRYPTION;
            }
            break;
 8022d7e:	e00e      	b.n	8022d9e <sm_sc_cmac_done+0x226>
                sm_conn->sm_engine_state = SM_INITIATOR_PH3_SEND_START_ENCRYPTION;
 8022d80:	68fb      	ldr	r3, [r7, #12]
 8022d82:	222e      	movs	r2, #46	; 0x2e
 8022d84:	731a      	strb	r2, [r3, #12]
            break;
 8022d86:	e00a      	b.n	8022d9e <sm_sc_cmac_done+0x226>
            sm_pairing_complete(sm_conn, ERROR_CODE_SUCCESS, 0);
            sm_done_for_handle(sm_conn->sm_handle);
            break;
#endif
        default:
            log_error("sm_sc_cmac_done in state %u", sm_conn->sm_engine_state);
 8022d88:	68fb      	ldr	r3, [r7, #12]
 8022d8a:	7b1b      	ldrb	r3, [r3, #12]
 8022d8c:	9300      	str	r3, [sp, #0]
 8022d8e:	f240 6396 	movw	r3, #1686	; 0x696
 8022d92:	4a05      	ldr	r2, [pc, #20]	; (8022da8 <sm_sc_cmac_done+0x230>)
 8022d94:	490d      	ldr	r1, [pc, #52]	; (8022dcc <sm_sc_cmac_done+0x254>)
 8022d96:	2002      	movs	r0, #2
 8022d98:	f7f4 fb52 	bl	8017440 <hci_dump_log>
            break;
 8022d9c:	bf00      	nop
    }
    sm_trigger_run();
 8022d9e:	f7fe fa07 	bl	80211b0 <sm_trigger_run>
}
 8022da2:	3710      	adds	r7, #16
 8022da4:	46bd      	mov	sp, r7
 8022da6:	bd80      	pop	{r7, pc}
 8022da8:	0802d4a8 	.word	0x0802d4a8
 8022dac:	0802d968 	.word	0x0802d968
 8022db0:	20009f64 	.word	0x20009f64
 8022db4:	20009f60 	.word	0x20009f60
 8022db8:	20009f50 	.word	0x20009f50
 8022dbc:	20009ff4 	.word	0x20009ff4
 8022dc0:	200000a0 	.word	0x200000a0
 8022dc4:	431bde83 	.word	0x431bde83
 8022dc8:	000f4240 	.word	0x000f4240
 8022dcc:	0802d984 	.word	0x0802d984

08022dd0 <f4_engine>:

static void f4_engine(sm_connection_t * sm_conn, const sm_key256_t u, const sm_key256_t v, const sm_key_t x, uint8_t z){
 8022dd0:	b580      	push	{r7, lr}
 8022dd2:	b086      	sub	sp, #24
 8022dd4:	af00      	add	r7, sp, #0
 8022dd6:	60f8      	str	r0, [r7, #12]
 8022dd8:	60b9      	str	r1, [r7, #8]
 8022dda:	607a      	str	r2, [r7, #4]
 8022ddc:	603b      	str	r3, [r7, #0]
    const uint16_t message_len = 65;
 8022dde:	2341      	movs	r3, #65	; 0x41
 8022de0:	82fb      	strh	r3, [r7, #22]
    sm_cmac_connection = sm_conn;
 8022de2:	4a1a      	ldr	r2, [pc, #104]	; (8022e4c <f4_engine+0x7c>)
 8022de4:	68fb      	ldr	r3, [r7, #12]
 8022de6:	6013      	str	r3, [r2, #0]
    (void)memcpy(sm_cmac_sc_buffer, u, 32);
 8022de8:	2220      	movs	r2, #32
 8022dea:	68b9      	ldr	r1, [r7, #8]
 8022dec:	4818      	ldr	r0, [pc, #96]	; (8022e50 <f4_engine+0x80>)
 8022dee:	f004 fe44 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 32, v, 32);
 8022df2:	4b18      	ldr	r3, [pc, #96]	; (8022e54 <f4_engine+0x84>)
 8022df4:	2220      	movs	r2, #32
 8022df6:	6879      	ldr	r1, [r7, #4]
 8022df8:	4618      	mov	r0, r3
 8022dfa:	f004 fe3e 	bl	8027a7a <memcpy>
    sm_cmac_sc_buffer[64] = z;
 8022dfe:	4a14      	ldr	r2, [pc, #80]	; (8022e50 <f4_engine+0x80>)
 8022e00:	f897 3020 	ldrb.w	r3, [r7, #32]
 8022e04:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
    log_info("f4 key");
 8022e08:	f240 63a2 	movw	r3, #1698	; 0x6a2
 8022e0c:	4a12      	ldr	r2, [pc, #72]	; (8022e58 <f4_engine+0x88>)
 8022e0e:	4913      	ldr	r1, [pc, #76]	; (8022e5c <f4_engine+0x8c>)
 8022e10:	2001      	movs	r0, #1
 8022e12:	f7f4 fb15 	bl	8017440 <hci_dump_log>
    log_info_hexdump(x, 16);
 8022e16:	2110      	movs	r1, #16
 8022e18:	6838      	ldr	r0, [r7, #0]
 8022e1a:	f7ec fa9d 	bl	800f358 <log_info_hexdump>
    log_info("f4 message");
 8022e1e:	f240 63a4 	movw	r3, #1700	; 0x6a4
 8022e22:	4a0d      	ldr	r2, [pc, #52]	; (8022e58 <f4_engine+0x88>)
 8022e24:	490e      	ldr	r1, [pc, #56]	; (8022e60 <f4_engine+0x90>)
 8022e26:	2001      	movs	r0, #1
 8022e28:	f7f4 fb0a 	bl	8017440 <hci_dump_log>
    log_info_hexdump(sm_cmac_sc_buffer, message_len);
 8022e2c:	8afb      	ldrh	r3, [r7, #22]
 8022e2e:	4619      	mov	r1, r3
 8022e30:	4807      	ldr	r0, [pc, #28]	; (8022e50 <f4_engine+0x80>)
 8022e32:	f7ec fa91 	bl	800f358 <log_info_hexdump>
    sm_cmac_message_start(x, message_len, sm_cmac_sc_buffer, &sm_sc_cmac_done);
 8022e36:	8af9      	ldrh	r1, [r7, #22]
 8022e38:	4b0a      	ldr	r3, [pc, #40]	; (8022e64 <f4_engine+0x94>)
 8022e3a:	4a05      	ldr	r2, [pc, #20]	; (8022e50 <f4_engine+0x80>)
 8022e3c:	6838      	ldr	r0, [r7, #0]
 8022e3e:	f7fe ffc5 	bl	8021dcc <sm_cmac_message_start>
}
 8022e42:	bf00      	nop
 8022e44:	3718      	adds	r7, #24
 8022e46:	46bd      	mov	sp, r7
 8022e48:	bd80      	pop	{r7, pc}
 8022e4a:	bf00      	nop
 8022e4c:	20009ff4 	.word	0x20009ff4
 8022e50:	20009ff8 	.word	0x20009ff8
 8022e54:	2000a018 	.word	0x2000a018
 8022e58:	0802d4a8 	.word	0x0802d4a8
 8022e5c:	0802d9a8 	.word	0x0802d9a8
 8022e60:	0802d9b8 	.word	0x0802d9b8
 8022e64:	08022b79 	.word	0x08022b79

08022e68 <f5_calculate_salt>:

static const uint8_t f5_key_id[] = { 0x62, 0x74, 0x6c, 0x65 };
static const uint8_t f5_length[] = { 0x01, 0x00};

static void f5_calculate_salt(sm_connection_t * sm_conn){
 8022e68:	b580      	push	{r7, lr}
 8022e6a:	b084      	sub	sp, #16
 8022e6c:	af00      	add	r7, sp, #0
 8022e6e:	6078      	str	r0, [r7, #4]

    static const sm_key_t f5_salt = { 0x6C ,0x88, 0x83, 0x91, 0xAA, 0xF5, 0xA5, 0x38, 0x60, 0x37, 0x0B, 0xDB, 0x5A, 0x60, 0x83, 0xBE};

    log_info("f5_calculate_salt");
 8022e70:	f44f 63d6 	mov.w	r3, #1712	; 0x6b0
 8022e74:	4a0e      	ldr	r2, [pc, #56]	; (8022eb0 <f5_calculate_salt+0x48>)
 8022e76:	490f      	ldr	r1, [pc, #60]	; (8022eb4 <f5_calculate_salt+0x4c>)
 8022e78:	2001      	movs	r0, #1
 8022e7a:	f7f4 fae1 	bl	8017440 <hci_dump_log>
    // calculate salt for f5
    const uint16_t message_len = 32;
 8022e7e:	2320      	movs	r3, #32
 8022e80:	81fb      	strh	r3, [r7, #14]
    sm_cmac_connection = sm_conn;
 8022e82:	4a0d      	ldr	r2, [pc, #52]	; (8022eb8 <f5_calculate_salt+0x50>)
 8022e84:	687b      	ldr	r3, [r7, #4]
 8022e86:	6013      	str	r3, [r2, #0]
    (void)memcpy(sm_cmac_sc_buffer, setup->sm_dhkey, message_len);
 8022e88:	4b0c      	ldr	r3, [pc, #48]	; (8022ebc <f5_calculate_salt+0x54>)
 8022e8a:	681b      	ldr	r3, [r3, #0]
 8022e8c:	f503 7383 	add.w	r3, r3, #262	; 0x106
 8022e90:	89fa      	ldrh	r2, [r7, #14]
 8022e92:	4619      	mov	r1, r3
 8022e94:	480a      	ldr	r0, [pc, #40]	; (8022ec0 <f5_calculate_salt+0x58>)
 8022e96:	f004 fdf0 	bl	8027a7a <memcpy>
    sm_cmac_message_start(f5_salt, message_len, sm_cmac_sc_buffer, &sm_sc_cmac_done);
 8022e9a:	89f9      	ldrh	r1, [r7, #14]
 8022e9c:	4b09      	ldr	r3, [pc, #36]	; (8022ec4 <f5_calculate_salt+0x5c>)
 8022e9e:	4a08      	ldr	r2, [pc, #32]	; (8022ec0 <f5_calculate_salt+0x58>)
 8022ea0:	4809      	ldr	r0, [pc, #36]	; (8022ec8 <f5_calculate_salt+0x60>)
 8022ea2:	f7fe ff93 	bl	8021dcc <sm_cmac_message_start>
}
 8022ea6:	bf00      	nop
 8022ea8:	3710      	adds	r7, #16
 8022eaa:	46bd      	mov	sp, r7
 8022eac:	bd80      	pop	{r7, pc}
 8022eae:	bf00      	nop
 8022eb0:	0802d4a8 	.word	0x0802d4a8
 8022eb4:	0802d9cc 	.word	0x0802d9cc
 8022eb8:	20009ff4 	.word	0x20009ff4
 8022ebc:	200000a0 	.word	0x200000a0
 8022ec0:	20009ff8 	.word	0x20009ff8
 8022ec4:	08022b79 	.word	0x08022b79
 8022ec8:	08030ed8 	.word	0x08030ed8

08022ecc <f5_mackkey>:

static inline void f5_mackkey(sm_connection_t * sm_conn, sm_key_t t, const sm_key_t n1, const sm_key_t n2, const sm_key56_t a1, const sm_key56_t a2){
 8022ecc:	b580      	push	{r7, lr}
 8022ece:	b086      	sub	sp, #24
 8022ed0:	af00      	add	r7, sp, #0
 8022ed2:	60f8      	str	r0, [r7, #12]
 8022ed4:	60b9      	str	r1, [r7, #8]
 8022ed6:	607a      	str	r2, [r7, #4]
 8022ed8:	603b      	str	r3, [r7, #0]
    const uint16_t message_len = 53;
 8022eda:	2335      	movs	r3, #53	; 0x35
 8022edc:	82fb      	strh	r3, [r7, #22]
    sm_cmac_connection = sm_conn;
 8022ede:	4a23      	ldr	r2, [pc, #140]	; (8022f6c <f5_mackkey+0xa0>)
 8022ee0:	68fb      	ldr	r3, [r7, #12]
 8022ee2:	6013      	str	r3, [r2, #0]

    // f5(W, N1, N2, A1, A2) = AES-CMACT (Counter = 0 || keyID || N1 || N2|| A1|| A2 || Length = 256) -- this is the MacKey
    sm_cmac_sc_buffer[0] = 0;
 8022ee4:	4b22      	ldr	r3, [pc, #136]	; (8022f70 <f5_mackkey+0xa4>)
 8022ee6:	2200      	movs	r2, #0
 8022ee8:	701a      	strb	r2, [r3, #0]
    (void)memcpy(sm_cmac_sc_buffer + 01, f5_key_id, 4);
 8022eea:	4a22      	ldr	r2, [pc, #136]	; (8022f74 <f5_mackkey+0xa8>)
 8022eec:	4b22      	ldr	r3, [pc, #136]	; (8022f78 <f5_mackkey+0xac>)
 8022eee:	681b      	ldr	r3, [r3, #0]
 8022ef0:	6013      	str	r3, [r2, #0]
    (void)memcpy(sm_cmac_sc_buffer + 05, n1, 16);
 8022ef2:	4b22      	ldr	r3, [pc, #136]	; (8022f7c <f5_mackkey+0xb0>)
 8022ef4:	2210      	movs	r2, #16
 8022ef6:	6879      	ldr	r1, [r7, #4]
 8022ef8:	4618      	mov	r0, r3
 8022efa:	f004 fdbe 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 21, n2, 16);
 8022efe:	4b20      	ldr	r3, [pc, #128]	; (8022f80 <f5_mackkey+0xb4>)
 8022f00:	2210      	movs	r2, #16
 8022f02:	6839      	ldr	r1, [r7, #0]
 8022f04:	4618      	mov	r0, r3
 8022f06:	f004 fdb8 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 37, a1, 7);
 8022f0a:	4b1e      	ldr	r3, [pc, #120]	; (8022f84 <f5_mackkey+0xb8>)
 8022f0c:	2207      	movs	r2, #7
 8022f0e:	6a39      	ldr	r1, [r7, #32]
 8022f10:	4618      	mov	r0, r3
 8022f12:	f004 fdb2 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 44, a2, 7);
 8022f16:	4b1c      	ldr	r3, [pc, #112]	; (8022f88 <f5_mackkey+0xbc>)
 8022f18:	2207      	movs	r2, #7
 8022f1a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8022f1c:	4618      	mov	r0, r3
 8022f1e:	f004 fdac 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 51, f5_length, 2);
 8022f22:	4a1a      	ldr	r2, [pc, #104]	; (8022f8c <f5_mackkey+0xc0>)
 8022f24:	4b1a      	ldr	r3, [pc, #104]	; (8022f90 <f5_mackkey+0xc4>)
 8022f26:	881b      	ldrh	r3, [r3, #0]
 8022f28:	8013      	strh	r3, [r2, #0]
    log_info("f5 key");
 8022f2a:	f240 63c4 	movw	r3, #1732	; 0x6c4
 8022f2e:	4a19      	ldr	r2, [pc, #100]	; (8022f94 <f5_mackkey+0xc8>)
 8022f30:	4919      	ldr	r1, [pc, #100]	; (8022f98 <f5_mackkey+0xcc>)
 8022f32:	2001      	movs	r0, #1
 8022f34:	f7f4 fa84 	bl	8017440 <hci_dump_log>
    log_info_hexdump(t, 16);
 8022f38:	2110      	movs	r1, #16
 8022f3a:	68b8      	ldr	r0, [r7, #8]
 8022f3c:	f7ec fa0c 	bl	800f358 <log_info_hexdump>
    log_info("f5 message for MacKey");
 8022f40:	f240 63c6 	movw	r3, #1734	; 0x6c6
 8022f44:	4a13      	ldr	r2, [pc, #76]	; (8022f94 <f5_mackkey+0xc8>)
 8022f46:	4915      	ldr	r1, [pc, #84]	; (8022f9c <f5_mackkey+0xd0>)
 8022f48:	2001      	movs	r0, #1
 8022f4a:	f7f4 fa79 	bl	8017440 <hci_dump_log>
    log_info_hexdump(sm_cmac_sc_buffer, message_len);
 8022f4e:	8afb      	ldrh	r3, [r7, #22]
 8022f50:	4619      	mov	r1, r3
 8022f52:	4807      	ldr	r0, [pc, #28]	; (8022f70 <f5_mackkey+0xa4>)
 8022f54:	f7ec fa00 	bl	800f358 <log_info_hexdump>
    sm_cmac_message_start(t, message_len, sm_cmac_sc_buffer, &sm_sc_cmac_done);
 8022f58:	8af9      	ldrh	r1, [r7, #22]
 8022f5a:	4b11      	ldr	r3, [pc, #68]	; (8022fa0 <f5_mackkey+0xd4>)
 8022f5c:	4a04      	ldr	r2, [pc, #16]	; (8022f70 <f5_mackkey+0xa4>)
 8022f5e:	68b8      	ldr	r0, [r7, #8]
 8022f60:	f7fe ff34 	bl	8021dcc <sm_cmac_message_start>
}
 8022f64:	bf00      	nop
 8022f66:	3718      	adds	r7, #24
 8022f68:	46bd      	mov	sp, r7
 8022f6a:	bd80      	pop	{r7, pc}
 8022f6c:	20009ff4 	.word	0x20009ff4
 8022f70:	20009ff8 	.word	0x20009ff8
 8022f74:	20009ff9 	.word	0x20009ff9
 8022f78:	08030e98 	.word	0x08030e98
 8022f7c:	20009ffd 	.word	0x20009ffd
 8022f80:	2000a00d 	.word	0x2000a00d
 8022f84:	2000a01d 	.word	0x2000a01d
 8022f88:	2000a024 	.word	0x2000a024
 8022f8c:	2000a02b 	.word	0x2000a02b
 8022f90:	08030e9c 	.word	0x08030e9c
 8022f94:	0802d4a8 	.word	0x0802d4a8
 8022f98:	0802d9e8 	.word	0x0802d9e8
 8022f9c:	0802d9f8 	.word	0x0802d9f8
 8022fa0:	08022b79 	.word	0x08022b79

08022fa4 <f5_calculate_mackey>:

static void f5_calculate_mackey(sm_connection_t * sm_conn){
 8022fa4:	b580      	push	{r7, lr}
 8022fa6:	b088      	sub	sp, #32
 8022fa8:	af02      	add	r7, sp, #8
 8022faa:	6078      	str	r0, [r7, #4]
    sm_key56_t bd_addr_master, bd_addr_slave;
    bd_addr_master[0] =  setup->sm_m_addr_type;
 8022fac:	4b2a      	ldr	r3, [pc, #168]	; (8023058 <f5_calculate_mackey+0xb4>)
 8022fae:	681b      	ldr	r3, [r3, #0]
 8022fb0:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
 8022fb4:	743b      	strb	r3, [r7, #16]
    bd_addr_slave[0]  =  setup->sm_s_addr_type;
 8022fb6:	4b28      	ldr	r3, [pc, #160]	; (8023058 <f5_calculate_mackey+0xb4>)
 8022fb8:	681b      	ldr	r3, [r3, #0]
 8022fba:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 8022fbe:	723b      	strb	r3, [r7, #8]
    (void)memcpy(&bd_addr_master[1], setup->sm_m_address, 6);
 8022fc0:	4b25      	ldr	r3, [pc, #148]	; (8023058 <f5_calculate_mackey+0xb4>)
 8022fc2:	681b      	ldr	r3, [r3, #0]
 8022fc4:	f103 0189 	add.w	r1, r3, #137	; 0x89
 8022fc8:	f107 0310 	add.w	r3, r7, #16
 8022fcc:	3301      	adds	r3, #1
 8022fce:	2206      	movs	r2, #6
 8022fd0:	4618      	mov	r0, r3
 8022fd2:	f004 fd52 	bl	8027a7a <memcpy>
    (void)memcpy(&bd_addr_slave[1], setup->sm_s_address, 6);
 8022fd6:	4b20      	ldr	r3, [pc, #128]	; (8023058 <f5_calculate_mackey+0xb4>)
 8022fd8:	681b      	ldr	r3, [r3, #0]
 8022fda:	f103 018f 	add.w	r1, r3, #143	; 0x8f
 8022fde:	f107 0308 	add.w	r3, r7, #8
 8022fe2:	3301      	adds	r3, #1
 8022fe4:	2206      	movs	r2, #6
 8022fe6:	4618      	mov	r0, r3
 8022fe8:	f004 fd47 	bl	8027a7a <memcpy>
    if (IS_RESPONDER(sm_conn->sm_role)){
 8022fec:	687b      	ldr	r3, [r7, #4]
 8022fee:	789b      	ldrb	r3, [r3, #2]
 8022ff0:	2b00      	cmp	r3, #0
 8022ff2:	d016      	beq.n	8023022 <f5_calculate_mackey+0x7e>
        // responder
        f5_mackkey(sm_conn, setup->sm_t, setup->sm_peer_nonce, setup->sm_local_nonce, bd_addr_master, bd_addr_slave);
 8022ff4:	4b18      	ldr	r3, [pc, #96]	; (8023058 <f5_calculate_mackey+0xb4>)
 8022ff6:	681b      	ldr	r3, [r3, #0]
 8022ff8:	f503 71b3 	add.w	r1, r3, #358	; 0x166
 8022ffc:	4b16      	ldr	r3, [pc, #88]	; (8023058 <f5_calculate_mackey+0xb4>)
 8022ffe:	681b      	ldr	r3, [r3, #0]
 8023000:	f103 02e6 	add.w	r2, r3, #230	; 0xe6
 8023004:	4b14      	ldr	r3, [pc, #80]	; (8023058 <f5_calculate_mackey+0xb4>)
 8023006:	681b      	ldr	r3, [r3, #0]
 8023008:	f103 00f6 	add.w	r0, r3, #246	; 0xf6
 802300c:	f107 0308 	add.w	r3, r7, #8
 8023010:	9301      	str	r3, [sp, #4]
 8023012:	f107 0310 	add.w	r3, r7, #16
 8023016:	9300      	str	r3, [sp, #0]
 8023018:	4603      	mov	r3, r0
 802301a:	6878      	ldr	r0, [r7, #4]
 802301c:	f7ff ff56 	bl	8022ecc <f5_mackkey>
    } else {
        // initiator
        f5_mackkey(sm_conn, setup->sm_t, setup->sm_local_nonce, setup->sm_peer_nonce, bd_addr_master, bd_addr_slave);
    }
}
 8023020:	e015      	b.n	802304e <f5_calculate_mackey+0xaa>
        f5_mackkey(sm_conn, setup->sm_t, setup->sm_local_nonce, setup->sm_peer_nonce, bd_addr_master, bd_addr_slave);
 8023022:	4b0d      	ldr	r3, [pc, #52]	; (8023058 <f5_calculate_mackey+0xb4>)
 8023024:	681b      	ldr	r3, [r3, #0]
 8023026:	f503 71b3 	add.w	r1, r3, #358	; 0x166
 802302a:	4b0b      	ldr	r3, [pc, #44]	; (8023058 <f5_calculate_mackey+0xb4>)
 802302c:	681b      	ldr	r3, [r3, #0]
 802302e:	f103 02f6 	add.w	r2, r3, #246	; 0xf6
 8023032:	4b09      	ldr	r3, [pc, #36]	; (8023058 <f5_calculate_mackey+0xb4>)
 8023034:	681b      	ldr	r3, [r3, #0]
 8023036:	f103 00e6 	add.w	r0, r3, #230	; 0xe6
 802303a:	f107 0308 	add.w	r3, r7, #8
 802303e:	9301      	str	r3, [sp, #4]
 8023040:	f107 0310 	add.w	r3, r7, #16
 8023044:	9300      	str	r3, [sp, #0]
 8023046:	4603      	mov	r3, r0
 8023048:	6878      	ldr	r0, [r7, #4]
 802304a:	f7ff ff3f 	bl	8022ecc <f5_mackkey>
}
 802304e:	bf00      	nop
 8023050:	3718      	adds	r7, #24
 8023052:	46bd      	mov	sp, r7
 8023054:	bd80      	pop	{r7, pc}
 8023056:	bf00      	nop
 8023058:	200000a0 	.word	0x200000a0

0802305c <f5_ltk>:

// note: must be called right after f5_mackey, as sm_cmac_buffer[1..52] will be reused
static inline void f5_ltk(sm_connection_t * sm_conn, sm_key_t t){
 802305c:	b580      	push	{r7, lr}
 802305e:	b084      	sub	sp, #16
 8023060:	af00      	add	r7, sp, #0
 8023062:	6078      	str	r0, [r7, #4]
 8023064:	6039      	str	r1, [r7, #0]
    const uint16_t message_len = 53;
 8023066:	2335      	movs	r3, #53	; 0x35
 8023068:	81fb      	strh	r3, [r7, #14]
    sm_cmac_connection = sm_conn;
 802306a:	4a13      	ldr	r2, [pc, #76]	; (80230b8 <f5_ltk+0x5c>)
 802306c:	687b      	ldr	r3, [r7, #4]
 802306e:	6013      	str	r3, [r2, #0]
    sm_cmac_sc_buffer[0] = 1;
 8023070:	4b12      	ldr	r3, [pc, #72]	; (80230bc <f5_ltk+0x60>)
 8023072:	2201      	movs	r2, #1
 8023074:	701a      	strb	r2, [r3, #0]
    // 1..52 setup before
    log_info("f5 key");
 8023076:	f44f 63dc 	mov.w	r3, #1760	; 0x6e0
 802307a:	4a11      	ldr	r2, [pc, #68]	; (80230c0 <f5_ltk+0x64>)
 802307c:	4911      	ldr	r1, [pc, #68]	; (80230c4 <f5_ltk+0x68>)
 802307e:	2001      	movs	r0, #1
 8023080:	f7f4 f9de 	bl	8017440 <hci_dump_log>
    log_info_hexdump(t, 16);
 8023084:	2110      	movs	r1, #16
 8023086:	6838      	ldr	r0, [r7, #0]
 8023088:	f7ec f966 	bl	800f358 <log_info_hexdump>
    log_info("f5 message for LTK");
 802308c:	f240 63e2 	movw	r3, #1762	; 0x6e2
 8023090:	4a0b      	ldr	r2, [pc, #44]	; (80230c0 <f5_ltk+0x64>)
 8023092:	490d      	ldr	r1, [pc, #52]	; (80230c8 <f5_ltk+0x6c>)
 8023094:	2001      	movs	r0, #1
 8023096:	f7f4 f9d3 	bl	8017440 <hci_dump_log>
    log_info_hexdump(sm_cmac_sc_buffer, message_len);
 802309a:	89fb      	ldrh	r3, [r7, #14]
 802309c:	4619      	mov	r1, r3
 802309e:	4807      	ldr	r0, [pc, #28]	; (80230bc <f5_ltk+0x60>)
 80230a0:	f7ec f95a 	bl	800f358 <log_info_hexdump>
    sm_cmac_message_start(t, message_len, sm_cmac_sc_buffer, &sm_sc_cmac_done);
 80230a4:	89f9      	ldrh	r1, [r7, #14]
 80230a6:	4b09      	ldr	r3, [pc, #36]	; (80230cc <f5_ltk+0x70>)
 80230a8:	4a04      	ldr	r2, [pc, #16]	; (80230bc <f5_ltk+0x60>)
 80230aa:	6838      	ldr	r0, [r7, #0]
 80230ac:	f7fe fe8e 	bl	8021dcc <sm_cmac_message_start>
}
 80230b0:	bf00      	nop
 80230b2:	3710      	adds	r7, #16
 80230b4:	46bd      	mov	sp, r7
 80230b6:	bd80      	pop	{r7, pc}
 80230b8:	20009ff4 	.word	0x20009ff4
 80230bc:	20009ff8 	.word	0x20009ff8
 80230c0:	0802d4a8 	.word	0x0802d4a8
 80230c4:	0802d9e8 	.word	0x0802d9e8
 80230c8:	0802da18 	.word	0x0802da18
 80230cc:	08022b79 	.word	0x08022b79

080230d0 <f5_calculate_ltk>:

static void f5_calculate_ltk(sm_connection_t * sm_conn){
 80230d0:	b580      	push	{r7, lr}
 80230d2:	b082      	sub	sp, #8
 80230d4:	af00      	add	r7, sp, #0
 80230d6:	6078      	str	r0, [r7, #4]
    f5_ltk(sm_conn, setup->sm_t);
 80230d8:	4b05      	ldr	r3, [pc, #20]	; (80230f0 <f5_calculate_ltk+0x20>)
 80230da:	681b      	ldr	r3, [r3, #0]
 80230dc:	f503 73b3 	add.w	r3, r3, #358	; 0x166
 80230e0:	4619      	mov	r1, r3
 80230e2:	6878      	ldr	r0, [r7, #4]
 80230e4:	f7ff ffba 	bl	802305c <f5_ltk>
}
 80230e8:	bf00      	nop
 80230ea:	3708      	adds	r7, #8
 80230ec:	46bd      	mov	sp, r7
 80230ee:	bd80      	pop	{r7, pc}
 80230f0:	200000a0 	.word	0x200000a0

080230f4 <f6_setup>:

static void f6_setup(const sm_key_t n1, const sm_key_t n2, const sm_key_t r, const sm_key24_t io_cap, const sm_key56_t a1, const sm_key56_t a2){
 80230f4:	b580      	push	{r7, lr}
 80230f6:	b084      	sub	sp, #16
 80230f8:	af00      	add	r7, sp, #0
 80230fa:	60f8      	str	r0, [r7, #12]
 80230fc:	60b9      	str	r1, [r7, #8]
 80230fe:	607a      	str	r2, [r7, #4]
 8023100:	603b      	str	r3, [r7, #0]
    (void)memcpy(sm_cmac_sc_buffer, n1, 16);
 8023102:	2210      	movs	r2, #16
 8023104:	68f9      	ldr	r1, [r7, #12]
 8023106:	4812      	ldr	r0, [pc, #72]	; (8023150 <f6_setup+0x5c>)
 8023108:	f004 fcb7 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 16, n2, 16);
 802310c:	4b11      	ldr	r3, [pc, #68]	; (8023154 <f6_setup+0x60>)
 802310e:	2210      	movs	r2, #16
 8023110:	68b9      	ldr	r1, [r7, #8]
 8023112:	4618      	mov	r0, r3
 8023114:	f004 fcb1 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 32, r, 16);
 8023118:	4b0f      	ldr	r3, [pc, #60]	; (8023158 <f6_setup+0x64>)
 802311a:	2210      	movs	r2, #16
 802311c:	6879      	ldr	r1, [r7, #4]
 802311e:	4618      	mov	r0, r3
 8023120:	f004 fcab 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 48, io_cap, 3);
 8023124:	4b0d      	ldr	r3, [pc, #52]	; (802315c <f6_setup+0x68>)
 8023126:	2203      	movs	r2, #3
 8023128:	6839      	ldr	r1, [r7, #0]
 802312a:	4618      	mov	r0, r3
 802312c:	f004 fca5 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 51, a1, 7);
 8023130:	4b0b      	ldr	r3, [pc, #44]	; (8023160 <f6_setup+0x6c>)
 8023132:	2207      	movs	r2, #7
 8023134:	69b9      	ldr	r1, [r7, #24]
 8023136:	4618      	mov	r0, r3
 8023138:	f004 fc9f 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 58, a2, 7);
 802313c:	4b09      	ldr	r3, [pc, #36]	; (8023164 <f6_setup+0x70>)
 802313e:	2207      	movs	r2, #7
 8023140:	69f9      	ldr	r1, [r7, #28]
 8023142:	4618      	mov	r0, r3
 8023144:	f004 fc99 	bl	8027a7a <memcpy>
}
 8023148:	bf00      	nop
 802314a:	3710      	adds	r7, #16
 802314c:	46bd      	mov	sp, r7
 802314e:	bd80      	pop	{r7, pc}
 8023150:	20009ff8 	.word	0x20009ff8
 8023154:	2000a008 	.word	0x2000a008
 8023158:	2000a018 	.word	0x2000a018
 802315c:	2000a028 	.word	0x2000a028
 8023160:	2000a02b 	.word	0x2000a02b
 8023164:	2000a032 	.word	0x2000a032

08023168 <f6_engine>:

static void f6_engine(sm_connection_t * sm_conn, const sm_key_t w){
 8023168:	b580      	push	{r7, lr}
 802316a:	b084      	sub	sp, #16
 802316c:	af00      	add	r7, sp, #0
 802316e:	6078      	str	r0, [r7, #4]
 8023170:	6039      	str	r1, [r7, #0]
    const uint16_t message_len = 65;
 8023172:	2341      	movs	r3, #65	; 0x41
 8023174:	81fb      	strh	r3, [r7, #14]
    sm_cmac_connection = sm_conn;
 8023176:	4a12      	ldr	r2, [pc, #72]	; (80231c0 <f6_engine+0x58>)
 8023178:	687b      	ldr	r3, [r7, #4]
 802317a:	6013      	str	r3, [r2, #0]
    log_info("f6 key");
 802317c:	f240 63f7 	movw	r3, #1783	; 0x6f7
 8023180:	4a10      	ldr	r2, [pc, #64]	; (80231c4 <f6_engine+0x5c>)
 8023182:	4911      	ldr	r1, [pc, #68]	; (80231c8 <f6_engine+0x60>)
 8023184:	2001      	movs	r0, #1
 8023186:	f7f4 f95b 	bl	8017440 <hci_dump_log>
    log_info_hexdump(w, 16);
 802318a:	2110      	movs	r1, #16
 802318c:	6838      	ldr	r0, [r7, #0]
 802318e:	f7ec f8e3 	bl	800f358 <log_info_hexdump>
    log_info("f6 message");
 8023192:	f240 63f9 	movw	r3, #1785	; 0x6f9
 8023196:	4a0b      	ldr	r2, [pc, #44]	; (80231c4 <f6_engine+0x5c>)
 8023198:	490c      	ldr	r1, [pc, #48]	; (80231cc <f6_engine+0x64>)
 802319a:	2001      	movs	r0, #1
 802319c:	f7f4 f950 	bl	8017440 <hci_dump_log>
    log_info_hexdump(sm_cmac_sc_buffer, message_len);
 80231a0:	89fb      	ldrh	r3, [r7, #14]
 80231a2:	4619      	mov	r1, r3
 80231a4:	480a      	ldr	r0, [pc, #40]	; (80231d0 <f6_engine+0x68>)
 80231a6:	f7ec f8d7 	bl	800f358 <log_info_hexdump>
    sm_cmac_message_start(w, 65, sm_cmac_sc_buffer, &sm_sc_cmac_done);
 80231aa:	4b0a      	ldr	r3, [pc, #40]	; (80231d4 <f6_engine+0x6c>)
 80231ac:	4a08      	ldr	r2, [pc, #32]	; (80231d0 <f6_engine+0x68>)
 80231ae:	2141      	movs	r1, #65	; 0x41
 80231b0:	6838      	ldr	r0, [r7, #0]
 80231b2:	f7fe fe0b 	bl	8021dcc <sm_cmac_message_start>
}
 80231b6:	bf00      	nop
 80231b8:	3710      	adds	r7, #16
 80231ba:	46bd      	mov	sp, r7
 80231bc:	bd80      	pop	{r7, pc}
 80231be:	bf00      	nop
 80231c0:	20009ff4 	.word	0x20009ff4
 80231c4:	0802d4a8 	.word	0x0802d4a8
 80231c8:	0802da34 	.word	0x0802da34
 80231cc:	0802da44 	.word	0x0802da44
 80231d0:	20009ff8 	.word	0x20009ff8
 80231d4:	08022b79 	.word	0x08022b79

080231d8 <g2_engine>:
// g2(U, V, X, Y) = AES-CMACX(U || V || Y) mod 2^32
// - U is 256 bits
// - V is 256 bits
// - X is 128 bits
// - Y is 128 bits
static void g2_engine(sm_connection_t * sm_conn, const sm_key256_t u, const sm_key256_t v, const sm_key_t x, const sm_key_t y){
 80231d8:	b580      	push	{r7, lr}
 80231da:	b086      	sub	sp, #24
 80231dc:	af00      	add	r7, sp, #0
 80231de:	60f8      	str	r0, [r7, #12]
 80231e0:	60b9      	str	r1, [r7, #8]
 80231e2:	607a      	str	r2, [r7, #4]
 80231e4:	603b      	str	r3, [r7, #0]
    const uint16_t message_len = 80;
 80231e6:	2350      	movs	r3, #80	; 0x50
 80231e8:	82fb      	strh	r3, [r7, #22]
    sm_cmac_connection = sm_conn;
 80231ea:	4a1a      	ldr	r2, [pc, #104]	; (8023254 <g2_engine+0x7c>)
 80231ec:	68fb      	ldr	r3, [r7, #12]
 80231ee:	6013      	str	r3, [r2, #0]
    (void)memcpy(sm_cmac_sc_buffer, u, 32);
 80231f0:	2220      	movs	r2, #32
 80231f2:	68b9      	ldr	r1, [r7, #8]
 80231f4:	4818      	ldr	r0, [pc, #96]	; (8023258 <g2_engine+0x80>)
 80231f6:	f004 fc40 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 32, v, 32);
 80231fa:	4b18      	ldr	r3, [pc, #96]	; (802325c <g2_engine+0x84>)
 80231fc:	2220      	movs	r2, #32
 80231fe:	6879      	ldr	r1, [r7, #4]
 8023200:	4618      	mov	r0, r3
 8023202:	f004 fc3a 	bl	8027a7a <memcpy>
    (void)memcpy(sm_cmac_sc_buffer + 64, y, 16);
 8023206:	4b16      	ldr	r3, [pc, #88]	; (8023260 <g2_engine+0x88>)
 8023208:	2210      	movs	r2, #16
 802320a:	6a39      	ldr	r1, [r7, #32]
 802320c:	4618      	mov	r0, r3
 802320e:	f004 fc34 	bl	8027a7a <memcpy>
    log_info("g2 key");
 8023212:	f240 7309 	movw	r3, #1801	; 0x709
 8023216:	4a13      	ldr	r2, [pc, #76]	; (8023264 <g2_engine+0x8c>)
 8023218:	4913      	ldr	r1, [pc, #76]	; (8023268 <g2_engine+0x90>)
 802321a:	2001      	movs	r0, #1
 802321c:	f7f4 f910 	bl	8017440 <hci_dump_log>
    log_info_hexdump(x, 16);
 8023220:	2110      	movs	r1, #16
 8023222:	6838      	ldr	r0, [r7, #0]
 8023224:	f7ec f898 	bl	800f358 <log_info_hexdump>
    log_info("g2 message");
 8023228:	f240 730b 	movw	r3, #1803	; 0x70b
 802322c:	4a0d      	ldr	r2, [pc, #52]	; (8023264 <g2_engine+0x8c>)
 802322e:	490f      	ldr	r1, [pc, #60]	; (802326c <g2_engine+0x94>)
 8023230:	2001      	movs	r0, #1
 8023232:	f7f4 f905 	bl	8017440 <hci_dump_log>
    log_info_hexdump(sm_cmac_sc_buffer, message_len);
 8023236:	8afb      	ldrh	r3, [r7, #22]
 8023238:	4619      	mov	r1, r3
 802323a:	4807      	ldr	r0, [pc, #28]	; (8023258 <g2_engine+0x80>)
 802323c:	f7ec f88c 	bl	800f358 <log_info_hexdump>
    sm_cmac_message_start(x, message_len, sm_cmac_sc_buffer, &sm_sc_cmac_done);
 8023240:	8af9      	ldrh	r1, [r7, #22]
 8023242:	4b0b      	ldr	r3, [pc, #44]	; (8023270 <g2_engine+0x98>)
 8023244:	4a04      	ldr	r2, [pc, #16]	; (8023258 <g2_engine+0x80>)
 8023246:	6838      	ldr	r0, [r7, #0]
 8023248:	f7fe fdc0 	bl	8021dcc <sm_cmac_message_start>
}
 802324c:	bf00      	nop
 802324e:	3718      	adds	r7, #24
 8023250:	46bd      	mov	sp, r7
 8023252:	bd80      	pop	{r7, pc}
 8023254:	20009ff4 	.word	0x20009ff4
 8023258:	20009ff8 	.word	0x20009ff8
 802325c:	2000a018 	.word	0x2000a018
 8023260:	2000a038 	.word	0x2000a038
 8023264:	0802d4a8 	.word	0x0802d4a8
 8023268:	0802da58 	.word	0x0802da58
 802326c:	0802da68 	.word	0x0802da68
 8023270:	08022b79 	.word	0x08022b79

08023274 <g2_calculate>:

static void g2_calculate(sm_connection_t * sm_conn) {
 8023274:	b580      	push	{r7, lr}
 8023276:	b084      	sub	sp, #16
 8023278:	af02      	add	r7, sp, #8
 802327a:	6078      	str	r0, [r7, #4]
    // calc Va if numeric comparison
    if (IS_RESPONDER(sm_conn->sm_role)){
 802327c:	687b      	ldr	r3, [r7, #4]
 802327e:	789b      	ldrb	r3, [r3, #2]
 8023280:	2b00      	cmp	r3, #0
 8023282:	d011      	beq.n	80232a8 <g2_calculate+0x34>
        // responder
        g2_engine(sm_conn, setup->sm_peer_q, ec_q, setup->sm_peer_nonce, setup->sm_local_nonce);;
 8023284:	4b13      	ldr	r3, [pc, #76]	; (80232d4 <g2_calculate+0x60>)
 8023286:	681b      	ldr	r3, [r3, #0]
 8023288:	f103 01a6 	add.w	r1, r3, #166	; 0xa6
 802328c:	4b11      	ldr	r3, [pc, #68]	; (80232d4 <g2_calculate+0x60>)
 802328e:	681b      	ldr	r3, [r3, #0]
 8023290:	f103 02e6 	add.w	r2, r3, #230	; 0xe6
 8023294:	4b0f      	ldr	r3, [pc, #60]	; (80232d4 <g2_calculate+0x60>)
 8023296:	681b      	ldr	r3, [r3, #0]
 8023298:	33f6      	adds	r3, #246	; 0xf6
 802329a:	9300      	str	r3, [sp, #0]
 802329c:	4613      	mov	r3, r2
 802329e:	4a0e      	ldr	r2, [pc, #56]	; (80232d8 <g2_calculate+0x64>)
 80232a0:	6878      	ldr	r0, [r7, #4]
 80232a2:	f7ff ff99 	bl	80231d8 <g2_engine>
    } else {
        // initiator
        g2_engine(sm_conn, ec_q, setup->sm_peer_q, setup->sm_local_nonce, setup->sm_peer_nonce);
    }
}
 80232a6:	e010      	b.n	80232ca <g2_calculate+0x56>
        g2_engine(sm_conn, ec_q, setup->sm_peer_q, setup->sm_local_nonce, setup->sm_peer_nonce);
 80232a8:	4b0a      	ldr	r3, [pc, #40]	; (80232d4 <g2_calculate+0x60>)
 80232aa:	681b      	ldr	r3, [r3, #0]
 80232ac:	f103 02a6 	add.w	r2, r3, #166	; 0xa6
 80232b0:	4b08      	ldr	r3, [pc, #32]	; (80232d4 <g2_calculate+0x60>)
 80232b2:	681b      	ldr	r3, [r3, #0]
 80232b4:	f103 01f6 	add.w	r1, r3, #246	; 0xf6
 80232b8:	4b06      	ldr	r3, [pc, #24]	; (80232d4 <g2_calculate+0x60>)
 80232ba:	681b      	ldr	r3, [r3, #0]
 80232bc:	33e6      	adds	r3, #230	; 0xe6
 80232be:	9300      	str	r3, [sp, #0]
 80232c0:	460b      	mov	r3, r1
 80232c2:	4905      	ldr	r1, [pc, #20]	; (80232d8 <g2_calculate+0x64>)
 80232c4:	6878      	ldr	r0, [r7, #4]
 80232c6:	f7ff ff87 	bl	80231d8 <g2_engine>
}
 80232ca:	bf00      	nop
 80232cc:	3708      	adds	r7, #8
 80232ce:	46bd      	mov	sp, r7
 80232d0:	bd80      	pop	{r7, pc}
 80232d2:	bf00      	nop
 80232d4:	200000a0 	.word	0x200000a0
 80232d8:	2000a110 	.word	0x2000a110

080232dc <sm_sc_calculate_local_confirm>:

static void sm_sc_calculate_local_confirm(sm_connection_t * sm_conn){
 80232dc:	b580      	push	{r7, lr}
 80232de:	b086      	sub	sp, #24
 80232e0:	af02      	add	r7, sp, #8
 80232e2:	6078      	str	r0, [r7, #4]
    uint8_t z = 0;
 80232e4:	2300      	movs	r3, #0
 80232e6:	73fb      	strb	r3, [r7, #15]
    if (sm_passkey_entry(setup->sm_stk_generation_method)){
 80232e8:	4b1c      	ldr	r3, [pc, #112]	; (802335c <sm_sc_calculate_local_confirm+0x80>)
 80232ea:	681b      	ldr	r3, [r3, #0]
 80232ec:	7d9b      	ldrb	r3, [r3, #22]
 80232ee:	4618      	mov	r0, r3
 80232f0:	f003 f86e 	bl	80263d0 <sm_passkey_entry>
 80232f4:	4603      	mov	r3, r0
 80232f6:	2b00      	cmp	r3, #0
 80232f8:	d01d      	beq.n	8023336 <sm_sc_calculate_local_confirm+0x5a>
        // some form of passkey
        uint32_t pk = big_endian_read_32(setup->sm_tk, 12);
 80232fa:	4b18      	ldr	r3, [pc, #96]	; (802335c <sm_sc_calculate_local_confirm+0x80>)
 80232fc:	681b      	ldr	r3, [r3, #0]
 80232fe:	3317      	adds	r3, #23
 8023300:	210c      	movs	r1, #12
 8023302:	4618      	mov	r0, r3
 8023304:	f7eb fe1f 	bl	800ef46 <big_endian_read_32>
 8023308:	60b8      	str	r0, [r7, #8]
        z = 0x80u | ((pk >> setup->sm_passkey_bit) & 1u);
 802330a:	4b14      	ldr	r3, [pc, #80]	; (802335c <sm_sc_calculate_local_confirm+0x80>)
 802330c:	681b      	ldr	r3, [r3, #0]
 802330e:	f893 3186 	ldrb.w	r3, [r3, #390]	; 0x186
 8023312:	461a      	mov	r2, r3
 8023314:	68bb      	ldr	r3, [r7, #8]
 8023316:	40d3      	lsrs	r3, r2
 8023318:	b2db      	uxtb	r3, r3
 802331a:	f003 0301 	and.w	r3, r3, #1
 802331e:	b2db      	uxtb	r3, r3
 8023320:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8023324:	73fb      	strb	r3, [r7, #15]
        setup->sm_passkey_bit++;
 8023326:	4b0d      	ldr	r3, [pc, #52]	; (802335c <sm_sc_calculate_local_confirm+0x80>)
 8023328:	681b      	ldr	r3, [r3, #0]
 802332a:	f893 2186 	ldrb.w	r2, [r3, #390]	; 0x186
 802332e:	3201      	adds	r2, #1
 8023330:	b2d2      	uxtb	r2, r2
 8023332:	f883 2186 	strb.w	r2, [r3, #390]	; 0x186
    }
    f4_engine(sm_conn, ec_q, setup->sm_peer_q, setup->sm_local_nonce, z);
 8023336:	4b09      	ldr	r3, [pc, #36]	; (802335c <sm_sc_calculate_local_confirm+0x80>)
 8023338:	681b      	ldr	r3, [r3, #0]
 802333a:	f103 02a6 	add.w	r2, r3, #166	; 0xa6
 802333e:	4b07      	ldr	r3, [pc, #28]	; (802335c <sm_sc_calculate_local_confirm+0x80>)
 8023340:	681b      	ldr	r3, [r3, #0]
 8023342:	f103 01f6 	add.w	r1, r3, #246	; 0xf6
 8023346:	7bfb      	ldrb	r3, [r7, #15]
 8023348:	9300      	str	r3, [sp, #0]
 802334a:	460b      	mov	r3, r1
 802334c:	4904      	ldr	r1, [pc, #16]	; (8023360 <sm_sc_calculate_local_confirm+0x84>)
 802334e:	6878      	ldr	r0, [r7, #4]
 8023350:	f7ff fd3e 	bl	8022dd0 <f4_engine>
}
 8023354:	bf00      	nop
 8023356:	3710      	adds	r7, #16
 8023358:	46bd      	mov	sp, r7
 802335a:	bd80      	pop	{r7, pc}
 802335c:	200000a0 	.word	0x200000a0
 8023360:	2000a110 	.word	0x2000a110

08023364 <sm_sc_calculate_remote_confirm>:

static void sm_sc_calculate_remote_confirm(sm_connection_t * sm_conn){
 8023364:	b580      	push	{r7, lr}
 8023366:	b086      	sub	sp, #24
 8023368:	af02      	add	r7, sp, #8
 802336a:	6078      	str	r0, [r7, #4]
    // OOB
    if (setup->sm_stk_generation_method == OOB){
 802336c:	4b31      	ldr	r3, [pc, #196]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 802336e:	681b      	ldr	r3, [r3, #0]
 8023370:	7d9b      	ldrb	r3, [r3, #22]
 8023372:	2b05      	cmp	r3, #5
 8023374:	d129      	bne.n	80233ca <sm_sc_calculate_remote_confirm+0x66>
        if (IS_RESPONDER(sm_conn->sm_role)){
 8023376:	687b      	ldr	r3, [r7, #4]
 8023378:	789b      	ldrb	r3, [r3, #2]
 802337a:	2b00      	cmp	r3, #0
 802337c:	d012      	beq.n	80233a4 <sm_sc_calculate_remote_confirm+0x40>
            f4_engine(sm_conn, setup->sm_peer_q, setup->sm_peer_q, setup->sm_ra, 0);
 802337e:	4b2d      	ldr	r3, [pc, #180]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 8023380:	681b      	ldr	r3, [r3, #0]
 8023382:	f103 01a6 	add.w	r1, r3, #166	; 0xa6
 8023386:	4b2b      	ldr	r3, [pc, #172]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 8023388:	681b      	ldr	r3, [r3, #0]
 802338a:	f103 02a6 	add.w	r2, r3, #166	; 0xa6
 802338e:	4b29      	ldr	r3, [pc, #164]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 8023390:	681b      	ldr	r3, [r3, #0]
 8023392:	f503 70a3 	add.w	r0, r3, #326	; 0x146
 8023396:	2300      	movs	r3, #0
 8023398:	9300      	str	r3, [sp, #0]
 802339a:	4603      	mov	r3, r0
 802339c:	6878      	ldr	r0, [r7, #4]
 802339e:	f7ff fd17 	bl	8022dd0 <f4_engine>
        } else {
            f4_engine(sm_conn, setup->sm_peer_q, setup->sm_peer_q, setup->sm_rb, 0);
        }
        return;
 80233a2:	e043      	b.n	802342c <sm_sc_calculate_remote_confirm+0xc8>
            f4_engine(sm_conn, setup->sm_peer_q, setup->sm_peer_q, setup->sm_rb, 0);
 80233a4:	4b23      	ldr	r3, [pc, #140]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 80233a6:	681b      	ldr	r3, [r3, #0]
 80233a8:	f103 01a6 	add.w	r1, r3, #166	; 0xa6
 80233ac:	4b21      	ldr	r3, [pc, #132]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 80233ae:	681b      	ldr	r3, [r3, #0]
 80233b0:	f103 02a6 	add.w	r2, r3, #166	; 0xa6
 80233b4:	4b1f      	ldr	r3, [pc, #124]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 80233b6:	681b      	ldr	r3, [r3, #0]
 80233b8:	f503 70ab 	add.w	r0, r3, #342	; 0x156
 80233bc:	2300      	movs	r3, #0
 80233be:	9300      	str	r3, [sp, #0]
 80233c0:	4603      	mov	r3, r0
 80233c2:	6878      	ldr	r0, [r7, #4]
 80233c4:	f7ff fd04 	bl	8022dd0 <f4_engine>
        return;
 80233c8:	e030      	b.n	802342c <sm_sc_calculate_remote_confirm+0xc8>
    }

    uint8_t z = 0;
 80233ca:	2300      	movs	r3, #0
 80233cc:	73fb      	strb	r3, [r7, #15]
    if (sm_passkey_entry(setup->sm_stk_generation_method)){
 80233ce:	4b19      	ldr	r3, [pc, #100]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 80233d0:	681b      	ldr	r3, [r3, #0]
 80233d2:	7d9b      	ldrb	r3, [r3, #22]
 80233d4:	4618      	mov	r0, r3
 80233d6:	f002 fffb 	bl	80263d0 <sm_passkey_entry>
 80233da:	4603      	mov	r3, r0
 80233dc:	2b00      	cmp	r3, #0
 80233de:	d016      	beq.n	802340e <sm_sc_calculate_remote_confirm+0xaa>
        // some form of passkey
        uint32_t pk = big_endian_read_32(setup->sm_tk, 12);
 80233e0:	4b14      	ldr	r3, [pc, #80]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 80233e2:	681b      	ldr	r3, [r3, #0]
 80233e4:	3317      	adds	r3, #23
 80233e6:	210c      	movs	r1, #12
 80233e8:	4618      	mov	r0, r3
 80233ea:	f7eb fdac 	bl	800ef46 <big_endian_read_32>
 80233ee:	60b8      	str	r0, [r7, #8]
        // sm_passkey_bit was increased before sending confirm value
        z = 0x80u | ((pk >> (setup->sm_passkey_bit-1u)) & 1u);
 80233f0:	4b10      	ldr	r3, [pc, #64]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 80233f2:	681b      	ldr	r3, [r3, #0]
 80233f4:	f893 3186 	ldrb.w	r3, [r3, #390]	; 0x186
 80233f8:	3b01      	subs	r3, #1
 80233fa:	68ba      	ldr	r2, [r7, #8]
 80233fc:	fa22 f303 	lsr.w	r3, r2, r3
 8023400:	b2db      	uxtb	r3, r3
 8023402:	f003 0301 	and.w	r3, r3, #1
 8023406:	b2db      	uxtb	r3, r3
 8023408:	f063 037f 	orn	r3, r3, #127	; 0x7f
 802340c:	73fb      	strb	r3, [r7, #15]
    }
    f4_engine(sm_conn, setup->sm_peer_q, ec_q, setup->sm_peer_nonce, z);
 802340e:	4b09      	ldr	r3, [pc, #36]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 8023410:	681b      	ldr	r3, [r3, #0]
 8023412:	f103 01a6 	add.w	r1, r3, #166	; 0xa6
 8023416:	4b07      	ldr	r3, [pc, #28]	; (8023434 <sm_sc_calculate_remote_confirm+0xd0>)
 8023418:	681b      	ldr	r3, [r3, #0]
 802341a:	f103 02e6 	add.w	r2, r3, #230	; 0xe6
 802341e:	7bfb      	ldrb	r3, [r7, #15]
 8023420:	9300      	str	r3, [sp, #0]
 8023422:	4613      	mov	r3, r2
 8023424:	4a04      	ldr	r2, [pc, #16]	; (8023438 <sm_sc_calculate_remote_confirm+0xd4>)
 8023426:	6878      	ldr	r0, [r7, #4]
 8023428:	f7ff fcd2 	bl	8022dd0 <f4_engine>
}
 802342c:	3710      	adds	r7, #16
 802342e:	46bd      	mov	sp, r7
 8023430:	bd80      	pop	{r7, pc}
 8023432:	bf00      	nop
 8023434:	200000a0 	.word	0x200000a0
 8023438:	2000a110 	.word	0x2000a110

0802343c <sm_sc_prepare_dhkey_check>:

static void sm_sc_prepare_dhkey_check(sm_connection_t * sm_conn){
 802343c:	b580      	push	{r7, lr}
 802343e:	b084      	sub	sp, #16
 8023440:	af02      	add	r7, sp, #8
 8023442:	6078      	str	r0, [r7, #4]
    log_info("sm_sc_prepare_dhkey_check, DHKEY calculated %u", (setup->sm_state_vars & SM_STATE_VAR_DHKEY_CALCULATED) ? 1 : 0);
 8023444:	4b10      	ldr	r3, [pc, #64]	; (8023488 <sm_sc_prepare_dhkey_check+0x4c>)
 8023446:	681b      	ldr	r3, [r3, #0]
 8023448:	f893 30a5 	ldrb.w	r3, [r3, #165]	; 0xa5
 802344c:	105b      	asrs	r3, r3, #1
 802344e:	f003 0301 	and.w	r3, r3, #1
 8023452:	9300      	str	r3, [sp, #0]
 8023454:	f240 733c 	movw	r3, #1852	; 0x73c
 8023458:	4a0c      	ldr	r2, [pc, #48]	; (802348c <sm_sc_prepare_dhkey_check+0x50>)
 802345a:	490d      	ldr	r1, [pc, #52]	; (8023490 <sm_sc_prepare_dhkey_check+0x54>)
 802345c:	2001      	movs	r0, #1
 802345e:	f7f3 ffef 	bl	8017440 <hci_dump_log>

    if (setup->sm_state_vars & SM_STATE_VAR_DHKEY_CALCULATED){
 8023462:	4b09      	ldr	r3, [pc, #36]	; (8023488 <sm_sc_prepare_dhkey_check+0x4c>)
 8023464:	681b      	ldr	r3, [r3, #0]
 8023466:	f893 30a5 	ldrb.w	r3, [r3, #165]	; 0xa5
 802346a:	f003 0302 	and.w	r3, r3, #2
 802346e:	2b00      	cmp	r3, #0
 8023470:	d003      	beq.n	802347a <sm_sc_prepare_dhkey_check+0x3e>
        sm_conn->sm_engine_state = SM_SC_W2_CALCULATE_F5_SALT;
 8023472:	687b      	ldr	r3, [r7, #4]
 8023474:	223f      	movs	r2, #63	; 0x3f
 8023476:	731a      	strb	r2, [r3, #12]
        return;
 8023478:	e002      	b.n	8023480 <sm_sc_prepare_dhkey_check+0x44>
    } else {
        sm_conn->sm_engine_state = SM_SC_W4_CALCULATE_DHKEY;
 802347a:	687b      	ldr	r3, [r7, #4]
 802347c:	223e      	movs	r2, #62	; 0x3e
 802347e:	731a      	strb	r2, [r3, #12]
    }
}
 8023480:	3708      	adds	r7, #8
 8023482:	46bd      	mov	sp, r7
 8023484:	bd80      	pop	{r7, pc}
 8023486:	bf00      	nop
 8023488:	200000a0 	.word	0x200000a0
 802348c:	0802d4a8 	.word	0x0802d4a8
 8023490:	0802da7c 	.word	0x0802da7c

08023494 <sm_sc_dhkey_calculated>:

static void sm_sc_dhkey_calculated(void * arg){
 8023494:	b580      	push	{r7, lr}
 8023496:	b084      	sub	sp, #16
 8023498:	af00      	add	r7, sp, #0
 802349a:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 802349c:	687b      	ldr	r3, [r7, #4]
 802349e:	81fb      	strh	r3, [r7, #14]
    sm_connection_t * sm_conn = sm_get_connection_for_handle(con_handle);
 80234a0:	89fb      	ldrh	r3, [r7, #14]
 80234a2:	4618      	mov	r0, r3
 80234a4:	f003 fe64 	bl	8027170 <sm_get_connection_for_handle>
 80234a8:	60b8      	str	r0, [r7, #8]
    if (sm_conn == NULL) return;
 80234aa:	68bb      	ldr	r3, [r7, #8]
 80234ac:	2b00      	cmp	r3, #0
 80234ae:	d023      	beq.n	80234f8 <sm_sc_dhkey_calculated+0x64>

    log_info("dhkey");
 80234b0:	f240 734b 	movw	r3, #1867	; 0x74b
 80234b4:	4a12      	ldr	r2, [pc, #72]	; (8023500 <sm_sc_dhkey_calculated+0x6c>)
 80234b6:	4913      	ldr	r1, [pc, #76]	; (8023504 <sm_sc_dhkey_calculated+0x70>)
 80234b8:	2001      	movs	r0, #1
 80234ba:	f7f3 ffc1 	bl	8017440 <hci_dump_log>
    log_info_hexdump(&setup->sm_dhkey[0], 32);
 80234be:	4b12      	ldr	r3, [pc, #72]	; (8023508 <sm_sc_dhkey_calculated+0x74>)
 80234c0:	681b      	ldr	r3, [r3, #0]
 80234c2:	f503 7383 	add.w	r3, r3, #262	; 0x106
 80234c6:	2120      	movs	r1, #32
 80234c8:	4618      	mov	r0, r3
 80234ca:	f7eb ff45 	bl	800f358 <log_info_hexdump>
    setup->sm_state_vars |= SM_STATE_VAR_DHKEY_CALCULATED;
 80234ce:	4b0e      	ldr	r3, [pc, #56]	; (8023508 <sm_sc_dhkey_calculated+0x74>)
 80234d0:	681b      	ldr	r3, [r3, #0]
 80234d2:	f893 20a5 	ldrb.w	r2, [r3, #165]	; 0xa5
 80234d6:	4b0c      	ldr	r3, [pc, #48]	; (8023508 <sm_sc_dhkey_calculated+0x74>)
 80234d8:	681b      	ldr	r3, [r3, #0]
 80234da:	f042 0202 	orr.w	r2, r2, #2
 80234de:	b2d2      	uxtb	r2, r2
 80234e0:	f883 20a5 	strb.w	r2, [r3, #165]	; 0xa5
    // trigger next step
    if (sm_conn->sm_engine_state == SM_SC_W4_CALCULATE_DHKEY){
 80234e4:	68bb      	ldr	r3, [r7, #8]
 80234e6:	7b1b      	ldrb	r3, [r3, #12]
 80234e8:	2b3e      	cmp	r3, #62	; 0x3e
 80234ea:	d102      	bne.n	80234f2 <sm_sc_dhkey_calculated+0x5e>
        sm_conn->sm_engine_state = SM_SC_W2_CALCULATE_F5_SALT;
 80234ec:	68bb      	ldr	r3, [r7, #8]
 80234ee:	223f      	movs	r2, #63	; 0x3f
 80234f0:	731a      	strb	r2, [r3, #12]
    }
    sm_trigger_run();
 80234f2:	f7fd fe5d 	bl	80211b0 <sm_trigger_run>
 80234f6:	e000      	b.n	80234fa <sm_sc_dhkey_calculated+0x66>
    if (sm_conn == NULL) return;
 80234f8:	bf00      	nop
}
 80234fa:	3710      	adds	r7, #16
 80234fc:	46bd      	mov	sp, r7
 80234fe:	bd80      	pop	{r7, pc}
 8023500:	0802d4a8 	.word	0x0802d4a8
 8023504:	0802dab4 	.word	0x0802dab4
 8023508:	200000a0 	.word	0x200000a0

0802350c <sm_sc_calculate_f6_for_dhkey_check>:

static void sm_sc_calculate_f6_for_dhkey_check(sm_connection_t * sm_conn){
 802350c:	b590      	push	{r4, r7, lr}
 802350e:	b08b      	sub	sp, #44	; 0x2c
 8023510:	af02      	add	r7, sp, #8
 8023512:	6078      	str	r0, [r7, #4]
    // calculate DHKCheck
    sm_key56_t bd_addr_master, bd_addr_slave;
    bd_addr_master[0] =  setup->sm_m_addr_type;
 8023514:	4b4b      	ldr	r3, [pc, #300]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 8023516:	681b      	ldr	r3, [r3, #0]
 8023518:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
 802351c:	763b      	strb	r3, [r7, #24]
    bd_addr_slave[0]  =  setup->sm_s_addr_type;
 802351e:	4b49      	ldr	r3, [pc, #292]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 8023520:	681b      	ldr	r3, [r3, #0]
 8023522:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 8023526:	743b      	strb	r3, [r7, #16]
    (void)memcpy(&bd_addr_master[1], setup->sm_m_address, 6);
 8023528:	4b46      	ldr	r3, [pc, #280]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 802352a:	681b      	ldr	r3, [r3, #0]
 802352c:	f103 0189 	add.w	r1, r3, #137	; 0x89
 8023530:	f107 0318 	add.w	r3, r7, #24
 8023534:	3301      	adds	r3, #1
 8023536:	2206      	movs	r2, #6
 8023538:	4618      	mov	r0, r3
 802353a:	f004 fa9e 	bl	8027a7a <memcpy>
    (void)memcpy(&bd_addr_slave[1], setup->sm_s_address, 6);
 802353e:	4b41      	ldr	r3, [pc, #260]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 8023540:	681b      	ldr	r3, [r3, #0]
 8023542:	f103 018f 	add.w	r1, r3, #143	; 0x8f
 8023546:	f107 0310 	add.w	r3, r7, #16
 802354a:	3301      	adds	r3, #1
 802354c:	2206      	movs	r2, #6
 802354e:	4618      	mov	r0, r3
 8023550:	f004 fa93 	bl	8027a7a <memcpy>
    uint8_t iocap_a[3];
    iocap_a[0] = sm_pairing_packet_get_auth_req(setup->sm_m_preq);
 8023554:	4b3b      	ldr	r3, [pc, #236]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 8023556:	681b      	ldr	r3, [r3, #0]
 8023558:	3339      	adds	r3, #57	; 0x39
 802355a:	4618      	mov	r0, r3
 802355c:	f7fd fd46 	bl	8020fec <sm_pairing_packet_get_auth_req>
 8023560:	4603      	mov	r3, r0
 8023562:	733b      	strb	r3, [r7, #12]
    iocap_a[1] = sm_pairing_packet_get_oob_data_flag(setup->sm_m_preq);
 8023564:	4b37      	ldr	r3, [pc, #220]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 8023566:	681b      	ldr	r3, [r3, #0]
 8023568:	3339      	adds	r3, #57	; 0x39
 802356a:	4618      	mov	r0, r3
 802356c:	f7fd fd32 	bl	8020fd4 <sm_pairing_packet_get_oob_data_flag>
 8023570:	4603      	mov	r3, r0
 8023572:	737b      	strb	r3, [r7, #13]
    iocap_a[2] = sm_pairing_packet_get_io_capability(setup->sm_m_preq);
 8023574:	4b33      	ldr	r3, [pc, #204]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 8023576:	681b      	ldr	r3, [r3, #0]
 8023578:	3339      	adds	r3, #57	; 0x39
 802357a:	4618      	mov	r0, r3
 802357c:	f7fd fd1e 	bl	8020fbc <sm_pairing_packet_get_io_capability>
 8023580:	4603      	mov	r3, r0
 8023582:	73bb      	strb	r3, [r7, #14]
    uint8_t iocap_b[3];
    iocap_b[0] = sm_pairing_packet_get_auth_req(setup->sm_s_pres);
 8023584:	4b2f      	ldr	r3, [pc, #188]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 8023586:	681b      	ldr	r3, [r3, #0]
 8023588:	3340      	adds	r3, #64	; 0x40
 802358a:	4618      	mov	r0, r3
 802358c:	f7fd fd2e 	bl	8020fec <sm_pairing_packet_get_auth_req>
 8023590:	4603      	mov	r3, r0
 8023592:	723b      	strb	r3, [r7, #8]
    iocap_b[1] = sm_pairing_packet_get_oob_data_flag(setup->sm_s_pres);
 8023594:	4b2b      	ldr	r3, [pc, #172]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 8023596:	681b      	ldr	r3, [r3, #0]
 8023598:	3340      	adds	r3, #64	; 0x40
 802359a:	4618      	mov	r0, r3
 802359c:	f7fd fd1a 	bl	8020fd4 <sm_pairing_packet_get_oob_data_flag>
 80235a0:	4603      	mov	r3, r0
 80235a2:	727b      	strb	r3, [r7, #9]
    iocap_b[2] = sm_pairing_packet_get_io_capability(setup->sm_s_pres);
 80235a4:	4b27      	ldr	r3, [pc, #156]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 80235a6:	681b      	ldr	r3, [r3, #0]
 80235a8:	3340      	adds	r3, #64	; 0x40
 80235aa:	4618      	mov	r0, r3
 80235ac:	f7fd fd06 	bl	8020fbc <sm_pairing_packet_get_io_capability>
 80235b0:	4603      	mov	r3, r0
 80235b2:	72bb      	strb	r3, [r7, #10]
    if (IS_RESPONDER(sm_conn->sm_role)){
 80235b4:	687b      	ldr	r3, [r7, #4]
 80235b6:	789b      	ldrb	r3, [r3, #2]
 80235b8:	2b00      	cmp	r3, #0
 80235ba:	d01f      	beq.n	80235fc <sm_sc_calculate_f6_for_dhkey_check+0xf0>
        // responder
        f6_setup(setup->sm_local_nonce, setup->sm_peer_nonce, setup->sm_ra, iocap_b, bd_addr_slave, bd_addr_master);
 80235bc:	4b21      	ldr	r3, [pc, #132]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 80235be:	681b      	ldr	r3, [r3, #0]
 80235c0:	f103 00f6 	add.w	r0, r3, #246	; 0xf6
 80235c4:	4b1f      	ldr	r3, [pc, #124]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 80235c6:	681b      	ldr	r3, [r3, #0]
 80235c8:	f103 01e6 	add.w	r1, r3, #230	; 0xe6
 80235cc:	4b1d      	ldr	r3, [pc, #116]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 80235ce:	681b      	ldr	r3, [r3, #0]
 80235d0:	f503 72a3 	add.w	r2, r3, #326	; 0x146
 80235d4:	f107 0408 	add.w	r4, r7, #8
 80235d8:	f107 0318 	add.w	r3, r7, #24
 80235dc:	9301      	str	r3, [sp, #4]
 80235de:	f107 0310 	add.w	r3, r7, #16
 80235e2:	9300      	str	r3, [sp, #0]
 80235e4:	4623      	mov	r3, r4
 80235e6:	f7ff fd85 	bl	80230f4 <f6_setup>
        f6_engine(sm_conn, setup->sm_mackey);
 80235ea:	4b16      	ldr	r3, [pc, #88]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 80235ec:	681b      	ldr	r3, [r3, #0]
 80235ee:	f503 73bb 	add.w	r3, r3, #374	; 0x176
 80235f2:	4619      	mov	r1, r3
 80235f4:	6878      	ldr	r0, [r7, #4]
 80235f6:	f7ff fdb7 	bl	8023168 <f6_engine>
    } else {
        // initiator
        f6_setup( setup->sm_local_nonce, setup->sm_peer_nonce, setup->sm_rb, iocap_a, bd_addr_master, bd_addr_slave);
        f6_engine(sm_conn, setup->sm_mackey);
    }
}
 80235fa:	e01e      	b.n	802363a <sm_sc_calculate_f6_for_dhkey_check+0x12e>
        f6_setup( setup->sm_local_nonce, setup->sm_peer_nonce, setup->sm_rb, iocap_a, bd_addr_master, bd_addr_slave);
 80235fc:	4b11      	ldr	r3, [pc, #68]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 80235fe:	681b      	ldr	r3, [r3, #0]
 8023600:	f103 00f6 	add.w	r0, r3, #246	; 0xf6
 8023604:	4b0f      	ldr	r3, [pc, #60]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 8023606:	681b      	ldr	r3, [r3, #0]
 8023608:	f103 01e6 	add.w	r1, r3, #230	; 0xe6
 802360c:	4b0d      	ldr	r3, [pc, #52]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 802360e:	681b      	ldr	r3, [r3, #0]
 8023610:	f503 72ab 	add.w	r2, r3, #342	; 0x156
 8023614:	f107 040c 	add.w	r4, r7, #12
 8023618:	f107 0310 	add.w	r3, r7, #16
 802361c:	9301      	str	r3, [sp, #4]
 802361e:	f107 0318 	add.w	r3, r7, #24
 8023622:	9300      	str	r3, [sp, #0]
 8023624:	4623      	mov	r3, r4
 8023626:	f7ff fd65 	bl	80230f4 <f6_setup>
        f6_engine(sm_conn, setup->sm_mackey);
 802362a:	4b06      	ldr	r3, [pc, #24]	; (8023644 <sm_sc_calculate_f6_for_dhkey_check+0x138>)
 802362c:	681b      	ldr	r3, [r3, #0]
 802362e:	f503 73bb 	add.w	r3, r3, #374	; 0x176
 8023632:	4619      	mov	r1, r3
 8023634:	6878      	ldr	r0, [r7, #4]
 8023636:	f7ff fd97 	bl	8023168 <f6_engine>
}
 802363a:	bf00      	nop
 802363c:	3724      	adds	r7, #36	; 0x24
 802363e:	46bd      	mov	sp, r7
 8023640:	bd90      	pop	{r4, r7, pc}
 8023642:	bf00      	nop
 8023644:	200000a0 	.word	0x200000a0

08023648 <sm_sc_calculate_f6_to_verify_dhkey_check>:

static void sm_sc_calculate_f6_to_verify_dhkey_check(sm_connection_t * sm_conn){
 8023648:	b590      	push	{r4, r7, lr}
 802364a:	b08b      	sub	sp, #44	; 0x2c
 802364c:	af02      	add	r7, sp, #8
 802364e:	6078      	str	r0, [r7, #4]
    // validate E = f6()
    sm_key56_t bd_addr_master, bd_addr_slave;
    bd_addr_master[0] =  setup->sm_m_addr_type;
 8023650:	4b4b      	ldr	r3, [pc, #300]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 8023652:	681b      	ldr	r3, [r3, #0]
 8023654:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
 8023658:	763b      	strb	r3, [r7, #24]
    bd_addr_slave[0]  =  setup->sm_s_addr_type;
 802365a:	4b49      	ldr	r3, [pc, #292]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 802365c:	681b      	ldr	r3, [r3, #0]
 802365e:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 8023662:	743b      	strb	r3, [r7, #16]
    (void)memcpy(&bd_addr_master[1], setup->sm_m_address, 6);
 8023664:	4b46      	ldr	r3, [pc, #280]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 8023666:	681b      	ldr	r3, [r3, #0]
 8023668:	f103 0189 	add.w	r1, r3, #137	; 0x89
 802366c:	f107 0318 	add.w	r3, r7, #24
 8023670:	3301      	adds	r3, #1
 8023672:	2206      	movs	r2, #6
 8023674:	4618      	mov	r0, r3
 8023676:	f004 fa00 	bl	8027a7a <memcpy>
    (void)memcpy(&bd_addr_slave[1], setup->sm_s_address, 6);
 802367a:	4b41      	ldr	r3, [pc, #260]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 802367c:	681b      	ldr	r3, [r3, #0]
 802367e:	f103 018f 	add.w	r1, r3, #143	; 0x8f
 8023682:	f107 0310 	add.w	r3, r7, #16
 8023686:	3301      	adds	r3, #1
 8023688:	2206      	movs	r2, #6
 802368a:	4618      	mov	r0, r3
 802368c:	f004 f9f5 	bl	8027a7a <memcpy>

    uint8_t iocap_a[3];
    iocap_a[0] = sm_pairing_packet_get_auth_req(setup->sm_m_preq);
 8023690:	4b3b      	ldr	r3, [pc, #236]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 8023692:	681b      	ldr	r3, [r3, #0]
 8023694:	3339      	adds	r3, #57	; 0x39
 8023696:	4618      	mov	r0, r3
 8023698:	f7fd fca8 	bl	8020fec <sm_pairing_packet_get_auth_req>
 802369c:	4603      	mov	r3, r0
 802369e:	733b      	strb	r3, [r7, #12]
    iocap_a[1] = sm_pairing_packet_get_oob_data_flag(setup->sm_m_preq);
 80236a0:	4b37      	ldr	r3, [pc, #220]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 80236a2:	681b      	ldr	r3, [r3, #0]
 80236a4:	3339      	adds	r3, #57	; 0x39
 80236a6:	4618      	mov	r0, r3
 80236a8:	f7fd fc94 	bl	8020fd4 <sm_pairing_packet_get_oob_data_flag>
 80236ac:	4603      	mov	r3, r0
 80236ae:	737b      	strb	r3, [r7, #13]
    iocap_a[2] = sm_pairing_packet_get_io_capability(setup->sm_m_preq);
 80236b0:	4b33      	ldr	r3, [pc, #204]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 80236b2:	681b      	ldr	r3, [r3, #0]
 80236b4:	3339      	adds	r3, #57	; 0x39
 80236b6:	4618      	mov	r0, r3
 80236b8:	f7fd fc80 	bl	8020fbc <sm_pairing_packet_get_io_capability>
 80236bc:	4603      	mov	r3, r0
 80236be:	73bb      	strb	r3, [r7, #14]
    uint8_t iocap_b[3];
    iocap_b[0] = sm_pairing_packet_get_auth_req(setup->sm_s_pres);
 80236c0:	4b2f      	ldr	r3, [pc, #188]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 80236c2:	681b      	ldr	r3, [r3, #0]
 80236c4:	3340      	adds	r3, #64	; 0x40
 80236c6:	4618      	mov	r0, r3
 80236c8:	f7fd fc90 	bl	8020fec <sm_pairing_packet_get_auth_req>
 80236cc:	4603      	mov	r3, r0
 80236ce:	723b      	strb	r3, [r7, #8]
    iocap_b[1] = sm_pairing_packet_get_oob_data_flag(setup->sm_s_pres);
 80236d0:	4b2b      	ldr	r3, [pc, #172]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 80236d2:	681b      	ldr	r3, [r3, #0]
 80236d4:	3340      	adds	r3, #64	; 0x40
 80236d6:	4618      	mov	r0, r3
 80236d8:	f7fd fc7c 	bl	8020fd4 <sm_pairing_packet_get_oob_data_flag>
 80236dc:	4603      	mov	r3, r0
 80236de:	727b      	strb	r3, [r7, #9]
    iocap_b[2] = sm_pairing_packet_get_io_capability(setup->sm_s_pres);
 80236e0:	4b27      	ldr	r3, [pc, #156]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 80236e2:	681b      	ldr	r3, [r3, #0]
 80236e4:	3340      	adds	r3, #64	; 0x40
 80236e6:	4618      	mov	r0, r3
 80236e8:	f7fd fc68 	bl	8020fbc <sm_pairing_packet_get_io_capability>
 80236ec:	4603      	mov	r3, r0
 80236ee:	72bb      	strb	r3, [r7, #10]
    if (IS_RESPONDER(sm_conn->sm_role)){
 80236f0:	687b      	ldr	r3, [r7, #4]
 80236f2:	789b      	ldrb	r3, [r3, #2]
 80236f4:	2b00      	cmp	r3, #0
 80236f6:	d01f      	beq.n	8023738 <sm_sc_calculate_f6_to_verify_dhkey_check+0xf0>
        // responder
        f6_setup(setup->sm_peer_nonce, setup->sm_local_nonce, setup->sm_rb, iocap_a, bd_addr_master, bd_addr_slave);
 80236f8:	4b21      	ldr	r3, [pc, #132]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 80236fa:	681b      	ldr	r3, [r3, #0]
 80236fc:	f103 00e6 	add.w	r0, r3, #230	; 0xe6
 8023700:	4b1f      	ldr	r3, [pc, #124]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 8023702:	681b      	ldr	r3, [r3, #0]
 8023704:	f103 01f6 	add.w	r1, r3, #246	; 0xf6
 8023708:	4b1d      	ldr	r3, [pc, #116]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 802370a:	681b      	ldr	r3, [r3, #0]
 802370c:	f503 72ab 	add.w	r2, r3, #342	; 0x156
 8023710:	f107 040c 	add.w	r4, r7, #12
 8023714:	f107 0310 	add.w	r3, r7, #16
 8023718:	9301      	str	r3, [sp, #4]
 802371a:	f107 0318 	add.w	r3, r7, #24
 802371e:	9300      	str	r3, [sp, #0]
 8023720:	4623      	mov	r3, r4
 8023722:	f7ff fce7 	bl	80230f4 <f6_setup>
        f6_engine(sm_conn, setup->sm_mackey);
 8023726:	4b16      	ldr	r3, [pc, #88]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 8023728:	681b      	ldr	r3, [r3, #0]
 802372a:	f503 73bb 	add.w	r3, r3, #374	; 0x176
 802372e:	4619      	mov	r1, r3
 8023730:	6878      	ldr	r0, [r7, #4]
 8023732:	f7ff fd19 	bl	8023168 <f6_engine>
    } else {
        // initiator
        f6_setup(setup->sm_peer_nonce, setup->sm_local_nonce, setup->sm_ra, iocap_b, bd_addr_slave, bd_addr_master);
        f6_engine(sm_conn, setup->sm_mackey);
    }
}
 8023736:	e01e      	b.n	8023776 <sm_sc_calculate_f6_to_verify_dhkey_check+0x12e>
        f6_setup(setup->sm_peer_nonce, setup->sm_local_nonce, setup->sm_ra, iocap_b, bd_addr_slave, bd_addr_master);
 8023738:	4b11      	ldr	r3, [pc, #68]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 802373a:	681b      	ldr	r3, [r3, #0]
 802373c:	f103 00e6 	add.w	r0, r3, #230	; 0xe6
 8023740:	4b0f      	ldr	r3, [pc, #60]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 8023742:	681b      	ldr	r3, [r3, #0]
 8023744:	f103 01f6 	add.w	r1, r3, #246	; 0xf6
 8023748:	4b0d      	ldr	r3, [pc, #52]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 802374a:	681b      	ldr	r3, [r3, #0]
 802374c:	f503 72a3 	add.w	r2, r3, #326	; 0x146
 8023750:	f107 0408 	add.w	r4, r7, #8
 8023754:	f107 0318 	add.w	r3, r7, #24
 8023758:	9301      	str	r3, [sp, #4]
 802375a:	f107 0310 	add.w	r3, r7, #16
 802375e:	9300      	str	r3, [sp, #0]
 8023760:	4623      	mov	r3, r4
 8023762:	f7ff fcc7 	bl	80230f4 <f6_setup>
        f6_engine(sm_conn, setup->sm_mackey);
 8023766:	4b06      	ldr	r3, [pc, #24]	; (8023780 <sm_sc_calculate_f6_to_verify_dhkey_check+0x138>)
 8023768:	681b      	ldr	r3, [r3, #0]
 802376a:	f503 73bb 	add.w	r3, r3, #374	; 0x176
 802376e:	4619      	mov	r1, r3
 8023770:	6878      	ldr	r0, [r7, #4]
 8023772:	f7ff fcf9 	bl	8023168 <f6_engine>
}
 8023776:	bf00      	nop
 8023778:	3724      	adds	r7, #36	; 0x24
 802377a:	46bd      	mov	sp, r7
 802377c:	bd90      	pop	{r4, r7, pc}
 802377e:	bf00      	nop
 8023780:	200000a0 	.word	0x200000a0

08023784 <sm_load_security_info>:

// key management secure connections:
// - both devices store same LTK from ECDH key exchange.

#if defined(ENABLE_LE_SECURE_CONNECTIONS) || defined(ENABLE_LE_CENTRAL)
static void sm_load_security_info(sm_connection_t * sm_connection){
 8023784:	b590      	push	{r4, r7, lr}
 8023786:	b08d      	sub	sp, #52	; 0x34
 8023788:	af06      	add	r7, sp, #24
 802378a:	6078      	str	r0, [r7, #4]
    int authenticated;
    int authorized;
    int secure_connection;

    // fetch data from device db - incl. authenticated/authorized/key size. Note all sm_connection_X require encryption enabled
    le_device_db_encryption_get(sm_connection->sm_le_db_index, &setup->sm_peer_ediv, setup->sm_peer_rand, setup->sm_peer_ltk,
 802378c:	687b      	ldr	r3, [r7, #4]
 802378e:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8023790:	4b22      	ldr	r3, [pc, #136]	; (802381c <sm_load_security_info+0x98>)
 8023792:	681b      	ldr	r3, [r3, #0]
 8023794:	f503 71e5 	add.w	r1, r3, #458	; 0x1ca
 8023798:	4b20      	ldr	r3, [pc, #128]	; (802381c <sm_load_security_info+0x98>)
 802379a:	681b      	ldr	r3, [r3, #0]
 802379c:	f503 72e6 	add.w	r2, r3, #460	; 0x1cc
 80237a0:	4b1e      	ldr	r3, [pc, #120]	; (802381c <sm_load_security_info+0x98>)
 80237a2:	681b      	ldr	r3, [r3, #0]
 80237a4:	f503 74ea 	add.w	r4, r3, #468	; 0x1d4
 80237a8:	f107 0308 	add.w	r3, r7, #8
 80237ac:	9303      	str	r3, [sp, #12]
 80237ae:	f107 030c 	add.w	r3, r7, #12
 80237b2:	9302      	str	r3, [sp, #8]
 80237b4:	f107 0310 	add.w	r3, r7, #16
 80237b8:	9301      	str	r3, [sp, #4]
 80237ba:	f107 0314 	add.w	r3, r7, #20
 80237be:	9300      	str	r3, [sp, #0]
 80237c0:	4623      	mov	r3, r4
 80237c2:	f7fd fb19 	bl	8020df8 <le_device_db_encryption_get>
                                &encryption_key_size, &authenticated, &authorized, &secure_connection);
    log_info("db index %u, key size %u, authenticated %u, authorized %u, secure connetion %u", sm_connection->sm_le_db_index, encryption_key_size, authenticated, authorized, secure_connection);
 80237c6:	687b      	ldr	r3, [r7, #4]
 80237c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80237ca:	697a      	ldr	r2, [r7, #20]
 80237cc:	6939      	ldr	r1, [r7, #16]
 80237ce:	68f8      	ldr	r0, [r7, #12]
 80237d0:	68bc      	ldr	r4, [r7, #8]
 80237d2:	9404      	str	r4, [sp, #16]
 80237d4:	9003      	str	r0, [sp, #12]
 80237d6:	9102      	str	r1, [sp, #8]
 80237d8:	9201      	str	r2, [sp, #4]
 80237da:	9300      	str	r3, [sp, #0]
 80237dc:	f240 73d4 	movw	r3, #2004	; 0x7d4
 80237e0:	4a0f      	ldr	r2, [pc, #60]	; (8023820 <sm_load_security_info+0x9c>)
 80237e2:	4910      	ldr	r1, [pc, #64]	; (8023824 <sm_load_security_info+0xa0>)
 80237e4:	2001      	movs	r0, #1
 80237e6:	f7f3 fe2b 	bl	8017440 <hci_dump_log>
    sm_connection->sm_actual_encryption_key_size = encryption_key_size;
 80237ea:	697b      	ldr	r3, [r7, #20]
 80237ec:	b2da      	uxtb	r2, r3
 80237ee:	687b      	ldr	r3, [r7, #4]
 80237f0:	745a      	strb	r2, [r3, #17]
    sm_connection->sm_connection_authenticated = authenticated;
 80237f2:	693b      	ldr	r3, [r7, #16]
 80237f4:	b2da      	uxtb	r2, r3
 80237f6:	687b      	ldr	r3, [r7, #4]
 80237f8:	73da      	strb	r2, [r3, #15]
    sm_connection->sm_connection_authorization_state = authorized ? AUTHORIZATION_GRANTED : AUTHORIZATION_UNKNOWN;
 80237fa:	68fb      	ldr	r3, [r7, #12]
 80237fc:	2b00      	cmp	r3, #0
 80237fe:	d001      	beq.n	8023804 <sm_load_security_info+0x80>
 8023800:	2203      	movs	r2, #3
 8023802:	e000      	b.n	8023806 <sm_load_security_info+0x82>
 8023804:	2200      	movs	r2, #0
 8023806:	687b      	ldr	r3, [r7, #4]
 8023808:	765a      	strb	r2, [r3, #25]
    sm_connection->sm_connection_sc = secure_connection;
 802380a:	68bb      	ldr	r3, [r7, #8]
 802380c:	b2da      	uxtb	r2, r3
 802380e:	687b      	ldr	r3, [r7, #4]
 8023810:	741a      	strb	r2, [r3, #16]
}
 8023812:	bf00      	nop
 8023814:	371c      	adds	r7, #28
 8023816:	46bd      	mov	sp, r7
 8023818:	bd90      	pop	{r4, r7, pc}
 802381a:	bf00      	nop
 802381c:	200000a0 	.word	0x200000a0
 8023820:	0802d4a8 	.word	0x0802d4a8
 8023824:	0802dac4 	.word	0x0802dac4

08023828 <sm_start_calculating_ltk_from_ediv_and_rand>:
#endif

#ifdef ENABLE_LE_PERIPHERAL
static void sm_start_calculating_ltk_from_ediv_and_rand(sm_connection_t * sm_connection){
 8023828:	b580      	push	{r7, lr}
 802382a:	b084      	sub	sp, #16
 802382c:	af02      	add	r7, sp, #8
 802382e:	6078      	str	r0, [r7, #4]
    (void)memcpy(setup->sm_local_rand, sm_connection->sm_local_rand, 8);
 8023830:	4b1d      	ldr	r3, [pc, #116]	; (80238a8 <sm_start_calculating_ltk_from_ediv_and_rand+0x80>)
 8023832:	681b      	ldr	r3, [r3, #0]
 8023834:	f503 70c7 	add.w	r0, r3, #398	; 0x18e
 8023838:	687b      	ldr	r3, [r7, #4]
 802383a:	331c      	adds	r3, #28
 802383c:	2208      	movs	r2, #8
 802383e:	4619      	mov	r1, r3
 8023840:	f004 f91b 	bl	8027a7a <memcpy>
    setup->sm_local_ediv = sm_connection->sm_local_ediv;
 8023844:	4b18      	ldr	r3, [pc, #96]	; (80238a8 <sm_start_calculating_ltk_from_ediv_and_rand+0x80>)
 8023846:	681b      	ldr	r3, [r3, #0]
 8023848:	687a      	ldr	r2, [r7, #4]
 802384a:	8b52      	ldrh	r2, [r2, #26]
 802384c:	f8a3 218c 	strh.w	r2, [r3, #396]	; 0x18c
    // re-establish used key encryption size
    // no db for encryption size hack: encryption size is stored in lowest nibble of setup->sm_local_rand
    sm_connection->sm_actual_encryption_key_size = (setup->sm_local_rand[7u] & 0x0fu) + 1u;
 8023850:	4b15      	ldr	r3, [pc, #84]	; (80238a8 <sm_start_calculating_ltk_from_ediv_and_rand+0x80>)
 8023852:	681b      	ldr	r3, [r3, #0]
 8023854:	f893 3195 	ldrb.w	r3, [r3, #405]	; 0x195
 8023858:	f003 030f 	and.w	r3, r3, #15
 802385c:	b2db      	uxtb	r3, r3
 802385e:	3301      	adds	r3, #1
 8023860:	b2da      	uxtb	r2, r3
 8023862:	687b      	ldr	r3, [r7, #4]
 8023864:	745a      	strb	r2, [r3, #17]
    // no db for authenticated flag hack: flag is stored in bit 4 of LSB
    sm_connection->sm_connection_authenticated = (setup->sm_local_rand[7u] & 0x10u) >> 4u;
 8023866:	4b10      	ldr	r3, [pc, #64]	; (80238a8 <sm_start_calculating_ltk_from_ediv_and_rand+0x80>)
 8023868:	681b      	ldr	r3, [r3, #0]
 802386a:	f893 3195 	ldrb.w	r3, [r3, #405]	; 0x195
 802386e:	091b      	lsrs	r3, r3, #4
 8023870:	b2db      	uxtb	r3, r3
 8023872:	f003 0301 	and.w	r3, r3, #1
 8023876:	b2da      	uxtb	r2, r3
 8023878:	687b      	ldr	r3, [r7, #4]
 802387a:	73da      	strb	r2, [r3, #15]
    // Legacy paring -> not SC
    sm_connection->sm_connection_sc = 0;
 802387c:	687b      	ldr	r3, [r7, #4]
 802387e:	2200      	movs	r2, #0
 8023880:	741a      	strb	r2, [r3, #16]
    log_info("sm: received ltk request with key size %u, authenticated %u",
 8023882:	687b      	ldr	r3, [r7, #4]
 8023884:	7c5b      	ldrb	r3, [r3, #17]
 8023886:	461a      	mov	r2, r3
 8023888:	687b      	ldr	r3, [r7, #4]
 802388a:	7bdb      	ldrb	r3, [r3, #15]
 802388c:	9301      	str	r3, [sp, #4]
 802388e:	9200      	str	r2, [sp, #0]
 8023890:	f44f 63fd 	mov.w	r3, #2024	; 0x7e8
 8023894:	4a05      	ldr	r2, [pc, #20]	; (80238ac <sm_start_calculating_ltk_from_ediv_and_rand+0x84>)
 8023896:	4906      	ldr	r1, [pc, #24]	; (80238b0 <sm_start_calculating_ltk_from_ediv_and_rand+0x88>)
 8023898:	2001      	movs	r0, #1
 802389a:	f7f3 fdd1 	bl	8017440 <hci_dump_log>
            sm_connection->sm_actual_encryption_key_size, sm_connection->sm_connection_authenticated);
}
 802389e:	bf00      	nop
 80238a0:	3708      	adds	r7, #8
 80238a2:	46bd      	mov	sp, r7
 80238a4:	bd80      	pop	{r7, pc}
 80238a6:	bf00      	nop
 80238a8:	200000a0 	.word	0x200000a0
 80238ac:	0802d4a8 	.word	0x0802d4a8
 80238b0:	0802db1c 	.word	0x0802db1c

080238b4 <sm_run_dpkg>:
#endif

// distributed key generation
static bool sm_run_dpkg(void){
 80238b4:	b580      	push	{r7, lr}
 80238b6:	b082      	sub	sp, #8
 80238b8:	af02      	add	r7, sp, #8
    switch (dkg_state){
 80238ba:	4b26      	ldr	r3, [pc, #152]	; (8023954 <sm_run_dpkg+0xa0>)
 80238bc:	781b      	ldrb	r3, [r3, #0]
 80238be:	2b01      	cmp	r3, #1
 80238c0:	d002      	beq.n	80238c8 <sm_run_dpkg+0x14>
 80238c2:	2b02      	cmp	r3, #2
 80238c4:	d01f      	beq.n	8023906 <sm_run_dpkg+0x52>
                btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, sm_persistent_ir, sm_aes128_plaintext, sm_persistent_dhk, sm_handle_encryption_result_dkg_dhk, NULL);
                return true;
            }
            break;
        default:
            break;
 80238c6:	e040      	b.n	802394a <sm_run_dpkg+0x96>
            if (sm_aes128_state == SM_AES128_IDLE) {
 80238c8:	4b23      	ldr	r3, [pc, #140]	; (8023958 <sm_run_dpkg+0xa4>)
 80238ca:	781b      	ldrb	r3, [r3, #0]
 80238cc:	2b00      	cmp	r3, #0
 80238ce:	d139      	bne.n	8023944 <sm_run_dpkg+0x90>
                log_info("DKG_CALC_IRK started");
 80238d0:	f240 73f2 	movw	r3, #2034	; 0x7f2
 80238d4:	4a21      	ldr	r2, [pc, #132]	; (802395c <sm_run_dpkg+0xa8>)
 80238d6:	4922      	ldr	r1, [pc, #136]	; (8023960 <sm_run_dpkg+0xac>)
 80238d8:	2001      	movs	r0, #1
 80238da:	f7f3 fdb1 	bl	8017440 <hci_dump_log>
                sm_d1_d_prime(1, 0, sm_aes128_plaintext);  // plaintext = d1 prime
 80238de:	4a21      	ldr	r2, [pc, #132]	; (8023964 <sm_run_dpkg+0xb0>)
 80238e0:	2100      	movs	r1, #0
 80238e2:	2001      	movs	r0, #1
 80238e4:	f7fd ffe1 	bl	80218aa <sm_d1_d_prime>
                sm_aes128_state = SM_AES128_ACTIVE;
 80238e8:	4b1b      	ldr	r3, [pc, #108]	; (8023958 <sm_run_dpkg+0xa4>)
 80238ea:	2201      	movs	r2, #1
 80238ec:	701a      	strb	r2, [r3, #0]
                btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, sm_persistent_ir, sm_aes128_plaintext, sm_persistent_irk, sm_handle_encryption_result_dkg_irk, NULL);
 80238ee:	2300      	movs	r3, #0
 80238f0:	9301      	str	r3, [sp, #4]
 80238f2:	4b1d      	ldr	r3, [pc, #116]	; (8023968 <sm_run_dpkg+0xb4>)
 80238f4:	9300      	str	r3, [sp, #0]
 80238f6:	4b1d      	ldr	r3, [pc, #116]	; (802396c <sm_run_dpkg+0xb8>)
 80238f8:	4a1a      	ldr	r2, [pc, #104]	; (8023964 <sm_run_dpkg+0xb0>)
 80238fa:	491d      	ldr	r1, [pc, #116]	; (8023970 <sm_run_dpkg+0xbc>)
 80238fc:	481d      	ldr	r0, [pc, #116]	; (8023974 <sm_run_dpkg+0xc0>)
 80238fe:	f7ea fdc1 	bl	800e484 <btstack_crypto_aes128_encrypt>
                return true;
 8023902:	2301      	movs	r3, #1
 8023904:	e022      	b.n	802394c <sm_run_dpkg+0x98>
            if (sm_aes128_state == SM_AES128_IDLE) {
 8023906:	4b14      	ldr	r3, [pc, #80]	; (8023958 <sm_run_dpkg+0xa4>)
 8023908:	781b      	ldrb	r3, [r3, #0]
 802390a:	2b00      	cmp	r3, #0
 802390c:	d11c      	bne.n	8023948 <sm_run_dpkg+0x94>
                log_info("DKG_CALC_DHK started");
 802390e:	f240 73fd 	movw	r3, #2045	; 0x7fd
 8023912:	4a12      	ldr	r2, [pc, #72]	; (802395c <sm_run_dpkg+0xa8>)
 8023914:	4918      	ldr	r1, [pc, #96]	; (8023978 <sm_run_dpkg+0xc4>)
 8023916:	2001      	movs	r0, #1
 8023918:	f7f3 fd92 	bl	8017440 <hci_dump_log>
                sm_d1_d_prime(3, 0, sm_aes128_plaintext);  // plaintext = d1 prime
 802391c:	4a11      	ldr	r2, [pc, #68]	; (8023964 <sm_run_dpkg+0xb0>)
 802391e:	2100      	movs	r1, #0
 8023920:	2003      	movs	r0, #3
 8023922:	f7fd ffc2 	bl	80218aa <sm_d1_d_prime>
                sm_aes128_state = SM_AES128_ACTIVE;
 8023926:	4b0c      	ldr	r3, [pc, #48]	; (8023958 <sm_run_dpkg+0xa4>)
 8023928:	2201      	movs	r2, #1
 802392a:	701a      	strb	r2, [r3, #0]
                btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, sm_persistent_ir, sm_aes128_plaintext, sm_persistent_dhk, sm_handle_encryption_result_dkg_dhk, NULL);
 802392c:	2300      	movs	r3, #0
 802392e:	9301      	str	r3, [sp, #4]
 8023930:	4b12      	ldr	r3, [pc, #72]	; (802397c <sm_run_dpkg+0xc8>)
 8023932:	9300      	str	r3, [sp, #0]
 8023934:	4b12      	ldr	r3, [pc, #72]	; (8023980 <sm_run_dpkg+0xcc>)
 8023936:	4a0b      	ldr	r2, [pc, #44]	; (8023964 <sm_run_dpkg+0xb0>)
 8023938:	490d      	ldr	r1, [pc, #52]	; (8023970 <sm_run_dpkg+0xbc>)
 802393a:	480e      	ldr	r0, [pc, #56]	; (8023974 <sm_run_dpkg+0xc0>)
 802393c:	f7ea fda2 	bl	800e484 <btstack_crypto_aes128_encrypt>
                return true;
 8023940:	2301      	movs	r3, #1
 8023942:	e003      	b.n	802394c <sm_run_dpkg+0x98>
            break;
 8023944:	bf00      	nop
 8023946:	e000      	b.n	802394a <sm_run_dpkg+0x96>
            break;
 8023948:	bf00      	nop
    }
    return false;
 802394a:	2300      	movs	r3, #0
}
 802394c:	4618      	mov	r0, r3
 802394e:	46bd      	mov	sp, r7
 8023950:	bd80      	pop	{r7, pc}
 8023952:	bf00      	nop
 8023954:	20009fb0 	.word	0x20009fb0
 8023958:	2000a068 	.word	0x2000a068
 802395c:	0802d4a8 	.word	0x0802d4a8
 8023960:	0802db60 	.word	0x0802db60
 8023964:	2000a0d0 	.word	0x2000a0d0
 8023968:	08025845 	.word	0x08025845
 802396c:	20009fa0 	.word	0x20009fa0
 8023970:	20009f80 	.word	0x20009f80
 8023974:	2000a084 	.word	0x2000a084
 8023978:	0802db7c 	.word	0x0802db7c
 802397c:	0802587d 	.word	0x0802587d
 8023980:	20009f90 	.word	0x20009f90

08023984 <sm_run_rau>:

// random address updates
static bool sm_run_rau(void){
 8023984:	b580      	push	{r7, lr}
 8023986:	b082      	sub	sp, #8
 8023988:	af02      	add	r7, sp, #8
    switch (rau_state){
 802398a:	4b23      	ldr	r3, [pc, #140]	; (8023a18 <sm_run_rau+0x94>)
 802398c:	781b      	ldrb	r3, [r3, #0]
 802398e:	2b03      	cmp	r3, #3
 8023990:	d011      	beq.n	80239b6 <sm_run_rau+0x32>
 8023992:	2b05      	cmp	r3, #5
 8023994:	d026      	beq.n	80239e4 <sm_run_rau+0x60>
 8023996:	2b01      	cmp	r3, #1
 8023998:	d000      	beq.n	802399c <sm_run_rau+0x18>
            log_info("New random address: %s", bd_addr_to_str(sm_random_address));
            rau_state = RAU_IDLE;
            hci_send_cmd(&hci_le_set_random_address, sm_random_address);
            return true;
        default:
            break;
 802399a:	e039      	b.n	8023a10 <sm_run_rau+0x8c>
            rau_state = RAU_W4_RANDOM;
 802399c:	4b1e      	ldr	r3, [pc, #120]	; (8023a18 <sm_run_rau+0x94>)
 802399e:	2202      	movs	r2, #2
 80239a0:	701a      	strb	r2, [r3, #0]
            btstack_crypto_random_generate(&sm_crypto_random_request, sm_random_address, 6, &sm_handle_random_result_rau, NULL);
 80239a2:	2300      	movs	r3, #0
 80239a4:	9300      	str	r3, [sp, #0]
 80239a6:	4b1d      	ldr	r3, [pc, #116]	; (8023a1c <sm_run_rau+0x98>)
 80239a8:	2206      	movs	r2, #6
 80239aa:	491d      	ldr	r1, [pc, #116]	; (8023a20 <sm_run_rau+0x9c>)
 80239ac:	481d      	ldr	r0, [pc, #116]	; (8023a24 <sm_run_rau+0xa0>)
 80239ae:	f7ea fd45 	bl	800e43c <btstack_crypto_random_generate>
            return true;
 80239b2:	2301      	movs	r3, #1
 80239b4:	e02d      	b.n	8023a12 <sm_run_rau+0x8e>
            if (sm_aes128_state == SM_AES128_IDLE) {
 80239b6:	4b1c      	ldr	r3, [pc, #112]	; (8023a28 <sm_run_rau+0xa4>)
 80239b8:	781b      	ldrb	r3, [r3, #0]
 80239ba:	2b00      	cmp	r3, #0
 80239bc:	d127      	bne.n	8023a0e <sm_run_rau+0x8a>
                sm_ah_r_prime(sm_random_address, sm_aes128_plaintext);
 80239be:	491b      	ldr	r1, [pc, #108]	; (8023a2c <sm_run_rau+0xa8>)
 80239c0:	4817      	ldr	r0, [pc, #92]	; (8023a20 <sm_run_rau+0x9c>)
 80239c2:	f7fd ff5d 	bl	8021880 <sm_ah_r_prime>
                sm_aes128_state = SM_AES128_ACTIVE;
 80239c6:	4b18      	ldr	r3, [pc, #96]	; (8023a28 <sm_run_rau+0xa4>)
 80239c8:	2201      	movs	r2, #1
 80239ca:	701a      	strb	r2, [r3, #0]
                btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, sm_persistent_irk, sm_aes128_plaintext, sm_aes128_ciphertext, sm_handle_encryption_result_rau, NULL);
 80239cc:	2300      	movs	r3, #0
 80239ce:	9301      	str	r3, [sp, #4]
 80239d0:	4b17      	ldr	r3, [pc, #92]	; (8023a30 <sm_run_rau+0xac>)
 80239d2:	9300      	str	r3, [sp, #0]
 80239d4:	4b17      	ldr	r3, [pc, #92]	; (8023a34 <sm_run_rau+0xb0>)
 80239d6:	4a15      	ldr	r2, [pc, #84]	; (8023a2c <sm_run_rau+0xa8>)
 80239d8:	4917      	ldr	r1, [pc, #92]	; (8023a38 <sm_run_rau+0xb4>)
 80239da:	4818      	ldr	r0, [pc, #96]	; (8023a3c <sm_run_rau+0xb8>)
 80239dc:	f7ea fd52 	bl	800e484 <btstack_crypto_aes128_encrypt>
                return true;
 80239e0:	2301      	movs	r3, #1
 80239e2:	e016      	b.n	8023a12 <sm_run_rau+0x8e>
            log_info("New random address: %s", bd_addr_to_str(sm_random_address));
 80239e4:	480e      	ldr	r0, [pc, #56]	; (8023a20 <sm_run_rau+0x9c>)
 80239e6:	f7eb fd13 	bl	800f410 <bd_addr_to_str>
 80239ea:	4603      	mov	r3, r0
 80239ec:	9300      	str	r3, [sp, #0]
 80239ee:	f640 031c 	movw	r3, #2076	; 0x81c
 80239f2:	4a13      	ldr	r2, [pc, #76]	; (8023a40 <sm_run_rau+0xbc>)
 80239f4:	4913      	ldr	r1, [pc, #76]	; (8023a44 <sm_run_rau+0xc0>)
 80239f6:	2001      	movs	r0, #1
 80239f8:	f7f3 fd22 	bl	8017440 <hci_dump_log>
            rau_state = RAU_IDLE;
 80239fc:	4b06      	ldr	r3, [pc, #24]	; (8023a18 <sm_run_rau+0x94>)
 80239fe:	2200      	movs	r2, #0
 8023a00:	701a      	strb	r2, [r3, #0]
            hci_send_cmd(&hci_le_set_random_address, sm_random_address);
 8023a02:	4907      	ldr	r1, [pc, #28]	; (8023a20 <sm_run_rau+0x9c>)
 8023a04:	4810      	ldr	r0, [pc, #64]	; (8023a48 <sm_run_rau+0xc4>)
 8023a06:	f7f2 faeb 	bl	8015fe0 <hci_send_cmd>
            return true;
 8023a0a:	2301      	movs	r3, #1
 8023a0c:	e001      	b.n	8023a12 <sm_run_rau+0x8e>
            break;
 8023a0e:	bf00      	nop
    }
    return false;
 8023a10:	2300      	movs	r3, #0
}
 8023a12:	4618      	mov	r0, r3
 8023a14:	46bd      	mov	sp, r7
 8023a16:	bd80      	pop	{r7, pc}
 8023a18:	20009fb1 	.word	0x20009fb1
 8023a1c:	080258f1 	.word	0x080258f1
 8023a20:	20009fb4 	.word	0x20009fb4
 8023a24:	2000a06c 	.word	0x2000a06c
 8023a28:	2000a068 	.word	0x2000a068
 8023a2c:	2000a0d0 	.word	0x2000a0d0
 8023a30:	080258b5 	.word	0x080258b5
 8023a34:	2000a0e0 	.word	0x2000a0e0
 8023a38:	20009fa0 	.word	0x20009fa0
 8023a3c:	2000a084 	.word	0x2000a084
 8023a40:	0802d4a8 	.word	0x0802d4a8
 8023a44:	0802db98 	.word	0x0802db98
 8023a48:	08030b88 	.word	0x08030b88

08023a4c <sm_run_csrk>:

// CSRK Lookup
static bool sm_run_csrk(void){
 8023a4c:	b590      	push	{r4, r7, lr}
 8023a4e:	b091      	sub	sp, #68	; 0x44
 8023a50:	af02      	add	r7, sp, #8
    btstack_linked_list_iterator_t it;

    // -- if csrk lookup ready, find connection that require csrk lookup
    if (sm_address_resolution_idle()){
 8023a52:	f7fe f951 	bl	8021cf8 <sm_address_resolution_idle>
 8023a56:	4603      	mov	r3, r0
 8023a58:	2b00      	cmp	r3, #0
 8023a5a:	d02a      	beq.n	8023ab2 <sm_run_csrk+0x66>
        hci_connections_get_iterator(&it);
 8023a5c:	f107 0320 	add.w	r3, r7, #32
 8023a60:	4618      	mov	r0, r3
 8023a62:	f7eb ff1d 	bl	800f8a0 <hci_connections_get_iterator>
        while(btstack_linked_list_iterator_has_next(&it)){
 8023a66:	e01c      	b.n	8023aa2 <sm_run_csrk+0x56>
            hci_connection_t * hci_connection = (hci_connection_t *) btstack_linked_list_iterator_next(&it);
 8023a68:	f107 0320 	add.w	r3, r7, #32
 8023a6c:	4618      	mov	r0, r3
 8023a6e:	f7ea feb1 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8023a72:	6378      	str	r0, [r7, #52]	; 0x34
            sm_connection_t  * sm_connection  = &hci_connection->sm_connection;
 8023a74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8023a76:	f203 731c 	addw	r3, r3, #1820	; 0x71c
 8023a7a:	633b      	str	r3, [r7, #48]	; 0x30
            if (sm_connection->sm_irk_lookup_state == IRK_LOOKUP_W4_READY){
 8023a7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023a7e:	7b5b      	ldrb	r3, [r3, #13]
 8023a80:	2b01      	cmp	r3, #1
 8023a82:	d10e      	bne.n	8023aa2 <sm_run_csrk+0x56>
                // and start lookup
                sm_address_resolution_start_lookup(sm_connection->sm_peer_addr_type, sm_connection->sm_handle, sm_connection->sm_peer_address, ADDRESS_RESOLUTION_FOR_CONNECTION, sm_connection);
 8023a84:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023a86:	7958      	ldrb	r0, [r3, #5]
 8023a88:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023a8a:	8819      	ldrh	r1, [r3, #0]
 8023a8c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023a8e:	1d9a      	adds	r2, r3, #6
 8023a90:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023a92:	9300      	str	r3, [sp, #0]
 8023a94:	2302      	movs	r3, #2
 8023a96:	f7fe f93f 	bl	8021d18 <sm_address_resolution_start_lookup>
                sm_connection->sm_irk_lookup_state = IRK_LOOKUP_STARTED;
 8023a9a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023a9c:	2202      	movs	r2, #2
 8023a9e:	735a      	strb	r2, [r3, #13]
                break;
 8023aa0:	e007      	b.n	8023ab2 <sm_run_csrk+0x66>
        while(btstack_linked_list_iterator_has_next(&it)){
 8023aa2:	f107 0320 	add.w	r3, r7, #32
 8023aa6:	4618      	mov	r0, r3
 8023aa8:	f7ea fe66 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8023aac:	4603      	mov	r3, r0
 8023aae:	2b00      	cmp	r3, #0
 8023ab0:	d1da      	bne.n	8023a68 <sm_run_csrk+0x1c>
            }
        }
    }

    // -- if csrk lookup ready, resolved addresses for received addresses
    if (sm_address_resolution_idle()) {
 8023ab2:	f7fe f921 	bl	8021cf8 <sm_address_resolution_idle>
 8023ab6:	4603      	mov	r3, r0
 8023ab8:	2b00      	cmp	r3, #0
 8023aba:	d01c      	beq.n	8023af6 <sm_run_csrk+0xaa>
        if (!btstack_linked_list_empty(&sm_address_resolution_general_queue)){
 8023abc:	4862      	ldr	r0, [pc, #392]	; (8023c48 <sm_run_csrk+0x1fc>)
 8023abe:	f7ea fda7 	bl	800e610 <btstack_linked_list_empty>
 8023ac2:	4603      	mov	r3, r0
 8023ac4:	f083 0301 	eor.w	r3, r3, #1
 8023ac8:	b2db      	uxtb	r3, r3
 8023aca:	2b00      	cmp	r3, #0
 8023acc:	d013      	beq.n	8023af6 <sm_run_csrk+0xaa>
            sm_lookup_entry_t * entry = (sm_lookup_entry_t *) sm_address_resolution_general_queue;
 8023ace:	4b5e      	ldr	r3, [pc, #376]	; (8023c48 <sm_run_csrk+0x1fc>)
 8023ad0:	681b      	ldr	r3, [r3, #0]
 8023ad2:	62fb      	str	r3, [r7, #44]	; 0x2c
            btstack_linked_list_remove(&sm_address_resolution_general_queue, (btstack_linked_item_t *) entry);
 8023ad4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8023ad6:	485c      	ldr	r0, [pc, #368]	; (8023c48 <sm_run_csrk+0x1fc>)
 8023ad8:	f7ea fdf1 	bl	800e6be <btstack_linked_list_remove>
            sm_address_resolution_start_lookup(entry->address_type, 0, entry->address, ADDRESS_RESOLUTION_GENERAL, NULL);
 8023adc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023ade:	7a98      	ldrb	r0, [r3, #10]
 8023ae0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023ae2:	1d1a      	adds	r2, r3, #4
 8023ae4:	2300      	movs	r3, #0
 8023ae6:	9300      	str	r3, [sp, #0]
 8023ae8:	2301      	movs	r3, #1
 8023aea:	2100      	movs	r1, #0
 8023aec:	f7fe f914 	bl	8021d18 <sm_address_resolution_start_lookup>
            btstack_memory_sm_lookup_entry_free(entry);
 8023af0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8023af2:	f7ea ff09 	bl	800e908 <btstack_memory_sm_lookup_entry_free>
        }
    }

    // -- Continue with CSRK device lookup by public or resolvable private address
    if (!sm_address_resolution_idle()){
 8023af6:	f7fe f8ff 	bl	8021cf8 <sm_address_resolution_idle>
 8023afa:	4603      	mov	r3, r0
 8023afc:	2b00      	cmp	r3, #0
 8023afe:	f040 809e 	bne.w	8023c3e <sm_run_csrk+0x1f2>
        log_info("LE Device Lookup: device %u/%u", sm_address_resolution_test, le_device_db_max_count());
 8023b02:	4b52      	ldr	r3, [pc, #328]	; (8023c4c <sm_run_csrk+0x200>)
 8023b04:	681c      	ldr	r4, [r3, #0]
 8023b06:	f7fc ffb3 	bl	8020a70 <le_device_db_max_count>
 8023b0a:	4603      	mov	r3, r0
 8023b0c:	9301      	str	r3, [sp, #4]
 8023b0e:	9400      	str	r4, [sp, #0]
 8023b10:	f640 0345 	movw	r3, #2117	; 0x845
 8023b14:	4a4e      	ldr	r2, [pc, #312]	; (8023c50 <sm_run_csrk+0x204>)
 8023b16:	494f      	ldr	r1, [pc, #316]	; (8023c54 <sm_run_csrk+0x208>)
 8023b18:	2001      	movs	r0, #1
 8023b1a:	f7f3 fc91 	bl	8017440 <hci_dump_log>
        while (sm_address_resolution_test < le_device_db_max_count()){
 8023b1e:	e074      	b.n	8023c0a <sm_run_csrk+0x1be>
            int addr_type = BD_ADDR_TYPE_UNKNOWN;
 8023b20:	23fe      	movs	r3, #254	; 0xfe
 8023b22:	61fb      	str	r3, [r7, #28]
            bd_addr_t addr;
            sm_key_t irk;
            le_device_db_info(sm_address_resolution_test, &addr_type, addr, irk);
 8023b24:	4b49      	ldr	r3, [pc, #292]	; (8023c4c <sm_run_csrk+0x200>)
 8023b26:	6818      	ldr	r0, [r3, #0]
 8023b28:	1d3b      	adds	r3, r7, #4
 8023b2a:	f107 0214 	add.w	r2, r7, #20
 8023b2e:	f107 011c 	add.w	r1, r7, #28
 8023b32:	f7fd f8b5 	bl	8020ca0 <le_device_db_info>
            log_info("device type %u, addr: %s", addr_type, bd_addr_to_str(addr));
 8023b36:	69fc      	ldr	r4, [r7, #28]
 8023b38:	f107 0314 	add.w	r3, r7, #20
 8023b3c:	4618      	mov	r0, r3
 8023b3e:	f7eb fc67 	bl	800f410 <bd_addr_to_str>
 8023b42:	4603      	mov	r3, r0
 8023b44:	9301      	str	r3, [sp, #4]
 8023b46:	9400      	str	r4, [sp, #0]
 8023b48:	f640 034b 	movw	r3, #2123	; 0x84b
 8023b4c:	4a40      	ldr	r2, [pc, #256]	; (8023c50 <sm_run_csrk+0x204>)
 8023b4e:	4942      	ldr	r1, [pc, #264]	; (8023c58 <sm_run_csrk+0x20c>)
 8023b50:	2001      	movs	r0, #1
 8023b52:	f7f3 fc75 	bl	8017440 <hci_dump_log>

            // skip unused entries
            if (addr_type == BD_ADDR_TYPE_UNKNOWN){
 8023b56:	69fb      	ldr	r3, [r7, #28]
 8023b58:	2bfe      	cmp	r3, #254	; 0xfe
 8023b5a:	d105      	bne.n	8023b68 <sm_run_csrk+0x11c>
                sm_address_resolution_test++;
 8023b5c:	4b3b      	ldr	r3, [pc, #236]	; (8023c4c <sm_run_csrk+0x200>)
 8023b5e:	681b      	ldr	r3, [r3, #0]
 8023b60:	3301      	adds	r3, #1
 8023b62:	4a3a      	ldr	r2, [pc, #232]	; (8023c4c <sm_run_csrk+0x200>)
 8023b64:	6013      	str	r3, [r2, #0]
                continue;
 8023b66:	e050      	b.n	8023c0a <sm_run_csrk+0x1be>
            }

            if ((sm_address_resolution_addr_type == addr_type) && (memcmp(addr, sm_address_resolution_address, 6) == 0)){
 8023b68:	4b3c      	ldr	r3, [pc, #240]	; (8023c5c <sm_run_csrk+0x210>)
 8023b6a:	781b      	ldrb	r3, [r3, #0]
 8023b6c:	461a      	mov	r2, r3
 8023b6e:	69fb      	ldr	r3, [r7, #28]
 8023b70:	429a      	cmp	r2, r3
 8023b72:	d114      	bne.n	8023b9e <sm_run_csrk+0x152>
 8023b74:	f107 0314 	add.w	r3, r7, #20
 8023b78:	2206      	movs	r2, #6
 8023b7a:	4939      	ldr	r1, [pc, #228]	; (8023c60 <sm_run_csrk+0x214>)
 8023b7c:	4618      	mov	r0, r3
 8023b7e:	f003 ff6d 	bl	8027a5c <memcmp>
 8023b82:	4603      	mov	r3, r0
 8023b84:	2b00      	cmp	r3, #0
 8023b86:	d10a      	bne.n	8023b9e <sm_run_csrk+0x152>
                log_info("LE Device Lookup: found CSRK by { addr_type, address} ");
 8023b88:	f640 0354 	movw	r3, #2132	; 0x854
 8023b8c:	4a30      	ldr	r2, [pc, #192]	; (8023c50 <sm_run_csrk+0x204>)
 8023b8e:	4935      	ldr	r1, [pc, #212]	; (8023c64 <sm_run_csrk+0x218>)
 8023b90:	2001      	movs	r0, #1
 8023b92:	f7f3 fc55 	bl	8017440 <hci_dump_log>
                sm_address_resolution_handle_event(ADDRESS_RESOLUTION_SUCCEEDED);
 8023b96:	2000      	movs	r0, #0
 8023b98:	f7fe fc26 	bl	80223e8 <sm_address_resolution_handle_event>
                break;
 8023b9c:	e03e      	b.n	8023c1c <sm_run_csrk+0x1d0>
            }

            // if connection type is public, it must be a different one
            if (sm_address_resolution_addr_type == BD_ADDR_TYPE_LE_PUBLIC){
 8023b9e:	4b2f      	ldr	r3, [pc, #188]	; (8023c5c <sm_run_csrk+0x210>)
 8023ba0:	781b      	ldrb	r3, [r3, #0]
 8023ba2:	2b00      	cmp	r3, #0
 8023ba4:	d105      	bne.n	8023bb2 <sm_run_csrk+0x166>
                sm_address_resolution_test++;
 8023ba6:	4b29      	ldr	r3, [pc, #164]	; (8023c4c <sm_run_csrk+0x200>)
 8023ba8:	681b      	ldr	r3, [r3, #0]
 8023baa:	3301      	adds	r3, #1
 8023bac:	4a27      	ldr	r2, [pc, #156]	; (8023c4c <sm_run_csrk+0x200>)
 8023bae:	6013      	str	r3, [r2, #0]
                continue;
 8023bb0:	e02b      	b.n	8023c0a <sm_run_csrk+0x1be>
            }

            if (sm_aes128_state == SM_AES128_ACTIVE) break;
 8023bb2:	4b2d      	ldr	r3, [pc, #180]	; (8023c68 <sm_run_csrk+0x21c>)
 8023bb4:	781b      	ldrb	r3, [r3, #0]
 8023bb6:	2b01      	cmp	r3, #1
 8023bb8:	d02f      	beq.n	8023c1a <sm_run_csrk+0x1ce>

            log_info("LE Device Lookup: calculate AH");
 8023bba:	f640 0361 	movw	r3, #2145	; 0x861
 8023bbe:	4a24      	ldr	r2, [pc, #144]	; (8023c50 <sm_run_csrk+0x204>)
 8023bc0:	492a      	ldr	r1, [pc, #168]	; (8023c6c <sm_run_csrk+0x220>)
 8023bc2:	2001      	movs	r0, #1
 8023bc4:	f7f3 fc3c 	bl	8017440 <hci_dump_log>
            log_info_key("IRK", irk);
 8023bc8:	1d3b      	adds	r3, r7, #4
 8023bca:	4619      	mov	r1, r3
 8023bcc:	4828      	ldr	r0, [pc, #160]	; (8023c70 <sm_run_csrk+0x224>)
 8023bce:	f7eb fbd1 	bl	800f374 <log_info_key>

            (void)memcpy(sm_aes128_key, irk, 16);
 8023bd2:	4b28      	ldr	r3, [pc, #160]	; (8023c74 <sm_run_csrk+0x228>)
 8023bd4:	461c      	mov	r4, r3
 8023bd6:	1d3b      	adds	r3, r7, #4
 8023bd8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8023bda:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
            sm_ah_r_prime(sm_address_resolution_address, sm_aes128_plaintext);
 8023bde:	4926      	ldr	r1, [pc, #152]	; (8023c78 <sm_run_csrk+0x22c>)
 8023be0:	481f      	ldr	r0, [pc, #124]	; (8023c60 <sm_run_csrk+0x214>)
 8023be2:	f7fd fe4d 	bl	8021880 <sm_ah_r_prime>
            sm_address_resolution_ah_calculation_active = 1;
 8023be6:	4b25      	ldr	r3, [pc, #148]	; (8023c7c <sm_run_csrk+0x230>)
 8023be8:	2201      	movs	r2, #1
 8023bea:	601a      	str	r2, [r3, #0]
            sm_aes128_state = SM_AES128_ACTIVE;
 8023bec:	4b1e      	ldr	r3, [pc, #120]	; (8023c68 <sm_run_csrk+0x21c>)
 8023bee:	2201      	movs	r2, #1
 8023bf0:	701a      	strb	r2, [r3, #0]
            btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, sm_aes128_key, sm_aes128_plaintext, sm_aes128_ciphertext, sm_handle_encryption_result_address_resolution, NULL);
 8023bf2:	2300      	movs	r3, #0
 8023bf4:	9301      	str	r3, [sp, #4]
 8023bf6:	4b22      	ldr	r3, [pc, #136]	; (8023c80 <sm_run_csrk+0x234>)
 8023bf8:	9300      	str	r3, [sp, #0]
 8023bfa:	4b22      	ldr	r3, [pc, #136]	; (8023c84 <sm_run_csrk+0x238>)
 8023bfc:	4a1e      	ldr	r2, [pc, #120]	; (8023c78 <sm_run_csrk+0x22c>)
 8023bfe:	491d      	ldr	r1, [pc, #116]	; (8023c74 <sm_run_csrk+0x228>)
 8023c00:	4821      	ldr	r0, [pc, #132]	; (8023c88 <sm_run_csrk+0x23c>)
 8023c02:	f7ea fc3f 	bl	800e484 <btstack_crypto_aes128_encrypt>
            return true;
 8023c06:	2301      	movs	r3, #1
 8023c08:	e01a      	b.n	8023c40 <sm_run_csrk+0x1f4>
        while (sm_address_resolution_test < le_device_db_max_count()){
 8023c0a:	f7fc ff31 	bl	8020a70 <le_device_db_max_count>
 8023c0e:	4602      	mov	r2, r0
 8023c10:	4b0e      	ldr	r3, [pc, #56]	; (8023c4c <sm_run_csrk+0x200>)
 8023c12:	681b      	ldr	r3, [r3, #0]
 8023c14:	429a      	cmp	r2, r3
 8023c16:	dc83      	bgt.n	8023b20 <sm_run_csrk+0xd4>
 8023c18:	e000      	b.n	8023c1c <sm_run_csrk+0x1d0>
            if (sm_aes128_state == SM_AES128_ACTIVE) break;
 8023c1a:	bf00      	nop
        }

        if (sm_address_resolution_test >= le_device_db_max_count()){
 8023c1c:	f7fc ff28 	bl	8020a70 <le_device_db_max_count>
 8023c20:	4602      	mov	r2, r0
 8023c22:	4b0a      	ldr	r3, [pc, #40]	; (8023c4c <sm_run_csrk+0x200>)
 8023c24:	681b      	ldr	r3, [r3, #0]
 8023c26:	429a      	cmp	r2, r3
 8023c28:	dc09      	bgt.n	8023c3e <sm_run_csrk+0x1f2>
            log_info("LE Device Lookup: not found");
 8023c2a:	f640 036d 	movw	r3, #2157	; 0x86d
 8023c2e:	4a08      	ldr	r2, [pc, #32]	; (8023c50 <sm_run_csrk+0x204>)
 8023c30:	4916      	ldr	r1, [pc, #88]	; (8023c8c <sm_run_csrk+0x240>)
 8023c32:	2001      	movs	r0, #1
 8023c34:	f7f3 fc04 	bl	8017440 <hci_dump_log>
            sm_address_resolution_handle_event(ADDRESS_RESOLUTION_FAILED);
 8023c38:	2001      	movs	r0, #1
 8023c3a:	f7fe fbd5 	bl	80223e8 <sm_address_resolution_handle_event>
        }
    }
    return false;
 8023c3e:	2300      	movs	r3, #0
}
 8023c40:	4618      	mov	r0, r3
 8023c42:	373c      	adds	r7, #60	; 0x3c
 8023c44:	46bd      	mov	sp, r7
 8023c46:	bd90      	pop	{r4, r7, pc}
 8023c48:	2000a064 	.word	0x2000a064
 8023c4c:	2000a048 	.word	0x2000a048
 8023c50:	0802d4a8 	.word	0x0802d4a8
 8023c54:	0802dbb8 	.word	0x0802dbb8
 8023c58:	0802dbe0 	.word	0x0802dbe0
 8023c5c:	2000a050 	.word	0x2000a050
 8023c60:	2000a054 	.word	0x2000a054
 8023c64:	0802dc00 	.word	0x0802dc00
 8023c68:	2000a068 	.word	0x2000a068
 8023c6c:	0802dc40 	.word	0x0802dc40
 8023c70:	0802dc68 	.word	0x0802dc68
 8023c74:	2000a0c0 	.word	0x2000a0c0
 8023c78:	2000a0d0 	.word	0x2000a0d0
 8023c7c:	2000a04c 	.word	0x2000a04c
 8023c80:	080257d1 	.word	0x080257d1
 8023c84:	2000a0e0 	.word	0x2000a0e0
 8023c88:	2000a084 	.word	0x2000a084
 8023c8c:	0802dc6c 	.word	0x0802dc6c

08023c90 <sm_run_oob>:

// SC OOB
static bool sm_run_oob(void){
 8023c90:	b580      	push	{r7, lr}
 8023c92:	b082      	sub	sp, #8
 8023c94:	af02      	add	r7, sp, #8
#ifdef ENABLE_LE_SECURE_CONNECTIONS
    switch (sm_sc_oob_state){
 8023c96:	4b0e      	ldr	r3, [pc, #56]	; (8023cd0 <sm_run_oob+0x40>)
 8023c98:	781b      	ldrb	r3, [r3, #0]
 8023c9a:	2b02      	cmp	r3, #2
 8023c9c:	d000      	beq.n	8023ca0 <sm_run_oob+0x10>
            if (!sm_cmac_ready()) break;
            sm_sc_oob_state = SM_SC_OOB_W4_CONFIRM;
            f4_engine(NULL, ec_q, ec_q, sm_sc_oob_random, 0);
            return true;
        default:
            break;
 8023c9e:	e012      	b.n	8023cc6 <sm_run_oob+0x36>
            if (!sm_cmac_ready()) break;
 8023ca0:	f7fe f884 	bl	8021dac <sm_cmac_ready>
 8023ca4:	4603      	mov	r3, r0
 8023ca6:	2b00      	cmp	r3, #0
 8023ca8:	d00c      	beq.n	8023cc4 <sm_run_oob+0x34>
            sm_sc_oob_state = SM_SC_OOB_W4_CONFIRM;
 8023caa:	4b09      	ldr	r3, [pc, #36]	; (8023cd0 <sm_run_oob+0x40>)
 8023cac:	2203      	movs	r2, #3
 8023cae:	701a      	strb	r2, [r3, #0]
            f4_engine(NULL, ec_q, ec_q, sm_sc_oob_random, 0);
 8023cb0:	2300      	movs	r3, #0
 8023cb2:	9300      	str	r3, [sp, #0]
 8023cb4:	4b07      	ldr	r3, [pc, #28]	; (8023cd4 <sm_run_oob+0x44>)
 8023cb6:	4a08      	ldr	r2, [pc, #32]	; (8023cd8 <sm_run_oob+0x48>)
 8023cb8:	4907      	ldr	r1, [pc, #28]	; (8023cd8 <sm_run_oob+0x48>)
 8023cba:	2000      	movs	r0, #0
 8023cbc:	f7ff f888 	bl	8022dd0 <f4_engine>
            return true;
 8023cc0:	2301      	movs	r3, #1
 8023cc2:	e001      	b.n	8023cc8 <sm_run_oob+0x38>
            if (!sm_cmac_ready()) break;
 8023cc4:	bf00      	nop
    }
#endif
    return false;
 8023cc6:	2300      	movs	r3, #0
}
 8023cc8:	4618      	mov	r0, r3
 8023cca:	46bd      	mov	sp, r7
 8023ccc:	bd80      	pop	{r7, pc}
 8023cce:	bf00      	nop
 8023cd0:	20009f64 	.word	0x20009f64
 8023cd4:	20009f50 	.word	0x20009f50
 8023cd8:	2000a110 	.word	0x2000a110

08023cdc <sm_run_basic>:

// handle basic actions that don't requires the full context
static bool sm_run_basic(void){
 8023cdc:	b580      	push	{r7, lr}
 8023cde:	b086      	sub	sp, #24
 8023ce0:	af00      	add	r7, sp, #0
    btstack_linked_list_iterator_t it;
    hci_connections_get_iterator(&it);
 8023ce2:	1d3b      	adds	r3, r7, #4
 8023ce4:	4618      	mov	r0, r3
 8023ce6:	f7eb fddb 	bl	800f8a0 <hci_connections_get_iterator>
    while(btstack_linked_list_iterator_has_next(&it)){
 8023cea:	e033      	b.n	8023d54 <sm_run_basic+0x78>
        hci_connection_t * hci_connection = (hci_connection_t *) btstack_linked_list_iterator_next(&it);
 8023cec:	1d3b      	adds	r3, r7, #4
 8023cee:	4618      	mov	r0, r3
 8023cf0:	f7ea fd70 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8023cf4:	6178      	str	r0, [r7, #20]
        sm_connection_t  * sm_connection = &hci_connection->sm_connection;
 8023cf6:	697b      	ldr	r3, [r7, #20]
 8023cf8:	f203 731c 	addw	r3, r3, #1820	; 0x71c
 8023cfc:	613b      	str	r3, [r7, #16]
        switch(sm_connection->sm_engine_state){
 8023cfe:	693b      	ldr	r3, [r7, #16]
 8023d00:	7b1b      	ldrb	r3, [r3, #12]
 8023d02:	2b1e      	cmp	r3, #30
 8023d04:	d002      	beq.n	8023d0c <sm_run_basic+0x30>
 8023d06:	2b30      	cmp	r3, #48	; 0x30
 8023d08:	d00b      	beq.n	8023d22 <sm_run_basic+0x46>
 8023d0a:	e022      	b.n	8023d52 <sm_run_basic+0x76>
            // responder side
            case SM_RESPONDER_PH0_SEND_LTK_REQUESTED_NEGATIVE_REPLY:
                sm_connection->sm_engine_state = SM_RESPONDER_IDLE;
 8023d0c:	693b      	ldr	r3, [r7, #16]
 8023d0e:	221a      	movs	r2, #26
 8023d10:	731a      	strb	r2, [r3, #12]
                hci_send_cmd(&hci_le_long_term_key_negative_reply, sm_connection->sm_handle);
 8023d12:	693b      	ldr	r3, [r7, #16]
 8023d14:	881b      	ldrh	r3, [r3, #0]
 8023d16:	4619      	mov	r1, r3
 8023d18:	4814      	ldr	r0, [pc, #80]	; (8023d6c <sm_run_basic+0x90>)
 8023d1a:	f7f2 f961 	bl	8015fe0 <hci_send_cmd>
                return true;
 8023d1e:	2301      	movs	r3, #1
 8023d20:	e020      	b.n	8023d64 <sm_run_basic+0x88>

#ifdef ENABLE_LE_SECURE_CONNECTIONS
            case SM_SC_RECEIVED_LTK_REQUEST:
                switch (sm_connection->sm_irk_lookup_state){
 8023d22:	693b      	ldr	r3, [r7, #16]
 8023d24:	7b5b      	ldrb	r3, [r3, #13]
 8023d26:	2b04      	cmp	r3, #4
 8023d28:	d001      	beq.n	8023d2e <sm_run_basic+0x52>
                        log_info("LTK Request: IRK Lookup Failed)");
                        sm_connection->sm_engine_state = SM_RESPONDER_IDLE;
                        hci_send_cmd(&hci_le_long_term_key_negative_reply, sm_connection->sm_handle);
                        return true;
                    default:
                        break;
 8023d2a:	bf00      	nop
                }
                break;
 8023d2c:	e012      	b.n	8023d54 <sm_run_basic+0x78>
                        log_info("LTK Request: IRK Lookup Failed)");
 8023d2e:	f640 0396 	movw	r3, #2198	; 0x896
 8023d32:	4a0f      	ldr	r2, [pc, #60]	; (8023d70 <sm_run_basic+0x94>)
 8023d34:	490f      	ldr	r1, [pc, #60]	; (8023d74 <sm_run_basic+0x98>)
 8023d36:	2001      	movs	r0, #1
 8023d38:	f7f3 fb82 	bl	8017440 <hci_dump_log>
                        sm_connection->sm_engine_state = SM_RESPONDER_IDLE;
 8023d3c:	693b      	ldr	r3, [r7, #16]
 8023d3e:	221a      	movs	r2, #26
 8023d40:	731a      	strb	r2, [r3, #12]
                        hci_send_cmd(&hci_le_long_term_key_negative_reply, sm_connection->sm_handle);
 8023d42:	693b      	ldr	r3, [r7, #16]
 8023d44:	881b      	ldrh	r3, [r3, #0]
 8023d46:	4619      	mov	r1, r3
 8023d48:	4808      	ldr	r0, [pc, #32]	; (8023d6c <sm_run_basic+0x90>)
 8023d4a:	f7f2 f949 	bl	8015fe0 <hci_send_cmd>
                        return true;
 8023d4e:	2301      	movs	r3, #1
 8023d50:	e008      	b.n	8023d64 <sm_run_basic+0x88>
#endif
            default:
                break;
 8023d52:	bf00      	nop
    while(btstack_linked_list_iterator_has_next(&it)){
 8023d54:	1d3b      	adds	r3, r7, #4
 8023d56:	4618      	mov	r0, r3
 8023d58:	f7ea fd0e 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8023d5c:	4603      	mov	r3, r0
 8023d5e:	2b00      	cmp	r3, #0
 8023d60:	d1c4      	bne.n	8023cec <sm_run_basic+0x10>
        }
    }
    return false;
 8023d62:	2300      	movs	r3, #0
}
 8023d64:	4618      	mov	r0, r3
 8023d66:	3718      	adds	r7, #24
 8023d68:	46bd      	mov	sp, r7
 8023d6a:	bd80      	pop	{r7, pc}
 8023d6c:	08030c10 	.word	0x08030c10
 8023d70:	0802d4a8 	.word	0x0802d4a8
 8023d74:	0802dc90 	.word	0x0802dc90

08023d78 <sm_run_activate_connection>:

static void sm_run_activate_connection(void){
 8023d78:	b580      	push	{r7, lr}
 8023d7a:	b08a      	sub	sp, #40	; 0x28
 8023d7c:	af04      	add	r7, sp, #16
    // Find connections that requires setup context and make active if no other is locked
    btstack_linked_list_iterator_t it;
    hci_connections_get_iterator(&it);
 8023d7e:	463b      	mov	r3, r7
 8023d80:	4618      	mov	r0, r3
 8023d82:	f7eb fd8d 	bl	800f8a0 <hci_connections_get_iterator>
    while((sm_active_connection_handle == HCI_CON_HANDLE_INVALID) && btstack_linked_list_iterator_has_next(&it)){
 8023d86:	e076      	b.n	8023e76 <sm_run_activate_connection+0xfe>
        hci_connection_t * hci_connection = (hci_connection_t *) btstack_linked_list_iterator_next(&it);
 8023d88:	463b      	mov	r3, r7
 8023d8a:	4618      	mov	r0, r3
 8023d8c:	f7ea fd22 	bl	800e7d4 <btstack_linked_list_iterator_next>
 8023d90:	6138      	str	r0, [r7, #16]
        sm_connection_t  * sm_connection = &hci_connection->sm_connection;
 8023d92:	693b      	ldr	r3, [r7, #16]
 8023d94:	f203 731c 	addw	r3, r3, #1820	; 0x71c
 8023d98:	60fb      	str	r3, [r7, #12]
        // - if no connection locked and we're ready/waiting for setup context, fetch it and start
        bool done = true;
 8023d9a:	2301      	movs	r3, #1
 8023d9c:	75fb      	strb	r3, [r7, #23]
        int err;
        UNUSED(err);

#ifdef ENABLE_LE_SECURE_CONNECTIONS
        // assert ec key is ready
        if (   (sm_connection->sm_engine_state == SM_RESPONDER_PH1_PAIRING_REQUEST_RECEIVED)
 8023d9e:	68fb      	ldr	r3, [r7, #12]
 8023da0:	7b1b      	ldrb	r3, [r3, #12]
 8023da2:	2b20      	cmp	r3, #32
 8023da4:	d007      	beq.n	8023db6 <sm_run_activate_connection+0x3e>
            || (sm_connection->sm_engine_state == SM_INITIATOR_PH1_W2_SEND_PAIRING_REQUEST)
 8023da6:	68fb      	ldr	r3, [r7, #12]
 8023da8:	7b1b      	ldrb	r3, [r3, #12]
 8023daa:	2b2a      	cmp	r3, #42	; 0x2a
 8023dac:	d003      	beq.n	8023db6 <sm_run_activate_connection+0x3e>
			|| (sm_connection->sm_engine_state == SM_RESPONDER_SEND_SECURITY_REQUEST)){
 8023dae:	68fb      	ldr	r3, [r7, #12]
 8023db0:	7b1b      	ldrb	r3, [r3, #12]
 8023db2:	2b1b      	cmp	r3, #27
 8023db4:	d10a      	bne.n	8023dcc <sm_run_activate_connection+0x54>
            if (ec_key_generation_state == EC_KEY_GENERATION_IDLE){
 8023db6:	4b39      	ldr	r3, [pc, #228]	; (8023e9c <sm_run_activate_connection+0x124>)
 8023db8:	781b      	ldrb	r3, [r3, #0]
 8023dba:	2b00      	cmp	r3, #0
 8023dbc:	d101      	bne.n	8023dc2 <sm_run_activate_connection+0x4a>
                sm_ec_generate_new_key();
 8023dbe:	f003 f933 	bl	8027028 <sm_ec_generate_new_key>
            }
            if (ec_key_generation_state != EC_KEY_GENERATION_DONE){
 8023dc2:	4b36      	ldr	r3, [pc, #216]	; (8023e9c <sm_run_activate_connection+0x124>)
 8023dc4:	781b      	ldrb	r3, [r3, #0]
 8023dc6:	2b02      	cmp	r3, #2
 8023dc8:	d000      	beq.n	8023dcc <sm_run_activate_connection+0x54>
                continue;
 8023dca:	e054      	b.n	8023e76 <sm_run_activate_connection+0xfe>
            }
        }
#endif

        switch (sm_connection->sm_engine_state) {
 8023dcc:	68fb      	ldr	r3, [r7, #12]
 8023dce:	7b1b      	ldrb	r3, [r3, #12]
 8023dd0:	3b1b      	subs	r3, #27
 8023dd2:	2b15      	cmp	r3, #21
 8023dd4:	d82e      	bhi.n	8023e34 <sm_run_activate_connection+0xbc>
 8023dd6:	a201      	add	r2, pc, #4	; (adr r2, 8023ddc <sm_run_activate_connection+0x64>)
 8023dd8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8023ddc:	08023e3b 	.word	0x08023e3b
 8023de0:	08023e3b 	.word	0x08023e3b
 8023de4:	08023e35 	.word	0x08023e35
 8023de8:	08023e35 	.word	0x08023e35
 8023dec:	08023e35 	.word	0x08023e35
 8023df0:	08023e3b 	.word	0x08023e3b
 8023df4:	08023e35 	.word	0x08023e35
 8023df8:	08023e35 	.word	0x08023e35
 8023dfc:	08023e35 	.word	0x08023e35
 8023e00:	08023e35 	.word	0x08023e35
 8023e04:	08023e35 	.word	0x08023e35
 8023e08:	08023e35 	.word	0x08023e35
 8023e0c:	08023e35 	.word	0x08023e35
 8023e10:	08023e35 	.word	0x08023e35
 8023e14:	08023e35 	.word	0x08023e35
 8023e18:	08023e3b 	.word	0x08023e3b
 8023e1c:	08023e35 	.word	0x08023e35
 8023e20:	08023e35 	.word	0x08023e35
 8023e24:	08023e35 	.word	0x08023e35
 8023e28:	08023e35 	.word	0x08023e35
 8023e2c:	08023e3b 	.word	0x08023e3b
 8023e30:	08023e3b 	.word	0x08023e3b
			case SM_INITIATOR_PH1_W2_SEND_PAIRING_REQUEST:
#endif
				// just lock context
				break;
            default:
                done = false;
 8023e34:	2300      	movs	r3, #0
 8023e36:	75fb      	strb	r3, [r7, #23]
                break;
 8023e38:	e000      	b.n	8023e3c <sm_run_activate_connection+0xc4>
				break;
 8023e3a:	bf00      	nop
        }
        if (done){
 8023e3c:	7dfb      	ldrb	r3, [r7, #23]
 8023e3e:	2b00      	cmp	r3, #0
 8023e40:	d019      	beq.n	8023e76 <sm_run_activate_connection+0xfe>
            sm_active_connection_handle = sm_connection->sm_handle;
 8023e42:	68fb      	ldr	r3, [r7, #12]
 8023e44:	881a      	ldrh	r2, [r3, #0]
 8023e46:	4b16      	ldr	r3, [pc, #88]	; (8023ea0 <sm_run_activate_connection+0x128>)
 8023e48:	801a      	strh	r2, [r3, #0]
            log_info("sm: connection 0x%04x locked setup context as %s, state %u", sm_active_connection_handle, sm_connection->sm_role ? "responder" : "initiator", sm_connection->sm_engine_state);
 8023e4a:	4b15      	ldr	r3, [pc, #84]	; (8023ea0 <sm_run_activate_connection+0x128>)
 8023e4c:	881b      	ldrh	r3, [r3, #0]
 8023e4e:	4619      	mov	r1, r3
 8023e50:	68fb      	ldr	r3, [r7, #12]
 8023e52:	789b      	ldrb	r3, [r3, #2]
 8023e54:	2b00      	cmp	r3, #0
 8023e56:	d001      	beq.n	8023e5c <sm_run_activate_connection+0xe4>
 8023e58:	4b12      	ldr	r3, [pc, #72]	; (8023ea4 <sm_run_activate_connection+0x12c>)
 8023e5a:	e000      	b.n	8023e5e <sm_run_activate_connection+0xe6>
 8023e5c:	4b12      	ldr	r3, [pc, #72]	; (8023ea8 <sm_run_activate_connection+0x130>)
 8023e5e:	68fa      	ldr	r2, [r7, #12]
 8023e60:	7b12      	ldrb	r2, [r2, #12]
 8023e62:	9202      	str	r2, [sp, #8]
 8023e64:	9301      	str	r3, [sp, #4]
 8023e66:	9100      	str	r1, [sp, #0]
 8023e68:	f640 03d5 	movw	r3, #2261	; 0x8d5
 8023e6c:	4a0f      	ldr	r2, [pc, #60]	; (8023eac <sm_run_activate_connection+0x134>)
 8023e6e:	4910      	ldr	r1, [pc, #64]	; (8023eb0 <sm_run_activate_connection+0x138>)
 8023e70:	2001      	movs	r0, #1
 8023e72:	f7f3 fae5 	bl	8017440 <hci_dump_log>
    while((sm_active_connection_handle == HCI_CON_HANDLE_INVALID) && btstack_linked_list_iterator_has_next(&it)){
 8023e76:	4b0a      	ldr	r3, [pc, #40]	; (8023ea0 <sm_run_activate_connection+0x128>)
 8023e78:	881b      	ldrh	r3, [r3, #0]
 8023e7a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8023e7e:	4293      	cmp	r3, r2
 8023e80:	d107      	bne.n	8023e92 <sm_run_activate_connection+0x11a>
 8023e82:	463b      	mov	r3, r7
 8023e84:	4618      	mov	r0, r3
 8023e86:	f7ea fc77 	bl	800e778 <btstack_linked_list_iterator_has_next>
 8023e8a:	4603      	mov	r3, r0
 8023e8c:	2b00      	cmp	r3, #0
 8023e8e:	f47f af7b 	bne.w	8023d88 <sm_run_activate_connection+0x10>
        }
    }
}
 8023e92:	bf00      	nop
 8023e94:	3718      	adds	r7, #24
 8023e96:	46bd      	mov	sp, r7
 8023e98:	bd80      	pop	{r7, pc}
 8023e9a:	bf00      	nop
 8023e9c:	2000a10c 	.word	0x2000a10c
 8023ea0:	200000a4 	.word	0x200000a4
 8023ea4:	0802dcb8 	.word	0x0802dcb8
 8023ea8:	0802dcc4 	.word	0x0802dcc4
 8023eac:	0802d4a8 	.word	0x0802d4a8
 8023eb0:	0802dcd0 	.word	0x0802dcd0

08023eb4 <sm_run_send_keypress_notification>:

static void sm_run_send_keypress_notification(sm_connection_t * connection){
 8023eb4:	b580      	push	{r7, lr}
 8023eb6:	b086      	sub	sp, #24
 8023eb8:	af00      	add	r7, sp, #0
 8023eba:	6078      	str	r0, [r7, #4]
    int i;
    uint8_t flags       = setup->sm_keypress_notification & 0x1fu;
 8023ebc:	4b30      	ldr	r3, [pc, #192]	; (8023f80 <sm_run_send_keypress_notification+0xcc>)
 8023ebe:	681b      	ldr	r3, [r3, #0]
 8023ec0:	7c9b      	ldrb	r3, [r3, #18]
 8023ec2:	f003 031f 	and.w	r3, r3, #31
 8023ec6:	74fb      	strb	r3, [r7, #19]
    uint8_t num_actions = setup->sm_keypress_notification >> 5;
 8023ec8:	4b2d      	ldr	r3, [pc, #180]	; (8023f80 <sm_run_send_keypress_notification+0xcc>)
 8023eca:	681b      	ldr	r3, [r3, #0]
 8023ecc:	7c9b      	ldrb	r3, [r3, #18]
 8023ece:	095b      	lsrs	r3, r3, #5
 8023ed0:	74bb      	strb	r3, [r7, #18]
    uint8_t action = 0;
 8023ed2:	2300      	movs	r3, #0
 8023ed4:	747b      	strb	r3, [r7, #17]
    for (i=SM_KEYPRESS_PASSKEY_ENTRY_STARTED;i<=SM_KEYPRESS_PASSKEY_ENTRY_COMPLETED;i++){
 8023ed6:	2300      	movs	r3, #0
 8023ed8:	617b      	str	r3, [r7, #20]
 8023eda:	e02d      	b.n	8023f38 <sm_run_send_keypress_notification+0x84>
        if (flags & (1u<<i)){
 8023edc:	7cfa      	ldrb	r2, [r7, #19]
 8023ede:	697b      	ldr	r3, [r7, #20]
 8023ee0:	fa22 f303 	lsr.w	r3, r2, r3
 8023ee4:	f003 0301 	and.w	r3, r3, #1
 8023ee8:	2b00      	cmp	r3, #0
 8023eea:	d022      	beq.n	8023f32 <sm_run_send_keypress_notification+0x7e>
            bool clear_flag = true;
 8023eec:	2301      	movs	r3, #1
 8023eee:	743b      	strb	r3, [r7, #16]
            switch (i){
 8023ef0:	697b      	ldr	r3, [r7, #20]
 8023ef2:	3b01      	subs	r3, #1
 8023ef4:	2b01      	cmp	r3, #1
 8023ef6:	d809      	bhi.n	8023f0c <sm_run_send_keypress_notification+0x58>
                case SM_KEYPRESS_PASSKEY_ENTRY_COMPLETED:
                default:
                    break;
                case SM_KEYPRESS_PASSKEY_DIGIT_ENTERED:
                case SM_KEYPRESS_PASSKEY_DIGIT_ERASED:
                    num_actions--;
 8023ef8:	7cbb      	ldrb	r3, [r7, #18]
 8023efa:	3b01      	subs	r3, #1
 8023efc:	74bb      	strb	r3, [r7, #18]
                    clear_flag = num_actions == 0u;
 8023efe:	7cbb      	ldrb	r3, [r7, #18]
 8023f00:	2b00      	cmp	r3, #0
 8023f02:	bf0c      	ite	eq
 8023f04:	2301      	moveq	r3, #1
 8023f06:	2300      	movne	r3, #0
 8023f08:	743b      	strb	r3, [r7, #16]
                    break;
 8023f0a:	e000      	b.n	8023f0e <sm_run_send_keypress_notification+0x5a>
                    break;
 8023f0c:	bf00      	nop
            }
            if (clear_flag){
 8023f0e:	7c3b      	ldrb	r3, [r7, #16]
 8023f10:	2b00      	cmp	r3, #0
 8023f12:	d00b      	beq.n	8023f2c <sm_run_send_keypress_notification+0x78>
                flags &= ~(1<<i);
 8023f14:	2201      	movs	r2, #1
 8023f16:	697b      	ldr	r3, [r7, #20]
 8023f18:	fa02 f303 	lsl.w	r3, r2, r3
 8023f1c:	b25b      	sxtb	r3, r3
 8023f1e:	43db      	mvns	r3, r3
 8023f20:	b25a      	sxtb	r2, r3
 8023f22:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8023f26:	4013      	ands	r3, r2
 8023f28:	b25b      	sxtb	r3, r3
 8023f2a:	74fb      	strb	r3, [r7, #19]
            }
            action = i;
 8023f2c:	697b      	ldr	r3, [r7, #20]
 8023f2e:	747b      	strb	r3, [r7, #17]
            break;
 8023f30:	e005      	b.n	8023f3e <sm_run_send_keypress_notification+0x8a>
    for (i=SM_KEYPRESS_PASSKEY_ENTRY_STARTED;i<=SM_KEYPRESS_PASSKEY_ENTRY_COMPLETED;i++){
 8023f32:	697b      	ldr	r3, [r7, #20]
 8023f34:	3301      	adds	r3, #1
 8023f36:	617b      	str	r3, [r7, #20]
 8023f38:	697b      	ldr	r3, [r7, #20]
 8023f3a:	2b04      	cmp	r3, #4
 8023f3c:	ddce      	ble.n	8023edc <sm_run_send_keypress_notification+0x28>
        }
    }
    setup->sm_keypress_notification = (num_actions << 5) | flags;
 8023f3e:	7cbb      	ldrb	r3, [r7, #18]
 8023f40:	015b      	lsls	r3, r3, #5
 8023f42:	b25a      	sxtb	r2, r3
 8023f44:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8023f48:	4313      	orrs	r3, r2
 8023f4a:	b25a      	sxtb	r2, r3
 8023f4c:	4b0c      	ldr	r3, [pc, #48]	; (8023f80 <sm_run_send_keypress_notification+0xcc>)
 8023f4e:	681b      	ldr	r3, [r3, #0]
 8023f50:	b2d2      	uxtb	r2, r2
 8023f52:	749a      	strb	r2, [r3, #18]

    // send keypress notification
    uint8_t buffer[2];
    buffer[0] = SM_CODE_KEYPRESS_NOTIFICATION;
 8023f54:	230e      	movs	r3, #14
 8023f56:	733b      	strb	r3, [r7, #12]
    buffer[1] = action;
 8023f58:	7c7b      	ldrb	r3, [r7, #17]
 8023f5a:	737b      	strb	r3, [r7, #13]
    l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 8023f5c:	687b      	ldr	r3, [r7, #4]
 8023f5e:	8818      	ldrh	r0, [r3, #0]
 8023f60:	f107 020c 	add.w	r2, r7, #12
 8023f64:	2302      	movs	r3, #2
 8023f66:	2106      	movs	r1, #6
 8023f68:	f7f4 fc4a 	bl	8018800 <l2cap_send_connectionless>

    // try
    l2cap_request_can_send_fix_channel_now_event(sm_active_connection_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL);
 8023f6c:	4b05      	ldr	r3, [pc, #20]	; (8023f84 <sm_run_send_keypress_notification+0xd0>)
 8023f6e:	881b      	ldrh	r3, [r3, #0]
 8023f70:	2106      	movs	r1, #6
 8023f72:	4618      	mov	r0, r3
 8023f74:	f7f4 fb8a 	bl	801868c <l2cap_request_can_send_fix_channel_now_event>
}
 8023f78:	bf00      	nop
 8023f7a:	3718      	adds	r7, #24
 8023f7c:	46bd      	mov	sp, r7
 8023f7e:	bd80      	pop	{r7, pc}
 8023f80:	200000a0 	.word	0x200000a0
 8023f84:	200000a4 	.word	0x200000a4

08023f88 <sm_run_distribute_keys>:

static void sm_run_distribute_keys(sm_connection_t * connection){
 8023f88:	b580      	push	{r7, lr}
 8023f8a:	b098      	sub	sp, #96	; 0x60
 8023f8c:	af00      	add	r7, sp, #0
 8023f8e:	6078      	str	r0, [r7, #4]
    if (setup->sm_key_distribution_send_set &   SM_KEYDIST_FLAG_ENCRYPTION_INFORMATION){
 8023f90:	4b95      	ldr	r3, [pc, #596]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8023f92:	681b      	ldr	r3, [r3, #0]
 8023f94:	7cdb      	ldrb	r3, [r3, #19]
 8023f96:	f003 0301 	and.w	r3, r3, #1
 8023f9a:	2b00      	cmp	r3, #0
 8023f9c:	d02c      	beq.n	8023ff8 <sm_run_distribute_keys+0x70>
        setup->sm_key_distribution_send_set &= ~SM_KEYDIST_FLAG_ENCRYPTION_INFORMATION;
 8023f9e:	4b92      	ldr	r3, [pc, #584]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8023fa0:	681b      	ldr	r3, [r3, #0]
 8023fa2:	7cda      	ldrb	r2, [r3, #19]
 8023fa4:	4b90      	ldr	r3, [pc, #576]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8023fa6:	681b      	ldr	r3, [r3, #0]
 8023fa8:	f022 0201 	bic.w	r2, r2, #1
 8023fac:	b2d2      	uxtb	r2, r2
 8023fae:	74da      	strb	r2, [r3, #19]
        setup->sm_key_distribution_sent_set |=  SM_KEYDIST_FLAG_ENCRYPTION_INFORMATION;
 8023fb0:	4b8d      	ldr	r3, [pc, #564]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8023fb2:	681b      	ldr	r3, [r3, #0]
 8023fb4:	7d1a      	ldrb	r2, [r3, #20]
 8023fb6:	4b8c      	ldr	r3, [pc, #560]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8023fb8:	681b      	ldr	r3, [r3, #0]
 8023fba:	f042 0201 	orr.w	r2, r2, #1
 8023fbe:	b2d2      	uxtb	r2, r2
 8023fc0:	751a      	strb	r2, [r3, #20]
        uint8_t buffer[17];
        buffer[0] = SM_CODE_ENCRYPTION_INFORMATION;
 8023fc2:	2306      	movs	r3, #6
 8023fc4:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
        reverse_128(setup->sm_ltk, &buffer[1]);
 8023fc8:	4b87      	ldr	r3, [pc, #540]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8023fca:	681b      	ldr	r3, [r3, #0]
 8023fcc:	f103 0295 	add.w	r2, r3, #149	; 0x95
 8023fd0:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8023fd4:	3301      	adds	r3, #1
 8023fd6:	4619      	mov	r1, r3
 8023fd8:	4610      	mov	r0, r2
 8023fda:	f7eb f86e 	bl	800f0ba <reverse_128>
        l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 8023fde:	687b      	ldr	r3, [r7, #4]
 8023fe0:	8818      	ldrh	r0, [r3, #0]
 8023fe2:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 8023fe6:	2311      	movs	r3, #17
 8023fe8:	2106      	movs	r1, #6
 8023fea:	f7f4 fc09 	bl	8018800 <l2cap_send_connectionless>
        sm_timeout_reset(connection);
 8023fee:	6878      	ldr	r0, [r7, #4]
 8023ff0:	f7fd fbd4 	bl	802179c <sm_timeout_reset>
        return;
 8023ff4:	bf00      	nop
 8023ff6:	e0f4      	b.n	80241e2 <sm_run_distribute_keys+0x25a>
    }
    if (setup->sm_key_distribution_send_set &   SM_KEYDIST_FLAG_MASTER_IDENTIFICATION){
 8023ff8:	4b7b      	ldr	r3, [pc, #492]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8023ffa:	681b      	ldr	r3, [r3, #0]
 8023ffc:	7cdb      	ldrb	r3, [r3, #19]
 8023ffe:	f003 0302 	and.w	r3, r3, #2
 8024002:	2b00      	cmp	r3, #0
 8024004:	d036      	beq.n	8024074 <sm_run_distribute_keys+0xec>
        setup->sm_key_distribution_send_set &= ~SM_KEYDIST_FLAG_MASTER_IDENTIFICATION;
 8024006:	4b78      	ldr	r3, [pc, #480]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8024008:	681b      	ldr	r3, [r3, #0]
 802400a:	7cda      	ldrb	r2, [r3, #19]
 802400c:	4b76      	ldr	r3, [pc, #472]	; (80241e8 <sm_run_distribute_keys+0x260>)
 802400e:	681b      	ldr	r3, [r3, #0]
 8024010:	f022 0202 	bic.w	r2, r2, #2
 8024014:	b2d2      	uxtb	r2, r2
 8024016:	74da      	strb	r2, [r3, #19]
        setup->sm_key_distribution_sent_set |=  SM_KEYDIST_FLAG_MASTER_IDENTIFICATION;
 8024018:	4b73      	ldr	r3, [pc, #460]	; (80241e8 <sm_run_distribute_keys+0x260>)
 802401a:	681b      	ldr	r3, [r3, #0]
 802401c:	7d1a      	ldrb	r2, [r3, #20]
 802401e:	4b72      	ldr	r3, [pc, #456]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8024020:	681b      	ldr	r3, [r3, #0]
 8024022:	f042 0202 	orr.w	r2, r2, #2
 8024026:	b2d2      	uxtb	r2, r2
 8024028:	751a      	strb	r2, [r3, #20]
        uint8_t buffer[11];
        buffer[0] = SM_CODE_MASTER_IDENTIFICATION;
 802402a:	2307      	movs	r3, #7
 802402c:	f887 3040 	strb.w	r3, [r7, #64]	; 0x40
        little_endian_store_16(buffer, 1, setup->sm_local_ediv);
 8024030:	4b6d      	ldr	r3, [pc, #436]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8024032:	681b      	ldr	r3, [r3, #0]
 8024034:	f8b3 218c 	ldrh.w	r2, [r3, #396]	; 0x18c
 8024038:	f107 0340 	add.w	r3, r7, #64	; 0x40
 802403c:	2101      	movs	r1, #1
 802403e:	4618      	mov	r0, r3
 8024040:	f7ea ff11 	bl	800ee66 <little_endian_store_16>
        reverse_64(setup->sm_local_rand, &buffer[3]);
 8024044:	4b68      	ldr	r3, [pc, #416]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8024046:	681b      	ldr	r3, [r3, #0]
 8024048:	f503 72c7 	add.w	r2, r3, #398	; 0x18e
 802404c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8024050:	3303      	adds	r3, #3
 8024052:	4619      	mov	r1, r3
 8024054:	4610      	mov	r0, r2
 8024056:	f7eb f822 	bl	800f09e <reverse_64>
        l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 802405a:	687b      	ldr	r3, [r7, #4]
 802405c:	8818      	ldrh	r0, [r3, #0]
 802405e:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8024062:	230b      	movs	r3, #11
 8024064:	2106      	movs	r1, #6
 8024066:	f7f4 fbcb 	bl	8018800 <l2cap_send_connectionless>
        sm_timeout_reset(connection);
 802406a:	6878      	ldr	r0, [r7, #4]
 802406c:	f7fd fb96 	bl	802179c <sm_timeout_reset>
        return;
 8024070:	bf00      	nop
 8024072:	e0b6      	b.n	80241e2 <sm_run_distribute_keys+0x25a>
    }
    if (setup->sm_key_distribution_send_set &   SM_KEYDIST_FLAG_IDENTITY_INFORMATION){
 8024074:	4b5c      	ldr	r3, [pc, #368]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8024076:	681b      	ldr	r3, [r3, #0]
 8024078:	7cdb      	ldrb	r3, [r3, #19]
 802407a:	f003 0304 	and.w	r3, r3, #4
 802407e:	2b00      	cmp	r3, #0
 8024080:	d028      	beq.n	80240d4 <sm_run_distribute_keys+0x14c>
        setup->sm_key_distribution_send_set &= ~SM_KEYDIST_FLAG_IDENTITY_INFORMATION;
 8024082:	4b59      	ldr	r3, [pc, #356]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8024084:	681b      	ldr	r3, [r3, #0]
 8024086:	7cda      	ldrb	r2, [r3, #19]
 8024088:	4b57      	ldr	r3, [pc, #348]	; (80241e8 <sm_run_distribute_keys+0x260>)
 802408a:	681b      	ldr	r3, [r3, #0]
 802408c:	f022 0204 	bic.w	r2, r2, #4
 8024090:	b2d2      	uxtb	r2, r2
 8024092:	74da      	strb	r2, [r3, #19]
        setup->sm_key_distribution_sent_set |=  SM_KEYDIST_FLAG_IDENTITY_INFORMATION;
 8024094:	4b54      	ldr	r3, [pc, #336]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8024096:	681b      	ldr	r3, [r3, #0]
 8024098:	7d1a      	ldrb	r2, [r3, #20]
 802409a:	4b53      	ldr	r3, [pc, #332]	; (80241e8 <sm_run_distribute_keys+0x260>)
 802409c:	681b      	ldr	r3, [r3, #0]
 802409e:	f042 0204 	orr.w	r2, r2, #4
 80240a2:	b2d2      	uxtb	r2, r2
 80240a4:	751a      	strb	r2, [r3, #20]
        uint8_t buffer[17];
        buffer[0] = SM_CODE_IDENTITY_INFORMATION;
 80240a6:	2308      	movs	r3, #8
 80240a8:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        reverse_128(sm_persistent_irk, &buffer[1]);
 80240ac:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80240b0:	3301      	adds	r3, #1
 80240b2:	4619      	mov	r1, r3
 80240b4:	484d      	ldr	r0, [pc, #308]	; (80241ec <sm_run_distribute_keys+0x264>)
 80240b6:	f7eb f800 	bl	800f0ba <reverse_128>
        l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 80240ba:	687b      	ldr	r3, [r7, #4]
 80240bc:	8818      	ldrh	r0, [r3, #0]
 80240be:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 80240c2:	2311      	movs	r3, #17
 80240c4:	2106      	movs	r1, #6
 80240c6:	f7f4 fb9b 	bl	8018800 <l2cap_send_connectionless>
        sm_timeout_reset(connection);
 80240ca:	6878      	ldr	r0, [r7, #4]
 80240cc:	f7fd fb66 	bl	802179c <sm_timeout_reset>
        return;
 80240d0:	bf00      	nop
 80240d2:	e086      	b.n	80241e2 <sm_run_distribute_keys+0x25a>
    }
    if (setup->sm_key_distribution_send_set &   SM_KEYDIST_FLAG_IDENTITY_ADDRESS_INFORMATION){
 80240d4:	4b44      	ldr	r3, [pc, #272]	; (80241e8 <sm_run_distribute_keys+0x260>)
 80240d6:	681b      	ldr	r3, [r3, #0]
 80240d8:	7cdb      	ldrb	r3, [r3, #19]
 80240da:	f003 0308 	and.w	r3, r3, #8
 80240de:	2b00      	cmp	r3, #0
 80240e0:	d04d      	beq.n	802417e <sm_run_distribute_keys+0x1f6>
        setup->sm_key_distribution_send_set &= ~SM_KEYDIST_FLAG_IDENTITY_ADDRESS_INFORMATION;
 80240e2:	4b41      	ldr	r3, [pc, #260]	; (80241e8 <sm_run_distribute_keys+0x260>)
 80240e4:	681b      	ldr	r3, [r3, #0]
 80240e6:	7cda      	ldrb	r2, [r3, #19]
 80240e8:	4b3f      	ldr	r3, [pc, #252]	; (80241e8 <sm_run_distribute_keys+0x260>)
 80240ea:	681b      	ldr	r3, [r3, #0]
 80240ec:	f022 0208 	bic.w	r2, r2, #8
 80240f0:	b2d2      	uxtb	r2, r2
 80240f2:	74da      	strb	r2, [r3, #19]
        setup->sm_key_distribution_sent_set |=  SM_KEYDIST_FLAG_IDENTITY_ADDRESS_INFORMATION;
 80240f4:	4b3c      	ldr	r3, [pc, #240]	; (80241e8 <sm_run_distribute_keys+0x260>)
 80240f6:	681b      	ldr	r3, [r3, #0]
 80240f8:	7d1a      	ldrb	r2, [r3, #20]
 80240fa:	4b3b      	ldr	r3, [pc, #236]	; (80241e8 <sm_run_distribute_keys+0x260>)
 80240fc:	681b      	ldr	r3, [r3, #0]
 80240fe:	f042 0208 	orr.w	r2, r2, #8
 8024102:	b2d2      	uxtb	r2, r2
 8024104:	751a      	strb	r2, [r3, #20]
        bd_addr_t local_address;
        uint8_t buffer[8];
        buffer[0] = SM_CODE_IDENTITY_ADDRESS_INFORMATION;
 8024106:	2309      	movs	r3, #9
 8024108:	773b      	strb	r3, [r7, #28]
        switch (gap_random_address_get_mode()){
 802410a:	f003 f98b 	bl	8027424 <gap_random_address_get_mode>
 802410e:	4603      	mov	r3, r0
 8024110:	2b03      	cmp	r3, #3
 8024112:	d81d      	bhi.n	8024150 <sm_run_distribute_keys+0x1c8>
 8024114:	a201      	add	r2, pc, #4	; (adr r2, 802411c <sm_run_distribute_keys+0x194>)
 8024116:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802411a:	bf00      	nop
 802411c:	0802412d 	.word	0x0802412d
 8024120:	0802412d 	.word	0x0802412d
 8024124:	08024141 	.word	0x08024141
 8024128:	08024141 	.word	0x08024141
            case GAP_RANDOM_ADDRESS_TYPE_OFF:
            case GAP_RANDOM_ADDRESS_TYPE_STATIC:
                // public or static random
                gap_le_get_own_address(&buffer[1], local_address);
 802412c:	f107 0224 	add.w	r2, r7, #36	; 0x24
 8024130:	f107 031c 	add.w	r3, r7, #28
 8024134:	3301      	adds	r3, #1
 8024136:	4611      	mov	r1, r2
 8024138:	4618      	mov	r0, r3
 802413a:	f7ec fba7 	bl	801088c <gap_le_get_own_address>
                break;
 802413e:	e008      	b.n	8024152 <sm_run_distribute_keys+0x1ca>
            case GAP_RANDOM_ADDRESS_NON_RESOLVABLE:
            case GAP_RANDOM_ADDRESS_RESOLVABLE:
                // fallback to public
                gap_local_bd_addr(local_address);
 8024140:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8024144:	4618      	mov	r0, r3
 8024146:	f7f0 faff 	bl	8014748 <gap_local_bd_addr>
                buffer[1] = 0;
 802414a:	2300      	movs	r3, #0
 802414c:	777b      	strb	r3, [r7, #29]
                break;
 802414e:	e000      	b.n	8024152 <sm_run_distribute_keys+0x1ca>
            default:
                btstack_assert(false);
                break;
 8024150:	bf00      	nop
        }
        reverse_bd_addr(local_address, &buffer[2]);
 8024152:	f107 031c 	add.w	r3, r7, #28
 8024156:	1c9a      	adds	r2, r3, #2
 8024158:	f107 0324 	add.w	r3, r7, #36	; 0x24
 802415c:	4611      	mov	r1, r2
 802415e:	4618      	mov	r0, r3
 8024160:	f7ea ffc7 	bl	800f0f2 <reverse_bd_addr>
        l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 8024164:	687b      	ldr	r3, [r7, #4]
 8024166:	8818      	ldrh	r0, [r3, #0]
 8024168:	f107 021c 	add.w	r2, r7, #28
 802416c:	2308      	movs	r3, #8
 802416e:	2106      	movs	r1, #6
 8024170:	f7f4 fb46 	bl	8018800 <l2cap_send_connectionless>
        sm_timeout_reset(connection);
 8024174:	6878      	ldr	r0, [r7, #4]
 8024176:	f7fd fb11 	bl	802179c <sm_timeout_reset>
        return;
 802417a:	bf00      	nop
 802417c:	e031      	b.n	80241e2 <sm_run_distribute_keys+0x25a>
    }
    if (setup->sm_key_distribution_send_set &   SM_KEYDIST_FLAG_SIGNING_IDENTIFICATION){
 802417e:	4b1a      	ldr	r3, [pc, #104]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8024180:	681b      	ldr	r3, [r3, #0]
 8024182:	7cdb      	ldrb	r3, [r3, #19]
 8024184:	f003 0310 	and.w	r3, r3, #16
 8024188:	2b00      	cmp	r3, #0
 802418a:	d02a      	beq.n	80241e2 <sm_run_distribute_keys+0x25a>
        setup->sm_key_distribution_send_set &= ~SM_KEYDIST_FLAG_SIGNING_IDENTIFICATION;
 802418c:	4b16      	ldr	r3, [pc, #88]	; (80241e8 <sm_run_distribute_keys+0x260>)
 802418e:	681b      	ldr	r3, [r3, #0]
 8024190:	7cda      	ldrb	r2, [r3, #19]
 8024192:	4b15      	ldr	r3, [pc, #84]	; (80241e8 <sm_run_distribute_keys+0x260>)
 8024194:	681b      	ldr	r3, [r3, #0]
 8024196:	f022 0210 	bic.w	r2, r2, #16
 802419a:	b2d2      	uxtb	r2, r2
 802419c:	74da      	strb	r2, [r3, #19]
        setup->sm_key_distribution_sent_set |=  SM_KEYDIST_FLAG_SIGNING_IDENTIFICATION;
 802419e:	4b12      	ldr	r3, [pc, #72]	; (80241e8 <sm_run_distribute_keys+0x260>)
 80241a0:	681b      	ldr	r3, [r3, #0]
 80241a2:	7d1a      	ldrb	r2, [r3, #20]
 80241a4:	4b10      	ldr	r3, [pc, #64]	; (80241e8 <sm_run_distribute_keys+0x260>)
 80241a6:	681b      	ldr	r3, [r3, #0]
 80241a8:	f042 0210 	orr.w	r2, r2, #16
 80241ac:	b2d2      	uxtb	r2, r2
 80241ae:	751a      	strb	r2, [r3, #20]
                        le_device_db_local_counter_set(setup->sm_le_device_index, 0);
                    }
#endif

        uint8_t buffer[17];
        buffer[0] = SM_CODE_SIGNING_INFORMATION;
 80241b0:	230a      	movs	r3, #10
 80241b2:	723b      	strb	r3, [r7, #8]
        reverse_128(setup->sm_local_csrk, &buffer[1]);
 80241b4:	4b0c      	ldr	r3, [pc, #48]	; (80241e8 <sm_run_distribute_keys+0x260>)
 80241b6:	681b      	ldr	r3, [r3, #0]
 80241b8:	f503 72d3 	add.w	r2, r3, #422	; 0x1a6
 80241bc:	f107 0308 	add.w	r3, r7, #8
 80241c0:	3301      	adds	r3, #1
 80241c2:	4619      	mov	r1, r3
 80241c4:	4610      	mov	r0, r2
 80241c6:	f7ea ff78 	bl	800f0ba <reverse_128>
        l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 80241ca:	687b      	ldr	r3, [r7, #4]
 80241cc:	8818      	ldrh	r0, [r3, #0]
 80241ce:	f107 0208 	add.w	r2, r7, #8
 80241d2:	2311      	movs	r3, #17
 80241d4:	2106      	movs	r1, #6
 80241d6:	f7f4 fb13 	bl	8018800 <l2cap_send_connectionless>
        sm_timeout_reset(connection);
 80241da:	6878      	ldr	r0, [r7, #4]
 80241dc:	f7fd fade 	bl	802179c <sm_timeout_reset>
        return;
 80241e0:	bf00      	nop
    }
    btstack_assert(false);
}
 80241e2:	3760      	adds	r7, #96	; 0x60
 80241e4:	46bd      	mov	sp, r7
 80241e6:	bd80      	pop	{r7, pc}
 80241e8:	200000a0 	.word	0x200000a0
 80241ec:	20009fa0 	.word	0x20009fa0

080241f0 <sm_run>:

static void sm_run(void){
 80241f0:	b5b0      	push	{r4, r5, r7, lr}
 80241f2:	b0cc      	sub	sp, #304	; 0x130
 80241f4:	af04      	add	r7, sp, #16

    // assert that stack has already bootet
    if (hci_get_state() != HCI_STATE_WORKING) return;
 80241f6:	f7f2 fcad 	bl	8016b54 <hci_get_state>
 80241fa:	4603      	mov	r3, r0
 80241fc:	2b02      	cmp	r3, #2
 80241fe:	f040 87a1 	bne.w	8025144 <sm_run+0xf54>

    // assert that we can send at least commands
    if (!hci_can_send_command_packet_now()) return;
 8024202:	f7eb fe71 	bl	800fee8 <hci_can_send_command_packet_now>
 8024206:	4603      	mov	r3, r0
 8024208:	2b00      	cmp	r3, #0
 802420a:	f000 879d 	beq.w	8025148 <sm_run+0xf58>

    // pause until IR/ER are ready
    if (sm_persistent_keys_random_active) return;
 802420e:	4be3      	ldr	r3, [pc, #908]	; (802459c <sm_run+0x3ac>)
 8024210:	781b      	ldrb	r3, [r3, #0]
 8024212:	2b00      	cmp	r3, #0
 8024214:	f040 879a 	bne.w	802514c <sm_run+0xf5c>

    //
    // non-connection related behaviour
    //

    done = sm_run_dpkg();
 8024218:	f7ff fb4c 	bl	80238b4 <sm_run_dpkg>
 802421c:	4603      	mov	r3, r0
 802421e:	f887 3119 	strb.w	r3, [r7, #281]	; 0x119
    if (done) return;
 8024222:	f897 3119 	ldrb.w	r3, [r7, #281]	; 0x119
 8024226:	2b00      	cmp	r3, #0
 8024228:	f040 8792 	bne.w	8025150 <sm_run+0xf60>

    done = sm_run_rau();
 802422c:	f7ff fbaa 	bl	8023984 <sm_run_rau>
 8024230:	4603      	mov	r3, r0
 8024232:	f887 3119 	strb.w	r3, [r7, #281]	; 0x119
    if (done) return;
 8024236:	f897 3119 	ldrb.w	r3, [r7, #281]	; 0x119
 802423a:	2b00      	cmp	r3, #0
 802423c:	f040 878a 	bne.w	8025154 <sm_run+0xf64>

    done = sm_run_csrk();
 8024240:	f7ff fc04 	bl	8023a4c <sm_run_csrk>
 8024244:	4603      	mov	r3, r0
 8024246:	f887 3119 	strb.w	r3, [r7, #281]	; 0x119
    if (done) return;
 802424a:	f897 3119 	ldrb.w	r3, [r7, #281]	; 0x119
 802424e:	2b00      	cmp	r3, #0
 8024250:	f040 8782 	bne.w	8025158 <sm_run+0xf68>

    done = sm_run_oob();
 8024254:	f7ff fd1c 	bl	8023c90 <sm_run_oob>
 8024258:	4603      	mov	r3, r0
 802425a:	f887 3119 	strb.w	r3, [r7, #281]	; 0x119
    if (done) return;
 802425e:	f897 3119 	ldrb.w	r3, [r7, #281]	; 0x119
 8024262:	2b00      	cmp	r3, #0
 8024264:	f040 877a 	bne.w	802515c <sm_run+0xf6c>

    // assert that we can send at least commands - cmd might have been sent by crypto engine
    if (!hci_can_send_command_packet_now()) return;
 8024268:	f7eb fe3e 	bl	800fee8 <hci_can_send_command_packet_now>
 802426c:	4603      	mov	r3, r0
 802426e:	2b00      	cmp	r3, #0
 8024270:	f000 8776 	beq.w	8025160 <sm_run+0xf70>

    // handle basic actions that don't requires the full context
    done = sm_run_basic();
 8024274:	f7ff fd32 	bl	8023cdc <sm_run_basic>
 8024278:	4603      	mov	r3, r0
 802427a:	f887 3119 	strb.w	r3, [r7, #281]	; 0x119
    if (done) return;
 802427e:	f897 3119 	ldrb.w	r3, [r7, #281]	; 0x119
 8024282:	2b00      	cmp	r3, #0
 8024284:	f040 876e 	bne.w	8025164 <sm_run+0xf74>
    // active connection handling
    // -- use loop to handle next connection if lock on setup context is released

    while (true) {

        sm_run_activate_connection();
 8024288:	f7ff fd76 	bl	8023d78 <sm_run_activate_connection>

        if (sm_active_connection_handle == HCI_CON_HANDLE_INVALID) return;
 802428c:	4bc4      	ldr	r3, [pc, #784]	; (80245a0 <sm_run+0x3b0>)
 802428e:	881b      	ldrh	r3, [r3, #0]
 8024290:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8024294:	4293      	cmp	r3, r2
 8024296:	f000 8767 	beq.w	8025168 <sm_run+0xf78>

        //
        // active connection handling
        //

        sm_connection_t * connection = sm_get_connection_for_handle(sm_active_connection_handle);
 802429a:	4bc1      	ldr	r3, [pc, #772]	; (80245a0 <sm_run+0x3b0>)
 802429c:	881b      	ldrh	r3, [r3, #0]
 802429e:	4618      	mov	r0, r3
 80242a0:	f002 ff66 	bl	8027170 <sm_get_connection_for_handle>
 80242a4:	f8c7 0114 	str.w	r0, [r7, #276]	; 0x114
        if (!connection) {
 80242a8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80242ac:	2b00      	cmp	r3, #0
 80242ae:	d10b      	bne.n	80242c8 <sm_run+0xd8>
            log_info("no connection for handle 0x%04x", sm_active_connection_handle);
 80242b0:	4bbb      	ldr	r3, [pc, #748]	; (80245a0 <sm_run+0x3b0>)
 80242b2:	881b      	ldrh	r3, [r3, #0]
 80242b4:	9300      	str	r3, [sp, #0]
 80242b6:	f640 138c 	movw	r3, #2444	; 0x98c
 80242ba:	4aba      	ldr	r2, [pc, #744]	; (80245a4 <sm_run+0x3b4>)
 80242bc:	49ba      	ldr	r1, [pc, #744]	; (80245a8 <sm_run+0x3b8>)
 80242be:	2001      	movs	r0, #1
 80242c0:	f7f3 f8be 	bl	8017440 <hci_dump_log>
            return;
 80242c4:	f000 bf55 	b.w	8025172 <sm_run+0xf82>
        }

        // assert that we could send a SM PDU - not needed for all of the following
        if (!l2cap_can_send_fixed_channel_packet_now(sm_active_connection_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL)) {
 80242c8:	4bb5      	ldr	r3, [pc, #724]	; (80245a0 <sm_run+0x3b0>)
 80242ca:	881b      	ldrh	r3, [r3, #0]
 80242cc:	2106      	movs	r1, #6
 80242ce:	4618      	mov	r0, r3
 80242d0:	f7f4 f9f6 	bl	80186c0 <l2cap_can_send_fixed_channel_packet_now>
 80242d4:	4603      	mov	r3, r0
 80242d6:	2b00      	cmp	r3, #0
 80242d8:	d10e      	bne.n	80242f8 <sm_run+0x108>
            log_info("cannot send now, requesting can send now event");
 80242da:	f640 1392 	movw	r3, #2450	; 0x992
 80242de:	4ab1      	ldr	r2, [pc, #708]	; (80245a4 <sm_run+0x3b4>)
 80242e0:	49b2      	ldr	r1, [pc, #712]	; (80245ac <sm_run+0x3bc>)
 80242e2:	2001      	movs	r0, #1
 80242e4:	f7f3 f8ac 	bl	8017440 <hci_dump_log>
            l2cap_request_can_send_fix_channel_now_event(sm_active_connection_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL);
 80242e8:	4bad      	ldr	r3, [pc, #692]	; (80245a0 <sm_run+0x3b0>)
 80242ea:	881b      	ldrh	r3, [r3, #0]
 80242ec:	2106      	movs	r1, #6
 80242ee:	4618      	mov	r0, r3
 80242f0:	f7f4 f9cc 	bl	801868c <l2cap_request_can_send_fix_channel_now_event>
            return;
 80242f4:	f000 bf3d 	b.w	8025172 <sm_run+0xf82>
        }

        // send keypress notifications
        if (setup->sm_keypress_notification){
 80242f8:	4bad      	ldr	r3, [pc, #692]	; (80245b0 <sm_run+0x3c0>)
 80242fa:	681b      	ldr	r3, [r3, #0]
 80242fc:	7c9b      	ldrb	r3, [r3, #18]
 80242fe:	2b00      	cmp	r3, #0
 8024300:	d005      	beq.n	802430e <sm_run+0x11e>
            sm_run_send_keypress_notification(connection);
 8024302:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024306:	f7ff fdd5 	bl	8023eb4 <sm_run_send_keypress_notification>
            return;
 802430a:	f000 bf32 	b.w	8025172 <sm_run+0xf82>
		int err;
		UNUSED(err);
        bool have_ltk;
        uint8_t ltk[16];

        log_info("sm_run: state %u", connection->sm_engine_state);
 802430e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024312:	7b1b      	ldrb	r3, [r3, #12]
 8024314:	9300      	str	r3, [sp, #0]
 8024316:	f640 13a4 	movw	r3, #2468	; 0x9a4
 802431a:	4aa2      	ldr	r2, [pc, #648]	; (80245a4 <sm_run+0x3b4>)
 802431c:	49a5      	ldr	r1, [pc, #660]	; (80245b4 <sm_run+0x3c4>)
 802431e:	2001      	movs	r0, #1
 8024320:	f7f3 f88e 	bl	8017440 <hci_dump_log>
        if (!l2cap_can_send_fixed_channel_packet_now(sm_active_connection_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL)) {
 8024324:	4b9e      	ldr	r3, [pc, #632]	; (80245a0 <sm_run+0x3b0>)
 8024326:	881b      	ldrh	r3, [r3, #0]
 8024328:	2106      	movs	r1, #6
 802432a:	4618      	mov	r0, r3
 802432c:	f7f4 f9c8 	bl	80186c0 <l2cap_can_send_fixed_channel_packet_now>
 8024330:	4603      	mov	r3, r0
 8024332:	2b00      	cmp	r3, #0
 8024334:	d106      	bne.n	8024344 <sm_run+0x154>
            log_info("sm_run // cannot send");
 8024336:	f640 13a6 	movw	r3, #2470	; 0x9a6
 802433a:	4a9a      	ldr	r2, [pc, #616]	; (80245a4 <sm_run+0x3b4>)
 802433c:	499e      	ldr	r1, [pc, #632]	; (80245b8 <sm_run+0x3c8>)
 802433e:	2001      	movs	r0, #1
 8024340:	f7f3 f87e 	bl	8017440 <hci_dump_log>
        }
        switch (connection->sm_engine_state){
 8024344:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024348:	7b1b      	ldrb	r3, [r3, #12]
 802434a:	3b01      	subs	r3, #1
 802434c:	2b49      	cmp	r3, #73	; 0x49
 802434e:	f200 86d4 	bhi.w	80250fa <sm_run+0xf0a>
 8024352:	a201      	add	r2, pc, #4	; (adr r2, 8024358 <sm_run+0x168>)
 8024354:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8024358:	08024481 	.word	0x08024481
 802435c:	080250fb 	.word	0x080250fb
 8024360:	080250fb 	.word	0x080250fb
 8024364:	080250fb 	.word	0x080250fb
 8024368:	080250fb 	.word	0x080250fb
 802436c:	080250fb 	.word	0x080250fb
 8024370:	080250fb 	.word	0x080250fb
 8024374:	080250fb 	.word	0x080250fb
 8024378:	080250fb 	.word	0x080250fb
 802437c:	080250fb 	.word	0x080250fb
 8024380:	08024d4f 	.word	0x08024d4f
 8024384:	080250fb 	.word	0x080250fb
 8024388:	08024dbd 	.word	0x08024dbd
 802438c:	080250fb 	.word	0x080250fb
 8024390:	08024ef1 	.word	0x08024ef1
 8024394:	08024cf9 	.word	0x08024cf9
 8024398:	08024e2b 	.word	0x08024e2b
 802439c:	080250fb 	.word	0x080250fb
 80243a0:	080250fb 	.word	0x080250fb
 80243a4:	08024ea3 	.word	0x08024ea3
 80243a8:	080250fb 	.word	0x080250fb
 80243ac:	080250fb 	.word	0x080250fb
 80243b0:	08025091 	.word	0x08025091
 80243b4:	080250fb 	.word	0x080250fb
 80243b8:	080250fb 	.word	0x080250fb
 80243bc:	080250fb 	.word	0x080250fb
 80243c0:	080249f5 	.word	0x080249f5
 80243c4:	08024fdd 	.word	0x08024fdd
 80243c8:	080250fb 	.word	0x080250fb
 80243cc:	080250fb 	.word	0x080250fb
 80243d0:	080250fb 	.word	0x080250fb
 80243d4:	08024ad1 	.word	0x08024ad1
 80243d8:	080250fb 	.word	0x080250fb
 80243dc:	08024bd7 	.word	0x08024bd7
 80243e0:	080250fb 	.word	0x080250fb
 80243e4:	080250fb 	.word	0x080250fb
 80243e8:	080250fb 	.word	0x080250fb
 80243ec:	08024f47 	.word	0x08024f47
 80243f0:	080250fb 	.word	0x080250fb
 80243f4:	08024f79 	.word	0x08024f79
 80243f8:	080250fb 	.word	0x080250fb
 80243fc:	0802469b 	.word	0x0802469b
 8024400:	080250fb 	.word	0x080250fb
 8024404:	080250fb 	.word	0x080250fb
 8024408:	080250fb 	.word	0x080250fb
 802440c:	08025057 	.word	0x08025057
 8024410:	080245fd 	.word	0x080245fd
 8024414:	08024a29 	.word	0x08024a29
 8024418:	080246ef 	.word	0x080246ef
 802441c:	080250fb 	.word	0x080250fb
 8024420:	080250fb 	.word	0x080250fb
 8024424:	080244dd 	.word	0x080244dd
 8024428:	080250fb 	.word	0x080250fb
 802442c:	0802481f 	.word	0x0802481f
 8024430:	080244fd 	.word	0x080244fd
 8024434:	080250fb 	.word	0x080250fb
 8024438:	080250fb 	.word	0x080250fb
 802443c:	08024877 	.word	0x08024877
 8024440:	080250fb 	.word	0x080250fb
 8024444:	080245dd 	.word	0x080245dd
 8024448:	080250fb 	.word	0x080250fb
 802444c:	080250fb 	.word	0x080250fb
 8024450:	0802455d 	.word	0x0802455d
 8024454:	080250fb 	.word	0x080250fb
 8024458:	0802457d 	.word	0x0802457d
 802445c:	080250fb 	.word	0x080250fb
 8024460:	080245bd 	.word	0x080245bd
 8024464:	080250fb 	.word	0x080250fb
 8024468:	0802451d 	.word	0x0802451d
 802446c:	080250fb 	.word	0x080250fb
 8024470:	0802453d 	.word	0x0802453d
 8024474:	080250fb 	.word	0x080250fb
 8024478:	080250fb 	.word	0x080250fb
 802447c:	0802499f 	.word	0x0802499f

            // general
            case SM_GENERAL_SEND_PAIRING_FAILED: {
                uint8_t buffer[2];
                buffer[0] = SM_CODE_PAIRING_FAILED;
 8024480:	2305      	movs	r3, #5
 8024482:	f887 30f0 	strb.w	r3, [r7, #240]	; 0xf0
                buffer[1] = setup->sm_pairing_failed_reason;
 8024486:	4b4a      	ldr	r3, [pc, #296]	; (80245b0 <sm_run+0x3c0>)
 8024488:	681b      	ldr	r3, [r3, #0]
 802448a:	7c1b      	ldrb	r3, [r3, #16]
 802448c:	f887 30f1 	strb.w	r3, [r7, #241]	; 0xf1
                connection->sm_engine_state = connection->sm_role ? SM_RESPONDER_IDLE : SM_INITIATOR_CONNECTED;
 8024490:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024494:	789b      	ldrb	r3, [r3, #2]
 8024496:	2b00      	cmp	r3, #0
 8024498:	d001      	beq.n	802449e <sm_run+0x2ae>
 802449a:	221a      	movs	r2, #26
 802449c:	e000      	b.n	80244a0 <sm_run+0x2b0>
 802449e:	2229      	movs	r2, #41	; 0x29
 80244a0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80244a4:	731a      	strb	r2, [r3, #12]
                l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 80244a6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80244aa:	8818      	ldrh	r0, [r3, #0]
 80244ac:	f107 02f0 	add.w	r2, r7, #240	; 0xf0
 80244b0:	2302      	movs	r3, #2
 80244b2:	2106      	movs	r1, #6
 80244b4:	f7f4 f9a4 	bl	8018800 <l2cap_send_connectionless>
                sm_pairing_complete(connection, ERROR_CODE_AUTHENTICATION_FAILURE, setup->sm_pairing_failed_reason);
 80244b8:	4b3d      	ldr	r3, [pc, #244]	; (80245b0 <sm_run+0x3c0>)
 80244ba:	681b      	ldr	r3, [r3, #0]
 80244bc:	7c1b      	ldrb	r3, [r3, #16]
 80244be:	461a      	mov	r2, r3
 80244c0:	2105      	movs	r1, #5
 80244c2:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80244c6:	f7fd f8d3 	bl	8021670 <sm_pairing_complete>
                sm_done_for_handle(connection->sm_handle);
 80244ca:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80244ce:	881b      	ldrh	r3, [r3, #0]
 80244d0:	4618      	mov	r0, r3
 80244d2:	f7fd fd8f 	bl	8021ff4 <sm_done_for_handle>
                break;
 80244d6:	bf00      	nop
 80244d8:	f000 be2c 	b.w	8025134 <sm_run+0xf44>
            }

            // secure connections, initiator + responding states
#ifdef ENABLE_LE_SECURE_CONNECTIONS
            case SM_SC_W2_CMAC_FOR_CONFIRMATION:
                if (!sm_cmac_ready()) break;
 80244dc:	f7fd fc66 	bl	8021dac <sm_cmac_ready>
 80244e0:	4603      	mov	r3, r0
 80244e2:	2b00      	cmp	r3, #0
 80244e4:	f000 860b 	beq.w	80250fe <sm_run+0xf0e>
                connection->sm_engine_state = SM_SC_W4_CMAC_FOR_CONFIRMATION;
 80244e8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80244ec:	2235      	movs	r2, #53	; 0x35
 80244ee:	731a      	strb	r2, [r3, #12]
                sm_sc_calculate_local_confirm(connection);
 80244f0:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80244f4:	f7fe fef2 	bl	80232dc <sm_sc_calculate_local_confirm>
                break;
 80244f8:	f000 be1c 	b.w	8025134 <sm_run+0xf44>
            case SM_SC_W2_CMAC_FOR_CHECK_CONFIRMATION:
                if (!sm_cmac_ready()) break;
 80244fc:	f7fd fc56 	bl	8021dac <sm_cmac_ready>
 8024500:	4603      	mov	r3, r0
 8024502:	2b00      	cmp	r3, #0
 8024504:	f000 85fd 	beq.w	8025102 <sm_run+0xf12>
                connection->sm_engine_state = SM_SC_W4_CMAC_FOR_CHECK_CONFIRMATION;
 8024508:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802450c:	2238      	movs	r2, #56	; 0x38
 802450e:	731a      	strb	r2, [r3, #12]
                sm_sc_calculate_remote_confirm(connection);
 8024510:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024514:	f7fe ff26 	bl	8023364 <sm_sc_calculate_remote_confirm>
                break;
 8024518:	f000 be0c 	b.w	8025134 <sm_run+0xf44>
            case SM_SC_W2_CALCULATE_F6_FOR_DHKEY_CHECK:
                if (!sm_cmac_ready()) break;
 802451c:	f7fd fc46 	bl	8021dac <sm_cmac_ready>
 8024520:	4603      	mov	r3, r0
 8024522:	2b00      	cmp	r3, #0
 8024524:	f000 85ef 	beq.w	8025106 <sm_run+0xf16>
                connection->sm_engine_state = SM_SC_W4_CALCULATE_F6_FOR_DHKEY_CHECK;
 8024528:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802452c:	2246      	movs	r2, #70	; 0x46
 802452e:	731a      	strb	r2, [r3, #12]
                sm_sc_calculate_f6_for_dhkey_check(connection);
 8024530:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024534:	f7fe ffea 	bl	802350c <sm_sc_calculate_f6_for_dhkey_check>
                break;
 8024538:	f000 bdfc 	b.w	8025134 <sm_run+0xf44>
            case SM_SC_W2_CALCULATE_F6_TO_VERIFY_DHKEY_CHECK:
                if (!sm_cmac_ready()) break;
 802453c:	f7fd fc36 	bl	8021dac <sm_cmac_ready>
 8024540:	4603      	mov	r3, r0
 8024542:	2b00      	cmp	r3, #0
 8024544:	f000 85e1 	beq.w	802510a <sm_run+0xf1a>
                connection->sm_engine_state = SM_SC_W4_CALCULATE_F6_TO_VERIFY_DHKEY_CHECK;
 8024548:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802454c:	2248      	movs	r2, #72	; 0x48
 802454e:	731a      	strb	r2, [r3, #12]
                sm_sc_calculate_f6_to_verify_dhkey_check(connection);
 8024550:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024554:	f7ff f878 	bl	8023648 <sm_sc_calculate_f6_to_verify_dhkey_check>
                break;
 8024558:	f000 bdec 	b.w	8025134 <sm_run+0xf44>
            case SM_SC_W2_CALCULATE_F5_SALT:
                if (!sm_cmac_ready()) break;
 802455c:	f7fd fc26 	bl	8021dac <sm_cmac_ready>
 8024560:	4603      	mov	r3, r0
 8024562:	2b00      	cmp	r3, #0
 8024564:	f000 85d3 	beq.w	802510e <sm_run+0xf1e>
                connection->sm_engine_state = SM_SC_W4_CALCULATE_F5_SALT;
 8024568:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802456c:	2240      	movs	r2, #64	; 0x40
 802456e:	731a      	strb	r2, [r3, #12]
                f5_calculate_salt(connection);
 8024570:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024574:	f7fe fc78 	bl	8022e68 <f5_calculate_salt>
                break;
 8024578:	f000 bddc 	b.w	8025134 <sm_run+0xf44>
            case SM_SC_W2_CALCULATE_F5_MACKEY:
                if (!sm_cmac_ready()) break;
 802457c:	f7fd fc16 	bl	8021dac <sm_cmac_ready>
 8024580:	4603      	mov	r3, r0
 8024582:	2b00      	cmp	r3, #0
 8024584:	f000 85c5 	beq.w	8025112 <sm_run+0xf22>
                connection->sm_engine_state = SM_SC_W4_CALCULATE_F5_MACKEY;
 8024588:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802458c:	2242      	movs	r2, #66	; 0x42
 802458e:	731a      	strb	r2, [r3, #12]
                f5_calculate_mackey(connection);
 8024590:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024594:	f7fe fd06 	bl	8022fa4 <f5_calculate_mackey>
                break;
 8024598:	f000 bdcc 	b.w	8025134 <sm_run+0xf44>
 802459c:	20009f65 	.word	0x20009f65
 80245a0:	200000a4 	.word	0x200000a4
 80245a4:	0802d4a8 	.word	0x0802d4a8
 80245a8:	0802dd14 	.word	0x0802dd14
 80245ac:	0802dd3c 	.word	0x0802dd3c
 80245b0:	200000a0 	.word	0x200000a0
 80245b4:	0802dd74 	.word	0x0802dd74
 80245b8:	0802dd8c 	.word	0x0802dd8c
            case SM_SC_W2_CALCULATE_F5_LTK:
                if (!sm_cmac_ready()) break;
 80245bc:	f7fd fbf6 	bl	8021dac <sm_cmac_ready>
 80245c0:	4603      	mov	r3, r0
 80245c2:	2b00      	cmp	r3, #0
 80245c4:	f000 85a7 	beq.w	8025116 <sm_run+0xf26>
                connection->sm_engine_state = SM_SC_W4_CALCULATE_F5_LTK;
 80245c8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80245cc:	2244      	movs	r2, #68	; 0x44
 80245ce:	731a      	strb	r2, [r3, #12]
                f5_calculate_ltk(connection);
 80245d0:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80245d4:	f7fe fd7c 	bl	80230d0 <f5_calculate_ltk>
                break;
 80245d8:	f000 bdac 	b.w	8025134 <sm_run+0xf44>
            case SM_SC_W2_CALCULATE_G2:
                if (!sm_cmac_ready()) break;
 80245dc:	f7fd fbe6 	bl	8021dac <sm_cmac_ready>
 80245e0:	4603      	mov	r3, r0
 80245e2:	2b00      	cmp	r3, #0
 80245e4:	f000 8599 	beq.w	802511a <sm_run+0xf2a>
                connection->sm_engine_state = SM_SC_W4_CALCULATE_G2;
 80245e8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80245ec:	223d      	movs	r2, #61	; 0x3d
 80245ee:	731a      	strb	r2, [r3, #12]
                g2_calculate(connection);
 80245f0:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80245f4:	f7fe fe3e 	bl	8023274 <g2_calculate>
                break;
 80245f8:	f000 bd9c 	b.w	8025134 <sm_run+0xf44>

#ifdef ENABLE_LE_CENTRAL
            // initiator side

            case SM_INITIATOR_PH4_HAS_LTK: {
				sm_reset_setup();
 80245fc:	f7fd fd56 	bl	80220ac <sm_reset_setup>
				sm_load_security_info(connection);
 8024600:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024604:	f7ff f8be 	bl	8023784 <sm_load_security_info>
                sm_reencryption_started(connection);
 8024608:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 802460c:	f7fc ff91 	bl	8021532 <sm_reencryption_started>

                sm_key_t peer_ltk_flipped;
                reverse_128(setup->sm_peer_ltk, peer_ltk_flipped);
 8024610:	4bc9      	ldr	r3, [pc, #804]	; (8024938 <sm_run+0x748>)
 8024612:	681b      	ldr	r3, [r3, #0]
 8024614:	f503 73ea 	add.w	r3, r3, #468	; 0x1d4
 8024618:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 802461c:	4611      	mov	r1, r2
 802461e:	4618      	mov	r0, r3
 8024620:	f7ea fd4b 	bl	800f0ba <reverse_128>
                connection->sm_engine_state = SM_PH4_W4_CONNECTION_ENCRYPTED;
 8024624:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024628:	2219      	movs	r2, #25
 802462a:	731a      	strb	r2, [r3, #12]
                log_info("sm: hci_le_start_encryption ediv 0x%04x", setup->sm_peer_ediv);
 802462c:	4bc2      	ldr	r3, [pc, #776]	; (8024938 <sm_run+0x748>)
 802462e:	681b      	ldr	r3, [r3, #0]
 8024630:	f8b3 31ca 	ldrh.w	r3, [r3, #458]	; 0x1ca
 8024634:	9300      	str	r3, [sp, #0]
 8024636:	f640 13fe 	movw	r3, #2558	; 0x9fe
 802463a:	4ac0      	ldr	r2, [pc, #768]	; (802493c <sm_run+0x74c>)
 802463c:	49c0      	ldr	r1, [pc, #768]	; (8024940 <sm_run+0x750>)
 802463e:	2001      	movs	r0, #1
 8024640:	f7f2 fefe 	bl	8017440 <hci_dump_log>
                uint32_t rand_high = big_endian_read_32(setup->sm_peer_rand, 0);
 8024644:	4bbc      	ldr	r3, [pc, #752]	; (8024938 <sm_run+0x748>)
 8024646:	681b      	ldr	r3, [r3, #0]
 8024648:	f503 73e6 	add.w	r3, r3, #460	; 0x1cc
 802464c:	2100      	movs	r1, #0
 802464e:	4618      	mov	r0, r3
 8024650:	f7ea fc79 	bl	800ef46 <big_endian_read_32>
 8024654:	f8c7 0110 	str.w	r0, [r7, #272]	; 0x110
                uint32_t rand_low  = big_endian_read_32(setup->sm_peer_rand, 4);
 8024658:	4bb7      	ldr	r3, [pc, #732]	; (8024938 <sm_run+0x748>)
 802465a:	681b      	ldr	r3, [r3, #0]
 802465c:	f503 73e6 	add.w	r3, r3, #460	; 0x1cc
 8024660:	2104      	movs	r1, #4
 8024662:	4618      	mov	r0, r3
 8024664:	f7ea fc6f 	bl	800ef46 <big_endian_read_32>
 8024668:	f8c7 010c 	str.w	r0, [r7, #268]	; 0x10c
                hci_send_cmd(&hci_le_start_encryption, connection->sm_handle,rand_low, rand_high, setup->sm_peer_ediv, peer_ltk_flipped);
 802466c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024670:	881b      	ldrh	r3, [r3, #0]
 8024672:	4619      	mov	r1, r3
 8024674:	4bb0      	ldr	r3, [pc, #704]	; (8024938 <sm_run+0x748>)
 8024676:	681b      	ldr	r3, [r3, #0]
 8024678:	f8b3 31ca 	ldrh.w	r3, [r3, #458]	; 0x1ca
 802467c:	461a      	mov	r2, r3
 802467e:	f107 03e0 	add.w	r3, r7, #224	; 0xe0
 8024682:	9301      	str	r3, [sp, #4]
 8024684:	9200      	str	r2, [sp, #0]
 8024686:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 802468a:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 802468e:	48ad      	ldr	r0, [pc, #692]	; (8024944 <sm_run+0x754>)
 8024690:	f7f1 fca6 	bl	8015fe0 <hci_send_cmd>
                return;
 8024694:	bf00      	nop
 8024696:	f000 bd6c 	b.w	8025172 <sm_run+0xf82>
            }

			case SM_INITIATOR_PH1_W2_SEND_PAIRING_REQUEST:
				sm_reset_setup();
 802469a:	f7fd fd07 	bl	80220ac <sm_reset_setup>
				sm_init_setup(connection);
 802469e:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80246a2:	f7fd fd15 	bl	80220d0 <sm_init_setup>
				sm_timeout_start(connection);
 80246a6:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80246aa:	f7fd f841 	bl	8021730 <sm_timeout_start>
				sm_pairing_started(connection);
 80246ae:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80246b2:	f7fc ffaf 	bl	8021614 <sm_pairing_started>

                sm_pairing_packet_set_code(setup->sm_m_preq, SM_CODE_PAIRING_REQUEST);
 80246b6:	4ba0      	ldr	r3, [pc, #640]	; (8024938 <sm_run+0x748>)
 80246b8:	681b      	ldr	r3, [r3, #0]
 80246ba:	3339      	adds	r3, #57	; 0x39
 80246bc:	2101      	movs	r1, #1
 80246be:	4618      	mov	r0, r3
 80246c0:	f7fc fcc4 	bl	802104c <sm_pairing_packet_set_code>
                connection->sm_engine_state = SM_INITIATOR_PH1_W4_PAIRING_RESPONSE;
 80246c4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80246c8:	222b      	movs	r2, #43	; 0x2b
 80246ca:	731a      	strb	r2, [r3, #12]
                l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) &setup->sm_m_preq, sizeof(sm_pairing_packet_t));
 80246cc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80246d0:	8818      	ldrh	r0, [r3, #0]
 80246d2:	4b99      	ldr	r3, [pc, #612]	; (8024938 <sm_run+0x748>)
 80246d4:	681b      	ldr	r3, [r3, #0]
 80246d6:	f103 0239 	add.w	r2, r3, #57	; 0x39
 80246da:	2307      	movs	r3, #7
 80246dc:	2106      	movs	r1, #6
 80246de:	f7f4 f88f 	bl	8018800 <l2cap_send_connectionless>
                sm_timeout_reset(connection);
 80246e2:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80246e6:	f7fd f859 	bl	802179c <sm_timeout_reset>
                break;
 80246ea:	f000 bd23 	b.w	8025134 <sm_run+0xf44>
#endif

#ifdef ENABLE_LE_SECURE_CONNECTIONS

            case SM_SC_SEND_PUBLIC_KEY_COMMAND: {
                bool trigger_user_response   = false;
 80246ee:	2300      	movs	r3, #0
 80246f0:	f887 311b 	strb.w	r3, [r7, #283]	; 0x11b
                bool trigger_start_calculating_local_confirm = false;
 80246f4:	2300      	movs	r3, #0
 80246f6:	f887 311a 	strb.w	r3, [r7, #282]	; 0x11a
                uint8_t buffer[65];
                buffer[0] = SM_CODE_PAIRING_PUBLIC_KEY;
 80246fa:	1d3b      	adds	r3, r7, #4
 80246fc:	220c      	movs	r2, #12
 80246fe:	701a      	strb	r2, [r3, #0]
                //
                reverse_256(&ec_q[0],  &buffer[1]);
 8024700:	1d3b      	adds	r3, r7, #4
 8024702:	3301      	adds	r3, #1
 8024704:	4619      	mov	r1, r3
 8024706:	4890      	ldr	r0, [pc, #576]	; (8024948 <sm_run+0x758>)
 8024708:	f7ea fce5 	bl	800f0d6 <reverse_256>
                reverse_256(&ec_q[32], &buffer[33]);
 802470c:	1d3b      	adds	r3, r7, #4
 802470e:	3321      	adds	r3, #33	; 0x21
 8024710:	4619      	mov	r1, r3
 8024712:	488e      	ldr	r0, [pc, #568]	; (802494c <sm_run+0x75c>)
 8024714:	f7ea fcdf 	bl	800f0d6 <reverse_256>
                }
#endif

                // stk generation method
                // passkey entry: notify app to show passkey or to request passkey
                switch (setup->sm_stk_generation_method){
 8024718:	4b87      	ldr	r3, [pc, #540]	; (8024938 <sm_run+0x748>)
 802471a:	681b      	ldr	r3, [r3, #0]
 802471c:	7d9b      	ldrb	r3, [r3, #22]
 802471e:	2b05      	cmp	r3, #5
 8024720:	d85c      	bhi.n	80247dc <sm_run+0x5ec>
 8024722:	a201      	add	r2, pc, #4	; (adr r2, 8024728 <sm_run+0x538>)
 8024724:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8024728:	08024741 	.word	0x08024741
 802472c:	08024765 	.word	0x08024765
 8024730:	08024765 	.word	0x08024765
 8024734:	08024765 	.word	0x08024765
 8024738:	08024741 	.word	0x08024741
 802473c:	080247bf 	.word	0x080247bf
                    case JUST_WORKS:
                    case NUMERIC_COMPARISON:
                        if (IS_RESPONDER(connection->sm_role)){
 8024740:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024744:	789b      	ldrb	r3, [r3, #2]
 8024746:	2b00      	cmp	r3, #0
 8024748:	d007      	beq.n	802475a <sm_run+0x56a>
                            // responder
                            trigger_start_calculating_local_confirm = true;
 802474a:	2301      	movs	r3, #1
 802474c:	f887 311a 	strb.w	r3, [r7, #282]	; 0x11a
                            connection->sm_engine_state = SM_SC_W4_LOCAL_NONCE;
 8024750:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024754:	2233      	movs	r2, #51	; 0x33
 8024756:	731a      	strb	r2, [r3, #12]
                        } else {
                            // initiator
                            connection->sm_engine_state = SM_SC_W4_PUBLIC_KEY_COMMAND;
                        }
                        break;
 8024758:	e041      	b.n	80247de <sm_run+0x5ee>
                            connection->sm_engine_state = SM_SC_W4_PUBLIC_KEY_COMMAND;
 802475a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802475e:	2232      	movs	r2, #50	; 0x32
 8024760:	731a      	strb	r2, [r3, #12]
                        break;
 8024762:	e03c      	b.n	80247de <sm_run+0x5ee>
                    case PK_INIT_INPUT:
                    case PK_RESP_INPUT:
                    case PK_BOTH_INPUT:
                        // use random TK for display
                        (void)memcpy(setup->sm_ra, setup->sm_tk, 16);
 8024764:	4b74      	ldr	r3, [pc, #464]	; (8024938 <sm_run+0x748>)
 8024766:	681b      	ldr	r3, [r3, #0]
 8024768:	f503 70a3 	add.w	r0, r3, #326	; 0x146
 802476c:	4b72      	ldr	r3, [pc, #456]	; (8024938 <sm_run+0x748>)
 802476e:	681b      	ldr	r3, [r3, #0]
 8024770:	3317      	adds	r3, #23
 8024772:	2210      	movs	r2, #16
 8024774:	4619      	mov	r1, r3
 8024776:	f003 f980 	bl	8027a7a <memcpy>
                        (void)memcpy(setup->sm_rb, setup->sm_tk, 16);
 802477a:	4b6f      	ldr	r3, [pc, #444]	; (8024938 <sm_run+0x748>)
 802477c:	681b      	ldr	r3, [r3, #0]
 802477e:	f503 70ab 	add.w	r0, r3, #342	; 0x156
 8024782:	4b6d      	ldr	r3, [pc, #436]	; (8024938 <sm_run+0x748>)
 8024784:	681b      	ldr	r3, [r3, #0]
 8024786:	3317      	adds	r3, #23
 8024788:	2210      	movs	r2, #16
 802478a:	4619      	mov	r1, r3
 802478c:	f003 f975 	bl	8027a7a <memcpy>
                        setup->sm_passkey_bit = 0;
 8024790:	4b69      	ldr	r3, [pc, #420]	; (8024938 <sm_run+0x748>)
 8024792:	681b      	ldr	r3, [r3, #0]
 8024794:	2200      	movs	r2, #0
 8024796:	f883 2186 	strb.w	r2, [r3, #390]	; 0x186

                        if (IS_RESPONDER(connection->sm_role)){
 802479a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802479e:	789b      	ldrb	r3, [r3, #2]
 80247a0:	2b00      	cmp	r3, #0
 80247a2:	d004      	beq.n	80247ae <sm_run+0x5be>
                            // responder
                            connection->sm_engine_state = SM_SC_W4_CONFIRMATION;
 80247a4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80247a8:	2239      	movs	r2, #57	; 0x39
 80247aa:	731a      	strb	r2, [r3, #12]
 80247ac:	e003      	b.n	80247b6 <sm_run+0x5c6>
                        } else {
                            // initiator
                            connection->sm_engine_state = SM_SC_W4_PUBLIC_KEY_COMMAND;
 80247ae:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80247b2:	2232      	movs	r2, #50	; 0x32
 80247b4:	731a      	strb	r2, [r3, #12]
                        }
                        trigger_user_response = true;
 80247b6:	2301      	movs	r3, #1
 80247b8:	f887 311b 	strb.w	r3, [r7, #283]	; 0x11b
                        break;
 80247bc:	e00f      	b.n	80247de <sm_run+0x5ee>
                    case OOB:
                        if (IS_RESPONDER(connection->sm_role)){
 80247be:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80247c2:	789b      	ldrb	r3, [r3, #2]
 80247c4:	2b00      	cmp	r3, #0
 80247c6:	d004      	beq.n	80247d2 <sm_run+0x5e2>
                            // responder
                            connection->sm_engine_state = SM_SC_W4_PAIRING_RANDOM;
 80247c8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80247cc:	223b      	movs	r2, #59	; 0x3b
 80247ce:	731a      	strb	r2, [r3, #12]
                        } else {
                            // initiator
                            connection->sm_engine_state = SM_SC_W4_PUBLIC_KEY_COMMAND;
                        }
                        break;
 80247d0:	e005      	b.n	80247de <sm_run+0x5ee>
                            connection->sm_engine_state = SM_SC_W4_PUBLIC_KEY_COMMAND;
 80247d2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80247d6:	2232      	movs	r2, #50	; 0x32
 80247d8:	731a      	strb	r2, [r3, #12]
                        break;
 80247da:	e000      	b.n	80247de <sm_run+0x5ee>
                    default:
                        btstack_assert(false);
                        break;
 80247dc:	bf00      	nop
                }

                l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 80247de:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80247e2:	8818      	ldrh	r0, [r3, #0]
 80247e4:	1d3a      	adds	r2, r7, #4
 80247e6:	2341      	movs	r3, #65	; 0x41
 80247e8:	2106      	movs	r1, #6
 80247ea:	f7f4 f809 	bl	8018800 <l2cap_send_connectionless>
                sm_timeout_reset(connection);
 80247ee:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80247f2:	f7fc ffd3 	bl	802179c <sm_timeout_reset>

                // trigger user response and calc confirm after sending pdu
                if (trigger_user_response){
 80247f6:	f897 311b 	ldrb.w	r3, [r7, #283]	; 0x11b
 80247fa:	2b00      	cmp	r3, #0
 80247fc:	d003      	beq.n	8024806 <sm_run+0x616>
                    sm_trigger_user_response(connection);
 80247fe:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024802:	f7fd fb0b 	bl	8021e1c <sm_trigger_user_response>
                }
                if (trigger_start_calculating_local_confirm){
 8024806:	f897 311a 	ldrb.w	r3, [r7, #282]	; 0x11a
 802480a:	2b00      	cmp	r3, #0
 802480c:	f000 8487 	beq.w	802511e <sm_run+0xf2e>
                    sm_sc_start_calculating_local_confirm(connection);
 8024810:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024814:	f7fe f928 	bl	8022a68 <sm_sc_start_calculating_local_confirm>
                }
                break;
 8024818:	bf00      	nop
 802481a:	f000 bc80 	b.w	802511e <sm_run+0xf2e>
            }
            case SM_SC_SEND_CONFIRMATION: {
                uint8_t buffer[17];
                buffer[0] = SM_CODE_PAIRING_CONFIRM;
 802481e:	2303      	movs	r3, #3
 8024820:	f887 30cc 	strb.w	r3, [r7, #204]	; 0xcc
                reverse_128(setup->sm_local_confirm, &buffer[1]);
 8024824:	4b44      	ldr	r3, [pc, #272]	; (8024938 <sm_run+0x748>)
 8024826:	681b      	ldr	r3, [r3, #0]
 8024828:	f103 0257 	add.w	r2, r3, #87	; 0x57
 802482c:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
 8024830:	3301      	adds	r3, #1
 8024832:	4619      	mov	r1, r3
 8024834:	4610      	mov	r0, r2
 8024836:	f7ea fc40 	bl	800f0ba <reverse_128>
                if (IS_RESPONDER(connection->sm_role)){
 802483a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802483e:	789b      	ldrb	r3, [r3, #2]
 8024840:	2b00      	cmp	r3, #0
 8024842:	d004      	beq.n	802484e <sm_run+0x65e>
                    connection->sm_engine_state = SM_SC_W4_PAIRING_RANDOM;
 8024844:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024848:	223b      	movs	r2, #59	; 0x3b
 802484a:	731a      	strb	r2, [r3, #12]
 802484c:	e003      	b.n	8024856 <sm_run+0x666>
                } else {
                    connection->sm_engine_state = SM_SC_W4_CONFIRMATION;
 802484e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024852:	2239      	movs	r2, #57	; 0x39
 8024854:	731a      	strb	r2, [r3, #12]
                }
                l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 8024856:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802485a:	8818      	ldrh	r0, [r3, #0]
 802485c:	f107 02cc 	add.w	r2, r7, #204	; 0xcc
 8024860:	2311      	movs	r3, #17
 8024862:	2106      	movs	r1, #6
 8024864:	f7f3 ffcc 	bl	8018800 <l2cap_send_connectionless>
                sm_timeout_reset(connection);
 8024868:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 802486c:	f7fc ff96 	bl	802179c <sm_timeout_reset>
                break;
 8024870:	bf00      	nop
 8024872:	f000 bc5f 	b.w	8025134 <sm_run+0xf44>
            }
            case SM_SC_SEND_PAIRING_RANDOM: {
                uint8_t buffer[17];
                buffer[0] = SM_CODE_PAIRING_RANDOM;
 8024876:	2304      	movs	r3, #4
 8024878:	f887 30b8 	strb.w	r3, [r7, #184]	; 0xb8
                reverse_128(setup->sm_local_nonce, &buffer[1]);
 802487c:	4b2e      	ldr	r3, [pc, #184]	; (8024938 <sm_run+0x748>)
 802487e:	681b      	ldr	r3, [r3, #0]
 8024880:	f103 02f6 	add.w	r2, r3, #246	; 0xf6
 8024884:	f107 03b8 	add.w	r3, r7, #184	; 0xb8
 8024888:	3301      	adds	r3, #1
 802488a:	4619      	mov	r1, r3
 802488c:	4610      	mov	r0, r2
 802488e:	f7ea fc14 	bl	800f0ba <reverse_128>
                log_info("stk method %u, num bits %u", setup->sm_stk_generation_method, setup->sm_passkey_bit);
 8024892:	4b29      	ldr	r3, [pc, #164]	; (8024938 <sm_run+0x748>)
 8024894:	681b      	ldr	r3, [r3, #0]
 8024896:	7d9b      	ldrb	r3, [r3, #22]
 8024898:	461a      	mov	r2, r3
 802489a:	4b27      	ldr	r3, [pc, #156]	; (8024938 <sm_run+0x748>)
 802489c:	681b      	ldr	r3, [r3, #0]
 802489e:	f893 3186 	ldrb.w	r3, [r3, #390]	; 0x186
 80248a2:	9301      	str	r3, [sp, #4]
 80248a4:	9200      	str	r2, [sp, #0]
 80248a6:	f640 236f 	movw	r3, #2671	; 0xa6f
 80248aa:	4a24      	ldr	r2, [pc, #144]	; (802493c <sm_run+0x74c>)
 80248ac:	4928      	ldr	r1, [pc, #160]	; (8024950 <sm_run+0x760>)
 80248ae:	2001      	movs	r0, #1
 80248b0:	f7f2 fdc6 	bl	8017440 <hci_dump_log>
                if (sm_passkey_entry(setup->sm_stk_generation_method) && (setup->sm_passkey_bit < 20u)){
 80248b4:	4b20      	ldr	r3, [pc, #128]	; (8024938 <sm_run+0x748>)
 80248b6:	681b      	ldr	r3, [r3, #0]
 80248b8:	7d9b      	ldrb	r3, [r3, #22]
 80248ba:	4618      	mov	r0, r3
 80248bc:	f001 fd88 	bl	80263d0 <sm_passkey_entry>
 80248c0:	4603      	mov	r3, r0
 80248c2:	2b00      	cmp	r3, #0
 80248c4:	d01b      	beq.n	80248fe <sm_run+0x70e>
 80248c6:	4b1c      	ldr	r3, [pc, #112]	; (8024938 <sm_run+0x748>)
 80248c8:	681b      	ldr	r3, [r3, #0]
 80248ca:	f893 3186 	ldrb.w	r3, [r3, #390]	; 0x186
 80248ce:	2b13      	cmp	r3, #19
 80248d0:	d815      	bhi.n	80248fe <sm_run+0x70e>
                    log_info("SM_SC_SEND_PAIRING_RANDOM A");
 80248d2:	f640 2371 	movw	r3, #2673	; 0xa71
 80248d6:	4a19      	ldr	r2, [pc, #100]	; (802493c <sm_run+0x74c>)
 80248d8:	491e      	ldr	r1, [pc, #120]	; (8024954 <sm_run+0x764>)
 80248da:	2001      	movs	r0, #1
 80248dc:	f7f2 fdb0 	bl	8017440 <hci_dump_log>
                    if (IS_RESPONDER(connection->sm_role)){
 80248e0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80248e4:	789b      	ldrb	r3, [r3, #2]
 80248e6:	2b00      	cmp	r3, #0
 80248e8:	d004      	beq.n	80248f4 <sm_run+0x704>
                        // responder
                        connection->sm_engine_state = SM_SC_W4_CONFIRMATION;
 80248ea:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80248ee:	2239      	movs	r2, #57	; 0x39
 80248f0:	731a      	strb	r2, [r3, #12]
                    if (IS_RESPONDER(connection->sm_role)){
 80248f2:	e045      	b.n	8024980 <sm_run+0x790>
                    } else {
                        // initiator
                        connection->sm_engine_state = SM_SC_W4_PAIRING_RANDOM;
 80248f4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80248f8:	223b      	movs	r2, #59	; 0x3b
 80248fa:	731a      	strb	r2, [r3, #12]
                    if (IS_RESPONDER(connection->sm_role)){
 80248fc:	e040      	b.n	8024980 <sm_run+0x790>
                    }
                } else {
                    log_info("SM_SC_SEND_PAIRING_RANDOM B");
 80248fe:	f640 237a 	movw	r3, #2682	; 0xa7a
 8024902:	4a0e      	ldr	r2, [pc, #56]	; (802493c <sm_run+0x74c>)
 8024904:	4914      	ldr	r1, [pc, #80]	; (8024958 <sm_run+0x768>)
 8024906:	2001      	movs	r0, #1
 8024908:	f7f2 fd9a 	bl	8017440 <hci_dump_log>
                    if (IS_RESPONDER(connection->sm_role)){
 802490c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024910:	789b      	ldrb	r3, [r3, #2]
 8024912:	2b00      	cmp	r3, #0
 8024914:	d030      	beq.n	8024978 <sm_run+0x788>
                        // responder
                        if (setup->sm_stk_generation_method == NUMERIC_COMPARISON){
 8024916:	4b08      	ldr	r3, [pc, #32]	; (8024938 <sm_run+0x748>)
 8024918:	681b      	ldr	r3, [r3, #0]
 802491a:	7d9b      	ldrb	r3, [r3, #22]
 802491c:	2b04      	cmp	r3, #4
 802491e:	d11f      	bne.n	8024960 <sm_run+0x770>
                            log_info("SM_SC_SEND_PAIRING_RANDOM B1");
 8024920:	f640 237e 	movw	r3, #2686	; 0xa7e
 8024924:	4a05      	ldr	r2, [pc, #20]	; (802493c <sm_run+0x74c>)
 8024926:	490d      	ldr	r1, [pc, #52]	; (802495c <sm_run+0x76c>)
 8024928:	2001      	movs	r0, #1
 802492a:	f7f2 fd89 	bl	8017440 <hci_dump_log>
                            connection->sm_engine_state = SM_SC_W2_CALCULATE_G2;
 802492e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024932:	223c      	movs	r2, #60	; 0x3c
 8024934:	731a      	strb	r2, [r3, #12]
 8024936:	e023      	b.n	8024980 <sm_run+0x790>
 8024938:	200000a0 	.word	0x200000a0
 802493c:	0802d4a8 	.word	0x0802d4a8
 8024940:	0802ddac 	.word	0x0802ddac
 8024944:	08030c00 	.word	0x08030c00
 8024948:	2000a110 	.word	0x2000a110
 802494c:	2000a130 	.word	0x2000a130
 8024950:	0802dddc 	.word	0x0802dddc
 8024954:	0802de00 	.word	0x0802de00
 8024958:	0802de24 	.word	0x0802de24
 802495c:	0802de48 	.word	0x0802de48
                        } else {
                            log_info("SM_SC_SEND_PAIRING_RANDOM B2");
 8024960:	f640 2381 	movw	r3, #2689	; 0xa81
 8024964:	4ac8      	ldr	r2, [pc, #800]	; (8024c88 <sm_run+0xa98>)
 8024966:	49c9      	ldr	r1, [pc, #804]	; (8024c8c <sm_run+0xa9c>)
 8024968:	2001      	movs	r0, #1
 802496a:	f7f2 fd69 	bl	8017440 <hci_dump_log>
                            sm_sc_prepare_dhkey_check(connection);
 802496e:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024972:	f7fe fd63 	bl	802343c <sm_sc_prepare_dhkey_check>
 8024976:	e003      	b.n	8024980 <sm_run+0x790>
                        }
                    } else {
                        // initiator
                        connection->sm_engine_state = SM_SC_W4_PAIRING_RANDOM;
 8024978:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802497c:	223b      	movs	r2, #59	; 0x3b
 802497e:	731a      	strb	r2, [r3, #12]
                    }
                }
                l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 8024980:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024984:	8818      	ldrh	r0, [r3, #0]
 8024986:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 802498a:	2311      	movs	r3, #17
 802498c:	2106      	movs	r1, #6
 802498e:	f7f3 ff37 	bl	8018800 <l2cap_send_connectionless>
                sm_timeout_reset(connection);
 8024992:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024996:	f7fc ff01 	bl	802179c <sm_timeout_reset>
                break;
 802499a:	bf00      	nop
 802499c:	e3ca      	b.n	8025134 <sm_run+0xf44>
            }
            case SM_SC_SEND_DHKEY_CHECK_COMMAND: {
                uint8_t buffer[17];
                buffer[0] = SM_CODE_PAIRING_DHKEY_CHECK;
 802499e:	230d      	movs	r3, #13
 80249a0:	f887 30a4 	strb.w	r3, [r7, #164]	; 0xa4
                reverse_128(setup->sm_local_dhkey_check, &buffer[1]);
 80249a4:	4bba      	ldr	r3, [pc, #744]	; (8024c90 <sm_run+0xaa0>)
 80249a6:	681b      	ldr	r3, [r3, #0]
 80249a8:	f503 729b 	add.w	r2, r3, #310	; 0x136
 80249ac:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
 80249b0:	3301      	adds	r3, #1
 80249b2:	4619      	mov	r1, r3
 80249b4:	4610      	mov	r0, r2
 80249b6:	f7ea fb80 	bl	800f0ba <reverse_128>

                if (IS_RESPONDER(connection->sm_role)){
 80249ba:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80249be:	789b      	ldrb	r3, [r3, #2]
 80249c0:	2b00      	cmp	r3, #0
 80249c2:	d004      	beq.n	80249ce <sm_run+0x7de>
                    connection->sm_engine_state = SM_SC_W4_LTK_REQUEST_SC;
 80249c4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80249c8:	224c      	movs	r2, #76	; 0x4c
 80249ca:	731a      	strb	r2, [r3, #12]
 80249cc:	e003      	b.n	80249d6 <sm_run+0x7e6>
                } else {
                    connection->sm_engine_state = SM_SC_W4_DHKEY_CHECK_COMMAND;
 80249ce:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80249d2:	224b      	movs	r2, #75	; 0x4b
 80249d4:	731a      	strb	r2, [r3, #12]
                }

                l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 80249d6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80249da:	8818      	ldrh	r0, [r3, #0]
 80249dc:	f107 02a4 	add.w	r2, r7, #164	; 0xa4
 80249e0:	2311      	movs	r3, #17
 80249e2:	2106      	movs	r1, #6
 80249e4:	f7f3 ff0c 	bl	8018800 <l2cap_send_connectionless>
                sm_timeout_reset(connection);
 80249e8:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80249ec:	f7fc fed6 	bl	802179c <sm_timeout_reset>
                break;
 80249f0:	bf00      	nop
 80249f2:	e39f      	b.n	8025134 <sm_run+0xf44>
#endif

#ifdef ENABLE_LE_PERIPHERAL

			case SM_RESPONDER_SEND_SECURITY_REQUEST: {
				const uint8_t buffer[2] = {SM_CODE_SECURITY_REQUEST, sm_auth_req};
 80249f4:	230b      	movs	r3, #11
 80249f6:	f887 30a0 	strb.w	r3, [r7, #160]	; 0xa0
 80249fa:	4ba6      	ldr	r3, [pc, #664]	; (8024c94 <sm_run+0xaa4>)
 80249fc:	781b      	ldrb	r3, [r3, #0]
 80249fe:	f887 30a1 	strb.w	r3, [r7, #161]	; 0xa1
				connection->sm_engine_state = SM_RESPONDER_PH1_W4_PAIRING_REQUEST;
 8024a02:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024a06:	221f      	movs	r2, #31
 8024a08:	731a      	strb	r2, [r3, #12]
				l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL,  (uint8_t *) buffer, sizeof(buffer));
 8024a0a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024a0e:	8818      	ldrh	r0, [r3, #0]
 8024a10:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 8024a14:	2302      	movs	r3, #2
 8024a16:	2106      	movs	r1, #6
 8024a18:	f7f3 fef2 	bl	8018800 <l2cap_send_connectionless>
				sm_timeout_start(connection);
 8024a1c:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024a20:	f7fc fe86 	bl	8021730 <sm_timeout_start>
				break;
 8024a24:	bf00      	nop
 8024a26:	e385      	b.n	8025134 <sm_run+0xf44>
			}

#ifdef ENABLE_LE_SECURE_CONNECTIONS
			case SM_SC_RECEIVED_LTK_REQUEST:
				switch (connection->sm_irk_lookup_state){
 8024a28:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024a2c:	7b5b      	ldrb	r3, [r3, #13]
 8024a2e:	2b03      	cmp	r3, #3
 8024a30:	d000      	beq.n	8024a34 <sm_run+0x844>
						connection->sm_engine_state = SM_RESPONDER_IDLE;
						hci_send_cmd(&hci_le_long_term_key_negative_reply, connection->sm_handle);
						return;
					default:
						// just wait until IRK lookup is completed
						break;
 8024a32:	e04c      	b.n	8024ace <sm_run+0x8de>
						sm_reset_setup();
 8024a34:	f7fd fb3a 	bl	80220ac <sm_reset_setup>
						sm_load_security_info(connection);
 8024a38:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024a3c:	f7fe fea2 	bl	8023784 <sm_load_security_info>
						if ((setup->sm_peer_ediv == 0u) && sm_is_null_random(setup->sm_peer_rand) && !sm_is_null_key(setup->sm_peer_ltk)){
 8024a40:	4b93      	ldr	r3, [pc, #588]	; (8024c90 <sm_run+0xaa0>)
 8024a42:	681b      	ldr	r3, [r3, #0]
 8024a44:	f8b3 31ca 	ldrh.w	r3, [r3, #458]	; 0x1ca
 8024a48:	2b00      	cmp	r3, #0
 8024a4a:	d12d      	bne.n	8024aa8 <sm_run+0x8b8>
 8024a4c:	4b90      	ldr	r3, [pc, #576]	; (8024c90 <sm_run+0xaa0>)
 8024a4e:	681b      	ldr	r3, [r3, #0]
 8024a50:	f503 73e6 	add.w	r3, r3, #460	; 0x1cc
 8024a54:	4618      	mov	r0, r3
 8024a56:	f7fc fb86 	bl	8021166 <sm_is_null_random>
 8024a5a:	4603      	mov	r3, r0
 8024a5c:	2b00      	cmp	r3, #0
 8024a5e:	d023      	beq.n	8024aa8 <sm_run+0x8b8>
 8024a60:	4b8b      	ldr	r3, [pc, #556]	; (8024c90 <sm_run+0xaa0>)
 8024a62:	681b      	ldr	r3, [r3, #0]
 8024a64:	f503 73ea 	add.w	r3, r3, #468	; 0x1d4
 8024a68:	4618      	mov	r0, r3
 8024a6a:	f7fc fb89 	bl	8021180 <sm_is_null_key>
 8024a6e:	4603      	mov	r3, r0
 8024a70:	f083 0301 	eor.w	r3, r3, #1
 8024a74:	b2db      	uxtb	r3, r3
 8024a76:	2b00      	cmp	r3, #0
 8024a78:	d016      	beq.n	8024aa8 <sm_run+0x8b8>
							(void)memcpy(setup->sm_ltk, setup->sm_peer_ltk, 16);
 8024a7a:	4b85      	ldr	r3, [pc, #532]	; (8024c90 <sm_run+0xaa0>)
 8024a7c:	681b      	ldr	r3, [r3, #0]
 8024a7e:	f103 0095 	add.w	r0, r3, #149	; 0x95
 8024a82:	4b83      	ldr	r3, [pc, #524]	; (8024c90 <sm_run+0xaa0>)
 8024a84:	681b      	ldr	r3, [r3, #0]
 8024a86:	f503 73ea 	add.w	r3, r3, #468	; 0x1d4
 8024a8a:	2210      	movs	r2, #16
 8024a8c:	4619      	mov	r1, r3
 8024a8e:	f002 fff4 	bl	8027a7a <memcpy>
							connection->sm_engine_state = SM_RESPONDER_PH4_SEND_LTK_REPLY;
 8024a92:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024a96:	2228      	movs	r2, #40	; 0x28
 8024a98:	731a      	strb	r2, [r3, #12]
                            sm_reencryption_started(connection);
 8024a9a:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024a9e:	f7fc fd48 	bl	8021532 <sm_reencryption_started>
                            sm_trigger_run();
 8024aa2:	f7fc fb85 	bl	80211b0 <sm_trigger_run>
							break;
 8024aa6:	e012      	b.n	8024ace <sm_run+0x8de>
						log_info("LTK Request: ediv & random are empty, but no stored LTK (IRK Lookup Succeeded)");
 8024aa8:	f640 23b8 	movw	r3, #2744	; 0xab8
 8024aac:	4a76      	ldr	r2, [pc, #472]	; (8024c88 <sm_run+0xa98>)
 8024aae:	497a      	ldr	r1, [pc, #488]	; (8024c98 <sm_run+0xaa8>)
 8024ab0:	2001      	movs	r0, #1
 8024ab2:	f7f2 fcc5 	bl	8017440 <hci_dump_log>
						connection->sm_engine_state = SM_RESPONDER_IDLE;
 8024ab6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024aba:	221a      	movs	r2, #26
 8024abc:	731a      	strb	r2, [r3, #12]
						hci_send_cmd(&hci_le_long_term_key_negative_reply, connection->sm_handle);
 8024abe:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024ac2:	881b      	ldrh	r3, [r3, #0]
 8024ac4:	4619      	mov	r1, r3
 8024ac6:	4875      	ldr	r0, [pc, #468]	; (8024c9c <sm_run+0xaac>)
 8024ac8:	f7f1 fa8a 	bl	8015fe0 <hci_send_cmd>
						return;
 8024acc:	e351      	b.n	8025172 <sm_run+0xf82>
				}
				break;
 8024ace:	e331      	b.n	8025134 <sm_run+0xf44>
#endif /* ENABLE_LE_SECURE_CONNECTIONS */

			case SM_RESPONDER_PH1_PAIRING_REQUEST_RECEIVED:
                sm_reset_setup();
 8024ad0:	f7fd faec 	bl	80220ac <sm_reset_setup>

			    // handle Pairing Request with LTK available
                switch (connection->sm_irk_lookup_state) {
 8024ad4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024ad8:	7b5b      	ldrb	r3, [r3, #13]
 8024ada:	2b03      	cmp	r3, #3
 8024adc:	d000      	beq.n	8024ae0 <sm_run+0x8f0>
                            sm_reencryption_started(connection);
                            sm_reencryption_complete(connection, ERROR_CODE_PIN_OR_KEY_MISSING);
                        }
                        break;
                    default:
                        break;
 8024ade:	e03c      	b.n	8024b5a <sm_run+0x96a>
                        le_device_db_encryption_get(connection->sm_le_db_index, NULL, NULL, ltk, NULL, NULL, NULL, NULL);
 8024ae0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024ae4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8024ae6:	f107 02f4 	add.w	r2, r7, #244	; 0xf4
 8024aea:	2300      	movs	r3, #0
 8024aec:	9303      	str	r3, [sp, #12]
 8024aee:	2300      	movs	r3, #0
 8024af0:	9302      	str	r3, [sp, #8]
 8024af2:	2300      	movs	r3, #0
 8024af4:	9301      	str	r3, [sp, #4]
 8024af6:	2300      	movs	r3, #0
 8024af8:	9300      	str	r3, [sp, #0]
 8024afa:	4613      	mov	r3, r2
 8024afc:	2200      	movs	r2, #0
 8024afe:	2100      	movs	r1, #0
 8024b00:	f7fc f97a 	bl	8020df8 <le_device_db_encryption_get>
                        have_ltk = !sm_is_null_key(ltk);
 8024b04:	f107 03f4 	add.w	r3, r7, #244	; 0xf4
 8024b08:	4618      	mov	r0, r3
 8024b0a:	f7fc fb39 	bl	8021180 <sm_is_null_key>
 8024b0e:	4603      	mov	r3, r0
 8024b10:	2b00      	cmp	r3, #0
 8024b12:	bf14      	ite	ne
 8024b14:	2301      	movne	r3, #1
 8024b16:	2300      	moveq	r3, #0
 8024b18:	b2db      	uxtb	r3, r3
 8024b1a:	f083 0301 	eor.w	r3, r3, #1
 8024b1e:	b2db      	uxtb	r3, r3
 8024b20:	f887 310b 	strb.w	r3, [r7, #267]	; 0x10b
 8024b24:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 8024b28:	f003 0301 	and.w	r3, r3, #1
 8024b2c:	f887 310b 	strb.w	r3, [r7, #267]	; 0x10b
                        if (have_ltk){
 8024b30:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 8024b34:	2b00      	cmp	r3, #0
 8024b36:	d00f      	beq.n	8024b58 <sm_run+0x968>
                            log_info("pairing request but LTK available");
 8024b38:	f640 23cc 	movw	r3, #2764	; 0xacc
 8024b3c:	4a52      	ldr	r2, [pc, #328]	; (8024c88 <sm_run+0xa98>)
 8024b3e:	4958      	ldr	r1, [pc, #352]	; (8024ca0 <sm_run+0xab0>)
 8024b40:	2001      	movs	r0, #1
 8024b42:	f7f2 fc7d 	bl	8017440 <hci_dump_log>
                            sm_reencryption_started(connection);
 8024b46:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024b4a:	f7fc fcf2 	bl	8021532 <sm_reencryption_started>
                            sm_reencryption_complete(connection, ERROR_CODE_PIN_OR_KEY_MISSING);
 8024b4e:	2106      	movs	r1, #6
 8024b50:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024b54:	f7fc fd21 	bl	802159a <sm_reencryption_complete>
                        break;
 8024b58:	bf00      	nop
                }

				sm_init_setup(connection);
 8024b5a:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024b5e:	f7fd fab7 	bl	80220d0 <sm_init_setup>
                sm_pairing_started(connection);
 8024b62:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024b66:	f7fc fd55 	bl	8021614 <sm_pairing_started>

				// recover pairing request
				(void)memcpy(&setup->sm_m_preq, &connection->sm_m_preq, sizeof(sm_pairing_packet_t));
 8024b6a:	4b49      	ldr	r3, [pc, #292]	; (8024c90 <sm_run+0xaa0>)
 8024b6c:	681b      	ldr	r3, [r3, #0]
 8024b6e:	f103 0039 	add.w	r0, r3, #57	; 0x39
 8024b72:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024b76:	3312      	adds	r3, #18
 8024b78:	2207      	movs	r2, #7
 8024b7a:	4619      	mov	r1, r3
 8024b7c:	f002 ff7d 	bl	8027a7a <memcpy>
				err = sm_stk_generation_init(connection);
 8024b80:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024b84:	f7fd fbae 	bl	80222e4 <sm_stk_generation_init>
 8024b88:	f8c7 0104 	str.w	r0, [r7, #260]	; 0x104
				if ((0 < test_pairing_failure) && (test_pairing_failure < SM_REASON_DHKEY_CHECK_FAILED)){
                        log_info("testing_support: respond with pairing failure %u", test_pairing_failure);
                        err = test_pairing_failure;
                    }
#endif
				if (err != 0){
 8024b8c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8024b90:	2b00      	cmp	r3, #0
 8024b92:	d00c      	beq.n	8024bae <sm_run+0x9be>
					setup->sm_pairing_failed_reason = err;
 8024b94:	4b3e      	ldr	r3, [pc, #248]	; (8024c90 <sm_run+0xaa0>)
 8024b96:	681b      	ldr	r3, [r3, #0]
 8024b98:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8024b9c:	b2d2      	uxtb	r2, r2
 8024b9e:	741a      	strb	r2, [r3, #16]
					connection->sm_engine_state = SM_GENERAL_SEND_PAIRING_FAILED;
 8024ba0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024ba4:	2201      	movs	r2, #1
 8024ba6:	731a      	strb	r2, [r3, #12]
					sm_trigger_run();
 8024ba8:	f7fc fb02 	bl	80211b0 <sm_trigger_run>
					break;
 8024bac:	e2c2      	b.n	8025134 <sm_run+0xf44>
				}

				sm_timeout_start(connection);
 8024bae:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024bb2:	f7fc fdbd 	bl	8021730 <sm_timeout_start>

				// generate random number first, if we need to show passkey, otherwise send response
				if (setup->sm_stk_generation_method == PK_INIT_INPUT){
 8024bb6:	4b36      	ldr	r3, [pc, #216]	; (8024c90 <sm_run+0xaa0>)
 8024bb8:	681b      	ldr	r3, [r3, #0]
 8024bba:	7d9b      	ldrb	r3, [r3, #22]
 8024bbc:	2b02      	cmp	r3, #2
 8024bbe:	d10a      	bne.n	8024bd6 <sm_run+0x9e6>
					btstack_crypto_random_generate(&sm_crypto_random_request, sm_random_data, 8, &sm_handle_random_result_ph2_tk, (void *)(uintptr_t) connection->sm_handle);
 8024bc0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024bc4:	881b      	ldrh	r3, [r3, #0]
 8024bc6:	9300      	str	r3, [sp, #0]
 8024bc8:	4b36      	ldr	r3, [pc, #216]	; (8024ca4 <sm_run+0xab4>)
 8024bca:	2208      	movs	r2, #8
 8024bcc:	4936      	ldr	r1, [pc, #216]	; (8024ca8 <sm_run+0xab8>)
 8024bce:	4837      	ldr	r0, [pc, #220]	; (8024cac <sm_run+0xabc>)
 8024bd0:	f7e9 fc34 	bl	800e43c <btstack_crypto_random_generate>
					break;
 8024bd4:	e2ae      	b.n	8025134 <sm_run+0xf44>
				}

				/* fall through */

            case SM_RESPONDER_PH1_SEND_PAIRING_RESPONSE:
                sm_pairing_packet_set_code(setup->sm_s_pres,SM_CODE_PAIRING_RESPONSE);
 8024bd6:	4b2e      	ldr	r3, [pc, #184]	; (8024c90 <sm_run+0xaa0>)
 8024bd8:	681b      	ldr	r3, [r3, #0]
 8024bda:	3340      	adds	r3, #64	; 0x40
 8024bdc:	2102      	movs	r1, #2
 8024bde:	4618      	mov	r0, r3
 8024be0:	f7fc fa34 	bl	802104c <sm_pairing_packet_set_code>

                // start with initiator key dist flags
                key_distribution_flags = sm_key_distribution_flags_for_auth_req();
 8024be4:	f7fd fa4a 	bl	802207c <sm_key_distribution_flags_for_auth_req>
 8024be8:	f8c7 011c 	str.w	r0, [r7, #284]	; 0x11c

#ifdef ENABLE_LE_SECURE_CONNECTIONS
                // LTK (= encyrption information & master identification) only exchanged for LE Legacy Connection
                if (setup->sm_use_secure_connections){
 8024bec:	4b28      	ldr	r3, [pc, #160]	; (8024c90 <sm_run+0xaa0>)
 8024bee:	681b      	ldr	r3, [r3, #0]
 8024bf0:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8024bf4:	2b00      	cmp	r3, #0
 8024bf6:	d005      	beq.n	8024c04 <sm_run+0xa14>
                    key_distribution_flags &= ~SM_KEYDIST_ENC_KEY;
 8024bf8:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8024bfc:	f023 0301 	bic.w	r3, r3, #1
 8024c00:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
                }
#endif
                // setup in response 
                sm_pairing_packet_set_initiator_key_distribution(setup->sm_s_pres, sm_pairing_packet_get_initiator_key_distribution(setup->sm_m_preq) & key_distribution_flags);
 8024c04:	4b22      	ldr	r3, [pc, #136]	; (8024c90 <sm_run+0xaa0>)
 8024c06:	681b      	ldr	r3, [r3, #0]
 8024c08:	f103 0440 	add.w	r4, r3, #64	; 0x40
 8024c0c:	4b20      	ldr	r3, [pc, #128]	; (8024c90 <sm_run+0xaa0>)
 8024c0e:	681b      	ldr	r3, [r3, #0]
 8024c10:	3339      	adds	r3, #57	; 0x39
 8024c12:	4618      	mov	r0, r3
 8024c14:	f7fc fa02 	bl	802101c <sm_pairing_packet_get_initiator_key_distribution>
 8024c18:	4603      	mov	r3, r0
 8024c1a:	b25a      	sxtb	r2, r3
 8024c1c:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8024c20:	b25b      	sxtb	r3, r3
 8024c22:	4013      	ands	r3, r2
 8024c24:	b25b      	sxtb	r3, r3
 8024c26:	b2db      	uxtb	r3, r3
 8024c28:	4619      	mov	r1, r3
 8024c2a:	4620      	mov	r0, r4
 8024c2c:	f7fc fa5d 	bl	80210ea <sm_pairing_packet_set_initiator_key_distribution>
                sm_pairing_packet_set_responder_key_distribution(setup->sm_s_pres, sm_pairing_packet_get_responder_key_distribution(setup->sm_m_preq) & key_distribution_flags);
 8024c30:	4b17      	ldr	r3, [pc, #92]	; (8024c90 <sm_run+0xaa0>)
 8024c32:	681b      	ldr	r3, [r3, #0]
 8024c34:	f103 0440 	add.w	r4, r3, #64	; 0x40
 8024c38:	4b15      	ldr	r3, [pc, #84]	; (8024c90 <sm_run+0xaa0>)
 8024c3a:	681b      	ldr	r3, [r3, #0]
 8024c3c:	3339      	adds	r3, #57	; 0x39
 8024c3e:	4618      	mov	r0, r3
 8024c40:	f7fc f9f8 	bl	8021034 <sm_pairing_packet_get_responder_key_distribution>
 8024c44:	4603      	mov	r3, r0
 8024c46:	b25a      	sxtb	r2, r3
 8024c48:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8024c4c:	b25b      	sxtb	r3, r3
 8024c4e:	4013      	ands	r3, r2
 8024c50:	b25b      	sxtb	r3, r3
 8024c52:	b2db      	uxtb	r3, r3
 8024c54:	4619      	mov	r1, r3
 8024c56:	4620      	mov	r0, r4
 8024c58:	f7fc fa57 	bl	802110a <sm_pairing_packet_set_responder_key_distribution>

                // update key distribution after ENC was dropped
                sm_setup_key_distribution(sm_pairing_packet_get_responder_key_distribution(setup->sm_s_pres));
 8024c5c:	4b0c      	ldr	r3, [pc, #48]	; (8024c90 <sm_run+0xaa0>)
 8024c5e:	681b      	ldr	r3, [r3, #0]
 8024c60:	3340      	adds	r3, #64	; 0x40
 8024c62:	4618      	mov	r0, r3
 8024c64:	f7fc f9e6 	bl	8021034 <sm_pairing_packet_get_responder_key_distribution>
 8024c68:	4603      	mov	r3, r0
 8024c6a:	4618      	mov	r0, r3
 8024c6c:	f7fd f828 	bl	8021cc0 <sm_setup_key_distribution>

                if (setup->sm_use_secure_connections){
 8024c70:	4b07      	ldr	r3, [pc, #28]	; (8024c90 <sm_run+0xaa0>)
 8024c72:	681b      	ldr	r3, [r3, #0]
 8024c74:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8024c78:	2b00      	cmp	r3, #0
 8024c7a:	d019      	beq.n	8024cb0 <sm_run+0xac0>
                    connection->sm_engine_state = SM_SC_W4_PUBLIC_KEY_COMMAND;
 8024c7c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024c80:	2232      	movs	r2, #50	; 0x32
 8024c82:	731a      	strb	r2, [r3, #12]
 8024c84:	e018      	b.n	8024cb8 <sm_run+0xac8>
 8024c86:	bf00      	nop
 8024c88:	0802d4a8 	.word	0x0802d4a8
 8024c8c:	0802de6c 	.word	0x0802de6c
 8024c90:	200000a0 	.word	0x200000a0
 8024c94:	20009f46 	.word	0x20009f46
 8024c98:	0802de90 	.word	0x0802de90
 8024c9c:	08030c10 	.word	0x08030c10
 8024ca0:	0802dee8 	.word	0x0802dee8
 8024ca4:	080259e5 	.word	0x080259e5
 8024ca8:	2000a0b8 	.word	0x2000a0b8
 8024cac:	2000a06c 	.word	0x2000a06c
                } else {
                    connection->sm_engine_state = SM_RESPONDER_PH1_W4_PAIRING_CONFIRM;
 8024cb0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024cb4:	2223      	movs	r2, #35	; 0x23
 8024cb6:	731a      	strb	r2, [r3, #12]
                }

                l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) &setup->sm_s_pres, sizeof(sm_pairing_packet_t));
 8024cb8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024cbc:	8818      	ldrh	r0, [r3, #0]
 8024cbe:	4bbb      	ldr	r3, [pc, #748]	; (8024fac <sm_run+0xdbc>)
 8024cc0:	681b      	ldr	r3, [r3, #0]
 8024cc2:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8024cc6:	2307      	movs	r3, #7
 8024cc8:	2106      	movs	r1, #6
 8024cca:	f7f3 fd99 	bl	8018800 <l2cap_send_connectionless>
                sm_timeout_reset(connection);
 8024cce:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024cd2:	f7fc fd63 	bl	802179c <sm_timeout_reset>
                // SC Numeric Comparison will trigger user response after public keys & nonces have been exchanged
                if (!setup->sm_use_secure_connections || (setup->sm_stk_generation_method == JUST_WORKS)){
 8024cd6:	4bb5      	ldr	r3, [pc, #724]	; (8024fac <sm_run+0xdbc>)
 8024cd8:	681b      	ldr	r3, [r3, #0]
 8024cda:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8024cde:	2b00      	cmp	r3, #0
 8024ce0:	d005      	beq.n	8024cee <sm_run+0xafe>
 8024ce2:	4bb2      	ldr	r3, [pc, #712]	; (8024fac <sm_run+0xdbc>)
 8024ce4:	681b      	ldr	r3, [r3, #0]
 8024ce6:	7d9b      	ldrb	r3, [r3, #22]
 8024ce8:	2b00      	cmp	r3, #0
 8024cea:	f040 823f 	bne.w	802516c <sm_run+0xf7c>
                    sm_trigger_user_response(connection);
 8024cee:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024cf2:	f7fd f893 	bl	8021e1c <sm_trigger_user_response>
                }
                return;
 8024cf6:	e239      	b.n	802516c <sm_run+0xf7c>
#endif

            case SM_PH2_SEND_PAIRING_RANDOM: {
                uint8_t buffer[17];
                buffer[0] = SM_CODE_PAIRING_RANDOM;
 8024cf8:	2304      	movs	r3, #4
 8024cfa:	f887 308c 	strb.w	r3, [r7, #140]	; 0x8c
                reverse_128(setup->sm_local_random, &buffer[1]);
 8024cfe:	4bab      	ldr	r3, [pc, #684]	; (8024fac <sm_run+0xdbc>)
 8024d00:	681b      	ldr	r3, [r3, #0]
 8024d02:	f103 0247 	add.w	r2, r3, #71	; 0x47
 8024d06:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 8024d0a:	3301      	adds	r3, #1
 8024d0c:	4619      	mov	r1, r3
 8024d0e:	4610      	mov	r0, r2
 8024d10:	f7ea f9d3 	bl	800f0ba <reverse_128>
                if (IS_RESPONDER(connection->sm_role)){
 8024d14:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024d18:	789b      	ldrb	r3, [r3, #2]
 8024d1a:	2b00      	cmp	r3, #0
 8024d1c:	d004      	beq.n	8024d28 <sm_run+0xb38>
                    connection->sm_engine_state = SM_RESPONDER_PH2_W4_LTK_REQUEST;
 8024d1e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024d22:	2225      	movs	r2, #37	; 0x25
 8024d24:	731a      	strb	r2, [r3, #12]
 8024d26:	e003      	b.n	8024d30 <sm_run+0xb40>
                } else {
                    connection->sm_engine_state = SM_INITIATOR_PH2_W4_PAIRING_RANDOM;
 8024d28:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024d2c:	222d      	movs	r2, #45	; 0x2d
 8024d2e:	731a      	strb	r2, [r3, #12]
                }
                l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 8024d30:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024d34:	8818      	ldrh	r0, [r3, #0]
 8024d36:	f107 028c 	add.w	r2, r7, #140	; 0x8c
 8024d3a:	2311      	movs	r3, #17
 8024d3c:	2106      	movs	r1, #6
 8024d3e:	f7f3 fd5f 	bl	8018800 <l2cap_send_connectionless>
                sm_timeout_reset(connection);
 8024d42:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024d46:	f7fc fd29 	bl	802179c <sm_timeout_reset>
                break;
 8024d4a:	bf00      	nop
 8024d4c:	e1f2      	b.n	8025134 <sm_run+0xf44>
            }

            case SM_PH2_C1_GET_ENC_A:
                // already busy?
                if (sm_aes128_state == SM_AES128_ACTIVE) break;
 8024d4e:	4b98      	ldr	r3, [pc, #608]	; (8024fb0 <sm_run+0xdc0>)
 8024d50:	781b      	ldrb	r3, [r3, #0]
 8024d52:	2b01      	cmp	r3, #1
 8024d54:	f000 81e5 	beq.w	8025122 <sm_run+0xf32>
                // calculate confirm using aes128 engine - step 1
                sm_c1_t1(setup->sm_local_random, (uint8_t*) &setup->sm_m_preq, (uint8_t*) &setup->sm_s_pres, setup->sm_m_addr_type, setup->sm_s_addr_type, sm_aes128_plaintext);
 8024d58:	4b94      	ldr	r3, [pc, #592]	; (8024fac <sm_run+0xdbc>)
 8024d5a:	681b      	ldr	r3, [r3, #0]
 8024d5c:	f103 0047 	add.w	r0, r3, #71	; 0x47
 8024d60:	4b92      	ldr	r3, [pc, #584]	; (8024fac <sm_run+0xdbc>)
 8024d62:	681b      	ldr	r3, [r3, #0]
 8024d64:	f103 0139 	add.w	r1, r3, #57	; 0x39
 8024d68:	4b90      	ldr	r3, [pc, #576]	; (8024fac <sm_run+0xdbc>)
 8024d6a:	681b      	ldr	r3, [r3, #0]
 8024d6c:	f103 0440 	add.w	r4, r3, #64	; 0x40
 8024d70:	4b8e      	ldr	r3, [pc, #568]	; (8024fac <sm_run+0xdbc>)
 8024d72:	681b      	ldr	r3, [r3, #0]
 8024d74:	f893 5087 	ldrb.w	r5, [r3, #135]	; 0x87
 8024d78:	4b8c      	ldr	r3, [pc, #560]	; (8024fac <sm_run+0xdbc>)
 8024d7a:	681b      	ldr	r3, [r3, #0]
 8024d7c:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 8024d80:	4a8c      	ldr	r2, [pc, #560]	; (8024fb4 <sm_run+0xdc4>)
 8024d82:	9201      	str	r2, [sp, #4]
 8024d84:	9300      	str	r3, [sp, #0]
 8024d86:	462b      	mov	r3, r5
 8024d88:	4622      	mov	r2, r4
 8024d8a:	f7fc fdab 	bl	80218e4 <sm_c1_t1>
                connection->sm_engine_state = SM_PH2_C1_W4_ENC_A;
 8024d8e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024d92:	220c      	movs	r2, #12
 8024d94:	731a      	strb	r2, [r3, #12]
                sm_aes128_state = SM_AES128_ACTIVE;
 8024d96:	4b86      	ldr	r3, [pc, #536]	; (8024fb0 <sm_run+0xdc0>)
 8024d98:	2201      	movs	r2, #1
 8024d9a:	701a      	strb	r2, [r3, #0]
                btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, setup->sm_tk, sm_aes128_plaintext, sm_aes128_ciphertext, sm_handle_encryption_result_enc_a, (void *)(uintptr_t) connection->sm_handle);
 8024d9c:	4b83      	ldr	r3, [pc, #524]	; (8024fac <sm_run+0xdbc>)
 8024d9e:	681b      	ldr	r3, [r3, #0]
 8024da0:	f103 0117 	add.w	r1, r3, #23
 8024da4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024da8:	881b      	ldrh	r3, [r3, #0]
 8024daa:	9301      	str	r3, [sp, #4]
 8024dac:	4b82      	ldr	r3, [pc, #520]	; (8024fb8 <sm_run+0xdc8>)
 8024dae:	9300      	str	r3, [sp, #0]
 8024db0:	4b82      	ldr	r3, [pc, #520]	; (8024fbc <sm_run+0xdcc>)
 8024db2:	4a80      	ldr	r2, [pc, #512]	; (8024fb4 <sm_run+0xdc4>)
 8024db4:	4882      	ldr	r0, [pc, #520]	; (8024fc0 <sm_run+0xdd0>)
 8024db6:	f7e9 fb65 	bl	800e484 <btstack_crypto_aes128_encrypt>
                break;
 8024dba:	e1bb      	b.n	8025134 <sm_run+0xf44>

            case SM_PH2_C1_GET_ENC_C:
                // already busy?
                if (sm_aes128_state == SM_AES128_ACTIVE) break;
 8024dbc:	4b7c      	ldr	r3, [pc, #496]	; (8024fb0 <sm_run+0xdc0>)
 8024dbe:	781b      	ldrb	r3, [r3, #0]
 8024dc0:	2b01      	cmp	r3, #1
 8024dc2:	f000 81b0 	beq.w	8025126 <sm_run+0xf36>
                // calculate m_confirm using aes128 engine - step 1
                sm_c1_t1(setup->sm_peer_random, (uint8_t*) &setup->sm_m_preq, (uint8_t*) &setup->sm_s_pres, setup->sm_m_addr_type, setup->sm_s_addr_type, sm_aes128_plaintext);
 8024dc6:	4b79      	ldr	r3, [pc, #484]	; (8024fac <sm_run+0xdbc>)
 8024dc8:	681b      	ldr	r3, [r3, #0]
 8024dca:	f103 0067 	add.w	r0, r3, #103	; 0x67
 8024dce:	4b77      	ldr	r3, [pc, #476]	; (8024fac <sm_run+0xdbc>)
 8024dd0:	681b      	ldr	r3, [r3, #0]
 8024dd2:	f103 0139 	add.w	r1, r3, #57	; 0x39
 8024dd6:	4b75      	ldr	r3, [pc, #468]	; (8024fac <sm_run+0xdbc>)
 8024dd8:	681b      	ldr	r3, [r3, #0]
 8024dda:	f103 0440 	add.w	r4, r3, #64	; 0x40
 8024dde:	4b73      	ldr	r3, [pc, #460]	; (8024fac <sm_run+0xdbc>)
 8024de0:	681b      	ldr	r3, [r3, #0]
 8024de2:	f893 5087 	ldrb.w	r5, [r3, #135]	; 0x87
 8024de6:	4b71      	ldr	r3, [pc, #452]	; (8024fac <sm_run+0xdbc>)
 8024de8:	681b      	ldr	r3, [r3, #0]
 8024dea:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 8024dee:	4a71      	ldr	r2, [pc, #452]	; (8024fb4 <sm_run+0xdc4>)
 8024df0:	9201      	str	r2, [sp, #4]
 8024df2:	9300      	str	r3, [sp, #0]
 8024df4:	462b      	mov	r3, r5
 8024df6:	4622      	mov	r2, r4
 8024df8:	f7fc fd74 	bl	80218e4 <sm_c1_t1>
                connection->sm_engine_state = SM_PH2_C1_W4_ENC_C;
 8024dfc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024e00:	220e      	movs	r2, #14
 8024e02:	731a      	strb	r2, [r3, #12]
                sm_aes128_state = SM_AES128_ACTIVE;
 8024e04:	4b6a      	ldr	r3, [pc, #424]	; (8024fb0 <sm_run+0xdc0>)
 8024e06:	2201      	movs	r2, #1
 8024e08:	701a      	strb	r2, [r3, #0]
                btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, setup->sm_tk, sm_aes128_plaintext, sm_aes128_ciphertext, sm_handle_encryption_result_enc_c, (void *)(uintptr_t) connection->sm_handle);
 8024e0a:	4b68      	ldr	r3, [pc, #416]	; (8024fac <sm_run+0xdbc>)
 8024e0c:	681b      	ldr	r3, [r3, #0]
 8024e0e:	f103 0117 	add.w	r1, r3, #23
 8024e12:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024e16:	881b      	ldrh	r3, [r3, #0]
 8024e18:	9301      	str	r3, [sp, #4]
 8024e1a:	4b6a      	ldr	r3, [pc, #424]	; (8024fc4 <sm_run+0xdd4>)
 8024e1c:	9300      	str	r3, [sp, #0]
 8024e1e:	4b67      	ldr	r3, [pc, #412]	; (8024fbc <sm_run+0xdcc>)
 8024e20:	4a64      	ldr	r2, [pc, #400]	; (8024fb4 <sm_run+0xdc4>)
 8024e22:	4867      	ldr	r0, [pc, #412]	; (8024fc0 <sm_run+0xdd0>)
 8024e24:	f7e9 fb2e 	bl	800e484 <btstack_crypto_aes128_encrypt>
                break;
 8024e28:	e184      	b.n	8025134 <sm_run+0xf44>

            case SM_PH2_CALC_STK:
                // already busy?
                if (sm_aes128_state == SM_AES128_ACTIVE) break;
 8024e2a:	4b61      	ldr	r3, [pc, #388]	; (8024fb0 <sm_run+0xdc0>)
 8024e2c:	781b      	ldrb	r3, [r3, #0]
 8024e2e:	2b01      	cmp	r3, #1
 8024e30:	f000 817b 	beq.w	802512a <sm_run+0xf3a>
                // calculate STK
                if (IS_RESPONDER(connection->sm_role)){
 8024e34:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024e38:	789b      	ldrb	r3, [r3, #2]
 8024e3a:	2b00      	cmp	r3, #0
 8024e3c:	d00b      	beq.n	8024e56 <sm_run+0xc66>
                    sm_s1_r_prime(setup->sm_local_random, setup->sm_peer_random, sm_aes128_plaintext);
 8024e3e:	4b5b      	ldr	r3, [pc, #364]	; (8024fac <sm_run+0xdbc>)
 8024e40:	681b      	ldr	r3, [r3, #0]
 8024e42:	f103 0047 	add.w	r0, r3, #71	; 0x47
 8024e46:	4b59      	ldr	r3, [pc, #356]	; (8024fac <sm_run+0xdbc>)
 8024e48:	681b      	ldr	r3, [r3, #0]
 8024e4a:	3367      	adds	r3, #103	; 0x67
 8024e4c:	4a59      	ldr	r2, [pc, #356]	; (8024fb4 <sm_run+0xdc4>)
 8024e4e:	4619      	mov	r1, r3
 8024e50:	f7fc fddc 	bl	8021a0c <sm_s1_r_prime>
 8024e54:	e00a      	b.n	8024e6c <sm_run+0xc7c>
                } else {
                    sm_s1_r_prime(setup->sm_peer_random, setup->sm_local_random, sm_aes128_plaintext);
 8024e56:	4b55      	ldr	r3, [pc, #340]	; (8024fac <sm_run+0xdbc>)
 8024e58:	681b      	ldr	r3, [r3, #0]
 8024e5a:	f103 0067 	add.w	r0, r3, #103	; 0x67
 8024e5e:	4b53      	ldr	r3, [pc, #332]	; (8024fac <sm_run+0xdbc>)
 8024e60:	681b      	ldr	r3, [r3, #0]
 8024e62:	3347      	adds	r3, #71	; 0x47
 8024e64:	4a53      	ldr	r2, [pc, #332]	; (8024fb4 <sm_run+0xdc4>)
 8024e66:	4619      	mov	r1, r3
 8024e68:	f7fc fdd0 	bl	8021a0c <sm_s1_r_prime>
                }
                connection->sm_engine_state = SM_PH2_W4_STK;
 8024e6c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024e70:	2212      	movs	r2, #18
 8024e72:	731a      	strb	r2, [r3, #12]
                sm_aes128_state = SM_AES128_ACTIVE;
 8024e74:	4b4e      	ldr	r3, [pc, #312]	; (8024fb0 <sm_run+0xdc0>)
 8024e76:	2201      	movs	r2, #1
 8024e78:	701a      	strb	r2, [r3, #0]
                btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, setup->sm_tk, sm_aes128_plaintext, setup->sm_ltk, sm_handle_encryption_result_enc_stk, (void *)(uintptr_t) connection->sm_handle);
 8024e7a:	4b4c      	ldr	r3, [pc, #304]	; (8024fac <sm_run+0xdbc>)
 8024e7c:	681b      	ldr	r3, [r3, #0]
 8024e7e:	f103 0117 	add.w	r1, r3, #23
 8024e82:	4b4a      	ldr	r3, [pc, #296]	; (8024fac <sm_run+0xdbc>)
 8024e84:	681b      	ldr	r3, [r3, #0]
 8024e86:	f103 0295 	add.w	r2, r3, #149	; 0x95
 8024e8a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024e8e:	881b      	ldrh	r3, [r3, #0]
 8024e90:	9301      	str	r3, [sp, #4]
 8024e92:	4b4d      	ldr	r3, [pc, #308]	; (8024fc8 <sm_run+0xdd8>)
 8024e94:	9300      	str	r3, [sp, #0]
 8024e96:	4613      	mov	r3, r2
 8024e98:	4a46      	ldr	r2, [pc, #280]	; (8024fb4 <sm_run+0xdc4>)
 8024e9a:	4849      	ldr	r0, [pc, #292]	; (8024fc0 <sm_run+0xdd0>)
 8024e9c:	f7e9 faf2 	bl	800e484 <btstack_crypto_aes128_encrypt>
                break;
 8024ea0:	e148      	b.n	8025134 <sm_run+0xf44>

            case SM_PH3_Y_GET_ENC:
                // already busy?
                if (sm_aes128_state == SM_AES128_ACTIVE) break;
 8024ea2:	4b43      	ldr	r3, [pc, #268]	; (8024fb0 <sm_run+0xdc0>)
 8024ea4:	781b      	ldrb	r3, [r3, #0]
 8024ea6:	2b01      	cmp	r3, #1
 8024ea8:	f000 8141 	beq.w	802512e <sm_run+0xf3e>
                // PH3B2 - calculate Y from      - enc

                // dm helper (was sm_dm_r_prime)
                // r' = padding || r
                // r - 64 bit value
                memset(&sm_aes128_plaintext[0], 0, 8);
 8024eac:	2208      	movs	r2, #8
 8024eae:	2100      	movs	r1, #0
 8024eb0:	4840      	ldr	r0, [pc, #256]	; (8024fb4 <sm_run+0xdc4>)
 8024eb2:	f002 fe06 	bl	8027ac2 <memset>
                (void)memcpy(&sm_aes128_plaintext[8], setup->sm_local_rand, 8);
 8024eb6:	4b3d      	ldr	r3, [pc, #244]	; (8024fac <sm_run+0xdbc>)
 8024eb8:	681b      	ldr	r3, [r3, #0]
 8024eba:	f503 73c7 	add.w	r3, r3, #398	; 0x18e
 8024ebe:	2208      	movs	r2, #8
 8024ec0:	4619      	mov	r1, r3
 8024ec2:	4842      	ldr	r0, [pc, #264]	; (8024fcc <sm_run+0xddc>)
 8024ec4:	f002 fdd9 	bl	8027a7a <memcpy>

                // Y = dm(DHK, Rand)
                connection->sm_engine_state = SM_PH3_Y_W4_ENC;
 8024ec8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024ecc:	2215      	movs	r2, #21
 8024ece:	731a      	strb	r2, [r3, #12]
                sm_aes128_state = SM_AES128_ACTIVE;
 8024ed0:	4b37      	ldr	r3, [pc, #220]	; (8024fb0 <sm_run+0xdc0>)
 8024ed2:	2201      	movs	r2, #1
 8024ed4:	701a      	strb	r2, [r3, #0]
                btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, sm_persistent_dhk, sm_aes128_plaintext, sm_aes128_ciphertext, sm_handle_encryption_result_enc_ph3_y, (void *)(uintptr_t) connection->sm_handle);
 8024ed6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024eda:	881b      	ldrh	r3, [r3, #0]
 8024edc:	9301      	str	r3, [sp, #4]
 8024ede:	4b3c      	ldr	r3, [pc, #240]	; (8024fd0 <sm_run+0xde0>)
 8024ee0:	9300      	str	r3, [sp, #0]
 8024ee2:	4b36      	ldr	r3, [pc, #216]	; (8024fbc <sm_run+0xdcc>)
 8024ee4:	4a33      	ldr	r2, [pc, #204]	; (8024fb4 <sm_run+0xdc4>)
 8024ee6:	493b      	ldr	r1, [pc, #236]	; (8024fd4 <sm_run+0xde4>)
 8024ee8:	4835      	ldr	r0, [pc, #212]	; (8024fc0 <sm_run+0xdd0>)
 8024eea:	f7e9 facb 	bl	800e484 <btstack_crypto_aes128_encrypt>
                break;
 8024eee:	e121      	b.n	8025134 <sm_run+0xf44>

            case SM_PH2_C1_SEND_PAIRING_CONFIRM: {
                uint8_t buffer[17];
                buffer[0] = SM_CODE_PAIRING_CONFIRM;
 8024ef0:	2303      	movs	r3, #3
 8024ef2:	f887 3078 	strb.w	r3, [r7, #120]	; 0x78
                reverse_128(setup->sm_local_confirm, &buffer[1]);
 8024ef6:	4b2d      	ldr	r3, [pc, #180]	; (8024fac <sm_run+0xdbc>)
 8024ef8:	681b      	ldr	r3, [r3, #0]
 8024efa:	f103 0257 	add.w	r2, r3, #87	; 0x57
 8024efe:	f107 0378 	add.w	r3, r7, #120	; 0x78
 8024f02:	3301      	adds	r3, #1
 8024f04:	4619      	mov	r1, r3
 8024f06:	4610      	mov	r0, r2
 8024f08:	f7ea f8d7 	bl	800f0ba <reverse_128>
                if (IS_RESPONDER(connection->sm_role)){
 8024f0c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024f10:	789b      	ldrb	r3, [r3, #2]
 8024f12:	2b00      	cmp	r3, #0
 8024f14:	d004      	beq.n	8024f20 <sm_run+0xd30>
                    connection->sm_engine_state = SM_RESPONDER_PH2_W4_PAIRING_RANDOM;
 8024f16:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024f1a:	2224      	movs	r2, #36	; 0x24
 8024f1c:	731a      	strb	r2, [r3, #12]
 8024f1e:	e003      	b.n	8024f28 <sm_run+0xd38>
                } else {
                    connection->sm_engine_state = SM_INITIATOR_PH2_W4_PAIRING_CONFIRM;
 8024f20:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024f24:	222c      	movs	r2, #44	; 0x2c
 8024f26:	731a      	strb	r2, [r3, #12]
                }
                l2cap_send_connectionless(connection->sm_handle, L2CAP_CID_SECURITY_MANAGER_PROTOCOL, (uint8_t*) buffer, sizeof(buffer));
 8024f28:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024f2c:	8818      	ldrh	r0, [r3, #0]
 8024f2e:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8024f32:	2311      	movs	r3, #17
 8024f34:	2106      	movs	r1, #6
 8024f36:	f7f3 fc63 	bl	8018800 <l2cap_send_connectionless>
                sm_timeout_reset(connection);
 8024f3a:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8024f3e:	f7fc fc2d 	bl	802179c <sm_timeout_reset>
                return;
 8024f42:	bf00      	nop
 8024f44:	e115      	b.n	8025172 <sm_run+0xf82>
            }
#ifdef ENABLE_LE_PERIPHERAL
            case SM_RESPONDER_PH2_SEND_LTK_REPLY: {
                sm_key_t stk_flipped;
                reverse_128(setup->sm_ltk, stk_flipped);
 8024f46:	4b19      	ldr	r3, [pc, #100]	; (8024fac <sm_run+0xdbc>)
 8024f48:	681b      	ldr	r3, [r3, #0]
 8024f4a:	3395      	adds	r3, #149	; 0x95
 8024f4c:	f107 0268 	add.w	r2, r7, #104	; 0x68
 8024f50:	4611      	mov	r1, r2
 8024f52:	4618      	mov	r0, r3
 8024f54:	f7ea f8b1 	bl	800f0ba <reverse_128>
                connection->sm_engine_state = SM_PH2_W4_CONNECTION_ENCRYPTED;
 8024f58:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024f5c:	2213      	movs	r2, #19
 8024f5e:	731a      	strb	r2, [r3, #12]
                hci_send_cmd(&hci_le_long_term_key_request_reply, connection->sm_handle, stk_flipped);
 8024f60:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024f64:	881b      	ldrh	r3, [r3, #0]
 8024f66:	4619      	mov	r1, r3
 8024f68:	f107 0368 	add.w	r3, r7, #104	; 0x68
 8024f6c:	461a      	mov	r2, r3
 8024f6e:	481a      	ldr	r0, [pc, #104]	; (8024fd8 <sm_run+0xde8>)
 8024f70:	f7f1 f836 	bl	8015fe0 <hci_send_cmd>
                return;
 8024f74:	bf00      	nop
 8024f76:	e0fc      	b.n	8025172 <sm_run+0xf82>
            }
            case SM_RESPONDER_PH4_SEND_LTK_REPLY: {
                sm_key_t ltk_flipped;
                reverse_128(setup->sm_ltk, ltk_flipped);
 8024f78:	4b0c      	ldr	r3, [pc, #48]	; (8024fac <sm_run+0xdbc>)
 8024f7a:	681b      	ldr	r3, [r3, #0]
 8024f7c:	3395      	adds	r3, #149	; 0x95
 8024f7e:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8024f82:	4611      	mov	r1, r2
 8024f84:	4618      	mov	r0, r3
 8024f86:	f7ea f898 	bl	800f0ba <reverse_128>
                connection->sm_engine_state = SM_PH4_W4_CONNECTION_ENCRYPTED;
 8024f8a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024f8e:	2219      	movs	r2, #25
 8024f90:	731a      	strb	r2, [r3, #12]
                hci_send_cmd(&hci_le_long_term_key_request_reply, connection->sm_handle, ltk_flipped);
 8024f92:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8024f96:	881b      	ldrh	r3, [r3, #0]
 8024f98:	4619      	mov	r1, r3
 8024f9a:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8024f9e:	461a      	mov	r2, r3
 8024fa0:	480d      	ldr	r0, [pc, #52]	; (8024fd8 <sm_run+0xde8>)
 8024fa2:	f7f1 f81d 	bl	8015fe0 <hci_send_cmd>
                return;
 8024fa6:	bf00      	nop
 8024fa8:	e0e3      	b.n	8025172 <sm_run+0xf82>
 8024faa:	bf00      	nop
 8024fac:	200000a0 	.word	0x200000a0
 8024fb0:	2000a068 	.word	0x2000a068
 8024fb4:	2000a0d0 	.word	0x2000a0d0
 8024fb8:	080251ad 	.word	0x080251ad
 8024fbc:	2000a0e0 	.word	0x2000a0e0
 8024fc0:	2000a084 	.word	0x2000a084
 8024fc4:	08025289 	.word	0x08025289
 8024fc8:	080253dd 	.word	0x080253dd
 8024fcc:	2000a0d8 	.word	0x2000a0d8
 8024fd0:	08025451 	.word	0x08025451
 8024fd4:	20009f90 	.word	0x20009f90
 8024fd8:	08030c08 	.word	0x08030c08
            }

			case SM_RESPONDER_PH0_RECEIVED_LTK_REQUEST:
                // already busy?
                if (sm_aes128_state == SM_AES128_ACTIVE) break;
 8024fdc:	4b67      	ldr	r3, [pc, #412]	; (802517c <sm_run+0xf8c>)
 8024fde:	781b      	ldrb	r3, [r3, #0]
 8024fe0:	2b01      	cmp	r3, #1
 8024fe2:	f000 80a6 	beq.w	8025132 <sm_run+0xf42>
                log_info("LTK Request: recalculating with ediv 0x%04x", setup->sm_local_ediv);
 8024fe6:	4b66      	ldr	r3, [pc, #408]	; (8025180 <sm_run+0xf90>)
 8024fe8:	681b      	ldr	r3, [r3, #0]
 8024fea:	f8b3 318c 	ldrh.w	r3, [r3, #396]	; 0x18c
 8024fee:	9300      	str	r3, [sp, #0]
 8024ff0:	f640 3377 	movw	r3, #2935	; 0xb77
 8024ff4:	4a63      	ldr	r2, [pc, #396]	; (8025184 <sm_run+0xf94>)
 8024ff6:	4964      	ldr	r1, [pc, #400]	; (8025188 <sm_run+0xf98>)
 8024ff8:	2001      	movs	r0, #1
 8024ffa:	f7f2 fa21 	bl	8017440 <hci_dump_log>

				sm_reset_setup();
 8024ffe:	f7fd f855 	bl	80220ac <sm_reset_setup>
				sm_start_calculating_ltk_from_ediv_and_rand(connection);
 8025002:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8025006:	f7fe fc0f 	bl	8023828 <sm_start_calculating_ltk_from_ediv_and_rand>

				sm_reencryption_started(connection);
 802500a:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 802500e:	f7fc fa90 	bl	8021532 <sm_reencryption_started>

                // dm helper (was sm_dm_r_prime)
                // r' = padding || r
                // r - 64 bit value
                memset(&sm_aes128_plaintext[0], 0, 8);
 8025012:	2208      	movs	r2, #8
 8025014:	2100      	movs	r1, #0
 8025016:	485d      	ldr	r0, [pc, #372]	; (802518c <sm_run+0xf9c>)
 8025018:	f002 fd53 	bl	8027ac2 <memset>
                (void)memcpy(&sm_aes128_plaintext[8], setup->sm_local_rand, 8);
 802501c:	4b58      	ldr	r3, [pc, #352]	; (8025180 <sm_run+0xf90>)
 802501e:	681b      	ldr	r3, [r3, #0]
 8025020:	f503 73c7 	add.w	r3, r3, #398	; 0x18e
 8025024:	2208      	movs	r2, #8
 8025026:	4619      	mov	r1, r3
 8025028:	4859      	ldr	r0, [pc, #356]	; (8025190 <sm_run+0xfa0>)
 802502a:	f002 fd26 	bl	8027a7a <memcpy>

                // Y = dm(DHK, Rand)
                connection->sm_engine_state = SM_RESPONDER_PH4_Y_W4_ENC;
 802502e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8025032:	2227      	movs	r2, #39	; 0x27
 8025034:	731a      	strb	r2, [r3, #12]
                sm_aes128_state = SM_AES128_ACTIVE;
 8025036:	4b51      	ldr	r3, [pc, #324]	; (802517c <sm_run+0xf8c>)
 8025038:	2201      	movs	r2, #1
 802503a:	701a      	strb	r2, [r3, #0]
                btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, sm_persistent_dhk, sm_aes128_plaintext, sm_aes128_ciphertext, sm_handle_encryption_result_enc_ph4_y, (void *)(uintptr_t) connection->sm_handle);
 802503c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8025040:	881b      	ldrh	r3, [r3, #0]
 8025042:	9301      	str	r3, [sp, #4]
 8025044:	4b53      	ldr	r3, [pc, #332]	; (8025194 <sm_run+0xfa4>)
 8025046:	9300      	str	r3, [sp, #0]
 8025048:	4b53      	ldr	r3, [pc, #332]	; (8025198 <sm_run+0xfa8>)
 802504a:	4a50      	ldr	r2, [pc, #320]	; (802518c <sm_run+0xf9c>)
 802504c:	4953      	ldr	r1, [pc, #332]	; (802519c <sm_run+0xfac>)
 802504e:	4854      	ldr	r0, [pc, #336]	; (80251a0 <sm_run+0xfb0>)
 8025050:	f7e9 fa18 	bl	800e484 <btstack_crypto_aes128_encrypt>
                return;
 8025054:	e08d      	b.n	8025172 <sm_run+0xf82>
#endif
#ifdef ENABLE_LE_CENTRAL
            case SM_INITIATOR_PH3_SEND_START_ENCRYPTION: {
                sm_key_t stk_flipped;
                reverse_128(setup->sm_ltk, stk_flipped);
 8025056:	4b4a      	ldr	r3, [pc, #296]	; (8025180 <sm_run+0xf90>)
 8025058:	681b      	ldr	r3, [r3, #0]
 802505a:	3395      	adds	r3, #149	; 0x95
 802505c:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8025060:	4611      	mov	r1, r2
 8025062:	4618      	mov	r0, r3
 8025064:	f7ea f829 	bl	800f0ba <reverse_128>
                connection->sm_engine_state = SM_PH2_W4_CONNECTION_ENCRYPTED;
 8025068:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802506c:	2213      	movs	r2, #19
 802506e:	731a      	strb	r2, [r3, #12]
                hci_send_cmd(&hci_le_start_encryption, connection->sm_handle, 0, 0, 0, stk_flipped);
 8025070:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8025074:	881b      	ldrh	r3, [r3, #0]
 8025076:	4619      	mov	r1, r3
 8025078:	f107 0348 	add.w	r3, r7, #72	; 0x48
 802507c:	9301      	str	r3, [sp, #4]
 802507e:	2300      	movs	r3, #0
 8025080:	9300      	str	r3, [sp, #0]
 8025082:	2300      	movs	r3, #0
 8025084:	2200      	movs	r2, #0
 8025086:	4847      	ldr	r0, [pc, #284]	; (80251a4 <sm_run+0xfb4>)
 8025088:	f7f0 ffaa 	bl	8015fe0 <hci_send_cmd>
                return;
 802508c:	bf00      	nop
 802508e:	e070      	b.n	8025172 <sm_run+0xf82>
            }
#endif

            case SM_PH3_DISTRIBUTE_KEYS:
                if (setup->sm_key_distribution_send_set != 0){
 8025090:	4b3b      	ldr	r3, [pc, #236]	; (8025180 <sm_run+0xf90>)
 8025092:	681b      	ldr	r3, [r3, #0]
 8025094:	7cdb      	ldrb	r3, [r3, #19]
 8025096:	2b00      	cmp	r3, #0
 8025098:	d004      	beq.n	80250a4 <sm_run+0xeb4>
                    sm_run_distribute_keys(connection);
 802509a:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 802509e:	f7fe ff73 	bl	8023f88 <sm_run_distribute_keys>
                    return;
 80250a2:	e066      	b.n	8025172 <sm_run+0xf82>
                }

                // keys are sent
                if (IS_RESPONDER(connection->sm_role)){
 80250a4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80250a8:	789b      	ldrb	r3, [r3, #2]
 80250aa:	2b00      	cmp	r3, #0
 80250ac:	d020      	beq.n	80250f0 <sm_run+0xf00>
                    // slave -> receive master keys if any
                    if (sm_key_distribution_all_received(connection)){
 80250ae:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80250b2:	f7fc ff63 	bl	8021f7c <sm_key_distribution_all_received>
 80250b6:	4603      	mov	r3, r0
 80250b8:	2b00      	cmp	r3, #0
 80250ba:	d014      	beq.n	80250e6 <sm_run+0xef6>
                        sm_key_distribution_handle_all_received(connection);
 80250bc:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80250c0:	f7fd fb10 	bl	80226e4 <sm_key_distribution_handle_all_received>
                        connection->sm_engine_state = SM_RESPONDER_IDLE;
 80250c4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80250c8:	221a      	movs	r2, #26
 80250ca:	731a      	strb	r2, [r3, #12]
                        sm_pairing_complete(connection, ERROR_CODE_SUCCESS, 0);
 80250cc:	2200      	movs	r2, #0
 80250ce:	2100      	movs	r1, #0
 80250d0:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80250d4:	f7fc facc 	bl	8021670 <sm_pairing_complete>
                        sm_done_for_handle(connection->sm_handle);
 80250d8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80250dc:	881b      	ldrh	r3, [r3, #0]
 80250de:	4618      	mov	r0, r3
 80250e0:	f7fc ff88 	bl	8021ff4 <sm_done_for_handle>
                        connection->sm_engine_state = SM_PH3_RECEIVE_KEYS;
                    }
                } else {
                    sm_master_pairing_success(connection);
                }
                break;
 80250e4:	e026      	b.n	8025134 <sm_run+0xf44>
                        connection->sm_engine_state = SM_PH3_RECEIVE_KEYS;
 80250e6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80250ea:	2218      	movs	r2, #24
 80250ec:	731a      	strb	r2, [r3, #12]
                break;
 80250ee:	e021      	b.n	8025134 <sm_run+0xf44>
                    sm_master_pairing_success(connection);
 80250f0:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 80250f4:	f7fc ffac 	bl	8022050 <sm_master_pairing_success>
                break;
 80250f8:	e01c      	b.n	8025134 <sm_run+0xf44>

            default:
                break;
 80250fa:	bf00      	nop
 80250fc:	e01a      	b.n	8025134 <sm_run+0xf44>
                if (!sm_cmac_ready()) break;
 80250fe:	bf00      	nop
 8025100:	e018      	b.n	8025134 <sm_run+0xf44>
                if (!sm_cmac_ready()) break;
 8025102:	bf00      	nop
 8025104:	e016      	b.n	8025134 <sm_run+0xf44>
                if (!sm_cmac_ready()) break;
 8025106:	bf00      	nop
 8025108:	e014      	b.n	8025134 <sm_run+0xf44>
                if (!sm_cmac_ready()) break;
 802510a:	bf00      	nop
 802510c:	e012      	b.n	8025134 <sm_run+0xf44>
                if (!sm_cmac_ready()) break;
 802510e:	bf00      	nop
 8025110:	e010      	b.n	8025134 <sm_run+0xf44>
                if (!sm_cmac_ready()) break;
 8025112:	bf00      	nop
 8025114:	e00e      	b.n	8025134 <sm_run+0xf44>
                if (!sm_cmac_ready()) break;
 8025116:	bf00      	nop
 8025118:	e00c      	b.n	8025134 <sm_run+0xf44>
                if (!sm_cmac_ready()) break;
 802511a:	bf00      	nop
 802511c:	e00a      	b.n	8025134 <sm_run+0xf44>
                break;
 802511e:	bf00      	nop
 8025120:	e008      	b.n	8025134 <sm_run+0xf44>
                if (sm_aes128_state == SM_AES128_ACTIVE) break;
 8025122:	bf00      	nop
 8025124:	e006      	b.n	8025134 <sm_run+0xf44>
                if (sm_aes128_state == SM_AES128_ACTIVE) break;
 8025126:	bf00      	nop
 8025128:	e004      	b.n	8025134 <sm_run+0xf44>
                if (sm_aes128_state == SM_AES128_ACTIVE) break;
 802512a:	bf00      	nop
 802512c:	e002      	b.n	8025134 <sm_run+0xf44>
                if (sm_aes128_state == SM_AES128_ACTIVE) break;
 802512e:	bf00      	nop
 8025130:	e000      	b.n	8025134 <sm_run+0xf44>
                if (sm_aes128_state == SM_AES128_ACTIVE) break;
 8025132:	bf00      	nop
        }

        // check again if active connection was released
        if (sm_active_connection_handle != HCI_CON_HANDLE_INVALID) break;
 8025134:	4b1c      	ldr	r3, [pc, #112]	; (80251a8 <sm_run+0xfb8>)
 8025136:	881b      	ldrh	r3, [r3, #0]
 8025138:	f64f 72ff 	movw	r2, #65535	; 0xffff
 802513c:	4293      	cmp	r3, r2
 802513e:	d117      	bne.n	8025170 <sm_run+0xf80>
    while (true) {
 8025140:	f7ff b8a2 	b.w	8024288 <sm_run+0x98>
    if (hci_get_state() != HCI_STATE_WORKING) return;
 8025144:	bf00      	nop
 8025146:	e014      	b.n	8025172 <sm_run+0xf82>
    if (!hci_can_send_command_packet_now()) return;
 8025148:	bf00      	nop
 802514a:	e012      	b.n	8025172 <sm_run+0xf82>
    if (sm_persistent_keys_random_active) return;
 802514c:	bf00      	nop
 802514e:	e010      	b.n	8025172 <sm_run+0xf82>
    if (done) return;
 8025150:	bf00      	nop
 8025152:	e00e      	b.n	8025172 <sm_run+0xf82>
    if (done) return;
 8025154:	bf00      	nop
 8025156:	e00c      	b.n	8025172 <sm_run+0xf82>
    if (done) return;
 8025158:	bf00      	nop
 802515a:	e00a      	b.n	8025172 <sm_run+0xf82>
    if (done) return;
 802515c:	bf00      	nop
 802515e:	e008      	b.n	8025172 <sm_run+0xf82>
    if (!hci_can_send_command_packet_now()) return;
 8025160:	bf00      	nop
 8025162:	e006      	b.n	8025172 <sm_run+0xf82>
    if (done) return;
 8025164:	bf00      	nop
 8025166:	e004      	b.n	8025172 <sm_run+0xf82>
        if (sm_active_connection_handle == HCI_CON_HANDLE_INVALID) return;
 8025168:	bf00      	nop
 802516a:	e002      	b.n	8025172 <sm_run+0xf82>
                return;
 802516c:	bf00      	nop
 802516e:	e000      	b.n	8025172 <sm_run+0xf82>
        if (sm_active_connection_handle != HCI_CON_HANDLE_INVALID) break;
 8025170:	bf00      	nop
    }
}
 8025172:	f507 7790 	add.w	r7, r7, #288	; 0x120
 8025176:	46bd      	mov	sp, r7
 8025178:	bdb0      	pop	{r4, r5, r7, pc}
 802517a:	bf00      	nop
 802517c:	2000a068 	.word	0x2000a068
 8025180:	200000a0 	.word	0x200000a0
 8025184:	0802d4a8 	.word	0x0802d4a8
 8025188:	0802df14 	.word	0x0802df14
 802518c:	2000a0d0 	.word	0x2000a0d0
 8025190:	2000a0d8 	.word	0x2000a0d8
 8025194:	08025529 	.word	0x08025529
 8025198:	2000a0e0 	.word	0x2000a0e0
 802519c:	20009f90 	.word	0x20009f90
 80251a0:	2000a084 	.word	0x2000a084
 80251a4:	08030c00 	.word	0x08030c00
 80251a8:	200000a4 	.word	0x200000a4

080251ac <sm_handle_encryption_result_enc_a>:

// sm_aes128_state stays active
static void sm_handle_encryption_result_enc_a(void *arg){
 80251ac:	b580      	push	{r7, lr}
 80251ae:	b086      	sub	sp, #24
 80251b0:	af02      	add	r7, sp, #8
 80251b2:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 80251b4:	687b      	ldr	r3, [r7, #4]
 80251b6:	81fb      	strh	r3, [r7, #14]
    sm_aes128_state = SM_AES128_IDLE;
 80251b8:	4b1a      	ldr	r3, [pc, #104]	; (8025224 <sm_handle_encryption_result_enc_a+0x78>)
 80251ba:	2200      	movs	r2, #0
 80251bc:	701a      	strb	r2, [r3, #0]

    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 80251be:	89fb      	ldrh	r3, [r7, #14]
 80251c0:	4618      	mov	r0, r3
 80251c2:	f001 ffd5 	bl	8027170 <sm_get_connection_for_handle>
 80251c6:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 80251c8:	68bb      	ldr	r3, [r7, #8]
 80251ca:	2b00      	cmp	r3, #0
 80251cc:	d026      	beq.n	802521c <sm_handle_encryption_result_enc_a+0x70>

    sm_c1_t3(sm_aes128_ciphertext, setup->sm_m_address, setup->sm_s_address, setup->sm_c1_t3_value);
 80251ce:	4b16      	ldr	r3, [pc, #88]	; (8025228 <sm_handle_encryption_result_enc_a+0x7c>)
 80251d0:	681b      	ldr	r3, [r3, #0]
 80251d2:	f103 0189 	add.w	r1, r3, #137	; 0x89
 80251d6:	4b14      	ldr	r3, [pc, #80]	; (8025228 <sm_handle_encryption_result_enc_a+0x7c>)
 80251d8:	681b      	ldr	r3, [r3, #0]
 80251da:	f103 028f 	add.w	r2, r3, #143	; 0x8f
 80251de:	4b12      	ldr	r3, [pc, #72]	; (8025228 <sm_handle_encryption_result_enc_a+0x7c>)
 80251e0:	681b      	ldr	r3, [r3, #0]
 80251e2:	3329      	adds	r3, #41	; 0x29
 80251e4:	4811      	ldr	r0, [pc, #68]	; (802522c <sm_handle_encryption_result_enc_a+0x80>)
 80251e6:	f7fc fbc9 	bl	802197c <sm_c1_t3>
    sm_aes128_state = SM_AES128_ACTIVE;
 80251ea:	4b0e      	ldr	r3, [pc, #56]	; (8025224 <sm_handle_encryption_result_enc_a+0x78>)
 80251ec:	2201      	movs	r2, #1
 80251ee:	701a      	strb	r2, [r3, #0]
    btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, setup->sm_tk, setup->sm_c1_t3_value, setup->sm_local_confirm, sm_handle_encryption_result_enc_b, (void *)(uintptr_t) connection->sm_handle);
 80251f0:	4b0d      	ldr	r3, [pc, #52]	; (8025228 <sm_handle_encryption_result_enc_a+0x7c>)
 80251f2:	681b      	ldr	r3, [r3, #0]
 80251f4:	f103 0117 	add.w	r1, r3, #23
 80251f8:	4b0b      	ldr	r3, [pc, #44]	; (8025228 <sm_handle_encryption_result_enc_a+0x7c>)
 80251fa:	681b      	ldr	r3, [r3, #0]
 80251fc:	f103 0229 	add.w	r2, r3, #41	; 0x29
 8025200:	4b09      	ldr	r3, [pc, #36]	; (8025228 <sm_handle_encryption_result_enc_a+0x7c>)
 8025202:	681b      	ldr	r3, [r3, #0]
 8025204:	f103 0057 	add.w	r0, r3, #87	; 0x57
 8025208:	68bb      	ldr	r3, [r7, #8]
 802520a:	881b      	ldrh	r3, [r3, #0]
 802520c:	9301      	str	r3, [sp, #4]
 802520e:	4b08      	ldr	r3, [pc, #32]	; (8025230 <sm_handle_encryption_result_enc_a+0x84>)
 8025210:	9300      	str	r3, [sp, #0]
 8025212:	4603      	mov	r3, r0
 8025214:	4807      	ldr	r0, [pc, #28]	; (8025234 <sm_handle_encryption_result_enc_a+0x88>)
 8025216:	f7e9 f935 	bl	800e484 <btstack_crypto_aes128_encrypt>
 802521a:	e000      	b.n	802521e <sm_handle_encryption_result_enc_a+0x72>
    if (connection == NULL) return;
 802521c:	bf00      	nop
}
 802521e:	3710      	adds	r7, #16
 8025220:	46bd      	mov	sp, r7
 8025222:	bd80      	pop	{r7, pc}
 8025224:	2000a068 	.word	0x2000a068
 8025228:	200000a0 	.word	0x200000a0
 802522c:	2000a0e0 	.word	0x2000a0e0
 8025230:	08025239 	.word	0x08025239
 8025234:	2000a084 	.word	0x2000a084

08025238 <sm_handle_encryption_result_enc_b>:

static void sm_handle_encryption_result_enc_b(void *arg){
 8025238:	b580      	push	{r7, lr}
 802523a:	b084      	sub	sp, #16
 802523c:	af00      	add	r7, sp, #0
 802523e:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 8025240:	687b      	ldr	r3, [r7, #4]
 8025242:	81fb      	strh	r3, [r7, #14]
    sm_aes128_state = SM_AES128_IDLE;
 8025244:	4b0d      	ldr	r3, [pc, #52]	; (802527c <sm_handle_encryption_result_enc_b+0x44>)
 8025246:	2200      	movs	r2, #0
 8025248:	701a      	strb	r2, [r3, #0]

    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 802524a:	89fb      	ldrh	r3, [r7, #14]
 802524c:	4618      	mov	r0, r3
 802524e:	f001 ff8f 	bl	8027170 <sm_get_connection_for_handle>
 8025252:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 8025254:	68bb      	ldr	r3, [r7, #8]
 8025256:	2b00      	cmp	r3, #0
 8025258:	d00c      	beq.n	8025274 <sm_handle_encryption_result_enc_b+0x3c>

    log_info_key("c1!", setup->sm_local_confirm);
 802525a:	4b09      	ldr	r3, [pc, #36]	; (8025280 <sm_handle_encryption_result_enc_b+0x48>)
 802525c:	681b      	ldr	r3, [r3, #0]
 802525e:	3357      	adds	r3, #87	; 0x57
 8025260:	4619      	mov	r1, r3
 8025262:	4808      	ldr	r0, [pc, #32]	; (8025284 <sm_handle_encryption_result_enc_b+0x4c>)
 8025264:	f7ea f886 	bl	800f374 <log_info_key>
    connection->sm_engine_state = SM_PH2_C1_SEND_PAIRING_CONFIRM;
 8025268:	68bb      	ldr	r3, [r7, #8]
 802526a:	220f      	movs	r2, #15
 802526c:	731a      	strb	r2, [r3, #12]
    sm_trigger_run();
 802526e:	f7fb ff9f 	bl	80211b0 <sm_trigger_run>
 8025272:	e000      	b.n	8025276 <sm_handle_encryption_result_enc_b+0x3e>
    if (connection == NULL) return;
 8025274:	bf00      	nop
}
 8025276:	3710      	adds	r7, #16
 8025278:	46bd      	mov	sp, r7
 802527a:	bd80      	pop	{r7, pc}
 802527c:	2000a068 	.word	0x2000a068
 8025280:	200000a0 	.word	0x200000a0
 8025284:	0802df48 	.word	0x0802df48

08025288 <sm_handle_encryption_result_enc_c>:

// sm_aes128_state stays active
static void sm_handle_encryption_result_enc_c(void *arg){
 8025288:	b580      	push	{r7, lr}
 802528a:	b086      	sub	sp, #24
 802528c:	af02      	add	r7, sp, #8
 802528e:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 8025290:	687b      	ldr	r3, [r7, #4]
 8025292:	81fb      	strh	r3, [r7, #14]
    sm_aes128_state = SM_AES128_IDLE;
 8025294:	4b18      	ldr	r3, [pc, #96]	; (80252f8 <sm_handle_encryption_result_enc_c+0x70>)
 8025296:	2200      	movs	r2, #0
 8025298:	701a      	strb	r2, [r3, #0]

    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 802529a:	89fb      	ldrh	r3, [r7, #14]
 802529c:	4618      	mov	r0, r3
 802529e:	f001 ff67 	bl	8027170 <sm_get_connection_for_handle>
 80252a2:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 80252a4:	68bb      	ldr	r3, [r7, #8]
 80252a6:	2b00      	cmp	r3, #0
 80252a8:	d022      	beq.n	80252f0 <sm_handle_encryption_result_enc_c+0x68>

    sm_c1_t3(sm_aes128_ciphertext, setup->sm_m_address, setup->sm_s_address, setup->sm_c1_t3_value);
 80252aa:	4b14      	ldr	r3, [pc, #80]	; (80252fc <sm_handle_encryption_result_enc_c+0x74>)
 80252ac:	681b      	ldr	r3, [r3, #0]
 80252ae:	f103 0189 	add.w	r1, r3, #137	; 0x89
 80252b2:	4b12      	ldr	r3, [pc, #72]	; (80252fc <sm_handle_encryption_result_enc_c+0x74>)
 80252b4:	681b      	ldr	r3, [r3, #0]
 80252b6:	f103 028f 	add.w	r2, r3, #143	; 0x8f
 80252ba:	4b10      	ldr	r3, [pc, #64]	; (80252fc <sm_handle_encryption_result_enc_c+0x74>)
 80252bc:	681b      	ldr	r3, [r3, #0]
 80252be:	3329      	adds	r3, #41	; 0x29
 80252c0:	480f      	ldr	r0, [pc, #60]	; (8025300 <sm_handle_encryption_result_enc_c+0x78>)
 80252c2:	f7fc fb5b 	bl	802197c <sm_c1_t3>
    sm_aes128_state = SM_AES128_ACTIVE;
 80252c6:	4b0c      	ldr	r3, [pc, #48]	; (80252f8 <sm_handle_encryption_result_enc_c+0x70>)
 80252c8:	2201      	movs	r2, #1
 80252ca:	701a      	strb	r2, [r3, #0]
    btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, setup->sm_tk, setup->sm_c1_t3_value, sm_aes128_ciphertext, sm_handle_encryption_result_enc_d, (void *)(uintptr_t) connection->sm_handle);
 80252cc:	4b0b      	ldr	r3, [pc, #44]	; (80252fc <sm_handle_encryption_result_enc_c+0x74>)
 80252ce:	681b      	ldr	r3, [r3, #0]
 80252d0:	f103 0117 	add.w	r1, r3, #23
 80252d4:	4b09      	ldr	r3, [pc, #36]	; (80252fc <sm_handle_encryption_result_enc_c+0x74>)
 80252d6:	681b      	ldr	r3, [r3, #0]
 80252d8:	f103 0229 	add.w	r2, r3, #41	; 0x29
 80252dc:	68bb      	ldr	r3, [r7, #8]
 80252de:	881b      	ldrh	r3, [r3, #0]
 80252e0:	9301      	str	r3, [sp, #4]
 80252e2:	4b08      	ldr	r3, [pc, #32]	; (8025304 <sm_handle_encryption_result_enc_c+0x7c>)
 80252e4:	9300      	str	r3, [sp, #0]
 80252e6:	4b06      	ldr	r3, [pc, #24]	; (8025300 <sm_handle_encryption_result_enc_c+0x78>)
 80252e8:	4807      	ldr	r0, [pc, #28]	; (8025308 <sm_handle_encryption_result_enc_c+0x80>)
 80252ea:	f7e9 f8cb 	bl	800e484 <btstack_crypto_aes128_encrypt>
 80252ee:	e000      	b.n	80252f2 <sm_handle_encryption_result_enc_c+0x6a>
    if (connection == NULL) return;
 80252f0:	bf00      	nop
}
 80252f2:	3710      	adds	r7, #16
 80252f4:	46bd      	mov	sp, r7
 80252f6:	bd80      	pop	{r7, pc}
 80252f8:	2000a068 	.word	0x2000a068
 80252fc:	200000a0 	.word	0x200000a0
 8025300:	2000a0e0 	.word	0x2000a0e0
 8025304:	0802530d 	.word	0x0802530d
 8025308:	2000a084 	.word	0x2000a084

0802530c <sm_handle_encryption_result_enc_d>:

static void sm_handle_encryption_result_enc_d(void * arg){
 802530c:	b580      	push	{r7, lr}
 802530e:	b086      	sub	sp, #24
 8025310:	af02      	add	r7, sp, #8
 8025312:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 8025314:	687b      	ldr	r3, [r7, #4]
 8025316:	81fb      	strh	r3, [r7, #14]
    sm_aes128_state = SM_AES128_IDLE;
 8025318:	4b29      	ldr	r3, [pc, #164]	; (80253c0 <sm_handle_encryption_result_enc_d+0xb4>)
 802531a:	2200      	movs	r2, #0
 802531c:	701a      	strb	r2, [r3, #0]

    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 802531e:	89fb      	ldrh	r3, [r7, #14]
 8025320:	4618      	mov	r0, r3
 8025322:	f001 ff25 	bl	8027170 <sm_get_connection_for_handle>
 8025326:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 8025328:	68bb      	ldr	r3, [r7, #8]
 802532a:	2b00      	cmp	r3, #0
 802532c:	d043      	beq.n	80253b6 <sm_handle_encryption_result_enc_d+0xaa>

    log_info_key("c1!", sm_aes128_ciphertext);
 802532e:	4925      	ldr	r1, [pc, #148]	; (80253c4 <sm_handle_encryption_result_enc_d+0xb8>)
 8025330:	4825      	ldr	r0, [pc, #148]	; (80253c8 <sm_handle_encryption_result_enc_d+0xbc>)
 8025332:	f7ea f81f 	bl	800f374 <log_info_key>
    if (memcmp(setup->sm_peer_confirm, sm_aes128_ciphertext, 16) != 0){
 8025336:	4b25      	ldr	r3, [pc, #148]	; (80253cc <sm_handle_encryption_result_enc_d+0xc0>)
 8025338:	681b      	ldr	r3, [r3, #0]
 802533a:	3377      	adds	r3, #119	; 0x77
 802533c:	2210      	movs	r2, #16
 802533e:	4921      	ldr	r1, [pc, #132]	; (80253c4 <sm_handle_encryption_result_enc_d+0xb8>)
 8025340:	4618      	mov	r0, r3
 8025342:	f002 fb8b 	bl	8027a5c <memcmp>
 8025346:	4603      	mov	r3, r0
 8025348:	2b00      	cmp	r3, #0
 802534a:	d009      	beq.n	8025360 <sm_handle_encryption_result_enc_d+0x54>
        setup->sm_pairing_failed_reason = SM_REASON_CONFIRM_VALUE_FAILED;
 802534c:	4b1f      	ldr	r3, [pc, #124]	; (80253cc <sm_handle_encryption_result_enc_d+0xc0>)
 802534e:	681b      	ldr	r3, [r3, #0]
 8025350:	2204      	movs	r2, #4
 8025352:	741a      	strb	r2, [r3, #16]
        connection->sm_engine_state = SM_GENERAL_SEND_PAIRING_FAILED;
 8025354:	68bb      	ldr	r3, [r7, #8]
 8025356:	2201      	movs	r2, #1
 8025358:	731a      	strb	r2, [r3, #12]
        sm_trigger_run();
 802535a:	f7fb ff29 	bl	80211b0 <sm_trigger_run>
        return;
 802535e:	e02b      	b.n	80253b8 <sm_handle_encryption_result_enc_d+0xac>
    }
    if (IS_RESPONDER(connection->sm_role)){
 8025360:	68bb      	ldr	r3, [r7, #8]
 8025362:	789b      	ldrb	r3, [r3, #2]
 8025364:	2b00      	cmp	r3, #0
 8025366:	d005      	beq.n	8025374 <sm_handle_encryption_result_enc_d+0x68>
        connection->sm_engine_state = SM_PH2_SEND_PAIRING_RANDOM;
 8025368:	68bb      	ldr	r3, [r7, #8]
 802536a:	2210      	movs	r2, #16
 802536c:	731a      	strb	r2, [r3, #12]
        sm_trigger_run();
 802536e:	f7fb ff1f 	bl	80211b0 <sm_trigger_run>
 8025372:	e021      	b.n	80253b8 <sm_handle_encryption_result_enc_d+0xac>
    } else {
        sm_s1_r_prime(setup->sm_peer_random, setup->sm_local_random, sm_aes128_plaintext);
 8025374:	4b15      	ldr	r3, [pc, #84]	; (80253cc <sm_handle_encryption_result_enc_d+0xc0>)
 8025376:	681b      	ldr	r3, [r3, #0]
 8025378:	f103 0067 	add.w	r0, r3, #103	; 0x67
 802537c:	4b13      	ldr	r3, [pc, #76]	; (80253cc <sm_handle_encryption_result_enc_d+0xc0>)
 802537e:	681b      	ldr	r3, [r3, #0]
 8025380:	3347      	adds	r3, #71	; 0x47
 8025382:	4a13      	ldr	r2, [pc, #76]	; (80253d0 <sm_handle_encryption_result_enc_d+0xc4>)
 8025384:	4619      	mov	r1, r3
 8025386:	f7fc fb41 	bl	8021a0c <sm_s1_r_prime>
        sm_aes128_state = SM_AES128_ACTIVE;
 802538a:	4b0d      	ldr	r3, [pc, #52]	; (80253c0 <sm_handle_encryption_result_enc_d+0xb4>)
 802538c:	2201      	movs	r2, #1
 802538e:	701a      	strb	r2, [r3, #0]
        btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, setup->sm_tk, sm_aes128_plaintext, setup->sm_ltk, sm_handle_encryption_result_enc_stk, (void *)(uintptr_t) connection->sm_handle);
 8025390:	4b0e      	ldr	r3, [pc, #56]	; (80253cc <sm_handle_encryption_result_enc_d+0xc0>)
 8025392:	681b      	ldr	r3, [r3, #0]
 8025394:	f103 0117 	add.w	r1, r3, #23
 8025398:	4b0c      	ldr	r3, [pc, #48]	; (80253cc <sm_handle_encryption_result_enc_d+0xc0>)
 802539a:	681b      	ldr	r3, [r3, #0]
 802539c:	f103 0295 	add.w	r2, r3, #149	; 0x95
 80253a0:	68bb      	ldr	r3, [r7, #8]
 80253a2:	881b      	ldrh	r3, [r3, #0]
 80253a4:	9301      	str	r3, [sp, #4]
 80253a6:	4b0b      	ldr	r3, [pc, #44]	; (80253d4 <sm_handle_encryption_result_enc_d+0xc8>)
 80253a8:	9300      	str	r3, [sp, #0]
 80253aa:	4613      	mov	r3, r2
 80253ac:	4a08      	ldr	r2, [pc, #32]	; (80253d0 <sm_handle_encryption_result_enc_d+0xc4>)
 80253ae:	480a      	ldr	r0, [pc, #40]	; (80253d8 <sm_handle_encryption_result_enc_d+0xcc>)
 80253b0:	f7e9 f868 	bl	800e484 <btstack_crypto_aes128_encrypt>
 80253b4:	e000      	b.n	80253b8 <sm_handle_encryption_result_enc_d+0xac>
    if (connection == NULL) return;
 80253b6:	bf00      	nop
    }
}
 80253b8:	3710      	adds	r7, #16
 80253ba:	46bd      	mov	sp, r7
 80253bc:	bd80      	pop	{r7, pc}
 80253be:	bf00      	nop
 80253c0:	2000a068 	.word	0x2000a068
 80253c4:	2000a0e0 	.word	0x2000a0e0
 80253c8:	0802df48 	.word	0x0802df48
 80253cc:	200000a0 	.word	0x200000a0
 80253d0:	2000a0d0 	.word	0x2000a0d0
 80253d4:	080253dd 	.word	0x080253dd
 80253d8:	2000a084 	.word	0x2000a084

080253dc <sm_handle_encryption_result_enc_stk>:

static void sm_handle_encryption_result_enc_stk(void *arg){
 80253dc:	b580      	push	{r7, lr}
 80253de:	b084      	sub	sp, #16
 80253e0:	af00      	add	r7, sp, #0
 80253e2:	6078      	str	r0, [r7, #4]
    sm_aes128_state = SM_AES128_IDLE;
 80253e4:	4b17      	ldr	r3, [pc, #92]	; (8025444 <sm_handle_encryption_result_enc_stk+0x68>)
 80253e6:	2200      	movs	r2, #0
 80253e8:	701a      	strb	r2, [r3, #0]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 80253ea:	687b      	ldr	r3, [r7, #4]
 80253ec:	81fb      	strh	r3, [r7, #14]

    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 80253ee:	89fb      	ldrh	r3, [r7, #14]
 80253f0:	4618      	mov	r0, r3
 80253f2:	f001 febd 	bl	8027170 <sm_get_connection_for_handle>
 80253f6:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 80253f8:	68bb      	ldr	r3, [r7, #8]
 80253fa:	2b00      	cmp	r3, #0
 80253fc:	d01e      	beq.n	802543c <sm_handle_encryption_result_enc_stk+0x60>

    sm_truncate_key(setup->sm_ltk, connection->sm_actual_encryption_key_size);
 80253fe:	4b12      	ldr	r3, [pc, #72]	; (8025448 <sm_handle_encryption_result_enc_stk+0x6c>)
 8025400:	681b      	ldr	r3, [r3, #0]
 8025402:	f103 0295 	add.w	r2, r3, #149	; 0x95
 8025406:	68bb      	ldr	r3, [r7, #8]
 8025408:	7c5b      	ldrb	r3, [r3, #17]
 802540a:	4619      	mov	r1, r3
 802540c:	4610      	mov	r0, r2
 802540e:	f7fb ff05 	bl	802121c <sm_truncate_key>
    log_info_key("stk", setup->sm_ltk);
 8025412:	4b0d      	ldr	r3, [pc, #52]	; (8025448 <sm_handle_encryption_result_enc_stk+0x6c>)
 8025414:	681b      	ldr	r3, [r3, #0]
 8025416:	3395      	adds	r3, #149	; 0x95
 8025418:	4619      	mov	r1, r3
 802541a:	480c      	ldr	r0, [pc, #48]	; (802544c <sm_handle_encryption_result_enc_stk+0x70>)
 802541c:	f7e9 ffaa 	bl	800f374 <log_info_key>
    if (IS_RESPONDER(connection->sm_role)){
 8025420:	68bb      	ldr	r3, [r7, #8]
 8025422:	789b      	ldrb	r3, [r3, #2]
 8025424:	2b00      	cmp	r3, #0
 8025426:	d003      	beq.n	8025430 <sm_handle_encryption_result_enc_stk+0x54>
        connection->sm_engine_state = SM_RESPONDER_PH2_SEND_LTK_REPLY;
 8025428:	68bb      	ldr	r3, [r7, #8]
 802542a:	2226      	movs	r2, #38	; 0x26
 802542c:	731a      	strb	r2, [r3, #12]
 802542e:	e002      	b.n	8025436 <sm_handle_encryption_result_enc_stk+0x5a>
    } else {
        connection->sm_engine_state = SM_INITIATOR_PH3_SEND_START_ENCRYPTION;
 8025430:	68bb      	ldr	r3, [r7, #8]
 8025432:	222e      	movs	r2, #46	; 0x2e
 8025434:	731a      	strb	r2, [r3, #12]
    }
    sm_trigger_run();
 8025436:	f7fb febb 	bl	80211b0 <sm_trigger_run>
 802543a:	e000      	b.n	802543e <sm_handle_encryption_result_enc_stk+0x62>
    if (connection == NULL) return;
 802543c:	bf00      	nop
}
 802543e:	3710      	adds	r7, #16
 8025440:	46bd      	mov	sp, r7
 8025442:	bd80      	pop	{r7, pc}
 8025444:	2000a068 	.word	0x2000a068
 8025448:	200000a0 	.word	0x200000a0
 802544c:	0802df4c 	.word	0x0802df4c

08025450 <sm_handle_encryption_result_enc_ph3_y>:

// sm_aes128_state stays active
static void sm_handle_encryption_result_enc_ph3_y(void *arg){
 8025450:	b580      	push	{r7, lr}
 8025452:	b086      	sub	sp, #24
 8025454:	af02      	add	r7, sp, #8
 8025456:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 8025458:	687b      	ldr	r3, [r7, #4]
 802545a:	81fb      	strh	r3, [r7, #14]
    sm_aes128_state = SM_AES128_IDLE;
 802545c:	4b29      	ldr	r3, [pc, #164]	; (8025504 <sm_handle_encryption_result_enc_ph3_y+0xb4>)
 802545e:	2200      	movs	r2, #0
 8025460:	701a      	strb	r2, [r3, #0]

    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 8025462:	89fb      	ldrh	r3, [r7, #14]
 8025464:	4618      	mov	r0, r3
 8025466:	f001 fe83 	bl	8027170 <sm_get_connection_for_handle>
 802546a:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 802546c:	68bb      	ldr	r3, [r7, #8]
 802546e:	2b00      	cmp	r3, #0
 8025470:	d043      	beq.n	80254fa <sm_handle_encryption_result_enc_ph3_y+0xaa>

    setup->sm_local_y = big_endian_read_16(sm_aes128_ciphertext, 14);
 8025472:	210e      	movs	r1, #14
 8025474:	4824      	ldr	r0, [pc, #144]	; (8025508 <sm_handle_encryption_result_enc_ph3_y+0xb8>)
 8025476:	f7e9 fd4c 	bl	800ef12 <big_endian_read_16>
 802547a:	4602      	mov	r2, r0
 802547c:	4b23      	ldr	r3, [pc, #140]	; (802550c <sm_handle_encryption_result_enc_ph3_y+0xbc>)
 802547e:	681b      	ldr	r3, [r3, #0]
 8025480:	b292      	uxth	r2, r2
 8025482:	f8a3 2188 	strh.w	r2, [r3, #392]	; 0x188
    log_info_hex16("y", setup->sm_local_y);
 8025486:	4b21      	ldr	r3, [pc, #132]	; (802550c <sm_handle_encryption_result_enc_ph3_y+0xbc>)
 8025488:	681b      	ldr	r3, [r3, #0]
 802548a:	f8b3 3188 	ldrh.w	r3, [r3, #392]	; 0x188
 802548e:	4619      	mov	r1, r3
 8025490:	481f      	ldr	r0, [pc, #124]	; (8025510 <sm_handle_encryption_result_enc_ph3_y+0xc0>)
 8025492:	f7fb fd79 	bl	8020f88 <log_info_hex16>
    // PH3B3 - calculate EDIV
    setup->sm_local_ediv = setup->sm_local_y ^ setup->sm_local_div;
 8025496:	4b1d      	ldr	r3, [pc, #116]	; (802550c <sm_handle_encryption_result_enc_ph3_y+0xbc>)
 8025498:	681b      	ldr	r3, [r3, #0]
 802549a:	f8b3 1188 	ldrh.w	r1, [r3, #392]	; 0x188
 802549e:	4b1b      	ldr	r3, [pc, #108]	; (802550c <sm_handle_encryption_result_enc_ph3_y+0xbc>)
 80254a0:	681b      	ldr	r3, [r3, #0]
 80254a2:	f8b3 218a 	ldrh.w	r2, [r3, #394]	; 0x18a
 80254a6:	4b19      	ldr	r3, [pc, #100]	; (802550c <sm_handle_encryption_result_enc_ph3_y+0xbc>)
 80254a8:	681b      	ldr	r3, [r3, #0]
 80254aa:	404a      	eors	r2, r1
 80254ac:	b292      	uxth	r2, r2
 80254ae:	f8a3 218c 	strh.w	r2, [r3, #396]	; 0x18c
    log_info_hex16("ediv", setup->sm_local_ediv);
 80254b2:	4b16      	ldr	r3, [pc, #88]	; (802550c <sm_handle_encryption_result_enc_ph3_y+0xbc>)
 80254b4:	681b      	ldr	r3, [r3, #0]
 80254b6:	f8b3 318c 	ldrh.w	r3, [r3, #396]	; 0x18c
 80254ba:	4619      	mov	r1, r3
 80254bc:	4815      	ldr	r0, [pc, #84]	; (8025514 <sm_handle_encryption_result_enc_ph3_y+0xc4>)
 80254be:	f7fb fd63 	bl	8020f88 <log_info_hex16>
    // PH3B4 - calculate LTK         - enc
    // LTK = d1(ER, DIV, 0))
    sm_d1_d_prime(setup->sm_local_div, 0, sm_aes128_plaintext);
 80254c2:	4b12      	ldr	r3, [pc, #72]	; (802550c <sm_handle_encryption_result_enc_ph3_y+0xbc>)
 80254c4:	681b      	ldr	r3, [r3, #0]
 80254c6:	f8b3 318a 	ldrh.w	r3, [r3, #394]	; 0x18a
 80254ca:	4a13      	ldr	r2, [pc, #76]	; (8025518 <sm_handle_encryption_result_enc_ph3_y+0xc8>)
 80254cc:	2100      	movs	r1, #0
 80254ce:	4618      	mov	r0, r3
 80254d0:	f7fc f9eb 	bl	80218aa <sm_d1_d_prime>
    sm_aes128_state = SM_AES128_ACTIVE;
 80254d4:	4b0b      	ldr	r3, [pc, #44]	; (8025504 <sm_handle_encryption_result_enc_ph3_y+0xb4>)
 80254d6:	2201      	movs	r2, #1
 80254d8:	701a      	strb	r2, [r3, #0]
    btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, sm_persistent_er, sm_aes128_plaintext, setup->sm_ltk, sm_handle_encryption_result_enc_ph3_ltk, (void *)(uintptr_t) connection->sm_handle);
 80254da:	4b0c      	ldr	r3, [pc, #48]	; (802550c <sm_handle_encryption_result_enc_ph3_y+0xbc>)
 80254dc:	681b      	ldr	r3, [r3, #0]
 80254de:	f103 0295 	add.w	r2, r3, #149	; 0x95
 80254e2:	68bb      	ldr	r3, [r7, #8]
 80254e4:	881b      	ldrh	r3, [r3, #0]
 80254e6:	9301      	str	r3, [sp, #4]
 80254e8:	4b0c      	ldr	r3, [pc, #48]	; (802551c <sm_handle_encryption_result_enc_ph3_y+0xcc>)
 80254ea:	9300      	str	r3, [sp, #0]
 80254ec:	4613      	mov	r3, r2
 80254ee:	4a0a      	ldr	r2, [pc, #40]	; (8025518 <sm_handle_encryption_result_enc_ph3_y+0xc8>)
 80254f0:	490b      	ldr	r1, [pc, #44]	; (8025520 <sm_handle_encryption_result_enc_ph3_y+0xd0>)
 80254f2:	480c      	ldr	r0, [pc, #48]	; (8025524 <sm_handle_encryption_result_enc_ph3_y+0xd4>)
 80254f4:	f7e8 ffc6 	bl	800e484 <btstack_crypto_aes128_encrypt>
 80254f8:	e000      	b.n	80254fc <sm_handle_encryption_result_enc_ph3_y+0xac>
    if (connection == NULL) return;
 80254fa:	bf00      	nop
}
 80254fc:	3710      	adds	r7, #16
 80254fe:	46bd      	mov	sp, r7
 8025500:	bd80      	pop	{r7, pc}
 8025502:	bf00      	nop
 8025504:	2000a068 	.word	0x2000a068
 8025508:	2000a0e0 	.word	0x2000a0e0
 802550c:	200000a0 	.word	0x200000a0
 8025510:	0802df50 	.word	0x0802df50
 8025514:	0802df54 	.word	0x0802df54
 8025518:	2000a0d0 	.word	0x2000a0d0
 802551c:	08025601 	.word	0x08025601
 8025520:	20009f70 	.word	0x20009f70
 8025524:	2000a084 	.word	0x2000a084

08025528 <sm_handle_encryption_result_enc_ph4_y>:

#ifdef ENABLE_LE_PERIPHERAL
// sm_aes128_state stays active
static void sm_handle_encryption_result_enc_ph4_y(void *arg){
 8025528:	b580      	push	{r7, lr}
 802552a:	b086      	sub	sp, #24
 802552c:	af02      	add	r7, sp, #8
 802552e:	6078      	str	r0, [r7, #4]
    sm_aes128_state = SM_AES128_IDLE;
 8025530:	4b2a      	ldr	r3, [pc, #168]	; (80255dc <sm_handle_encryption_result_enc_ph4_y+0xb4>)
 8025532:	2200      	movs	r2, #0
 8025534:	701a      	strb	r2, [r3, #0]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 8025536:	687b      	ldr	r3, [r7, #4]
 8025538:	81fb      	strh	r3, [r7, #14]

    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 802553a:	89fb      	ldrh	r3, [r7, #14]
 802553c:	4618      	mov	r0, r3
 802553e:	f001 fe17 	bl	8027170 <sm_get_connection_for_handle>
 8025542:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 8025544:	68bb      	ldr	r3, [r7, #8]
 8025546:	2b00      	cmp	r3, #0
 8025548:	d043      	beq.n	80255d2 <sm_handle_encryption_result_enc_ph4_y+0xaa>

    setup->sm_local_y = big_endian_read_16(sm_aes128_ciphertext, 14);
 802554a:	210e      	movs	r1, #14
 802554c:	4824      	ldr	r0, [pc, #144]	; (80255e0 <sm_handle_encryption_result_enc_ph4_y+0xb8>)
 802554e:	f7e9 fce0 	bl	800ef12 <big_endian_read_16>
 8025552:	4602      	mov	r2, r0
 8025554:	4b23      	ldr	r3, [pc, #140]	; (80255e4 <sm_handle_encryption_result_enc_ph4_y+0xbc>)
 8025556:	681b      	ldr	r3, [r3, #0]
 8025558:	b292      	uxth	r2, r2
 802555a:	f8a3 2188 	strh.w	r2, [r3, #392]	; 0x188
    log_info_hex16("y", setup->sm_local_y);
 802555e:	4b21      	ldr	r3, [pc, #132]	; (80255e4 <sm_handle_encryption_result_enc_ph4_y+0xbc>)
 8025560:	681b      	ldr	r3, [r3, #0]
 8025562:	f8b3 3188 	ldrh.w	r3, [r3, #392]	; 0x188
 8025566:	4619      	mov	r1, r3
 8025568:	481f      	ldr	r0, [pc, #124]	; (80255e8 <sm_handle_encryption_result_enc_ph4_y+0xc0>)
 802556a:	f7fb fd0d 	bl	8020f88 <log_info_hex16>

    // PH3B3 - calculate DIV
    setup->sm_local_div = setup->sm_local_y ^ setup->sm_local_ediv;
 802556e:	4b1d      	ldr	r3, [pc, #116]	; (80255e4 <sm_handle_encryption_result_enc_ph4_y+0xbc>)
 8025570:	681b      	ldr	r3, [r3, #0]
 8025572:	f8b3 1188 	ldrh.w	r1, [r3, #392]	; 0x188
 8025576:	4b1b      	ldr	r3, [pc, #108]	; (80255e4 <sm_handle_encryption_result_enc_ph4_y+0xbc>)
 8025578:	681b      	ldr	r3, [r3, #0]
 802557a:	f8b3 218c 	ldrh.w	r2, [r3, #396]	; 0x18c
 802557e:	4b19      	ldr	r3, [pc, #100]	; (80255e4 <sm_handle_encryption_result_enc_ph4_y+0xbc>)
 8025580:	681b      	ldr	r3, [r3, #0]
 8025582:	404a      	eors	r2, r1
 8025584:	b292      	uxth	r2, r2
 8025586:	f8a3 218a 	strh.w	r2, [r3, #394]	; 0x18a
    log_info_hex16("ediv", setup->sm_local_ediv);
 802558a:	4b16      	ldr	r3, [pc, #88]	; (80255e4 <sm_handle_encryption_result_enc_ph4_y+0xbc>)
 802558c:	681b      	ldr	r3, [r3, #0]
 802558e:	f8b3 318c 	ldrh.w	r3, [r3, #396]	; 0x18c
 8025592:	4619      	mov	r1, r3
 8025594:	4815      	ldr	r0, [pc, #84]	; (80255ec <sm_handle_encryption_result_enc_ph4_y+0xc4>)
 8025596:	f7fb fcf7 	bl	8020f88 <log_info_hex16>
    // PH3B4 - calculate LTK         - enc
    // LTK = d1(ER, DIV, 0))
    sm_d1_d_prime(setup->sm_local_div, 0, sm_aes128_plaintext);
 802559a:	4b12      	ldr	r3, [pc, #72]	; (80255e4 <sm_handle_encryption_result_enc_ph4_y+0xbc>)
 802559c:	681b      	ldr	r3, [r3, #0]
 802559e:	f8b3 318a 	ldrh.w	r3, [r3, #394]	; 0x18a
 80255a2:	4a13      	ldr	r2, [pc, #76]	; (80255f0 <sm_handle_encryption_result_enc_ph4_y+0xc8>)
 80255a4:	2100      	movs	r1, #0
 80255a6:	4618      	mov	r0, r3
 80255a8:	f7fc f97f 	bl	80218aa <sm_d1_d_prime>
    sm_aes128_state = SM_AES128_ACTIVE;
 80255ac:	4b0b      	ldr	r3, [pc, #44]	; (80255dc <sm_handle_encryption_result_enc_ph4_y+0xb4>)
 80255ae:	2201      	movs	r2, #1
 80255b0:	701a      	strb	r2, [r3, #0]
    btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, sm_persistent_er, sm_aes128_plaintext, setup->sm_ltk, sm_handle_encryption_result_enc_ph4_ltk, (void *)(uintptr_t) connection->sm_handle);
 80255b2:	4b0c      	ldr	r3, [pc, #48]	; (80255e4 <sm_handle_encryption_result_enc_ph4_y+0xbc>)
 80255b4:	681b      	ldr	r3, [r3, #0]
 80255b6:	f103 0295 	add.w	r2, r3, #149	; 0x95
 80255ba:	68bb      	ldr	r3, [r7, #8]
 80255bc:	881b      	ldrh	r3, [r3, #0]
 80255be:	9301      	str	r3, [sp, #4]
 80255c0:	4b0c      	ldr	r3, [pc, #48]	; (80255f4 <sm_handle_encryption_result_enc_ph4_y+0xcc>)
 80255c2:	9300      	str	r3, [sp, #0]
 80255c4:	4613      	mov	r3, r2
 80255c6:	4a0a      	ldr	r2, [pc, #40]	; (80255f0 <sm_handle_encryption_result_enc_ph4_y+0xc8>)
 80255c8:	490b      	ldr	r1, [pc, #44]	; (80255f8 <sm_handle_encryption_result_enc_ph4_y+0xd0>)
 80255ca:	480c      	ldr	r0, [pc, #48]	; (80255fc <sm_handle_encryption_result_enc_ph4_y+0xd4>)
 80255cc:	f7e8 ff5a 	bl	800e484 <btstack_crypto_aes128_encrypt>
 80255d0:	e000      	b.n	80255d4 <sm_handle_encryption_result_enc_ph4_y+0xac>
    if (connection == NULL) return;
 80255d2:	bf00      	nop
}
 80255d4:	3710      	adds	r7, #16
 80255d6:	46bd      	mov	sp, r7
 80255d8:	bd80      	pop	{r7, pc}
 80255da:	bf00      	nop
 80255dc:	2000a068 	.word	0x2000a068
 80255e0:	2000a0e0 	.word	0x2000a0e0
 80255e4:	200000a0 	.word	0x200000a0
 80255e8:	0802df50 	.word	0x0802df50
 80255ec:	0802df54 	.word	0x0802df54
 80255f0:	2000a0d0 	.word	0x2000a0d0
 80255f4:	0802576d 	.word	0x0802576d
 80255f8:	20009f70 	.word	0x20009f70
 80255fc:	2000a084 	.word	0x2000a084

08025600 <sm_handle_encryption_result_enc_ph3_ltk>:
#endif

// sm_aes128_state stays active
static void sm_handle_encryption_result_enc_ph3_ltk(void *arg){
 8025600:	b580      	push	{r7, lr}
 8025602:	b086      	sub	sp, #24
 8025604:	af02      	add	r7, sp, #8
 8025606:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 8025608:	687b      	ldr	r3, [r7, #4]
 802560a:	81fb      	strh	r3, [r7, #14]
    sm_aes128_state = SM_AES128_IDLE;
 802560c:	4b18      	ldr	r3, [pc, #96]	; (8025670 <sm_handle_encryption_result_enc_ph3_ltk+0x70>)
 802560e:	2200      	movs	r2, #0
 8025610:	701a      	strb	r2, [r3, #0]

    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 8025612:	89fb      	ldrh	r3, [r7, #14]
 8025614:	4618      	mov	r0, r3
 8025616:	f001 fdab 	bl	8027170 <sm_get_connection_for_handle>
 802561a:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 802561c:	68bb      	ldr	r3, [r7, #8]
 802561e:	2b00      	cmp	r3, #0
 8025620:	d022      	beq.n	8025668 <sm_handle_encryption_result_enc_ph3_ltk+0x68>

    log_info_key("ltk", setup->sm_ltk);
 8025622:	4b14      	ldr	r3, [pc, #80]	; (8025674 <sm_handle_encryption_result_enc_ph3_ltk+0x74>)
 8025624:	681b      	ldr	r3, [r3, #0]
 8025626:	3395      	adds	r3, #149	; 0x95
 8025628:	4619      	mov	r1, r3
 802562a:	4813      	ldr	r0, [pc, #76]	; (8025678 <sm_handle_encryption_result_enc_ph3_ltk+0x78>)
 802562c:	f7e9 fea2 	bl	800f374 <log_info_key>
    // calc CSRK next
    sm_d1_d_prime(setup->sm_local_div, 1, sm_aes128_plaintext);
 8025630:	4b10      	ldr	r3, [pc, #64]	; (8025674 <sm_handle_encryption_result_enc_ph3_ltk+0x74>)
 8025632:	681b      	ldr	r3, [r3, #0]
 8025634:	f8b3 318a 	ldrh.w	r3, [r3, #394]	; 0x18a
 8025638:	4a10      	ldr	r2, [pc, #64]	; (802567c <sm_handle_encryption_result_enc_ph3_ltk+0x7c>)
 802563a:	2101      	movs	r1, #1
 802563c:	4618      	mov	r0, r3
 802563e:	f7fc f934 	bl	80218aa <sm_d1_d_prime>
    sm_aes128_state = SM_AES128_ACTIVE;
 8025642:	4b0b      	ldr	r3, [pc, #44]	; (8025670 <sm_handle_encryption_result_enc_ph3_ltk+0x70>)
 8025644:	2201      	movs	r2, #1
 8025646:	701a      	strb	r2, [r3, #0]
    btstack_crypto_aes128_encrypt(&sm_crypto_aes128_request, sm_persistent_er, sm_aes128_plaintext, setup->sm_local_csrk, sm_handle_encryption_result_enc_csrk, (void *)(uintptr_t) connection->sm_handle);
 8025648:	4b0a      	ldr	r3, [pc, #40]	; (8025674 <sm_handle_encryption_result_enc_ph3_ltk+0x74>)
 802564a:	681b      	ldr	r3, [r3, #0]
 802564c:	f503 72d3 	add.w	r2, r3, #422	; 0x1a6
 8025650:	68bb      	ldr	r3, [r7, #8]
 8025652:	881b      	ldrh	r3, [r3, #0]
 8025654:	9301      	str	r3, [sp, #4]
 8025656:	4b0a      	ldr	r3, [pc, #40]	; (8025680 <sm_handle_encryption_result_enc_ph3_ltk+0x80>)
 8025658:	9300      	str	r3, [sp, #0]
 802565a:	4613      	mov	r3, r2
 802565c:	4a07      	ldr	r2, [pc, #28]	; (802567c <sm_handle_encryption_result_enc_ph3_ltk+0x7c>)
 802565e:	4909      	ldr	r1, [pc, #36]	; (8025684 <sm_handle_encryption_result_enc_ph3_ltk+0x84>)
 8025660:	4809      	ldr	r0, [pc, #36]	; (8025688 <sm_handle_encryption_result_enc_ph3_ltk+0x88>)
 8025662:	f7e8 ff0f 	bl	800e484 <btstack_crypto_aes128_encrypt>
 8025666:	e000      	b.n	802566a <sm_handle_encryption_result_enc_ph3_ltk+0x6a>
    if (connection == NULL) return;
 8025668:	bf00      	nop
}
 802566a:	3710      	adds	r7, #16
 802566c:	46bd      	mov	sp, r7
 802566e:	bd80      	pop	{r7, pc}
 8025670:	2000a068 	.word	0x2000a068
 8025674:	200000a0 	.word	0x200000a0
 8025678:	0802df5c 	.word	0x0802df5c
 802567c:	2000a0d0 	.word	0x2000a0d0
 8025680:	080256a5 	.word	0x080256a5
 8025684:	20009f70 	.word	0x20009f70
 8025688:	2000a084 	.word	0x2000a084

0802568c <sm_ctkd_from_le>:
static bool sm_ctkd_from_le(sm_connection_t *sm_connection) {
 802568c:	b480      	push	{r7}
 802568e:	b083      	sub	sp, #12
 8025690:	af00      	add	r7, sp, #0
 8025692:	6078      	str	r0, [r7, #4]
	}
	// get started (all of the above are true)
	return true;
#else
    UNUSED(sm_connection);
	return false;
 8025694:	2300      	movs	r3, #0
#endif
}
 8025696:	4618      	mov	r0, r3
 8025698:	370c      	adds	r7, #12
 802569a:	46bd      	mov	sp, r7
 802569c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80256a0:	4770      	bx	lr
	...

080256a4 <sm_handle_encryption_result_enc_csrk>:

static void sm_handle_encryption_result_enc_csrk(void *arg){
 80256a4:	b590      	push	{r4, r7, lr}
 80256a6:	b087      	sub	sp, #28
 80256a8:	af00      	add	r7, sp, #0
 80256aa:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 80256ac:	687b      	ldr	r3, [r7, #4]
 80256ae:	82fb      	strh	r3, [r7, #22]
    sm_aes128_state = SM_AES128_IDLE;
 80256b0:	4b2b      	ldr	r3, [pc, #172]	; (8025760 <sm_handle_encryption_result_enc_csrk+0xbc>)
 80256b2:	2200      	movs	r2, #0
 80256b4:	701a      	strb	r2, [r3, #0]

    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 80256b6:	8afb      	ldrh	r3, [r7, #22]
 80256b8:	4618      	mov	r0, r3
 80256ba:	f001 fd59 	bl	8027170 <sm_get_connection_for_handle>
 80256be:	6138      	str	r0, [r7, #16]
    if (connection == NULL) return;
 80256c0:	693b      	ldr	r3, [r7, #16]
 80256c2:	2b00      	cmp	r3, #0
 80256c4:	d048      	beq.n	8025758 <sm_handle_encryption_result_enc_csrk+0xb4>

    sm_aes128_state = SM_AES128_IDLE;
 80256c6:	4b26      	ldr	r3, [pc, #152]	; (8025760 <sm_handle_encryption_result_enc_csrk+0xbc>)
 80256c8:	2200      	movs	r2, #0
 80256ca:	701a      	strb	r2, [r3, #0]
    log_info_key("csrk", setup->sm_local_csrk);
 80256cc:	4b25      	ldr	r3, [pc, #148]	; (8025764 <sm_handle_encryption_result_enc_csrk+0xc0>)
 80256ce:	681b      	ldr	r3, [r3, #0]
 80256d0:	f503 73d3 	add.w	r3, r3, #422	; 0x1a6
 80256d4:	4619      	mov	r1, r3
 80256d6:	4824      	ldr	r0, [pc, #144]	; (8025768 <sm_handle_encryption_result_enc_csrk+0xc4>)
 80256d8:	f7e9 fe4c 	bl	800f374 <log_info_key>
    if (setup->sm_key_distribution_send_set){
 80256dc:	4b21      	ldr	r3, [pc, #132]	; (8025764 <sm_handle_encryption_result_enc_csrk+0xc0>)
 80256de:	681b      	ldr	r3, [r3, #0]
 80256e0:	7cdb      	ldrb	r3, [r3, #19]
 80256e2:	2b00      	cmp	r3, #0
 80256e4:	d003      	beq.n	80256ee <sm_handle_encryption_result_enc_csrk+0x4a>
        connection->sm_engine_state = SM_PH3_DISTRIBUTE_KEYS;
 80256e6:	693b      	ldr	r3, [r7, #16]
 80256e8:	2217      	movs	r2, #23
 80256ea:	731a      	strb	r2, [r3, #12]
 80256ec:	e031      	b.n	8025752 <sm_handle_encryption_result_enc_csrk+0xae>
    } else {
        // no keys to send, just continue
        if (IS_RESPONDER(connection->sm_role)){
 80256ee:	693b      	ldr	r3, [r7, #16]
 80256f0:	789b      	ldrb	r3, [r3, #2]
 80256f2:	2b00      	cmp	r3, #0
 80256f4:	d003      	beq.n	80256fe <sm_handle_encryption_result_enc_csrk+0x5a>
            // slave -> receive master keys
            connection->sm_engine_state = SM_PH3_RECEIVE_KEYS;
 80256f6:	693b      	ldr	r3, [r7, #16]
 80256f8:	2218      	movs	r2, #24
 80256fa:	731a      	strb	r2, [r3, #12]
 80256fc:	e029      	b.n	8025752 <sm_handle_encryption_result_enc_csrk+0xae>
        } else {
			if (sm_ctkd_from_le(connection)){
 80256fe:	6938      	ldr	r0, [r7, #16]
 8025700:	f7ff ffc4 	bl	802568c <sm_ctkd_from_le>
 8025704:	4603      	mov	r3, r0
 8025706:	2b00      	cmp	r3, #0
 8025708:	d020      	beq.n	802574c <sm_handle_encryption_result_enc_csrk+0xa8>
				bool use_h7 = (sm_pairing_packet_get_auth_req(setup->sm_m_preq) & sm_pairing_packet_get_auth_req(setup->sm_s_pres) & SM_AUTHREQ_CT2) != 0;
 802570a:	4b16      	ldr	r3, [pc, #88]	; (8025764 <sm_handle_encryption_result_enc_csrk+0xc0>)
 802570c:	681b      	ldr	r3, [r3, #0]
 802570e:	3339      	adds	r3, #57	; 0x39
 8025710:	4618      	mov	r0, r3
 8025712:	f7fb fc6b 	bl	8020fec <sm_pairing_packet_get_auth_req>
 8025716:	4603      	mov	r3, r0
 8025718:	461c      	mov	r4, r3
 802571a:	4b12      	ldr	r3, [pc, #72]	; (8025764 <sm_handle_encryption_result_enc_csrk+0xc0>)
 802571c:	681b      	ldr	r3, [r3, #0]
 802571e:	3340      	adds	r3, #64	; 0x40
 8025720:	4618      	mov	r0, r3
 8025722:	f7fb fc63 	bl	8020fec <sm_pairing_packet_get_auth_req>
 8025726:	4603      	mov	r3, r0
 8025728:	4023      	ands	r3, r4
 802572a:	b2db      	uxtb	r3, r3
 802572c:	f003 0320 	and.w	r3, r3, #32
 8025730:	2b00      	cmp	r3, #0
 8025732:	bf14      	ite	ne
 8025734:	2301      	movne	r3, #1
 8025736:	2300      	moveq	r3, #0
 8025738:	73fb      	strb	r3, [r7, #15]
				connection->sm_engine_state = use_h7 ? SM_SC_W2_CALCULATE_ILK_USING_H7 : SM_SC_W2_CALCULATE_ILK_USING_H6;
 802573a:	7bfb      	ldrb	r3, [r7, #15]
 802573c:	2b00      	cmp	r3, #0
 802573e:	d001      	beq.n	8025744 <sm_handle_encryption_result_enc_csrk+0xa0>
 8025740:	224e      	movs	r2, #78	; 0x4e
 8025742:	e000      	b.n	8025746 <sm_handle_encryption_result_enc_csrk+0xa2>
 8025744:	224d      	movs	r2, #77	; 0x4d
 8025746:	693b      	ldr	r3, [r7, #16]
 8025748:	731a      	strb	r2, [r3, #12]
 802574a:	e002      	b.n	8025752 <sm_handle_encryption_result_enc_csrk+0xae>
            } else {
                sm_master_pairing_success(connection);
 802574c:	6938      	ldr	r0, [r7, #16]
 802574e:	f7fc fc7f 	bl	8022050 <sm_master_pairing_success>
            }
        }
    }
    sm_trigger_run();
 8025752:	f7fb fd2d 	bl	80211b0 <sm_trigger_run>
 8025756:	e000      	b.n	802575a <sm_handle_encryption_result_enc_csrk+0xb6>
    if (connection == NULL) return;
 8025758:	bf00      	nop
}
 802575a:	371c      	adds	r7, #28
 802575c:	46bd      	mov	sp, r7
 802575e:	bd90      	pop	{r4, r7, pc}
 8025760:	2000a068 	.word	0x2000a068
 8025764:	200000a0 	.word	0x200000a0
 8025768:	0802df60 	.word	0x0802df60

0802576c <sm_handle_encryption_result_enc_ph4_ltk>:

#ifdef ENABLE_LE_PERIPHERAL
static void sm_handle_encryption_result_enc_ph4_ltk(void *arg){
 802576c:	b580      	push	{r7, lr}
 802576e:	b084      	sub	sp, #16
 8025770:	af00      	add	r7, sp, #0
 8025772:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 8025774:	687b      	ldr	r3, [r7, #4]
 8025776:	81fb      	strh	r3, [r7, #14]
    sm_aes128_state = SM_AES128_IDLE;
 8025778:	4b12      	ldr	r3, [pc, #72]	; (80257c4 <sm_handle_encryption_result_enc_ph4_ltk+0x58>)
 802577a:	2200      	movs	r2, #0
 802577c:	701a      	strb	r2, [r3, #0]

    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 802577e:	89fb      	ldrh	r3, [r7, #14]
 8025780:	4618      	mov	r0, r3
 8025782:	f001 fcf5 	bl	8027170 <sm_get_connection_for_handle>
 8025786:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 8025788:	68bb      	ldr	r3, [r7, #8]
 802578a:	2b00      	cmp	r3, #0
 802578c:	d016      	beq.n	80257bc <sm_handle_encryption_result_enc_ph4_ltk+0x50>

    sm_truncate_key(setup->sm_ltk, connection->sm_actual_encryption_key_size);
 802578e:	4b0e      	ldr	r3, [pc, #56]	; (80257c8 <sm_handle_encryption_result_enc_ph4_ltk+0x5c>)
 8025790:	681b      	ldr	r3, [r3, #0]
 8025792:	f103 0295 	add.w	r2, r3, #149	; 0x95
 8025796:	68bb      	ldr	r3, [r7, #8]
 8025798:	7c5b      	ldrb	r3, [r3, #17]
 802579a:	4619      	mov	r1, r3
 802579c:	4610      	mov	r0, r2
 802579e:	f7fb fd3d 	bl	802121c <sm_truncate_key>
    log_info_key("ltk", setup->sm_ltk);
 80257a2:	4b09      	ldr	r3, [pc, #36]	; (80257c8 <sm_handle_encryption_result_enc_ph4_ltk+0x5c>)
 80257a4:	681b      	ldr	r3, [r3, #0]
 80257a6:	3395      	adds	r3, #149	; 0x95
 80257a8:	4619      	mov	r1, r3
 80257aa:	4808      	ldr	r0, [pc, #32]	; (80257cc <sm_handle_encryption_result_enc_ph4_ltk+0x60>)
 80257ac:	f7e9 fde2 	bl	800f374 <log_info_key>
    connection->sm_engine_state = SM_RESPONDER_PH4_SEND_LTK_REPLY;
 80257b0:	68bb      	ldr	r3, [r7, #8]
 80257b2:	2228      	movs	r2, #40	; 0x28
 80257b4:	731a      	strb	r2, [r3, #12]
    sm_trigger_run();
 80257b6:	f7fb fcfb 	bl	80211b0 <sm_trigger_run>
 80257ba:	e000      	b.n	80257be <sm_handle_encryption_result_enc_ph4_ltk+0x52>
    if (connection == NULL) return;
 80257bc:	bf00      	nop
}
 80257be:	3710      	adds	r7, #16
 80257c0:	46bd      	mov	sp, r7
 80257c2:	bd80      	pop	{r7, pc}
 80257c4:	2000a068 	.word	0x2000a068
 80257c8:	200000a0 	.word	0x200000a0
 80257cc:	0802df5c 	.word	0x0802df5c

080257d0 <sm_handle_encryption_result_address_resolution>:
#endif

static void sm_handle_encryption_result_address_resolution(void *arg){
 80257d0:	b580      	push	{r7, lr}
 80257d2:	b084      	sub	sp, #16
 80257d4:	af00      	add	r7, sp, #0
 80257d6:	6078      	str	r0, [r7, #4]
    UNUSED(arg);
    sm_aes128_state = SM_AES128_IDLE;
 80257d8:	4b13      	ldr	r3, [pc, #76]	; (8025828 <sm_handle_encryption_result_address_resolution+0x58>)
 80257da:	2200      	movs	r2, #0
 80257dc:	701a      	strb	r2, [r3, #0]

    sm_address_resolution_ah_calculation_active = 0;
 80257de:	4b13      	ldr	r3, [pc, #76]	; (802582c <sm_handle_encryption_result_address_resolution+0x5c>)
 80257e0:	2200      	movs	r2, #0
 80257e2:	601a      	str	r2, [r3, #0]
    // compare calulated address against connecting device
    uint8_t * hash = &sm_aes128_ciphertext[13];
 80257e4:	4b12      	ldr	r3, [pc, #72]	; (8025830 <sm_handle_encryption_result_address_resolution+0x60>)
 80257e6:	60fb      	str	r3, [r7, #12]
    if (memcmp(&sm_address_resolution_address[3], hash, 3) == 0){
 80257e8:	2203      	movs	r2, #3
 80257ea:	68f9      	ldr	r1, [r7, #12]
 80257ec:	4811      	ldr	r0, [pc, #68]	; (8025834 <sm_handle_encryption_result_address_resolution+0x64>)
 80257ee:	f002 f935 	bl	8027a5c <memcmp>
 80257f2:	4603      	mov	r3, r0
 80257f4:	2b00      	cmp	r3, #0
 80257f6:	d10c      	bne.n	8025812 <sm_handle_encryption_result_address_resolution+0x42>
        log_info("LE Device Lookup: matched resolvable private address");
 80257f8:	f640 438d 	movw	r3, #3213	; 0xc8d
 80257fc:	4a0e      	ldr	r2, [pc, #56]	; (8025838 <sm_handle_encryption_result_address_resolution+0x68>)
 80257fe:	490f      	ldr	r1, [pc, #60]	; (802583c <sm_handle_encryption_result_address_resolution+0x6c>)
 8025800:	2001      	movs	r0, #1
 8025802:	f7f1 fe1d 	bl	8017440 <hci_dump_log>
        sm_address_resolution_handle_event(ADDRESS_RESOLUTION_SUCCEEDED);
 8025806:	2000      	movs	r0, #0
 8025808:	f7fc fdee 	bl	80223e8 <sm_address_resolution_handle_event>
        sm_trigger_run();
 802580c:	f7fb fcd0 	bl	80211b0 <sm_trigger_run>
        return;
 8025810:	e006      	b.n	8025820 <sm_handle_encryption_result_address_resolution+0x50>
    }
    // no match, try next
    sm_address_resolution_test++;
 8025812:	4b0b      	ldr	r3, [pc, #44]	; (8025840 <sm_handle_encryption_result_address_resolution+0x70>)
 8025814:	681b      	ldr	r3, [r3, #0]
 8025816:	3301      	adds	r3, #1
 8025818:	4a09      	ldr	r2, [pc, #36]	; (8025840 <sm_handle_encryption_result_address_resolution+0x70>)
 802581a:	6013      	str	r3, [r2, #0]
    sm_trigger_run();
 802581c:	f7fb fcc8 	bl	80211b0 <sm_trigger_run>
}
 8025820:	3710      	adds	r7, #16
 8025822:	46bd      	mov	sp, r7
 8025824:	bd80      	pop	{r7, pc}
 8025826:	bf00      	nop
 8025828:	2000a068 	.word	0x2000a068
 802582c:	2000a04c 	.word	0x2000a04c
 8025830:	2000a0ed 	.word	0x2000a0ed
 8025834:	2000a057 	.word	0x2000a057
 8025838:	0802d4a8 	.word	0x0802d4a8
 802583c:	0802df68 	.word	0x0802df68
 8025840:	2000a048 	.word	0x2000a048

08025844 <sm_handle_encryption_result_dkg_irk>:

static void sm_handle_encryption_result_dkg_irk(void *arg){
 8025844:	b580      	push	{r7, lr}
 8025846:	b082      	sub	sp, #8
 8025848:	af00      	add	r7, sp, #0
 802584a:	6078      	str	r0, [r7, #4]
    UNUSED(arg);
    sm_aes128_state = SM_AES128_IDLE;
 802584c:	4b07      	ldr	r3, [pc, #28]	; (802586c <sm_handle_encryption_result_dkg_irk+0x28>)
 802584e:	2200      	movs	r2, #0
 8025850:	701a      	strb	r2, [r3, #0]

    log_info_key("irk", sm_persistent_irk);
 8025852:	4907      	ldr	r1, [pc, #28]	; (8025870 <sm_handle_encryption_result_dkg_irk+0x2c>)
 8025854:	4807      	ldr	r0, [pc, #28]	; (8025874 <sm_handle_encryption_result_dkg_irk+0x30>)
 8025856:	f7e9 fd8d 	bl	800f374 <log_info_key>
    dkg_state = DKG_CALC_DHK;
 802585a:	4b07      	ldr	r3, [pc, #28]	; (8025878 <sm_handle_encryption_result_dkg_irk+0x34>)
 802585c:	2202      	movs	r2, #2
 802585e:	701a      	strb	r2, [r3, #0]
    sm_trigger_run();
 8025860:	f7fb fca6 	bl	80211b0 <sm_trigger_run>
}
 8025864:	bf00      	nop
 8025866:	3708      	adds	r7, #8
 8025868:	46bd      	mov	sp, r7
 802586a:	bd80      	pop	{r7, pc}
 802586c:	2000a068 	.word	0x2000a068
 8025870:	20009fa0 	.word	0x20009fa0
 8025874:	0802dfa4 	.word	0x0802dfa4
 8025878:	20009fb0 	.word	0x20009fb0

0802587c <sm_handle_encryption_result_dkg_dhk>:

static void sm_handle_encryption_result_dkg_dhk(void *arg){
 802587c:	b580      	push	{r7, lr}
 802587e:	b082      	sub	sp, #8
 8025880:	af00      	add	r7, sp, #0
 8025882:	6078      	str	r0, [r7, #4]
    UNUSED(arg);
    sm_aes128_state = SM_AES128_IDLE;
 8025884:	4b07      	ldr	r3, [pc, #28]	; (80258a4 <sm_handle_encryption_result_dkg_dhk+0x28>)
 8025886:	2200      	movs	r2, #0
 8025888:	701a      	strb	r2, [r3, #0]

    log_info_key("dhk", sm_persistent_dhk);
 802588a:	4907      	ldr	r1, [pc, #28]	; (80258a8 <sm_handle_encryption_result_dkg_dhk+0x2c>)
 802588c:	4807      	ldr	r0, [pc, #28]	; (80258ac <sm_handle_encryption_result_dkg_dhk+0x30>)
 802588e:	f7e9 fd71 	bl	800f374 <log_info_key>
    dkg_state = DKG_READY;
 8025892:	4b07      	ldr	r3, [pc, #28]	; (80258b0 <sm_handle_encryption_result_dkg_dhk+0x34>)
 8025894:	2203      	movs	r2, #3
 8025896:	701a      	strb	r2, [r3, #0]
    sm_trigger_run();
 8025898:	f7fb fc8a 	bl	80211b0 <sm_trigger_run>
}
 802589c:	bf00      	nop
 802589e:	3708      	adds	r7, #8
 80258a0:	46bd      	mov	sp, r7
 80258a2:	bd80      	pop	{r7, pc}
 80258a4:	2000a068 	.word	0x2000a068
 80258a8:	20009f90 	.word	0x20009f90
 80258ac:	0802dfa8 	.word	0x0802dfa8
 80258b0:	20009fb0 	.word	0x20009fb0

080258b4 <sm_handle_encryption_result_rau>:

static void sm_handle_encryption_result_rau(void *arg){
 80258b4:	b580      	push	{r7, lr}
 80258b6:	b082      	sub	sp, #8
 80258b8:	af00      	add	r7, sp, #0
 80258ba:	6078      	str	r0, [r7, #4]
    UNUSED(arg);
    sm_aes128_state = SM_AES128_IDLE;
 80258bc:	4b08      	ldr	r3, [pc, #32]	; (80258e0 <sm_handle_encryption_result_rau+0x2c>)
 80258be:	2200      	movs	r2, #0
 80258c0:	701a      	strb	r2, [r3, #0]

    (void)memcpy(&sm_random_address[3], &sm_aes128_ciphertext[13], 3);
 80258c2:	2203      	movs	r2, #3
 80258c4:	4907      	ldr	r1, [pc, #28]	; (80258e4 <sm_handle_encryption_result_rau+0x30>)
 80258c6:	4808      	ldr	r0, [pc, #32]	; (80258e8 <sm_handle_encryption_result_rau+0x34>)
 80258c8:	f002 f8d7 	bl	8027a7a <memcpy>
    rau_state = RAU_SET_ADDRESS;
 80258cc:	4b07      	ldr	r3, [pc, #28]	; (80258ec <sm_handle_encryption_result_rau+0x38>)
 80258ce:	2205      	movs	r2, #5
 80258d0:	701a      	strb	r2, [r3, #0]
    sm_trigger_run();
 80258d2:	f7fb fc6d 	bl	80211b0 <sm_trigger_run>
}
 80258d6:	bf00      	nop
 80258d8:	3708      	adds	r7, #8
 80258da:	46bd      	mov	sp, r7
 80258dc:	bd80      	pop	{r7, pc}
 80258de:	bf00      	nop
 80258e0:	2000a068 	.word	0x2000a068
 80258e4:	2000a0ed 	.word	0x2000a0ed
 80258e8:	20009fb7 	.word	0x20009fb7
 80258ec:	20009fb1 	.word	0x20009fb1

080258f0 <sm_handle_random_result_rau>:

static void sm_handle_random_result_rau(void * arg){
 80258f0:	b580      	push	{r7, lr}
 80258f2:	b082      	sub	sp, #8
 80258f4:	af00      	add	r7, sp, #0
 80258f6:	6078      	str	r0, [r7, #4]
    UNUSED(arg);
    // non-resolvable vs. resolvable
    switch (gap_random_adress_type){
 80258f8:	4b13      	ldr	r3, [pc, #76]	; (8025948 <sm_handle_random_result_rau+0x58>)
 80258fa:	781b      	ldrb	r3, [r3, #0]
 80258fc:	2b03      	cmp	r3, #3
 80258fe:	d111      	bne.n	8025924 <sm_handle_random_result_rau+0x34>
        case GAP_RANDOM_ADDRESS_RESOLVABLE:
            // resolvable: use random as prand and calc address hash
            // "The two most significant bits of prand shall be equal to ‘0’ and ‘1"
            sm_random_address[0u] &= 0x3fu;
 8025900:	4b12      	ldr	r3, [pc, #72]	; (802594c <sm_handle_random_result_rau+0x5c>)
 8025902:	781b      	ldrb	r3, [r3, #0]
 8025904:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8025908:	b2da      	uxtb	r2, r3
 802590a:	4b10      	ldr	r3, [pc, #64]	; (802594c <sm_handle_random_result_rau+0x5c>)
 802590c:	701a      	strb	r2, [r3, #0]
            sm_random_address[0u] |= 0x40u;
 802590e:	4b0f      	ldr	r3, [pc, #60]	; (802594c <sm_handle_random_result_rau+0x5c>)
 8025910:	781b      	ldrb	r3, [r3, #0]
 8025912:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8025916:	b2da      	uxtb	r2, r3
 8025918:	4b0c      	ldr	r3, [pc, #48]	; (802594c <sm_handle_random_result_rau+0x5c>)
 802591a:	701a      	strb	r2, [r3, #0]
            rau_state = RAU_GET_ENC;
 802591c:	4b0c      	ldr	r3, [pc, #48]	; (8025950 <sm_handle_random_result_rau+0x60>)
 802591e:	2203      	movs	r2, #3
 8025920:	701a      	strb	r2, [r3, #0]
            break;
 8025922:	e00a      	b.n	802593a <sm_handle_random_result_rau+0x4a>
        case GAP_RANDOM_ADDRESS_NON_RESOLVABLE:
        default:
            // "The two most significant bits of the address shall be equal to ‘0’""
            sm_random_address[0u] &= 0x3fu;
 8025924:	4b09      	ldr	r3, [pc, #36]	; (802594c <sm_handle_random_result_rau+0x5c>)
 8025926:	781b      	ldrb	r3, [r3, #0]
 8025928:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 802592c:	b2da      	uxtb	r2, r3
 802592e:	4b07      	ldr	r3, [pc, #28]	; (802594c <sm_handle_random_result_rau+0x5c>)
 8025930:	701a      	strb	r2, [r3, #0]
            rau_state = RAU_SET_ADDRESS;
 8025932:	4b07      	ldr	r3, [pc, #28]	; (8025950 <sm_handle_random_result_rau+0x60>)
 8025934:	2205      	movs	r2, #5
 8025936:	701a      	strb	r2, [r3, #0]
            break;
 8025938:	bf00      	nop
    }
    sm_trigger_run();
 802593a:	f7fb fc39 	bl	80211b0 <sm_trigger_run>
}
 802593e:	bf00      	nop
 8025940:	3708      	adds	r7, #8
 8025942:	46bd      	mov	sp, r7
 8025944:	bd80      	pop	{r7, pc}
 8025946:	bf00      	nop
 8025948:	2000a364 	.word	0x2000a364
 802594c:	20009fb4 	.word	0x20009fb4
 8025950:	20009fb1 	.word	0x20009fb1

08025954 <sm_handle_random_result_sc_next_send_pairing_random>:

#ifdef ENABLE_LE_SECURE_CONNECTIONS
static void sm_handle_random_result_sc_next_send_pairing_random(void * arg){
 8025954:	b580      	push	{r7, lr}
 8025956:	b084      	sub	sp, #16
 8025958:	af00      	add	r7, sp, #0
 802595a:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 802595c:	687b      	ldr	r3, [r7, #4]
 802595e:	81fb      	strh	r3, [r7, #14]
    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 8025960:	89fb      	ldrh	r3, [r7, #14]
 8025962:	4618      	mov	r0, r3
 8025964:	f001 fc04 	bl	8027170 <sm_get_connection_for_handle>
 8025968:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 802596a:	68bb      	ldr	r3, [r7, #8]
 802596c:	2b00      	cmp	r3, #0
 802596e:	d005      	beq.n	802597c <sm_handle_random_result_sc_next_send_pairing_random+0x28>

    connection->sm_engine_state = SM_SC_SEND_PAIRING_RANDOM;
 8025970:	68bb      	ldr	r3, [r7, #8]
 8025972:	223a      	movs	r2, #58	; 0x3a
 8025974:	731a      	strb	r2, [r3, #12]
    sm_trigger_run();
 8025976:	f7fb fc1b 	bl	80211b0 <sm_trigger_run>
 802597a:	e000      	b.n	802597e <sm_handle_random_result_sc_next_send_pairing_random+0x2a>
    if (connection == NULL) return;
 802597c:	bf00      	nop
}
 802597e:	3710      	adds	r7, #16
 8025980:	46bd      	mov	sp, r7
 8025982:	bd80      	pop	{r7, pc}

08025984 <sm_handle_random_result_sc_next_w2_cmac_for_confirmation>:

static void sm_handle_random_result_sc_next_w2_cmac_for_confirmation(void * arg){
 8025984:	b580      	push	{r7, lr}
 8025986:	b084      	sub	sp, #16
 8025988:	af00      	add	r7, sp, #0
 802598a:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 802598c:	687b      	ldr	r3, [r7, #4]
 802598e:	81fb      	strh	r3, [r7, #14]
    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 8025990:	89fb      	ldrh	r3, [r7, #14]
 8025992:	4618      	mov	r0, r3
 8025994:	f001 fbec 	bl	8027170 <sm_get_connection_for_handle>
 8025998:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 802599a:	68bb      	ldr	r3, [r7, #8]
 802599c:	2b00      	cmp	r3, #0
 802599e:	d005      	beq.n	80259ac <sm_handle_random_result_sc_next_w2_cmac_for_confirmation+0x28>

    connection->sm_engine_state = SM_SC_W2_CMAC_FOR_CONFIRMATION;
 80259a0:	68bb      	ldr	r3, [r7, #8]
 80259a2:	2234      	movs	r2, #52	; 0x34
 80259a4:	731a      	strb	r2, [r3, #12]
    sm_trigger_run();
 80259a6:	f7fb fc03 	bl	80211b0 <sm_trigger_run>
 80259aa:	e000      	b.n	80259ae <sm_handle_random_result_sc_next_w2_cmac_for_confirmation+0x2a>
    if (connection == NULL) return;
 80259ac:	bf00      	nop
}
 80259ae:	3710      	adds	r7, #16
 80259b0:	46bd      	mov	sp, r7
 80259b2:	bd80      	pop	{r7, pc}

080259b4 <sm_handle_random_result_ph2_random>:
#endif

static void sm_handle_random_result_ph2_random(void * arg){
 80259b4:	b580      	push	{r7, lr}
 80259b6:	b084      	sub	sp, #16
 80259b8:	af00      	add	r7, sp, #0
 80259ba:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 80259bc:	687b      	ldr	r3, [r7, #4]
 80259be:	81fb      	strh	r3, [r7, #14]
    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 80259c0:	89fb      	ldrh	r3, [r7, #14]
 80259c2:	4618      	mov	r0, r3
 80259c4:	f001 fbd4 	bl	8027170 <sm_get_connection_for_handle>
 80259c8:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 80259ca:	68bb      	ldr	r3, [r7, #8]
 80259cc:	2b00      	cmp	r3, #0
 80259ce:	d005      	beq.n	80259dc <sm_handle_random_result_ph2_random+0x28>

    connection->sm_engine_state = SM_PH2_C1_GET_ENC_A;
 80259d0:	68bb      	ldr	r3, [r7, #8]
 80259d2:	220b      	movs	r2, #11
 80259d4:	731a      	strb	r2, [r3, #12]
    sm_trigger_run();
 80259d6:	f7fb fbeb 	bl	80211b0 <sm_trigger_run>
 80259da:	e000      	b.n	80259de <sm_handle_random_result_ph2_random+0x2a>
    if (connection == NULL) return;
 80259dc:	bf00      	nop
}
 80259de:	3710      	adds	r7, #16
 80259e0:	46bd      	mov	sp, r7
 80259e2:	bd80      	pop	{r7, pc}

080259e4 <sm_handle_random_result_ph2_tk>:

static void sm_handle_random_result_ph2_tk(void * arg){
 80259e4:	b580      	push	{r7, lr}
 80259e6:	b088      	sub	sp, #32
 80259e8:	af02      	add	r7, sp, #8
 80259ea:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 80259ec:	687b      	ldr	r3, [r7, #4]
 80259ee:	827b      	strh	r3, [r7, #18]
    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 80259f0:	8a7b      	ldrh	r3, [r7, #18]
 80259f2:	4618      	mov	r0, r3
 80259f4:	f001 fbbc 	bl	8027170 <sm_get_connection_for_handle>
 80259f8:	60f8      	str	r0, [r7, #12]
    if (connection == NULL) return;
 80259fa:	68fb      	ldr	r3, [r7, #12]
 80259fc:	2b00      	cmp	r3, #0
 80259fe:	d051      	beq.n	8025aa4 <sm_handle_random_result_ph2_tk+0xc0>

    sm_reset_tk();
 8025a00:	f7fb fbf0 	bl	80211e4 <sm_reset_tk>
    uint32_t tk;
    if (sm_fixed_passkey_in_display_role == 0xffffffff){
 8025a04:	4b29      	ldr	r3, [pc, #164]	; (8025aac <sm_handle_random_result_ph2_tk+0xc8>)
 8025a06:	681b      	ldr	r3, [r3, #0]
 8025a08:	f1b3 3fff 	cmp.w	r3, #4294967295
 8025a0c:	d113      	bne.n	8025a36 <sm_handle_random_result_ph2_tk+0x52>
        // map random to 0-999999 without speding much cycles on a modulus operation
        tk = little_endian_read_32(sm_random_data,0);
 8025a0e:	2100      	movs	r1, #0
 8025a10:	4827      	ldr	r0, [pc, #156]	; (8025ab0 <sm_handle_random_result_ph2_tk+0xcc>)
 8025a12:	f7e9 fa02 	bl	800ee1a <little_endian_read_32>
 8025a16:	6178      	str	r0, [r7, #20]
        tk = tk & 0xfffff;  // 1048575
 8025a18:	697b      	ldr	r3, [r7, #20]
 8025a1a:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8025a1e:	617b      	str	r3, [r7, #20]
        if (tk >= 999999u){
 8025a20:	697b      	ldr	r3, [r7, #20]
 8025a22:	4a24      	ldr	r2, [pc, #144]	; (8025ab4 <sm_handle_random_result_ph2_tk+0xd0>)
 8025a24:	4293      	cmp	r3, r2
 8025a26:	d909      	bls.n	8025a3c <sm_handle_random_result_ph2_tk+0x58>
            tk = tk - 999999u;
 8025a28:	697b      	ldr	r3, [r7, #20]
 8025a2a:	f5a3 2374 	sub.w	r3, r3, #999424	; 0xf4000
 8025a2e:	f2a3 233f 	subw	r3, r3, #575	; 0x23f
 8025a32:	617b      	str	r3, [r7, #20]
 8025a34:	e002      	b.n	8025a3c <sm_handle_random_result_ph2_tk+0x58>
        }
    } else {
        // override with pre-defined passkey
        tk = sm_fixed_passkey_in_display_role;
 8025a36:	4b1d      	ldr	r3, [pc, #116]	; (8025aac <sm_handle_random_result_ph2_tk+0xc8>)
 8025a38:	681b      	ldr	r3, [r3, #0]
 8025a3a:	617b      	str	r3, [r7, #20]
    }
    big_endian_store_32(setup->sm_tk, 12, tk);
 8025a3c:	4b1e      	ldr	r3, [pc, #120]	; (8025ab8 <sm_handle_random_result_ph2_tk+0xd4>)
 8025a3e:	681b      	ldr	r3, [r3, #0]
 8025a40:	3317      	adds	r3, #23
 8025a42:	697a      	ldr	r2, [r7, #20]
 8025a44:	210c      	movs	r1, #12
 8025a46:	4618      	mov	r0, r3
 8025a48:	f7e9 fac5 	bl	800efd6 <big_endian_store_32>
    if (IS_RESPONDER(connection->sm_role)){
 8025a4c:	68fb      	ldr	r3, [r7, #12]
 8025a4e:	789b      	ldrb	r3, [r3, #2]
 8025a50:	2b00      	cmp	r3, #0
 8025a52:	d003      	beq.n	8025a5c <sm_handle_random_result_ph2_tk+0x78>
        connection->sm_engine_state = SM_RESPONDER_PH1_SEND_PAIRING_RESPONSE;
 8025a54:	68fb      	ldr	r3, [r7, #12]
 8025a56:	2222      	movs	r2, #34	; 0x22
 8025a58:	731a      	strb	r2, [r3, #12]
 8025a5a:	e020      	b.n	8025a9e <sm_handle_random_result_ph2_tk+0xba>
    } else {
        if (setup->sm_use_secure_connections){
 8025a5c:	4b16      	ldr	r3, [pc, #88]	; (8025ab8 <sm_handle_random_result_ph2_tk+0xd4>)
 8025a5e:	681b      	ldr	r3, [r3, #0]
 8025a60:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8025a64:	2b00      	cmp	r3, #0
 8025a66:	d003      	beq.n	8025a70 <sm_handle_random_result_ph2_tk+0x8c>
            connection->sm_engine_state = SM_SC_SEND_PUBLIC_KEY_COMMAND;
 8025a68:	68fb      	ldr	r3, [r7, #12]
 8025a6a:	2231      	movs	r2, #49	; 0x31
 8025a6c:	731a      	strb	r2, [r3, #12]
 8025a6e:	e016      	b.n	8025a9e <sm_handle_random_result_ph2_tk+0xba>
        } else {
            connection->sm_engine_state = SM_PH1_W4_USER_RESPONSE;
 8025a70:	68fb      	ldr	r3, [r7, #12]
 8025a72:	2204      	movs	r2, #4
 8025a74:	731a      	strb	r2, [r3, #12]
            sm_trigger_user_response(connection);
 8025a76:	68f8      	ldr	r0, [r7, #12]
 8025a78:	f7fc f9d0 	bl	8021e1c <sm_trigger_user_response>
            // response_idle == nothing <--> sm_trigger_user_response() did not require response
            if (setup->sm_user_response == SM_USER_RESPONSE_IDLE){
 8025a7c:	4b0e      	ldr	r3, [pc, #56]	; (8025ab8 <sm_handle_random_result_ph2_tk+0xd4>)
 8025a7e:	681b      	ldr	r3, [r3, #0]
 8025a80:	7c5b      	ldrb	r3, [r3, #17]
 8025a82:	2b00      	cmp	r3, #0
 8025a84:	d10b      	bne.n	8025a9e <sm_handle_random_result_ph2_tk+0xba>
                btstack_crypto_random_generate(&sm_crypto_random_request, setup->sm_local_random, 16, &sm_handle_random_result_ph2_random, (void *)(uintptr_t) connection->sm_handle);
 8025a86:	4b0c      	ldr	r3, [pc, #48]	; (8025ab8 <sm_handle_random_result_ph2_tk+0xd4>)
 8025a88:	681b      	ldr	r3, [r3, #0]
 8025a8a:	f103 0147 	add.w	r1, r3, #71	; 0x47
 8025a8e:	68fb      	ldr	r3, [r7, #12]
 8025a90:	881b      	ldrh	r3, [r3, #0]
 8025a92:	9300      	str	r3, [sp, #0]
 8025a94:	4b09      	ldr	r3, [pc, #36]	; (8025abc <sm_handle_random_result_ph2_tk+0xd8>)
 8025a96:	2210      	movs	r2, #16
 8025a98:	4809      	ldr	r0, [pc, #36]	; (8025ac0 <sm_handle_random_result_ph2_tk+0xdc>)
 8025a9a:	f7e8 fccf 	bl	800e43c <btstack_crypto_random_generate>
            }
        }
    }   
    sm_trigger_run(); 
 8025a9e:	f7fb fb87 	bl	80211b0 <sm_trigger_run>
 8025aa2:	e000      	b.n	8025aa6 <sm_handle_random_result_ph2_tk+0xc2>
    if (connection == NULL) return;
 8025aa4:	bf00      	nop
}
 8025aa6:	3718      	adds	r7, #24
 8025aa8:	46bd      	mov	sp, r7
 8025aaa:	bd80      	pop	{r7, pc}
 8025aac:	20009f48 	.word	0x20009f48
 8025ab0:	2000a0b8 	.word	0x2000a0b8
 8025ab4:	000f423e 	.word	0x000f423e
 8025ab8:	200000a0 	.word	0x200000a0
 8025abc:	080259b5 	.word	0x080259b5
 8025ac0:	2000a06c 	.word	0x2000a06c

08025ac4 <sm_handle_random_result_ph3_div>:

static void sm_handle_random_result_ph3_div(void * arg){
 8025ac4:	b580      	push	{r7, lr}
 8025ac6:	b084      	sub	sp, #16
 8025ac8:	af00      	add	r7, sp, #0
 8025aca:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 8025acc:	687b      	ldr	r3, [r7, #4]
 8025ace:	81fb      	strh	r3, [r7, #14]
    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 8025ad0:	89fb      	ldrh	r3, [r7, #14]
 8025ad2:	4618      	mov	r0, r3
 8025ad4:	f001 fb4c 	bl	8027170 <sm_get_connection_for_handle>
 8025ad8:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 8025ada:	68bb      	ldr	r3, [r7, #8]
 8025adc:	2b00      	cmp	r3, #0
 8025ade:	d017      	beq.n	8025b10 <sm_handle_random_result_ph3_div+0x4c>

    // use 16 bit from random value as div
    setup->sm_local_div = big_endian_read_16(sm_random_data, 0);
 8025ae0:	2100      	movs	r1, #0
 8025ae2:	480d      	ldr	r0, [pc, #52]	; (8025b18 <sm_handle_random_result_ph3_div+0x54>)
 8025ae4:	f7e9 fa15 	bl	800ef12 <big_endian_read_16>
 8025ae8:	4602      	mov	r2, r0
 8025aea:	4b0c      	ldr	r3, [pc, #48]	; (8025b1c <sm_handle_random_result_ph3_div+0x58>)
 8025aec:	681b      	ldr	r3, [r3, #0]
 8025aee:	b292      	uxth	r2, r2
 8025af0:	f8a3 218a 	strh.w	r2, [r3, #394]	; 0x18a
    log_info_hex16("div", setup->sm_local_div);
 8025af4:	4b09      	ldr	r3, [pc, #36]	; (8025b1c <sm_handle_random_result_ph3_div+0x58>)
 8025af6:	681b      	ldr	r3, [r3, #0]
 8025af8:	f8b3 318a 	ldrh.w	r3, [r3, #394]	; 0x18a
 8025afc:	4619      	mov	r1, r3
 8025afe:	4808      	ldr	r0, [pc, #32]	; (8025b20 <sm_handle_random_result_ph3_div+0x5c>)
 8025b00:	f7fb fa42 	bl	8020f88 <log_info_hex16>
    connection->sm_engine_state = SM_PH3_Y_GET_ENC;
 8025b04:	68bb      	ldr	r3, [r7, #8]
 8025b06:	2214      	movs	r2, #20
 8025b08:	731a      	strb	r2, [r3, #12]
    sm_trigger_run();
 8025b0a:	f7fb fb51 	bl	80211b0 <sm_trigger_run>
 8025b0e:	e000      	b.n	8025b12 <sm_handle_random_result_ph3_div+0x4e>
    if (connection == NULL) return;
 8025b10:	bf00      	nop
}
 8025b12:	3710      	adds	r7, #16
 8025b14:	46bd      	mov	sp, r7
 8025b16:	bd80      	pop	{r7, pc}
 8025b18:	2000a0b8 	.word	0x2000a0b8
 8025b1c:	200000a0 	.word	0x200000a0
 8025b20:	0802dfac 	.word	0x0802dfac

08025b24 <sm_handle_random_result_ph3_random>:

static void sm_handle_random_result_ph3_random(void * arg){
 8025b24:	b580      	push	{r7, lr}
 8025b26:	b086      	sub	sp, #24
 8025b28:	af02      	add	r7, sp, #8
 8025b2a:	6078      	str	r0, [r7, #4]
    hci_con_handle_t con_handle = (hci_con_handle_t) (uintptr_t) arg;
 8025b2c:	687b      	ldr	r3, [r7, #4]
 8025b2e:	81fb      	strh	r3, [r7, #14]
    sm_connection_t * connection = sm_get_connection_for_handle(con_handle);
 8025b30:	89fb      	ldrh	r3, [r7, #14]
 8025b32:	4618      	mov	r0, r3
 8025b34:	f001 fb1c 	bl	8027170 <sm_get_connection_for_handle>
 8025b38:	60b8      	str	r0, [r7, #8]
    if (connection == NULL) return;
 8025b3a:	68bb      	ldr	r3, [r7, #8]
 8025b3c:	2b00      	cmp	r3, #0
 8025b3e:	d033      	beq.n	8025ba8 <sm_handle_random_result_ph3_random+0x84>

    reverse_64(sm_random_data, setup->sm_local_rand);
 8025b40:	4b1b      	ldr	r3, [pc, #108]	; (8025bb0 <sm_handle_random_result_ph3_random+0x8c>)
 8025b42:	681b      	ldr	r3, [r3, #0]
 8025b44:	f503 73c7 	add.w	r3, r3, #398	; 0x18e
 8025b48:	4619      	mov	r1, r3
 8025b4a:	481a      	ldr	r0, [pc, #104]	; (8025bb4 <sm_handle_random_result_ph3_random+0x90>)
 8025b4c:	f7e9 faa7 	bl	800f09e <reverse_64>
    // no db for encryption size hack: encryption size is stored in lowest nibble of setup->sm_local_rand
    setup->sm_local_rand[7u] = (setup->sm_local_rand[7u] & 0xf0u) + (connection->sm_actual_encryption_key_size - 1u);
 8025b50:	4b17      	ldr	r3, [pc, #92]	; (8025bb0 <sm_handle_random_result_ph3_random+0x8c>)
 8025b52:	681b      	ldr	r3, [r3, #0]
 8025b54:	f893 3195 	ldrb.w	r3, [r3, #405]	; 0x195
 8025b58:	f023 030f 	bic.w	r3, r3, #15
 8025b5c:	b2da      	uxtb	r2, r3
 8025b5e:	68bb      	ldr	r3, [r7, #8]
 8025b60:	7c5b      	ldrb	r3, [r3, #17]
 8025b62:	4413      	add	r3, r2
 8025b64:	b2da      	uxtb	r2, r3
 8025b66:	4b12      	ldr	r3, [pc, #72]	; (8025bb0 <sm_handle_random_result_ph3_random+0x8c>)
 8025b68:	681b      	ldr	r3, [r3, #0]
 8025b6a:	3a01      	subs	r2, #1
 8025b6c:	b2d2      	uxtb	r2, r2
 8025b6e:	f883 2195 	strb.w	r2, [r3, #405]	; 0x195
    // no db for authenticated flag hack: store flag in bit 4 of LSB
    setup->sm_local_rand[7u] = (setup->sm_local_rand[7u] & 0xefu) + (connection->sm_connection_authenticated << 4u);
 8025b72:	4b0f      	ldr	r3, [pc, #60]	; (8025bb0 <sm_handle_random_result_ph3_random+0x8c>)
 8025b74:	681b      	ldr	r3, [r3, #0]
 8025b76:	f893 3195 	ldrb.w	r3, [r3, #405]	; 0x195
 8025b7a:	f023 0310 	bic.w	r3, r3, #16
 8025b7e:	b2d9      	uxtb	r1, r3
 8025b80:	68bb      	ldr	r3, [r7, #8]
 8025b82:	7bdb      	ldrb	r3, [r3, #15]
 8025b84:	011b      	lsls	r3, r3, #4
 8025b86:	b2da      	uxtb	r2, r3
 8025b88:	4b09      	ldr	r3, [pc, #36]	; (8025bb0 <sm_handle_random_result_ph3_random+0x8c>)
 8025b8a:	681b      	ldr	r3, [r3, #0]
 8025b8c:	440a      	add	r2, r1
 8025b8e:	b2d2      	uxtb	r2, r2
 8025b90:	f883 2195 	strb.w	r2, [r3, #405]	; 0x195
    btstack_crypto_random_generate(&sm_crypto_random_request, sm_random_data, 2, &sm_handle_random_result_ph3_div, (void *)(uintptr_t) connection->sm_handle);
 8025b94:	68bb      	ldr	r3, [r7, #8]
 8025b96:	881b      	ldrh	r3, [r3, #0]
 8025b98:	9300      	str	r3, [sp, #0]
 8025b9a:	4b07      	ldr	r3, [pc, #28]	; (8025bb8 <sm_handle_random_result_ph3_random+0x94>)
 8025b9c:	2202      	movs	r2, #2
 8025b9e:	4905      	ldr	r1, [pc, #20]	; (8025bb4 <sm_handle_random_result_ph3_random+0x90>)
 8025ba0:	4806      	ldr	r0, [pc, #24]	; (8025bbc <sm_handle_random_result_ph3_random+0x98>)
 8025ba2:	f7e8 fc4b 	bl	800e43c <btstack_crypto_random_generate>
 8025ba6:	e000      	b.n	8025baa <sm_handle_random_result_ph3_random+0x86>
    if (connection == NULL) return;
 8025ba8:	bf00      	nop
}
 8025baa:	3710      	adds	r7, #16
 8025bac:	46bd      	mov	sp, r7
 8025bae:	bd80      	pop	{r7, pc}
 8025bb0:	200000a0 	.word	0x200000a0
 8025bb4:	2000a0b8 	.word	0x2000a0b8
 8025bb8:	08025ac5 	.word	0x08025ac5
 8025bbc:	2000a06c 	.word	0x2000a06c

08025bc0 <sm_validate_er_ir>:
static void sm_validate_er_ir(void){
 8025bc0:	b580      	push	{r7, lr}
 8025bc2:	b082      	sub	sp, #8
 8025bc4:	af00      	add	r7, sp, #0
    // warn about default ER/IR
    bool warning = false;
 8025bc6:	2300      	movs	r3, #0
 8025bc8:	71fb      	strb	r3, [r7, #7]
    if (sm_ir_is_default()){
 8025bca:	f7fb fb8b 	bl	80212e4 <sm_ir_is_default>
 8025bce:	4603      	mov	r3, r0
 8025bd0:	2b00      	cmp	r3, #0
 8025bd2:	d008      	beq.n	8025be6 <sm_validate_er_ir+0x26>
        warning = true;
 8025bd4:	2301      	movs	r3, #1
 8025bd6:	71fb      	strb	r3, [r7, #7]
        log_error("Persistent IR not set with sm_set_ir. Use of private addresses will cause pairing issues");
 8025bd8:	f640 5325 	movw	r3, #3365	; 0xd25
 8025bdc:	4a10      	ldr	r2, [pc, #64]	; (8025c20 <sm_validate_er_ir+0x60>)
 8025bde:	4911      	ldr	r1, [pc, #68]	; (8025c24 <sm_validate_er_ir+0x64>)
 8025be0:	2002      	movs	r0, #2
 8025be2:	f7f1 fc2d 	bl	8017440 <hci_dump_log>
    }
    if (sm_er_is_default()){
 8025be6:	f7fb fb5d 	bl	80212a4 <sm_er_is_default>
 8025bea:	4603      	mov	r3, r0
 8025bec:	2b00      	cmp	r3, #0
 8025bee:	d008      	beq.n	8025c02 <sm_validate_er_ir+0x42>
        warning = true;
 8025bf0:	2301      	movs	r3, #1
 8025bf2:	71fb      	strb	r3, [r7, #7]
        log_error("Persistent ER not set with sm_set_er. Legacy Pairing LTK is not secure");
 8025bf4:	f640 5329 	movw	r3, #3369	; 0xd29
 8025bf8:	4a09      	ldr	r2, [pc, #36]	; (8025c20 <sm_validate_er_ir+0x60>)
 8025bfa:	490b      	ldr	r1, [pc, #44]	; (8025c28 <sm_validate_er_ir+0x68>)
 8025bfc:	2002      	movs	r0, #2
 8025bfe:	f7f1 fc1f 	bl	8017440 <hci_dump_log>
    }
    if (warning) {
 8025c02:	79fb      	ldrb	r3, [r7, #7]
 8025c04:	2b00      	cmp	r3, #0
 8025c06:	d006      	beq.n	8025c16 <sm_validate_er_ir+0x56>
        log_error("Please configure btstack_tlv to let BTstack setup ER and IR keys");
 8025c08:	f640 532c 	movw	r3, #3372	; 0xd2c
 8025c0c:	4a04      	ldr	r2, [pc, #16]	; (8025c20 <sm_validate_er_ir+0x60>)
 8025c0e:	4907      	ldr	r1, [pc, #28]	; (8025c2c <sm_validate_er_ir+0x6c>)
 8025c10:	2002      	movs	r0, #2
 8025c12:	f7f1 fc15 	bl	8017440 <hci_dump_log>
    }
}
 8025c16:	bf00      	nop
 8025c18:	3708      	adds	r7, #8
 8025c1a:	46bd      	mov	sp, r7
 8025c1c:	bd80      	pop	{r7, pc}
 8025c1e:	bf00      	nop
 8025c20:	0802d4a8 	.word	0x0802d4a8
 8025c24:	0802dfb0 	.word	0x0802dfb0
 8025c28:	0802e010 	.word	0x0802e010
 8025c2c:	0802e060 	.word	0x0802e060

08025c30 <sm_handle_random_result_ir>:

static void sm_handle_random_result_ir(void *arg){
 8025c30:	b590      	push	{r4, r7, lr}
 8025c32:	b087      	sub	sp, #28
 8025c34:	af02      	add	r7, sp, #8
 8025c36:	6078      	str	r0, [r7, #4]
    sm_persistent_keys_random_active = false;
 8025c38:	4b18      	ldr	r3, [pc, #96]	; (8025c9c <sm_handle_random_result_ir+0x6c>)
 8025c3a:	2200      	movs	r2, #0
 8025c3c:	701a      	strb	r2, [r3, #0]
    if (arg != NULL){
 8025c3e:	687b      	ldr	r3, [r7, #4]
 8025c40:	2b00      	cmp	r3, #0
 8025c42:	d012      	beq.n	8025c6a <sm_handle_random_result_ir+0x3a>
        // key generated, store in tlv
        int status = sm_tlv_impl->store_tag(sm_tlv_context, BTSTACK_TAG32('S','M','I','R'), sm_persistent_ir, 16u);
 8025c44:	4b16      	ldr	r3, [pc, #88]	; (8025ca0 <sm_handle_random_result_ir+0x70>)
 8025c46:	681b      	ldr	r3, [r3, #0]
 8025c48:	685c      	ldr	r4, [r3, #4]
 8025c4a:	4b16      	ldr	r3, [pc, #88]	; (8025ca4 <sm_handle_random_result_ir+0x74>)
 8025c4c:	6818      	ldr	r0, [r3, #0]
 8025c4e:	2310      	movs	r3, #16
 8025c50:	4a15      	ldr	r2, [pc, #84]	; (8025ca8 <sm_handle_random_result_ir+0x78>)
 8025c52:	4916      	ldr	r1, [pc, #88]	; (8025cac <sm_handle_random_result_ir+0x7c>)
 8025c54:	47a0      	blx	r4
 8025c56:	60f8      	str	r0, [r7, #12]
        log_info("Generated IR key. Store in TLV status: %d", status);
 8025c58:	68fb      	ldr	r3, [r7, #12]
 8025c5a:	9300      	str	r3, [sp, #0]
 8025c5c:	f640 5335 	movw	r3, #3381	; 0xd35
 8025c60:	4a13      	ldr	r2, [pc, #76]	; (8025cb0 <sm_handle_random_result_ir+0x80>)
 8025c62:	4914      	ldr	r1, [pc, #80]	; (8025cb4 <sm_handle_random_result_ir+0x84>)
 8025c64:	2001      	movs	r0, #1
 8025c66:	f7f1 fbeb 	bl	8017440 <hci_dump_log>
        UNUSED(status);
    }
    log_info_key("IR", sm_persistent_ir);
 8025c6a:	490f      	ldr	r1, [pc, #60]	; (8025ca8 <sm_handle_random_result_ir+0x78>)
 8025c6c:	4812      	ldr	r0, [pc, #72]	; (8025cb8 <sm_handle_random_result_ir+0x88>)
 8025c6e:	f7e9 fb81 	bl	800f374 <log_info_key>
    dkg_state = DKG_CALC_IRK;
 8025c72:	4b12      	ldr	r3, [pc, #72]	; (8025cbc <sm_handle_random_result_ir+0x8c>)
 8025c74:	2201      	movs	r2, #1
 8025c76:	701a      	strb	r2, [r3, #0]

    if (test_use_fixed_local_irk){
 8025c78:	4b11      	ldr	r3, [pc, #68]	; (8025cc0 <sm_handle_random_result_ir+0x90>)
 8025c7a:	781b      	ldrb	r3, [r3, #0]
 8025c7c:	2b00      	cmp	r3, #0
 8025c7e:	d006      	beq.n	8025c8e <sm_handle_random_result_ir+0x5e>
        log_info_key("IRK", sm_persistent_irk);
 8025c80:	4910      	ldr	r1, [pc, #64]	; (8025cc4 <sm_handle_random_result_ir+0x94>)
 8025c82:	4811      	ldr	r0, [pc, #68]	; (8025cc8 <sm_handle_random_result_ir+0x98>)
 8025c84:	f7e9 fb76 	bl	800f374 <log_info_key>
        dkg_state = DKG_CALC_DHK;
 8025c88:	4b0c      	ldr	r3, [pc, #48]	; (8025cbc <sm_handle_random_result_ir+0x8c>)
 8025c8a:	2202      	movs	r2, #2
 8025c8c:	701a      	strb	r2, [r3, #0]
    }

    sm_trigger_run();
 8025c8e:	f7fb fa8f 	bl	80211b0 <sm_trigger_run>
}
 8025c92:	bf00      	nop
 8025c94:	3714      	adds	r7, #20
 8025c96:	46bd      	mov	sp, r7
 8025c98:	bd90      	pop	{r4, r7, pc}
 8025c9a:	bf00      	nop
 8025c9c:	20009f65 	.word	0x20009f65
 8025ca0:	20009f68 	.word	0x20009f68
 8025ca4:	20009f6c 	.word	0x20009f6c
 8025ca8:	20009f80 	.word	0x20009f80
 8025cac:	534d4952 	.word	0x534d4952
 8025cb0:	0802d4a8 	.word	0x0802d4a8
 8025cb4:	0802e0a8 	.word	0x0802e0a8
 8025cb8:	0802e0dc 	.word	0x0802e0dc
 8025cbc:	20009fb0 	.word	0x20009fb0
 8025cc0:	20009f42 	.word	0x20009f42
 8025cc4:	20009fa0 	.word	0x20009fa0
 8025cc8:	0802dc68 	.word	0x0802dc68

08025ccc <sm_handle_random_result_er>:

static void sm_handle_random_result_er(void *arg){
 8025ccc:	b590      	push	{r4, r7, lr}
 8025cce:	b087      	sub	sp, #28
 8025cd0:	af02      	add	r7, sp, #8
 8025cd2:	6078      	str	r0, [r7, #4]
    sm_persistent_keys_random_active = false;
 8025cd4:	4b21      	ldr	r3, [pc, #132]	; (8025d5c <sm_handle_random_result_er+0x90>)
 8025cd6:	2200      	movs	r2, #0
 8025cd8:	701a      	strb	r2, [r3, #0]
    if (arg != 0){
 8025cda:	687b      	ldr	r3, [r7, #4]
 8025cdc:	2b00      	cmp	r3, #0
 8025cde:	d012      	beq.n	8025d06 <sm_handle_random_result_er+0x3a>
        // key generated, store in tlv
        int status = sm_tlv_impl->store_tag(sm_tlv_context, BTSTACK_TAG32('S','M','E','R'), sm_persistent_er, 16u);
 8025ce0:	4b1f      	ldr	r3, [pc, #124]	; (8025d60 <sm_handle_random_result_er+0x94>)
 8025ce2:	681b      	ldr	r3, [r3, #0]
 8025ce4:	685c      	ldr	r4, [r3, #4]
 8025ce6:	4b1f      	ldr	r3, [pc, #124]	; (8025d64 <sm_handle_random_result_er+0x98>)
 8025ce8:	6818      	ldr	r0, [r3, #0]
 8025cea:	2310      	movs	r3, #16
 8025cec:	4a1e      	ldr	r2, [pc, #120]	; (8025d68 <sm_handle_random_result_er+0x9c>)
 8025cee:	491f      	ldr	r1, [pc, #124]	; (8025d6c <sm_handle_random_result_er+0xa0>)
 8025cf0:	47a0      	blx	r4
 8025cf2:	60f8      	str	r0, [r7, #12]
        log_info("Generated ER key. Store in TLV status: %d", status);
 8025cf4:	68fb      	ldr	r3, [r7, #12]
 8025cf6:	9300      	str	r3, [sp, #0]
 8025cf8:	f640 5348 	movw	r3, #3400	; 0xd48
 8025cfc:	4a1c      	ldr	r2, [pc, #112]	; (8025d70 <sm_handle_random_result_er+0xa4>)
 8025cfe:	491d      	ldr	r1, [pc, #116]	; (8025d74 <sm_handle_random_result_er+0xa8>)
 8025d00:	2001      	movs	r0, #1
 8025d02:	f7f1 fb9d 	bl	8017440 <hci_dump_log>
        UNUSED(status);
    }
    log_info_key("ER", sm_persistent_er);
 8025d06:	4918      	ldr	r1, [pc, #96]	; (8025d68 <sm_handle_random_result_er+0x9c>)
 8025d08:	481b      	ldr	r0, [pc, #108]	; (8025d78 <sm_handle_random_result_er+0xac>)
 8025d0a:	f7e9 fb33 	bl	800f374 <log_info_key>

    // try load ir
    int key_size = sm_tlv_impl->get_tag(sm_tlv_context, BTSTACK_TAG32('S','M','I','R'), sm_persistent_ir, 16u);
 8025d0e:	4b14      	ldr	r3, [pc, #80]	; (8025d60 <sm_handle_random_result_er+0x94>)
 8025d10:	681b      	ldr	r3, [r3, #0]
 8025d12:	681c      	ldr	r4, [r3, #0]
 8025d14:	4b13      	ldr	r3, [pc, #76]	; (8025d64 <sm_handle_random_result_er+0x98>)
 8025d16:	6818      	ldr	r0, [r3, #0]
 8025d18:	2310      	movs	r3, #16
 8025d1a:	4a18      	ldr	r2, [pc, #96]	; (8025d7c <sm_handle_random_result_er+0xb0>)
 8025d1c:	4918      	ldr	r1, [pc, #96]	; (8025d80 <sm_handle_random_result_er+0xb4>)
 8025d1e:	47a0      	blx	r4
 8025d20:	60b8      	str	r0, [r7, #8]
    if (key_size == 16){
 8025d22:	68bb      	ldr	r3, [r7, #8]
 8025d24:	2b10      	cmp	r3, #16
 8025d26:	d10a      	bne.n	8025d3e <sm_handle_random_result_er+0x72>
        // ok, let's continue
        log_info("IR from TLV");
 8025d28:	f640 5351 	movw	r3, #3409	; 0xd51
 8025d2c:	4a10      	ldr	r2, [pc, #64]	; (8025d70 <sm_handle_random_result_er+0xa4>)
 8025d2e:	4915      	ldr	r1, [pc, #84]	; (8025d84 <sm_handle_random_result_er+0xb8>)
 8025d30:	2001      	movs	r0, #1
 8025d32:	f7f1 fb85 	bl	8017440 <hci_dump_log>
        sm_handle_random_result_ir( NULL );
 8025d36:	2000      	movs	r0, #0
 8025d38:	f7ff ff7a 	bl	8025c30 <sm_handle_random_result_ir>
    } else {
        // invalid, generate new random one
        sm_persistent_keys_random_active = true;
        btstack_crypto_random_generate(&sm_crypto_random_request, sm_persistent_ir, 16, &sm_handle_random_result_ir, &sm_persistent_ir);
    }
}
 8025d3c:	e00a      	b.n	8025d54 <sm_handle_random_result_er+0x88>
        sm_persistent_keys_random_active = true;
 8025d3e:	4b07      	ldr	r3, [pc, #28]	; (8025d5c <sm_handle_random_result_er+0x90>)
 8025d40:	2201      	movs	r2, #1
 8025d42:	701a      	strb	r2, [r3, #0]
        btstack_crypto_random_generate(&sm_crypto_random_request, sm_persistent_ir, 16, &sm_handle_random_result_ir, &sm_persistent_ir);
 8025d44:	4b0d      	ldr	r3, [pc, #52]	; (8025d7c <sm_handle_random_result_er+0xb0>)
 8025d46:	9300      	str	r3, [sp, #0]
 8025d48:	4b0f      	ldr	r3, [pc, #60]	; (8025d88 <sm_handle_random_result_er+0xbc>)
 8025d4a:	2210      	movs	r2, #16
 8025d4c:	490b      	ldr	r1, [pc, #44]	; (8025d7c <sm_handle_random_result_er+0xb0>)
 8025d4e:	480f      	ldr	r0, [pc, #60]	; (8025d8c <sm_handle_random_result_er+0xc0>)
 8025d50:	f7e8 fb74 	bl	800e43c <btstack_crypto_random_generate>
}
 8025d54:	bf00      	nop
 8025d56:	3714      	adds	r7, #20
 8025d58:	46bd      	mov	sp, r7
 8025d5a:	bd90      	pop	{r4, r7, pc}
 8025d5c:	20009f65 	.word	0x20009f65
 8025d60:	20009f68 	.word	0x20009f68
 8025d64:	20009f6c 	.word	0x20009f6c
 8025d68:	20009f70 	.word	0x20009f70
 8025d6c:	534d4552 	.word	0x534d4552
 8025d70:	0802d4a8 	.word	0x0802d4a8
 8025d74:	0802e0e0 	.word	0x0802e0e0
 8025d78:	0802e114 	.word	0x0802e114
 8025d7c:	20009f80 	.word	0x20009f80
 8025d80:	534d4952 	.word	0x534d4952
 8025d84:	0802e118 	.word	0x0802e118
 8025d88:	08025c31 	.word	0x08025c31
 8025d8c:	2000a06c 	.word	0x2000a06c

08025d90 <sm_event_packet_handler>:

static void sm_event_packet_handler (uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){
 8025d90:	b590      	push	{r4, r7, lr}
 8025d92:	b08d      	sub	sp, #52	; 0x34
 8025d94:	af02      	add	r7, sp, #8
 8025d96:	60ba      	str	r2, [r7, #8]
 8025d98:	461a      	mov	r2, r3
 8025d9a:	4603      	mov	r3, r0
 8025d9c:	73fb      	strb	r3, [r7, #15]
 8025d9e:	460b      	mov	r3, r1
 8025da0:	81bb      	strh	r3, [r7, #12]
 8025da2:	4613      	mov	r3, r2
 8025da4:	80fb      	strh	r3, [r7, #6]
    UNUSED(size);       // ok: fixed format HCI events

    sm_connection_t * sm_conn;
    hci_con_handle_t  con_handle;
    uint8_t           status;
    switch (packet_type) {
 8025da6:	7bfb      	ldrb	r3, [r7, #15]
 8025da8:	2b04      	cmp	r3, #4
 8025daa:	d000      	beq.n	8025dae <sm_event_packet_handler+0x1e>
                default:
                    break;
			}
            break;
        default:
            break;
 8025dac:	e2b5      	b.n	802631a <sm_event_packet_handler+0x58a>
			switch (hci_event_packet_get_type(packet)) {
 8025dae:	68b8      	ldr	r0, [r7, #8]
 8025db0:	f7fb f8aa 	bl	8020f08 <hci_event_packet_get_type>
 8025db4:	4603      	mov	r3, r0
 8025db6:	2b0e      	cmp	r3, #14
 8025db8:	f000 8289 	beq.w	80262ce <sm_event_packet_handler+0x53e>
 8025dbc:	2b0e      	cmp	r3, #14
 8025dbe:	dc06      	bgt.n	8025dce <sm_event_packet_handler+0x3e>
 8025dc0:	2b05      	cmp	r3, #5
 8025dc2:	f000 8258 	beq.w	8026276 <sm_event_packet_handler+0x4e6>
 8025dc6:	2b08      	cmp	r3, #8
 8025dc8:	f000 8131 	beq.w	802602e <sm_event_packet_handler+0x29e>
                    break;
 8025dcc:	e2a4      	b.n	8026318 <sm_event_packet_handler+0x588>
			switch (hci_event_packet_get_type(packet)) {
 8025dce:	2b3e      	cmp	r3, #62	; 0x3e
 8025dd0:	d055      	beq.n	8025e7e <sm_event_packet_handler+0xee>
 8025dd2:	2b60      	cmp	r3, #96	; 0x60
 8025dd4:	d003      	beq.n	8025dde <sm_event_packet_handler+0x4e>
 8025dd6:	2b30      	cmp	r3, #48	; 0x30
 8025dd8:	f000 81ff 	beq.w	80261da <sm_event_packet_handler+0x44a>
                    break;
 8025ddc:	e29c      	b.n	8026318 <sm_event_packet_handler+0x588>
					if (btstack_event_state_get_state(packet) == HCI_STATE_WORKING){
 8025dde:	68b8      	ldr	r0, [r7, #8]
 8025de0:	f7fb f8c5 	bl	8020f6e <btstack_event_state_get_state>
 8025de4:	4603      	mov	r3, r0
 8025de6:	2b02      	cmp	r3, #2
 8025de8:	f040 828d 	bne.w	8026306 <sm_event_packet_handler+0x576>
                        log_info("HCI Working!");
 8025dec:	f640 536a 	movw	r3, #3434	; 0xd6a
 8025df0:	4aa9      	ldr	r2, [pc, #676]	; (8026098 <sm_event_packet_handler+0x308>)
 8025df2:	49aa      	ldr	r1, [pc, #680]	; (802609c <sm_event_packet_handler+0x30c>)
 8025df4:	2001      	movs	r0, #1
 8025df6:	f7f1 fb23 	bl	8017440 <hci_dump_log>
                        btstack_tlv_get_instance(&sm_tlv_impl, &sm_tlv_context);
 8025dfa:	49a9      	ldr	r1, [pc, #676]	; (80260a0 <sm_event_packet_handler+0x310>)
 8025dfc:	48a9      	ldr	r0, [pc, #676]	; (80260a4 <sm_event_packet_handler+0x314>)
 8025dfe:	f7e8 ffbd 	bl	800ed7c <btstack_tlv_get_instance>
                        if (sm_tlv_impl != NULL){
 8025e02:	4ba8      	ldr	r3, [pc, #672]	; (80260a4 <sm_event_packet_handler+0x314>)
 8025e04:	681b      	ldr	r3, [r3, #0]
 8025e06:	2b00      	cmp	r3, #0
 8025e08:	d023      	beq.n	8025e52 <sm_event_packet_handler+0xc2>
                            int key_size = sm_tlv_impl->get_tag(sm_tlv_context, BTSTACK_TAG32('S','M','E','R'), sm_persistent_er, 16u);
 8025e0a:	4ba6      	ldr	r3, [pc, #664]	; (80260a4 <sm_event_packet_handler+0x314>)
 8025e0c:	681b      	ldr	r3, [r3, #0]
 8025e0e:	681c      	ldr	r4, [r3, #0]
 8025e10:	4ba3      	ldr	r3, [pc, #652]	; (80260a0 <sm_event_packet_handler+0x310>)
 8025e12:	6818      	ldr	r0, [r3, #0]
 8025e14:	2310      	movs	r3, #16
 8025e16:	4aa4      	ldr	r2, [pc, #656]	; (80260a8 <sm_event_packet_handler+0x318>)
 8025e18:	49a4      	ldr	r1, [pc, #656]	; (80260ac <sm_event_packet_handler+0x31c>)
 8025e1a:	47a0      	blx	r4
 8025e1c:	6238      	str	r0, [r7, #32]
                            if (key_size == 16){
 8025e1e:	6a3b      	ldr	r3, [r7, #32]
 8025e20:	2b10      	cmp	r3, #16
 8025e22:	d10a      	bne.n	8025e3a <sm_event_packet_handler+0xaa>
                                log_info("ER from TLV");
 8025e24:	f640 5372 	movw	r3, #3442	; 0xd72
 8025e28:	4a9b      	ldr	r2, [pc, #620]	; (8026098 <sm_event_packet_handler+0x308>)
 8025e2a:	49a1      	ldr	r1, [pc, #644]	; (80260b0 <sm_event_packet_handler+0x320>)
 8025e2c:	2001      	movs	r0, #1
 8025e2e:	f7f1 fb07 	bl	8017440 <hci_dump_log>
                                sm_handle_random_result_er( NULL );
 8025e32:	2000      	movs	r0, #0
 8025e34:	f7ff ff4a 	bl	8025ccc <sm_handle_random_result_er>
 8025e38:	e01b      	b.n	8025e72 <sm_event_packet_handler+0xe2>
                                sm_persistent_keys_random_active = true;
 8025e3a:	4b9e      	ldr	r3, [pc, #632]	; (80260b4 <sm_event_packet_handler+0x324>)
 8025e3c:	2201      	movs	r2, #1
 8025e3e:	701a      	strb	r2, [r3, #0]
                                btstack_crypto_random_generate(&sm_crypto_random_request, sm_persistent_er, 16, &sm_handle_random_result_er, &sm_persistent_er);
 8025e40:	4b99      	ldr	r3, [pc, #612]	; (80260a8 <sm_event_packet_handler+0x318>)
 8025e42:	9300      	str	r3, [sp, #0]
 8025e44:	4b9c      	ldr	r3, [pc, #624]	; (80260b8 <sm_event_packet_handler+0x328>)
 8025e46:	2210      	movs	r2, #16
 8025e48:	4997      	ldr	r1, [pc, #604]	; (80260a8 <sm_event_packet_handler+0x318>)
 8025e4a:	489c      	ldr	r0, [pc, #624]	; (80260bc <sm_event_packet_handler+0x32c>)
 8025e4c:	f7e8 faf6 	bl	800e43c <btstack_crypto_random_generate>
 8025e50:	e00f      	b.n	8025e72 <sm_event_packet_handler+0xe2>
                            sm_validate_er_ir();
 8025e52:	f7ff feb5 	bl	8025bc0 <sm_validate_er_ir>
                            dkg_state = DKG_CALC_IRK;
 8025e56:	4b9a      	ldr	r3, [pc, #616]	; (80260c0 <sm_event_packet_handler+0x330>)
 8025e58:	2201      	movs	r2, #1
 8025e5a:	701a      	strb	r2, [r3, #0]
                            if (test_use_fixed_local_irk){
 8025e5c:	4b99      	ldr	r3, [pc, #612]	; (80260c4 <sm_event_packet_handler+0x334>)
 8025e5e:	781b      	ldrb	r3, [r3, #0]
 8025e60:	2b00      	cmp	r3, #0
 8025e62:	d006      	beq.n	8025e72 <sm_event_packet_handler+0xe2>
                                log_info_key("IRK", sm_persistent_irk);
 8025e64:	4998      	ldr	r1, [pc, #608]	; (80260c8 <sm_event_packet_handler+0x338>)
 8025e66:	4899      	ldr	r0, [pc, #612]	; (80260cc <sm_event_packet_handler+0x33c>)
 8025e68:	f7e9 fa84 	bl	800f374 <log_info_key>
                                dkg_state = DKG_CALC_DHK;
 8025e6c:	4b94      	ldr	r3, [pc, #592]	; (80260c0 <sm_event_packet_handler+0x330>)
 8025e6e:	2202      	movs	r2, #2
 8025e70:	701a      	strb	r2, [r3, #0]
                        gap_random_address_set_mode(gap_random_adress_type);
 8025e72:	4b97      	ldr	r3, [pc, #604]	; (80260d0 <sm_event_packet_handler+0x340>)
 8025e74:	781b      	ldrb	r3, [r3, #0]
 8025e76:	4618      	mov	r0, r3
 8025e78:	f001 fab4 	bl	80273e4 <gap_random_address_set_mode>
					break;
 8025e7c:	e243      	b.n	8026306 <sm_event_packet_handler+0x576>
                    switch (packet[2]) {
 8025e7e:	68bb      	ldr	r3, [r7, #8]
 8025e80:	3302      	adds	r3, #2
 8025e82:	781b      	ldrb	r3, [r3, #0]
 8025e84:	2b01      	cmp	r3, #1
 8025e86:	d002      	beq.n	8025e8e <sm_event_packet_handler+0xfe>
 8025e88:	2b05      	cmp	r3, #5
 8025e8a:	d05f      	beq.n	8025f4c <sm_event_packet_handler+0x1bc>
                            break;
 8025e8c:	e0ce      	b.n	802602c <sm_event_packet_handler+0x29c>
                            log_info("sm: connected");
 8025e8e:	f640 538c 	movw	r3, #3468	; 0xd8c
 8025e92:	4a81      	ldr	r2, [pc, #516]	; (8026098 <sm_event_packet_handler+0x308>)
 8025e94:	498f      	ldr	r1, [pc, #572]	; (80260d4 <sm_event_packet_handler+0x344>)
 8025e96:	2001      	movs	r0, #1
 8025e98:	f7f1 fad2 	bl	8017440 <hci_dump_log>
                            if (packet[3]) return; // connection failed
 8025e9c:	68bb      	ldr	r3, [r7, #8]
 8025e9e:	3303      	adds	r3, #3
 8025ea0:	781b      	ldrb	r3, [r3, #0]
 8025ea2:	2b00      	cmp	r3, #0
 8025ea4:	f040 823c 	bne.w	8026320 <sm_event_packet_handler+0x590>
                            con_handle = little_endian_read_16(packet, 4);
 8025ea8:	2104      	movs	r1, #4
 8025eaa:	68b8      	ldr	r0, [r7, #8]
 8025eac:	f7e8 ff9b 	bl	800ede6 <little_endian_read_16>
 8025eb0:	4603      	mov	r3, r0
 8025eb2:	83fb      	strh	r3, [r7, #30]
                            sm_conn = sm_get_connection_for_handle(con_handle);
 8025eb4:	8bfb      	ldrh	r3, [r7, #30]
 8025eb6:	4618      	mov	r0, r3
 8025eb8:	f001 f95a 	bl	8027170 <sm_get_connection_for_handle>
 8025ebc:	61b8      	str	r0, [r7, #24]
                            if (!sm_conn) break;
 8025ebe:	69bb      	ldr	r3, [r7, #24]
 8025ec0:	2b00      	cmp	r3, #0
 8025ec2:	f000 80b0 	beq.w	8026026 <sm_event_packet_handler+0x296>
                            sm_conn->sm_handle = con_handle;
 8025ec6:	69bb      	ldr	r3, [r7, #24]
 8025ec8:	8bfa      	ldrh	r2, [r7, #30]
 8025eca:	801a      	strh	r2, [r3, #0]
                            sm_conn->sm_role = packet[6];
 8025ecc:	68bb      	ldr	r3, [r7, #8]
 8025ece:	799a      	ldrb	r2, [r3, #6]
 8025ed0:	69bb      	ldr	r3, [r7, #24]
 8025ed2:	709a      	strb	r2, [r3, #2]
                            sm_conn->sm_peer_addr_type = packet[7];
 8025ed4:	68bb      	ldr	r3, [r7, #8]
 8025ed6:	79da      	ldrb	r2, [r3, #7]
 8025ed8:	69bb      	ldr	r3, [r7, #24]
 8025eda:	715a      	strb	r2, [r3, #5]
                            reverse_bd_addr(&packet[8], sm_conn->sm_peer_address);
 8025edc:	68bb      	ldr	r3, [r7, #8]
 8025ede:	f103 0208 	add.w	r2, r3, #8
 8025ee2:	69bb      	ldr	r3, [r7, #24]
 8025ee4:	3306      	adds	r3, #6
 8025ee6:	4619      	mov	r1, r3
 8025ee8:	4610      	mov	r0, r2
 8025eea:	f7e9 f902 	bl	800f0f2 <reverse_bd_addr>
                            log_info("New sm_conn, role %s", sm_conn->sm_role ? "slave" : "master");
 8025eee:	69bb      	ldr	r3, [r7, #24]
 8025ef0:	789b      	ldrb	r3, [r3, #2]
 8025ef2:	2b00      	cmp	r3, #0
 8025ef4:	d001      	beq.n	8025efa <sm_event_packet_handler+0x16a>
 8025ef6:	4b78      	ldr	r3, [pc, #480]	; (80260d8 <sm_event_packet_handler+0x348>)
 8025ef8:	e000      	b.n	8025efc <sm_event_packet_handler+0x16c>
 8025efa:	4b78      	ldr	r3, [pc, #480]	; (80260dc <sm_event_packet_handler+0x34c>)
 8025efc:	9300      	str	r3, [sp, #0]
 8025efe:	f640 5399 	movw	r3, #3481	; 0xd99
 8025f02:	4a65      	ldr	r2, [pc, #404]	; (8026098 <sm_event_packet_handler+0x308>)
 8025f04:	4976      	ldr	r1, [pc, #472]	; (80260e0 <sm_event_packet_handler+0x350>)
 8025f06:	2001      	movs	r0, #1
 8025f08:	f7f1 fa9a 	bl	8017440 <hci_dump_log>
                            sm_conn->sm_connection_encrypted = 0;
 8025f0c:	69bb      	ldr	r3, [r7, #24]
 8025f0e:	2200      	movs	r2, #0
 8025f10:	739a      	strb	r2, [r3, #14]
                            sm_conn->sm_connection_authenticated = 0;
 8025f12:	69bb      	ldr	r3, [r7, #24]
 8025f14:	2200      	movs	r2, #0
 8025f16:	73da      	strb	r2, [r3, #15]
                            sm_conn->sm_connection_authorization_state = AUTHORIZATION_UNKNOWN;
 8025f18:	69bb      	ldr	r3, [r7, #24]
 8025f1a:	2200      	movs	r2, #0
 8025f1c:	765a      	strb	r2, [r3, #25]
                            sm_conn->sm_le_db_index = -1;
 8025f1e:	69bb      	ldr	r3, [r7, #24]
 8025f20:	f04f 32ff 	mov.w	r2, #4294967295
 8025f24:	625a      	str	r2, [r3, #36]	; 0x24
                            sm_conn->sm_reencryption_active = false;
 8025f26:	69bb      	ldr	r3, [r7, #24]
 8025f28:	2200      	movs	r2, #0
 8025f2a:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
                            sm_conn->sm_irk_lookup_state = IRK_LOOKUP_W4_READY;
 8025f2e:	69bb      	ldr	r3, [r7, #24]
 8025f30:	2201      	movs	r2, #1
 8025f32:	735a      	strb	r2, [r3, #13]
                            if (IS_RESPONDER(sm_conn->sm_role)){
 8025f34:	69bb      	ldr	r3, [r7, #24]
 8025f36:	789b      	ldrb	r3, [r3, #2]
 8025f38:	2b00      	cmp	r3, #0
 8025f3a:	d003      	beq.n	8025f44 <sm_event_packet_handler+0x1b4>
                                sm_conn->sm_engine_state = SM_RESPONDER_IDLE;
 8025f3c:	69bb      	ldr	r3, [r7, #24]
 8025f3e:	221a      	movs	r2, #26
 8025f40:	731a      	strb	r2, [r3, #12]
                                break;
 8025f42:	e073      	b.n	802602c <sm_event_packet_handler+0x29c>
                                sm_conn->sm_engine_state = SM_INITIATOR_CONNECTED;
 8025f44:	69bb      	ldr	r3, [r7, #24]
 8025f46:	2229      	movs	r2, #41	; 0x29
 8025f48:	731a      	strb	r2, [r3, #12]
                            break;
 8025f4a:	e06f      	b.n	802602c <sm_event_packet_handler+0x29c>
                            con_handle = little_endian_read_16(packet, 3);
 8025f4c:	2103      	movs	r1, #3
 8025f4e:	68b8      	ldr	r0, [r7, #8]
 8025f50:	f7e8 ff49 	bl	800ede6 <little_endian_read_16>
 8025f54:	4603      	mov	r3, r0
 8025f56:	83fb      	strh	r3, [r7, #30]
                            sm_conn = sm_get_connection_for_handle(con_handle);
 8025f58:	8bfb      	ldrh	r3, [r7, #30]
 8025f5a:	4618      	mov	r0, r3
 8025f5c:	f001 f908 	bl	8027170 <sm_get_connection_for_handle>
 8025f60:	61b8      	str	r0, [r7, #24]
                            if (!sm_conn) break;
 8025f62:	69bb      	ldr	r3, [r7, #24]
 8025f64:	2b00      	cmp	r3, #0
 8025f66:	d060      	beq.n	802602a <sm_event_packet_handler+0x29a>
                            log_info("LTK Request: state %u", sm_conn->sm_engine_state);
 8025f68:	69bb      	ldr	r3, [r7, #24]
 8025f6a:	7b1b      	ldrb	r3, [r3, #12]
 8025f6c:	9300      	str	r3, [sp, #0]
 8025f6e:	f640 53b5 	movw	r3, #3509	; 0xdb5
 8025f72:	4a49      	ldr	r2, [pc, #292]	; (8026098 <sm_event_packet_handler+0x308>)
 8025f74:	495b      	ldr	r1, [pc, #364]	; (80260e4 <sm_event_packet_handler+0x354>)
 8025f76:	2001      	movs	r0, #1
 8025f78:	f7f1 fa62 	bl	8017440 <hci_dump_log>
                            if (sm_conn->sm_engine_state == SM_RESPONDER_PH2_W4_LTK_REQUEST){
 8025f7c:	69bb      	ldr	r3, [r7, #24]
 8025f7e:	7b1b      	ldrb	r3, [r3, #12]
 8025f80:	2b25      	cmp	r3, #37	; 0x25
 8025f82:	d103      	bne.n	8025f8c <sm_event_packet_handler+0x1fc>
                                sm_conn->sm_engine_state = SM_PH2_CALC_STK;
 8025f84:	69bb      	ldr	r3, [r7, #24]
 8025f86:	2211      	movs	r2, #17
 8025f88:	731a      	strb	r2, [r3, #12]
                                break;
 8025f8a:	e04f      	b.n	802602c <sm_event_packet_handler+0x29c>
                            if (sm_conn->sm_engine_state == SM_SC_W4_LTK_REQUEST_SC){
 8025f8c:	69bb      	ldr	r3, [r7, #24]
 8025f8e:	7b1b      	ldrb	r3, [r3, #12]
 8025f90:	2b4c      	cmp	r3, #76	; 0x4c
 8025f92:	d103      	bne.n	8025f9c <sm_event_packet_handler+0x20c>
                                sm_conn->sm_engine_state = SM_RESPONDER_PH2_SEND_LTK_REPLY;
 8025f94:	69bb      	ldr	r3, [r7, #24]
 8025f96:	2226      	movs	r2, #38	; 0x26
 8025f98:	731a      	strb	r2, [r3, #12]
                                break;
 8025f9a:	e047      	b.n	802602c <sm_event_packet_handler+0x29c>
                            reverse_64(&packet[5], sm_conn->sm_local_rand);
 8025f9c:	68bb      	ldr	r3, [r7, #8]
 8025f9e:	1d5a      	adds	r2, r3, #5
 8025fa0:	69bb      	ldr	r3, [r7, #24]
 8025fa2:	331c      	adds	r3, #28
 8025fa4:	4619      	mov	r1, r3
 8025fa6:	4610      	mov	r0, r2
 8025fa8:	f7e9 f879 	bl	800f09e <reverse_64>
                            sm_conn->sm_local_ediv = little_endian_read_16(packet, 13);
 8025fac:	210d      	movs	r1, #13
 8025fae:	68b8      	ldr	r0, [r7, #8]
 8025fb0:	f7e8 ff19 	bl	800ede6 <little_endian_read_16>
 8025fb4:	4603      	mov	r3, r0
 8025fb6:	461a      	mov	r2, r3
 8025fb8:	69bb      	ldr	r3, [r7, #24]
 8025fba:	835a      	strh	r2, [r3, #26]
                            if ((sm_conn->sm_local_ediv != 0u) || !sm_is_null_random(sm_conn->sm_local_rand)){
 8025fbc:	69bb      	ldr	r3, [r7, #24]
 8025fbe:	8b5b      	ldrh	r3, [r3, #26]
 8025fc0:	2b00      	cmp	r3, #0
 8025fc2:	d10a      	bne.n	8025fda <sm_event_packet_handler+0x24a>
 8025fc4:	69bb      	ldr	r3, [r7, #24]
 8025fc6:	331c      	adds	r3, #28
 8025fc8:	4618      	mov	r0, r3
 8025fca:	f7fb f8cc 	bl	8021166 <sm_is_null_random>
 8025fce:	4603      	mov	r3, r0
 8025fd0:	f083 0301 	eor.w	r3, r3, #1
 8025fd4:	b2db      	uxtb	r3, r3
 8025fd6:	2b00      	cmp	r3, #0
 8025fd8:	d021      	beq.n	802601e <sm_event_packet_handler+0x28e>
                                if (sm_reconstruct_ltk_without_le_device_db_entry){
 8025fda:	4b43      	ldr	r3, [pc, #268]	; (80260e8 <sm_event_packet_handler+0x358>)
 8025fdc:	781b      	ldrb	r3, [r3, #0]
 8025fde:	2b00      	cmp	r3, #0
 8025fe0:	d003      	beq.n	8025fea <sm_event_packet_handler+0x25a>
                                    sm_conn->sm_engine_state = SM_RESPONDER_PH0_RECEIVED_LTK_REQUEST;
 8025fe2:	69bb      	ldr	r3, [r7, #24]
 8025fe4:	221c      	movs	r2, #28
 8025fe6:	731a      	strb	r2, [r3, #12]
                                    break;
 8025fe8:	e020      	b.n	802602c <sm_event_packet_handler+0x29c>
                                switch(sm_conn->sm_irk_lookup_state){
 8025fea:	69bb      	ldr	r3, [r7, #24]
 8025fec:	7b5b      	ldrb	r3, [r3, #13]
 8025fee:	2b03      	cmp	r3, #3
 8025ff0:	d00c      	beq.n	802600c <sm_event_packet_handler+0x27c>
 8025ff2:	2b04      	cmp	r3, #4
 8025ff4:	d10e      	bne.n	8026014 <sm_event_packet_handler+0x284>
                                        log_info("LTK Request: device not in device db");
 8025ff6:	f640 53ce 	movw	r3, #3534	; 0xdce
 8025ffa:	4a27      	ldr	r2, [pc, #156]	; (8026098 <sm_event_packet_handler+0x308>)
 8025ffc:	493b      	ldr	r1, [pc, #236]	; (80260ec <sm_event_packet_handler+0x35c>)
 8025ffe:	2001      	movs	r0, #1
 8026000:	f7f1 fa1e 	bl	8017440 <hci_dump_log>
                                        sm_conn->sm_engine_state = SM_RESPONDER_PH0_SEND_LTK_REQUESTED_NEGATIVE_REPLY;
 8026004:	69bb      	ldr	r3, [r7, #24]
 8026006:	221e      	movs	r2, #30
 8026008:	731a      	strb	r2, [r3, #12]
                                        break;
 802600a:	e007      	b.n	802601c <sm_event_packet_handler+0x28c>
                                        sm_conn->sm_engine_state = SM_RESPONDER_PH0_RECEIVED_LTK_REQUEST;
 802600c:	69bb      	ldr	r3, [r7, #24]
 802600e:	221c      	movs	r2, #28
 8026010:	731a      	strb	r2, [r3, #12]
                                        break;
 8026012:	e003      	b.n	802601c <sm_event_packet_handler+0x28c>
                                        sm_conn->sm_engine_state = SM_RESPONDER_PH0_RECEIVED_LTK_W4_IRK;
 8026014:	69bb      	ldr	r3, [r7, #24]
 8026016:	221d      	movs	r2, #29
 8026018:	731a      	strb	r2, [r3, #12]
                                        break;
 802601a:	bf00      	nop
                                break;
 802601c:	e006      	b.n	802602c <sm_event_packet_handler+0x29c>
                            sm_conn->sm_engine_state = SM_SC_RECEIVED_LTK_REQUEST;
 802601e:	69bb      	ldr	r3, [r7, #24]
 8026020:	2230      	movs	r2, #48	; 0x30
 8026022:	731a      	strb	r2, [r3, #12]
                            break;
 8026024:	e002      	b.n	802602c <sm_event_packet_handler+0x29c>
                            if (!sm_conn) break;
 8026026:	bf00      	nop
 8026028:	e176      	b.n	8026318 <sm_event_packet_handler+0x588>
                            if (!sm_conn) break;
 802602a:	bf00      	nop
                    break;
 802602c:	e174      	b.n	8026318 <sm_event_packet_handler+0x588>
                	con_handle = hci_event_encryption_change_get_connection_handle(packet);
 802602e:	68b8      	ldr	r0, [r7, #8]
 8026030:	f7fa ff83 	bl	8020f3a <hci_event_encryption_change_get_connection_handle>
 8026034:	4603      	mov	r3, r0
 8026036:	83fb      	strh	r3, [r7, #30]
                    sm_conn = sm_get_connection_for_handle(con_handle);
 8026038:	8bfb      	ldrh	r3, [r7, #30]
 802603a:	4618      	mov	r0, r3
 802603c:	f001 f898 	bl	8027170 <sm_get_connection_for_handle>
 8026040:	61b8      	str	r0, [r7, #24]
                    if (!sm_conn) break;
 8026042:	69bb      	ldr	r3, [r7, #24]
 8026044:	2b00      	cmp	r3, #0
 8026046:	f000 8160 	beq.w	802630a <sm_event_packet_handler+0x57a>
                    sm_conn->sm_connection_encrypted = hci_event_encryption_change_get_encryption_enabled(packet);
 802604a:	68b8      	ldr	r0, [r7, #8]
 802604c:	f7fa ff82 	bl	8020f54 <hci_event_encryption_change_get_encryption_enabled>
 8026050:	4603      	mov	r3, r0
 8026052:	461a      	mov	r2, r3
 8026054:	69bb      	ldr	r3, [r7, #24]
 8026056:	739a      	strb	r2, [r3, #14]
                    log_info("Encryption state change: %u, key size %u", sm_conn->sm_connection_encrypted,
 8026058:	69bb      	ldr	r3, [r7, #24]
 802605a:	7b9b      	ldrb	r3, [r3, #14]
 802605c:	461a      	mov	r2, r3
 802605e:	69bb      	ldr	r3, [r7, #24]
 8026060:	7c5b      	ldrb	r3, [r3, #17]
 8026062:	9301      	str	r3, [sp, #4]
 8026064:	9200      	str	r2, [sp, #0]
 8026066:	f44f 635f 	mov.w	r3, #3568	; 0xdf0
 802606a:	4a0b      	ldr	r2, [pc, #44]	; (8026098 <sm_event_packet_handler+0x308>)
 802606c:	4920      	ldr	r1, [pc, #128]	; (80260f0 <sm_event_packet_handler+0x360>)
 802606e:	2001      	movs	r0, #1
 8026070:	f7f1 f9e6 	bl	8017440 <hci_dump_log>
                    log_info("event handler, state %u", sm_conn->sm_engine_state);
 8026074:	69bb      	ldr	r3, [r7, #24]
 8026076:	7b1b      	ldrb	r3, [r3, #12]
 8026078:	9300      	str	r3, [sp, #0]
 802607a:	f640 53f1 	movw	r3, #3569	; 0xdf1
 802607e:	4a06      	ldr	r2, [pc, #24]	; (8026098 <sm_event_packet_handler+0x308>)
 8026080:	491c      	ldr	r1, [pc, #112]	; (80260f4 <sm_event_packet_handler+0x364>)
 8026082:	2001      	movs	r0, #1
 8026084:	f7f1 f9dc 	bl	8017440 <hci_dump_log>
                    switch (sm_conn->sm_engine_state){
 8026088:	69bb      	ldr	r3, [r7, #24]
 802608a:	7b1b      	ldrb	r3, [r3, #12]
 802608c:	2b13      	cmp	r3, #19
 802608e:	d069      	beq.n	8026164 <sm_event_packet_handler+0x3d4>
 8026090:	2b19      	cmp	r3, #25
 8026092:	d031      	beq.n	80260f8 <sm_event_packet_handler+0x368>
                            break;
 8026094:	e0a0      	b.n	80261d8 <sm_event_packet_handler+0x448>
 8026096:	bf00      	nop
 8026098:	0802d4a8 	.word	0x0802d4a8
 802609c:	0802e12c 	.word	0x0802e12c
 80260a0:	20009f6c 	.word	0x20009f6c
 80260a4:	20009f68 	.word	0x20009f68
 80260a8:	20009f70 	.word	0x20009f70
 80260ac:	534d4552 	.word	0x534d4552
 80260b0:	0802e140 	.word	0x0802e140
 80260b4:	20009f65 	.word	0x20009f65
 80260b8:	08025ccd 	.word	0x08025ccd
 80260bc:	2000a06c 	.word	0x2000a06c
 80260c0:	20009fb0 	.word	0x20009fb0
 80260c4:	20009f42 	.word	0x20009f42
 80260c8:	20009fa0 	.word	0x20009fa0
 80260cc:	0802dc68 	.word	0x0802dc68
 80260d0:	2000a364 	.word	0x2000a364
 80260d4:	0802e154 	.word	0x0802e154
 80260d8:	0802e16c 	.word	0x0802e16c
 80260dc:	0802e174 	.word	0x0802e174
 80260e0:	0802e17c 	.word	0x0802e17c
 80260e4:	0802e198 	.word	0x0802e198
 80260e8:	20009f4c 	.word	0x20009f4c
 80260ec:	0802e1b8 	.word	0x0802e1b8
 80260f0:	0802e1e4 	.word	0x0802e1e4
 80260f4:	0802e214 	.word	0x0802e214
                            if (sm_conn->sm_connection_encrypted) {
 80260f8:	69bb      	ldr	r3, [r7, #24]
 80260fa:	7b9b      	ldrb	r3, [r3, #14]
 80260fc:	2b00      	cmp	r3, #0
 80260fe:	d00e      	beq.n	802611e <sm_event_packet_handler+0x38e>
                                status = ERROR_CODE_SUCCESS;
 8026100:	2300      	movs	r3, #0
 8026102:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                                if (sm_conn->sm_role){
 8026106:	69bb      	ldr	r3, [r7, #24]
 8026108:	789b      	ldrb	r3, [r3, #2]
 802610a:	2b00      	cmp	r3, #0
 802610c:	d003      	beq.n	8026116 <sm_event_packet_handler+0x386>
                                    sm_conn->sm_engine_state = SM_RESPONDER_IDLE;
 802610e:	69bb      	ldr	r3, [r7, #24]
 8026110:	221a      	movs	r2, #26
 8026112:	731a      	strb	r2, [r3, #12]
 8026114:	e00c      	b.n	8026130 <sm_event_packet_handler+0x3a0>
                                    sm_conn->sm_engine_state = SM_INITIATOR_CONNECTED;
 8026116:	69bb      	ldr	r3, [r7, #24]
 8026118:	2229      	movs	r2, #41	; 0x29
 802611a:	731a      	strb	r2, [r3, #12]
 802611c:	e008      	b.n	8026130 <sm_event_packet_handler+0x3a0>
                                status = hci_event_encryption_change_get_status(packet);
 802611e:	68b8      	ldr	r0, [r7, #8]
 8026120:	f7fa fefe 	bl	8020f20 <hci_event_encryption_change_get_status>
 8026124:	4603      	mov	r3, r0
 8026126:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                                sm_conn->sm_engine_state = SM_GENERAL_REENCRYPTION_FAILED;
 802612a:	69bb      	ldr	r3, [r7, #24]
 802612c:	2203      	movs	r2, #3
 802612e:	731a      	strb	r2, [r3, #12]
                            sm_reencryption_complete(sm_conn, status);
 8026130:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8026134:	4619      	mov	r1, r3
 8026136:	69b8      	ldr	r0, [r7, #24]
 8026138:	f7fb fa2f 	bl	802159a <sm_reencryption_complete>
                            if (sm_conn->sm_pairing_requested){
 802613c:	69bb      	ldr	r3, [r7, #24]
 802613e:	791b      	ldrb	r3, [r3, #4]
 8026140:	2b00      	cmp	r3, #0
 8026142:	d009      	beq.n	8026158 <sm_event_packet_handler+0x3c8>
                                sm_conn->sm_pairing_requested = 0;
 8026144:	69bb      	ldr	r3, [r7, #24]
 8026146:	2200      	movs	r2, #0
 8026148:	711a      	strb	r2, [r3, #4]
                                sm_pairing_complete(sm_conn, status, 0);
 802614a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 802614e:	2200      	movs	r2, #0
 8026150:	4619      	mov	r1, r3
 8026152:	69b8      	ldr	r0, [r7, #24]
 8026154:	f7fb fa8c 	bl	8021670 <sm_pairing_complete>
                            sm_done_for_handle(sm_conn->sm_handle);
 8026158:	69bb      	ldr	r3, [r7, #24]
 802615a:	881b      	ldrh	r3, [r3, #0]
 802615c:	4618      	mov	r0, r3
 802615e:	f7fb ff49 	bl	8021ff4 <sm_done_for_handle>
                            break;
 8026162:	e039      	b.n	80261d8 <sm_event_packet_handler+0x448>
                            if (!sm_conn->sm_connection_encrypted) break;
 8026164:	69bb      	ldr	r3, [r7, #24]
 8026166:	7b9b      	ldrb	r3, [r3, #14]
 8026168:	2b00      	cmp	r3, #0
 802616a:	d034      	beq.n	80261d6 <sm_event_packet_handler+0x446>
                            sm_conn->sm_connection_sc = setup->sm_use_secure_connections;
 802616c:	4b6e      	ldr	r3, [pc, #440]	; (8026328 <sm_event_packet_handler+0x598>)
 802616e:	681b      	ldr	r3, [r3, #0]
 8026170:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
 8026174:	69bb      	ldr	r3, [r7, #24]
 8026176:	741a      	strb	r2, [r3, #16]
                            if (IS_RESPONDER(sm_conn->sm_role)){
 8026178:	69bb      	ldr	r3, [r7, #24]
 802617a:	789b      	ldrb	r3, [r3, #2]
 802617c:	2b00      	cmp	r3, #0
 802617e:	d013      	beq.n	80261a8 <sm_event_packet_handler+0x418>
                                if (setup->sm_use_secure_connections){
 8026180:	4b69      	ldr	r3, [pc, #420]	; (8026328 <sm_event_packet_handler+0x598>)
 8026182:	681b      	ldr	r3, [r3, #0]
 8026184:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8026188:	2b00      	cmp	r3, #0
 802618a:	d003      	beq.n	8026194 <sm_event_packet_handler+0x404>
                                    sm_conn->sm_engine_state = SM_PH3_DISTRIBUTE_KEYS;
 802618c:	69bb      	ldr	r3, [r7, #24]
 802618e:	2217      	movs	r2, #23
 8026190:	731a      	strb	r2, [r3, #12]
                            break;
 8026192:	e021      	b.n	80261d8 <sm_event_packet_handler+0x448>
                                    btstack_crypto_random_generate(&sm_crypto_random_request, sm_random_data, 8, &sm_handle_random_result_ph3_random, (void *)(uintptr_t) sm_conn->sm_handle);
 8026194:	69bb      	ldr	r3, [r7, #24]
 8026196:	881b      	ldrh	r3, [r3, #0]
 8026198:	9300      	str	r3, [sp, #0]
 802619a:	4b64      	ldr	r3, [pc, #400]	; (802632c <sm_event_packet_handler+0x59c>)
 802619c:	2208      	movs	r2, #8
 802619e:	4964      	ldr	r1, [pc, #400]	; (8026330 <sm_event_packet_handler+0x5a0>)
 80261a0:	4864      	ldr	r0, [pc, #400]	; (8026334 <sm_event_packet_handler+0x5a4>)
 80261a2:	f7e8 f94b 	bl	800e43c <btstack_crypto_random_generate>
                            break;
 80261a6:	e017      	b.n	80261d8 <sm_event_packet_handler+0x448>
                                if (sm_key_distribution_all_received(sm_conn)){
 80261a8:	69b8      	ldr	r0, [r7, #24]
 80261aa:	f7fb fee7 	bl	8021f7c <sm_key_distribution_all_received>
 80261ae:	4603      	mov	r3, r0
 80261b0:	2b00      	cmp	r3, #0
 80261b2:	d00c      	beq.n	80261ce <sm_event_packet_handler+0x43e>
                                    sm_key_distribution_handle_all_received(sm_conn);
 80261b4:	69b8      	ldr	r0, [r7, #24]
 80261b6:	f7fc fa95 	bl	80226e4 <sm_key_distribution_handle_all_received>
                                    btstack_crypto_random_generate(&sm_crypto_random_request, sm_random_data, 8, &sm_handle_random_result_ph3_random, (void *)(uintptr_t) sm_conn->sm_handle);
 80261ba:	69bb      	ldr	r3, [r7, #24]
 80261bc:	881b      	ldrh	r3, [r3, #0]
 80261be:	9300      	str	r3, [sp, #0]
 80261c0:	4b5a      	ldr	r3, [pc, #360]	; (802632c <sm_event_packet_handler+0x59c>)
 80261c2:	2208      	movs	r2, #8
 80261c4:	495a      	ldr	r1, [pc, #360]	; (8026330 <sm_event_packet_handler+0x5a0>)
 80261c6:	485b      	ldr	r0, [pc, #364]	; (8026334 <sm_event_packet_handler+0x5a4>)
 80261c8:	f7e8 f938 	bl	800e43c <btstack_crypto_random_generate>
                            break;
 80261cc:	e004      	b.n	80261d8 <sm_event_packet_handler+0x448>
                                    sm_conn->sm_engine_state = SM_PH3_RECEIVE_KEYS;
 80261ce:	69bb      	ldr	r3, [r7, #24]
 80261d0:	2218      	movs	r2, #24
 80261d2:	731a      	strb	r2, [r3, #12]
                            break;
 80261d4:	e000      	b.n	80261d8 <sm_event_packet_handler+0x448>
                            if (!sm_conn->sm_connection_encrypted) break;
 80261d6:	bf00      	nop
                    break;
 80261d8:	e09e      	b.n	8026318 <sm_event_packet_handler+0x588>
                    con_handle = little_endian_read_16(packet, 3);
 80261da:	2103      	movs	r1, #3
 80261dc:	68b8      	ldr	r0, [r7, #8]
 80261de:	f7e8 fe02 	bl	800ede6 <little_endian_read_16>
 80261e2:	4603      	mov	r3, r0
 80261e4:	83fb      	strh	r3, [r7, #30]
                    sm_conn = sm_get_connection_for_handle(con_handle);
 80261e6:	8bfb      	ldrh	r3, [r7, #30]
 80261e8:	4618      	mov	r0, r3
 80261ea:	f000 ffc1 	bl	8027170 <sm_get_connection_for_handle>
 80261ee:	61b8      	str	r0, [r7, #24]
                    if (!sm_conn) break;
 80261f0:	69bb      	ldr	r3, [r7, #24]
 80261f2:	2b00      	cmp	r3, #0
 80261f4:	f000 808b 	beq.w	802630e <sm_event_packet_handler+0x57e>
                    log_info("Encryption key refresh complete, key size %u", sm_conn->sm_actual_encryption_key_size);
 80261f8:	69bb      	ldr	r3, [r7, #24]
 80261fa:	7c5b      	ldrb	r3, [r3, #17]
 80261fc:	9300      	str	r3, [sp, #0]
 80261fe:	f44f 6363 	mov.w	r3, #3632	; 0xe30
 8026202:	4a4d      	ldr	r2, [pc, #308]	; (8026338 <sm_event_packet_handler+0x5a8>)
 8026204:	494d      	ldr	r1, [pc, #308]	; (802633c <sm_event_packet_handler+0x5ac>)
 8026206:	2001      	movs	r0, #1
 8026208:	f7f1 f91a 	bl	8017440 <hci_dump_log>
                    log_info("event handler, state %u", sm_conn->sm_engine_state);
 802620c:	69bb      	ldr	r3, [r7, #24]
 802620e:	7b1b      	ldrb	r3, [r3, #12]
 8026210:	9300      	str	r3, [sp, #0]
 8026212:	f640 6331 	movw	r3, #3633	; 0xe31
 8026216:	4a48      	ldr	r2, [pc, #288]	; (8026338 <sm_event_packet_handler+0x5a8>)
 8026218:	4949      	ldr	r1, [pc, #292]	; (8026340 <sm_event_packet_handler+0x5b0>)
 802621a:	2001      	movs	r0, #1
 802621c:	f7f1 f910 	bl	8017440 <hci_dump_log>
                    switch (sm_conn->sm_engine_state){
 8026220:	69bb      	ldr	r3, [r7, #24]
 8026222:	7b1b      	ldrb	r3, [r3, #12]
 8026224:	2b13      	cmp	r3, #19
 8026226:	d013      	beq.n	8026250 <sm_event_packet_handler+0x4c0>
 8026228:	2b19      	cmp	r3, #25
 802622a:	d000      	beq.n	802622e <sm_event_packet_handler+0x49e>
                            break;
 802622c:	e022      	b.n	8026274 <sm_event_packet_handler+0x4e4>
                            if (sm_conn->sm_role){
 802622e:	69bb      	ldr	r3, [r7, #24]
 8026230:	789b      	ldrb	r3, [r3, #2]
 8026232:	2b00      	cmp	r3, #0
 8026234:	d003      	beq.n	802623e <sm_event_packet_handler+0x4ae>
                                sm_conn->sm_engine_state = SM_RESPONDER_IDLE;
 8026236:	69bb      	ldr	r3, [r7, #24]
 8026238:	221a      	movs	r2, #26
 802623a:	731a      	strb	r2, [r3, #12]
 802623c:	e002      	b.n	8026244 <sm_event_packet_handler+0x4b4>
                                sm_conn->sm_engine_state = SM_INITIATOR_CONNECTED;
 802623e:	69bb      	ldr	r3, [r7, #24]
 8026240:	2229      	movs	r2, #41	; 0x29
 8026242:	731a      	strb	r2, [r3, #12]
                            sm_done_for_handle(sm_conn->sm_handle);
 8026244:	69bb      	ldr	r3, [r7, #24]
 8026246:	881b      	ldrh	r3, [r3, #0]
 8026248:	4618      	mov	r0, r3
 802624a:	f7fb fed3 	bl	8021ff4 <sm_done_for_handle>
                            break;
 802624e:	e011      	b.n	8026274 <sm_event_packet_handler+0x4e4>
                            if (IS_RESPONDER(sm_conn->sm_role)){
 8026250:	69bb      	ldr	r3, [r7, #24]
 8026252:	789b      	ldrb	r3, [r3, #2]
 8026254:	2b00      	cmp	r3, #0
 8026256:	d009      	beq.n	802626c <sm_event_packet_handler+0x4dc>
                                btstack_crypto_random_generate(&sm_crypto_random_request, sm_random_data, 8, &sm_handle_random_result_ph3_random, (void *)(uintptr_t) sm_conn->sm_handle);
 8026258:	69bb      	ldr	r3, [r7, #24]
 802625a:	881b      	ldrh	r3, [r3, #0]
 802625c:	9300      	str	r3, [sp, #0]
 802625e:	4b33      	ldr	r3, [pc, #204]	; (802632c <sm_event_packet_handler+0x59c>)
 8026260:	2208      	movs	r2, #8
 8026262:	4933      	ldr	r1, [pc, #204]	; (8026330 <sm_event_packet_handler+0x5a0>)
 8026264:	4833      	ldr	r0, [pc, #204]	; (8026334 <sm_event_packet_handler+0x5a4>)
 8026266:	f7e8 f8e9 	bl	800e43c <btstack_crypto_random_generate>
                            break;
 802626a:	e002      	b.n	8026272 <sm_event_packet_handler+0x4e2>
                                sm_conn->sm_engine_state = SM_PH3_RECEIVE_KEYS;
 802626c:	69bb      	ldr	r3, [r7, #24]
 802626e:	2218      	movs	r2, #24
 8026270:	731a      	strb	r2, [r3, #12]
                            break;
 8026272:	bf00      	nop
                    break;
 8026274:	e050      	b.n	8026318 <sm_event_packet_handler+0x588>
                    con_handle = little_endian_read_16(packet, 3);
 8026276:	2103      	movs	r1, #3
 8026278:	68b8      	ldr	r0, [r7, #8]
 802627a:	f7e8 fdb4 	bl	800ede6 <little_endian_read_16>
 802627e:	4603      	mov	r3, r0
 8026280:	83fb      	strh	r3, [r7, #30]
                    sm_done_for_handle(con_handle);
 8026282:	8bfb      	ldrh	r3, [r7, #30]
 8026284:	4618      	mov	r0, r3
 8026286:	f7fb feb5 	bl	8021ff4 <sm_done_for_handle>
                    sm_conn = sm_get_connection_for_handle(con_handle);
 802628a:	8bfb      	ldrh	r3, [r7, #30]
 802628c:	4618      	mov	r0, r3
 802628e:	f000 ff6f 	bl	8027170 <sm_get_connection_for_handle>
 8026292:	61b8      	str	r0, [r7, #24]
                    if (!sm_conn) break;
 8026294:	69bb      	ldr	r3, [r7, #24]
 8026296:	2b00      	cmp	r3, #0
 8026298:	d03b      	beq.n	8026312 <sm_event_packet_handler+0x582>
                    switch (sm_conn->sm_engine_state){
 802629a:	69bb      	ldr	r3, [r7, #24]
 802629c:	7b1b      	ldrb	r3, [r3, #12]
 802629e:	2b1a      	cmp	r3, #26
 80262a0:	d00d      	beq.n	80262be <sm_event_packet_handler+0x52e>
 80262a2:	2b29      	cmp	r3, #41	; 0x29
 80262a4:	d00b      	beq.n	80262be <sm_event_packet_handler+0x52e>
 80262a6:	2b00      	cmp	r3, #0
 80262a8:	d009      	beq.n	80262be <sm_event_packet_handler+0x52e>
                            sm_reencryption_complete(sm_conn, ERROR_CODE_REMOTE_USER_TERMINATED_CONNECTION);
 80262aa:	2113      	movs	r1, #19
 80262ac:	69b8      	ldr	r0, [r7, #24]
 80262ae:	f7fb f974 	bl	802159a <sm_reencryption_complete>
                            sm_pairing_complete(sm_conn, ERROR_CODE_REMOTE_USER_TERMINATED_CONNECTION, 0);
 80262b2:	2200      	movs	r2, #0
 80262b4:	2113      	movs	r1, #19
 80262b6:	69b8      	ldr	r0, [r7, #24]
 80262b8:	f7fb f9da 	bl	8021670 <sm_pairing_complete>
                            break;
 80262bc:	e000      	b.n	80262c0 <sm_event_packet_handler+0x530>
                            break;
 80262be:	bf00      	nop
                    sm_conn->sm_engine_state = SM_GENERAL_IDLE;
 80262c0:	69bb      	ldr	r3, [r7, #24]
 80262c2:	2200      	movs	r2, #0
 80262c4:	731a      	strb	r2, [r3, #12]
                    sm_conn->sm_handle = 0;
 80262c6:	69bb      	ldr	r3, [r7, #24]
 80262c8:	2200      	movs	r2, #0
 80262ca:	801a      	strh	r2, [r3, #0]
                    break;
 80262cc:	e024      	b.n	8026318 <sm_event_packet_handler+0x588>
                    if (HCI_EVENT_IS_COMMAND_COMPLETE(packet, hci_read_bd_addr)){
 80262ce:	68bb      	ldr	r3, [r7, #8]
 80262d0:	781b      	ldrb	r3, [r3, #0]
 80262d2:	2b0e      	cmp	r3, #14
 80262d4:	d11f      	bne.n	8026316 <sm_event_packet_handler+0x586>
 80262d6:	2103      	movs	r1, #3
 80262d8:	68b8      	ldr	r0, [r7, #8]
 80262da:	f7e8 fd84 	bl	800ede6 <little_endian_read_16>
 80262de:	4603      	mov	r3, r0
 80262e0:	461a      	mov	r2, r3
 80262e2:	4b18      	ldr	r3, [pc, #96]	; (8026344 <sm_event_packet_handler+0x5b4>)
 80262e4:	881b      	ldrh	r3, [r3, #0]
 80262e6:	429a      	cmp	r2, r3
 80262e8:	d115      	bne.n	8026316 <sm_event_packet_handler+0x586>
                        reverse_bd_addr(&packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE + 1], addr);
 80262ea:	68bb      	ldr	r3, [r7, #8]
 80262ec:	3306      	adds	r3, #6
 80262ee:	f107 0210 	add.w	r2, r7, #16
 80262f2:	4611      	mov	r1, r2
 80262f4:	4618      	mov	r0, r3
 80262f6:	f7e8 fefc 	bl	800f0f2 <reverse_bd_addr>
                        le_device_db_set_local_bd_addr(addr);
 80262fa:	f107 0310 	add.w	r3, r7, #16
 80262fe:	4618      	mov	r0, r3
 8026300:	f7fa fbac 	bl	8020a5c <le_device_db_set_local_bd_addr>
                    break;
 8026304:	e007      	b.n	8026316 <sm_event_packet_handler+0x586>
					break;
 8026306:	bf00      	nop
 8026308:	e006      	b.n	8026318 <sm_event_packet_handler+0x588>
                    if (!sm_conn) break;
 802630a:	bf00      	nop
 802630c:	e004      	b.n	8026318 <sm_event_packet_handler+0x588>
                    if (!sm_conn) break;
 802630e:	bf00      	nop
 8026310:	e002      	b.n	8026318 <sm_event_packet_handler+0x588>
                    if (!sm_conn) break;
 8026312:	bf00      	nop
 8026314:	e000      	b.n	8026318 <sm_event_packet_handler+0x588>
                    break;
 8026316:	bf00      	nop
            break;
 8026318:	bf00      	nop
	}

    sm_run();
 802631a:	f7fd ff69 	bl	80241f0 <sm_run>
 802631e:	e000      	b.n	8026322 <sm_event_packet_handler+0x592>
                            if (packet[3]) return; // connection failed
 8026320:	bf00      	nop
}
 8026322:	372c      	adds	r7, #44	; 0x2c
 8026324:	46bd      	mov	sp, r7
 8026326:	bd90      	pop	{r4, r7, pc}
 8026328:	200000a0 	.word	0x200000a0
 802632c:	08025b25 	.word	0x08025b25
 8026330:	2000a0b8 	.word	0x2000a0b8
 8026334:	2000a06c 	.word	0x2000a06c
 8026338:	0802d4a8 	.word	0x0802d4a8
 802633c:	0802e234 	.word	0x0802e234
 8026340:	0802e214 	.word	0x0802e214
 8026344:	08030b60 	.word	0x08030b60

08026348 <sm_calc_actual_encryption_key_size>:

static inline int sm_calc_actual_encryption_key_size(int other){
 8026348:	b480      	push	{r7}
 802634a:	b083      	sub	sp, #12
 802634c:	af00      	add	r7, sp, #0
 802634e:	6078      	str	r0, [r7, #4]
    if (other < sm_min_encryption_key_size) return 0;
 8026350:	4b0b      	ldr	r3, [pc, #44]	; (8026380 <sm_calc_actual_encryption_key_size+0x38>)
 8026352:	781b      	ldrb	r3, [r3, #0]
 8026354:	461a      	mov	r2, r3
 8026356:	687b      	ldr	r3, [r7, #4]
 8026358:	4293      	cmp	r3, r2
 802635a:	da01      	bge.n	8026360 <sm_calc_actual_encryption_key_size+0x18>
 802635c:	2300      	movs	r3, #0
 802635e:	e009      	b.n	8026374 <sm_calc_actual_encryption_key_size+0x2c>
    if (other < sm_max_encryption_key_size) return other;
 8026360:	4b08      	ldr	r3, [pc, #32]	; (8026384 <sm_calc_actual_encryption_key_size+0x3c>)
 8026362:	781b      	ldrb	r3, [r3, #0]
 8026364:	461a      	mov	r2, r3
 8026366:	687b      	ldr	r3, [r7, #4]
 8026368:	4293      	cmp	r3, r2
 802636a:	da01      	bge.n	8026370 <sm_calc_actual_encryption_key_size+0x28>
 802636c:	687b      	ldr	r3, [r7, #4]
 802636e:	e001      	b.n	8026374 <sm_calc_actual_encryption_key_size+0x2c>
    return sm_max_encryption_key_size;
 8026370:	4b04      	ldr	r3, [pc, #16]	; (8026384 <sm_calc_actual_encryption_key_size+0x3c>)
 8026372:	781b      	ldrb	r3, [r3, #0]
}
 8026374:	4618      	mov	r0, r3
 8026376:	370c      	adds	r7, #12
 8026378:	46bd      	mov	sp, r7
 802637a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802637e:	4770      	bx	lr
 8026380:	20009f45 	.word	0x20009f45
 8026384:	20009f44 	.word	0x20009f44

08026388 <sm_just_works_or_numeric_comparison>:


#ifdef ENABLE_LE_SECURE_CONNECTIONS
static int sm_just_works_or_numeric_comparison(stk_generation_method_t method){
 8026388:	b480      	push	{r7}
 802638a:	b083      	sub	sp, #12
 802638c:	af00      	add	r7, sp, #0
 802638e:	4603      	mov	r3, r0
 8026390:	71fb      	strb	r3, [r7, #7]
    switch (method){
 8026392:	79fb      	ldrb	r3, [r7, #7]
 8026394:	2b00      	cmp	r3, #0
 8026396:	d001      	beq.n	802639c <sm_just_works_or_numeric_comparison+0x14>
 8026398:	2b04      	cmp	r3, #4
 802639a:	d101      	bne.n	80263a0 <sm_just_works_or_numeric_comparison+0x18>
        case JUST_WORKS:
        case NUMERIC_COMPARISON:
            return 1;
 802639c:	2301      	movs	r3, #1
 802639e:	e000      	b.n	80263a2 <sm_just_works_or_numeric_comparison+0x1a>
        default:
            return 0;
 80263a0:	2300      	movs	r3, #0
    }
}
 80263a2:	4618      	mov	r0, r3
 80263a4:	370c      	adds	r7, #12
 80263a6:	46bd      	mov	sp, r7
 80263a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80263ac:	4770      	bx	lr

080263ae <sm_passkey_used>:
// responder

static int sm_passkey_used(stk_generation_method_t method){
 80263ae:	b480      	push	{r7}
 80263b0:	b083      	sub	sp, #12
 80263b2:	af00      	add	r7, sp, #0
 80263b4:	4603      	mov	r3, r0
 80263b6:	71fb      	strb	r3, [r7, #7]
    switch (method){
 80263b8:	79fb      	ldrb	r3, [r7, #7]
 80263ba:	2b01      	cmp	r3, #1
 80263bc:	d101      	bne.n	80263c2 <sm_passkey_used+0x14>
        case PK_RESP_INPUT:
            return 1;
 80263be:	2301      	movs	r3, #1
 80263c0:	e000      	b.n	80263c4 <sm_passkey_used+0x16>
        default:
            return 0;
 80263c2:	2300      	movs	r3, #0
    }
}
 80263c4:	4618      	mov	r0, r3
 80263c6:	370c      	adds	r7, #12
 80263c8:	46bd      	mov	sp, r7
 80263ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80263ce:	4770      	bx	lr

080263d0 <sm_passkey_entry>:

static int sm_passkey_entry(stk_generation_method_t method){
 80263d0:	b480      	push	{r7}
 80263d2:	b083      	sub	sp, #12
 80263d4:	af00      	add	r7, sp, #0
 80263d6:	4603      	mov	r3, r0
 80263d8:	71fb      	strb	r3, [r7, #7]
    switch (method){
 80263da:	79fb      	ldrb	r3, [r7, #7]
 80263dc:	3b01      	subs	r3, #1
 80263de:	2b02      	cmp	r3, #2
 80263e0:	d801      	bhi.n	80263e6 <sm_passkey_entry+0x16>
        case PK_RESP_INPUT:
        case PK_INIT_INPUT:
        case PK_BOTH_INPUT:
            return 1;
 80263e2:	2301      	movs	r3, #1
 80263e4:	e000      	b.n	80263e8 <sm_passkey_entry+0x18>
        default:
            return 0;
 80263e6:	2300      	movs	r3, #0
    }
}
 80263e8:	4618      	mov	r0, r3
 80263ea:	370c      	adds	r7, #12
 80263ec:	46bd      	mov	sp, r7
 80263ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80263f2:	4770      	bx	lr

080263f4 <sm_validate_stk_generation_method>:
#endif

/**
 * @return ok
 */
static int sm_validate_stk_generation_method(void){
 80263f4:	b480      	push	{r7}
 80263f6:	af00      	add	r7, sp, #0
    // check if STK generation method is acceptable by client
    switch (setup->sm_stk_generation_method){
 80263f8:	4b20      	ldr	r3, [pc, #128]	; (802647c <sm_validate_stk_generation_method+0x88>)
 80263fa:	681b      	ldr	r3, [r3, #0]
 80263fc:	7d9b      	ldrb	r3, [r3, #22]
 80263fe:	2b05      	cmp	r3, #5
 8026400:	d836      	bhi.n	8026470 <sm_validate_stk_generation_method+0x7c>
 8026402:	a201      	add	r2, pc, #4	; (adr r2, 8026408 <sm_validate_stk_generation_method+0x14>)
 8026404:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8026408:	08026421 	.word	0x08026421
 802640c:	08026435 	.word	0x08026435
 8026410:	08026435 	.word	0x08026435
 8026414:	08026435 	.word	0x08026435
 8026418:	0802645d 	.word	0x0802645d
 802641c:	08026449 	.word	0x08026449
        case JUST_WORKS:
            return (sm_accepted_stk_generation_methods & SM_STK_GENERATION_METHOD_JUST_WORKS) != 0u;
 8026420:	4b17      	ldr	r3, [pc, #92]	; (8026480 <sm_validate_stk_generation_method+0x8c>)
 8026422:	781b      	ldrb	r3, [r3, #0]
 8026424:	f003 0301 	and.w	r3, r3, #1
 8026428:	2b00      	cmp	r3, #0
 802642a:	bf14      	ite	ne
 802642c:	2301      	movne	r3, #1
 802642e:	2300      	moveq	r3, #0
 8026430:	b2db      	uxtb	r3, r3
 8026432:	e01e      	b.n	8026472 <sm_validate_stk_generation_method+0x7e>
        case PK_RESP_INPUT:
        case PK_INIT_INPUT:
        case PK_BOTH_INPUT:
            return (sm_accepted_stk_generation_methods & SM_STK_GENERATION_METHOD_PASSKEY) != 0u;
 8026434:	4b12      	ldr	r3, [pc, #72]	; (8026480 <sm_validate_stk_generation_method+0x8c>)
 8026436:	781b      	ldrb	r3, [r3, #0]
 8026438:	f003 0304 	and.w	r3, r3, #4
 802643c:	2b00      	cmp	r3, #0
 802643e:	bf14      	ite	ne
 8026440:	2301      	movne	r3, #1
 8026442:	2300      	moveq	r3, #0
 8026444:	b2db      	uxtb	r3, r3
 8026446:	e014      	b.n	8026472 <sm_validate_stk_generation_method+0x7e>
        case OOB:
            return (sm_accepted_stk_generation_methods & SM_STK_GENERATION_METHOD_OOB) != 0u;
 8026448:	4b0d      	ldr	r3, [pc, #52]	; (8026480 <sm_validate_stk_generation_method+0x8c>)
 802644a:	781b      	ldrb	r3, [r3, #0]
 802644c:	f003 0302 	and.w	r3, r3, #2
 8026450:	2b00      	cmp	r3, #0
 8026452:	bf14      	ite	ne
 8026454:	2301      	movne	r3, #1
 8026456:	2300      	moveq	r3, #0
 8026458:	b2db      	uxtb	r3, r3
 802645a:	e00a      	b.n	8026472 <sm_validate_stk_generation_method+0x7e>
        case NUMERIC_COMPARISON:
            return (sm_accepted_stk_generation_methods & SM_STK_GENERATION_METHOD_NUMERIC_COMPARISON) != 0u;
 802645c:	4b08      	ldr	r3, [pc, #32]	; (8026480 <sm_validate_stk_generation_method+0x8c>)
 802645e:	781b      	ldrb	r3, [r3, #0]
 8026460:	f003 0308 	and.w	r3, r3, #8
 8026464:	2b00      	cmp	r3, #0
 8026466:	bf14      	ite	ne
 8026468:	2301      	movne	r3, #1
 802646a:	2300      	moveq	r3, #0
 802646c:	b2db      	uxtb	r3, r3
 802646e:	e000      	b.n	8026472 <sm_validate_stk_generation_method+0x7e>
        default:
            return 0;
 8026470:	2300      	movs	r3, #0
    }
}
 8026472:	4618      	mov	r0, r3
 8026474:	46bd      	mov	sp, r7
 8026476:	f85d 7b04 	ldr.w	r7, [sp], #4
 802647a:	4770      	bx	lr
 802647c:	200000a0 	.word	0x200000a0
 8026480:	20009f43 	.word	0x20009f43

08026484 <sm_pdu_handler>:

static void sm_pdu_handler(uint8_t packet_type, hci_con_handle_t con_handle, uint8_t *packet, uint16_t size){
 8026484:	b5f0      	push	{r4, r5, r6, r7, lr}
 8026486:	b095      	sub	sp, #84	; 0x54
 8026488:	af04      	add	r7, sp, #16
 802648a:	60ba      	str	r2, [r7, #8]
 802648c:	461a      	mov	r2, r3
 802648e:	4603      	mov	r3, r0
 8026490:	73fb      	strb	r3, [r7, #15]
 8026492:	460b      	mov	r3, r1
 8026494:	81bb      	strh	r3, [r7, #12]
 8026496:	4613      	mov	r3, r2
 8026498:	80fb      	strh	r3, [r7, #6]
            65, // 0x0c pairing public key
            17, // 0x0d pairing dhk check
            2,  // 0x0e keypress notification
    };

    if ((packet_type == HCI_EVENT_PACKET) && (packet[0] == L2CAP_EVENT_CAN_SEND_NOW)){
 802649a:	7bfb      	ldrb	r3, [r7, #15]
 802649c:	2b04      	cmp	r3, #4
 802649e:	d105      	bne.n	80264ac <sm_pdu_handler+0x28>
 80264a0:	68bb      	ldr	r3, [r7, #8]
 80264a2:	781b      	ldrb	r3, [r3, #0]
 80264a4:	2b78      	cmp	r3, #120	; 0x78
 80264a6:	d101      	bne.n	80264ac <sm_pdu_handler+0x28>
        sm_run();
 80264a8:	f7fd fea2 	bl	80241f0 <sm_run>
    }

    if (packet_type != SM_DATA_PACKET) return;
 80264ac:	7bfb      	ldrb	r3, [r7, #15]
 80264ae:	2b09      	cmp	r3, #9
 80264b0:	f040 857f 	bne.w	8026fb2 <sm_pdu_handler+0xb2e>
    if (size == 0u) return;
 80264b4:	88fb      	ldrh	r3, [r7, #6]
 80264b6:	2b00      	cmp	r3, #0
 80264b8:	f000 857d 	beq.w	8026fb6 <sm_pdu_handler+0xb32>

    uint8_t sm_pdu_code = packet[0];
 80264bc:	68bb      	ldr	r3, [r7, #8]
 80264be:	781b      	ldrb	r3, [r3, #0]
 80264c0:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

    // validate pdu size
    if (sm_pdu_code >= sizeof(sm_pdu_size)) return;
 80264c4:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80264c8:	2b0e      	cmp	r3, #14
 80264ca:	f200 8576 	bhi.w	8026fba <sm_pdu_handler+0xb36>
    if (sm_pdu_size[sm_pdu_code] != size)   return;
 80264ce:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80264d2:	4ac9      	ldr	r2, [pc, #804]	; (80267f8 <sm_pdu_handler+0x374>)
 80264d4:	5cd3      	ldrb	r3, [r2, r3]
 80264d6:	b29b      	uxth	r3, r3
 80264d8:	88fa      	ldrh	r2, [r7, #6]
 80264da:	429a      	cmp	r2, r3
 80264dc:	f040 856f 	bne.w	8026fbe <sm_pdu_handler+0xb3a>

    sm_connection_t * sm_conn = sm_get_connection_for_handle(con_handle);
 80264e0:	89bb      	ldrh	r3, [r7, #12]
 80264e2:	4618      	mov	r0, r3
 80264e4:	f000 fe44 	bl	8027170 <sm_get_connection_for_handle>
 80264e8:	63b8      	str	r0, [r7, #56]	; 0x38
    if (!sm_conn) return;
 80264ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80264ec:	2b00      	cmp	r3, #0
 80264ee:	f000 8568 	beq.w	8026fc2 <sm_pdu_handler+0xb3e>

    if (sm_pdu_code == SM_CODE_PAIRING_FAILED){
 80264f2:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80264f6:	2b05      	cmp	r3, #5
 80264f8:	d11a      	bne.n	8026530 <sm_pdu_handler+0xac>
        sm_reencryption_complete(sm_conn, ERROR_CODE_AUTHENTICATION_FAILURE);
 80264fa:	2105      	movs	r1, #5
 80264fc:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80264fe:	f7fb f84c 	bl	802159a <sm_reencryption_complete>
        sm_pairing_complete(sm_conn, ERROR_CODE_AUTHENTICATION_FAILURE, packet[1]);
 8026502:	68bb      	ldr	r3, [r7, #8]
 8026504:	3301      	adds	r3, #1
 8026506:	781b      	ldrb	r3, [r3, #0]
 8026508:	461a      	mov	r2, r3
 802650a:	2105      	movs	r1, #5
 802650c:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 802650e:	f7fb f8af 	bl	8021670 <sm_pairing_complete>
        sm_done_for_handle(con_handle);
 8026512:	89bb      	ldrh	r3, [r7, #12]
 8026514:	4618      	mov	r0, r3
 8026516:	f7fb fd6d 	bl	8021ff4 <sm_done_for_handle>
        sm_conn->sm_engine_state = sm_conn->sm_role ? SM_RESPONDER_IDLE : SM_INITIATOR_CONNECTED;
 802651a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802651c:	789b      	ldrb	r3, [r3, #2]
 802651e:	2b00      	cmp	r3, #0
 8026520:	d001      	beq.n	8026526 <sm_pdu_handler+0xa2>
 8026522:	221a      	movs	r2, #26
 8026524:	e000      	b.n	8026528 <sm_pdu_handler+0xa4>
 8026526:	2229      	movs	r2, #41	; 0x29
 8026528:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802652a:	731a      	strb	r2, [r3, #12]
        return;
 802652c:	f000 bd4c 	b.w	8026fc8 <sm_pdu_handler+0xb44>
    log_debug("sm_pdu_handler: state %u, pdu 0x%02x", sm_conn->sm_engine_state, sm_pdu_code);

    int err;
    UNUSED(err);

    if (sm_pdu_code == SM_CODE_KEYPRESS_NOTIFICATION){
 8026530:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8026534:	2b0e      	cmp	r3, #14
 8026536:	d117      	bne.n	8026568 <sm_pdu_handler+0xe4>
        uint8_t buffer[5];
        buffer[0] = SM_EVENT_KEYPRESS_NOTIFICATION;
 8026538:	23da      	movs	r3, #218	; 0xda
 802653a:	753b      	strb	r3, [r7, #20]
        buffer[1] = 3;
 802653c:	2303      	movs	r3, #3
 802653e:	757b      	strb	r3, [r7, #21]
        little_endian_store_16(buffer, 2, con_handle);
 8026540:	89ba      	ldrh	r2, [r7, #12]
 8026542:	f107 0314 	add.w	r3, r7, #20
 8026546:	2102      	movs	r1, #2
 8026548:	4618      	mov	r0, r3
 802654a:	f7e8 fc8c 	bl	800ee66 <little_endian_store_16>
        buffer[4] = packet[1];
 802654e:	68bb      	ldr	r3, [r7, #8]
 8026550:	785b      	ldrb	r3, [r3, #1]
 8026552:	763b      	strb	r3, [r7, #24]
        sm_dispatch_event(HCI_EVENT_PACKET, 0, buffer, sizeof(buffer));
 8026554:	f107 0214 	add.w	r2, r7, #20
 8026558:	2305      	movs	r3, #5
 802655a:	2100      	movs	r1, #0
 802655c:	2004      	movs	r0, #4
 802655e:	f7fa fee1 	bl	8021324 <sm_dispatch_event>
        return;
 8026562:	bf00      	nop
 8026564:	f000 bd30 	b.w	8026fc8 <sm_pdu_handler+0xb44>
    }

    int have_ltk;
    uint8_t ltk[16];

    switch (sm_conn->sm_engine_state){
 8026568:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802656a:	7b1b      	ldrb	r3, [r3, #12]
 802656c:	3b02      	subs	r3, #2
 802656e:	2b49      	cmp	r3, #73	; 0x49
 8026570:	f200 8506 	bhi.w	8026f80 <sm_pdu_handler+0xafc>
 8026574:	a201      	add	r2, pc, #4	; (adr r2, 802657c <sm_pdu_handler+0xf8>)
 8026576:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802657a:	bf00      	nop
 802657c:	08026fc7 	.word	0x08026fc7
 8026580:	08026f81 	.word	0x08026f81
 8026584:	08026f81 	.word	0x08026f81
 8026588:	08026f81 	.word	0x08026f81
 802658c:	08026f81 	.word	0x08026f81
 8026590:	08026f81 	.word	0x08026f81
 8026594:	08026f81 	.word	0x08026f81
 8026598:	08026f81 	.word	0x08026f81
 802659c:	08026f81 	.word	0x08026f81
 80265a0:	08026f81 	.word	0x08026f81
 80265a4:	08026f81 	.word	0x08026f81
 80265a8:	08026f81 	.word	0x08026f81
 80265ac:	08026f81 	.word	0x08026f81
 80265b0:	08026f81 	.word	0x08026f81
 80265b4:	08026f81 	.word	0x08026f81
 80265b8:	08026f81 	.word	0x08026f81
 80265bc:	08026f81 	.word	0x08026f81
 80265c0:	08026f81 	.word	0x08026f81
 80265c4:	08026f81 	.word	0x08026f81
 80265c8:	08026f81 	.word	0x08026f81
 80265cc:	08026f81 	.word	0x08026f81
 80265d0:	08026f81 	.word	0x08026f81
 80265d4:	08026d81 	.word	0x08026d81
 80265d8:	08026f81 	.word	0x08026f81
 80265dc:	080268c3 	.word	0x080268c3
 80265e0:	080268c3 	.word	0x080268c3
 80265e4:	08026f81 	.word	0x08026f81
 80265e8:	08026f81 	.word	0x08026f81
 80265ec:	08026f81 	.word	0x08026f81
 80265f0:	080268c3 	.word	0x080268c3
 80265f4:	08026f81 	.word	0x08026f81
 80265f8:	08026f81 	.word	0x08026f81
 80265fc:	08026f81 	.word	0x08026f81
 8026600:	08026cd3 	.word	0x08026cd3
 8026604:	08026d57 	.word	0x08026d57
 8026608:	08026f81 	.word	0x08026f81
 802660c:	08026f81 	.word	0x08026f81
 8026610:	08026f81 	.word	0x08026f81
 8026614:	08026f81 	.word	0x08026f81
 8026618:	080266a5 	.word	0x080266a5
 802661c:	08026f81 	.word	0x08026f81
 8026620:	0802673d 	.word	0x0802673d
 8026624:	0802684b 	.word	0x0802684b
 8026628:	08026899 	.word	0x08026899
 802662c:	08026f81 	.word	0x08026f81
 8026630:	08026f81 	.word	0x08026f81
 8026634:	08026f81 	.word	0x08026f81
 8026638:	08026f81 	.word	0x08026f81
 802663c:	080268fd 	.word	0x080268fd
 8026640:	08026f81 	.word	0x08026f81
 8026644:	08026f81 	.word	0x08026f81
 8026648:	08026f81 	.word	0x08026f81
 802664c:	08026f81 	.word	0x08026f81
 8026650:	08026f81 	.word	0x08026f81
 8026654:	08026f81 	.word	0x08026f81
 8026658:	08026a27 	.word	0x08026a27
 802665c:	08026f81 	.word	0x08026f81
 8026660:	08026ab1 	.word	0x08026ab1
 8026664:	08026c87 	.word	0x08026c87
 8026668:	08026c87 	.word	0x08026c87
 802666c:	08026c87 	.word	0x08026c87
 8026670:	08026c87 	.word	0x08026c87
 8026674:	08026c87 	.word	0x08026c87
 8026678:	08026c87 	.word	0x08026c87
 802667c:	08026c87 	.word	0x08026c87
 8026680:	08026c87 	.word	0x08026c87
 8026684:	08026c87 	.word	0x08026c87
 8026688:	08026c87 	.word	0x08026c87
 802668c:	08026c87 	.word	0x08026c87
 8026690:	08026f81 	.word	0x08026f81
 8026694:	08026f81 	.word	0x08026f81
 8026698:	08026c87 	.word	0x08026c87
 802669c:	08026f81 	.word	0x08026f81
 80266a0:	08026c87 	.word	0x08026c87

#ifdef ENABLE_LE_CENTRAL

        // Initiator
        case SM_INITIATOR_CONNECTED:
            if ((sm_pdu_code != SM_CODE_SECURITY_REQUEST) || (sm_conn->sm_role)){
 80266a4:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80266a8:	2b0b      	cmp	r3, #11
 80266aa:	d103      	bne.n	80266b4 <sm_pdu_handler+0x230>
 80266ac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80266ae:	789b      	ldrb	r3, [r3, #2]
 80266b0:	2b00      	cmp	r3, #0
 80266b2:	d004      	beq.n	80266be <sm_pdu_handler+0x23a>
                sm_pdu_received_in_wrong_state(sm_conn);
 80266b4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80266b6:	f7fc f9cb 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;
 80266ba:	f000 bc77 	b.w	8026fac <sm_pdu_handler+0xb28>
            }

            // IRK complete?
            switch (sm_conn->sm_irk_lookup_state){
 80266be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80266c0:	7b5b      	ldrb	r3, [r3, #13]
 80266c2:	2b03      	cmp	r3, #3
 80266c4:	d005      	beq.n	80266d2 <sm_pdu_handler+0x24e>
 80266c6:	2b04      	cmp	r3, #4
 80266c8:	d132      	bne.n	8026730 <sm_pdu_handler+0x2ac>
                case IRK_LOOKUP_FAILED:
                    // start pairing
                    sm_conn->sm_engine_state = SM_INITIATOR_PH1_W2_SEND_PAIRING_REQUEST;
 80266ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80266cc:	222a      	movs	r2, #42	; 0x2a
 80266ce:	731a      	strb	r2, [r3, #12]
                    break;
 80266d0:	e032      	b.n	8026738 <sm_pdu_handler+0x2b4>
                case IRK_LOOKUP_SUCCEEDED:
                    le_device_db_encryption_get(sm_conn->sm_le_db_index, NULL, NULL, ltk, NULL, NULL, NULL, NULL);
 80266d2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80266d4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80266d6:	f107 021c 	add.w	r2, r7, #28
 80266da:	2300      	movs	r3, #0
 80266dc:	9303      	str	r3, [sp, #12]
 80266de:	2300      	movs	r3, #0
 80266e0:	9302      	str	r3, [sp, #8]
 80266e2:	2300      	movs	r3, #0
 80266e4:	9301      	str	r3, [sp, #4]
 80266e6:	2300      	movs	r3, #0
 80266e8:	9300      	str	r3, [sp, #0]
 80266ea:	4613      	mov	r3, r2
 80266ec:	2200      	movs	r2, #0
 80266ee:	2100      	movs	r1, #0
 80266f0:	f7fa fb82 	bl	8020df8 <le_device_db_encryption_get>
                    have_ltk = !sm_is_null_key(ltk);
 80266f4:	f107 031c 	add.w	r3, r7, #28
 80266f8:	4618      	mov	r0, r3
 80266fa:	f7fa fd41 	bl	8021180 <sm_is_null_key>
 80266fe:	4603      	mov	r3, r0
 8026700:	f083 0301 	eor.w	r3, r3, #1
 8026704:	b2db      	uxtb	r3, r3
 8026706:	633b      	str	r3, [r7, #48]	; 0x30
                    log_info("central: security request - have_ltk %u", have_ltk);
 8026708:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802670a:	9300      	str	r3, [sp, #0]
 802670c:	f640 7309 	movw	r3, #3849	; 0xf09
 8026710:	4a3a      	ldr	r2, [pc, #232]	; (80267fc <sm_pdu_handler+0x378>)
 8026712:	493b      	ldr	r1, [pc, #236]	; (8026800 <sm_pdu_handler+0x37c>)
 8026714:	2001      	movs	r0, #1
 8026716:	f7f0 fe93 	bl	8017440 <hci_dump_log>
                    if (have_ltk){
 802671a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802671c:	2b00      	cmp	r3, #0
 802671e:	d003      	beq.n	8026728 <sm_pdu_handler+0x2a4>
                        // start re-encrypt
                        sm_conn->sm_engine_state = SM_INITIATOR_PH4_HAS_LTK;
 8026720:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026722:	222f      	movs	r2, #47	; 0x2f
 8026724:	731a      	strb	r2, [r3, #12]
                    } else {
                        // start pairing
                        sm_conn->sm_engine_state = SM_INITIATOR_PH1_W2_SEND_PAIRING_REQUEST;
                    }
                    break;
 8026726:	e007      	b.n	8026738 <sm_pdu_handler+0x2b4>
                        sm_conn->sm_engine_state = SM_INITIATOR_PH1_W2_SEND_PAIRING_REQUEST;
 8026728:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802672a:	222a      	movs	r2, #42	; 0x2a
 802672c:	731a      	strb	r2, [r3, #12]
                    break;
 802672e:	e003      	b.n	8026738 <sm_pdu_handler+0x2b4>
                default:
                    // otherwise, store security request
                    sm_conn->sm_security_request_received = 1;
 8026730:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026732:	2201      	movs	r2, #1
 8026734:	70da      	strb	r2, [r3, #3]
                    break;
 8026736:	bf00      	nop
            }
            break;
 8026738:	f000 bc38 	b.w	8026fac <sm_pdu_handler+0xb28>

        case SM_INITIATOR_PH1_W4_PAIRING_RESPONSE:
            // Core 5, Vol 3, Part H, 2.4.6:
            // "The master shall ignore the slave’s Security Request if the master has sent a Pairing Request
            //  without receiving a Pairing Response from the slave or if the master has initiated encryption mode setup."
            if (sm_pdu_code == SM_CODE_SECURITY_REQUEST){
 802673c:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8026740:	2b0b      	cmp	r3, #11
 8026742:	d108      	bne.n	8026756 <sm_pdu_handler+0x2d2>
                log_info("Ignoring Security Request");
 8026744:	f640 731e 	movw	r3, #3870	; 0xf1e
 8026748:	4a2c      	ldr	r2, [pc, #176]	; (80267fc <sm_pdu_handler+0x378>)
 802674a:	492e      	ldr	r1, [pc, #184]	; (8026804 <sm_pdu_handler+0x380>)
 802674c:	2001      	movs	r0, #1
 802674e:	f7f0 fe77 	bl	8017440 <hci_dump_log>
                break;
 8026752:	f000 bc2b 	b.w	8026fac <sm_pdu_handler+0xb28>
            }

            // all other pdus are incorrect
            if (sm_pdu_code != SM_CODE_PAIRING_RESPONSE){
 8026756:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 802675a:	2b02      	cmp	r3, #2
 802675c:	d004      	beq.n	8026768 <sm_pdu_handler+0x2e4>
                sm_pdu_received_in_wrong_state(sm_conn);
 802675e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026760:	f7fc f976 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;
 8026764:	f000 bc22 	b.w	8026fac <sm_pdu_handler+0xb28>
            }

            // store pairing request
            (void)memcpy(&setup->sm_s_pres, packet,
 8026768:	4b27      	ldr	r3, [pc, #156]	; (8026808 <sm_pdu_handler+0x384>)
 802676a:	681b      	ldr	r3, [r3, #0]
 802676c:	3340      	adds	r3, #64	; 0x40
 802676e:	2207      	movs	r2, #7
 8026770:	68b9      	ldr	r1, [r7, #8]
 8026772:	4618      	mov	r0, r3
 8026774:	f001 f981 	bl	8027a7a <memcpy>
                         sizeof(sm_pairing_packet_t));
            err = sm_stk_generation_init(sm_conn);
 8026778:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 802677a:	f7fb fdb3 	bl	80222e4 <sm_stk_generation_init>
 802677e:	6378      	str	r0, [r7, #52]	; 0x34
                log_info("testing_support: abort with pairing failure %u", test_pairing_failure);
                err = test_pairing_failure;
            }
#endif

            if (err != 0){
 8026780:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8026782:	2b00      	cmp	r3, #0
 8026784:	d009      	beq.n	802679a <sm_pdu_handler+0x316>
                setup->sm_pairing_failed_reason = err;
 8026786:	4b20      	ldr	r3, [pc, #128]	; (8026808 <sm_pdu_handler+0x384>)
 8026788:	681b      	ldr	r3, [r3, #0]
 802678a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 802678c:	b2d2      	uxtb	r2, r2
 802678e:	741a      	strb	r2, [r3, #16]
                sm_conn->sm_engine_state = SM_GENERAL_SEND_PAIRING_FAILED;
 8026790:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026792:	2201      	movs	r2, #1
 8026794:	731a      	strb	r2, [r3, #12]
                break;
 8026796:	f000 bc09 	b.w	8026fac <sm_pdu_handler+0xb28>
            }

            // generate random number first, if we need to show passkey
            if (setup->sm_stk_generation_method == PK_RESP_INPUT){
 802679a:	4b1b      	ldr	r3, [pc, #108]	; (8026808 <sm_pdu_handler+0x384>)
 802679c:	681b      	ldr	r3, [r3, #0]
 802679e:	7d9b      	ldrb	r3, [r3, #22]
 80267a0:	2b01      	cmp	r3, #1
 80267a2:	d109      	bne.n	80267b8 <sm_pdu_handler+0x334>
                btstack_crypto_random_generate(&sm_crypto_random_request, sm_random_data, 8, &sm_handle_random_result_ph2_tk,  (void *)(uintptr_t) sm_conn->sm_handle);
 80267a4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80267a6:	881b      	ldrh	r3, [r3, #0]
 80267a8:	9300      	str	r3, [sp, #0]
 80267aa:	4b18      	ldr	r3, [pc, #96]	; (802680c <sm_pdu_handler+0x388>)
 80267ac:	2208      	movs	r2, #8
 80267ae:	4918      	ldr	r1, [pc, #96]	; (8026810 <sm_pdu_handler+0x38c>)
 80267b0:	4818      	ldr	r0, [pc, #96]	; (8026814 <sm_pdu_handler+0x390>)
 80267b2:	f7e7 fe43 	bl	800e43c <btstack_crypto_random_generate>
                break;
 80267b6:	e3f9      	b.n	8026fac <sm_pdu_handler+0xb28>
            }

#ifdef ENABLE_LE_SECURE_CONNECTIONS
            if (setup->sm_use_secure_connections){
 80267b8:	4b13      	ldr	r3, [pc, #76]	; (8026808 <sm_pdu_handler+0x384>)
 80267ba:	681b      	ldr	r3, [r3, #0]
 80267bc:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80267c0:	2b00      	cmp	r3, #0
 80267c2:	d029      	beq.n	8026818 <sm_pdu_handler+0x394>
                // SC Numeric Comparison will trigger user response after public keys & nonces have been exchanged
                if (setup->sm_stk_generation_method == JUST_WORKS){
 80267c4:	4b10      	ldr	r3, [pc, #64]	; (8026808 <sm_pdu_handler+0x384>)
 80267c6:	681b      	ldr	r3, [r3, #0]
 80267c8:	7d9b      	ldrb	r3, [r3, #22]
 80267ca:	2b00      	cmp	r3, #0
 80267cc:	d10f      	bne.n	80267ee <sm_pdu_handler+0x36a>
                    sm_conn->sm_engine_state = SM_PH1_W4_USER_RESPONSE;
 80267ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80267d0:	2204      	movs	r2, #4
 80267d2:	731a      	strb	r2, [r3, #12]
                    sm_trigger_user_response(sm_conn);
 80267d4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80267d6:	f7fb fb21 	bl	8021e1c <sm_trigger_user_response>
                    if (setup->sm_user_response == SM_USER_RESPONSE_IDLE){
 80267da:	4b0b      	ldr	r3, [pc, #44]	; (8026808 <sm_pdu_handler+0x384>)
 80267dc:	681b      	ldr	r3, [r3, #0]
 80267de:	7c5b      	ldrb	r3, [r3, #17]
 80267e0:	2b00      	cmp	r3, #0
 80267e2:	f040 83dc 	bne.w	8026f9e <sm_pdu_handler+0xb1a>
                        sm_conn->sm_engine_state = SM_SC_SEND_PUBLIC_KEY_COMMAND;
 80267e6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80267e8:	2231      	movs	r2, #49	; 0x31
 80267ea:	731a      	strb	r2, [r3, #12]
                    }
                } else {
                    sm_conn->sm_engine_state = SM_SC_SEND_PUBLIC_KEY_COMMAND;
                }
                break;
 80267ec:	e3d7      	b.n	8026f9e <sm_pdu_handler+0xb1a>
                    sm_conn->sm_engine_state = SM_SC_SEND_PUBLIC_KEY_COMMAND;
 80267ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80267f0:	2231      	movs	r2, #49	; 0x31
 80267f2:	731a      	strb	r2, [r3, #12]
                break;
 80267f4:	e3d3      	b.n	8026f9e <sm_pdu_handler+0xb1a>
 80267f6:	bf00      	nop
 80267f8:	08030ee8 	.word	0x08030ee8
 80267fc:	0802d4a8 	.word	0x0802d4a8
 8026800:	0802e268 	.word	0x0802e268
 8026804:	0802e298 	.word	0x0802e298
 8026808:	200000a0 	.word	0x200000a0
 802680c:	080259e5 	.word	0x080259e5
 8026810:	2000a0b8 	.word	0x2000a0b8
 8026814:	2000a06c 	.word	0x2000a06c
            }
#endif
            sm_conn->sm_engine_state = SM_PH1_W4_USER_RESPONSE;
 8026818:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802681a:	2204      	movs	r2, #4
 802681c:	731a      	strb	r2, [r3, #12]
            sm_trigger_user_response(sm_conn);
 802681e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026820:	f7fb fafc 	bl	8021e1c <sm_trigger_user_response>
            // response_idle == nothing <--> sm_trigger_user_response() did not require response
            if (setup->sm_user_response == SM_USER_RESPONSE_IDLE){
 8026824:	4ba6      	ldr	r3, [pc, #664]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026826:	681b      	ldr	r3, [r3, #0]
 8026828:	7c5b      	ldrb	r3, [r3, #17]
 802682a:	2b00      	cmp	r3, #0
 802682c:	f040 83b9 	bne.w	8026fa2 <sm_pdu_handler+0xb1e>
                btstack_crypto_random_generate(&sm_crypto_random_request, setup->sm_local_random, 16, &sm_handle_random_result_ph2_random, (void *)(uintptr_t) sm_conn->sm_handle);
 8026830:	4ba3      	ldr	r3, [pc, #652]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026832:	681b      	ldr	r3, [r3, #0]
 8026834:	f103 0147 	add.w	r1, r3, #71	; 0x47
 8026838:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802683a:	881b      	ldrh	r3, [r3, #0]
 802683c:	9300      	str	r3, [sp, #0]
 802683e:	4ba1      	ldr	r3, [pc, #644]	; (8026ac4 <sm_pdu_handler+0x640>)
 8026840:	2210      	movs	r2, #16
 8026842:	48a1      	ldr	r0, [pc, #644]	; (8026ac8 <sm_pdu_handler+0x644>)
 8026844:	f7e7 fdfa 	bl	800e43c <btstack_crypto_random_generate>
            }
            break;
 8026848:	e3ab      	b.n	8026fa2 <sm_pdu_handler+0xb1e>

        case SM_INITIATOR_PH2_W4_PAIRING_CONFIRM:
            if (sm_pdu_code != SM_CODE_PAIRING_CONFIRM){
 802684a:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 802684e:	2b03      	cmp	r3, #3
 8026850:	d003      	beq.n	802685a <sm_pdu_handler+0x3d6>
                sm_pdu_received_in_wrong_state(sm_conn);
 8026852:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026854:	f7fc f8fc 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;
 8026858:	e3a8      	b.n	8026fac <sm_pdu_handler+0xb28>
            }

            // store s_confirm
            reverse_128(&packet[1], setup->sm_peer_confirm);
 802685a:	68bb      	ldr	r3, [r7, #8]
 802685c:	1c5a      	adds	r2, r3, #1
 802685e:	4b98      	ldr	r3, [pc, #608]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026860:	681b      	ldr	r3, [r3, #0]
 8026862:	3377      	adds	r3, #119	; 0x77
 8026864:	4619      	mov	r1, r3
 8026866:	4610      	mov	r0, r2
 8026868:	f7e8 fc27 	bl	800f0ba <reverse_128>

            // abort if s_confirm matches m_confirm
            if (memcmp(setup->sm_local_confirm, setup->sm_peer_confirm, 16) == 0){
 802686c:	4b94      	ldr	r3, [pc, #592]	; (8026ac0 <sm_pdu_handler+0x63c>)
 802686e:	681b      	ldr	r3, [r3, #0]
 8026870:	f103 0057 	add.w	r0, r3, #87	; 0x57
 8026874:	4b92      	ldr	r3, [pc, #584]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026876:	681b      	ldr	r3, [r3, #0]
 8026878:	3377      	adds	r3, #119	; 0x77
 802687a:	2210      	movs	r2, #16
 802687c:	4619      	mov	r1, r3
 802687e:	f001 f8ed 	bl	8027a5c <memcmp>
 8026882:	4603      	mov	r3, r0
 8026884:	2b00      	cmp	r3, #0
 8026886:	d103      	bne.n	8026890 <sm_pdu_handler+0x40c>
                sm_pdu_received_in_wrong_state(sm_conn);
 8026888:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 802688a:	f7fc f8e1 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;
 802688e:	e38d      	b.n	8026fac <sm_pdu_handler+0xb28>
            if (test_pairing_failure == SM_REASON_CONFIRM_VALUE_FAILED){
                log_info("testing_support: reset confirm value");
                memset(setup->sm_peer_confirm, 0, 16);
            }
#endif
            sm_conn->sm_engine_state = SM_PH2_SEND_PAIRING_RANDOM;
 8026890:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026892:	2210      	movs	r2, #16
 8026894:	731a      	strb	r2, [r3, #12]
            break;
 8026896:	e389      	b.n	8026fac <sm_pdu_handler+0xb28>

        case SM_INITIATOR_PH2_W4_PAIRING_RANDOM:
            if (sm_pdu_code != SM_CODE_PAIRING_RANDOM){
 8026898:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 802689c:	2b04      	cmp	r3, #4
 802689e:	d003      	beq.n	80268a8 <sm_pdu_handler+0x424>
                sm_pdu_received_in_wrong_state(sm_conn);
 80268a0:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80268a2:	f7fc f8d5 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;;
 80268a6:	e381      	b.n	8026fac <sm_pdu_handler+0xb28>
            }

            // received random value
            reverse_128(&packet[1], setup->sm_peer_random);
 80268a8:	68bb      	ldr	r3, [r7, #8]
 80268aa:	1c5a      	adds	r2, r3, #1
 80268ac:	4b84      	ldr	r3, [pc, #528]	; (8026ac0 <sm_pdu_handler+0x63c>)
 80268ae:	681b      	ldr	r3, [r3, #0]
 80268b0:	3367      	adds	r3, #103	; 0x67
 80268b2:	4619      	mov	r1, r3
 80268b4:	4610      	mov	r0, r2
 80268b6:	f7e8 fc00 	bl	800f0ba <reverse_128>
            sm_conn->sm_engine_state = SM_PH2_C1_GET_ENC_C;
 80268ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80268bc:	220d      	movs	r2, #13
 80268be:	731a      	strb	r2, [r3, #12]
            break;
 80268c0:	e374      	b.n	8026fac <sm_pdu_handler+0xb28>
#ifdef ENABLE_LE_PERIPHERAL
        // Responder
        case SM_RESPONDER_IDLE:
        case SM_RESPONDER_SEND_SECURITY_REQUEST:
        case SM_RESPONDER_PH1_W4_PAIRING_REQUEST:
            if (sm_pdu_code != SM_CODE_PAIRING_REQUEST){
 80268c2:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80268c6:	2b01      	cmp	r3, #1
 80268c8:	d003      	beq.n	80268d2 <sm_pdu_handler+0x44e>
                sm_pdu_received_in_wrong_state(sm_conn);
 80268ca:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80268cc:	f7fc f8c0 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;;
 80268d0:	e36c      	b.n	8026fac <sm_pdu_handler+0xb28>
            }

            // store pairing request
            (void)memcpy(&sm_conn->sm_m_preq, packet, sizeof(sm_pairing_packet_t));
 80268d2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80268d4:	3312      	adds	r3, #18
 80268d6:	2207      	movs	r2, #7
 80268d8:	68b9      	ldr	r1, [r7, #8]
 80268da:	4618      	mov	r0, r3
 80268dc:	f001 f8cd 	bl	8027a7a <memcpy>

            // check if IRK completed
            switch (sm_conn->sm_irk_lookup_state){
 80268e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80268e2:	7b5b      	ldrb	r3, [r3, #13]
 80268e4:	3b03      	subs	r3, #3
 80268e6:	2b01      	cmp	r3, #1
 80268e8:	d803      	bhi.n	80268f2 <sm_pdu_handler+0x46e>
                case IRK_LOOKUP_SUCCEEDED:
                case IRK_LOOKUP_FAILED:
                    sm_conn->sm_engine_state = SM_RESPONDER_PH1_PAIRING_REQUEST_RECEIVED;
 80268ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80268ec:	2220      	movs	r2, #32
 80268ee:	731a      	strb	r2, [r3, #12]
                    break;
 80268f0:	e003      	b.n	80268fa <sm_pdu_handler+0x476>
                default:
                    sm_conn->sm_engine_state = SM_RESPONDER_PH1_PAIRING_REQUEST_RECEIVED_W4_IRK;
 80268f2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80268f4:	2221      	movs	r2, #33	; 0x21
 80268f6:	731a      	strb	r2, [r3, #12]
                    break;
 80268f8:	bf00      	nop
            }
            break;
 80268fa:	e357      	b.n	8026fac <sm_pdu_handler+0xb28>
#endif

#ifdef ENABLE_LE_SECURE_CONNECTIONS
        case SM_SC_W4_PUBLIC_KEY_COMMAND:
            if (sm_pdu_code != SM_CODE_PAIRING_PUBLIC_KEY){
 80268fc:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8026900:	2b0c      	cmp	r3, #12
 8026902:	d003      	beq.n	802690c <sm_pdu_handler+0x488>
                sm_pdu_received_in_wrong_state(sm_conn);
 8026904:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026906:	f7fc f8a3 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;
 802690a:	e34f      	b.n	8026fac <sm_pdu_handler+0xb28>
            }

            // store public key for DH Key calculation
            reverse_256(&packet[01], &setup->sm_peer_q[0]);
 802690c:	68bb      	ldr	r3, [r7, #8]
 802690e:	1c5a      	adds	r2, r3, #1
 8026910:	4b6b      	ldr	r3, [pc, #428]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026912:	681b      	ldr	r3, [r3, #0]
 8026914:	33a6      	adds	r3, #166	; 0xa6
 8026916:	4619      	mov	r1, r3
 8026918:	4610      	mov	r0, r2
 802691a:	f7e8 fbdc 	bl	800f0d6 <reverse_256>
            reverse_256(&packet[33], &setup->sm_peer_q[32]);
 802691e:	68bb      	ldr	r3, [r7, #8]
 8026920:	f103 0221 	add.w	r2, r3, #33	; 0x21
 8026924:	4b66      	ldr	r3, [pc, #408]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026926:	681b      	ldr	r3, [r3, #0]
 8026928:	33c6      	adds	r3, #198	; 0xc6
 802692a:	4619      	mov	r1, r3
 802692c:	4610      	mov	r0, r2
 802692e:	f7e8 fbd2 	bl	800f0d6 <reverse_256>

            // validate public key
            err = btstack_crypto_ecc_p256_validate_public_key(setup->sm_peer_q);
 8026932:	4b63      	ldr	r3, [pc, #396]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026934:	681b      	ldr	r3, [r3, #0]
 8026936:	33a6      	adds	r3, #166	; 0xa6
 8026938:	4618      	mov	r0, r3
 802693a:	f7e7 fe43 	bl	800e5c4 <btstack_crypto_ecc_p256_validate_public_key>
 802693e:	6378      	str	r0, [r7, #52]	; 0x34
            if (err != 0){
 8026940:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8026942:	2b00      	cmp	r3, #0
 8026944:	d00d      	beq.n	8026962 <sm_pdu_handler+0x4de>
                log_error("sm: peer public key invalid %x", err);
 8026946:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8026948:	9300      	str	r3, [sp, #0]
 802694a:	f640 73a3 	movw	r3, #4003	; 0xfa3
 802694e:	4a5f      	ldr	r2, [pc, #380]	; (8026acc <sm_pdu_handler+0x648>)
 8026950:	495f      	ldr	r1, [pc, #380]	; (8026ad0 <sm_pdu_handler+0x64c>)
 8026952:	2002      	movs	r0, #2
 8026954:	f7f0 fd74 	bl	8017440 <hci_dump_log>
                sm_pairing_error(sm_conn, SM_REASON_DHKEY_CHECK_FAILED);
 8026958:	210b      	movs	r1, #11
 802695a:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 802695c:	f7fc f862 	bl	8022a24 <sm_pairing_error>
                break;
 8026960:	e324      	b.n	8026fac <sm_pdu_handler+0xb28>
            }

            // start calculating dhkey
            btstack_crypto_ecc_p256_calculate_dhkey(&sm_crypto_ecc_p256_request, setup->sm_peer_q, setup->sm_dhkey, sm_sc_dhkey_calculated, (void*)(uintptr_t) sm_conn->sm_handle);
 8026962:	4b57      	ldr	r3, [pc, #348]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026964:	681b      	ldr	r3, [r3, #0]
 8026966:	f103 01a6 	add.w	r1, r3, #166	; 0xa6
 802696a:	4b55      	ldr	r3, [pc, #340]	; (8026ac0 <sm_pdu_handler+0x63c>)
 802696c:	681b      	ldr	r3, [r3, #0]
 802696e:	f503 7283 	add.w	r2, r3, #262	; 0x106
 8026972:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026974:	881b      	ldrh	r3, [r3, #0]
 8026976:	9300      	str	r3, [sp, #0]
 8026978:	4b56      	ldr	r3, [pc, #344]	; (8026ad4 <sm_pdu_handler+0x650>)
 802697a:	4857      	ldr	r0, [pc, #348]	; (8026ad8 <sm_pdu_handler+0x654>)
 802697c:	f7e7 fe00 	bl	800e580 <btstack_crypto_ecc_p256_calculate_dhkey>


            log_info("public key received, generation method %u", setup->sm_stk_generation_method);
 8026980:	4b4f      	ldr	r3, [pc, #316]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026982:	681b      	ldr	r3, [r3, #0]
 8026984:	7d9b      	ldrb	r3, [r3, #22]
 8026986:	9300      	str	r3, [sp, #0]
 8026988:	f640 73ac 	movw	r3, #4012	; 0xfac
 802698c:	4a4f      	ldr	r2, [pc, #316]	; (8026acc <sm_pdu_handler+0x648>)
 802698e:	4953      	ldr	r1, [pc, #332]	; (8026adc <sm_pdu_handler+0x658>)
 8026990:	2001      	movs	r0, #1
 8026992:	f7f0 fd55 	bl	8017440 <hci_dump_log>
            if (IS_RESPONDER(sm_conn->sm_role)){
 8026996:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026998:	789b      	ldrb	r3, [r3, #2]
 802699a:	2b00      	cmp	r3, #0
 802699c:	d003      	beq.n	80269a6 <sm_pdu_handler+0x522>
                // responder
                sm_conn->sm_engine_state = SM_SC_SEND_PUBLIC_KEY_COMMAND;
 802699e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80269a0:	2231      	movs	r2, #49	; 0x31
 80269a2:	731a      	strb	r2, [r3, #12]
                    default:
                        btstack_assert(false);
                        break;
                }
            }
            break;
 80269a4:	e302      	b.n	8026fac <sm_pdu_handler+0xb28>
                switch (setup->sm_stk_generation_method){
 80269a6:	4b46      	ldr	r3, [pc, #280]	; (8026ac0 <sm_pdu_handler+0x63c>)
 80269a8:	681b      	ldr	r3, [r3, #0]
 80269aa:	7d9b      	ldrb	r3, [r3, #22]
 80269ac:	2b05      	cmp	r3, #5
 80269ae:	d838      	bhi.n	8026a22 <sm_pdu_handler+0x59e>
 80269b0:	a201      	add	r2, pc, #4	; (adr r2, 80269b8 <sm_pdu_handler+0x534>)
 80269b2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80269b6:	bf00      	nop
 80269b8:	080269d1 	.word	0x080269d1
 80269bc:	080269d9 	.word	0x080269d9
 80269c0:	080269e1 	.word	0x080269e1
 80269c4:	080269e1 	.word	0x080269e1
 80269c8:	080269d1 	.word	0x080269d1
 80269cc:	080269fb 	.word	0x080269fb
                        sm_conn->sm_engine_state = SM_SC_W4_CONFIRMATION;
 80269d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80269d2:	2239      	movs	r2, #57	; 0x39
 80269d4:	731a      	strb	r2, [r3, #12]
                        break;
 80269d6:	e025      	b.n	8026a24 <sm_pdu_handler+0x5a0>
                        sm_sc_start_calculating_local_confirm(sm_conn);
 80269d8:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80269da:	f7fc f845 	bl	8022a68 <sm_sc_start_calculating_local_confirm>
                        break;
 80269de:	e021      	b.n	8026a24 <sm_pdu_handler+0x5a0>
                        if (setup->sm_user_response != SM_USER_RESPONSE_PASSKEY){
 80269e0:	4b37      	ldr	r3, [pc, #220]	; (8026ac0 <sm_pdu_handler+0x63c>)
 80269e2:	681b      	ldr	r3, [r3, #0]
 80269e4:	7c5b      	ldrb	r3, [r3, #17]
 80269e6:	2b03      	cmp	r3, #3
 80269e8:	d003      	beq.n	80269f2 <sm_pdu_handler+0x56e>
                            sm_conn->sm_engine_state = SM_SC_W4_USER_RESPONSE;
 80269ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80269ec:	2249      	movs	r2, #73	; 0x49
 80269ee:	731a      	strb	r2, [r3, #12]
                            break;
 80269f0:	e018      	b.n	8026a24 <sm_pdu_handler+0x5a0>
                        sm_sc_start_calculating_local_confirm(sm_conn);
 80269f2:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80269f4:	f7fc f838 	bl	8022a68 <sm_sc_start_calculating_local_confirm>
                        break;
 80269f8:	e014      	b.n	8026a24 <sm_pdu_handler+0x5a0>
                        log_info("Generate Na");
 80269fa:	f640 73c6 	movw	r3, #4038	; 0xfc6
 80269fe:	4a33      	ldr	r2, [pc, #204]	; (8026acc <sm_pdu_handler+0x648>)
 8026a00:	4937      	ldr	r1, [pc, #220]	; (8026ae0 <sm_pdu_handler+0x65c>)
 8026a02:	2001      	movs	r0, #1
 8026a04:	f7f0 fd1c 	bl	8017440 <hci_dump_log>
                        btstack_crypto_random_generate(&sm_crypto_random_request, setup->sm_local_nonce, 16, &sm_handle_random_result_sc_next_send_pairing_random, (void*)(uintptr_t) sm_conn->sm_handle);
 8026a08:	4b2d      	ldr	r3, [pc, #180]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026a0a:	681b      	ldr	r3, [r3, #0]
 8026a0c:	f103 01f6 	add.w	r1, r3, #246	; 0xf6
 8026a10:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026a12:	881b      	ldrh	r3, [r3, #0]
 8026a14:	9300      	str	r3, [sp, #0]
 8026a16:	4b33      	ldr	r3, [pc, #204]	; (8026ae4 <sm_pdu_handler+0x660>)
 8026a18:	2210      	movs	r2, #16
 8026a1a:	482b      	ldr	r0, [pc, #172]	; (8026ac8 <sm_pdu_handler+0x644>)
 8026a1c:	f7e7 fd0e 	bl	800e43c <btstack_crypto_random_generate>
                        break;
 8026a20:	e000      	b.n	8026a24 <sm_pdu_handler+0x5a0>
                        break;
 8026a22:	bf00      	nop
            break;
 8026a24:	e2c2      	b.n	8026fac <sm_pdu_handler+0xb28>

        case SM_SC_W4_CONFIRMATION:
            if (sm_pdu_code != SM_CODE_PAIRING_CONFIRM){
 8026a26:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8026a2a:	2b03      	cmp	r3, #3
 8026a2c:	d003      	beq.n	8026a36 <sm_pdu_handler+0x5b2>
                sm_pdu_received_in_wrong_state(sm_conn);
 8026a2e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026a30:	f7fc f80e 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;
 8026a34:	e2ba      	b.n	8026fac <sm_pdu_handler+0xb28>
            }
            // received confirm value
            reverse_128(&packet[1], setup->sm_peer_confirm);
 8026a36:	68bb      	ldr	r3, [r7, #8]
 8026a38:	1c5a      	adds	r2, r3, #1
 8026a3a:	4b21      	ldr	r3, [pc, #132]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026a3c:	681b      	ldr	r3, [r3, #0]
 8026a3e:	3377      	adds	r3, #119	; 0x77
 8026a40:	4619      	mov	r1, r3
 8026a42:	4610      	mov	r0, r2
 8026a44:	f7e8 fb39 	bl	800f0ba <reverse_128>
            if (test_pairing_failure == SM_REASON_CONFIRM_VALUE_FAILED){
                log_info("testing_support: reset confirm value");
                memset(setup->sm_peer_confirm, 0, 16);
            }
#endif
            if (IS_RESPONDER(sm_conn->sm_role)){
 8026a48:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026a4a:	789b      	ldrb	r3, [r3, #2]
 8026a4c:	2b00      	cmp	r3, #0
 8026a4e:	d015      	beq.n	8026a7c <sm_pdu_handler+0x5f8>
                // responder
                if (sm_passkey_used(setup->sm_stk_generation_method)){
 8026a50:	4b1b      	ldr	r3, [pc, #108]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026a52:	681b      	ldr	r3, [r3, #0]
 8026a54:	7d9b      	ldrb	r3, [r3, #22]
 8026a56:	4618      	mov	r0, r3
 8026a58:	f7ff fca9 	bl	80263ae <sm_passkey_used>
 8026a5c:	4603      	mov	r3, r0
 8026a5e:	2b00      	cmp	r3, #0
 8026a60:	d008      	beq.n	8026a74 <sm_pdu_handler+0x5f0>
                    if (setup->sm_user_response != SM_USER_RESPONSE_PASSKEY){
 8026a62:	4b17      	ldr	r3, [pc, #92]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026a64:	681b      	ldr	r3, [r3, #0]
 8026a66:	7c5b      	ldrb	r3, [r3, #17]
 8026a68:	2b03      	cmp	r3, #3
 8026a6a:	d003      	beq.n	8026a74 <sm_pdu_handler+0x5f0>
                        // still waiting for passkey
                        sm_conn->sm_engine_state = SM_SC_W4_USER_RESPONSE;
 8026a6c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026a6e:	2249      	movs	r2, #73	; 0x49
 8026a70:	731a      	strb	r2, [r3, #12]
                        break;
 8026a72:	e29b      	b.n	8026fac <sm_pdu_handler+0xb28>
                    }
                }
                sm_sc_start_calculating_local_confirm(sm_conn);
 8026a74:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026a76:	f7fb fff7 	bl	8022a68 <sm_sc_start_calculating_local_confirm>
                    btstack_crypto_random_generate(&sm_crypto_random_request, setup->sm_local_nonce, 16, &sm_handle_random_result_sc_next_send_pairing_random, (void*)(uintptr_t) sm_conn->sm_handle);
                } else {
                    sm_conn->sm_engine_state = SM_SC_SEND_PAIRING_RANDOM;
                }
            }
            break;
 8026a7a:	e297      	b.n	8026fac <sm_pdu_handler+0xb28>
                if (sm_just_works_or_numeric_comparison(setup->sm_stk_generation_method)){
 8026a7c:	4b10      	ldr	r3, [pc, #64]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026a7e:	681b      	ldr	r3, [r3, #0]
 8026a80:	7d9b      	ldrb	r3, [r3, #22]
 8026a82:	4618      	mov	r0, r3
 8026a84:	f7ff fc80 	bl	8026388 <sm_just_works_or_numeric_comparison>
 8026a88:	4603      	mov	r3, r0
 8026a8a:	2b00      	cmp	r3, #0
 8026a8c:	d00c      	beq.n	8026aa8 <sm_pdu_handler+0x624>
                    btstack_crypto_random_generate(&sm_crypto_random_request, setup->sm_local_nonce, 16, &sm_handle_random_result_sc_next_send_pairing_random, (void*)(uintptr_t) sm_conn->sm_handle);
 8026a8e:	4b0c      	ldr	r3, [pc, #48]	; (8026ac0 <sm_pdu_handler+0x63c>)
 8026a90:	681b      	ldr	r3, [r3, #0]
 8026a92:	f103 01f6 	add.w	r1, r3, #246	; 0xf6
 8026a96:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026a98:	881b      	ldrh	r3, [r3, #0]
 8026a9a:	9300      	str	r3, [sp, #0]
 8026a9c:	4b11      	ldr	r3, [pc, #68]	; (8026ae4 <sm_pdu_handler+0x660>)
 8026a9e:	2210      	movs	r2, #16
 8026aa0:	4809      	ldr	r0, [pc, #36]	; (8026ac8 <sm_pdu_handler+0x644>)
 8026aa2:	f7e7 fccb 	bl	800e43c <btstack_crypto_random_generate>
            break;
 8026aa6:	e281      	b.n	8026fac <sm_pdu_handler+0xb28>
                    sm_conn->sm_engine_state = SM_SC_SEND_PAIRING_RANDOM;
 8026aa8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026aaa:	223a      	movs	r2, #58	; 0x3a
 8026aac:	731a      	strb	r2, [r3, #12]
            break;
 8026aae:	e27d      	b.n	8026fac <sm_pdu_handler+0xb28>

        case SM_SC_W4_PAIRING_RANDOM:
            if (sm_pdu_code != SM_CODE_PAIRING_RANDOM){
 8026ab0:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8026ab4:	2b04      	cmp	r3, #4
 8026ab6:	d017      	beq.n	8026ae8 <sm_pdu_handler+0x664>
                sm_pdu_received_in_wrong_state(sm_conn);
 8026ab8:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026aba:	f7fb ffc9 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;
 8026abe:	e275      	b.n	8026fac <sm_pdu_handler+0xb28>
 8026ac0:	200000a0 	.word	0x200000a0
 8026ac4:	080259b5 	.word	0x080259b5
 8026ac8:	2000a06c 	.word	0x2000a06c
 8026acc:	0802d4a8 	.word	0x0802d4a8
 8026ad0:	0802e2bc 	.word	0x0802e2bc
 8026ad4:	08023495 	.word	0x08023495
 8026ad8:	2000a0a0 	.word	0x2000a0a0
 8026adc:	0802e2e4 	.word	0x0802e2e4
 8026ae0:	0802e318 	.word	0x0802e318
 8026ae4:	08025955 	.word	0x08025955
            }

            // received random value
            reverse_128(&packet[1], setup->sm_peer_nonce);
 8026ae8:	68bb      	ldr	r3, [r7, #8]
 8026aea:	1c5a      	adds	r2, r3, #1
 8026aec:	4bae      	ldr	r3, [pc, #696]	; (8026da8 <sm_pdu_handler+0x924>)
 8026aee:	681b      	ldr	r3, [r3, #0]
 8026af0:	33e6      	adds	r3, #230	; 0xe6
 8026af2:	4619      	mov	r1, r3
 8026af4:	4610      	mov	r0, r2
 8026af6:	f7e8 fae0 	bl	800f0ba <reverse_128>

            // validate confirm value if Cb = f4(Pkb, Pka, Nb, z)
            // only check for JUST WORK/NC in initiator role OR passkey entry
            log_info("SM_SC_W4_PAIRING_RANDOM, responder: %u, just works: %u, passkey used %u, passkey entry %u",
 8026afa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026afc:	789b      	ldrb	r3, [r3, #2]
 8026afe:	461c      	mov	r4, r3
 8026b00:	4ba9      	ldr	r3, [pc, #676]	; (8026da8 <sm_pdu_handler+0x924>)
 8026b02:	681b      	ldr	r3, [r3, #0]
 8026b04:	7d9b      	ldrb	r3, [r3, #22]
 8026b06:	4618      	mov	r0, r3
 8026b08:	f7ff fc3e 	bl	8026388 <sm_just_works_or_numeric_comparison>
 8026b0c:	4605      	mov	r5, r0
 8026b0e:	4ba6      	ldr	r3, [pc, #664]	; (8026da8 <sm_pdu_handler+0x924>)
 8026b10:	681b      	ldr	r3, [r3, #0]
 8026b12:	7d9b      	ldrb	r3, [r3, #22]
 8026b14:	4618      	mov	r0, r3
 8026b16:	f7ff fc4a 	bl	80263ae <sm_passkey_used>
 8026b1a:	4606      	mov	r6, r0
 8026b1c:	4ba2      	ldr	r3, [pc, #648]	; (8026da8 <sm_pdu_handler+0x924>)
 8026b1e:	681b      	ldr	r3, [r3, #0]
 8026b20:	7d9b      	ldrb	r3, [r3, #22]
 8026b22:	4618      	mov	r0, r3
 8026b24:	f7ff fc54 	bl	80263d0 <sm_passkey_entry>
 8026b28:	4603      	mov	r3, r0
 8026b2a:	9303      	str	r3, [sp, #12]
 8026b2c:	9602      	str	r6, [sp, #8]
 8026b2e:	9501      	str	r5, [sp, #4]
 8026b30:	9400      	str	r4, [sp, #0]
 8026b32:	f640 73ff 	movw	r3, #4095	; 0xfff
 8026b36:	4a9d      	ldr	r2, [pc, #628]	; (8026dac <sm_pdu_handler+0x928>)
 8026b38:	499d      	ldr	r1, [pc, #628]	; (8026db0 <sm_pdu_handler+0x92c>)
 8026b3a:	2001      	movs	r0, #1
 8026b3c:	f7f0 fc80 	bl	8017440 <hci_dump_log>
                     IS_RESPONDER(sm_conn->sm_role), sm_just_works_or_numeric_comparison(setup->sm_stk_generation_method),
                     sm_passkey_used(setup->sm_stk_generation_method), sm_passkey_entry(setup->sm_stk_generation_method));
            if ( (!IS_RESPONDER(sm_conn->sm_role) && sm_just_works_or_numeric_comparison(setup->sm_stk_generation_method)) 
 8026b40:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026b42:	789b      	ldrb	r3, [r3, #2]
 8026b44:	2b00      	cmp	r3, #0
 8026b46:	d108      	bne.n	8026b5a <sm_pdu_handler+0x6d6>
 8026b48:	4b97      	ldr	r3, [pc, #604]	; (8026da8 <sm_pdu_handler+0x924>)
 8026b4a:	681b      	ldr	r3, [r3, #0]
 8026b4c:	7d9b      	ldrb	r3, [r3, #22]
 8026b4e:	4618      	mov	r0, r3
 8026b50:	f7ff fc1a 	bl	8026388 <sm_just_works_or_numeric_comparison>
 8026b54:	4603      	mov	r3, r0
 8026b56:	2b00      	cmp	r3, #0
 8026b58:	d108      	bne.n	8026b6c <sm_pdu_handler+0x6e8>
            ||   (sm_passkey_entry(setup->sm_stk_generation_method)) ) {
 8026b5a:	4b93      	ldr	r3, [pc, #588]	; (8026da8 <sm_pdu_handler+0x924>)
 8026b5c:	681b      	ldr	r3, [r3, #0]
 8026b5e:	7d9b      	ldrb	r3, [r3, #22]
 8026b60:	4618      	mov	r0, r3
 8026b62:	f7ff fc35 	bl	80263d0 <sm_passkey_entry>
 8026b66:	4603      	mov	r3, r0
 8026b68:	2b00      	cmp	r3, #0
 8026b6a:	d003      	beq.n	8026b74 <sm_pdu_handler+0x6f0>
                 sm_conn->sm_engine_state = SM_SC_W2_CMAC_FOR_CHECK_CONFIRMATION;
 8026b6c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026b6e:	2237      	movs	r2, #55	; 0x37
 8026b70:	731a      	strb	r2, [r3, #12]
                 break;
 8026b72:	e21b      	b.n	8026fac <sm_pdu_handler+0xb28>
            }

            // OOB
            if (setup->sm_stk_generation_method == OOB){
 8026b74:	4b8c      	ldr	r3, [pc, #560]	; (8026da8 <sm_pdu_handler+0x924>)
 8026b76:	681b      	ldr	r3, [r3, #0]
 8026b78:	7d9b      	ldrb	r3, [r3, #22]
 8026b7a:	2b05      	cmp	r3, #5
 8026b7c:	d17f      	bne.n	8026c7e <sm_pdu_handler+0x7fa>

                // setup local random, set to zero if remote did not receive our data
                log_info("Received nonce, setup local random ra/rb for dhkey check");
 8026b7e:	f241 030a 	movw	r3, #4106	; 0x100a
 8026b82:	4a8a      	ldr	r2, [pc, #552]	; (8026dac <sm_pdu_handler+0x928>)
 8026b84:	498b      	ldr	r1, [pc, #556]	; (8026db4 <sm_pdu_handler+0x930>)
 8026b86:	2001      	movs	r0, #1
 8026b88:	f7f0 fc5a 	bl	8017440 <hci_dump_log>
                if (IS_RESPONDER(sm_conn->sm_role)){
 8026b8c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026b8e:	789b      	ldrb	r3, [r3, #2]
 8026b90:	2b00      	cmp	r3, #0
 8026b92:	d035      	beq.n	8026c00 <sm_pdu_handler+0x77c>
                    if (sm_pairing_packet_get_oob_data_flag(setup->sm_m_preq) == 0u){
 8026b94:	4b84      	ldr	r3, [pc, #528]	; (8026da8 <sm_pdu_handler+0x924>)
 8026b96:	681b      	ldr	r3, [r3, #0]
 8026b98:	3339      	adds	r3, #57	; 0x39
 8026b9a:	4618      	mov	r0, r3
 8026b9c:	f7fa fa1a 	bl	8020fd4 <sm_pairing_packet_get_oob_data_flag>
 8026ba0:	4603      	mov	r3, r0
 8026ba2:	2b00      	cmp	r3, #0
 8026ba4:	d110      	bne.n	8026bc8 <sm_pdu_handler+0x744>
                        log_info("Reset rb as A does not have OOB data");
 8026ba6:	f241 030d 	movw	r3, #4109	; 0x100d
 8026baa:	4a80      	ldr	r2, [pc, #512]	; (8026dac <sm_pdu_handler+0x928>)
 8026bac:	4982      	ldr	r1, [pc, #520]	; (8026db8 <sm_pdu_handler+0x934>)
 8026bae:	2001      	movs	r0, #1
 8026bb0:	f7f0 fc46 	bl	8017440 <hci_dump_log>
                        memset(setup->sm_rb, 0, 16);
 8026bb4:	4b7c      	ldr	r3, [pc, #496]	; (8026da8 <sm_pdu_handler+0x924>)
 8026bb6:	681b      	ldr	r3, [r3, #0]
 8026bb8:	f503 73ab 	add.w	r3, r3, #342	; 0x156
 8026bbc:	2210      	movs	r2, #16
 8026bbe:	2100      	movs	r1, #0
 8026bc0:	4618      	mov	r0, r3
 8026bc2:	f000 ff7e 	bl	8027ac2 <memset>
 8026bc6:	e050      	b.n	8026c6a <sm_pdu_handler+0x7e6>
                    } else {
                        (void)memcpy(setup->sm_rb, sm_sc_oob_random, 16);
 8026bc8:	4b77      	ldr	r3, [pc, #476]	; (8026da8 <sm_pdu_handler+0x924>)
 8026bca:	681b      	ldr	r3, [r3, #0]
 8026bcc:	f503 73ab 	add.w	r3, r3, #342	; 0x156
 8026bd0:	4a7a      	ldr	r2, [pc, #488]	; (8026dbc <sm_pdu_handler+0x938>)
 8026bd2:	461c      	mov	r4, r3
 8026bd4:	4615      	mov	r5, r2
 8026bd6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8026bd8:	6020      	str	r0, [r4, #0]
 8026bda:	6061      	str	r1, [r4, #4]
 8026bdc:	60a2      	str	r2, [r4, #8]
 8026bde:	60e3      	str	r3, [r4, #12]
                        log_info("Use stored rb");
 8026be0:	f241 0311 	movw	r3, #4113	; 0x1011
 8026be4:	4a71      	ldr	r2, [pc, #452]	; (8026dac <sm_pdu_handler+0x928>)
 8026be6:	4976      	ldr	r1, [pc, #472]	; (8026dc0 <sm_pdu_handler+0x93c>)
 8026be8:	2001      	movs	r0, #1
 8026bea:	f7f0 fc29 	bl	8017440 <hci_dump_log>
                        log_info_hexdump(setup->sm_rb, 16);
 8026bee:	4b6e      	ldr	r3, [pc, #440]	; (8026da8 <sm_pdu_handler+0x924>)
 8026bf0:	681b      	ldr	r3, [r3, #0]
 8026bf2:	f503 73ab 	add.w	r3, r3, #342	; 0x156
 8026bf6:	2110      	movs	r1, #16
 8026bf8:	4618      	mov	r0, r3
 8026bfa:	f7e8 fbad 	bl	800f358 <log_info_hexdump>
 8026bfe:	e034      	b.n	8026c6a <sm_pdu_handler+0x7e6>
                    }
                }  else {
                    if (sm_pairing_packet_get_oob_data_flag(setup->sm_s_pres) == 0u){
 8026c00:	4b69      	ldr	r3, [pc, #420]	; (8026da8 <sm_pdu_handler+0x924>)
 8026c02:	681b      	ldr	r3, [r3, #0]
 8026c04:	3340      	adds	r3, #64	; 0x40
 8026c06:	4618      	mov	r0, r3
 8026c08:	f7fa f9e4 	bl	8020fd4 <sm_pairing_packet_get_oob_data_flag>
 8026c0c:	4603      	mov	r3, r0
 8026c0e:	2b00      	cmp	r3, #0
 8026c10:	d110      	bne.n	8026c34 <sm_pdu_handler+0x7b0>
                        log_info("Reset ra as B does not have OOB data");
 8026c12:	f241 0316 	movw	r3, #4118	; 0x1016
 8026c16:	4a65      	ldr	r2, [pc, #404]	; (8026dac <sm_pdu_handler+0x928>)
 8026c18:	496a      	ldr	r1, [pc, #424]	; (8026dc4 <sm_pdu_handler+0x940>)
 8026c1a:	2001      	movs	r0, #1
 8026c1c:	f7f0 fc10 	bl	8017440 <hci_dump_log>
                        memset(setup->sm_ra, 0, 16);
 8026c20:	4b61      	ldr	r3, [pc, #388]	; (8026da8 <sm_pdu_handler+0x924>)
 8026c22:	681b      	ldr	r3, [r3, #0]
 8026c24:	f503 73a3 	add.w	r3, r3, #326	; 0x146
 8026c28:	2210      	movs	r2, #16
 8026c2a:	2100      	movs	r1, #0
 8026c2c:	4618      	mov	r0, r3
 8026c2e:	f000 ff48 	bl	8027ac2 <memset>
 8026c32:	e01a      	b.n	8026c6a <sm_pdu_handler+0x7e6>
                    } else {
                        (void)memcpy(setup->sm_ra, sm_sc_oob_random, 16);
 8026c34:	4b5c      	ldr	r3, [pc, #368]	; (8026da8 <sm_pdu_handler+0x924>)
 8026c36:	681b      	ldr	r3, [r3, #0]
 8026c38:	f503 73a3 	add.w	r3, r3, #326	; 0x146
 8026c3c:	4a5f      	ldr	r2, [pc, #380]	; (8026dbc <sm_pdu_handler+0x938>)
 8026c3e:	461c      	mov	r4, r3
 8026c40:	4615      	mov	r5, r2
 8026c42:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8026c44:	6020      	str	r0, [r4, #0]
 8026c46:	6061      	str	r1, [r4, #4]
 8026c48:	60a2      	str	r2, [r4, #8]
 8026c4a:	60e3      	str	r3, [r4, #12]
                        log_info("Use stored ra");
 8026c4c:	f241 031a 	movw	r3, #4122	; 0x101a
 8026c50:	4a56      	ldr	r2, [pc, #344]	; (8026dac <sm_pdu_handler+0x928>)
 8026c52:	495d      	ldr	r1, [pc, #372]	; (8026dc8 <sm_pdu_handler+0x944>)
 8026c54:	2001      	movs	r0, #1
 8026c56:	f7f0 fbf3 	bl	8017440 <hci_dump_log>
                        log_info_hexdump(setup->sm_ra, 16);
 8026c5a:	4b53      	ldr	r3, [pc, #332]	; (8026da8 <sm_pdu_handler+0x924>)
 8026c5c:	681b      	ldr	r3, [r3, #0]
 8026c5e:	f503 73a3 	add.w	r3, r3, #326	; 0x146
 8026c62:	2110      	movs	r1, #16
 8026c64:	4618      	mov	r0, r3
 8026c66:	f7e8 fb77 	bl	800f358 <log_info_hexdump>
                    }
                }

                // validate confirm value if Cb = f4(PKb, Pkb, rb, 0) for OOB if data received
                if (setup->sm_have_oob_data){
 8026c6a:	4b4f      	ldr	r3, [pc, #316]	; (8026da8 <sm_pdu_handler+0x924>)
 8026c6c:	681b      	ldr	r3, [r3, #0]
 8026c6e:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8026c72:	2b00      	cmp	r3, #0
 8026c74:	d003      	beq.n	8026c7e <sm_pdu_handler+0x7fa>
                     sm_conn->sm_engine_state = SM_SC_W2_CMAC_FOR_CHECK_CONFIRMATION;
 8026c76:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026c78:	2237      	movs	r2, #55	; 0x37
 8026c7a:	731a      	strb	r2, [r3, #12]
                     break;
 8026c7c:	e196      	b.n	8026fac <sm_pdu_handler+0xb28>
                }
            }

            // TODO: we only get here for Responder role with JW/NC
            sm_sc_state_after_receiving_random(sm_conn);
 8026c7e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026c80:	f7fb ff16 	bl	8022ab0 <sm_sc_state_after_receiving_random>
            break;
 8026c84:	e192      	b.n	8026fac <sm_pdu_handler+0xb28>
        case SM_SC_W4_CALCULATE_F5_LTK:
        case SM_SC_W2_CALCULATE_F6_FOR_DHKEY_CHECK:
        case SM_SC_W4_DHKEY_CHECK_COMMAND:
        case SM_SC_W4_CALCULATE_F6_FOR_DHKEY_CHECK:
        case SM_SC_W4_USER_RESPONSE:
            if (sm_pdu_code != SM_CODE_PAIRING_DHKEY_CHECK){
 8026c86:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8026c8a:	2b0d      	cmp	r3, #13
 8026c8c:	d003      	beq.n	8026c96 <sm_pdu_handler+0x812>
                sm_pdu_received_in_wrong_state(sm_conn);
 8026c8e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026c90:	f7fb fede 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;
 8026c94:	e18a      	b.n	8026fac <sm_pdu_handler+0xb28>
            }
            // store DHKey Check
            setup->sm_state_vars |= SM_STATE_VAR_DHKEY_COMMAND_RECEIVED;
 8026c96:	4b44      	ldr	r3, [pc, #272]	; (8026da8 <sm_pdu_handler+0x924>)
 8026c98:	681b      	ldr	r3, [r3, #0]
 8026c9a:	f893 20a5 	ldrb.w	r2, [r3, #165]	; 0xa5
 8026c9e:	4b42      	ldr	r3, [pc, #264]	; (8026da8 <sm_pdu_handler+0x924>)
 8026ca0:	681b      	ldr	r3, [r3, #0]
 8026ca2:	f042 0204 	orr.w	r2, r2, #4
 8026ca6:	b2d2      	uxtb	r2, r2
 8026ca8:	f883 20a5 	strb.w	r2, [r3, #165]	; 0xa5
            reverse_128(&packet[01], setup->sm_peer_dhkey_check);
 8026cac:	68bb      	ldr	r3, [r7, #8]
 8026cae:	1c5a      	adds	r2, r3, #1
 8026cb0:	4b3d      	ldr	r3, [pc, #244]	; (8026da8 <sm_pdu_handler+0x924>)
 8026cb2:	681b      	ldr	r3, [r3, #0]
 8026cb4:	f503 7393 	add.w	r3, r3, #294	; 0x126
 8026cb8:	4619      	mov	r1, r3
 8026cba:	4610      	mov	r0, r2
 8026cbc:	f7e8 f9fd 	bl	800f0ba <reverse_128>

            // have we been only waiting for dhkey check command?
            if (sm_conn->sm_engine_state == SM_SC_W4_DHKEY_CHECK_COMMAND){
 8026cc0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026cc2:	7b1b      	ldrb	r3, [r3, #12]
 8026cc4:	2b4b      	cmp	r3, #75	; 0x4b
 8026cc6:	f040 816e 	bne.w	8026fa6 <sm_pdu_handler+0xb22>
                sm_conn->sm_engine_state = SM_SC_W2_CALCULATE_F6_TO_VERIFY_DHKEY_CHECK;
 8026cca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026ccc:	2247      	movs	r2, #71	; 0x47
 8026cce:	731a      	strb	r2, [r3, #12]
            }
            break;
 8026cd0:	e169      	b.n	8026fa6 <sm_pdu_handler+0xb22>
#endif

#ifdef ENABLE_LE_PERIPHERAL
        case SM_RESPONDER_PH1_W4_PAIRING_CONFIRM:
            if (sm_pdu_code != SM_CODE_PAIRING_CONFIRM){
 8026cd2:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8026cd6:	2b03      	cmp	r3, #3
 8026cd8:	d003      	beq.n	8026ce2 <sm_pdu_handler+0x85e>
                sm_pdu_received_in_wrong_state(sm_conn);
 8026cda:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026cdc:	f7fb feb8 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;
 8026ce0:	e164      	b.n	8026fac <sm_pdu_handler+0xb28>
            }

            // received confirm value
            reverse_128(&packet[1], setup->sm_peer_confirm);
 8026ce2:	68bb      	ldr	r3, [r7, #8]
 8026ce4:	1c5a      	adds	r2, r3, #1
 8026ce6:	4b30      	ldr	r3, [pc, #192]	; (8026da8 <sm_pdu_handler+0x924>)
 8026ce8:	681b      	ldr	r3, [r3, #0]
 8026cea:	3377      	adds	r3, #119	; 0x77
 8026cec:	4619      	mov	r1, r3
 8026cee:	4610      	mov	r0, r2
 8026cf0:	f7e8 f9e3 	bl	800f0ba <reverse_128>
                log_info("testing_support: reset confirm value");
                memset(setup->sm_peer_confirm, 0, 16);
            }
#endif
            // notify client to hide shown passkey
            if (setup->sm_stk_generation_method == PK_INIT_INPUT){
 8026cf4:	4b2c      	ldr	r3, [pc, #176]	; (8026da8 <sm_pdu_handler+0x924>)
 8026cf6:	681b      	ldr	r3, [r3, #0]
 8026cf8:	7d9b      	ldrb	r3, [r3, #22]
 8026cfa:	2b02      	cmp	r3, #2
 8026cfc:	d108      	bne.n	8026d10 <sm_pdu_handler+0x88c>
                sm_notify_client_base(SM_EVENT_PASSKEY_DISPLAY_CANCEL, sm_conn->sm_handle, sm_conn->sm_peer_addr_type, sm_conn->sm_peer_address);
 8026cfe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026d00:	8819      	ldrh	r1, [r3, #0]
 8026d02:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026d04:	795a      	ldrb	r2, [r3, #5]
 8026d06:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026d08:	3306      	adds	r3, #6
 8026d0a:	20d2      	movs	r0, #210	; 0xd2
 8026d0c:	f7fa fb67 	bl	80213de <sm_notify_client_base>
            }

            // handle user cancel pairing?
            if (setup->sm_user_response == SM_USER_RESPONSE_DECLINE){
 8026d10:	4b25      	ldr	r3, [pc, #148]	; (8026da8 <sm_pdu_handler+0x924>)
 8026d12:	681b      	ldr	r3, [r3, #0]
 8026d14:	7c5b      	ldrb	r3, [r3, #17]
 8026d16:	2b04      	cmp	r3, #4
 8026d18:	d107      	bne.n	8026d2a <sm_pdu_handler+0x8a6>
                setup->sm_pairing_failed_reason = SM_REASON_PASSKEY_ENTRY_FAILED;
 8026d1a:	4b23      	ldr	r3, [pc, #140]	; (8026da8 <sm_pdu_handler+0x924>)
 8026d1c:	681b      	ldr	r3, [r3, #0]
 8026d1e:	2201      	movs	r2, #1
 8026d20:	741a      	strb	r2, [r3, #16]
                sm_conn->sm_engine_state = SM_GENERAL_SEND_PAIRING_FAILED;
 8026d22:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026d24:	2201      	movs	r2, #1
 8026d26:	731a      	strb	r2, [r3, #12]
                break;
 8026d28:	e140      	b.n	8026fac <sm_pdu_handler+0xb28>
            }

            // wait for user action?
            if (setup->sm_user_response == SM_USER_RESPONSE_PENDING){
 8026d2a:	4b1f      	ldr	r3, [pc, #124]	; (8026da8 <sm_pdu_handler+0x924>)
 8026d2c:	681b      	ldr	r3, [r3, #0]
 8026d2e:	7c5b      	ldrb	r3, [r3, #17]
 8026d30:	2b01      	cmp	r3, #1
 8026d32:	d103      	bne.n	8026d3c <sm_pdu_handler+0x8b8>
                sm_conn->sm_engine_state = SM_PH1_W4_USER_RESPONSE;
 8026d34:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026d36:	2204      	movs	r2, #4
 8026d38:	731a      	strb	r2, [r3, #12]
                break;
 8026d3a:	e137      	b.n	8026fac <sm_pdu_handler+0xb28>
            }

            // calculate and send local_confirm
            btstack_crypto_random_generate(&sm_crypto_random_request, setup->sm_local_random, 16, &sm_handle_random_result_ph2_random, (void *)(uintptr_t) sm_conn->sm_handle);
 8026d3c:	4b1a      	ldr	r3, [pc, #104]	; (8026da8 <sm_pdu_handler+0x924>)
 8026d3e:	681b      	ldr	r3, [r3, #0]
 8026d40:	f103 0147 	add.w	r1, r3, #71	; 0x47
 8026d44:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026d46:	881b      	ldrh	r3, [r3, #0]
 8026d48:	9300      	str	r3, [sp, #0]
 8026d4a:	4b20      	ldr	r3, [pc, #128]	; (8026dcc <sm_pdu_handler+0x948>)
 8026d4c:	2210      	movs	r2, #16
 8026d4e:	4820      	ldr	r0, [pc, #128]	; (8026dd0 <sm_pdu_handler+0x94c>)
 8026d50:	f7e7 fb74 	bl	800e43c <btstack_crypto_random_generate>
            break;
 8026d54:	e12a      	b.n	8026fac <sm_pdu_handler+0xb28>

        case SM_RESPONDER_PH2_W4_PAIRING_RANDOM:
            if (sm_pdu_code != SM_CODE_PAIRING_RANDOM){
 8026d56:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8026d5a:	2b04      	cmp	r3, #4
 8026d5c:	d003      	beq.n	8026d66 <sm_pdu_handler+0x8e2>
                sm_pdu_received_in_wrong_state(sm_conn);
 8026d5e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026d60:	f7fb fe76 	bl	8022a50 <sm_pdu_received_in_wrong_state>
                break;;
 8026d64:	e122      	b.n	8026fac <sm_pdu_handler+0xb28>
            }

            // received random value
            reverse_128(&packet[1], setup->sm_peer_random);
 8026d66:	68bb      	ldr	r3, [r7, #8]
 8026d68:	1c5a      	adds	r2, r3, #1
 8026d6a:	4b0f      	ldr	r3, [pc, #60]	; (8026da8 <sm_pdu_handler+0x924>)
 8026d6c:	681b      	ldr	r3, [r3, #0]
 8026d6e:	3367      	adds	r3, #103	; 0x67
 8026d70:	4619      	mov	r1, r3
 8026d72:	4610      	mov	r0, r2
 8026d74:	f7e8 f9a1 	bl	800f0ba <reverse_128>
            sm_conn->sm_engine_state = SM_PH2_C1_GET_ENC_C;
 8026d78:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026d7a:	220d      	movs	r2, #13
 8026d7c:	731a      	strb	r2, [r3, #12]
            break;
 8026d7e:	e115      	b.n	8026fac <sm_pdu_handler+0xb28>
#endif

        case SM_PH3_RECEIVE_KEYS:
            switch(sm_pdu_code){
 8026d80:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8026d84:	3b06      	subs	r3, #6
 8026d86:	2b04      	cmp	r3, #4
 8026d88:	f200 8097 	bhi.w	8026eba <sm_pdu_handler+0xa36>
 8026d8c:	a201      	add	r2, pc, #4	; (adr r2, 8026d94 <sm_pdu_handler+0x910>)
 8026d8e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8026d92:	bf00      	nop
 8026d94:	08026dd5 	.word	0x08026dd5
 8026d98:	08026dfd 	.word	0x08026dfd
 8026d9c:	08026e37 	.word	0x08026e37
 8026da0:	08026e5f 	.word	0x08026e5f
 8026da4:	08026e93 	.word	0x08026e93
 8026da8:	200000a0 	.word	0x200000a0
 8026dac:	0802d4a8 	.word	0x0802d4a8
 8026db0:	0802e32c 	.word	0x0802e32c
 8026db4:	0802e390 	.word	0x0802e390
 8026db8:	0802e3d0 	.word	0x0802e3d0
 8026dbc:	20009f50 	.word	0x20009f50
 8026dc0:	0802e3fc 	.word	0x0802e3fc
 8026dc4:	0802e414 	.word	0x0802e414
 8026dc8:	0802e440 	.word	0x0802e440
 8026dcc:	080259b5 	.word	0x080259b5
 8026dd0:	2000a06c 	.word	0x2000a06c
                case SM_CODE_ENCRYPTION_INFORMATION:
                    setup->sm_key_distribution_received_set |= SM_KEYDIST_FLAG_ENCRYPTION_INFORMATION;
 8026dd4:	4b7e      	ldr	r3, [pc, #504]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026dd6:	681b      	ldr	r3, [r3, #0]
 8026dd8:	7d5a      	ldrb	r2, [r3, #21]
 8026dda:	4b7d      	ldr	r3, [pc, #500]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026ddc:	681b      	ldr	r3, [r3, #0]
 8026dde:	f042 0201 	orr.w	r2, r2, #1
 8026de2:	b2d2      	uxtb	r2, r2
 8026de4:	755a      	strb	r2, [r3, #21]
                    reverse_128(&packet[1], setup->sm_peer_ltk);
 8026de6:	68bb      	ldr	r3, [r7, #8]
 8026de8:	1c5a      	adds	r2, r3, #1
 8026dea:	4b79      	ldr	r3, [pc, #484]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026dec:	681b      	ldr	r3, [r3, #0]
 8026dee:	f503 73ea 	add.w	r3, r3, #468	; 0x1d4
 8026df2:	4619      	mov	r1, r3
 8026df4:	4610      	mov	r0, r2
 8026df6:	f7e8 f960 	bl	800f0ba <reverse_128>
                    break;
 8026dfa:	e069      	b.n	8026ed0 <sm_pdu_handler+0xa4c>

                case SM_CODE_MASTER_IDENTIFICATION:
                    setup->sm_key_distribution_received_set |= SM_KEYDIST_FLAG_MASTER_IDENTIFICATION;
 8026dfc:	4b74      	ldr	r3, [pc, #464]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026dfe:	681b      	ldr	r3, [r3, #0]
 8026e00:	7d5a      	ldrb	r2, [r3, #21]
 8026e02:	4b73      	ldr	r3, [pc, #460]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e04:	681b      	ldr	r3, [r3, #0]
 8026e06:	f042 0202 	orr.w	r2, r2, #2
 8026e0a:	b2d2      	uxtb	r2, r2
 8026e0c:	755a      	strb	r2, [r3, #21]
                    setup->sm_peer_ediv = little_endian_read_16(packet, 1);
 8026e0e:	4b70      	ldr	r3, [pc, #448]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e10:	681c      	ldr	r4, [r3, #0]
 8026e12:	2101      	movs	r1, #1
 8026e14:	68b8      	ldr	r0, [r7, #8]
 8026e16:	f7e7 ffe6 	bl	800ede6 <little_endian_read_16>
 8026e1a:	4603      	mov	r3, r0
 8026e1c:	f8a4 31ca 	strh.w	r3, [r4, #458]	; 0x1ca
                    reverse_64(&packet[3], setup->sm_peer_rand);
 8026e20:	68bb      	ldr	r3, [r7, #8]
 8026e22:	1cda      	adds	r2, r3, #3
 8026e24:	4b6a      	ldr	r3, [pc, #424]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e26:	681b      	ldr	r3, [r3, #0]
 8026e28:	f503 73e6 	add.w	r3, r3, #460	; 0x1cc
 8026e2c:	4619      	mov	r1, r3
 8026e2e:	4610      	mov	r0, r2
 8026e30:	f7e8 f935 	bl	800f09e <reverse_64>
                    break;
 8026e34:	e04c      	b.n	8026ed0 <sm_pdu_handler+0xa4c>

                case SM_CODE_IDENTITY_INFORMATION:
                    setup->sm_key_distribution_received_set |= SM_KEYDIST_FLAG_IDENTITY_INFORMATION;
 8026e36:	4b66      	ldr	r3, [pc, #408]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e38:	681b      	ldr	r3, [r3, #0]
 8026e3a:	7d5a      	ldrb	r2, [r3, #21]
 8026e3c:	4b64      	ldr	r3, [pc, #400]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e3e:	681b      	ldr	r3, [r3, #0]
 8026e40:	f042 0204 	orr.w	r2, r2, #4
 8026e44:	b2d2      	uxtb	r2, r2
 8026e46:	755a      	strb	r2, [r3, #21]
                    reverse_128(&packet[1], setup->sm_peer_irk);
 8026e48:	68bb      	ldr	r3, [r7, #8]
 8026e4a:	1c5a      	adds	r2, r3, #1
 8026e4c:	4b60      	ldr	r3, [pc, #384]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e4e:	681b      	ldr	r3, [r3, #0]
 8026e50:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 8026e54:	4619      	mov	r1, r3
 8026e56:	4610      	mov	r0, r2
 8026e58:	f7e8 f92f 	bl	800f0ba <reverse_128>
                    break;
 8026e5c:	e038      	b.n	8026ed0 <sm_pdu_handler+0xa4c>

                case SM_CODE_IDENTITY_ADDRESS_INFORMATION:
                    setup->sm_key_distribution_received_set |= SM_KEYDIST_FLAG_IDENTITY_ADDRESS_INFORMATION;
 8026e5e:	4b5c      	ldr	r3, [pc, #368]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e60:	681b      	ldr	r3, [r3, #0]
 8026e62:	7d5a      	ldrb	r2, [r3, #21]
 8026e64:	4b5a      	ldr	r3, [pc, #360]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e66:	681b      	ldr	r3, [r3, #0]
 8026e68:	f042 0208 	orr.w	r2, r2, #8
 8026e6c:	b2d2      	uxtb	r2, r2
 8026e6e:	755a      	strb	r2, [r3, #21]
                    setup->sm_peer_addr_type = packet[1];
 8026e70:	4b57      	ldr	r3, [pc, #348]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e72:	681b      	ldr	r3, [r3, #0]
 8026e74:	68ba      	ldr	r2, [r7, #8]
 8026e76:	7852      	ldrb	r2, [r2, #1]
 8026e78:	f883 2204 	strb.w	r2, [r3, #516]	; 0x204
                    reverse_bd_addr(&packet[2], setup->sm_peer_address);
 8026e7c:	68bb      	ldr	r3, [r7, #8]
 8026e7e:	1c9a      	adds	r2, r3, #2
 8026e80:	4b53      	ldr	r3, [pc, #332]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e82:	681b      	ldr	r3, [r3, #0]
 8026e84:	f203 2305 	addw	r3, r3, #517	; 0x205
 8026e88:	4619      	mov	r1, r3
 8026e8a:	4610      	mov	r0, r2
 8026e8c:	f7e8 f931 	bl	800f0f2 <reverse_bd_addr>
                    break;
 8026e90:	e01e      	b.n	8026ed0 <sm_pdu_handler+0xa4c>

                case SM_CODE_SIGNING_INFORMATION:
                    setup->sm_key_distribution_received_set |= SM_KEYDIST_FLAG_SIGNING_IDENTIFICATION;
 8026e92:	4b4f      	ldr	r3, [pc, #316]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e94:	681b      	ldr	r3, [r3, #0]
 8026e96:	7d5a      	ldrb	r2, [r3, #21]
 8026e98:	4b4d      	ldr	r3, [pc, #308]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026e9a:	681b      	ldr	r3, [r3, #0]
 8026e9c:	f042 0210 	orr.w	r2, r2, #16
 8026ea0:	b2d2      	uxtb	r2, r2
 8026ea2:	755a      	strb	r2, [r3, #21]
                    reverse_128(&packet[1], setup->sm_peer_csrk);
 8026ea4:	68bb      	ldr	r3, [r7, #8]
 8026ea6:	1c5a      	adds	r2, r3, #1
 8026ea8:	4b49      	ldr	r3, [pc, #292]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026eaa:	681b      	ldr	r3, [r3, #0]
 8026eac:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8026eb0:	4619      	mov	r1, r3
 8026eb2:	4610      	mov	r0, r2
 8026eb4:	f7e8 f901 	bl	800f0ba <reverse_128>
                    break;
 8026eb8:	e00a      	b.n	8026ed0 <sm_pdu_handler+0xa4c>
                default:
                    // Unexpected PDU
                    log_info("Unexpected PDU %u in SM_PH3_RECEIVE_KEYS", packet[0]);
 8026eba:	68bb      	ldr	r3, [r7, #8]
 8026ebc:	781b      	ldrb	r3, [r3, #0]
 8026ebe:	9300      	str	r3, [sp, #0]
 8026ec0:	f241 0396 	movw	r3, #4246	; 0x1096
 8026ec4:	4a43      	ldr	r2, [pc, #268]	; (8026fd4 <sm_pdu_handler+0xb50>)
 8026ec6:	4944      	ldr	r1, [pc, #272]	; (8026fd8 <sm_pdu_handler+0xb54>)
 8026ec8:	2001      	movs	r0, #1
 8026eca:	f7f0 fab9 	bl	8017440 <hci_dump_log>
                    break;
 8026ece:	bf00      	nop
            }
            // done with key distribution?
            if (sm_key_distribution_all_received(sm_conn)){
 8026ed0:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026ed2:	f7fb f853 	bl	8021f7c <sm_key_distribution_all_received>
 8026ed6:	4603      	mov	r3, r0
 8026ed8:	2b00      	cmp	r3, #0
 8026eda:	d066      	beq.n	8026faa <sm_pdu_handler+0xb26>

                sm_key_distribution_handle_all_received(sm_conn);
 8026edc:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026ede:	f7fb fc01 	bl	80226e4 <sm_key_distribution_handle_all_received>

                if (IS_RESPONDER(sm_conn->sm_role)){
 8026ee2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026ee4:	789b      	ldrb	r3, [r3, #2]
 8026ee6:	2b00      	cmp	r3, #0
 8026ee8:	d036      	beq.n	8026f58 <sm_pdu_handler+0xad4>
                    if (sm_ctkd_from_le(sm_conn)){
 8026eea:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026eec:	f7fe fbce 	bl	802568c <sm_ctkd_from_le>
 8026ef0:	4603      	mov	r3, r0
 8026ef2:	2b00      	cmp	r3, #0
 8026ef4:	d022      	beq.n	8026f3c <sm_pdu_handler+0xab8>
                    	bool use_h7 = (sm_pairing_packet_get_auth_req(setup->sm_m_preq) & sm_pairing_packet_get_auth_req(setup->sm_s_pres) & SM_AUTHREQ_CT2) != 0;
 8026ef6:	4b36      	ldr	r3, [pc, #216]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026ef8:	681b      	ldr	r3, [r3, #0]
 8026efa:	3339      	adds	r3, #57	; 0x39
 8026efc:	4618      	mov	r0, r3
 8026efe:	f7fa f875 	bl	8020fec <sm_pairing_packet_get_auth_req>
 8026f02:	4603      	mov	r3, r0
 8026f04:	461c      	mov	r4, r3
 8026f06:	4b32      	ldr	r3, [pc, #200]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026f08:	681b      	ldr	r3, [r3, #0]
 8026f0a:	3340      	adds	r3, #64	; 0x40
 8026f0c:	4618      	mov	r0, r3
 8026f0e:	f7fa f86d 	bl	8020fec <sm_pairing_packet_get_auth_req>
 8026f12:	4603      	mov	r3, r0
 8026f14:	4023      	ands	r3, r4
 8026f16:	b2db      	uxtb	r3, r3
 8026f18:	f003 0320 	and.w	r3, r3, #32
 8026f1c:	2b00      	cmp	r3, #0
 8026f1e:	bf14      	ite	ne
 8026f20:	2301      	movne	r3, #1
 8026f22:	2300      	moveq	r3, #0
 8026f24:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                        sm_conn->sm_engine_state = use_h7 ? SM_SC_W2_CALCULATE_ILK_USING_H7 : SM_SC_W2_CALCULATE_ILK_USING_H6;
 8026f28:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8026f2c:	2b00      	cmp	r3, #0
 8026f2e:	d001      	beq.n	8026f34 <sm_pdu_handler+0xab0>
 8026f30:	224e      	movs	r2, #78	; 0x4e
 8026f32:	e000      	b.n	8026f36 <sm_pdu_handler+0xab2>
 8026f34:	224d      	movs	r2, #77	; 0x4d
 8026f36:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026f38:	731a      	strb	r2, [r3, #12]
                    } else {
                        btstack_crypto_random_generate(&sm_crypto_random_request, sm_random_data, 8, &sm_handle_random_result_ph3_random, (void *)(uintptr_t) sm_conn->sm_handle);
                    }
                }
            }
            break;
 8026f3a:	e036      	b.n	8026faa <sm_pdu_handler+0xb26>
                        sm_conn->sm_engine_state = SM_RESPONDER_IDLE;
 8026f3c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026f3e:	221a      	movs	r2, #26
 8026f40:	731a      	strb	r2, [r3, #12]
                        sm_pairing_complete(sm_conn, ERROR_CODE_SUCCESS, 0);
 8026f42:	2200      	movs	r2, #0
 8026f44:	2100      	movs	r1, #0
 8026f46:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8026f48:	f7fa fb92 	bl	8021670 <sm_pairing_complete>
                        sm_done_for_handle(sm_conn->sm_handle);
 8026f4c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026f4e:	881b      	ldrh	r3, [r3, #0]
 8026f50:	4618      	mov	r0, r3
 8026f52:	f7fb f84f 	bl	8021ff4 <sm_done_for_handle>
            break;
 8026f56:	e028      	b.n	8026faa <sm_pdu_handler+0xb26>
                    if (setup->sm_use_secure_connections){
 8026f58:	4b1d      	ldr	r3, [pc, #116]	; (8026fd0 <sm_pdu_handler+0xb4c>)
 8026f5a:	681b      	ldr	r3, [r3, #0]
 8026f5c:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8026f60:	2b00      	cmp	r3, #0
 8026f62:	d003      	beq.n	8026f6c <sm_pdu_handler+0xae8>
                        sm_conn->sm_engine_state = SM_PH3_DISTRIBUTE_KEYS;
 8026f64:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026f66:	2217      	movs	r2, #23
 8026f68:	731a      	strb	r2, [r3, #12]
            break;
 8026f6a:	e01e      	b.n	8026faa <sm_pdu_handler+0xb26>
                        btstack_crypto_random_generate(&sm_crypto_random_request, sm_random_data, 8, &sm_handle_random_result_ph3_random, (void *)(uintptr_t) sm_conn->sm_handle);
 8026f6c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026f6e:	881b      	ldrh	r3, [r3, #0]
 8026f70:	9300      	str	r3, [sp, #0]
 8026f72:	4b1a      	ldr	r3, [pc, #104]	; (8026fdc <sm_pdu_handler+0xb58>)
 8026f74:	2208      	movs	r2, #8
 8026f76:	491a      	ldr	r1, [pc, #104]	; (8026fe0 <sm_pdu_handler+0xb5c>)
 8026f78:	481a      	ldr	r0, [pc, #104]	; (8026fe4 <sm_pdu_handler+0xb60>)
 8026f7a:	f7e7 fa5f 	bl	800e43c <btstack_crypto_random_generate>
            break;
 8026f7e:	e014      	b.n	8026faa <sm_pdu_handler+0xb26>
        default:
            // Unexpected PDU
            log_info("Unexpected PDU %u in state %u", packet[0], sm_conn->sm_engine_state);
 8026f80:	68bb      	ldr	r3, [r7, #8]
 8026f82:	781b      	ldrb	r3, [r3, #0]
 8026f84:	461a      	mov	r2, r3
 8026f86:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026f88:	7b1b      	ldrb	r3, [r3, #12]
 8026f8a:	9301      	str	r3, [sp, #4]
 8026f8c:	9200      	str	r2, [sp, #0]
 8026f8e:	f241 03b2 	movw	r3, #4274	; 0x10b2
 8026f92:	4a10      	ldr	r2, [pc, #64]	; (8026fd4 <sm_pdu_handler+0xb50>)
 8026f94:	4914      	ldr	r1, [pc, #80]	; (8026fe8 <sm_pdu_handler+0xb64>)
 8026f96:	2001      	movs	r0, #1
 8026f98:	f7f0 fa52 	bl	8017440 <hci_dump_log>
            break;
 8026f9c:	e006      	b.n	8026fac <sm_pdu_handler+0xb28>
                break;
 8026f9e:	bf00      	nop
 8026fa0:	e004      	b.n	8026fac <sm_pdu_handler+0xb28>
            break;
 8026fa2:	bf00      	nop
 8026fa4:	e002      	b.n	8026fac <sm_pdu_handler+0xb28>
            break;
 8026fa6:	bf00      	nop
 8026fa8:	e000      	b.n	8026fac <sm_pdu_handler+0xb28>
            break;
 8026faa:	bf00      	nop
    }

    // try to send next pdu
    sm_trigger_run();
 8026fac:	f7fa f900 	bl	80211b0 <sm_trigger_run>
 8026fb0:	e00a      	b.n	8026fc8 <sm_pdu_handler+0xb44>
    if (packet_type != SM_DATA_PACKET) return;
 8026fb2:	bf00      	nop
 8026fb4:	e008      	b.n	8026fc8 <sm_pdu_handler+0xb44>
    if (size == 0u) return;
 8026fb6:	bf00      	nop
 8026fb8:	e006      	b.n	8026fc8 <sm_pdu_handler+0xb44>
    if (sm_pdu_code >= sizeof(sm_pdu_size)) return;
 8026fba:	bf00      	nop
 8026fbc:	e004      	b.n	8026fc8 <sm_pdu_handler+0xb44>
    if (sm_pdu_size[sm_pdu_code] != size)   return;
 8026fbe:	bf00      	nop
 8026fc0:	e002      	b.n	8026fc8 <sm_pdu_handler+0xb44>
    if (!sm_conn) return;
 8026fc2:	bf00      	nop
 8026fc4:	e000      	b.n	8026fc8 <sm_pdu_handler+0xb44>
            return;
 8026fc6:	bf00      	nop
}
 8026fc8:	3744      	adds	r7, #68	; 0x44
 8026fca:	46bd      	mov	sp, r7
 8026fcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8026fce:	bf00      	nop
 8026fd0:	200000a0 	.word	0x200000a0
 8026fd4:	0802d4a8 	.word	0x0802d4a8
 8026fd8:	0802e458 	.word	0x0802e458
 8026fdc:	08025b25 	.word	0x08025b25
 8026fe0:	2000a0b8 	.word	0x2000a0b8
 8026fe4:	2000a06c 	.word	0x2000a06c
 8026fe8:	0802e488 	.word	0x0802e488

08026fec <sm_add_event_handler>:

void sm_register_sc_oob_data_callback( int (*get_sc_oob_data_callback)(uint8_t address_type, bd_addr_t addr, uint8_t * oob_sc_peer_confirm, uint8_t * oob_sc_peer_random)){
    sm_get_sc_oob_data = get_sc_oob_data_callback;
}

void sm_add_event_handler(btstack_packet_callback_registration_t * callback_handler){
 8026fec:	b580      	push	{r7, lr}
 8026fee:	b082      	sub	sp, #8
 8026ff0:	af00      	add	r7, sp, #0
 8026ff2:	6078      	str	r0, [r7, #4]
    btstack_linked_list_add_tail(&sm_event_handlers, (btstack_linked_item_t*) callback_handler);
 8026ff4:	6879      	ldr	r1, [r7, #4]
 8026ff6:	4803      	ldr	r0, [pc, #12]	; (8027004 <sm_add_event_handler+0x18>)
 8026ff8:	f7e7 fb3e 	bl	800e678 <btstack_linked_list_add_tail>
}
 8026ffc:	bf00      	nop
 8026ffe:	3708      	adds	r7, #8
 8027000:	46bd      	mov	sp, r7
 8027002:	bd80      	pop	{r7, pc}
 8027004:	2000a0f8 	.word	0x2000a0f8

08027008 <sm_ec_generated>:
void sm_test_use_fixed_local_csrk(void){
    test_use_fixed_local_csrk = true;
}

#ifdef ENABLE_LE_SECURE_CONNECTIONS
static void sm_ec_generated(void * arg){
 8027008:	b580      	push	{r7, lr}
 802700a:	b082      	sub	sp, #8
 802700c:	af00      	add	r7, sp, #0
 802700e:	6078      	str	r0, [r7, #4]
    UNUSED(arg);
    ec_key_generation_state = EC_KEY_GENERATION_DONE;
 8027010:	4b04      	ldr	r3, [pc, #16]	; (8027024 <sm_ec_generated+0x1c>)
 8027012:	2202      	movs	r2, #2
 8027014:	701a      	strb	r2, [r3, #0]
    // trigger pairing if pending for ec key
    sm_trigger_run();
 8027016:	f7fa f8cb 	bl	80211b0 <sm_trigger_run>
}
 802701a:	bf00      	nop
 802701c:	3708      	adds	r7, #8
 802701e:	46bd      	mov	sp, r7
 8027020:	bd80      	pop	{r7, pc}
 8027022:	bf00      	nop
 8027024:	2000a10c 	.word	0x2000a10c

08027028 <sm_ec_generate_new_key>:
static void sm_ec_generate_new_key(void){
 8027028:	b580      	push	{r7, lr}
 802702a:	af00      	add	r7, sp, #0
    log_info("sm: generate new ec key");
 802702c:	f241 03ff 	movw	r3, #4351	; 0x10ff
 8027030:	4a07      	ldr	r2, [pc, #28]	; (8027050 <sm_ec_generate_new_key+0x28>)
 8027032:	4908      	ldr	r1, [pc, #32]	; (8027054 <sm_ec_generate_new_key+0x2c>)
 8027034:	2001      	movs	r0, #1
 8027036:	f7f0 fa03 	bl	8017440 <hci_dump_log>
    ec_key_generation_state = EC_KEY_GENERATION_ACTIVE;
 802703a:	4b07      	ldr	r3, [pc, #28]	; (8027058 <sm_ec_generate_new_key+0x30>)
 802703c:	2201      	movs	r2, #1
 802703e:	701a      	strb	r2, [r3, #0]
    btstack_crypto_ecc_p256_generate_key(&sm_crypto_ecc_p256_request, ec_q, &sm_ec_generated, NULL);
 8027040:	2300      	movs	r3, #0
 8027042:	4a06      	ldr	r2, [pc, #24]	; (802705c <sm_ec_generate_new_key+0x34>)
 8027044:	4906      	ldr	r1, [pc, #24]	; (8027060 <sm_ec_generate_new_key+0x38>)
 8027046:	4807      	ldr	r0, [pc, #28]	; (8027064 <sm_ec_generate_new_key+0x3c>)
 8027048:	f7e7 fa6c 	bl	800e524 <btstack_crypto_ecc_p256_generate_key>
}
 802704c:	bf00      	nop
 802704e:	bd80      	pop	{r7, pc}
 8027050:	0802d4a8 	.word	0x0802d4a8
 8027054:	0802e4b0 	.word	0x0802e4b0
 8027058:	2000a10c 	.word	0x2000a10c
 802705c:	08027009 	.word	0x08027009
 8027060:	2000a110 	.word	0x2000a110
 8027064:	2000a0a0 	.word	0x2000a0a0

08027068 <sm_init>:
void sm_test_set_pairing_failure(int reason){
    test_pairing_failure = reason;
}
#endif

void sm_init(void){
 8027068:	b580      	push	{r7, lr}
 802706a:	af00      	add	r7, sp, #0

    if (sm_initialized) return;
 802706c:	4b29      	ldr	r3, [pc, #164]	; (8027114 <sm_init+0xac>)
 802706e:	781b      	ldrb	r3, [r3, #0]
 8027070:	2b00      	cmp	r3, #0
 8027072:	d14c      	bne.n	802710e <sm_init+0xa6>

    // set default ER and IR values (should be unique - set by app or sm later using TLV)
    sm_er_ir_set_default();
 8027074:	f7fa f8ee 	bl	8021254 <sm_er_ir_set_default>

    // defaults
    sm_accepted_stk_generation_methods = SM_STK_GENERATION_METHOD_JUST_WORKS
 8027078:	4b27      	ldr	r3, [pc, #156]	; (8027118 <sm_init+0xb0>)
 802707a:	220f      	movs	r2, #15
 802707c:	701a      	strb	r2, [r3, #0]
                                       | SM_STK_GENERATION_METHOD_OOB
                                       | SM_STK_GENERATION_METHOD_PASSKEY
                                       | SM_STK_GENERATION_METHOD_NUMERIC_COMPARISON;

    sm_max_encryption_key_size = 16;
 802707e:	4b27      	ldr	r3, [pc, #156]	; (802711c <sm_init+0xb4>)
 8027080:	2210      	movs	r2, #16
 8027082:	701a      	strb	r2, [r3, #0]
    sm_min_encryption_key_size = 7;
 8027084:	4b26      	ldr	r3, [pc, #152]	; (8027120 <sm_init+0xb8>)
 8027086:	2207      	movs	r2, #7
 8027088:	701a      	strb	r2, [r3, #0]

    sm_fixed_passkey_in_display_role = 0xffffffff;
 802708a:	4b26      	ldr	r3, [pc, #152]	; (8027124 <sm_init+0xbc>)
 802708c:	f04f 32ff 	mov.w	r2, #4294967295
 8027090:	601a      	str	r2, [r3, #0]
    sm_reconstruct_ltk_without_le_device_db_entry = true;
 8027092:	4b25      	ldr	r3, [pc, #148]	; (8027128 <sm_init+0xc0>)
 8027094:	2201      	movs	r2, #1
 8027096:	701a      	strb	r2, [r3, #0]

#ifdef USE_CMAC_ENGINE
    sm_cmac_active  = 0;
 8027098:	4b24      	ldr	r3, [pc, #144]	; (802712c <sm_init+0xc4>)
 802709a:	2200      	movs	r2, #0
 802709c:	701a      	strb	r2, [r3, #0]
#endif
    dkg_state = DKG_W4_WORKING;
 802709e:	4b24      	ldr	r3, [pc, #144]	; (8027130 <sm_init+0xc8>)
 80270a0:	2200      	movs	r2, #0
 80270a2:	701a      	strb	r2, [r3, #0]
    rau_state = RAU_IDLE;
 80270a4:	4b23      	ldr	r3, [pc, #140]	; (8027134 <sm_init+0xcc>)
 80270a6:	2200      	movs	r2, #0
 80270a8:	701a      	strb	r2, [r3, #0]
    sm_aes128_state = SM_AES128_IDLE;
 80270aa:	4b23      	ldr	r3, [pc, #140]	; (8027138 <sm_init+0xd0>)
 80270ac:	2200      	movs	r2, #0
 80270ae:	701a      	strb	r2, [r3, #0]
    sm_address_resolution_test = -1;    // no private address to resolve yet
 80270b0:	4b22      	ldr	r3, [pc, #136]	; (802713c <sm_init+0xd4>)
 80270b2:	f04f 32ff 	mov.w	r2, #4294967295
 80270b6:	601a      	str	r2, [r3, #0]
    sm_address_resolution_ah_calculation_active = 0;
 80270b8:	4b21      	ldr	r3, [pc, #132]	; (8027140 <sm_init+0xd8>)
 80270ba:	2200      	movs	r2, #0
 80270bc:	601a      	str	r2, [r3, #0]
    sm_address_resolution_mode = ADDRESS_RESOLUTION_IDLE;
 80270be:	4b21      	ldr	r3, [pc, #132]	; (8027144 <sm_init+0xdc>)
 80270c0:	2200      	movs	r2, #0
 80270c2:	701a      	strb	r2, [r3, #0]
    sm_address_resolution_general_queue = NULL;
 80270c4:	4b20      	ldr	r3, [pc, #128]	; (8027148 <sm_init+0xe0>)
 80270c6:	2200      	movs	r2, #0
 80270c8:	601a      	str	r2, [r3, #0]

    gap_random_adress_update_period = 15 * 60 * 1000L;
 80270ca:	4b20      	ldr	r3, [pc, #128]	; (802714c <sm_init+0xe4>)
 80270cc:	4a20      	ldr	r2, [pc, #128]	; (8027150 <sm_init+0xe8>)
 80270ce:	601a      	str	r2, [r3, #0]
    sm_active_connection_handle = HCI_CON_HANDLE_INVALID;
 80270d0:	4b20      	ldr	r3, [pc, #128]	; (8027154 <sm_init+0xec>)
 80270d2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80270d6:	801a      	strh	r2, [r3, #0]

    test_use_fixed_local_csrk = false;
 80270d8:	4b1f      	ldr	r3, [pc, #124]	; (8027158 <sm_init+0xf0>)
 80270da:	2200      	movs	r2, #0
 80270dc:	701a      	strb	r2, [r3, #0]

    btstack_run_loop_set_timer_handler(&sm_run_timer, &sm_run_timer_handler);
 80270de:	491f      	ldr	r1, [pc, #124]	; (802715c <sm_init+0xf4>)
 80270e0:	481f      	ldr	r0, [pc, #124]	; (8027160 <sm_init+0xf8>)
 80270e2:	f7e7 fd53 	bl	800eb8c <btstack_run_loop_set_timer_handler>

    // register for HCI Events from HCI
    hci_event_callback_registration.callback = &sm_event_packet_handler;
 80270e6:	4b1f      	ldr	r3, [pc, #124]	; (8027164 <sm_init+0xfc>)
 80270e8:	4a1f      	ldr	r2, [pc, #124]	; (8027168 <sm_init+0x100>)
 80270ea:	605a      	str	r2, [r3, #4]
    hci_add_event_handler(&hci_event_callback_registration);
 80270ec:	481d      	ldr	r0, [pc, #116]	; (8027164 <sm_init+0xfc>)
 80270ee:	f7ec ff01 	bl	8013ef4 <hci_add_event_handler>

    // 
    btstack_crypto_init();
 80270f2:	f7e7 f98b 	bl	800e40c <btstack_crypto_init>

    // init le_device_db
    le_device_db_init();
 80270f6:	f7f9 fc9d 	bl	8020a34 <le_device_db_init>

    // and L2CAP PDUs + L2CAP_EVENT_CAN_SEND_NOW
    l2cap_register_fixed_channel(sm_pdu_handler, L2CAP_CID_SECURITY_MANAGER_PROTOCOL);
 80270fa:	2106      	movs	r1, #6
 80270fc:	481b      	ldr	r0, [pc, #108]	; (802716c <sm_init+0x104>)
 80270fe:	f7f5 fcc9 	bl	801ca94 <l2cap_register_fixed_channel>

#ifdef ENABLE_LE_SECURE_CONNECTIONS
    sm_ec_generate_new_key();
 8027102:	f7ff ff91 	bl	8027028 <sm_ec_generate_new_key>
#endif

    sm_initialized = true;
 8027106:	4b03      	ldr	r3, [pc, #12]	; (8027114 <sm_init+0xac>)
 8027108:	2201      	movs	r2, #1
 802710a:	701a      	strb	r2, [r3, #0]
 802710c:	e000      	b.n	8027110 <sm_init+0xa8>
    if (sm_initialized) return;
 802710e:	bf00      	nop
}
 8027110:	bd80      	pop	{r7, pc}
 8027112:	bf00      	nop
 8027114:	20009f40 	.word	0x20009f40
 8027118:	20009f43 	.word	0x20009f43
 802711c:	20009f44 	.word	0x20009f44
 8027120:	20009f45 	.word	0x20009f45
 8027124:	20009f48 	.word	0x20009f48
 8027128:	20009f4c 	.word	0x20009f4c
 802712c:	20009fe0 	.word	0x20009fe0
 8027130:	20009fb0 	.word	0x20009fb0
 8027134:	20009fb1 	.word	0x20009fb1
 8027138:	2000a068 	.word	0x2000a068
 802713c:	2000a048 	.word	0x2000a048
 8027140:	2000a04c 	.word	0x2000a04c
 8027144:	2000a060 	.word	0x2000a060
 8027148:	2000a064 	.word	0x2000a064
 802714c:	2000a378 	.word	0x2000a378
 8027150:	000dbba0 	.word	0x000dbba0
 8027154:	200000a4 	.word	0x200000a4
 8027158:	20009f41 	.word	0x20009f41
 802715c:	0802119b 	.word	0x0802119b
 8027160:	2000a0fc 	.word	0x2000a0fc
 8027164:	2000a0f0 	.word	0x2000a0f0
 8027168:	08025d91 	.word	0x08025d91
 802716c:	08026485 	.word	0x08026485

08027170 <sm_get_connection_for_handle>:

void sm_allow_ltk_reconstruction_without_le_device_db_entry(int allow){
    sm_reconstruct_ltk_without_le_device_db_entry = allow != 0;
}

static sm_connection_t * sm_get_connection_for_handle(hci_con_handle_t con_handle){
 8027170:	b580      	push	{r7, lr}
 8027172:	b084      	sub	sp, #16
 8027174:	af00      	add	r7, sp, #0
 8027176:	4603      	mov	r3, r0
 8027178:	80fb      	strh	r3, [r7, #6]
    hci_connection_t * hci_con = hci_connection_for_handle(con_handle);
 802717a:	88fb      	ldrh	r3, [r7, #6]
 802717c:	4618      	mov	r0, r3
 802717e:	f7e8 fba1 	bl	800f8c4 <hci_connection_for_handle>
 8027182:	60f8      	str	r0, [r7, #12]
    if (!hci_con) return NULL;
 8027184:	68fb      	ldr	r3, [r7, #12]
 8027186:	2b00      	cmp	r3, #0
 8027188:	d101      	bne.n	802718e <sm_get_connection_for_handle+0x1e>
 802718a:	2300      	movs	r3, #0
 802718c:	e002      	b.n	8027194 <sm_get_connection_for_handle+0x24>
    return &hci_con->sm_connection;
 802718e:	68fb      	ldr	r3, [r7, #12]
 8027190:	f203 731c 	addw	r3, r3, #1820	; 0x71c
}
 8027194:	4618      	mov	r0, r3
 8027196:	3710      	adds	r7, #16
 8027198:	46bd      	mov	sp, r7
 802719a:	bd80      	pop	{r7, pc}

0802719c <sm_request_pairing>:
    if (!IS_RESPONDER(sm_conn->sm_role)) return;
    sm_request_pairing(con_handle);
}

// request pairing
void sm_request_pairing(hci_con_handle_t con_handle){
 802719c:	b580      	push	{r7, lr}
 802719e:	b08c      	sub	sp, #48	; 0x30
 80271a0:	af04      	add	r7, sp, #16
 80271a2:	4603      	mov	r3, r0
 80271a4:	80fb      	strh	r3, [r7, #6]
    sm_connection_t * sm_conn = sm_get_connection_for_handle(con_handle);
 80271a6:	88fb      	ldrh	r3, [r7, #6]
 80271a8:	4618      	mov	r0, r3
 80271aa:	f7ff ffe1 	bl	8027170 <sm_get_connection_for_handle>
 80271ae:	61f8      	str	r0, [r7, #28]
    if (!sm_conn) return;     // wrong connection
 80271b0:	69fb      	ldr	r3, [r7, #28]
 80271b2:	2b00      	cmp	r3, #0
 80271b4:	f000 80d2 	beq.w	802735c <sm_request_pairing+0x1c0>

    bool have_ltk;
    uint8_t ltk[16];
    log_info("sm_request_pairing in role %u, state %u", sm_conn->sm_role, sm_conn->sm_engine_state);
 80271b8:	69fb      	ldr	r3, [r7, #28]
 80271ba:	789b      	ldrb	r3, [r3, #2]
 80271bc:	461a      	mov	r2, r3
 80271be:	69fb      	ldr	r3, [r7, #28]
 80271c0:	7b1b      	ldrb	r3, [r3, #12]
 80271c2:	9301      	str	r3, [sp, #4]
 80271c4:	9200      	str	r2, [sp, #0]
 80271c6:	f241 1361 	movw	r3, #4449	; 0x1161
 80271ca:	4a66      	ldr	r2, [pc, #408]	; (8027364 <sm_request_pairing+0x1c8>)
 80271cc:	4966      	ldr	r1, [pc, #408]	; (8027368 <sm_request_pairing+0x1cc>)
 80271ce:	2001      	movs	r0, #1
 80271d0:	f7f0 f936 	bl	8017440 <hci_dump_log>
    if (IS_RESPONDER(sm_conn->sm_role)){
 80271d4:	69fb      	ldr	r3, [r7, #28]
 80271d6:	789b      	ldrb	r3, [r3, #2]
 80271d8:	2b00      	cmp	r3, #0
 80271da:	d05d      	beq.n	8027298 <sm_request_pairing+0xfc>
        switch (sm_conn->sm_engine_state){
 80271dc:	69fb      	ldr	r3, [r7, #28]
 80271de:	7b1b      	ldrb	r3, [r3, #12]
 80271e0:	2b00      	cmp	r3, #0
 80271e2:	d002      	beq.n	80271ea <sm_request_pairing+0x4e>
 80271e4:	2b1a      	cmp	r3, #26
 80271e6:	d000      	beq.n	80271ea <sm_request_pairing+0x4e>
                        sm_conn->sm_pairing_requested = 1;
                        break;
                }
                break;
            default:
                break;
 80271e8:	e0b5      	b.n	8027356 <sm_request_pairing+0x1ba>
                switch (sm_conn->sm_irk_lookup_state){
 80271ea:	69fb      	ldr	r3, [r7, #28]
 80271ec:	7b5b      	ldrb	r3, [r3, #13]
 80271ee:	2b03      	cmp	r3, #3
 80271f0:	d002      	beq.n	80271f8 <sm_request_pairing+0x5c>
 80271f2:	2b04      	cmp	r3, #4
 80271f4:	d03a      	beq.n	802726c <sm_request_pairing+0xd0>
 80271f6:	e043      	b.n	8027280 <sm_request_pairing+0xe4>
                        le_device_db_encryption_get(sm_conn->sm_le_db_index, NULL, NULL, ltk, NULL, NULL, NULL, NULL);
 80271f8:	69fb      	ldr	r3, [r7, #28]
 80271fa:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80271fc:	f107 0208 	add.w	r2, r7, #8
 8027200:	2300      	movs	r3, #0
 8027202:	9303      	str	r3, [sp, #12]
 8027204:	2300      	movs	r3, #0
 8027206:	9302      	str	r3, [sp, #8]
 8027208:	2300      	movs	r3, #0
 802720a:	9301      	str	r3, [sp, #4]
 802720c:	2300      	movs	r3, #0
 802720e:	9300      	str	r3, [sp, #0]
 8027210:	4613      	mov	r3, r2
 8027212:	2200      	movs	r2, #0
 8027214:	2100      	movs	r1, #0
 8027216:	f7f9 fdef 	bl	8020df8 <le_device_db_encryption_get>
                        have_ltk = !sm_is_null_key(ltk);
 802721a:	f107 0308 	add.w	r3, r7, #8
 802721e:	4618      	mov	r0, r3
 8027220:	f7f9 ffae 	bl	8021180 <sm_is_null_key>
 8027224:	4603      	mov	r3, r0
 8027226:	2b00      	cmp	r3, #0
 8027228:	bf14      	ite	ne
 802722a:	2301      	movne	r3, #1
 802722c:	2300      	moveq	r3, #0
 802722e:	b2db      	uxtb	r3, r3
 8027230:	f083 0301 	eor.w	r3, r3, #1
 8027234:	b2db      	uxtb	r3, r3
 8027236:	76fb      	strb	r3, [r7, #27]
 8027238:	7efb      	ldrb	r3, [r7, #27]
 802723a:	f003 0301 	and.w	r3, r3, #1
 802723e:	76fb      	strb	r3, [r7, #27]
                        log_info("have ltk %u", have_ltk);
 8027240:	7efb      	ldrb	r3, [r7, #27]
 8027242:	9300      	str	r3, [sp, #0]
 8027244:	f241 136a 	movw	r3, #4458	; 0x116a
 8027248:	4a46      	ldr	r2, [pc, #280]	; (8027364 <sm_request_pairing+0x1c8>)
 802724a:	4948      	ldr	r1, [pc, #288]	; (802736c <sm_request_pairing+0x1d0>)
 802724c:	2001      	movs	r0, #1
 802724e:	f7f0 f8f7 	bl	8017440 <hci_dump_log>
                        if (have_ltk){
 8027252:	7efb      	ldrb	r3, [r7, #27]
 8027254:	2b00      	cmp	r3, #0
 8027256:	d009      	beq.n	802726c <sm_request_pairing+0xd0>
                            sm_conn->sm_pairing_requested = 1;
 8027258:	69fb      	ldr	r3, [r7, #28]
 802725a:	2201      	movs	r2, #1
 802725c:	711a      	strb	r2, [r3, #4]
                            sm_conn->sm_engine_state = SM_RESPONDER_SEND_SECURITY_REQUEST;
 802725e:	69fb      	ldr	r3, [r7, #28]
 8027260:	221b      	movs	r2, #27
 8027262:	731a      	strb	r2, [r3, #12]
                            sm_reencryption_started(sm_conn);
 8027264:	69f8      	ldr	r0, [r7, #28]
 8027266:	f7fa f964 	bl	8021532 <sm_reencryption_started>
                            break;
 802726a:	e014      	b.n	8027296 <sm_request_pairing+0xfa>
                        sm_conn->sm_pairing_requested = 1;
 802726c:	69fb      	ldr	r3, [r7, #28]
 802726e:	2201      	movs	r2, #1
 8027270:	711a      	strb	r2, [r3, #4]
                        sm_conn->sm_engine_state = SM_RESPONDER_SEND_SECURITY_REQUEST;
 8027272:	69fb      	ldr	r3, [r7, #28]
 8027274:	221b      	movs	r2, #27
 8027276:	731a      	strb	r2, [r3, #12]
                        sm_pairing_started(sm_conn);
 8027278:	69f8      	ldr	r0, [r7, #28]
 802727a:	f7fa f9cb 	bl	8021614 <sm_pairing_started>
                        break;
 802727e:	e00a      	b.n	8027296 <sm_request_pairing+0xfa>
                        log_info("irk lookup pending");
 8027280:	f241 1379 	movw	r3, #4473	; 0x1179
 8027284:	4a37      	ldr	r2, [pc, #220]	; (8027364 <sm_request_pairing+0x1c8>)
 8027286:	493a      	ldr	r1, [pc, #232]	; (8027370 <sm_request_pairing+0x1d4>)
 8027288:	2001      	movs	r0, #1
 802728a:	f7f0 f8d9 	bl	8017440 <hci_dump_log>
                        sm_conn->sm_pairing_requested = 1;
 802728e:	69fb      	ldr	r3, [r7, #28]
 8027290:	2201      	movs	r2, #1
 8027292:	711a      	strb	r2, [r3, #4]
                        break;
 8027294:	bf00      	nop
                break;
 8027296:	e05e      	b.n	8027356 <sm_request_pairing+0x1ba>
        }
    } else {
        // used as a trigger to start central/master/initiator security procedures
        switch (sm_conn->sm_engine_state){
 8027298:	69fb      	ldr	r3, [r7, #28]
 802729a:	7b1b      	ldrb	r3, [r3, #12]
 802729c:	2b03      	cmp	r3, #3
 802729e:	d052      	beq.n	8027346 <sm_request_pairing+0x1aa>
 80272a0:	2b29      	cmp	r3, #41	; 0x29
 80272a2:	d002      	beq.n	80272aa <sm_request_pairing+0x10e>
 80272a4:	2b00      	cmp	r3, #0
 80272a6:	d052      	beq.n	802734e <sm_request_pairing+0x1b2>
                break;
            case SM_GENERAL_IDLE:
                sm_conn->sm_pairing_requested = 1;
                break;
            default:
                break;
 80272a8:	e055      	b.n	8027356 <sm_request_pairing+0x1ba>
                switch (sm_conn->sm_irk_lookup_state){
 80272aa:	69fb      	ldr	r3, [r7, #28]
 80272ac:	7b5b      	ldrb	r3, [r3, #13]
 80272ae:	2b03      	cmp	r3, #3
 80272b0:	d002      	beq.n	80272b8 <sm_request_pairing+0x11c>
 80272b2:	2b04      	cmp	r3, #4
 80272b4:	d037      	beq.n	8027326 <sm_request_pairing+0x18a>
 80272b6:	e03a      	b.n	802732e <sm_request_pairing+0x192>
                        le_device_db_encryption_get(sm_conn->sm_le_db_index, NULL, NULL, ltk, NULL, NULL, NULL, NULL);
 80272b8:	69fb      	ldr	r3, [r7, #28]
 80272ba:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80272bc:	f107 0208 	add.w	r2, r7, #8
 80272c0:	2300      	movs	r3, #0
 80272c2:	9303      	str	r3, [sp, #12]
 80272c4:	2300      	movs	r3, #0
 80272c6:	9302      	str	r3, [sp, #8]
 80272c8:	2300      	movs	r3, #0
 80272ca:	9301      	str	r3, [sp, #4]
 80272cc:	2300      	movs	r3, #0
 80272ce:	9300      	str	r3, [sp, #0]
 80272d0:	4613      	mov	r3, r2
 80272d2:	2200      	movs	r2, #0
 80272d4:	2100      	movs	r1, #0
 80272d6:	f7f9 fd8f 	bl	8020df8 <le_device_db_encryption_get>
                        have_ltk = !sm_is_null_key(ltk);
 80272da:	f107 0308 	add.w	r3, r7, #8
 80272de:	4618      	mov	r0, r3
 80272e0:	f7f9 ff4e 	bl	8021180 <sm_is_null_key>
 80272e4:	4603      	mov	r3, r0
 80272e6:	2b00      	cmp	r3, #0
 80272e8:	bf14      	ite	ne
 80272ea:	2301      	movne	r3, #1
 80272ec:	2300      	moveq	r3, #0
 80272ee:	b2db      	uxtb	r3, r3
 80272f0:	f083 0301 	eor.w	r3, r3, #1
 80272f4:	b2db      	uxtb	r3, r3
 80272f6:	76fb      	strb	r3, [r7, #27]
 80272f8:	7efb      	ldrb	r3, [r7, #27]
 80272fa:	f003 0301 	and.w	r3, r3, #1
 80272fe:	76fb      	strb	r3, [r7, #27]
                        log_info("have ltk %u", have_ltk);
 8027300:	7efb      	ldrb	r3, [r7, #27]
 8027302:	9300      	str	r3, [sp, #0]
 8027304:	f241 1389 	movw	r3, #4489	; 0x1189
 8027308:	4a16      	ldr	r2, [pc, #88]	; (8027364 <sm_request_pairing+0x1c8>)
 802730a:	4918      	ldr	r1, [pc, #96]	; (802736c <sm_request_pairing+0x1d0>)
 802730c:	2001      	movs	r0, #1
 802730e:	f7f0 f897 	bl	8017440 <hci_dump_log>
                        if (have_ltk){
 8027312:	7efb      	ldrb	r3, [r7, #27]
 8027314:	2b00      	cmp	r3, #0
 8027316:	d006      	beq.n	8027326 <sm_request_pairing+0x18a>
                            sm_conn->sm_pairing_requested = 1;
 8027318:	69fb      	ldr	r3, [r7, #28]
 802731a:	2201      	movs	r2, #1
 802731c:	711a      	strb	r2, [r3, #4]
                            sm_conn->sm_engine_state = SM_INITIATOR_PH4_HAS_LTK;
 802731e:	69fb      	ldr	r3, [r7, #28]
 8027320:	222f      	movs	r2, #47	; 0x2f
 8027322:	731a      	strb	r2, [r3, #12]
                            break;
 8027324:	e00e      	b.n	8027344 <sm_request_pairing+0x1a8>
                        sm_conn->sm_engine_state = SM_INITIATOR_PH1_W2_SEND_PAIRING_REQUEST;
 8027326:	69fb      	ldr	r3, [r7, #28]
 8027328:	222a      	movs	r2, #42	; 0x2a
 802732a:	731a      	strb	r2, [r3, #12]
                        break;
 802732c:	e00a      	b.n	8027344 <sm_request_pairing+0x1a8>
                        log_info("irk lookup pending");
 802732e:	f241 1395 	movw	r3, #4501	; 0x1195
 8027332:	4a0c      	ldr	r2, [pc, #48]	; (8027364 <sm_request_pairing+0x1c8>)
 8027334:	490e      	ldr	r1, [pc, #56]	; (8027370 <sm_request_pairing+0x1d4>)
 8027336:	2001      	movs	r0, #1
 8027338:	f7f0 f882 	bl	8017440 <hci_dump_log>
                        sm_conn->sm_pairing_requested = 1;
 802733c:	69fb      	ldr	r3, [r7, #28]
 802733e:	2201      	movs	r2, #1
 8027340:	711a      	strb	r2, [r3, #4]
                        break;
 8027342:	bf00      	nop
                break;
 8027344:	e007      	b.n	8027356 <sm_request_pairing+0x1ba>
                sm_conn->sm_engine_state = SM_INITIATOR_PH1_W2_SEND_PAIRING_REQUEST;
 8027346:	69fb      	ldr	r3, [r7, #28]
 8027348:	222a      	movs	r2, #42	; 0x2a
 802734a:	731a      	strb	r2, [r3, #12]
                break;
 802734c:	e003      	b.n	8027356 <sm_request_pairing+0x1ba>
                sm_conn->sm_pairing_requested = 1;
 802734e:	69fb      	ldr	r3, [r7, #28]
 8027350:	2201      	movs	r2, #1
 8027352:	711a      	strb	r2, [r3, #4]
                break;
 8027354:	bf00      	nop
        }
    }
    sm_trigger_run();
 8027356:	f7f9 ff2b 	bl	80211b0 <sm_trigger_run>
 802735a:	e000      	b.n	802735e <sm_request_pairing+0x1c2>
    if (!sm_conn) return;     // wrong connection
 802735c:	bf00      	nop
}
 802735e:	3720      	adds	r7, #32
 8027360:	46bd      	mov	sp, r7
 8027362:	bd80      	pop	{r7, pc}
 8027364:	0802d4a8 	.word	0x0802d4a8
 8027368:	0802e4d0 	.word	0x0802e4d0
 802736c:	0802e500 	.word	0x0802e500
 8027370:	0802e514 	.word	0x0802e514

08027374 <sm_le_device_index>:
/**
 * @brief Identify device in LE Device DB
 * @param handle
 * @returns index from le_device_db or -1 if not found/identified
 */
int sm_le_device_index(hci_con_handle_t con_handle ){
 8027374:	b580      	push	{r7, lr}
 8027376:	b084      	sub	sp, #16
 8027378:	af00      	add	r7, sp, #0
 802737a:	4603      	mov	r3, r0
 802737c:	80fb      	strh	r3, [r7, #6]
    sm_connection_t * sm_conn = sm_get_connection_for_handle(con_handle);
 802737e:	88fb      	ldrh	r3, [r7, #6]
 8027380:	4618      	mov	r0, r3
 8027382:	f7ff fef5 	bl	8027170 <sm_get_connection_for_handle>
 8027386:	60f8      	str	r0, [r7, #12]
    if (!sm_conn) return -1;
 8027388:	68fb      	ldr	r3, [r7, #12]
 802738a:	2b00      	cmp	r3, #0
 802738c:	d102      	bne.n	8027394 <sm_le_device_index+0x20>
 802738e:	f04f 33ff 	mov.w	r3, #4294967295
 8027392:	e001      	b.n	8027398 <sm_le_device_index+0x24>
    return sm_conn->sm_le_db_index;
 8027394:	68fb      	ldr	r3, [r7, #12]
 8027396:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8027398:	4618      	mov	r0, r3
 802739a:	3710      	adds	r7, #16
 802739c:	46bd      	mov	sp, r7
 802739e:	bd80      	pop	{r7, pc}

080273a0 <gap_random_address_type_requires_updates>:

static int gap_random_address_type_requires_updates(void){
 80273a0:	b480      	push	{r7}
 80273a2:	af00      	add	r7, sp, #0
    switch (gap_random_adress_type){
 80273a4:	4b06      	ldr	r3, [pc, #24]	; (80273c0 <gap_random_address_type_requires_updates+0x20>)
 80273a6:	781b      	ldrb	r3, [r3, #0]
 80273a8:	3300      	adds	r3, #0
 80273aa:	2b01      	cmp	r3, #1
 80273ac:	d801      	bhi.n	80273b2 <gap_random_address_type_requires_updates+0x12>
        case GAP_RANDOM_ADDRESS_TYPE_OFF:
        case GAP_RANDOM_ADDRESS_TYPE_STATIC:
            return 0;
 80273ae:	2300      	movs	r3, #0
 80273b0:	e000      	b.n	80273b4 <gap_random_address_type_requires_updates+0x14>
        default:
            return 1;
 80273b2:	2301      	movs	r3, #1
    }
}
 80273b4:	4618      	mov	r0, r3
 80273b6:	46bd      	mov	sp, r7
 80273b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273bc:	4770      	bx	lr
 80273be:	bf00      	nop
 80273c0:	2000a364 	.word	0x2000a364

080273c4 <own_address_type>:

static uint8_t own_address_type(void){
 80273c4:	b480      	push	{r7}
 80273c6:	af00      	add	r7, sp, #0
    switch (gap_random_adress_type){
 80273c8:	4b05      	ldr	r3, [pc, #20]	; (80273e0 <own_address_type+0x1c>)
 80273ca:	781b      	ldrb	r3, [r3, #0]
 80273cc:	2b00      	cmp	r3, #0
 80273ce:	d101      	bne.n	80273d4 <own_address_type+0x10>
        case GAP_RANDOM_ADDRESS_TYPE_OFF:
            return BD_ADDR_TYPE_LE_PUBLIC;
 80273d0:	2300      	movs	r3, #0
 80273d2:	e000      	b.n	80273d6 <own_address_type+0x12>
        default:
            return BD_ADDR_TYPE_LE_RANDOM;
 80273d4:	2301      	movs	r3, #1
    }
}
 80273d6:	4618      	mov	r0, r3
 80273d8:	46bd      	mov	sp, r7
 80273da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273de:	4770      	bx	lr
 80273e0:	2000a364 	.word	0x2000a364

080273e4 <gap_random_address_set_mode>:

// GAP LE API
void gap_random_address_set_mode(gap_random_address_type_t random_address_type){
 80273e4:	b580      	push	{r7, lr}
 80273e6:	b082      	sub	sp, #8
 80273e8:	af00      	add	r7, sp, #0
 80273ea:	4603      	mov	r3, r0
 80273ec:	71fb      	strb	r3, [r7, #7]
    gap_random_address_update_stop();
 80273ee:	f7fa fa3d 	bl	802186c <gap_random_address_update_stop>
    gap_random_adress_type = random_address_type;
 80273f2:	4a0b      	ldr	r2, [pc, #44]	; (8027420 <gap_random_address_set_mode+0x3c>)
 80273f4:	79fb      	ldrb	r3, [r7, #7]
 80273f6:	7013      	strb	r3, [r2, #0]
    hci_le_set_own_address_type(own_address_type());
 80273f8:	f7ff ffe4 	bl	80273c4 <own_address_type>
 80273fc:	4603      	mov	r3, r0
 80273fe:	4618      	mov	r0, r3
 8027400:	f7ef fb20 	bl	8016a44 <hci_le_set_own_address_type>
    if (!gap_random_address_type_requires_updates()) return;
 8027404:	f7ff ffcc 	bl	80273a0 <gap_random_address_type_requires_updates>
 8027408:	4603      	mov	r3, r0
 802740a:	2b00      	cmp	r3, #0
 802740c:	d004      	beq.n	8027418 <gap_random_address_set_mode+0x34>
    gap_random_address_update_start();
 802740e:	f7fa fa15 	bl	802183c <gap_random_address_update_start>
    gap_random_address_trigger();
 8027412:	f7fa f9d1 	bl	80217b8 <gap_random_address_trigger>
 8027416:	e000      	b.n	802741a <gap_random_address_set_mode+0x36>
    if (!gap_random_address_type_requires_updates()) return;
 8027418:	bf00      	nop
}
 802741a:	3708      	adds	r7, #8
 802741c:	46bd      	mov	sp, r7
 802741e:	bd80      	pop	{r7, pc}
 8027420:	2000a364 	.word	0x2000a364

08027424 <gap_random_address_get_mode>:

gap_random_address_type_t gap_random_address_get_mode(void){
 8027424:	b480      	push	{r7}
 8027426:	af00      	add	r7, sp, #0
    return gap_random_adress_type;
 8027428:	4b03      	ldr	r3, [pc, #12]	; (8027438 <gap_random_address_get_mode+0x14>)
 802742a:	781b      	ldrb	r3, [r3, #0]
}
 802742c:	4618      	mov	r0, r3
 802742e:	46bd      	mov	sp, r7
 8027430:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027434:	4770      	bx	lr
 8027436:	bf00      	nop
 8027438:	2000a364 	.word	0x2000a364

0802743c <gap_advertisements_set_params>:
 * @param filter_policy
 *
 * @note own_address_type is used from gap_random_address_set_mode
 */
void gap_advertisements_set_params(uint16_t adv_int_min, uint16_t adv_int_max, uint8_t adv_type,
    uint8_t direct_address_typ, bd_addr_t direct_address, uint8_t channel_map, uint8_t filter_policy){
 802743c:	b590      	push	{r4, r7, lr}
 802743e:	b087      	sub	sp, #28
 8027440:	af04      	add	r7, sp, #16
 8027442:	4604      	mov	r4, r0
 8027444:	4608      	mov	r0, r1
 8027446:	4611      	mov	r1, r2
 8027448:	461a      	mov	r2, r3
 802744a:	4623      	mov	r3, r4
 802744c:	80fb      	strh	r3, [r7, #6]
 802744e:	4603      	mov	r3, r0
 8027450:	80bb      	strh	r3, [r7, #4]
 8027452:	460b      	mov	r3, r1
 8027454:	70fb      	strb	r3, [r7, #3]
 8027456:	4613      	mov	r3, r2
 8027458:	70bb      	strb	r3, [r7, #2]
    hci_le_advertisements_set_params(adv_int_min, adv_int_max, adv_type,
 802745a:	78bc      	ldrb	r4, [r7, #2]
 802745c:	78fa      	ldrb	r2, [r7, #3]
 802745e:	88b9      	ldrh	r1, [r7, #4]
 8027460:	88f8      	ldrh	r0, [r7, #6]
 8027462:	f897 3020 	ldrb.w	r3, [r7, #32]
 8027466:	9302      	str	r3, [sp, #8]
 8027468:	7f3b      	ldrb	r3, [r7, #28]
 802746a:	9301      	str	r3, [sp, #4]
 802746c:	69bb      	ldr	r3, [r7, #24]
 802746e:	9300      	str	r3, [sp, #0]
 8027470:	4623      	mov	r3, r4
 8027472:	f7ef fa85 	bl	8016980 <hci_le_advertisements_set_params>
        direct_address_typ, direct_address, channel_map, filter_policy);
}
 8027476:	bf00      	nop
 8027478:	370c      	adds	r7, #12
 802747a:	46bd      	mov	sp, r7
 802747c:	bd90      	pop	{r4, r7, pc}

0802747e <gap_reconnect_security_setup_active>:
#endif

int gap_reconnect_security_setup_active(hci_con_handle_t con_handle){
 802747e:	b580      	push	{r7, lr}
 8027480:	b084      	sub	sp, #16
 8027482:	af00      	add	r7, sp, #0
 8027484:	4603      	mov	r3, r0
 8027486:	80fb      	strh	r3, [r7, #6]
    sm_connection_t * sm_conn = sm_get_connection_for_handle(con_handle);
 8027488:	88fb      	ldrh	r3, [r7, #6]
 802748a:	4618      	mov	r0, r3
 802748c:	f7ff fe70 	bl	8027170 <sm_get_connection_for_handle>
 8027490:	60f8      	str	r0, [r7, #12]
     // wrong connection
    if (!sm_conn) return 0;
 8027492:	68fb      	ldr	r3, [r7, #12]
 8027494:	2b00      	cmp	r3, #0
 8027496:	d101      	bne.n	802749c <gap_reconnect_security_setup_active+0x1e>
 8027498:	2300      	movs	r3, #0
 802749a:	e029      	b.n	80274f0 <gap_reconnect_security_setup_active+0x72>
    // already encrypted
    if (sm_conn->sm_connection_encrypted) return 0;
 802749c:	68fb      	ldr	r3, [r7, #12]
 802749e:	7b9b      	ldrb	r3, [r3, #14]
 80274a0:	2b00      	cmp	r3, #0
 80274a2:	d001      	beq.n	80274a8 <gap_reconnect_security_setup_active+0x2a>
 80274a4:	2300      	movs	r3, #0
 80274a6:	e023      	b.n	80274f0 <gap_reconnect_security_setup_active+0x72>
    // irk status?
    switch(sm_conn->sm_irk_lookup_state){
 80274a8:	68fb      	ldr	r3, [r7, #12]
 80274aa:	7b5b      	ldrb	r3, [r3, #13]
 80274ac:	2b03      	cmp	r3, #3
 80274ae:	d005      	beq.n	80274bc <gap_reconnect_security_setup_active+0x3e>
 80274b0:	2b04      	cmp	r3, #4
 80274b2:	d101      	bne.n	80274b8 <gap_reconnect_security_setup_active+0x3a>
        case IRK_LOOKUP_FAILED:
            // done, cannot setup encryption
            return 0;
 80274b4:	2300      	movs	r3, #0
 80274b6:	e01b      	b.n	80274f0 <gap_reconnect_security_setup_active+0x72>
        case IRK_LOOKUP_SUCCEEDED:
            break;
        default:
            // IR Lookup pending
            return 1;
 80274b8:	2301      	movs	r3, #1
 80274ba:	e019      	b.n	80274f0 <gap_reconnect_security_setup_active+0x72>
            break;
 80274bc:	bf00      	nop
    }
    // IRK Lookup Succeeded, re-encryption should be initiated. When done, state gets reset or indicates failure
    if (sm_conn->sm_engine_state == SM_GENERAL_REENCRYPTION_FAILED) return 0;
 80274be:	68fb      	ldr	r3, [r7, #12]
 80274c0:	7b1b      	ldrb	r3, [r3, #12]
 80274c2:	2b03      	cmp	r3, #3
 80274c4:	d101      	bne.n	80274ca <gap_reconnect_security_setup_active+0x4c>
 80274c6:	2300      	movs	r3, #0
 80274c8:	e012      	b.n	80274f0 <gap_reconnect_security_setup_active+0x72>
    if (sm_conn->sm_role){
 80274ca:	68fb      	ldr	r3, [r7, #12]
 80274cc:	789b      	ldrb	r3, [r3, #2]
 80274ce:	2b00      	cmp	r3, #0
 80274d0:	d007      	beq.n	80274e2 <gap_reconnect_security_setup_active+0x64>
        return sm_conn->sm_engine_state != SM_RESPONDER_IDLE;
 80274d2:	68fb      	ldr	r3, [r7, #12]
 80274d4:	7b1b      	ldrb	r3, [r3, #12]
 80274d6:	2b1a      	cmp	r3, #26
 80274d8:	bf14      	ite	ne
 80274da:	2301      	movne	r3, #1
 80274dc:	2300      	moveq	r3, #0
 80274de:	b2db      	uxtb	r3, r3
 80274e0:	e006      	b.n	80274f0 <gap_reconnect_security_setup_active+0x72>
    } else {
        return sm_conn->sm_engine_state != SM_INITIATOR_CONNECTED;
 80274e2:	68fb      	ldr	r3, [r7, #12]
 80274e4:	7b1b      	ldrb	r3, [r3, #12]
 80274e6:	2b29      	cmp	r3, #41	; 0x29
 80274e8:	bf14      	ite	ne
 80274ea:	2301      	movne	r3, #1
 80274ec:	2300      	moveq	r3, #0
 80274ee:	b2db      	uxtb	r3, r3
    }
}
 80274f0:	4618      	mov	r0, r3
 80274f2:	3710      	adds	r7, #16
 80274f4:	46bd      	mov	sp, r7
 80274f6:	bd80      	pop	{r7, pc}

080274f8 <btstack_link_key_db_tag_for_index>:

static const char tag_0 = 'B';
static const char tag_1 = 'T';
static const char tag_2 = 'L';

static uint32_t btstack_link_key_db_tag_for_index(uint8_t index){
 80274f8:	b480      	push	{r7}
 80274fa:	b083      	sub	sp, #12
 80274fc:	af00      	add	r7, sp, #0
 80274fe:	4603      	mov	r3, r0
 8027500:	71fb      	strb	r3, [r7, #7]
    return (tag_0 << 24) | (tag_1 << 16) | (tag_2 << 8) | index;
 8027502:	2342      	movs	r3, #66	; 0x42
 8027504:	061a      	lsls	r2, r3, #24
 8027506:	2354      	movs	r3, #84	; 0x54
 8027508:	041b      	lsls	r3, r3, #16
 802750a:	431a      	orrs	r2, r3
 802750c:	234c      	movs	r3, #76	; 0x4c
 802750e:	021b      	lsls	r3, r3, #8
 8027510:	431a      	orrs	r2, r3
 8027512:	79fb      	ldrb	r3, [r7, #7]
 8027514:	4313      	orrs	r3, r2
}
 8027516:	4618      	mov	r0, r3
 8027518:	370c      	adds	r7, #12
 802751a:	46bd      	mov	sp, r7
 802751c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027520:	4770      	bx	lr

08027522 <btstack_link_key_db_tlv_open>:

// Device info
static void btstack_link_key_db_tlv_open(void){
 8027522:	b480      	push	{r7}
 8027524:	af00      	add	r7, sp, #0
}
 8027526:	bf00      	nop
 8027528:	46bd      	mov	sp, r7
 802752a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802752e:	4770      	bx	lr

08027530 <btstack_link_key_db_tlv_set_bd_addr>:

static void btstack_link_key_db_tlv_set_bd_addr(bd_addr_t bd_addr){
 8027530:	b480      	push	{r7}
 8027532:	b083      	sub	sp, #12
 8027534:	af00      	add	r7, sp, #0
 8027536:	6078      	str	r0, [r7, #4]
    (void)bd_addr;
}
 8027538:	bf00      	nop
 802753a:	370c      	adds	r7, #12
 802753c:	46bd      	mov	sp, r7
 802753e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027542:	4770      	bx	lr

08027544 <btstack_link_key_db_tlv_close>:

static void btstack_link_key_db_tlv_close(void){ 
 8027544:	b480      	push	{r7}
 8027546:	af00      	add	r7, sp, #0
}
 8027548:	bf00      	nop
 802754a:	46bd      	mov	sp, r7
 802754c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027550:	4770      	bx	lr
	...

08027554 <btstack_link_key_db_tlv_get_link_key>:

static int btstack_link_key_db_tlv_get_link_key(bd_addr_t bd_addr, link_key_t link_key, link_key_type_t * link_key_type) {
 8027554:	b590      	push	{r4, r7, lr}
 8027556:	b091      	sub	sp, #68	; 0x44
 8027558:	af02      	add	r7, sp, #8
 802755a:	60f8      	str	r0, [r7, #12]
 802755c:	60b9      	str	r1, [r7, #8]
 802755e:	607a      	str	r2, [r7, #4]
    int i;
    for (i=0;i<NVM_NUM_LINK_KEYS;i++){
 8027560:	2300      	movs	r3, #0
 8027562:	637b      	str	r3, [r7, #52]	; 0x34
 8027564:	e048      	b.n	80275f8 <btstack_link_key_db_tlv_get_link_key+0xa4>
        link_key_nvm_t entry;
        uint32_t tag = btstack_link_key_db_tag_for_index(i);
 8027566:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8027568:	b2db      	uxtb	r3, r3
 802756a:	4618      	mov	r0, r3
 802756c:	f7ff ffc4 	bl	80274f8 <btstack_link_key_db_tag_for_index>
 8027570:	6338      	str	r0, [r7, #48]	; 0x30
        int size = self->btstack_tlv_impl->get_tag(self->btstack_tlv_context, tag, (uint8_t*) &entry, sizeof(entry));
 8027572:	4b25      	ldr	r3, [pc, #148]	; (8027608 <btstack_link_key_db_tlv_get_link_key+0xb4>)
 8027574:	681b      	ldr	r3, [r3, #0]
 8027576:	681b      	ldr	r3, [r3, #0]
 8027578:	681c      	ldr	r4, [r3, #0]
 802757a:	4b23      	ldr	r3, [pc, #140]	; (8027608 <btstack_link_key_db_tlv_get_link_key+0xb4>)
 802757c:	681b      	ldr	r3, [r3, #0]
 802757e:	6858      	ldr	r0, [r3, #4]
 8027580:	f107 0210 	add.w	r2, r7, #16
 8027584:	231c      	movs	r3, #28
 8027586:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8027588:	47a0      	blx	r4
 802758a:	62f8      	str	r0, [r7, #44]	; 0x2c
        if (size == 0) continue;
 802758c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802758e:	2b00      	cmp	r3, #0
 8027590:	d02c      	beq.n	80275ec <btstack_link_key_db_tlv_get_link_key+0x98>
        log_info("tag %x, addr %s", (unsigned int) tag, bd_addr_to_str(entry.bd_addr));
 8027592:	f107 0310 	add.w	r3, r7, #16
 8027596:	3304      	adds	r3, #4
 8027598:	4618      	mov	r0, r3
 802759a:	f7e7 ff39 	bl	800f410 <bd_addr_to_str>
 802759e:	4603      	mov	r3, r0
 80275a0:	9301      	str	r3, [sp, #4]
 80275a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80275a4:	9300      	str	r3, [sp, #0]
 80275a6:	235f      	movs	r3, #95	; 0x5f
 80275a8:	4a18      	ldr	r2, [pc, #96]	; (802760c <btstack_link_key_db_tlv_get_link_key+0xb8>)
 80275aa:	4919      	ldr	r1, [pc, #100]	; (8027610 <btstack_link_key_db_tlv_get_link_key+0xbc>)
 80275ac:	2001      	movs	r0, #1
 80275ae:	f7ef ff47 	bl	8017440 <hci_dump_log>
        if (memcmp(bd_addr, entry.bd_addr, 6)) continue;
 80275b2:	f107 0310 	add.w	r3, r7, #16
 80275b6:	3304      	adds	r3, #4
 80275b8:	2206      	movs	r2, #6
 80275ba:	4619      	mov	r1, r3
 80275bc:	68f8      	ldr	r0, [r7, #12]
 80275be:	f000 fa4d 	bl	8027a5c <memcmp>
 80275c2:	4603      	mov	r3, r0
 80275c4:	2b00      	cmp	r3, #0
 80275c6:	d113      	bne.n	80275f0 <btstack_link_key_db_tlv_get_link_key+0x9c>
        // found, pass back
        (void)memcpy(link_key, entry.link_key, 16);
 80275c8:	68bb      	ldr	r3, [r7, #8]
 80275ca:	461a      	mov	r2, r3
 80275cc:	f107 031a 	add.w	r3, r7, #26
 80275d0:	681c      	ldr	r4, [r3, #0]
 80275d2:	6858      	ldr	r0, [r3, #4]
 80275d4:	6899      	ldr	r1, [r3, #8]
 80275d6:	68db      	ldr	r3, [r3, #12]
 80275d8:	6014      	str	r4, [r2, #0]
 80275da:	6050      	str	r0, [r2, #4]
 80275dc:	6091      	str	r1, [r2, #8]
 80275de:	60d3      	str	r3, [r2, #12]
        *link_key_type = entry.link_key_type;
 80275e0:	f897 202a 	ldrb.w	r2, [r7, #42]	; 0x2a
 80275e4:	687b      	ldr	r3, [r7, #4]
 80275e6:	701a      	strb	r2, [r3, #0]
        return 1;
 80275e8:	2301      	movs	r3, #1
 80275ea:	e009      	b.n	8027600 <btstack_link_key_db_tlv_get_link_key+0xac>
        if (size == 0) continue;
 80275ec:	bf00      	nop
 80275ee:	e000      	b.n	80275f2 <btstack_link_key_db_tlv_get_link_key+0x9e>
        if (memcmp(bd_addr, entry.bd_addr, 6)) continue;
 80275f0:	bf00      	nop
    for (i=0;i<NVM_NUM_LINK_KEYS;i++){
 80275f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80275f4:	3301      	adds	r3, #1
 80275f6:	637b      	str	r3, [r7, #52]	; 0x34
 80275f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80275fa:	2b0f      	cmp	r3, #15
 80275fc:	ddb3      	ble.n	8027566 <btstack_link_key_db_tlv_get_link_key+0x12>
    }
	return 0;
 80275fe:	2300      	movs	r3, #0
}
 8027600:	4618      	mov	r0, r3
 8027602:	373c      	adds	r7, #60	; 0x3c
 8027604:	46bd      	mov	sp, r7
 8027606:	bd90      	pop	{r4, r7, pc}
 8027608:	200000a8 	.word	0x200000a8
 802760c:	0802e54c 	.word	0x0802e54c
 8027610:	0802e568 	.word	0x0802e568

08027614 <btstack_link_key_db_tlv_delete_link_key>:

static void btstack_link_key_db_tlv_delete_link_key(bd_addr_t bd_addr){
 8027614:	b590      	push	{r4, r7, lr}
 8027616:	b08d      	sub	sp, #52	; 0x34
 8027618:	af00      	add	r7, sp, #0
 802761a:	6078      	str	r0, [r7, #4]
    int i;
    for (i=0;i<NVM_NUM_LINK_KEYS;i++){
 802761c:	2300      	movs	r3, #0
 802761e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8027620:	e031      	b.n	8027686 <btstack_link_key_db_tlv_delete_link_key+0x72>
        link_key_nvm_t entry;
        uint32_t tag = btstack_link_key_db_tag_for_index(i);
 8027622:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8027624:	b2db      	uxtb	r3, r3
 8027626:	4618      	mov	r0, r3
 8027628:	f7ff ff66 	bl	80274f8 <btstack_link_key_db_tag_for_index>
 802762c:	62b8      	str	r0, [r7, #40]	; 0x28
        int size = self->btstack_tlv_impl->get_tag(self->btstack_tlv_context, tag, (uint8_t*) &entry, sizeof(entry));
 802762e:	4b19      	ldr	r3, [pc, #100]	; (8027694 <btstack_link_key_db_tlv_delete_link_key+0x80>)
 8027630:	681b      	ldr	r3, [r3, #0]
 8027632:	681b      	ldr	r3, [r3, #0]
 8027634:	681c      	ldr	r4, [r3, #0]
 8027636:	4b17      	ldr	r3, [pc, #92]	; (8027694 <btstack_link_key_db_tlv_delete_link_key+0x80>)
 8027638:	681b      	ldr	r3, [r3, #0]
 802763a:	6858      	ldr	r0, [r3, #4]
 802763c:	f107 0208 	add.w	r2, r7, #8
 8027640:	231c      	movs	r3, #28
 8027642:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8027644:	47a0      	blx	r4
 8027646:	6278      	str	r0, [r7, #36]	; 0x24
        if (size == 0) continue;
 8027648:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802764a:	2b00      	cmp	r3, #0
 802764c:	d015      	beq.n	802767a <btstack_link_key_db_tlv_delete_link_key+0x66>
        if (memcmp(bd_addr, entry.bd_addr, 6)) continue;
 802764e:	f107 0308 	add.w	r3, r7, #8
 8027652:	3304      	adds	r3, #4
 8027654:	2206      	movs	r2, #6
 8027656:	4619      	mov	r1, r3
 8027658:	6878      	ldr	r0, [r7, #4]
 802765a:	f000 f9ff 	bl	8027a5c <memcmp>
 802765e:	4603      	mov	r3, r0
 8027660:	2b00      	cmp	r3, #0
 8027662:	d10c      	bne.n	802767e <btstack_link_key_db_tlv_delete_link_key+0x6a>
        // found, delete tag
        self->btstack_tlv_impl->delete_tag(self->btstack_tlv_context, tag);
 8027664:	4b0b      	ldr	r3, [pc, #44]	; (8027694 <btstack_link_key_db_tlv_delete_link_key+0x80>)
 8027666:	681b      	ldr	r3, [r3, #0]
 8027668:	681b      	ldr	r3, [r3, #0]
 802766a:	689b      	ldr	r3, [r3, #8]
 802766c:	4a09      	ldr	r2, [pc, #36]	; (8027694 <btstack_link_key_db_tlv_delete_link_key+0x80>)
 802766e:	6812      	ldr	r2, [r2, #0]
 8027670:	6852      	ldr	r2, [r2, #4]
 8027672:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8027674:	4610      	mov	r0, r2
 8027676:	4798      	blx	r3
        break;
    }
}
 8027678:	e008      	b.n	802768c <btstack_link_key_db_tlv_delete_link_key+0x78>
        if (size == 0) continue;
 802767a:	bf00      	nop
 802767c:	e000      	b.n	8027680 <btstack_link_key_db_tlv_delete_link_key+0x6c>
        if (memcmp(bd_addr, entry.bd_addr, 6)) continue;
 802767e:	bf00      	nop
    for (i=0;i<NVM_NUM_LINK_KEYS;i++){
 8027680:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8027682:	3301      	adds	r3, #1
 8027684:	62fb      	str	r3, [r7, #44]	; 0x2c
 8027686:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8027688:	2b0f      	cmp	r3, #15
 802768a:	ddca      	ble.n	8027622 <btstack_link_key_db_tlv_delete_link_key+0xe>
}
 802768c:	bf00      	nop
 802768e:	3734      	adds	r7, #52	; 0x34
 8027690:	46bd      	mov	sp, r7
 8027692:	bd90      	pop	{r4, r7, pc}
 8027694:	200000a8 	.word	0x200000a8

08027698 <btstack_link_key_db_tlv_put_link_key>:

static void btstack_link_key_db_tlv_put_link_key(bd_addr_t bd_addr, link_key_t link_key, link_key_type_t link_key_type){
 8027698:	b590      	push	{r4, r7, lr}
 802769a:	b0a1      	sub	sp, #132	; 0x84
 802769c:	af04      	add	r7, sp, #16
 802769e:	60f8      	str	r0, [r7, #12]
 80276a0:	60b9      	str	r1, [r7, #8]
 80276a2:	4613      	mov	r3, r2
 80276a4:	71fb      	strb	r3, [r7, #7]
    int i;
    uint32_t highest_seq_nr = 0;
 80276a6:	2300      	movs	r3, #0
 80276a8:	66bb      	str	r3, [r7, #104]	; 0x68
    uint32_t lowest_seq_nr = 0;
 80276aa:	2300      	movs	r3, #0
 80276ac:	667b      	str	r3, [r7, #100]	; 0x64
    uint32_t tag_for_lowest_seq_nr = 0;
 80276ae:	2300      	movs	r3, #0
 80276b0:	663b      	str	r3, [r7, #96]	; 0x60
    uint32_t tag_for_addr = 0;
 80276b2:	2300      	movs	r3, #0
 80276b4:	65fb      	str	r3, [r7, #92]	; 0x5c
    uint32_t tag_for_empty = 0;
 80276b6:	2300      	movs	r3, #0
 80276b8:	65bb      	str	r3, [r7, #88]	; 0x58

    for (i=0;i<NVM_NUM_LINK_KEYS;i++){
 80276ba:	2300      	movs	r3, #0
 80276bc:	66fb      	str	r3, [r7, #108]	; 0x6c
 80276be:	e039      	b.n	8027734 <btstack_link_key_db_tlv_put_link_key+0x9c>
        link_key_nvm_t entry;
        uint32_t tag = btstack_link_key_db_tag_for_index(i);
 80276c0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80276c2:	b2db      	uxtb	r3, r3
 80276c4:	4618      	mov	r0, r3
 80276c6:	f7ff ff17 	bl	80274f8 <btstack_link_key_db_tag_for_index>
 80276ca:	64f8      	str	r0, [r7, #76]	; 0x4c
        int size = self->btstack_tlv_impl->get_tag(self->btstack_tlv_context, tag, (uint8_t*) &entry, sizeof(entry));
 80276cc:	4b48      	ldr	r3, [pc, #288]	; (80277f0 <btstack_link_key_db_tlv_put_link_key+0x158>)
 80276ce:	681b      	ldr	r3, [r3, #0]
 80276d0:	681b      	ldr	r3, [r3, #0]
 80276d2:	681c      	ldr	r4, [r3, #0]
 80276d4:	4b46      	ldr	r3, [pc, #280]	; (80277f0 <btstack_link_key_db_tlv_put_link_key+0x158>)
 80276d6:	681b      	ldr	r3, [r3, #0]
 80276d8:	6858      	ldr	r0, [r3, #4]
 80276da:	f107 0210 	add.w	r2, r7, #16
 80276de:	231c      	movs	r3, #28
 80276e0:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80276e2:	47a0      	blx	r4
 80276e4:	64b8      	str	r0, [r7, #72]	; 0x48
        // empty/deleted tag
        if (size == 0) {
 80276e6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80276e8:	2b00      	cmp	r3, #0
 80276ea:	d102      	bne.n	80276f2 <btstack_link_key_db_tlv_put_link_key+0x5a>
            tag_for_empty = tag;
 80276ec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80276ee:	65bb      	str	r3, [r7, #88]	; 0x58
 80276f0:	e01d      	b.n	802772e <btstack_link_key_db_tlv_put_link_key+0x96>
            continue;
        }
        // found addr?
        if (memcmp(bd_addr, entry.bd_addr, 6) == 0){
 80276f2:	f107 0310 	add.w	r3, r7, #16
 80276f6:	3304      	adds	r3, #4
 80276f8:	2206      	movs	r2, #6
 80276fa:	4619      	mov	r1, r3
 80276fc:	68f8      	ldr	r0, [r7, #12]
 80276fe:	f000 f9ad 	bl	8027a5c <memcmp>
 8027702:	4603      	mov	r3, r0
 8027704:	2b00      	cmp	r3, #0
 8027706:	d101      	bne.n	802770c <btstack_link_key_db_tlv_put_link_key+0x74>
            tag_for_addr = tag;
 8027708:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802770a:	65fb      	str	r3, [r7, #92]	; 0x5c
        }
        // update highest seq nr
        if (entry.seq_nr > highest_seq_nr){
 802770c:	693b      	ldr	r3, [r7, #16]
 802770e:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8027710:	429a      	cmp	r2, r3
 8027712:	d201      	bcs.n	8027718 <btstack_link_key_db_tlv_put_link_key+0x80>
            highest_seq_nr = entry.seq_nr;
 8027714:	693b      	ldr	r3, [r7, #16]
 8027716:	66bb      	str	r3, [r7, #104]	; 0x68
        }
        // find entry with lowest seq nr
        if ((tag_for_lowest_seq_nr == 0) || (entry.seq_nr < lowest_seq_nr)){
 8027718:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 802771a:	2b00      	cmp	r3, #0
 802771c:	d003      	beq.n	8027726 <btstack_link_key_db_tlv_put_link_key+0x8e>
 802771e:	693b      	ldr	r3, [r7, #16]
 8027720:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8027722:	429a      	cmp	r2, r3
 8027724:	d903      	bls.n	802772e <btstack_link_key_db_tlv_put_link_key+0x96>
            tag_for_lowest_seq_nr = tag;
 8027726:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8027728:	663b      	str	r3, [r7, #96]	; 0x60
            lowest_seq_nr = entry.seq_nr;
 802772a:	693b      	ldr	r3, [r7, #16]
 802772c:	667b      	str	r3, [r7, #100]	; 0x64
    for (i=0;i<NVM_NUM_LINK_KEYS;i++){
 802772e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8027730:	3301      	adds	r3, #1
 8027732:	66fb      	str	r3, [r7, #108]	; 0x6c
 8027734:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8027736:	2b0f      	cmp	r3, #15
 8027738:	ddc2      	ble.n	80276c0 <btstack_link_key_db_tlv_put_link_key+0x28>
        }
    }

    log_info("tag_for_addr %x, tag_for_empy %x, tag_for_lowest_seq_nr %x",
 802773a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 802773c:	9302      	str	r3, [sp, #8]
 802773e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8027740:	9301      	str	r3, [sp, #4]
 8027742:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8027744:	9300      	str	r3, [sp, #0]
 8027746:	2398      	movs	r3, #152	; 0x98
 8027748:	4a2a      	ldr	r2, [pc, #168]	; (80277f4 <btstack_link_key_db_tlv_put_link_key+0x15c>)
 802774a:	492b      	ldr	r1, [pc, #172]	; (80277f8 <btstack_link_key_db_tlv_put_link_key+0x160>)
 802774c:	2001      	movs	r0, #1
 802774e:	f7ef fe77 	bl	8017440 <hci_dump_log>
             (unsigned int) tag_for_addr, (unsigned int) tag_for_empty, (unsigned int) tag_for_lowest_seq_nr);

    uint32_t tag_to_use = 0;
 8027752:	2300      	movs	r3, #0
 8027754:	657b      	str	r3, [r7, #84]	; 0x54
    if (tag_for_addr){
 8027756:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8027758:	2b00      	cmp	r3, #0
 802775a:	d002      	beq.n	8027762 <btstack_link_key_db_tlv_put_link_key+0xca>
        tag_to_use = tag_for_addr;
 802775c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 802775e:	657b      	str	r3, [r7, #84]	; 0x54
 8027760:	e00a      	b.n	8027778 <btstack_link_key_db_tlv_put_link_key+0xe0>
    } else if (tag_for_empty){
 8027762:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8027764:	2b00      	cmp	r3, #0
 8027766:	d002      	beq.n	802776e <btstack_link_key_db_tlv_put_link_key+0xd6>
        tag_to_use = tag_for_empty;
 8027768:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 802776a:	657b      	str	r3, [r7, #84]	; 0x54
 802776c:	e004      	b.n	8027778 <btstack_link_key_db_tlv_put_link_key+0xe0>
    } else if (tag_for_lowest_seq_nr){
 802776e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8027770:	2b00      	cmp	r3, #0
 8027772:	d038      	beq.n	80277e6 <btstack_link_key_db_tlv_put_link_key+0x14e>
        tag_to_use = tag_for_lowest_seq_nr;
 8027774:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8027776:	657b      	str	r3, [r7, #84]	; 0x54
    } else {
        // should not happen
        return;
    }

    log_info("store with tag %x", (unsigned int) tag_to_use);
 8027778:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 802777a:	9300      	str	r3, [sp, #0]
 802777c:	23a6      	movs	r3, #166	; 0xa6
 802777e:	4a1d      	ldr	r2, [pc, #116]	; (80277f4 <btstack_link_key_db_tlv_put_link_key+0x15c>)
 8027780:	491e      	ldr	r1, [pc, #120]	; (80277fc <btstack_link_key_db_tlv_put_link_key+0x164>)
 8027782:	2001      	movs	r0, #1
 8027784:	f7ef fe5c 	bl	8017440 <hci_dump_log>

    link_key_nvm_t entry;
    
    (void)memcpy(entry.bd_addr, bd_addr, 6);
 8027788:	68fa      	ldr	r2, [r7, #12]
 802778a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 802778e:	6810      	ldr	r0, [r2, #0]
 8027790:	6018      	str	r0, [r3, #0]
 8027792:	8892      	ldrh	r2, [r2, #4]
 8027794:	809a      	strh	r2, [r3, #4]
    (void)memcpy(entry.link_key, link_key, 16);
 8027796:	68ba      	ldr	r2, [r7, #8]
 8027798:	f107 0336 	add.w	r3, r7, #54	; 0x36
 802779c:	6814      	ldr	r4, [r2, #0]
 802779e:	6850      	ldr	r0, [r2, #4]
 80277a0:	6891      	ldr	r1, [r2, #8]
 80277a2:	68d2      	ldr	r2, [r2, #12]
 80277a4:	601c      	str	r4, [r3, #0]
 80277a6:	6058      	str	r0, [r3, #4]
 80277a8:	6099      	str	r1, [r3, #8]
 80277aa:	60da      	str	r2, [r3, #12]
    entry.link_key_type = link_key_type;
 80277ac:	79fb      	ldrb	r3, [r7, #7]
 80277ae:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
    entry.seq_nr = highest_seq_nr + 1;
 80277b2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80277b4:	3301      	adds	r3, #1
 80277b6:	62fb      	str	r3, [r7, #44]	; 0x2c

    int result = self->btstack_tlv_impl->store_tag(self->btstack_tlv_context, tag_to_use, (uint8_t*) &entry, sizeof(entry));
 80277b8:	4b0d      	ldr	r3, [pc, #52]	; (80277f0 <btstack_link_key_db_tlv_put_link_key+0x158>)
 80277ba:	681b      	ldr	r3, [r3, #0]
 80277bc:	681b      	ldr	r3, [r3, #0]
 80277be:	685c      	ldr	r4, [r3, #4]
 80277c0:	4b0b      	ldr	r3, [pc, #44]	; (80277f0 <btstack_link_key_db_tlv_put_link_key+0x158>)
 80277c2:	681b      	ldr	r3, [r3, #0]
 80277c4:	6858      	ldr	r0, [r3, #4]
 80277c6:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 80277ca:	231c      	movs	r3, #28
 80277cc:	6d79      	ldr	r1, [r7, #84]	; 0x54
 80277ce:	47a0      	blx	r4
 80277d0:	6538      	str	r0, [r7, #80]	; 0x50
    if (result != 0){
 80277d2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80277d4:	2b00      	cmp	r3, #0
 80277d6:	d007      	beq.n	80277e8 <btstack_link_key_db_tlv_put_link_key+0x150>
        log_error("store link key failed");
 80277d8:	23b1      	movs	r3, #177	; 0xb1
 80277da:	4a06      	ldr	r2, [pc, #24]	; (80277f4 <btstack_link_key_db_tlv_put_link_key+0x15c>)
 80277dc:	4908      	ldr	r1, [pc, #32]	; (8027800 <btstack_link_key_db_tlv_put_link_key+0x168>)
 80277de:	2002      	movs	r0, #2
 80277e0:	f7ef fe2e 	bl	8017440 <hci_dump_log>
 80277e4:	e000      	b.n	80277e8 <btstack_link_key_db_tlv_put_link_key+0x150>
        return;
 80277e6:	bf00      	nop
    }
}
 80277e8:	3774      	adds	r7, #116	; 0x74
 80277ea:	46bd      	mov	sp, r7
 80277ec:	bd90      	pop	{r4, r7, pc}
 80277ee:	bf00      	nop
 80277f0:	200000a8 	.word	0x200000a8
 80277f4:	0802e54c 	.word	0x0802e54c
 80277f8:	0802e580 	.word	0x0802e580
 80277fc:	0802e5c4 	.word	0x0802e5c4
 8027800:	0802e5e0 	.word	0x0802e5e0

08027804 <btstack_link_key_db_tlv_iterator_init>:

static int btstack_link_key_db_tlv_iterator_init(btstack_link_key_iterator_t * it){
 8027804:	b480      	push	{r7}
 8027806:	b083      	sub	sp, #12
 8027808:	af00      	add	r7, sp, #0
 802780a:	6078      	str	r0, [r7, #4]
    it->context = (void*) 0;
 802780c:	687b      	ldr	r3, [r7, #4]
 802780e:	2200      	movs	r2, #0
 8027810:	601a      	str	r2, [r3, #0]
    return 1;
 8027812:	2301      	movs	r3, #1
}
 8027814:	4618      	mov	r0, r3
 8027816:	370c      	adds	r7, #12
 8027818:	46bd      	mov	sp, r7
 802781a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802781e:	4770      	bx	lr

08027820 <btstack_link_key_db_tlv_iterator_get_next>:

static int  btstack_link_key_db_tlv_iterator_get_next(btstack_link_key_iterator_t * it, bd_addr_t bd_addr, link_key_t link_key, link_key_type_t * link_key_type){
 8027820:	b590      	push	{r4, r7, lr}
 8027822:	b091      	sub	sp, #68	; 0x44
 8027824:	af00      	add	r7, sp, #0
 8027826:	60f8      	str	r0, [r7, #12]
 8027828:	60b9      	str	r1, [r7, #8]
 802782a:	607a      	str	r2, [r7, #4]
 802782c:	603b      	str	r3, [r7, #0]
    uintptr_t i = (uintptr_t) it->context;
 802782e:	68fb      	ldr	r3, [r7, #12]
 8027830:	681b      	ldr	r3, [r3, #0]
 8027832:	63fb      	str	r3, [r7, #60]	; 0x3c
    int found = 0;
 8027834:	2300      	movs	r3, #0
 8027836:	63bb      	str	r3, [r7, #56]	; 0x38
    while (i<NVM_NUM_LINK_KEYS){
 8027838:	e033      	b.n	80278a2 <btstack_link_key_db_tlv_iterator_get_next+0x82>
        link_key_nvm_t entry;
        uint32_t tag = btstack_link_key_db_tag_for_index(i++);
 802783a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802783c:	1c5a      	adds	r2, r3, #1
 802783e:	63fa      	str	r2, [r7, #60]	; 0x3c
 8027840:	b2db      	uxtb	r3, r3
 8027842:	4618      	mov	r0, r3
 8027844:	f7ff fe58 	bl	80274f8 <btstack_link_key_db_tag_for_index>
 8027848:	6378      	str	r0, [r7, #52]	; 0x34
        int size = self->btstack_tlv_impl->get_tag(self->btstack_tlv_context, tag, (uint8_t*) &entry, sizeof(entry));
 802784a:	4b1b      	ldr	r3, [pc, #108]	; (80278b8 <btstack_link_key_db_tlv_iterator_get_next+0x98>)
 802784c:	681b      	ldr	r3, [r3, #0]
 802784e:	681b      	ldr	r3, [r3, #0]
 8027850:	681c      	ldr	r4, [r3, #0]
 8027852:	4b19      	ldr	r3, [pc, #100]	; (80278b8 <btstack_link_key_db_tlv_iterator_get_next+0x98>)
 8027854:	681b      	ldr	r3, [r3, #0]
 8027856:	6858      	ldr	r0, [r3, #4]
 8027858:	f107 0214 	add.w	r2, r7, #20
 802785c:	231c      	movs	r3, #28
 802785e:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8027860:	47a0      	blx	r4
 8027862:	6338      	str	r0, [r7, #48]	; 0x30
        if (size == 0) continue;
 8027864:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8027866:	2b00      	cmp	r3, #0
 8027868:	d100      	bne.n	802786c <btstack_link_key_db_tlv_iterator_get_next+0x4c>
 802786a:	e01a      	b.n	80278a2 <btstack_link_key_db_tlv_iterator_get_next+0x82>
        (void)memcpy(bd_addr, entry.bd_addr, 6);
 802786c:	68bb      	ldr	r3, [r7, #8]
 802786e:	461a      	mov	r2, r3
 8027870:	f107 0318 	add.w	r3, r7, #24
 8027874:	6818      	ldr	r0, [r3, #0]
 8027876:	6010      	str	r0, [r2, #0]
 8027878:	889b      	ldrh	r3, [r3, #4]
 802787a:	8093      	strh	r3, [r2, #4]
        (void)memcpy(link_key, entry.link_key, 16);
 802787c:	687b      	ldr	r3, [r7, #4]
 802787e:	461a      	mov	r2, r3
 8027880:	f107 031e 	add.w	r3, r7, #30
 8027884:	681c      	ldr	r4, [r3, #0]
 8027886:	6858      	ldr	r0, [r3, #4]
 8027888:	6899      	ldr	r1, [r3, #8]
 802788a:	68db      	ldr	r3, [r3, #12]
 802788c:	6014      	str	r4, [r2, #0]
 802788e:	6050      	str	r0, [r2, #4]
 8027890:	6091      	str	r1, [r2, #8]
 8027892:	60d3      	str	r3, [r2, #12]
        *link_key_type = entry.link_key_type;
 8027894:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 8027898:	683b      	ldr	r3, [r7, #0]
 802789a:	701a      	strb	r2, [r3, #0]
        found = 1;
 802789c:	2301      	movs	r3, #1
 802789e:	63bb      	str	r3, [r7, #56]	; 0x38
 80278a0:	e002      	b.n	80278a8 <btstack_link_key_db_tlv_iterator_get_next+0x88>
    while (i<NVM_NUM_LINK_KEYS){
 80278a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80278a4:	2b0f      	cmp	r3, #15
 80278a6:	d9c8      	bls.n	802783a <btstack_link_key_db_tlv_iterator_get_next+0x1a>
        break;
    }
    it->context = (void*) i;
 80278a8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80278aa:	68fb      	ldr	r3, [r7, #12]
 80278ac:	601a      	str	r2, [r3, #0]
    return found;
 80278ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
 80278b0:	4618      	mov	r0, r3
 80278b2:	3744      	adds	r7, #68	; 0x44
 80278b4:	46bd      	mov	sp, r7
 80278b6:	bd90      	pop	{r4, r7, pc}
 80278b8:	200000a8 	.word	0x200000a8

080278bc <btstack_link_key_db_tlv_iterator_done>:

static void btstack_link_key_db_tlv_iterator_done(btstack_link_key_iterator_t * it){
 80278bc:	b480      	push	{r7}
 80278be:	b083      	sub	sp, #12
 80278c0:	af00      	add	r7, sp, #0
 80278c2:	6078      	str	r0, [r7, #4]
    UNUSED(it);
}
 80278c4:	bf00      	nop
 80278c6:	370c      	adds	r7, #12
 80278c8:	46bd      	mov	sp, r7
 80278ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80278ce:	4770      	bx	lr

080278d0 <btstack_link_key_db_tlv_get_instance>:
    btstack_link_key_db_tlv_iterator_init,
    btstack_link_key_db_tlv_iterator_get_next,
    btstack_link_key_db_tlv_iterator_done,
};

const btstack_link_key_db_t * btstack_link_key_db_tlv_get_instance(const btstack_tlv_t * btstack_tlv_impl, void * btstack_tlv_context){
 80278d0:	b480      	push	{r7}
 80278d2:	b083      	sub	sp, #12
 80278d4:	af00      	add	r7, sp, #0
 80278d6:	6078      	str	r0, [r7, #4]
 80278d8:	6039      	str	r1, [r7, #0]
    self->btstack_tlv_impl = btstack_tlv_impl;
 80278da:	4b07      	ldr	r3, [pc, #28]	; (80278f8 <btstack_link_key_db_tlv_get_instance+0x28>)
 80278dc:	681b      	ldr	r3, [r3, #0]
 80278de:	687a      	ldr	r2, [r7, #4]
 80278e0:	601a      	str	r2, [r3, #0]
    self->btstack_tlv_context = btstack_tlv_context;
 80278e2:	4b05      	ldr	r3, [pc, #20]	; (80278f8 <btstack_link_key_db_tlv_get_instance+0x28>)
 80278e4:	681b      	ldr	r3, [r3, #0]
 80278e6:	683a      	ldr	r2, [r7, #0]
 80278e8:	605a      	str	r2, [r3, #4]
    return &btstack_link_key_db_tlv;
 80278ea:	4b04      	ldr	r3, [pc, #16]	; (80278fc <btstack_link_key_db_tlv_get_instance+0x2c>)
}
 80278ec:	4618      	mov	r0, r3
 80278ee:	370c      	adds	r7, #12
 80278f0:	46bd      	mov	sp, r7
 80278f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80278f6:	4770      	bx	lr
 80278f8:	200000a8 	.word	0x200000a8
 80278fc:	08030ef8 	.word	0x08030ef8

08027900 <i2cReleaseLock>:
}

/*----------------------------------------------------------------------*/

void i2cReleaseLock(void)
{
 8027900:	b580      	push	{r7, lr}
 8027902:	af00      	add	r7, sp, #0
	static BaseType_t xHigherPriorityTaskWoken;

	xSemaphoreGiveFromISR(i2c_sem_lock, &xHigherPriorityTaskWoken);
 8027904:	4b06      	ldr	r3, [pc, #24]	; (8027920 <i2cReleaseLock+0x20>)
 8027906:	681b      	ldr	r3, [r3, #0]
 8027908:	4906      	ldr	r1, [pc, #24]	; (8027924 <i2cReleaseLock+0x24>)
 802790a:	4618      	mov	r0, r3
 802790c:	f7e0 fd24 	bl	8008358 <xQueueGiveFromISR>
	xSemaphoreGiveFromISR(i2c_sem_done, &xHigherPriorityTaskWoken);
 8027910:	4b05      	ldr	r3, [pc, #20]	; (8027928 <i2cReleaseLock+0x28>)
 8027912:	681b      	ldr	r3, [r3, #0]
 8027914:	4903      	ldr	r1, [pc, #12]	; (8027924 <i2cReleaseLock+0x24>)
 8027916:	4618      	mov	r0, r3
 8027918:	f7e0 fd1e 	bl	8008358 <xQueueGiveFromISR>

	if (xHigherPriorityTaskWoken == pdTRUE)
	{
		//
	}
}
 802791c:	bf00      	nop
 802791e:	bd80      	pop	{r7, pc}
 8027920:	2000a704 	.word	0x2000a704
 8027924:	2000a384 	.word	0x2000a384
 8027928:	2000a708 	.word	0x2000a708

0802792c <HAL_I2C_MasterTxCpltCallback>:
/*----------------------------------------------------------------------*/
/* CALLBACKS -----------------------------------------------------------*/
/*----------------------------------------------------------------------*/

void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 802792c:	b580      	push	{r7, lr}
 802792e:	b082      	sub	sp, #8
 8027930:	af00      	add	r7, sp, #0
 8027932:	6078      	str	r0, [r7, #4]
	i2cReleaseLock();
 8027934:	f7ff ffe4 	bl	8027900 <i2cReleaseLock>
}
 8027938:	bf00      	nop
 802793a:	3708      	adds	r7, #8
 802793c:	46bd      	mov	sp, r7
 802793e:	bd80      	pop	{r7, pc}

08027940 <HAL_I2C_MasterRxCpltCallback>:

/*----------------------------------------------------------------------*/

void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8027940:	b580      	push	{r7, lr}
 8027942:	b082      	sub	sp, #8
 8027944:	af00      	add	r7, sp, #0
 8027946:	6078      	str	r0, [r7, #4]
	i2cReleaseLock();
 8027948:	f7ff ffda 	bl	8027900 <i2cReleaseLock>
}
 802794c:	bf00      	nop
 802794e:	3708      	adds	r7, #8
 8027950:	46bd      	mov	sp, r7
 8027952:	bd80      	pop	{r7, pc}

08027954 <HAL_I2C_MemTxCpltCallback>:

/*----------------------------------------------------------------------*/

void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8027954:	b580      	push	{r7, lr}
 8027956:	b082      	sub	sp, #8
 8027958:	af00      	add	r7, sp, #0
 802795a:	6078      	str	r0, [r7, #4]
	i2cReleaseLock();
 802795c:	f7ff ffd0 	bl	8027900 <i2cReleaseLock>
}
 8027960:	bf00      	nop
 8027962:	3708      	adds	r7, #8
 8027964:	46bd      	mov	sp, r7
 8027966:	bd80      	pop	{r7, pc}

08027968 <HAL_I2C_MemRxCpltCallback>:

/*----------------------------------------------------------------------*/

void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8027968:	b580      	push	{r7, lr}
 802796a:	b082      	sub	sp, #8
 802796c:	af00      	add	r7, sp, #0
 802796e:	6078      	str	r0, [r7, #4]
	i2cReleaseLock();
 8027970:	f7ff ffc6 	bl	8027900 <i2cReleaseLock>
}
 8027974:	bf00      	nop
 8027976:	3708      	adds	r7, #8
 8027978:	46bd      	mov	sp, r7
 802797a:	bd80      	pop	{r7, pc}

0802797c <HAL_I2C_ErrorCallback>:

/*----------------------------------------------------------------------*/

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
 802797c:	b580      	push	{r7, lr}
 802797e:	b082      	sub	sp, #8
 8027980:	af00      	add	r7, sp, #0
 8027982:	6078      	str	r0, [r7, #4]
	i2cReleaseLock();
 8027984:	f7ff ffbc 	bl	8027900 <i2cReleaseLock>
}
 8027988:	bf00      	nop
 802798a:	3708      	adds	r7, #8
 802798c:	46bd      	mov	sp, r7
 802798e:	bd80      	pop	{r7, pc}

08027990 <spiReleaseLock>:
}

/*----------------------------------------------------------------------*/

void spiReleaseLock(SPI_HandleTypeDef *hspi)
{
 8027990:	b580      	push	{r7, lr}
 8027992:	b084      	sub	sp, #16
 8027994:	af00      	add	r7, sp, #0
 8027996:	6078      	str	r0, [r7, #4]
	static BaseType_t xHigherPriorityTaskWoken;

	uint8_t periph_index;

	for (periph_index = 0; periph_index < SPI_MAX_PERIPH; periph_index++)
 8027998:	2300      	movs	r3, #0
 802799a:	73fb      	strb	r3, [r7, #15]
 802799c:	e01b      	b.n	80279d6 <spiReleaseLock+0x46>
	{
		if (spi_sem_lock[periph_index].handle == hspi)
 802799e:	7bfb      	ldrb	r3, [r7, #15]
 80279a0:	4a10      	ldr	r2, [pc, #64]	; (80279e4 <spiReleaseLock+0x54>)
 80279a2:	00db      	lsls	r3, r3, #3
 80279a4:	4413      	add	r3, r2
 80279a6:	685b      	ldr	r3, [r3, #4]
 80279a8:	687a      	ldr	r2, [r7, #4]
 80279aa:	429a      	cmp	r2, r3
 80279ac:	d110      	bne.n	80279d0 <spiReleaseLock+0x40>
		{
			xSemaphoreGiveFromISR(spi_sem_lock[periph_index].sem, &xHigherPriorityTaskWoken);
 80279ae:	7bfb      	ldrb	r3, [r7, #15]
 80279b0:	4a0c      	ldr	r2, [pc, #48]	; (80279e4 <spiReleaseLock+0x54>)
 80279b2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 80279b6:	490c      	ldr	r1, [pc, #48]	; (80279e8 <spiReleaseLock+0x58>)
 80279b8:	4618      	mov	r0, r3
 80279ba:	f7e0 fccd 	bl	8008358 <xQueueGiveFromISR>
			xSemaphoreGiveFromISR(spi_sem_done[periph_index].sem, &xHigherPriorityTaskWoken);
 80279be:	7bfb      	ldrb	r3, [r7, #15]
 80279c0:	4a0a      	ldr	r2, [pc, #40]	; (80279ec <spiReleaseLock+0x5c>)
 80279c2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 80279c6:	4908      	ldr	r1, [pc, #32]	; (80279e8 <spiReleaseLock+0x58>)
 80279c8:	4618      	mov	r0, r3
 80279ca:	f7e0 fcc5 	bl	8008358 <xQueueGiveFromISR>
			break;
 80279ce:	e005      	b.n	80279dc <spiReleaseLock+0x4c>
	for (periph_index = 0; periph_index < SPI_MAX_PERIPH; periph_index++)
 80279d0:	7bfb      	ldrb	r3, [r7, #15]
 80279d2:	3301      	adds	r3, #1
 80279d4:	73fb      	strb	r3, [r7, #15]
 80279d6:	7bfb      	ldrb	r3, [r7, #15]
 80279d8:	2b01      	cmp	r3, #1
 80279da:	d9e0      	bls.n	802799e <spiReleaseLock+0xe>

	if (xHigherPriorityTaskWoken == pdTRUE)
	{
		//Do nothing for now
	}
}
 80279dc:	bf00      	nop
 80279de:	3710      	adds	r7, #16
 80279e0:	46bd      	mov	sp, r7
 80279e2:	bd80      	pop	{r7, pc}
 80279e4:	2000a70c 	.word	0x2000a70c
 80279e8:	2000a388 	.word	0x2000a388
 80279ec:	2000a71c 	.word	0x2000a71c

080279f0 <HAL_SPI_ErrorCallback>:
}

/*----------------------------------------------------------------------*/

void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
 80279f0:	b580      	push	{r7, lr}
 80279f2:	b082      	sub	sp, #8
 80279f4:	af00      	add	r7, sp, #0
 80279f6:	6078      	str	r0, [r7, #4]
	spiReleaseLock(hspi);
 80279f8:	6878      	ldr	r0, [r7, #4]
 80279fa:	f7ff ffc9 	bl	8027990 <spiReleaseLock>
}
 80279fe:	bf00      	nop
 8027a00:	3708      	adds	r7, #8
 8027a02:	46bd      	mov	sp, r7
 8027a04:	bd80      	pop	{r7, pc}
	...

08027a08 <__errno>:
 8027a08:	4b01      	ldr	r3, [pc, #4]	; (8027a10 <__errno+0x8>)
 8027a0a:	6818      	ldr	r0, [r3, #0]
 8027a0c:	4770      	bx	lr
 8027a0e:	bf00      	nop
 8027a10:	200000ac 	.word	0x200000ac

08027a14 <__libc_init_array>:
 8027a14:	b570      	push	{r4, r5, r6, lr}
 8027a16:	4e0d      	ldr	r6, [pc, #52]	; (8027a4c <__libc_init_array+0x38>)
 8027a18:	4c0d      	ldr	r4, [pc, #52]	; (8027a50 <__libc_init_array+0x3c>)
 8027a1a:	1ba4      	subs	r4, r4, r6
 8027a1c:	10a4      	asrs	r4, r4, #2
 8027a1e:	2500      	movs	r5, #0
 8027a20:	42a5      	cmp	r5, r4
 8027a22:	d109      	bne.n	8027a38 <__libc_init_array+0x24>
 8027a24:	4e0b      	ldr	r6, [pc, #44]	; (8027a54 <__libc_init_array+0x40>)
 8027a26:	4c0c      	ldr	r4, [pc, #48]	; (8027a58 <__libc_init_array+0x44>)
 8027a28:	f000 ff98 	bl	802895c <_init>
 8027a2c:	1ba4      	subs	r4, r4, r6
 8027a2e:	10a4      	asrs	r4, r4, #2
 8027a30:	2500      	movs	r5, #0
 8027a32:	42a5      	cmp	r5, r4
 8027a34:	d105      	bne.n	8027a42 <__libc_init_array+0x2e>
 8027a36:	bd70      	pop	{r4, r5, r6, pc}
 8027a38:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8027a3c:	4798      	blx	r3
 8027a3e:	3501      	adds	r5, #1
 8027a40:	e7ee      	b.n	8027a20 <__libc_init_array+0xc>
 8027a42:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8027a46:	4798      	blx	r3
 8027a48:	3501      	adds	r5, #1
 8027a4a:	e7f2      	b.n	8027a32 <__libc_init_array+0x1e>
 8027a4c:	08030fbc 	.word	0x08030fbc
 8027a50:	08030fbc 	.word	0x08030fbc
 8027a54:	08030fbc 	.word	0x08030fbc
 8027a58:	08030fc0 	.word	0x08030fc0

08027a5c <memcmp>:
 8027a5c:	b530      	push	{r4, r5, lr}
 8027a5e:	2400      	movs	r4, #0
 8027a60:	42a2      	cmp	r2, r4
 8027a62:	d101      	bne.n	8027a68 <memcmp+0xc>
 8027a64:	2000      	movs	r0, #0
 8027a66:	e007      	b.n	8027a78 <memcmp+0x1c>
 8027a68:	5d03      	ldrb	r3, [r0, r4]
 8027a6a:	3401      	adds	r4, #1
 8027a6c:	190d      	adds	r5, r1, r4
 8027a6e:	f815 5c01 	ldrb.w	r5, [r5, #-1]
 8027a72:	42ab      	cmp	r3, r5
 8027a74:	d0f4      	beq.n	8027a60 <memcmp+0x4>
 8027a76:	1b58      	subs	r0, r3, r5
 8027a78:	bd30      	pop	{r4, r5, pc}

08027a7a <memcpy>:
 8027a7a:	b510      	push	{r4, lr}
 8027a7c:	1e43      	subs	r3, r0, #1
 8027a7e:	440a      	add	r2, r1
 8027a80:	4291      	cmp	r1, r2
 8027a82:	d100      	bne.n	8027a86 <memcpy+0xc>
 8027a84:	bd10      	pop	{r4, pc}
 8027a86:	f811 4b01 	ldrb.w	r4, [r1], #1
 8027a8a:	f803 4f01 	strb.w	r4, [r3, #1]!
 8027a8e:	e7f7      	b.n	8027a80 <memcpy+0x6>

08027a90 <memmove>:
 8027a90:	4288      	cmp	r0, r1
 8027a92:	b510      	push	{r4, lr}
 8027a94:	eb01 0302 	add.w	r3, r1, r2
 8027a98:	d807      	bhi.n	8027aaa <memmove+0x1a>
 8027a9a:	1e42      	subs	r2, r0, #1
 8027a9c:	4299      	cmp	r1, r3
 8027a9e:	d00a      	beq.n	8027ab6 <memmove+0x26>
 8027aa0:	f811 4b01 	ldrb.w	r4, [r1], #1
 8027aa4:	f802 4f01 	strb.w	r4, [r2, #1]!
 8027aa8:	e7f8      	b.n	8027a9c <memmove+0xc>
 8027aaa:	4283      	cmp	r3, r0
 8027aac:	d9f5      	bls.n	8027a9a <memmove+0xa>
 8027aae:	1881      	adds	r1, r0, r2
 8027ab0:	1ad2      	subs	r2, r2, r3
 8027ab2:	42d3      	cmn	r3, r2
 8027ab4:	d100      	bne.n	8027ab8 <memmove+0x28>
 8027ab6:	bd10      	pop	{r4, pc}
 8027ab8:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8027abc:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8027ac0:	e7f7      	b.n	8027ab2 <memmove+0x22>

08027ac2 <memset>:
 8027ac2:	4402      	add	r2, r0
 8027ac4:	4603      	mov	r3, r0
 8027ac6:	4293      	cmp	r3, r2
 8027ac8:	d100      	bne.n	8027acc <memset+0xa>
 8027aca:	4770      	bx	lr
 8027acc:	f803 1b01 	strb.w	r1, [r3], #1
 8027ad0:	e7f9      	b.n	8027ac6 <memset+0x4>
	...

08027ad4 <iprintf>:
 8027ad4:	b40f      	push	{r0, r1, r2, r3}
 8027ad6:	4b0a      	ldr	r3, [pc, #40]	; (8027b00 <iprintf+0x2c>)
 8027ad8:	b513      	push	{r0, r1, r4, lr}
 8027ada:	681c      	ldr	r4, [r3, #0]
 8027adc:	b124      	cbz	r4, 8027ae8 <iprintf+0x14>
 8027ade:	69a3      	ldr	r3, [r4, #24]
 8027ae0:	b913      	cbnz	r3, 8027ae8 <iprintf+0x14>
 8027ae2:	4620      	mov	r0, r4
 8027ae4:	f000 fa4e 	bl	8027f84 <__sinit>
 8027ae8:	ab05      	add	r3, sp, #20
 8027aea:	9a04      	ldr	r2, [sp, #16]
 8027aec:	68a1      	ldr	r1, [r4, #8]
 8027aee:	9301      	str	r3, [sp, #4]
 8027af0:	4620      	mov	r0, r4
 8027af2:	f000 fc19 	bl	8028328 <_vfiprintf_r>
 8027af6:	b002      	add	sp, #8
 8027af8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8027afc:	b004      	add	sp, #16
 8027afe:	4770      	bx	lr
 8027b00:	200000ac 	.word	0x200000ac

08027b04 <putchar>:
 8027b04:	b538      	push	{r3, r4, r5, lr}
 8027b06:	4b08      	ldr	r3, [pc, #32]	; (8027b28 <putchar+0x24>)
 8027b08:	681c      	ldr	r4, [r3, #0]
 8027b0a:	4605      	mov	r5, r0
 8027b0c:	b124      	cbz	r4, 8027b18 <putchar+0x14>
 8027b0e:	69a3      	ldr	r3, [r4, #24]
 8027b10:	b913      	cbnz	r3, 8027b18 <putchar+0x14>
 8027b12:	4620      	mov	r0, r4
 8027b14:	f000 fa36 	bl	8027f84 <__sinit>
 8027b18:	68a2      	ldr	r2, [r4, #8]
 8027b1a:	4629      	mov	r1, r5
 8027b1c:	4620      	mov	r0, r4
 8027b1e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8027b22:	f000 be9f 	b.w	8028864 <_putc_r>
 8027b26:	bf00      	nop
 8027b28:	200000ac 	.word	0x200000ac

08027b2c <__sread>:
 8027b2c:	b510      	push	{r4, lr}
 8027b2e:	460c      	mov	r4, r1
 8027b30:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8027b34:	f000 fecc 	bl	80288d0 <_read_r>
 8027b38:	2800      	cmp	r0, #0
 8027b3a:	bfab      	itete	ge
 8027b3c:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8027b3e:	89a3      	ldrhlt	r3, [r4, #12]
 8027b40:	181b      	addge	r3, r3, r0
 8027b42:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8027b46:	bfac      	ite	ge
 8027b48:	6563      	strge	r3, [r4, #84]	; 0x54
 8027b4a:	81a3      	strhlt	r3, [r4, #12]
 8027b4c:	bd10      	pop	{r4, pc}

08027b4e <__swrite>:
 8027b4e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027b52:	461f      	mov	r7, r3
 8027b54:	898b      	ldrh	r3, [r1, #12]
 8027b56:	05db      	lsls	r3, r3, #23
 8027b58:	4605      	mov	r5, r0
 8027b5a:	460c      	mov	r4, r1
 8027b5c:	4616      	mov	r6, r2
 8027b5e:	d505      	bpl.n	8027b6c <__swrite+0x1e>
 8027b60:	2302      	movs	r3, #2
 8027b62:	2200      	movs	r2, #0
 8027b64:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8027b68:	f000 fa96 	bl	8028098 <_lseek_r>
 8027b6c:	89a3      	ldrh	r3, [r4, #12]
 8027b6e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8027b72:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8027b76:	81a3      	strh	r3, [r4, #12]
 8027b78:	4632      	mov	r2, r6
 8027b7a:	463b      	mov	r3, r7
 8027b7c:	4628      	mov	r0, r5
 8027b7e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8027b82:	f000 b87f 	b.w	8027c84 <_write_r>

08027b86 <__sseek>:
 8027b86:	b510      	push	{r4, lr}
 8027b88:	460c      	mov	r4, r1
 8027b8a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8027b8e:	f000 fa83 	bl	8028098 <_lseek_r>
 8027b92:	1c43      	adds	r3, r0, #1
 8027b94:	89a3      	ldrh	r3, [r4, #12]
 8027b96:	bf15      	itete	ne
 8027b98:	6560      	strne	r0, [r4, #84]	; 0x54
 8027b9a:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8027b9e:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8027ba2:	81a3      	strheq	r3, [r4, #12]
 8027ba4:	bf18      	it	ne
 8027ba6:	81a3      	strhne	r3, [r4, #12]
 8027ba8:	bd10      	pop	{r4, pc}

08027baa <__sclose>:
 8027baa:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8027bae:	f000 b8e9 	b.w	8027d84 <_close_r>
	...

08027bb4 <viprintf>:
 8027bb4:	4b09      	ldr	r3, [pc, #36]	; (8027bdc <viprintf+0x28>)
 8027bb6:	b570      	push	{r4, r5, r6, lr}
 8027bb8:	681c      	ldr	r4, [r3, #0]
 8027bba:	4605      	mov	r5, r0
 8027bbc:	460e      	mov	r6, r1
 8027bbe:	b124      	cbz	r4, 8027bca <viprintf+0x16>
 8027bc0:	69a3      	ldr	r3, [r4, #24]
 8027bc2:	b913      	cbnz	r3, 8027bca <viprintf+0x16>
 8027bc4:	4620      	mov	r0, r4
 8027bc6:	f000 f9dd 	bl	8027f84 <__sinit>
 8027bca:	4633      	mov	r3, r6
 8027bcc:	462a      	mov	r2, r5
 8027bce:	68a1      	ldr	r1, [r4, #8]
 8027bd0:	4620      	mov	r0, r4
 8027bd2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8027bd6:	f000 bba7 	b.w	8028328 <_vfiprintf_r>
 8027bda:	bf00      	nop
 8027bdc:	200000ac 	.word	0x200000ac

08027be0 <__swbuf_r>:
 8027be0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8027be2:	460e      	mov	r6, r1
 8027be4:	4614      	mov	r4, r2
 8027be6:	4605      	mov	r5, r0
 8027be8:	b118      	cbz	r0, 8027bf2 <__swbuf_r+0x12>
 8027bea:	6983      	ldr	r3, [r0, #24]
 8027bec:	b90b      	cbnz	r3, 8027bf2 <__swbuf_r+0x12>
 8027bee:	f000 f9c9 	bl	8027f84 <__sinit>
 8027bf2:	4b21      	ldr	r3, [pc, #132]	; (8027c78 <__swbuf_r+0x98>)
 8027bf4:	429c      	cmp	r4, r3
 8027bf6:	d12a      	bne.n	8027c4e <__swbuf_r+0x6e>
 8027bf8:	686c      	ldr	r4, [r5, #4]
 8027bfa:	69a3      	ldr	r3, [r4, #24]
 8027bfc:	60a3      	str	r3, [r4, #8]
 8027bfe:	89a3      	ldrh	r3, [r4, #12]
 8027c00:	071a      	lsls	r2, r3, #28
 8027c02:	d52e      	bpl.n	8027c62 <__swbuf_r+0x82>
 8027c04:	6923      	ldr	r3, [r4, #16]
 8027c06:	b363      	cbz	r3, 8027c62 <__swbuf_r+0x82>
 8027c08:	6923      	ldr	r3, [r4, #16]
 8027c0a:	6820      	ldr	r0, [r4, #0]
 8027c0c:	1ac0      	subs	r0, r0, r3
 8027c0e:	6963      	ldr	r3, [r4, #20]
 8027c10:	b2f6      	uxtb	r6, r6
 8027c12:	4283      	cmp	r3, r0
 8027c14:	4637      	mov	r7, r6
 8027c16:	dc04      	bgt.n	8027c22 <__swbuf_r+0x42>
 8027c18:	4621      	mov	r1, r4
 8027c1a:	4628      	mov	r0, r5
 8027c1c:	f000 f948 	bl	8027eb0 <_fflush_r>
 8027c20:	bb28      	cbnz	r0, 8027c6e <__swbuf_r+0x8e>
 8027c22:	68a3      	ldr	r3, [r4, #8]
 8027c24:	3b01      	subs	r3, #1
 8027c26:	60a3      	str	r3, [r4, #8]
 8027c28:	6823      	ldr	r3, [r4, #0]
 8027c2a:	1c5a      	adds	r2, r3, #1
 8027c2c:	6022      	str	r2, [r4, #0]
 8027c2e:	701e      	strb	r6, [r3, #0]
 8027c30:	6963      	ldr	r3, [r4, #20]
 8027c32:	3001      	adds	r0, #1
 8027c34:	4283      	cmp	r3, r0
 8027c36:	d004      	beq.n	8027c42 <__swbuf_r+0x62>
 8027c38:	89a3      	ldrh	r3, [r4, #12]
 8027c3a:	07db      	lsls	r3, r3, #31
 8027c3c:	d519      	bpl.n	8027c72 <__swbuf_r+0x92>
 8027c3e:	2e0a      	cmp	r6, #10
 8027c40:	d117      	bne.n	8027c72 <__swbuf_r+0x92>
 8027c42:	4621      	mov	r1, r4
 8027c44:	4628      	mov	r0, r5
 8027c46:	f000 f933 	bl	8027eb0 <_fflush_r>
 8027c4a:	b190      	cbz	r0, 8027c72 <__swbuf_r+0x92>
 8027c4c:	e00f      	b.n	8027c6e <__swbuf_r+0x8e>
 8027c4e:	4b0b      	ldr	r3, [pc, #44]	; (8027c7c <__swbuf_r+0x9c>)
 8027c50:	429c      	cmp	r4, r3
 8027c52:	d101      	bne.n	8027c58 <__swbuf_r+0x78>
 8027c54:	68ac      	ldr	r4, [r5, #8]
 8027c56:	e7d0      	b.n	8027bfa <__swbuf_r+0x1a>
 8027c58:	4b09      	ldr	r3, [pc, #36]	; (8027c80 <__swbuf_r+0xa0>)
 8027c5a:	429c      	cmp	r4, r3
 8027c5c:	bf08      	it	eq
 8027c5e:	68ec      	ldreq	r4, [r5, #12]
 8027c60:	e7cb      	b.n	8027bfa <__swbuf_r+0x1a>
 8027c62:	4621      	mov	r1, r4
 8027c64:	4628      	mov	r0, r5
 8027c66:	f000 f81f 	bl	8027ca8 <__swsetup_r>
 8027c6a:	2800      	cmp	r0, #0
 8027c6c:	d0cc      	beq.n	8027c08 <__swbuf_r+0x28>
 8027c6e:	f04f 37ff 	mov.w	r7, #4294967295
 8027c72:	4638      	mov	r0, r7
 8027c74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8027c76:	bf00      	nop
 8027c78:	08030f40 	.word	0x08030f40
 8027c7c:	08030f60 	.word	0x08030f60
 8027c80:	08030f20 	.word	0x08030f20

08027c84 <_write_r>:
 8027c84:	b538      	push	{r3, r4, r5, lr}
 8027c86:	4c07      	ldr	r4, [pc, #28]	; (8027ca4 <_write_r+0x20>)
 8027c88:	4605      	mov	r5, r0
 8027c8a:	4608      	mov	r0, r1
 8027c8c:	4611      	mov	r1, r2
 8027c8e:	2200      	movs	r2, #0
 8027c90:	6022      	str	r2, [r4, #0]
 8027c92:	461a      	mov	r2, r3
 8027c94:	f7d9 f985 	bl	8000fa2 <_write>
 8027c98:	1c43      	adds	r3, r0, #1
 8027c9a:	d102      	bne.n	8027ca2 <_write_r+0x1e>
 8027c9c:	6823      	ldr	r3, [r4, #0]
 8027c9e:	b103      	cbz	r3, 8027ca2 <_write_r+0x1e>
 8027ca0:	602b      	str	r3, [r5, #0]
 8027ca2:	bd38      	pop	{r3, r4, r5, pc}
 8027ca4:	2000a72c 	.word	0x2000a72c

08027ca8 <__swsetup_r>:
 8027ca8:	4b32      	ldr	r3, [pc, #200]	; (8027d74 <__swsetup_r+0xcc>)
 8027caa:	b570      	push	{r4, r5, r6, lr}
 8027cac:	681d      	ldr	r5, [r3, #0]
 8027cae:	4606      	mov	r6, r0
 8027cb0:	460c      	mov	r4, r1
 8027cb2:	b125      	cbz	r5, 8027cbe <__swsetup_r+0x16>
 8027cb4:	69ab      	ldr	r3, [r5, #24]
 8027cb6:	b913      	cbnz	r3, 8027cbe <__swsetup_r+0x16>
 8027cb8:	4628      	mov	r0, r5
 8027cba:	f000 f963 	bl	8027f84 <__sinit>
 8027cbe:	4b2e      	ldr	r3, [pc, #184]	; (8027d78 <__swsetup_r+0xd0>)
 8027cc0:	429c      	cmp	r4, r3
 8027cc2:	d10f      	bne.n	8027ce4 <__swsetup_r+0x3c>
 8027cc4:	686c      	ldr	r4, [r5, #4]
 8027cc6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8027cca:	b29a      	uxth	r2, r3
 8027ccc:	0715      	lsls	r5, r2, #28
 8027cce:	d42c      	bmi.n	8027d2a <__swsetup_r+0x82>
 8027cd0:	06d0      	lsls	r0, r2, #27
 8027cd2:	d411      	bmi.n	8027cf8 <__swsetup_r+0x50>
 8027cd4:	2209      	movs	r2, #9
 8027cd6:	6032      	str	r2, [r6, #0]
 8027cd8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8027cdc:	81a3      	strh	r3, [r4, #12]
 8027cde:	f04f 30ff 	mov.w	r0, #4294967295
 8027ce2:	e03e      	b.n	8027d62 <__swsetup_r+0xba>
 8027ce4:	4b25      	ldr	r3, [pc, #148]	; (8027d7c <__swsetup_r+0xd4>)
 8027ce6:	429c      	cmp	r4, r3
 8027ce8:	d101      	bne.n	8027cee <__swsetup_r+0x46>
 8027cea:	68ac      	ldr	r4, [r5, #8]
 8027cec:	e7eb      	b.n	8027cc6 <__swsetup_r+0x1e>
 8027cee:	4b24      	ldr	r3, [pc, #144]	; (8027d80 <__swsetup_r+0xd8>)
 8027cf0:	429c      	cmp	r4, r3
 8027cf2:	bf08      	it	eq
 8027cf4:	68ec      	ldreq	r4, [r5, #12]
 8027cf6:	e7e6      	b.n	8027cc6 <__swsetup_r+0x1e>
 8027cf8:	0751      	lsls	r1, r2, #29
 8027cfa:	d512      	bpl.n	8027d22 <__swsetup_r+0x7a>
 8027cfc:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8027cfe:	b141      	cbz	r1, 8027d12 <__swsetup_r+0x6a>
 8027d00:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8027d04:	4299      	cmp	r1, r3
 8027d06:	d002      	beq.n	8027d0e <__swsetup_r+0x66>
 8027d08:	4630      	mov	r0, r6
 8027d0a:	f000 fa3b 	bl	8028184 <_free_r>
 8027d0e:	2300      	movs	r3, #0
 8027d10:	6363      	str	r3, [r4, #52]	; 0x34
 8027d12:	89a3      	ldrh	r3, [r4, #12]
 8027d14:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8027d18:	81a3      	strh	r3, [r4, #12]
 8027d1a:	2300      	movs	r3, #0
 8027d1c:	6063      	str	r3, [r4, #4]
 8027d1e:	6923      	ldr	r3, [r4, #16]
 8027d20:	6023      	str	r3, [r4, #0]
 8027d22:	89a3      	ldrh	r3, [r4, #12]
 8027d24:	f043 0308 	orr.w	r3, r3, #8
 8027d28:	81a3      	strh	r3, [r4, #12]
 8027d2a:	6923      	ldr	r3, [r4, #16]
 8027d2c:	b94b      	cbnz	r3, 8027d42 <__swsetup_r+0x9a>
 8027d2e:	89a3      	ldrh	r3, [r4, #12]
 8027d30:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8027d34:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8027d38:	d003      	beq.n	8027d42 <__swsetup_r+0x9a>
 8027d3a:	4621      	mov	r1, r4
 8027d3c:	4630      	mov	r0, r6
 8027d3e:	f000 f9e1 	bl	8028104 <__smakebuf_r>
 8027d42:	89a2      	ldrh	r2, [r4, #12]
 8027d44:	f012 0301 	ands.w	r3, r2, #1
 8027d48:	d00c      	beq.n	8027d64 <__swsetup_r+0xbc>
 8027d4a:	2300      	movs	r3, #0
 8027d4c:	60a3      	str	r3, [r4, #8]
 8027d4e:	6963      	ldr	r3, [r4, #20]
 8027d50:	425b      	negs	r3, r3
 8027d52:	61a3      	str	r3, [r4, #24]
 8027d54:	6923      	ldr	r3, [r4, #16]
 8027d56:	b953      	cbnz	r3, 8027d6e <__swsetup_r+0xc6>
 8027d58:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8027d5c:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 8027d60:	d1ba      	bne.n	8027cd8 <__swsetup_r+0x30>
 8027d62:	bd70      	pop	{r4, r5, r6, pc}
 8027d64:	0792      	lsls	r2, r2, #30
 8027d66:	bf58      	it	pl
 8027d68:	6963      	ldrpl	r3, [r4, #20]
 8027d6a:	60a3      	str	r3, [r4, #8]
 8027d6c:	e7f2      	b.n	8027d54 <__swsetup_r+0xac>
 8027d6e:	2000      	movs	r0, #0
 8027d70:	e7f7      	b.n	8027d62 <__swsetup_r+0xba>
 8027d72:	bf00      	nop
 8027d74:	200000ac 	.word	0x200000ac
 8027d78:	08030f40 	.word	0x08030f40
 8027d7c:	08030f60 	.word	0x08030f60
 8027d80:	08030f20 	.word	0x08030f20

08027d84 <_close_r>:
 8027d84:	b538      	push	{r3, r4, r5, lr}
 8027d86:	4c06      	ldr	r4, [pc, #24]	; (8027da0 <_close_r+0x1c>)
 8027d88:	2300      	movs	r3, #0
 8027d8a:	4605      	mov	r5, r0
 8027d8c:	4608      	mov	r0, r1
 8027d8e:	6023      	str	r3, [r4, #0]
 8027d90:	f7d9 f923 	bl	8000fda <_close>
 8027d94:	1c43      	adds	r3, r0, #1
 8027d96:	d102      	bne.n	8027d9e <_close_r+0x1a>
 8027d98:	6823      	ldr	r3, [r4, #0]
 8027d9a:	b103      	cbz	r3, 8027d9e <_close_r+0x1a>
 8027d9c:	602b      	str	r3, [r5, #0]
 8027d9e:	bd38      	pop	{r3, r4, r5, pc}
 8027da0:	2000a72c 	.word	0x2000a72c

08027da4 <__sflush_r>:
 8027da4:	898a      	ldrh	r2, [r1, #12]
 8027da6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027daa:	4605      	mov	r5, r0
 8027dac:	0710      	lsls	r0, r2, #28
 8027dae:	460c      	mov	r4, r1
 8027db0:	d458      	bmi.n	8027e64 <__sflush_r+0xc0>
 8027db2:	684b      	ldr	r3, [r1, #4]
 8027db4:	2b00      	cmp	r3, #0
 8027db6:	dc05      	bgt.n	8027dc4 <__sflush_r+0x20>
 8027db8:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8027dba:	2b00      	cmp	r3, #0
 8027dbc:	dc02      	bgt.n	8027dc4 <__sflush_r+0x20>
 8027dbe:	2000      	movs	r0, #0
 8027dc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8027dc4:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8027dc6:	2e00      	cmp	r6, #0
 8027dc8:	d0f9      	beq.n	8027dbe <__sflush_r+0x1a>
 8027dca:	2300      	movs	r3, #0
 8027dcc:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8027dd0:	682f      	ldr	r7, [r5, #0]
 8027dd2:	6a21      	ldr	r1, [r4, #32]
 8027dd4:	602b      	str	r3, [r5, #0]
 8027dd6:	d032      	beq.n	8027e3e <__sflush_r+0x9a>
 8027dd8:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8027dda:	89a3      	ldrh	r3, [r4, #12]
 8027ddc:	075a      	lsls	r2, r3, #29
 8027dde:	d505      	bpl.n	8027dec <__sflush_r+0x48>
 8027de0:	6863      	ldr	r3, [r4, #4]
 8027de2:	1ac0      	subs	r0, r0, r3
 8027de4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8027de6:	b10b      	cbz	r3, 8027dec <__sflush_r+0x48>
 8027de8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8027dea:	1ac0      	subs	r0, r0, r3
 8027dec:	2300      	movs	r3, #0
 8027dee:	4602      	mov	r2, r0
 8027df0:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8027df2:	6a21      	ldr	r1, [r4, #32]
 8027df4:	4628      	mov	r0, r5
 8027df6:	47b0      	blx	r6
 8027df8:	1c43      	adds	r3, r0, #1
 8027dfa:	89a3      	ldrh	r3, [r4, #12]
 8027dfc:	d106      	bne.n	8027e0c <__sflush_r+0x68>
 8027dfe:	6829      	ldr	r1, [r5, #0]
 8027e00:	291d      	cmp	r1, #29
 8027e02:	d848      	bhi.n	8027e96 <__sflush_r+0xf2>
 8027e04:	4a29      	ldr	r2, [pc, #164]	; (8027eac <__sflush_r+0x108>)
 8027e06:	40ca      	lsrs	r2, r1
 8027e08:	07d6      	lsls	r6, r2, #31
 8027e0a:	d544      	bpl.n	8027e96 <__sflush_r+0xf2>
 8027e0c:	2200      	movs	r2, #0
 8027e0e:	6062      	str	r2, [r4, #4]
 8027e10:	04d9      	lsls	r1, r3, #19
 8027e12:	6922      	ldr	r2, [r4, #16]
 8027e14:	6022      	str	r2, [r4, #0]
 8027e16:	d504      	bpl.n	8027e22 <__sflush_r+0x7e>
 8027e18:	1c42      	adds	r2, r0, #1
 8027e1a:	d101      	bne.n	8027e20 <__sflush_r+0x7c>
 8027e1c:	682b      	ldr	r3, [r5, #0]
 8027e1e:	b903      	cbnz	r3, 8027e22 <__sflush_r+0x7e>
 8027e20:	6560      	str	r0, [r4, #84]	; 0x54
 8027e22:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8027e24:	602f      	str	r7, [r5, #0]
 8027e26:	2900      	cmp	r1, #0
 8027e28:	d0c9      	beq.n	8027dbe <__sflush_r+0x1a>
 8027e2a:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8027e2e:	4299      	cmp	r1, r3
 8027e30:	d002      	beq.n	8027e38 <__sflush_r+0x94>
 8027e32:	4628      	mov	r0, r5
 8027e34:	f000 f9a6 	bl	8028184 <_free_r>
 8027e38:	2000      	movs	r0, #0
 8027e3a:	6360      	str	r0, [r4, #52]	; 0x34
 8027e3c:	e7c0      	b.n	8027dc0 <__sflush_r+0x1c>
 8027e3e:	2301      	movs	r3, #1
 8027e40:	4628      	mov	r0, r5
 8027e42:	47b0      	blx	r6
 8027e44:	1c41      	adds	r1, r0, #1
 8027e46:	d1c8      	bne.n	8027dda <__sflush_r+0x36>
 8027e48:	682b      	ldr	r3, [r5, #0]
 8027e4a:	2b00      	cmp	r3, #0
 8027e4c:	d0c5      	beq.n	8027dda <__sflush_r+0x36>
 8027e4e:	2b1d      	cmp	r3, #29
 8027e50:	d001      	beq.n	8027e56 <__sflush_r+0xb2>
 8027e52:	2b16      	cmp	r3, #22
 8027e54:	d101      	bne.n	8027e5a <__sflush_r+0xb6>
 8027e56:	602f      	str	r7, [r5, #0]
 8027e58:	e7b1      	b.n	8027dbe <__sflush_r+0x1a>
 8027e5a:	89a3      	ldrh	r3, [r4, #12]
 8027e5c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8027e60:	81a3      	strh	r3, [r4, #12]
 8027e62:	e7ad      	b.n	8027dc0 <__sflush_r+0x1c>
 8027e64:	690f      	ldr	r7, [r1, #16]
 8027e66:	2f00      	cmp	r7, #0
 8027e68:	d0a9      	beq.n	8027dbe <__sflush_r+0x1a>
 8027e6a:	0793      	lsls	r3, r2, #30
 8027e6c:	680e      	ldr	r6, [r1, #0]
 8027e6e:	bf08      	it	eq
 8027e70:	694b      	ldreq	r3, [r1, #20]
 8027e72:	600f      	str	r7, [r1, #0]
 8027e74:	bf18      	it	ne
 8027e76:	2300      	movne	r3, #0
 8027e78:	eba6 0807 	sub.w	r8, r6, r7
 8027e7c:	608b      	str	r3, [r1, #8]
 8027e7e:	f1b8 0f00 	cmp.w	r8, #0
 8027e82:	dd9c      	ble.n	8027dbe <__sflush_r+0x1a>
 8027e84:	4643      	mov	r3, r8
 8027e86:	463a      	mov	r2, r7
 8027e88:	6a21      	ldr	r1, [r4, #32]
 8027e8a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8027e8c:	4628      	mov	r0, r5
 8027e8e:	47b0      	blx	r6
 8027e90:	2800      	cmp	r0, #0
 8027e92:	dc06      	bgt.n	8027ea2 <__sflush_r+0xfe>
 8027e94:	89a3      	ldrh	r3, [r4, #12]
 8027e96:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8027e9a:	81a3      	strh	r3, [r4, #12]
 8027e9c:	f04f 30ff 	mov.w	r0, #4294967295
 8027ea0:	e78e      	b.n	8027dc0 <__sflush_r+0x1c>
 8027ea2:	4407      	add	r7, r0
 8027ea4:	eba8 0800 	sub.w	r8, r8, r0
 8027ea8:	e7e9      	b.n	8027e7e <__sflush_r+0xda>
 8027eaa:	bf00      	nop
 8027eac:	20400001 	.word	0x20400001

08027eb0 <_fflush_r>:
 8027eb0:	b538      	push	{r3, r4, r5, lr}
 8027eb2:	690b      	ldr	r3, [r1, #16]
 8027eb4:	4605      	mov	r5, r0
 8027eb6:	460c      	mov	r4, r1
 8027eb8:	b1db      	cbz	r3, 8027ef2 <_fflush_r+0x42>
 8027eba:	b118      	cbz	r0, 8027ec4 <_fflush_r+0x14>
 8027ebc:	6983      	ldr	r3, [r0, #24]
 8027ebe:	b90b      	cbnz	r3, 8027ec4 <_fflush_r+0x14>
 8027ec0:	f000 f860 	bl	8027f84 <__sinit>
 8027ec4:	4b0c      	ldr	r3, [pc, #48]	; (8027ef8 <_fflush_r+0x48>)
 8027ec6:	429c      	cmp	r4, r3
 8027ec8:	d109      	bne.n	8027ede <_fflush_r+0x2e>
 8027eca:	686c      	ldr	r4, [r5, #4]
 8027ecc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8027ed0:	b17b      	cbz	r3, 8027ef2 <_fflush_r+0x42>
 8027ed2:	4621      	mov	r1, r4
 8027ed4:	4628      	mov	r0, r5
 8027ed6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8027eda:	f7ff bf63 	b.w	8027da4 <__sflush_r>
 8027ede:	4b07      	ldr	r3, [pc, #28]	; (8027efc <_fflush_r+0x4c>)
 8027ee0:	429c      	cmp	r4, r3
 8027ee2:	d101      	bne.n	8027ee8 <_fflush_r+0x38>
 8027ee4:	68ac      	ldr	r4, [r5, #8]
 8027ee6:	e7f1      	b.n	8027ecc <_fflush_r+0x1c>
 8027ee8:	4b05      	ldr	r3, [pc, #20]	; (8027f00 <_fflush_r+0x50>)
 8027eea:	429c      	cmp	r4, r3
 8027eec:	bf08      	it	eq
 8027eee:	68ec      	ldreq	r4, [r5, #12]
 8027ef0:	e7ec      	b.n	8027ecc <_fflush_r+0x1c>
 8027ef2:	2000      	movs	r0, #0
 8027ef4:	bd38      	pop	{r3, r4, r5, pc}
 8027ef6:	bf00      	nop
 8027ef8:	08030f40 	.word	0x08030f40
 8027efc:	08030f60 	.word	0x08030f60
 8027f00:	08030f20 	.word	0x08030f20

08027f04 <std>:
 8027f04:	2300      	movs	r3, #0
 8027f06:	b510      	push	{r4, lr}
 8027f08:	4604      	mov	r4, r0
 8027f0a:	e9c0 3300 	strd	r3, r3, [r0]
 8027f0e:	6083      	str	r3, [r0, #8]
 8027f10:	8181      	strh	r1, [r0, #12]
 8027f12:	6643      	str	r3, [r0, #100]	; 0x64
 8027f14:	81c2      	strh	r2, [r0, #14]
 8027f16:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8027f1a:	6183      	str	r3, [r0, #24]
 8027f1c:	4619      	mov	r1, r3
 8027f1e:	2208      	movs	r2, #8
 8027f20:	305c      	adds	r0, #92	; 0x5c
 8027f22:	f7ff fdce 	bl	8027ac2 <memset>
 8027f26:	4b05      	ldr	r3, [pc, #20]	; (8027f3c <std+0x38>)
 8027f28:	6263      	str	r3, [r4, #36]	; 0x24
 8027f2a:	4b05      	ldr	r3, [pc, #20]	; (8027f40 <std+0x3c>)
 8027f2c:	62a3      	str	r3, [r4, #40]	; 0x28
 8027f2e:	4b05      	ldr	r3, [pc, #20]	; (8027f44 <std+0x40>)
 8027f30:	62e3      	str	r3, [r4, #44]	; 0x2c
 8027f32:	4b05      	ldr	r3, [pc, #20]	; (8027f48 <std+0x44>)
 8027f34:	6224      	str	r4, [r4, #32]
 8027f36:	6323      	str	r3, [r4, #48]	; 0x30
 8027f38:	bd10      	pop	{r4, pc}
 8027f3a:	bf00      	nop
 8027f3c:	08027b2d 	.word	0x08027b2d
 8027f40:	08027b4f 	.word	0x08027b4f
 8027f44:	08027b87 	.word	0x08027b87
 8027f48:	08027bab 	.word	0x08027bab

08027f4c <_cleanup_r>:
 8027f4c:	4901      	ldr	r1, [pc, #4]	; (8027f54 <_cleanup_r+0x8>)
 8027f4e:	f000 b885 	b.w	802805c <_fwalk_reent>
 8027f52:	bf00      	nop
 8027f54:	08027eb1 	.word	0x08027eb1

08027f58 <__sfmoreglue>:
 8027f58:	b570      	push	{r4, r5, r6, lr}
 8027f5a:	1e4a      	subs	r2, r1, #1
 8027f5c:	2568      	movs	r5, #104	; 0x68
 8027f5e:	4355      	muls	r5, r2
 8027f60:	460e      	mov	r6, r1
 8027f62:	f105 0174 	add.w	r1, r5, #116	; 0x74
 8027f66:	f000 f95b 	bl	8028220 <_malloc_r>
 8027f6a:	4604      	mov	r4, r0
 8027f6c:	b140      	cbz	r0, 8027f80 <__sfmoreglue+0x28>
 8027f6e:	2100      	movs	r1, #0
 8027f70:	e9c0 1600 	strd	r1, r6, [r0]
 8027f74:	300c      	adds	r0, #12
 8027f76:	60a0      	str	r0, [r4, #8]
 8027f78:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8027f7c:	f7ff fda1 	bl	8027ac2 <memset>
 8027f80:	4620      	mov	r0, r4
 8027f82:	bd70      	pop	{r4, r5, r6, pc}

08027f84 <__sinit>:
 8027f84:	6983      	ldr	r3, [r0, #24]
 8027f86:	b510      	push	{r4, lr}
 8027f88:	4604      	mov	r4, r0
 8027f8a:	bb33      	cbnz	r3, 8027fda <__sinit+0x56>
 8027f8c:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 8027f90:	6503      	str	r3, [r0, #80]	; 0x50
 8027f92:	4b12      	ldr	r3, [pc, #72]	; (8027fdc <__sinit+0x58>)
 8027f94:	4a12      	ldr	r2, [pc, #72]	; (8027fe0 <__sinit+0x5c>)
 8027f96:	681b      	ldr	r3, [r3, #0]
 8027f98:	6282      	str	r2, [r0, #40]	; 0x28
 8027f9a:	4298      	cmp	r0, r3
 8027f9c:	bf04      	itt	eq
 8027f9e:	2301      	moveq	r3, #1
 8027fa0:	6183      	streq	r3, [r0, #24]
 8027fa2:	f000 f81f 	bl	8027fe4 <__sfp>
 8027fa6:	6060      	str	r0, [r4, #4]
 8027fa8:	4620      	mov	r0, r4
 8027faa:	f000 f81b 	bl	8027fe4 <__sfp>
 8027fae:	60a0      	str	r0, [r4, #8]
 8027fb0:	4620      	mov	r0, r4
 8027fb2:	f000 f817 	bl	8027fe4 <__sfp>
 8027fb6:	2200      	movs	r2, #0
 8027fb8:	60e0      	str	r0, [r4, #12]
 8027fba:	2104      	movs	r1, #4
 8027fbc:	6860      	ldr	r0, [r4, #4]
 8027fbe:	f7ff ffa1 	bl	8027f04 <std>
 8027fc2:	2201      	movs	r2, #1
 8027fc4:	2109      	movs	r1, #9
 8027fc6:	68a0      	ldr	r0, [r4, #8]
 8027fc8:	f7ff ff9c 	bl	8027f04 <std>
 8027fcc:	2202      	movs	r2, #2
 8027fce:	2112      	movs	r1, #18
 8027fd0:	68e0      	ldr	r0, [r4, #12]
 8027fd2:	f7ff ff97 	bl	8027f04 <std>
 8027fd6:	2301      	movs	r3, #1
 8027fd8:	61a3      	str	r3, [r4, #24]
 8027fda:	bd10      	pop	{r4, pc}
 8027fdc:	08030f1c 	.word	0x08030f1c
 8027fe0:	08027f4d 	.word	0x08027f4d

08027fe4 <__sfp>:
 8027fe4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8027fe6:	4b1b      	ldr	r3, [pc, #108]	; (8028054 <__sfp+0x70>)
 8027fe8:	681e      	ldr	r6, [r3, #0]
 8027fea:	69b3      	ldr	r3, [r6, #24]
 8027fec:	4607      	mov	r7, r0
 8027fee:	b913      	cbnz	r3, 8027ff6 <__sfp+0x12>
 8027ff0:	4630      	mov	r0, r6
 8027ff2:	f7ff ffc7 	bl	8027f84 <__sinit>
 8027ff6:	3648      	adds	r6, #72	; 0x48
 8027ff8:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 8027ffc:	3b01      	subs	r3, #1
 8027ffe:	d503      	bpl.n	8028008 <__sfp+0x24>
 8028000:	6833      	ldr	r3, [r6, #0]
 8028002:	b133      	cbz	r3, 8028012 <__sfp+0x2e>
 8028004:	6836      	ldr	r6, [r6, #0]
 8028006:	e7f7      	b.n	8027ff8 <__sfp+0x14>
 8028008:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 802800c:	b16d      	cbz	r5, 802802a <__sfp+0x46>
 802800e:	3468      	adds	r4, #104	; 0x68
 8028010:	e7f4      	b.n	8027ffc <__sfp+0x18>
 8028012:	2104      	movs	r1, #4
 8028014:	4638      	mov	r0, r7
 8028016:	f7ff ff9f 	bl	8027f58 <__sfmoreglue>
 802801a:	6030      	str	r0, [r6, #0]
 802801c:	2800      	cmp	r0, #0
 802801e:	d1f1      	bne.n	8028004 <__sfp+0x20>
 8028020:	230c      	movs	r3, #12
 8028022:	603b      	str	r3, [r7, #0]
 8028024:	4604      	mov	r4, r0
 8028026:	4620      	mov	r0, r4
 8028028:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802802a:	4b0b      	ldr	r3, [pc, #44]	; (8028058 <__sfp+0x74>)
 802802c:	6665      	str	r5, [r4, #100]	; 0x64
 802802e:	e9c4 5500 	strd	r5, r5, [r4]
 8028032:	60a5      	str	r5, [r4, #8]
 8028034:	e9c4 3503 	strd	r3, r5, [r4, #12]
 8028038:	e9c4 5505 	strd	r5, r5, [r4, #20]
 802803c:	2208      	movs	r2, #8
 802803e:	4629      	mov	r1, r5
 8028040:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8028044:	f7ff fd3d 	bl	8027ac2 <memset>
 8028048:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 802804c:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 8028050:	e7e9      	b.n	8028026 <__sfp+0x42>
 8028052:	bf00      	nop
 8028054:	08030f1c 	.word	0x08030f1c
 8028058:	ffff0001 	.word	0xffff0001

0802805c <_fwalk_reent>:
 802805c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8028060:	4680      	mov	r8, r0
 8028062:	4689      	mov	r9, r1
 8028064:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8028068:	2600      	movs	r6, #0
 802806a:	b914      	cbnz	r4, 8028072 <_fwalk_reent+0x16>
 802806c:	4630      	mov	r0, r6
 802806e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8028072:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 8028076:	3f01      	subs	r7, #1
 8028078:	d501      	bpl.n	802807e <_fwalk_reent+0x22>
 802807a:	6824      	ldr	r4, [r4, #0]
 802807c:	e7f5      	b.n	802806a <_fwalk_reent+0xe>
 802807e:	89ab      	ldrh	r3, [r5, #12]
 8028080:	2b01      	cmp	r3, #1
 8028082:	d907      	bls.n	8028094 <_fwalk_reent+0x38>
 8028084:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8028088:	3301      	adds	r3, #1
 802808a:	d003      	beq.n	8028094 <_fwalk_reent+0x38>
 802808c:	4629      	mov	r1, r5
 802808e:	4640      	mov	r0, r8
 8028090:	47c8      	blx	r9
 8028092:	4306      	orrs	r6, r0
 8028094:	3568      	adds	r5, #104	; 0x68
 8028096:	e7ee      	b.n	8028076 <_fwalk_reent+0x1a>

08028098 <_lseek_r>:
 8028098:	b538      	push	{r3, r4, r5, lr}
 802809a:	4c07      	ldr	r4, [pc, #28]	; (80280b8 <_lseek_r+0x20>)
 802809c:	4605      	mov	r5, r0
 802809e:	4608      	mov	r0, r1
 80280a0:	4611      	mov	r1, r2
 80280a2:	2200      	movs	r2, #0
 80280a4:	6022      	str	r2, [r4, #0]
 80280a6:	461a      	mov	r2, r3
 80280a8:	f7d8 ffbe 	bl	8001028 <_lseek>
 80280ac:	1c43      	adds	r3, r0, #1
 80280ae:	d102      	bne.n	80280b6 <_lseek_r+0x1e>
 80280b0:	6823      	ldr	r3, [r4, #0]
 80280b2:	b103      	cbz	r3, 80280b6 <_lseek_r+0x1e>
 80280b4:	602b      	str	r3, [r5, #0]
 80280b6:	bd38      	pop	{r3, r4, r5, pc}
 80280b8:	2000a72c 	.word	0x2000a72c

080280bc <__swhatbuf_r>:
 80280bc:	b570      	push	{r4, r5, r6, lr}
 80280be:	460e      	mov	r6, r1
 80280c0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80280c4:	2900      	cmp	r1, #0
 80280c6:	b096      	sub	sp, #88	; 0x58
 80280c8:	4614      	mov	r4, r2
 80280ca:	461d      	mov	r5, r3
 80280cc:	da07      	bge.n	80280de <__swhatbuf_r+0x22>
 80280ce:	2300      	movs	r3, #0
 80280d0:	602b      	str	r3, [r5, #0]
 80280d2:	89b3      	ldrh	r3, [r6, #12]
 80280d4:	061a      	lsls	r2, r3, #24
 80280d6:	d410      	bmi.n	80280fa <__swhatbuf_r+0x3e>
 80280d8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80280dc:	e00e      	b.n	80280fc <__swhatbuf_r+0x40>
 80280de:	466a      	mov	r2, sp
 80280e0:	f000 fc18 	bl	8028914 <_fstat_r>
 80280e4:	2800      	cmp	r0, #0
 80280e6:	dbf2      	blt.n	80280ce <__swhatbuf_r+0x12>
 80280e8:	9a01      	ldr	r2, [sp, #4]
 80280ea:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 80280ee:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 80280f2:	425a      	negs	r2, r3
 80280f4:	415a      	adcs	r2, r3
 80280f6:	602a      	str	r2, [r5, #0]
 80280f8:	e7ee      	b.n	80280d8 <__swhatbuf_r+0x1c>
 80280fa:	2340      	movs	r3, #64	; 0x40
 80280fc:	2000      	movs	r0, #0
 80280fe:	6023      	str	r3, [r4, #0]
 8028100:	b016      	add	sp, #88	; 0x58
 8028102:	bd70      	pop	{r4, r5, r6, pc}

08028104 <__smakebuf_r>:
 8028104:	898b      	ldrh	r3, [r1, #12]
 8028106:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8028108:	079d      	lsls	r5, r3, #30
 802810a:	4606      	mov	r6, r0
 802810c:	460c      	mov	r4, r1
 802810e:	d507      	bpl.n	8028120 <__smakebuf_r+0x1c>
 8028110:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8028114:	6023      	str	r3, [r4, #0]
 8028116:	6123      	str	r3, [r4, #16]
 8028118:	2301      	movs	r3, #1
 802811a:	6163      	str	r3, [r4, #20]
 802811c:	b002      	add	sp, #8
 802811e:	bd70      	pop	{r4, r5, r6, pc}
 8028120:	ab01      	add	r3, sp, #4
 8028122:	466a      	mov	r2, sp
 8028124:	f7ff ffca 	bl	80280bc <__swhatbuf_r>
 8028128:	9900      	ldr	r1, [sp, #0]
 802812a:	4605      	mov	r5, r0
 802812c:	4630      	mov	r0, r6
 802812e:	f000 f877 	bl	8028220 <_malloc_r>
 8028132:	b948      	cbnz	r0, 8028148 <__smakebuf_r+0x44>
 8028134:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8028138:	059a      	lsls	r2, r3, #22
 802813a:	d4ef      	bmi.n	802811c <__smakebuf_r+0x18>
 802813c:	f023 0303 	bic.w	r3, r3, #3
 8028140:	f043 0302 	orr.w	r3, r3, #2
 8028144:	81a3      	strh	r3, [r4, #12]
 8028146:	e7e3      	b.n	8028110 <__smakebuf_r+0xc>
 8028148:	4b0d      	ldr	r3, [pc, #52]	; (8028180 <__smakebuf_r+0x7c>)
 802814a:	62b3      	str	r3, [r6, #40]	; 0x28
 802814c:	89a3      	ldrh	r3, [r4, #12]
 802814e:	6020      	str	r0, [r4, #0]
 8028150:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8028154:	81a3      	strh	r3, [r4, #12]
 8028156:	9b00      	ldr	r3, [sp, #0]
 8028158:	6163      	str	r3, [r4, #20]
 802815a:	9b01      	ldr	r3, [sp, #4]
 802815c:	6120      	str	r0, [r4, #16]
 802815e:	b15b      	cbz	r3, 8028178 <__smakebuf_r+0x74>
 8028160:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8028164:	4630      	mov	r0, r6
 8028166:	f000 fbe7 	bl	8028938 <_isatty_r>
 802816a:	b128      	cbz	r0, 8028178 <__smakebuf_r+0x74>
 802816c:	89a3      	ldrh	r3, [r4, #12]
 802816e:	f023 0303 	bic.w	r3, r3, #3
 8028172:	f043 0301 	orr.w	r3, r3, #1
 8028176:	81a3      	strh	r3, [r4, #12]
 8028178:	89a3      	ldrh	r3, [r4, #12]
 802817a:	431d      	orrs	r5, r3
 802817c:	81a5      	strh	r5, [r4, #12]
 802817e:	e7cd      	b.n	802811c <__smakebuf_r+0x18>
 8028180:	08027f4d 	.word	0x08027f4d

08028184 <_free_r>:
 8028184:	b538      	push	{r3, r4, r5, lr}
 8028186:	4605      	mov	r5, r0
 8028188:	2900      	cmp	r1, #0
 802818a:	d045      	beq.n	8028218 <_free_r+0x94>
 802818c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8028190:	1f0c      	subs	r4, r1, #4
 8028192:	2b00      	cmp	r3, #0
 8028194:	bfb8      	it	lt
 8028196:	18e4      	addlt	r4, r4, r3
 8028198:	f000 fbde 	bl	8028958 <__malloc_lock>
 802819c:	4a1f      	ldr	r2, [pc, #124]	; (802821c <_free_r+0x98>)
 802819e:	6813      	ldr	r3, [r2, #0]
 80281a0:	4610      	mov	r0, r2
 80281a2:	b933      	cbnz	r3, 80281b2 <_free_r+0x2e>
 80281a4:	6063      	str	r3, [r4, #4]
 80281a6:	6014      	str	r4, [r2, #0]
 80281a8:	4628      	mov	r0, r5
 80281aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80281ae:	f000 bbd4 	b.w	802895a <__malloc_unlock>
 80281b2:	42a3      	cmp	r3, r4
 80281b4:	d90c      	bls.n	80281d0 <_free_r+0x4c>
 80281b6:	6821      	ldr	r1, [r4, #0]
 80281b8:	1862      	adds	r2, r4, r1
 80281ba:	4293      	cmp	r3, r2
 80281bc:	bf04      	itt	eq
 80281be:	681a      	ldreq	r2, [r3, #0]
 80281c0:	685b      	ldreq	r3, [r3, #4]
 80281c2:	6063      	str	r3, [r4, #4]
 80281c4:	bf04      	itt	eq
 80281c6:	1852      	addeq	r2, r2, r1
 80281c8:	6022      	streq	r2, [r4, #0]
 80281ca:	6004      	str	r4, [r0, #0]
 80281cc:	e7ec      	b.n	80281a8 <_free_r+0x24>
 80281ce:	4613      	mov	r3, r2
 80281d0:	685a      	ldr	r2, [r3, #4]
 80281d2:	b10a      	cbz	r2, 80281d8 <_free_r+0x54>
 80281d4:	42a2      	cmp	r2, r4
 80281d6:	d9fa      	bls.n	80281ce <_free_r+0x4a>
 80281d8:	6819      	ldr	r1, [r3, #0]
 80281da:	1858      	adds	r0, r3, r1
 80281dc:	42a0      	cmp	r0, r4
 80281de:	d10b      	bne.n	80281f8 <_free_r+0x74>
 80281e0:	6820      	ldr	r0, [r4, #0]
 80281e2:	4401      	add	r1, r0
 80281e4:	1858      	adds	r0, r3, r1
 80281e6:	4282      	cmp	r2, r0
 80281e8:	6019      	str	r1, [r3, #0]
 80281ea:	d1dd      	bne.n	80281a8 <_free_r+0x24>
 80281ec:	6810      	ldr	r0, [r2, #0]
 80281ee:	6852      	ldr	r2, [r2, #4]
 80281f0:	605a      	str	r2, [r3, #4]
 80281f2:	4401      	add	r1, r0
 80281f4:	6019      	str	r1, [r3, #0]
 80281f6:	e7d7      	b.n	80281a8 <_free_r+0x24>
 80281f8:	d902      	bls.n	8028200 <_free_r+0x7c>
 80281fa:	230c      	movs	r3, #12
 80281fc:	602b      	str	r3, [r5, #0]
 80281fe:	e7d3      	b.n	80281a8 <_free_r+0x24>
 8028200:	6820      	ldr	r0, [r4, #0]
 8028202:	1821      	adds	r1, r4, r0
 8028204:	428a      	cmp	r2, r1
 8028206:	bf04      	itt	eq
 8028208:	6811      	ldreq	r1, [r2, #0]
 802820a:	6852      	ldreq	r2, [r2, #4]
 802820c:	6062      	str	r2, [r4, #4]
 802820e:	bf04      	itt	eq
 8028210:	1809      	addeq	r1, r1, r0
 8028212:	6021      	streq	r1, [r4, #0]
 8028214:	605c      	str	r4, [r3, #4]
 8028216:	e7c7      	b.n	80281a8 <_free_r+0x24>
 8028218:	bd38      	pop	{r3, r4, r5, pc}
 802821a:	bf00      	nop
 802821c:	2000a38c 	.word	0x2000a38c

08028220 <_malloc_r>:
 8028220:	b570      	push	{r4, r5, r6, lr}
 8028222:	1ccd      	adds	r5, r1, #3
 8028224:	f025 0503 	bic.w	r5, r5, #3
 8028228:	3508      	adds	r5, #8
 802822a:	2d0c      	cmp	r5, #12
 802822c:	bf38      	it	cc
 802822e:	250c      	movcc	r5, #12
 8028230:	2d00      	cmp	r5, #0
 8028232:	4606      	mov	r6, r0
 8028234:	db01      	blt.n	802823a <_malloc_r+0x1a>
 8028236:	42a9      	cmp	r1, r5
 8028238:	d903      	bls.n	8028242 <_malloc_r+0x22>
 802823a:	230c      	movs	r3, #12
 802823c:	6033      	str	r3, [r6, #0]
 802823e:	2000      	movs	r0, #0
 8028240:	bd70      	pop	{r4, r5, r6, pc}
 8028242:	f000 fb89 	bl	8028958 <__malloc_lock>
 8028246:	4a21      	ldr	r2, [pc, #132]	; (80282cc <_malloc_r+0xac>)
 8028248:	6814      	ldr	r4, [r2, #0]
 802824a:	4621      	mov	r1, r4
 802824c:	b991      	cbnz	r1, 8028274 <_malloc_r+0x54>
 802824e:	4c20      	ldr	r4, [pc, #128]	; (80282d0 <_malloc_r+0xb0>)
 8028250:	6823      	ldr	r3, [r4, #0]
 8028252:	b91b      	cbnz	r3, 802825c <_malloc_r+0x3c>
 8028254:	4630      	mov	r0, r6
 8028256:	f000 fb4d 	bl	80288f4 <_sbrk_r>
 802825a:	6020      	str	r0, [r4, #0]
 802825c:	4629      	mov	r1, r5
 802825e:	4630      	mov	r0, r6
 8028260:	f000 fb48 	bl	80288f4 <_sbrk_r>
 8028264:	1c43      	adds	r3, r0, #1
 8028266:	d124      	bne.n	80282b2 <_malloc_r+0x92>
 8028268:	230c      	movs	r3, #12
 802826a:	6033      	str	r3, [r6, #0]
 802826c:	4630      	mov	r0, r6
 802826e:	f000 fb74 	bl	802895a <__malloc_unlock>
 8028272:	e7e4      	b.n	802823e <_malloc_r+0x1e>
 8028274:	680b      	ldr	r3, [r1, #0]
 8028276:	1b5b      	subs	r3, r3, r5
 8028278:	d418      	bmi.n	80282ac <_malloc_r+0x8c>
 802827a:	2b0b      	cmp	r3, #11
 802827c:	d90f      	bls.n	802829e <_malloc_r+0x7e>
 802827e:	600b      	str	r3, [r1, #0]
 8028280:	50cd      	str	r5, [r1, r3]
 8028282:	18cc      	adds	r4, r1, r3
 8028284:	4630      	mov	r0, r6
 8028286:	f000 fb68 	bl	802895a <__malloc_unlock>
 802828a:	f104 000b 	add.w	r0, r4, #11
 802828e:	1d23      	adds	r3, r4, #4
 8028290:	f020 0007 	bic.w	r0, r0, #7
 8028294:	1ac3      	subs	r3, r0, r3
 8028296:	d0d3      	beq.n	8028240 <_malloc_r+0x20>
 8028298:	425a      	negs	r2, r3
 802829a:	50e2      	str	r2, [r4, r3]
 802829c:	e7d0      	b.n	8028240 <_malloc_r+0x20>
 802829e:	428c      	cmp	r4, r1
 80282a0:	684b      	ldr	r3, [r1, #4]
 80282a2:	bf16      	itet	ne
 80282a4:	6063      	strne	r3, [r4, #4]
 80282a6:	6013      	streq	r3, [r2, #0]
 80282a8:	460c      	movne	r4, r1
 80282aa:	e7eb      	b.n	8028284 <_malloc_r+0x64>
 80282ac:	460c      	mov	r4, r1
 80282ae:	6849      	ldr	r1, [r1, #4]
 80282b0:	e7cc      	b.n	802824c <_malloc_r+0x2c>
 80282b2:	1cc4      	adds	r4, r0, #3
 80282b4:	f024 0403 	bic.w	r4, r4, #3
 80282b8:	42a0      	cmp	r0, r4
 80282ba:	d005      	beq.n	80282c8 <_malloc_r+0xa8>
 80282bc:	1a21      	subs	r1, r4, r0
 80282be:	4630      	mov	r0, r6
 80282c0:	f000 fb18 	bl	80288f4 <_sbrk_r>
 80282c4:	3001      	adds	r0, #1
 80282c6:	d0cf      	beq.n	8028268 <_malloc_r+0x48>
 80282c8:	6025      	str	r5, [r4, #0]
 80282ca:	e7db      	b.n	8028284 <_malloc_r+0x64>
 80282cc:	2000a38c 	.word	0x2000a38c
 80282d0:	2000a390 	.word	0x2000a390

080282d4 <__sfputc_r>:
 80282d4:	6893      	ldr	r3, [r2, #8]
 80282d6:	3b01      	subs	r3, #1
 80282d8:	2b00      	cmp	r3, #0
 80282da:	b410      	push	{r4}
 80282dc:	6093      	str	r3, [r2, #8]
 80282de:	da08      	bge.n	80282f2 <__sfputc_r+0x1e>
 80282e0:	6994      	ldr	r4, [r2, #24]
 80282e2:	42a3      	cmp	r3, r4
 80282e4:	db01      	blt.n	80282ea <__sfputc_r+0x16>
 80282e6:	290a      	cmp	r1, #10
 80282e8:	d103      	bne.n	80282f2 <__sfputc_r+0x1e>
 80282ea:	f85d 4b04 	ldr.w	r4, [sp], #4
 80282ee:	f7ff bc77 	b.w	8027be0 <__swbuf_r>
 80282f2:	6813      	ldr	r3, [r2, #0]
 80282f4:	1c58      	adds	r0, r3, #1
 80282f6:	6010      	str	r0, [r2, #0]
 80282f8:	7019      	strb	r1, [r3, #0]
 80282fa:	4608      	mov	r0, r1
 80282fc:	f85d 4b04 	ldr.w	r4, [sp], #4
 8028300:	4770      	bx	lr

08028302 <__sfputs_r>:
 8028302:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028304:	4606      	mov	r6, r0
 8028306:	460f      	mov	r7, r1
 8028308:	4614      	mov	r4, r2
 802830a:	18d5      	adds	r5, r2, r3
 802830c:	42ac      	cmp	r4, r5
 802830e:	d101      	bne.n	8028314 <__sfputs_r+0x12>
 8028310:	2000      	movs	r0, #0
 8028312:	e007      	b.n	8028324 <__sfputs_r+0x22>
 8028314:	463a      	mov	r2, r7
 8028316:	f814 1b01 	ldrb.w	r1, [r4], #1
 802831a:	4630      	mov	r0, r6
 802831c:	f7ff ffda 	bl	80282d4 <__sfputc_r>
 8028320:	1c43      	adds	r3, r0, #1
 8028322:	d1f3      	bne.n	802830c <__sfputs_r+0xa>
 8028324:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08028328 <_vfiprintf_r>:
 8028328:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802832c:	460c      	mov	r4, r1
 802832e:	b09d      	sub	sp, #116	; 0x74
 8028330:	4617      	mov	r7, r2
 8028332:	461d      	mov	r5, r3
 8028334:	4606      	mov	r6, r0
 8028336:	b118      	cbz	r0, 8028340 <_vfiprintf_r+0x18>
 8028338:	6983      	ldr	r3, [r0, #24]
 802833a:	b90b      	cbnz	r3, 8028340 <_vfiprintf_r+0x18>
 802833c:	f7ff fe22 	bl	8027f84 <__sinit>
 8028340:	4b7c      	ldr	r3, [pc, #496]	; (8028534 <_vfiprintf_r+0x20c>)
 8028342:	429c      	cmp	r4, r3
 8028344:	d158      	bne.n	80283f8 <_vfiprintf_r+0xd0>
 8028346:	6874      	ldr	r4, [r6, #4]
 8028348:	89a3      	ldrh	r3, [r4, #12]
 802834a:	0718      	lsls	r0, r3, #28
 802834c:	d55e      	bpl.n	802840c <_vfiprintf_r+0xe4>
 802834e:	6923      	ldr	r3, [r4, #16]
 8028350:	2b00      	cmp	r3, #0
 8028352:	d05b      	beq.n	802840c <_vfiprintf_r+0xe4>
 8028354:	2300      	movs	r3, #0
 8028356:	9309      	str	r3, [sp, #36]	; 0x24
 8028358:	2320      	movs	r3, #32
 802835a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 802835e:	2330      	movs	r3, #48	; 0x30
 8028360:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8028364:	9503      	str	r5, [sp, #12]
 8028366:	f04f 0b01 	mov.w	fp, #1
 802836a:	46b8      	mov	r8, r7
 802836c:	4645      	mov	r5, r8
 802836e:	f815 3b01 	ldrb.w	r3, [r5], #1
 8028372:	b10b      	cbz	r3, 8028378 <_vfiprintf_r+0x50>
 8028374:	2b25      	cmp	r3, #37	; 0x25
 8028376:	d154      	bne.n	8028422 <_vfiprintf_r+0xfa>
 8028378:	ebb8 0a07 	subs.w	sl, r8, r7
 802837c:	d00b      	beq.n	8028396 <_vfiprintf_r+0x6e>
 802837e:	4653      	mov	r3, sl
 8028380:	463a      	mov	r2, r7
 8028382:	4621      	mov	r1, r4
 8028384:	4630      	mov	r0, r6
 8028386:	f7ff ffbc 	bl	8028302 <__sfputs_r>
 802838a:	3001      	adds	r0, #1
 802838c:	f000 80c2 	beq.w	8028514 <_vfiprintf_r+0x1ec>
 8028390:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8028392:	4453      	add	r3, sl
 8028394:	9309      	str	r3, [sp, #36]	; 0x24
 8028396:	f898 3000 	ldrb.w	r3, [r8]
 802839a:	2b00      	cmp	r3, #0
 802839c:	f000 80ba 	beq.w	8028514 <_vfiprintf_r+0x1ec>
 80283a0:	2300      	movs	r3, #0
 80283a2:	f04f 32ff 	mov.w	r2, #4294967295
 80283a6:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80283aa:	9304      	str	r3, [sp, #16]
 80283ac:	9307      	str	r3, [sp, #28]
 80283ae:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 80283b2:	931a      	str	r3, [sp, #104]	; 0x68
 80283b4:	46a8      	mov	r8, r5
 80283b6:	2205      	movs	r2, #5
 80283b8:	f818 1b01 	ldrb.w	r1, [r8], #1
 80283bc:	485e      	ldr	r0, [pc, #376]	; (8028538 <_vfiprintf_r+0x210>)
 80283be:	f7d7 ff17 	bl	80001f0 <memchr>
 80283c2:	9b04      	ldr	r3, [sp, #16]
 80283c4:	bb78      	cbnz	r0, 8028426 <_vfiprintf_r+0xfe>
 80283c6:	06d9      	lsls	r1, r3, #27
 80283c8:	bf44      	itt	mi
 80283ca:	2220      	movmi	r2, #32
 80283cc:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 80283d0:	071a      	lsls	r2, r3, #28
 80283d2:	bf44      	itt	mi
 80283d4:	222b      	movmi	r2, #43	; 0x2b
 80283d6:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 80283da:	782a      	ldrb	r2, [r5, #0]
 80283dc:	2a2a      	cmp	r2, #42	; 0x2a
 80283de:	d02a      	beq.n	8028436 <_vfiprintf_r+0x10e>
 80283e0:	9a07      	ldr	r2, [sp, #28]
 80283e2:	46a8      	mov	r8, r5
 80283e4:	2000      	movs	r0, #0
 80283e6:	250a      	movs	r5, #10
 80283e8:	4641      	mov	r1, r8
 80283ea:	f811 3b01 	ldrb.w	r3, [r1], #1
 80283ee:	3b30      	subs	r3, #48	; 0x30
 80283f0:	2b09      	cmp	r3, #9
 80283f2:	d969      	bls.n	80284c8 <_vfiprintf_r+0x1a0>
 80283f4:	b360      	cbz	r0, 8028450 <_vfiprintf_r+0x128>
 80283f6:	e024      	b.n	8028442 <_vfiprintf_r+0x11a>
 80283f8:	4b50      	ldr	r3, [pc, #320]	; (802853c <_vfiprintf_r+0x214>)
 80283fa:	429c      	cmp	r4, r3
 80283fc:	d101      	bne.n	8028402 <_vfiprintf_r+0xda>
 80283fe:	68b4      	ldr	r4, [r6, #8]
 8028400:	e7a2      	b.n	8028348 <_vfiprintf_r+0x20>
 8028402:	4b4f      	ldr	r3, [pc, #316]	; (8028540 <_vfiprintf_r+0x218>)
 8028404:	429c      	cmp	r4, r3
 8028406:	bf08      	it	eq
 8028408:	68f4      	ldreq	r4, [r6, #12]
 802840a:	e79d      	b.n	8028348 <_vfiprintf_r+0x20>
 802840c:	4621      	mov	r1, r4
 802840e:	4630      	mov	r0, r6
 8028410:	f7ff fc4a 	bl	8027ca8 <__swsetup_r>
 8028414:	2800      	cmp	r0, #0
 8028416:	d09d      	beq.n	8028354 <_vfiprintf_r+0x2c>
 8028418:	f04f 30ff 	mov.w	r0, #4294967295
 802841c:	b01d      	add	sp, #116	; 0x74
 802841e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028422:	46a8      	mov	r8, r5
 8028424:	e7a2      	b.n	802836c <_vfiprintf_r+0x44>
 8028426:	4a44      	ldr	r2, [pc, #272]	; (8028538 <_vfiprintf_r+0x210>)
 8028428:	1a80      	subs	r0, r0, r2
 802842a:	fa0b f000 	lsl.w	r0, fp, r0
 802842e:	4318      	orrs	r0, r3
 8028430:	9004      	str	r0, [sp, #16]
 8028432:	4645      	mov	r5, r8
 8028434:	e7be      	b.n	80283b4 <_vfiprintf_r+0x8c>
 8028436:	9a03      	ldr	r2, [sp, #12]
 8028438:	1d11      	adds	r1, r2, #4
 802843a:	6812      	ldr	r2, [r2, #0]
 802843c:	9103      	str	r1, [sp, #12]
 802843e:	2a00      	cmp	r2, #0
 8028440:	db01      	blt.n	8028446 <_vfiprintf_r+0x11e>
 8028442:	9207      	str	r2, [sp, #28]
 8028444:	e004      	b.n	8028450 <_vfiprintf_r+0x128>
 8028446:	4252      	negs	r2, r2
 8028448:	f043 0302 	orr.w	r3, r3, #2
 802844c:	9207      	str	r2, [sp, #28]
 802844e:	9304      	str	r3, [sp, #16]
 8028450:	f898 3000 	ldrb.w	r3, [r8]
 8028454:	2b2e      	cmp	r3, #46	; 0x2e
 8028456:	d10e      	bne.n	8028476 <_vfiprintf_r+0x14e>
 8028458:	f898 3001 	ldrb.w	r3, [r8, #1]
 802845c:	2b2a      	cmp	r3, #42	; 0x2a
 802845e:	d138      	bne.n	80284d2 <_vfiprintf_r+0x1aa>
 8028460:	9b03      	ldr	r3, [sp, #12]
 8028462:	1d1a      	adds	r2, r3, #4
 8028464:	681b      	ldr	r3, [r3, #0]
 8028466:	9203      	str	r2, [sp, #12]
 8028468:	2b00      	cmp	r3, #0
 802846a:	bfb8      	it	lt
 802846c:	f04f 33ff 	movlt.w	r3, #4294967295
 8028470:	f108 0802 	add.w	r8, r8, #2
 8028474:	9305      	str	r3, [sp, #20]
 8028476:	4d33      	ldr	r5, [pc, #204]	; (8028544 <_vfiprintf_r+0x21c>)
 8028478:	f898 1000 	ldrb.w	r1, [r8]
 802847c:	2203      	movs	r2, #3
 802847e:	4628      	mov	r0, r5
 8028480:	f7d7 feb6 	bl	80001f0 <memchr>
 8028484:	b140      	cbz	r0, 8028498 <_vfiprintf_r+0x170>
 8028486:	2340      	movs	r3, #64	; 0x40
 8028488:	1b40      	subs	r0, r0, r5
 802848a:	fa03 f000 	lsl.w	r0, r3, r0
 802848e:	9b04      	ldr	r3, [sp, #16]
 8028490:	4303      	orrs	r3, r0
 8028492:	f108 0801 	add.w	r8, r8, #1
 8028496:	9304      	str	r3, [sp, #16]
 8028498:	f898 1000 	ldrb.w	r1, [r8]
 802849c:	482a      	ldr	r0, [pc, #168]	; (8028548 <_vfiprintf_r+0x220>)
 802849e:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 80284a2:	2206      	movs	r2, #6
 80284a4:	f108 0701 	add.w	r7, r8, #1
 80284a8:	f7d7 fea2 	bl	80001f0 <memchr>
 80284ac:	2800      	cmp	r0, #0
 80284ae:	d037      	beq.n	8028520 <_vfiprintf_r+0x1f8>
 80284b0:	4b26      	ldr	r3, [pc, #152]	; (802854c <_vfiprintf_r+0x224>)
 80284b2:	bb1b      	cbnz	r3, 80284fc <_vfiprintf_r+0x1d4>
 80284b4:	9b03      	ldr	r3, [sp, #12]
 80284b6:	3307      	adds	r3, #7
 80284b8:	f023 0307 	bic.w	r3, r3, #7
 80284bc:	3308      	adds	r3, #8
 80284be:	9303      	str	r3, [sp, #12]
 80284c0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80284c2:	444b      	add	r3, r9
 80284c4:	9309      	str	r3, [sp, #36]	; 0x24
 80284c6:	e750      	b.n	802836a <_vfiprintf_r+0x42>
 80284c8:	fb05 3202 	mla	r2, r5, r2, r3
 80284cc:	2001      	movs	r0, #1
 80284ce:	4688      	mov	r8, r1
 80284d0:	e78a      	b.n	80283e8 <_vfiprintf_r+0xc0>
 80284d2:	2300      	movs	r3, #0
 80284d4:	f108 0801 	add.w	r8, r8, #1
 80284d8:	9305      	str	r3, [sp, #20]
 80284da:	4619      	mov	r1, r3
 80284dc:	250a      	movs	r5, #10
 80284de:	4640      	mov	r0, r8
 80284e0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80284e4:	3a30      	subs	r2, #48	; 0x30
 80284e6:	2a09      	cmp	r2, #9
 80284e8:	d903      	bls.n	80284f2 <_vfiprintf_r+0x1ca>
 80284ea:	2b00      	cmp	r3, #0
 80284ec:	d0c3      	beq.n	8028476 <_vfiprintf_r+0x14e>
 80284ee:	9105      	str	r1, [sp, #20]
 80284f0:	e7c1      	b.n	8028476 <_vfiprintf_r+0x14e>
 80284f2:	fb05 2101 	mla	r1, r5, r1, r2
 80284f6:	2301      	movs	r3, #1
 80284f8:	4680      	mov	r8, r0
 80284fa:	e7f0      	b.n	80284de <_vfiprintf_r+0x1b6>
 80284fc:	ab03      	add	r3, sp, #12
 80284fe:	9300      	str	r3, [sp, #0]
 8028500:	4622      	mov	r2, r4
 8028502:	4b13      	ldr	r3, [pc, #76]	; (8028550 <_vfiprintf_r+0x228>)
 8028504:	a904      	add	r1, sp, #16
 8028506:	4630      	mov	r0, r6
 8028508:	f3af 8000 	nop.w
 802850c:	f1b0 3fff 	cmp.w	r0, #4294967295
 8028510:	4681      	mov	r9, r0
 8028512:	d1d5      	bne.n	80284c0 <_vfiprintf_r+0x198>
 8028514:	89a3      	ldrh	r3, [r4, #12]
 8028516:	065b      	lsls	r3, r3, #25
 8028518:	f53f af7e 	bmi.w	8028418 <_vfiprintf_r+0xf0>
 802851c:	9809      	ldr	r0, [sp, #36]	; 0x24
 802851e:	e77d      	b.n	802841c <_vfiprintf_r+0xf4>
 8028520:	ab03      	add	r3, sp, #12
 8028522:	9300      	str	r3, [sp, #0]
 8028524:	4622      	mov	r2, r4
 8028526:	4b0a      	ldr	r3, [pc, #40]	; (8028550 <_vfiprintf_r+0x228>)
 8028528:	a904      	add	r1, sp, #16
 802852a:	4630      	mov	r0, r6
 802852c:	f000 f888 	bl	8028640 <_printf_i>
 8028530:	e7ec      	b.n	802850c <_vfiprintf_r+0x1e4>
 8028532:	bf00      	nop
 8028534:	08030f40 	.word	0x08030f40
 8028538:	08030f80 	.word	0x08030f80
 802853c:	08030f60 	.word	0x08030f60
 8028540:	08030f20 	.word	0x08030f20
 8028544:	08030f86 	.word	0x08030f86
 8028548:	08030f8a 	.word	0x08030f8a
 802854c:	00000000 	.word	0x00000000
 8028550:	08028303 	.word	0x08028303

08028554 <_printf_common>:
 8028554:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028558:	4691      	mov	r9, r2
 802855a:	461f      	mov	r7, r3
 802855c:	688a      	ldr	r2, [r1, #8]
 802855e:	690b      	ldr	r3, [r1, #16]
 8028560:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8028564:	4293      	cmp	r3, r2
 8028566:	bfb8      	it	lt
 8028568:	4613      	movlt	r3, r2
 802856a:	f8c9 3000 	str.w	r3, [r9]
 802856e:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8028572:	4606      	mov	r6, r0
 8028574:	460c      	mov	r4, r1
 8028576:	b112      	cbz	r2, 802857e <_printf_common+0x2a>
 8028578:	3301      	adds	r3, #1
 802857a:	f8c9 3000 	str.w	r3, [r9]
 802857e:	6823      	ldr	r3, [r4, #0]
 8028580:	0699      	lsls	r1, r3, #26
 8028582:	bf42      	ittt	mi
 8028584:	f8d9 3000 	ldrmi.w	r3, [r9]
 8028588:	3302      	addmi	r3, #2
 802858a:	f8c9 3000 	strmi.w	r3, [r9]
 802858e:	6825      	ldr	r5, [r4, #0]
 8028590:	f015 0506 	ands.w	r5, r5, #6
 8028594:	d107      	bne.n	80285a6 <_printf_common+0x52>
 8028596:	f104 0a19 	add.w	sl, r4, #25
 802859a:	68e3      	ldr	r3, [r4, #12]
 802859c:	f8d9 2000 	ldr.w	r2, [r9]
 80285a0:	1a9b      	subs	r3, r3, r2
 80285a2:	42ab      	cmp	r3, r5
 80285a4:	dc28      	bgt.n	80285f8 <_printf_common+0xa4>
 80285a6:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 80285aa:	6822      	ldr	r2, [r4, #0]
 80285ac:	3300      	adds	r3, #0
 80285ae:	bf18      	it	ne
 80285b0:	2301      	movne	r3, #1
 80285b2:	0692      	lsls	r2, r2, #26
 80285b4:	d42d      	bmi.n	8028612 <_printf_common+0xbe>
 80285b6:	f104 0243 	add.w	r2, r4, #67	; 0x43
 80285ba:	4639      	mov	r1, r7
 80285bc:	4630      	mov	r0, r6
 80285be:	47c0      	blx	r8
 80285c0:	3001      	adds	r0, #1
 80285c2:	d020      	beq.n	8028606 <_printf_common+0xb2>
 80285c4:	6823      	ldr	r3, [r4, #0]
 80285c6:	68e5      	ldr	r5, [r4, #12]
 80285c8:	f8d9 2000 	ldr.w	r2, [r9]
 80285cc:	f003 0306 	and.w	r3, r3, #6
 80285d0:	2b04      	cmp	r3, #4
 80285d2:	bf08      	it	eq
 80285d4:	1aad      	subeq	r5, r5, r2
 80285d6:	68a3      	ldr	r3, [r4, #8]
 80285d8:	6922      	ldr	r2, [r4, #16]
 80285da:	bf0c      	ite	eq
 80285dc:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 80285e0:	2500      	movne	r5, #0
 80285e2:	4293      	cmp	r3, r2
 80285e4:	bfc4      	itt	gt
 80285e6:	1a9b      	subgt	r3, r3, r2
 80285e8:	18ed      	addgt	r5, r5, r3
 80285ea:	f04f 0900 	mov.w	r9, #0
 80285ee:	341a      	adds	r4, #26
 80285f0:	454d      	cmp	r5, r9
 80285f2:	d11a      	bne.n	802862a <_printf_common+0xd6>
 80285f4:	2000      	movs	r0, #0
 80285f6:	e008      	b.n	802860a <_printf_common+0xb6>
 80285f8:	2301      	movs	r3, #1
 80285fa:	4652      	mov	r2, sl
 80285fc:	4639      	mov	r1, r7
 80285fe:	4630      	mov	r0, r6
 8028600:	47c0      	blx	r8
 8028602:	3001      	adds	r0, #1
 8028604:	d103      	bne.n	802860e <_printf_common+0xba>
 8028606:	f04f 30ff 	mov.w	r0, #4294967295
 802860a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802860e:	3501      	adds	r5, #1
 8028610:	e7c3      	b.n	802859a <_printf_common+0x46>
 8028612:	18e1      	adds	r1, r4, r3
 8028614:	1c5a      	adds	r2, r3, #1
 8028616:	2030      	movs	r0, #48	; 0x30
 8028618:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 802861c:	4422      	add	r2, r4
 802861e:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8028622:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8028626:	3302      	adds	r3, #2
 8028628:	e7c5      	b.n	80285b6 <_printf_common+0x62>
 802862a:	2301      	movs	r3, #1
 802862c:	4622      	mov	r2, r4
 802862e:	4639      	mov	r1, r7
 8028630:	4630      	mov	r0, r6
 8028632:	47c0      	blx	r8
 8028634:	3001      	adds	r0, #1
 8028636:	d0e6      	beq.n	8028606 <_printf_common+0xb2>
 8028638:	f109 0901 	add.w	r9, r9, #1
 802863c:	e7d8      	b.n	80285f0 <_printf_common+0x9c>
	...

08028640 <_printf_i>:
 8028640:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8028644:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 8028648:	460c      	mov	r4, r1
 802864a:	7e09      	ldrb	r1, [r1, #24]
 802864c:	b085      	sub	sp, #20
 802864e:	296e      	cmp	r1, #110	; 0x6e
 8028650:	4617      	mov	r7, r2
 8028652:	4606      	mov	r6, r0
 8028654:	4698      	mov	r8, r3
 8028656:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8028658:	f000 80b3 	beq.w	80287c2 <_printf_i+0x182>
 802865c:	d822      	bhi.n	80286a4 <_printf_i+0x64>
 802865e:	2963      	cmp	r1, #99	; 0x63
 8028660:	d036      	beq.n	80286d0 <_printf_i+0x90>
 8028662:	d80a      	bhi.n	802867a <_printf_i+0x3a>
 8028664:	2900      	cmp	r1, #0
 8028666:	f000 80b9 	beq.w	80287dc <_printf_i+0x19c>
 802866a:	2958      	cmp	r1, #88	; 0x58
 802866c:	f000 8083 	beq.w	8028776 <_printf_i+0x136>
 8028670:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8028674:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 8028678:	e032      	b.n	80286e0 <_printf_i+0xa0>
 802867a:	2964      	cmp	r1, #100	; 0x64
 802867c:	d001      	beq.n	8028682 <_printf_i+0x42>
 802867e:	2969      	cmp	r1, #105	; 0x69
 8028680:	d1f6      	bne.n	8028670 <_printf_i+0x30>
 8028682:	6820      	ldr	r0, [r4, #0]
 8028684:	6813      	ldr	r3, [r2, #0]
 8028686:	0605      	lsls	r5, r0, #24
 8028688:	f103 0104 	add.w	r1, r3, #4
 802868c:	d52a      	bpl.n	80286e4 <_printf_i+0xa4>
 802868e:	681b      	ldr	r3, [r3, #0]
 8028690:	6011      	str	r1, [r2, #0]
 8028692:	2b00      	cmp	r3, #0
 8028694:	da03      	bge.n	802869e <_printf_i+0x5e>
 8028696:	222d      	movs	r2, #45	; 0x2d
 8028698:	425b      	negs	r3, r3
 802869a:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 802869e:	486f      	ldr	r0, [pc, #444]	; (802885c <_printf_i+0x21c>)
 80286a0:	220a      	movs	r2, #10
 80286a2:	e039      	b.n	8028718 <_printf_i+0xd8>
 80286a4:	2973      	cmp	r1, #115	; 0x73
 80286a6:	f000 809d 	beq.w	80287e4 <_printf_i+0x1a4>
 80286aa:	d808      	bhi.n	80286be <_printf_i+0x7e>
 80286ac:	296f      	cmp	r1, #111	; 0x6f
 80286ae:	d020      	beq.n	80286f2 <_printf_i+0xb2>
 80286b0:	2970      	cmp	r1, #112	; 0x70
 80286b2:	d1dd      	bne.n	8028670 <_printf_i+0x30>
 80286b4:	6823      	ldr	r3, [r4, #0]
 80286b6:	f043 0320 	orr.w	r3, r3, #32
 80286ba:	6023      	str	r3, [r4, #0]
 80286bc:	e003      	b.n	80286c6 <_printf_i+0x86>
 80286be:	2975      	cmp	r1, #117	; 0x75
 80286c0:	d017      	beq.n	80286f2 <_printf_i+0xb2>
 80286c2:	2978      	cmp	r1, #120	; 0x78
 80286c4:	d1d4      	bne.n	8028670 <_printf_i+0x30>
 80286c6:	2378      	movs	r3, #120	; 0x78
 80286c8:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80286cc:	4864      	ldr	r0, [pc, #400]	; (8028860 <_printf_i+0x220>)
 80286ce:	e055      	b.n	802877c <_printf_i+0x13c>
 80286d0:	6813      	ldr	r3, [r2, #0]
 80286d2:	1d19      	adds	r1, r3, #4
 80286d4:	681b      	ldr	r3, [r3, #0]
 80286d6:	6011      	str	r1, [r2, #0]
 80286d8:	f104 0542 	add.w	r5, r4, #66	; 0x42
 80286dc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80286e0:	2301      	movs	r3, #1
 80286e2:	e08c      	b.n	80287fe <_printf_i+0x1be>
 80286e4:	681b      	ldr	r3, [r3, #0]
 80286e6:	6011      	str	r1, [r2, #0]
 80286e8:	f010 0f40 	tst.w	r0, #64	; 0x40
 80286ec:	bf18      	it	ne
 80286ee:	b21b      	sxthne	r3, r3
 80286f0:	e7cf      	b.n	8028692 <_printf_i+0x52>
 80286f2:	6813      	ldr	r3, [r2, #0]
 80286f4:	6825      	ldr	r5, [r4, #0]
 80286f6:	1d18      	adds	r0, r3, #4
 80286f8:	6010      	str	r0, [r2, #0]
 80286fa:	0628      	lsls	r0, r5, #24
 80286fc:	d501      	bpl.n	8028702 <_printf_i+0xc2>
 80286fe:	681b      	ldr	r3, [r3, #0]
 8028700:	e002      	b.n	8028708 <_printf_i+0xc8>
 8028702:	0668      	lsls	r0, r5, #25
 8028704:	d5fb      	bpl.n	80286fe <_printf_i+0xbe>
 8028706:	881b      	ldrh	r3, [r3, #0]
 8028708:	4854      	ldr	r0, [pc, #336]	; (802885c <_printf_i+0x21c>)
 802870a:	296f      	cmp	r1, #111	; 0x6f
 802870c:	bf14      	ite	ne
 802870e:	220a      	movne	r2, #10
 8028710:	2208      	moveq	r2, #8
 8028712:	2100      	movs	r1, #0
 8028714:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8028718:	6865      	ldr	r5, [r4, #4]
 802871a:	60a5      	str	r5, [r4, #8]
 802871c:	2d00      	cmp	r5, #0
 802871e:	f2c0 8095 	blt.w	802884c <_printf_i+0x20c>
 8028722:	6821      	ldr	r1, [r4, #0]
 8028724:	f021 0104 	bic.w	r1, r1, #4
 8028728:	6021      	str	r1, [r4, #0]
 802872a:	2b00      	cmp	r3, #0
 802872c:	d13d      	bne.n	80287aa <_printf_i+0x16a>
 802872e:	2d00      	cmp	r5, #0
 8028730:	f040 808e 	bne.w	8028850 <_printf_i+0x210>
 8028734:	4665      	mov	r5, ip
 8028736:	2a08      	cmp	r2, #8
 8028738:	d10b      	bne.n	8028752 <_printf_i+0x112>
 802873a:	6823      	ldr	r3, [r4, #0]
 802873c:	07db      	lsls	r3, r3, #31
 802873e:	d508      	bpl.n	8028752 <_printf_i+0x112>
 8028740:	6923      	ldr	r3, [r4, #16]
 8028742:	6862      	ldr	r2, [r4, #4]
 8028744:	429a      	cmp	r2, r3
 8028746:	bfde      	ittt	le
 8028748:	2330      	movle	r3, #48	; 0x30
 802874a:	f805 3c01 	strble.w	r3, [r5, #-1]
 802874e:	f105 35ff 	addle.w	r5, r5, #4294967295
 8028752:	ebac 0305 	sub.w	r3, ip, r5
 8028756:	6123      	str	r3, [r4, #16]
 8028758:	f8cd 8000 	str.w	r8, [sp]
 802875c:	463b      	mov	r3, r7
 802875e:	aa03      	add	r2, sp, #12
 8028760:	4621      	mov	r1, r4
 8028762:	4630      	mov	r0, r6
 8028764:	f7ff fef6 	bl	8028554 <_printf_common>
 8028768:	3001      	adds	r0, #1
 802876a:	d14d      	bne.n	8028808 <_printf_i+0x1c8>
 802876c:	f04f 30ff 	mov.w	r0, #4294967295
 8028770:	b005      	add	sp, #20
 8028772:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8028776:	4839      	ldr	r0, [pc, #228]	; (802885c <_printf_i+0x21c>)
 8028778:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 802877c:	6813      	ldr	r3, [r2, #0]
 802877e:	6821      	ldr	r1, [r4, #0]
 8028780:	1d1d      	adds	r5, r3, #4
 8028782:	681b      	ldr	r3, [r3, #0]
 8028784:	6015      	str	r5, [r2, #0]
 8028786:	060a      	lsls	r2, r1, #24
 8028788:	d50b      	bpl.n	80287a2 <_printf_i+0x162>
 802878a:	07ca      	lsls	r2, r1, #31
 802878c:	bf44      	itt	mi
 802878e:	f041 0120 	orrmi.w	r1, r1, #32
 8028792:	6021      	strmi	r1, [r4, #0]
 8028794:	b91b      	cbnz	r3, 802879e <_printf_i+0x15e>
 8028796:	6822      	ldr	r2, [r4, #0]
 8028798:	f022 0220 	bic.w	r2, r2, #32
 802879c:	6022      	str	r2, [r4, #0]
 802879e:	2210      	movs	r2, #16
 80287a0:	e7b7      	b.n	8028712 <_printf_i+0xd2>
 80287a2:	064d      	lsls	r5, r1, #25
 80287a4:	bf48      	it	mi
 80287a6:	b29b      	uxthmi	r3, r3
 80287a8:	e7ef      	b.n	802878a <_printf_i+0x14a>
 80287aa:	4665      	mov	r5, ip
 80287ac:	fbb3 f1f2 	udiv	r1, r3, r2
 80287b0:	fb02 3311 	mls	r3, r2, r1, r3
 80287b4:	5cc3      	ldrb	r3, [r0, r3]
 80287b6:	f805 3d01 	strb.w	r3, [r5, #-1]!
 80287ba:	460b      	mov	r3, r1
 80287bc:	2900      	cmp	r1, #0
 80287be:	d1f5      	bne.n	80287ac <_printf_i+0x16c>
 80287c0:	e7b9      	b.n	8028736 <_printf_i+0xf6>
 80287c2:	6813      	ldr	r3, [r2, #0]
 80287c4:	6825      	ldr	r5, [r4, #0]
 80287c6:	6961      	ldr	r1, [r4, #20]
 80287c8:	1d18      	adds	r0, r3, #4
 80287ca:	6010      	str	r0, [r2, #0]
 80287cc:	0628      	lsls	r0, r5, #24
 80287ce:	681b      	ldr	r3, [r3, #0]
 80287d0:	d501      	bpl.n	80287d6 <_printf_i+0x196>
 80287d2:	6019      	str	r1, [r3, #0]
 80287d4:	e002      	b.n	80287dc <_printf_i+0x19c>
 80287d6:	066a      	lsls	r2, r5, #25
 80287d8:	d5fb      	bpl.n	80287d2 <_printf_i+0x192>
 80287da:	8019      	strh	r1, [r3, #0]
 80287dc:	2300      	movs	r3, #0
 80287de:	6123      	str	r3, [r4, #16]
 80287e0:	4665      	mov	r5, ip
 80287e2:	e7b9      	b.n	8028758 <_printf_i+0x118>
 80287e4:	6813      	ldr	r3, [r2, #0]
 80287e6:	1d19      	adds	r1, r3, #4
 80287e8:	6011      	str	r1, [r2, #0]
 80287ea:	681d      	ldr	r5, [r3, #0]
 80287ec:	6862      	ldr	r2, [r4, #4]
 80287ee:	2100      	movs	r1, #0
 80287f0:	4628      	mov	r0, r5
 80287f2:	f7d7 fcfd 	bl	80001f0 <memchr>
 80287f6:	b108      	cbz	r0, 80287fc <_printf_i+0x1bc>
 80287f8:	1b40      	subs	r0, r0, r5
 80287fa:	6060      	str	r0, [r4, #4]
 80287fc:	6863      	ldr	r3, [r4, #4]
 80287fe:	6123      	str	r3, [r4, #16]
 8028800:	2300      	movs	r3, #0
 8028802:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8028806:	e7a7      	b.n	8028758 <_printf_i+0x118>
 8028808:	6923      	ldr	r3, [r4, #16]
 802880a:	462a      	mov	r2, r5
 802880c:	4639      	mov	r1, r7
 802880e:	4630      	mov	r0, r6
 8028810:	47c0      	blx	r8
 8028812:	3001      	adds	r0, #1
 8028814:	d0aa      	beq.n	802876c <_printf_i+0x12c>
 8028816:	6823      	ldr	r3, [r4, #0]
 8028818:	079b      	lsls	r3, r3, #30
 802881a:	d413      	bmi.n	8028844 <_printf_i+0x204>
 802881c:	68e0      	ldr	r0, [r4, #12]
 802881e:	9b03      	ldr	r3, [sp, #12]
 8028820:	4298      	cmp	r0, r3
 8028822:	bfb8      	it	lt
 8028824:	4618      	movlt	r0, r3
 8028826:	e7a3      	b.n	8028770 <_printf_i+0x130>
 8028828:	2301      	movs	r3, #1
 802882a:	464a      	mov	r2, r9
 802882c:	4639      	mov	r1, r7
 802882e:	4630      	mov	r0, r6
 8028830:	47c0      	blx	r8
 8028832:	3001      	adds	r0, #1
 8028834:	d09a      	beq.n	802876c <_printf_i+0x12c>
 8028836:	3501      	adds	r5, #1
 8028838:	68e3      	ldr	r3, [r4, #12]
 802883a:	9a03      	ldr	r2, [sp, #12]
 802883c:	1a9b      	subs	r3, r3, r2
 802883e:	42ab      	cmp	r3, r5
 8028840:	dcf2      	bgt.n	8028828 <_printf_i+0x1e8>
 8028842:	e7eb      	b.n	802881c <_printf_i+0x1dc>
 8028844:	2500      	movs	r5, #0
 8028846:	f104 0919 	add.w	r9, r4, #25
 802884a:	e7f5      	b.n	8028838 <_printf_i+0x1f8>
 802884c:	2b00      	cmp	r3, #0
 802884e:	d1ac      	bne.n	80287aa <_printf_i+0x16a>
 8028850:	7803      	ldrb	r3, [r0, #0]
 8028852:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8028856:	f104 0542 	add.w	r5, r4, #66	; 0x42
 802885a:	e76c      	b.n	8028736 <_printf_i+0xf6>
 802885c:	08030f91 	.word	0x08030f91
 8028860:	08030fa2 	.word	0x08030fa2

08028864 <_putc_r>:
 8028864:	b570      	push	{r4, r5, r6, lr}
 8028866:	460d      	mov	r5, r1
 8028868:	4614      	mov	r4, r2
 802886a:	4606      	mov	r6, r0
 802886c:	b118      	cbz	r0, 8028876 <_putc_r+0x12>
 802886e:	6983      	ldr	r3, [r0, #24]
 8028870:	b90b      	cbnz	r3, 8028876 <_putc_r+0x12>
 8028872:	f7ff fb87 	bl	8027f84 <__sinit>
 8028876:	4b13      	ldr	r3, [pc, #76]	; (80288c4 <_putc_r+0x60>)
 8028878:	429c      	cmp	r4, r3
 802887a:	d112      	bne.n	80288a2 <_putc_r+0x3e>
 802887c:	6874      	ldr	r4, [r6, #4]
 802887e:	68a3      	ldr	r3, [r4, #8]
 8028880:	3b01      	subs	r3, #1
 8028882:	2b00      	cmp	r3, #0
 8028884:	60a3      	str	r3, [r4, #8]
 8028886:	da16      	bge.n	80288b6 <_putc_r+0x52>
 8028888:	69a2      	ldr	r2, [r4, #24]
 802888a:	4293      	cmp	r3, r2
 802888c:	db02      	blt.n	8028894 <_putc_r+0x30>
 802888e:	b2eb      	uxtb	r3, r5
 8028890:	2b0a      	cmp	r3, #10
 8028892:	d110      	bne.n	80288b6 <_putc_r+0x52>
 8028894:	4622      	mov	r2, r4
 8028896:	4629      	mov	r1, r5
 8028898:	4630      	mov	r0, r6
 802889a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 802889e:	f7ff b99f 	b.w	8027be0 <__swbuf_r>
 80288a2:	4b09      	ldr	r3, [pc, #36]	; (80288c8 <_putc_r+0x64>)
 80288a4:	429c      	cmp	r4, r3
 80288a6:	d101      	bne.n	80288ac <_putc_r+0x48>
 80288a8:	68b4      	ldr	r4, [r6, #8]
 80288aa:	e7e8      	b.n	802887e <_putc_r+0x1a>
 80288ac:	4b07      	ldr	r3, [pc, #28]	; (80288cc <_putc_r+0x68>)
 80288ae:	429c      	cmp	r4, r3
 80288b0:	bf08      	it	eq
 80288b2:	68f4      	ldreq	r4, [r6, #12]
 80288b4:	e7e3      	b.n	802887e <_putc_r+0x1a>
 80288b6:	6823      	ldr	r3, [r4, #0]
 80288b8:	1c5a      	adds	r2, r3, #1
 80288ba:	6022      	str	r2, [r4, #0]
 80288bc:	701d      	strb	r5, [r3, #0]
 80288be:	b2e8      	uxtb	r0, r5
 80288c0:	bd70      	pop	{r4, r5, r6, pc}
 80288c2:	bf00      	nop
 80288c4:	08030f40 	.word	0x08030f40
 80288c8:	08030f60 	.word	0x08030f60
 80288cc:	08030f20 	.word	0x08030f20

080288d0 <_read_r>:
 80288d0:	b538      	push	{r3, r4, r5, lr}
 80288d2:	4c07      	ldr	r4, [pc, #28]	; (80288f0 <_read_r+0x20>)
 80288d4:	4605      	mov	r5, r0
 80288d6:	4608      	mov	r0, r1
 80288d8:	4611      	mov	r1, r2
 80288da:	2200      	movs	r2, #0
 80288dc:	6022      	str	r2, [r4, #0]
 80288de:	461a      	mov	r2, r3
 80288e0:	f7d8 fb42 	bl	8000f68 <_read>
 80288e4:	1c43      	adds	r3, r0, #1
 80288e6:	d102      	bne.n	80288ee <_read_r+0x1e>
 80288e8:	6823      	ldr	r3, [r4, #0]
 80288ea:	b103      	cbz	r3, 80288ee <_read_r+0x1e>
 80288ec:	602b      	str	r3, [r5, #0]
 80288ee:	bd38      	pop	{r3, r4, r5, pc}
 80288f0:	2000a72c 	.word	0x2000a72c

080288f4 <_sbrk_r>:
 80288f4:	b538      	push	{r3, r4, r5, lr}
 80288f6:	4c06      	ldr	r4, [pc, #24]	; (8028910 <_sbrk_r+0x1c>)
 80288f8:	2300      	movs	r3, #0
 80288fa:	4605      	mov	r5, r0
 80288fc:	4608      	mov	r0, r1
 80288fe:	6023      	str	r3, [r4, #0]
 8028900:	f7d8 fba0 	bl	8001044 <_sbrk>
 8028904:	1c43      	adds	r3, r0, #1
 8028906:	d102      	bne.n	802890e <_sbrk_r+0x1a>
 8028908:	6823      	ldr	r3, [r4, #0]
 802890a:	b103      	cbz	r3, 802890e <_sbrk_r+0x1a>
 802890c:	602b      	str	r3, [r5, #0]
 802890e:	bd38      	pop	{r3, r4, r5, pc}
 8028910:	2000a72c 	.word	0x2000a72c

08028914 <_fstat_r>:
 8028914:	b538      	push	{r3, r4, r5, lr}
 8028916:	4c07      	ldr	r4, [pc, #28]	; (8028934 <_fstat_r+0x20>)
 8028918:	2300      	movs	r3, #0
 802891a:	4605      	mov	r5, r0
 802891c:	4608      	mov	r0, r1
 802891e:	4611      	mov	r1, r2
 8028920:	6023      	str	r3, [r4, #0]
 8028922:	f7d8 fb66 	bl	8000ff2 <_fstat>
 8028926:	1c43      	adds	r3, r0, #1
 8028928:	d102      	bne.n	8028930 <_fstat_r+0x1c>
 802892a:	6823      	ldr	r3, [r4, #0]
 802892c:	b103      	cbz	r3, 8028930 <_fstat_r+0x1c>
 802892e:	602b      	str	r3, [r5, #0]
 8028930:	bd38      	pop	{r3, r4, r5, pc}
 8028932:	bf00      	nop
 8028934:	2000a72c 	.word	0x2000a72c

08028938 <_isatty_r>:
 8028938:	b538      	push	{r3, r4, r5, lr}
 802893a:	4c06      	ldr	r4, [pc, #24]	; (8028954 <_isatty_r+0x1c>)
 802893c:	2300      	movs	r3, #0
 802893e:	4605      	mov	r5, r0
 8028940:	4608      	mov	r0, r1
 8028942:	6023      	str	r3, [r4, #0]
 8028944:	f7d8 fb65 	bl	8001012 <_isatty>
 8028948:	1c43      	adds	r3, r0, #1
 802894a:	d102      	bne.n	8028952 <_isatty_r+0x1a>
 802894c:	6823      	ldr	r3, [r4, #0]
 802894e:	b103      	cbz	r3, 8028952 <_isatty_r+0x1a>
 8028950:	602b      	str	r3, [r5, #0]
 8028952:	bd38      	pop	{r3, r4, r5, pc}
 8028954:	2000a72c 	.word	0x2000a72c

08028958 <__malloc_lock>:
 8028958:	4770      	bx	lr

0802895a <__malloc_unlock>:
 802895a:	4770      	bx	lr

0802895c <_init>:
 802895c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802895e:	bf00      	nop
 8028960:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8028962:	bc08      	pop	{r3}
 8028964:	469e      	mov	lr, r3
 8028966:	4770      	bx	lr

08028968 <_fini>:
 8028968:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802896a:	bf00      	nop
 802896c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802896e:	bc08      	pop	{r3}
 8028970:	469e      	mov	lr, r3
 8028972:	4770      	bx	lr
